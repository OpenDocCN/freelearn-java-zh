- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book does not blindly praise microservices. Instead, it’s about how we
    can use their benefits while being able to handle the challenges of building scalable,
    resilient, and manageable microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'As an introduction to this book, the following topics will be covered in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: My way into microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a microservice-based architecture?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges with microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns for handling challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software enablers that can help us handle these challenges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important considerations that aren’t covered in this book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No installations are required for this chapter. However, you may be interested
    in taking a look at the C4 model conventions, [https://c4model.com](https://c4model.com),
    since the illustrations in this chapter are inspired by the C4 model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does not contain any source code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: My way into microservices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first learned about the concept of microservices back in 2014, I realized
    that I had been developing microservices (well, kind of) for a number of years
    without knowing it was microservices I was dealing with. I was involved in a project
    that started in 2009 where we developed a platform based on a set of separated
    features. The platform was delivered to a number of customers that deployed it
    on-premises. To make it easy for customers to pick and choose what features they
    wanted to use from the platform, each feature was developed as an **autonomous
    software component**; that is, it had its own persistent data and only communicated
    with other components using well-defined APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I can’t discuss specific features in this project’s platform, I have
    generalized the names of the components, which are labeled from **Component A**
    to **Component F**. The **composition** of the platform as a set of components
    is illustrated as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The composition of the platform'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: From the illustration, we can also see that each component has its own storage
    for persistent data, and is not sharing databases with other components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Each component is developed using Java and the Spring Framework, packaged as
    a WAR file, and deployed as a web app in a Java EE web container, for example,
    Apache Tomcat. Depending on the customer’s specific requirements, the platform
    can be deployed on single or multiple servers. A two-node deployment may look
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: A two-node deployment scenario'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of autonomous software components
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From this project, I learned that decomposing the platform’s functionality
    into a set of autonomous software components provides a number of benefits:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A customer can deploy parts of the platform in its own system landscape, integrating
    it with its existing systems using its well-defined APIs.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example where one customer decided to deploy **Component
    A**, **Component B**, **Component D**, and **Component E** from the platform and
    integrate them with two existing systems in the customer’s system landscape, **System
    A** and **System B**:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中一位客户决定从平台部署**组件A**、**组件B**、**组件D**和**组件E**，并将它们与客户系统环境中的两个现有系统**系统A**和**系统B**集成：
- en: '![Diagram  Description automatically generated](img/B19825_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B19825_03.png)'
- en: 'Figure 1.3: Partial deployment of the platform'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：平台的局部部署
- en: Another customer could choose to replace parts of the platform’s functionality
    with implementations that already exist in the customer’s system landscape, potentially
    requiring some adoption of the existing functionality in the platform’s APIs.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一位客户可以选择用客户系统环境中已有的实现来替换平台功能的一部分，这可能会要求在平台API中采用一些现有功能。
- en: 'The following is an example where a customer has replaced **Component C** and
    **Component F** in the platform with their own implementation:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中客户已将平台中的**组件C**和**组件F**替换为自己的实现：
- en: '![Diagram  Description automatically generated](img/B19825_04.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B19825_04.png)'
- en: 'Figure 1.4: Replacing parts of the platform'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：替换平台的部分
- en: Each component in the platform can be delivered and upgraded separately. Thanks
    to the use of well-defined APIs, one component can be upgraded to a new version
    without being dependent on the life cycle of the other components.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台中的每个组件都可以单独交付和升级。得益于使用定义良好的API，一个组件可以升级到新版本，而无需依赖于其他组件的生命周期。
- en: 'The following is an example where **Component A** has been upgraded from version
    **v1.1** to **v1.2**. **Component B**, which calls **Component A**, does not need
    to be upgraded since it uses a well-defined API; that is, it’s still the same
    after the upgrade (or it’s at least backward-compatible):'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中**组件A**已从版本**v1.1**升级到**v1.2**。调用**组件A**的**组件B**不需要升级，因为它使用的是定义良好的API；也就是说，升级后它仍然是相同的（或者至少是向后兼容的）：
- en: '![Graphical user interface  Description automatically generated](img/B19825_05.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B19825_05.png)'
- en: 'Figure 1.5: Upgrading a specific component'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：升级特定组件
- en: 'Thanks to the use of well-defined APIs, each component in the platform can
    also be scaled out to multiple servers independently of the other components.
    Scaling can be done either to meet high availability requirements or to handle
    higher volumes of requests. In this specific project, it was achieved by *manually*
    setting up load balancers in front of a number of servers, each running a Java
    EE web container. An example where **Component A** has been scaled out to three
    instances looks as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用了定义良好的API，平台中的每个组件也可以独立于其他组件扩展到多个服务器。扩展可以是满足高可用性要求或处理更高请求量的需要。在这个特定项目中，这是通过在运行Java
    EE Web容器的多个服务器前手动设置负载均衡器来实现的。**组件A**已扩展到三个实例的示例如下：
- en: '![](img/B19825_06.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19825_06.png)'
- en: 'Figure 1.6: Scaling out the platform'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：扩展平台
- en: Challenges with autonomous software components
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自主软件组件的挑战
- en: 'My team also learned that decomposing the platform introduced a number of new
    challenges that we were not exposed to (at least not to the same degree) when
    developing more traditional, monolithic applications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我的团队还了解到，将平台分解引入了许多新的挑战，这些挑战在我们开发更传统的、单体式应用时并未遇到（至少没有达到同样的程度）：
- en: Adding new instances to a component required manually configuring load balancers
    and manually setting up new nodes. This work was both time-consuming and error-prone.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向组件添加新实例需要手动配置负载均衡器并手动设置新节点。这项工作既耗时又容易出错。
- en: The platform was initially prone to errors caused by the other systems it was
    communicating with. If a system stopped responding to requests that were sent
    from the platform in a timely fashion, the platform quickly ran out of crucial
    resources, for example, OS threads, specifically when exposed to a large number
    of concurrent requests. This caused components in the platform to hang or even
    crash. Since most of the communication in the platform is based on synchronous
    communication, one component crashing can lead to cascading failures; that is,
    clients of the crashing components could also crash after a while. This is known
    as a **chain of failures**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台最初容易受到它所通信的其他系统引起的错误的影响。如果一个系统未能及时响应平台发送的请求，平台很快就会耗尽关键资源，例如，操作系统线程，尤其是在面对大量并发请求时。这导致平台中的组件挂起甚至崩溃。由于平台中的大多数通信都是基于同步通信，一个组件崩溃可能导致级联故障；也就是说，崩溃组件的客户端也可能在一段时间后崩溃。这被称为**故障链**。
- en: Keeping the configuration in all the instances of the components consistent
    and up to date quickly became a problem, causing a lot of manual and repetitive
    work. This led to quality problems from time to time.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持所有组件实例的配置一致并更新迅速成为一个问题，导致大量手动和重复性的工作。这有时会导致质量问题。
- en: Monitoring the state of the platform in terms of latency issues and hardware
    usage (for example, usage of CPU, memory, disks, and the network) was more complicated
    compared to monitoring a single instance of a monolithic application.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控平台在延迟问题和硬件使用（例如，CPU、内存、磁盘和网络的使用）方面的状态，与监控单体应用的单一实例相比，要复杂得多。
- en: Collecting log files from a number of distributed components and correlating
    related log events from the components was also difficult, but feasible since
    the number of components was fixed and known in advance.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个分布式组件收集日志文件并关联相关日志事件也是困难的，但由于组件数量固定且事先已知，因此是可行的。
- en: Over time, we addressed most of the challenges that were mentioned in the preceding
    list with a mix of in-house-developed tools and well-documented instructions for
    handling these challenges manually. The scale of the operation was, in general,
    at a level where manual procedures for releasing new versions of the components
    and handling runtime issues were acceptable, even though they were not desirable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们通过内部开发的工具和针对手动处理这些挑战的详细说明，解决了前面提到的大多数挑战。操作的规模通常在可以接受的水平上，即使它们不是理想的，手动发布组件新版本和处理运行时问题也是可行的。
- en: Enter microservices
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入微服务时代
- en: Learning about microservice-based architectures in 2014 made me realize that
    other projects had also been struggling with similar challenges (partly for other
    reasons than the ones I described earlier, for example, the large cloud service
    providers meeting web-scale requirements). Many microservice pioneers had published
    details of lessons they’d learned. It was very interesting to learn from these
    lessons.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年了解基于微服务的架构让我意识到，其他项目也一直在努力应对类似的挑战（部分原因不同于我之前描述的原因，例如，大型云服务提供商满足Web规模需求）。许多微服务先驱已经发布了他们所学到经验教训的细节。从这些经验教训中学习非常有趣。
- en: Many of the pioneers initially developed monolithic applications that made them
    very successful from a business perspective. But over time, these monolithic applications
    became more and more difficult to maintain and evolve. They also became challenging
    to scale beyond the capabilities of the largest machines available (also known
    as **vertical scaling**). Eventually, the pioneers started to find ways to split
    monolithic applications into smaller components that could be released and scaled
    independently of each other. Scaling small components can be done using **horizontal
    scaling**, that is, deploying a component on a number of smaller servers and placing
    a load balancer in front of it. If done in the cloud, the scaling capability is
    potentially endless – it is just a matter of how many virtual servers you bring
    in (given that your component can scale out on a huge number of instances, but
    more on that later on).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多先驱最初开发了单体应用，从商业角度来看，它们非常成功。但随着时间的推移，这些单体应用变得越来越难以维护和演进。它们也变得难以扩展到最大机器的能力之外（也称为**垂直扩展**）。最终，先驱们开始寻找将单体应用拆分成更小组件的方法，这些组件可以独立发布和扩展。可以通过**水平扩展**来实现小组件的扩展，即在多个较小的服务器上部署组件，并在其前面放置一个负载均衡器。如果在云中执行，扩展能力可能是无限的——这仅仅是一个关于你将多少虚拟服务器引入的问题（假设你的组件可以在大量实例上扩展，但关于这一点稍后还会详细说明）。
- en: In 2014, I also learned about a number of new open source projects that delivered
    tools and frameworks that simplified the development of microservices and could
    be used to handle the challenges that come with a microservice-based architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，我还了解到了一些新的开源项目，它们提供了工具和框架，简化了微服务的开发，并可用于处理基于微服务架构带来的挑战。
- en: 'Some of these are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些如下：
- en: Pivotal released **Spring Cloud**, which wraps parts of the **Netflix OSS**
    in order to provide capabilities such as dynamic service discovery, configuration
    management, distributed tracing, circuit breaking, and more.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal发布了**Spring Cloud**，它封装了**Netflix OSS**的部分功能，以提供动态服务发现、配置管理、分布式跟踪、断路器等功能。
- en: I also learned about **Docker** and the container revolution, which is great
    for minimizing the gap between development and production. Being able to package
    a component not only as a deployable runtime artifact (for example, a Java `war`
    or `jar` file) but as a complete image, ready to be launched as a container on
    a server running Docker, was a great step forward for development and testing.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还了解到了**Docker**和容器革命，这对于缩小开发和生产之间的差距非常有帮助。能够将组件打包不仅作为可部署的运行时工件（例如，Java `war`或`jar`文件），而且作为一个完整的镜像，准备好在运行Docker的服务器上启动为容器，这对于开发和测试来说是一个巨大的进步。
- en: For now, think of a container as an isolated process. We will learn more about
    containers in *Chapter 4*, *Deploying Our Microservices Using Docker*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将容器视为一个隔离的过程。我们将在*第4章*，*使用Docker部署我们的微服务*中了解更多关于容器的内容。
- en: A container engine, such as Docker, is not enough to be able to use containers
    in a production environment. Something is needed that can ensure that all the
    containers are up and running and that can scale out containers on a number of
    servers, thereby providing high availability and increased compute resources.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器引擎，例如Docker，仅靠它本身还不足以在生产环境中使用容器。需要某种东西来确保所有容器都处于运行状态，并且能够在多台服务器上扩展容器，从而提供高可用性和增加计算资源。
- en: These types of products became known as **container orchestrators**. A number
    of products have evolved over the last few years, such as Apache Mesos, Docker
    in Swarm mode, Amazon ECS, HashiCorp Nomad, and **Kubernetes**. Kubernetes was
    initially developed by Google. When Google released v1.0 in 2015, it also donated
    Kubernetes to **CNCF** ([https://www.cncf.io/](https://www.cncf.io/)). During
    2018, Kubernetes became kind of a de facto standard, available both pre-packaged
    for on-premises use and as a service from most of the major cloud providers.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类型的产品被称为**容器编排器**。在过去几年中，许多产品已经发展起来，例如Apache Mesos、Swarm模式下的Docker、Amazon
    ECS、HashiCorp Nomad和**Kubernetes**。Kubernetes最初是由Google开发的。当Google在2015年发布v1.0版本时，它还将Kubernetes捐赠给了**CNCF**
    ([https://www.cncf.io/](https://www.cncf.io/))。在2018年，Kubernetes成为了一种事实上的标准，既可以作为本地部署的预包装版本使用，也可以作为大多数主要云服务提供商的服务。
- en: As explained in [https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/),
    Kubernetes is actually an open source-based rewrite of an internal container orchestrator,
    named **Borg**, used by Google for more than a decade before the Kubernetes project
    was founded.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如[https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/)中所述，Kubernetes实际上是一个基于开源的重写，名为**Borg**的内部容器编排器，在Kubernetes项目成立之前，Google已经使用了十多年。
- en: In 2018, I started to learn about the concept of a **service mesh** and how
    a service mesh can complement a container orchestrator to further offload microservices
    from responsibilities to make them manageable and resilient.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年，我开始了解**服务网格**的概念以及服务网格如何补充容器编排器，进一步减轻微服务的责任，使其可管理和有弹性。
- en: A sample microservice landscape
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例微服务景观
- en: Since this book can’t cover all aspects of the technologies I just mentioned,
    I will focus on the parts that have proven to be useful in customer projects I
    have been involved in since 2014\. I will describe how they can be used together
    to create cooperating microservices that are manageable, scalable, and resilient.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书无法涵盖我刚才提到的所有技术方面，我将专注于自2014年以来我在客户项目中证明有用的部分。我将描述它们如何一起使用来创建可管理、可扩展和有弹性的协作微服务。
- en: 'Each chapter in this book will address a specific concern. To demonstrate how
    things fit together, I will use a small set of cooperating microservices that
    we will evolve throughout this book. The microservice landscape will be described
    in *Chapter 3*, *Creating a Set of Cooperating Microservices*; for now, it is
    sufficient to know that it looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每一章都将解决一个特定的问题。为了展示事物是如何相互关联的，我将使用一组协作的微服务，我们将在整本书中逐步发展这些微服务。微服务景观将在*第3章*，*创建一组协作微服务*中描述；目前，只需知道它看起来是这样的：
- en: '![Diagram  Description automatically generated](img/B19825_07.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_07.png)'
- en: 'Figure 1.7: The microservice-based system landscape used in the book'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：本书中使用的基于微服务的系统景观
- en: Note that this is a very small system landscape of cooperating microservices.
    The surrounding support services that we will add in the coming chapters might
    look overwhelmingly complex for these few microservices. But keep in mind that
    the solutions presented in this book aim to support a much larger system landscape.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个非常小的协作微服务系统景观。我们将在接下来的章节中添加的周围支持服务对于这些微服务来说可能看起来过于复杂。但请记住，本书中提出的解决方案旨在支持一个更大的系统景观。
- en: Now that we have been introduced to the potential benefits and challenges of
    microservices, let’s start to look into how a microservice can be defined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了微服务的潜在利益和挑战，让我们开始探讨如何定义微服务。
- en: Defining a microservice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义微服务
- en: 'A microservice architecture is about splitting up monolithic applications into
    smaller components, which achieves two major goals:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是将单体应用程序拆分为更小的组件，这实现了两个主要目标：
- en: Faster development, enabling continuous deployments
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的开发，实现持续部署
- en: Easier to scale, manually or automatically
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易扩展，手动或自动
- en: 'A microservice is essentially an autonomous software component that is independently
    upgradeable, replaceable, and scalable. To be able to act as an autonomous component,
    it must fulfill certain criteria, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务本质上是一个独立的软件组件，它可以独立升级、替换和扩展。为了能够作为一个自主组件，它必须满足以下某些标准：
- en: It must conform to a shared-nothing architecture; that is, microservices don’t
    share data in databases with each other!
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须符合无共享架构；也就是说，微服务之间不共享数据库中的数据！
- en: It must only communicate through well-defined interfaces, either using APIs
    and synchronous services or preferably by sending messages asynchronously. The
    APIs and message formats used must be stable, well documented, and evolve by following
    a defined versioning strategy.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须仅通过定义良好的接口进行通信，无论是使用API和同步服务，还是最好通过异步发送消息。使用的API和消息格式必须是稳定的、有良好文档的，并遵循定义的版本策略。
- en: It must be deployed as separate runtime processes. Each instance of a microservice
    runs in a separate runtime process, for example, a Docker container.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为独立的运行时进程部署。每个微服务的实例都在一个独立的运行时进程中运行，例如，一个Docker容器。
- en: Microservice instances are stateless so that incoming requests to a microservice
    can be handled by any of its instances.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a set of cooperating microservices, we can deploy to a number of smaller
    servers instead of being forced to deploy to a single big server, like we have
    to do when deploying a monolithic application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Given that the preceding criteria have been fulfilled, it is easier to scale
    up a single microservice into more instances (for example, using more virtual
    servers) compared to scaling up a big monolithic application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing autoscaling capabilities that are available in the cloud is also a
    possibility, but is not typically feasible for a big monolithic application. It’s
    also easier to upgrade or even replace a single microservice compared to upgrading
    a big monolithic application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated by the following diagram, where a monolithic application
    has been divided into six microservices, all of which have been deployed into
    separate servers. Some of the microservices have also been scaled up independently
    of the others:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B19825_08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Dividing a monolith into microservices'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'A very frequent question I receive from customers is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How big should a microservice be?
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I try to use the following rules of thumb:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Small enough to fit in the head of a developer
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big enough to not jeopardize performance (that is, latency) and/or data consistency
    (SQL foreign keys between data that’s stored in different microservices are no
    longer something you can take for granted)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, to summarize, microservice architecture is, in essence, an architectural
    style where we decompose a monolithic application into a group of cooperating
    autonomous software components. The motivation is to enable faster development
    and to make it easier to scale the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: With a better understanding of how to define a microservice, we can move on
    and detail the challenges that come with a system landscape of microservices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with microservices
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Challenges with autonomous software components* section, we have already
    seen some of the challenges that autonomous software components can bring (and
    they all apply to microservices as well), as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Many small components that use synchronous communication can cause *a chain
    of failure* problem, especially under high load
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the configuration up to date for many small components can be challenging
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s hard to track a request that’s being processed and involves many components,
    for example, when performing root cause analysis, where each component stores
    log records locally
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the usage of hardware resources on a component level can be challenging
    as well
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual configuration and management of many small components can become costly
    and error-prone
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another downside (but not always obvious initially) of decomposing an application
    into a group of autonomous components is that they form a **distributed system**.
    Distributed systems are known to be, by their nature, very hard to deal with.
    This has been known for many years (but in many cases was neglected until proven
    differently). My favorite quote to establish this fact is from Peter Deutsch who,
    back in 1994, stated the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成一组自治组件的另一个缺点（但最初可能并不明显）是它们形成了一个**分布式系统**。众所周知，分布式系统由于其本质而非常难以处理。这一点已经为人所知多年（但在许多情况下直到被证明不同才被忽视）。我最喜欢的关于这一事实的引言来自彼得·德克斯特，他在1994年提出了以下观点：
- en: '**The 8 fallacies of distributed computing**: Essentially everyone, when they
    first build a distributed application, makes the following eight assumptions.
    All prove to be false in the long run and all cause big trouble and painful learning
    experiences:'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**分布式计算的8大谬误**：基本上，每个人在第一次构建分布式应用程序时，都会做出以下八个假设。所有这些假设在长期内都被证明是错误的，并且都导致了巨大的麻烦和痛苦的学习经历：'
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1\. The network is reliable
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1. 网络是可靠的
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2\. Latency is zero
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2. 延迟为零
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. Bandwidth is infinite
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3. 带宽是无限的
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\. The network is secure
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4. 网络是安全的
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5\. The topology doesn’t change
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5. 拓扑结构不会改变
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6\. There is one administrator
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6. 只有一个管理员
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 7\. The transport cost is zero
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7. 传输成本为零
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8\. The network is homogeneous
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8. 网络是同质的
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Peter Deutsch, 1994
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——彼得·德克斯特，1994年
- en: In general, building microservices based on these false assumptions leads to
    solutions that are prone to both temporary network glitches and problems that
    occur in other microservice instances. When the number of microservices in a system
    landscape increases, the likelihood of problems also goes up. A good rule of thumb
    is to design your microservice architecture based on the assumption that there
    is always something going wrong in the system landscape. The microservice architecture
    needs to be designed to handle this, in terms of detecting problems and restarting
    failed components. Also, on the client side, ensure that requests are not sent
    to failed microservice instances. When problems are corrected, requests to the
    previously failing microservice should be resumed; that is, microservice clients
    need to be resilient. All of this needs, of course, to be fully automated. With
    a large number of microservices, it is not feasible for operators to handle this
    manually!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于这些错误假设构建的微服务会导致容易受到暂时性网络故障和其他微服务实例中发生的问题的影响。当系统景观中微服务的数量增加时，问题的可能性也会增加。一个很好的经验法则是根据系统景观中始终存在某些问题的假设来设计您的微服务架构。微服务架构需要设计来处理这些问题，包括检测问题和重启失败的组件。此外，在客户端，确保不要向失败的微服务实例发送请求。当问题得到纠正时，应恢复对之前失败的微服务的请求；也就是说，微服务客户端需要具有弹性。当然，所有这些都需要完全自动化。对于大量微服务，操作员手动处理这是不可行的！
- en: The scope of this is large, but we will limit ourselves for now and move on
    to learn about design patterns for microservices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题的范围很广，但我们将暂时限制自己，并继续学习微服务的设计模式。
- en: Design patterns for microservices
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: This topic will cover the use of design patterns to mitigate challenges with
    microservices, as described in the preceding section. Later in this book, we will
    see how we can implement these design patterns using Spring Boot, Spring Cloud,
    Kubernetes, and Istio.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题将涵盖使用设计模式来缓解前述部分中描述的微服务挑战。在本书的后续部分，我们将看到如何使用Spring Boot、Spring Cloud、Kubernetes和Istio来实现这些设计模式。
- en: The concept of design patterns is actually quite old; it was invented by Christopher
    Alexander back in 1977\. In essence, a design pattern is about describing a reusable
    solution to a problem when given a specific context. Using a tried and tested
    solution from a design pattern can save a lot of time and increase the quality
    of the implementation compared to spending time inventing the solution ourselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念实际上相当古老；它是由克里斯托弗·亚历山大在1977年发明的。本质上，设计模式是关于在特定上下文中描述一个可重用解决方案来解决问题的。使用设计模式中的经过验证和测试的解决方案可以节省大量时间，并且与自行发明解决方案相比，可以提高实现的品质。
- en: 'The design patterns we will cover are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的设计模式如下：
- en: Service discovery
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Edge server
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Reactive microservices
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: Central configuration
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央配置
- en: Centralized log analysis
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央日志分析
- en: Distributed tracing
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Circuit breaker
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: Control loop
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制回路
- en: Centralized monitoring and alarms
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央监控和警报
- en: This list is not intended to be comprehensive; instead, it’s a minimal list
    of design patterns that are required to handle the challenges we described previously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表并非旨在全面；相反，它是一个最小列表，列出了处理我们之前描述的挑战所需的设计模式。
- en: 'We will use a lightweight approach to describing design patterns, and focus
    on the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用轻量级的方法来描述设计模式，并重点关注以下内容：
- en: The problem
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: A solution
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案
- en: Requirements for the solution
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案的要求
- en: Throughout this book, we will delve more deeply into how to apply these design
    patterns. The context for these design patterns is a system landscape of cooperating
    microservices where the microservices communicate with each other using either
    synchronous requests (for example, using HTTP) or by sending asynchronous messages
    (for example, using a message broker).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将更深入地探讨如何应用这些设计模式。这些设计模式的应用背景是一个由协作微服务组成的系统景观，其中微服务通过同步请求（例如，使用HTTP）或发送异步消息（例如，使用消息代理）相互通信。
- en: Service discovery
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现
- en: The service discovery pattern has the following problem, solution, and solution
    requirements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: How can clients find microservices and their instances?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如何找到微服务和它们的实例？
- en: 'Microservices instances are typically assigned dynamically allocated IP addresses
    when they start up, for example, when running in containers. This makes it difficult
    for a client to make a request to a microservice that, for example, exposes a
    REST API over HTTP. Consider the following diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实例在启动时通常会分配动态分配的IP地址，例如，在容器中运行时。这使得客户端难以向一个例如通过HTTP暴露REST API的微服务发起请求。考虑以下图表：
- en: '![Graphical user interface, diagram  Description automatically generated](img/B19825_09.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表  自动生成的描述](img/B19825_09.png)'
- en: 'Figure 1.9: The service discovery issue'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：服务发现问题
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component – a **service discovery** service – to the system landscape,
    which keeps track of currently available microservices and the IP addresses of
    its instances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观添加一个新的组件——一个**服务发现**服务——以跟踪当前可用的微服务和其实例的IP地址。
- en: Solution requirements
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案的要求如下：
- en: Automatically register/unregister microservices and their instances as they
    come and go.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动注册/注销微服务和它们的实例，随着它们的到来和离去。
- en: The client must be able to make a request to a logical endpoint for the microservice.
    The request will be routed to one of the available microservice instances.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须能够向微服务的一个逻辑端点发起请求。请求将被路由到可用的微服务实例之一。
- en: Requests to a microservice must be load-balanced over the available instances.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在可用的实例之间对微服务的请求进行负载均衡。
- en: We must be able to detect instances that currently are unhealthy so that requests
    will not be routed to them.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须能够检测当前不健康的实例，以便请求不会路由到它们。
- en: '**Implementation notes**: As we will see in *Chapter 9*, *Adding Service Discovery
    Using Netflix Eureka*, *Chapter 15*, *Introduction to Kubernetes*, and *Chapter
    16*, *Deploying Our Microservices to Kubernetes*, this design pattern can be implemented
    using two different strategies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施说明**：正如我们将在第9章“使用Netflix Eureka添加服务发现”、第15章“Kubernetes简介”和第16章“将我们的微服务部署到Kubernetes”中看到的那样，此设计模式可以使用两种不同的策略实现：'
- en: '**Client-side routing**: The client uses a library that communicates with the
    service discovery service to find out the proper instances to send the requests
    to.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端路由**：客户端使用一个库与服务发现服务通信，以找出应向其发送请求的正确实例。'
- en: '**Server-side routing**: The infrastructure of the service discovery service
    also exposes a reverse proxy that all requests are sent to. The reverse proxy
    forwards the requests to a proper microservice instance on behalf of the client.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端路由**：服务发现服务的基础设施还公开了一个反向代理，所有请求都发送到该代理。反向代理代表客户端将请求转发到适当的微服务实例。'
- en: Edge server
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: The edge server pattern has the following problem, solution, and solution requirements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器模式具有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape of microservices, it is in many cases desirable to expose
    some of the microservices to the outside of the system landscape and hide the
    remaining microservices from external access. The exposed microservices must be
    protected against requests from malicious clients.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new component, an **edge server**, to the system landscape that all incoming
    requests will go through:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_10.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: The edge server design pattern'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation notes**: An edge server typically behaves like a reverse proxy
    and can be integrated with a discovery service to provide dynamic load-balancing
    capabilities.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some solution requirements are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Hide internal services that should not be exposed outside their context; that
    is, only route requests to microservices that are configured to allow external
    requests
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose external services and protect them from malicious requests; that is,
    use standard protocols and best practices such as OAuth, OIDC, JWT tokens, and
    API keys to ensure that the clients are trustworthy
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive microservices
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reactive microservices pattern has the following problem, solution, and
    solution requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, as Java developers, we are used to implementing synchronous communication
    using blocking I/O, for example, a RESTful JSON API over HTTP. Using a blocking
    I/O means that a thread is allocated from the operating system for the length
    of the request.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: If the number of concurrent requests goes up, a server might run out of available
    threads in the operating system, causing problems ranging from longer response
    times to crashing servers. Using a microservice architecture typically makes this
    problem even worse, where typically a chain of cooperating microservices is used
    to serve a request. The more microservices involved in serving a request, the
    faster the available threads will be drained.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use non-blocking I/O to ensure that no threads are allocated while waiting for
    processing to occur in another service, that is, a database or another microservice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some solution requirements are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Whenever feasible, use an asynchronous programming model, sending messages without
    waiting for the receiver to process them.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a synchronous programming model is preferred, use reactive frameworks that
    can execute synchronous requests using non-blocking I/O, without allocating a
    thread while waiting for a response. This will make the microservices easier to
    scale in order to handle an increased workload.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices must also be designed to be resilient and self-healing. Resilient
    meaning being capable of producing a response even if one of the services it depends
    on fails; self-healing meaning that once the failing service is operational again,
    the microservice must be able to resume using it.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2013, key principles for designing reactive systems were established in **The
    Reactive Manifesto** ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: According to the manifesto, the foundation for reactive systems is that they
    are message-driven; they use asynchronous communication. This allows them to be
    elastic, that is, scalable, and resilient, that is, tolerant to failures. Elasticity
    and resilience together enable a reactive system to always respond in a timely
    fashion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Central configuration
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central configuration pattern has the following problem, solution, and solution
    requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An application is, traditionally, deployed together with its configuration,
    for example, a set of environment variables and/or files containing configuration
    information. Given a system landscape based on a microservice architecture, that
    is, with a large number of deployed microservice instances, some queries arise:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: How do I get a complete picture of the configuration that is in place for all
    the running microservice instances?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I update the configuration and make sure that all the affected microservice
    instances are updated correctly?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new component, a **configuration server**, to the system landscape to
    store the configuration of all the microservices, as illustrated by the following
    diagram:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: The central configuration design pattern'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make it possible to store configuration information for a group of microservices
    in one place, with different settings for different environments (for example,
    **dev**, **test**, **qa**, and **prod**).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Centralized log analysis
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Centralized log analysis has the following problem, solution, and solution requirements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traditionally, an application writes log events to log files that are stored
    in the local filesystem of the server that the application runs on. Given a system
    landscape based on a microservice architecture, that is, with a large number of
    deployed microservice instances on a large number of smaller servers, we can ask
    the following questions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: How do I get an overview of what is going on in the system landscape when each
    microservice instance writes to its own local log file?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I find out if any of the microservice instances get into trouble and
    start writing error messages to their log files?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If end users start to report problems, how can I find related log messages;
    that is, how can I identify which microservice instance is the root cause of the
    problem? The following diagram illustrates the problem:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_12.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Microservices write log files to their local file system'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new component that can manage **centralized logging** and is capable
    of the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Detecting new microservice instances and collecting log events from them
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting and storing log events in a structured and searchable way in a
    central database
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing APIs and graphical tools for querying and analyzing log events
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some solution requirements are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Microservices stream log events to standard system output, `stdout`. This makes
    it easier for a log collector to find the log events compared to when log events
    are written to microservice-specific log files.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices tag the log events with the correlation ID described in the next
    section regarding the *Distributed tracing* design pattern.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A canonical log format is defined, so that log collectors can transform log
    events collected from the microservices to a canonical log format before log events
    are stored in the central database. Storing log events in a canonical log format
    is required to be able to query and analyze the collected log events.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Distributed tracing has the following problem, solution, and solution requirements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It must be possible to track requests and messages that flow between microservices
    while processing an external request to the system landscape.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of fault scenarios are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: If end users start to file support cases regarding a specific failure, how can
    we identify the microservice that caused the problem, that is, the root cause?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one support case mentions problems related to a specific entity, for example,
    a specific order number, how can we find log messages related to processing this
    specific order – for example, log messages from all microservices that were involved
    in processing it?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If end users start to file support cases regarding an unacceptably long response
    time, how can we identify which microservice in a call chain is causing the delay?
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_13.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: The distributed tracing issue'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To track the processing between cooperating microservices, we need to ensure
    that all related requests and messages are marked with a common **correlation
    ID** and that the correlation ID is part of all log events. Based on a correlation
    ID, we can use the centralized logging service to find all related log events.
    If one of the log events also includes information about a business-related identifier,
    for example, the ID of a customer, product, or order, we can find all related
    log events for that business identifier using the correlation ID.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To be able to analyze delays in a call chain of cooperating microservices, we
    must be able to collect timestamps for when requests, responses, and messages
    enter and exit each microservice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution requirements are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Assign unique correlation IDs to all incoming or new requests and events in
    a well-known place, such as a header with a standardized name
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a microservice makes an outgoing request or sends a message, it must add
    the correlation ID to the request and message
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All log events must include the correlation ID in a predefined format so that
    the centralized logging service can extract the correlation ID from the log event
    and make it searchable
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trace records must be created for when requests, responses, and messages both
    enter and exit a microservice instance
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The circuit breaker pattern has the following problem, solution, and solution
    requirements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A system landscape of microservices that uses synchronous intercommunication
    can be exposed to a **chain of failures**. If one microservice stops responding,
    its clients might get into problems as well and stop responding to requests from
    their clients. The problem can propagate recursively throughout a system landscape
    and take out major parts of it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This is especially common in cases where synchronous requests are executed using
    blocking I/O, that is, blocking a thread from the underlying operating system
    while a request is being processed. Combined with a large number of concurrent
    requests and a service that starts to respond unexpectedly slowly, thread pools
    can quickly become drained, causing the caller to hang and/or crash. This failure
    can spread unpleasantly quickly to the caller’s caller, and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add a **circuit breaker** that prevents new outgoing requests from a caller
    if it detects a problem with the service it calls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution requirements are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Open** the circuit and fail fast (without waiting for a timeout) if problems
    with the service are detected.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probe for failure correction (also known as a **half-open** circuit); that is,
    allow a single request to go through on a regular basis to see whether the service
    is operating normally again.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close** the circuit if the probe detects that the service is operating normally
    again. This capability is very important since it makes the system landscape resilient
    to these kinds of problems; in other words, it self-heals.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a scenario where all synchronous communication
    within the system landscape of microservices goes through circuit breakers. All
    the circuit breakers are closed; they allow traffic, except for one circuit breaker
    (for **Microservice E**) that has detected problems in the service the requests
    go to. Therefore, this circuit breaker is open and utilizes fast-fail logic; that
    is, it does not call the failing service and waits for a timeout to occur. Instead,
    **Microservice E** can immediately return a response, optionally applying some
    fallback logic before responding:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_14.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: The circuit breaker design pattern'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Control loop
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The control loop pattern has the following problem, solution, and solution requirements.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a system landscape with a large number of microservice instances spread out
    over a number of servers, it is very difficult to manually detect and correct
    problems such as crashed or hung microservice instances.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new component, a **control loop**, to the system landscape. This process
    is illustrated as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_15.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: The control loop design pattern'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control loop will constantly observe the **actual state** of the system
    landscape, comparing it with a **desired state**, as specified by the operators.
    If the two states differ, it will take action to make the actual state equal to
    the desired state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation notes**: In the world of containers, a *container orchestrator*
    such as Kubernetes is typically used to implement this pattern. We will learn
    more about Kubernetes in *Chapter 15*, *Introduction to Kubernetes*.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Centralized monitoring and alarms
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this pattern, we have the following problem, solution, and solution requirements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If observed response times and/or the usage of hardware resources become unacceptably
    high, it can be very hard to discover the root cause of the problem. For example,
    we need to be able to analyze hardware resource consumption per microservice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To curb this, we add a new component, a **monitor service**, to the system landscape,
    which is capable of collecting metrics about hardware resource usage for each
    microservice instance level.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Solution requirements
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution requirements are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: It must be able to collect metrics from all the servers that are used by the
    system landscape, which includes autoscaling servers
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to detect new microservice instances as they are launched on
    the available servers and start to collect metrics from them
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to provide APIs and graphical tools for querying and analyzing
    the collected metrics
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be possible to define alerts that are triggered when a specified metric
    exceeds a specified threshold value
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows Grafana, which visualizes metrics from Prometheus,
    a monitoring tool that we will look at in *Chapter 20*, *Monitoring Microservices*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_16.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Monitoring with Grafana'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: That was an extensive list! I am sure these design patterns helped you to understand
    the challenges with microservices better. Next, we will move on to learning about
    software enablers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Software enablers
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve already mentioned, we have a number of very good open source tools
    that can help us both meet our expectations of microservices and, most importantly,
    handle the new challenges that come with them:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Boot**, an application framework'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud/Netflix OSS**, a mix of application framework and ready-to-use
    services'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**, a tool for running containers on a single server'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes**, a container orchestrator that manages a cluster of servers
    that run containers'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Istio**, a service mesh implementation'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table maps the design patterns we will need to handle these challenges,
    along with the corresponding open source tool that will be used in this book to
    implement the design patterns:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '| **Design Pattern** | **Spring Boot** | **Spring Cloud** | **Kubernetes**
    | **Istio** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| **Service discovery** |  | Netflix Eureka and Spring Cloud LoadBalancer |
    Kubernetes `kube-proxy` and service resources |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| **Edge server** |  | Spring Cloud Gateway and Spring Security OAuth | Kubernetes
    Ingress controller | Istio ingress gateway |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| **Reactive microservices** | Project Reactor and Spring WebFlux |  |  |  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| **Central configuration** |  | Spring Config Server | Kubernetes `ConfigMaps`
    and Secrets |  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| **Centralized log analysis** |  |  | Elasticsearch, Fluentd, and Kibana.
    Note: Actually not part of Kubernetes, but can easily be deployed and configured
    together with Kubernetes |  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| **Distributed tracing** | Micrometer Tracing and Zipkin |  |  | Jaeger |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| **Circuit breaker** |  | Resilience4j |  | Outlier detection |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| **Control loop** |  |  | Kubernetes controller managers |  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| **Centralized monitoring and alarms** |  |  |  | Kiali, Grafana, and Prometheus
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: 'Figure 1.17: Mapping design patterns to open source tools'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Please note that any of Spring Cloud, Kubernetes, or Istio can be used to implement
    some design patterns, such as service discovery, edge server, and central configuration.
    We will discuss the pros and cons of using these alternatives later in this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: With the design patterns and tools that we will use in the book introduced,
    we will wrap up this chapter by going through some related areas that are also
    important, but not covered in this text.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Other important considerations
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be successful when it comes to implementing a microservice architecture,
    there are a number of related areas to consider as well. I will not cover these
    areas in this book; instead, I’ll just briefly mention them here as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Importance of DevOps**: One of the benefits of a microservice architecture
    is that it enables shorter delivery times and, in extreme cases, allows *continuous
    delivery* of new versions. To be able to deliver that fast, you need to establish
    an organization where dev and ops work together under the mantra *you built it,
    you run it*. This means that developers are no longer allowed to simply pass new
    versions of the software over to the operations team. Instead, the dev and ops
    organizations need to work much more closely together, organized into teams that
    have full responsibility for the end-to-end life cycle of one microservice (or
    a group of related microservices). Besides the organizational part of dev/ops,
    the teams also need to automate the delivery chain, that is, the steps for building,
    testing, packaging, and deploying the microservices to the various deployment
    environments. This is known as setting up a *delivery pipeline*.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizational aspects and Conway’s law**: Another interesting aspect of
    how a microservice architecture might affect the organization is *Conway’s law*,
    which states the following:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ”Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization’s communication structure.”
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Melvyn Conway, 1967
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that the traditional approach of organizing IT teams for large applications
    based on their technology expertise (for example, UX, business logic, and database
    teams) will lead to a big three-tier application – typically, a big monolithic
    application with a separately deployable unit for the UI, one for processing the
    business logic, and one for the big database.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To successfully deliver an application based on a microservice architecture,
    the organization needs to be changed into teams that work with one or a group
    of related microservices. The team must have the skills that are required for
    those microservices, for example, languages and frameworks for the business logic
    and database technologies for persisting its data.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Decomposing a monolithic application into microservices**: One of the most
    difficult decisions (and expensive if done wrong) is how to decompose a monolithic
    application into a set of cooperating microservices. If this is done in the wrong
    way, you will end up with problems such as the following:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slow delivery**: Changes in the business requirements will affect too many
    of the microservices, resulting in extra work.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad performance**: To be able to perform a specific business function, a
    lot of requests have to be passed between various microservices, resulting in
    long response times.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inconsistent data**: Since related data is separated into different microservices,
    inconsistencies can appear over time in data that’s managed by different microservices.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good approach to finding proper boundaries for microservices is to apply
    **domain-driven design** and its concept of **bounded contexts**. According to
    Eric Evans, a *bounded context* is:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ”A description of a boundary (typically a subsystem, or the work of a particular
    team) within which a particular model is defined and applicable.”
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that a microservice defined by a bounded context will have a well-defined
    model of its own data.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Importance of API design**: If a group of microservices exposes a common,
    externally available API, it is important that the API is easy to understand and
    adheres to the following guidelines:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the same concept is used in multiple APIs, it should have the same description
    in terms of the naming and data types used.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is of great importance that APIs are allowed to evolve in an independent
    but controlled manner. This typically requires applying a proper versioning schema
    for the APIs, for example, [https://semver.org/](https://semver.org/). This implies
    supporting multiple major versions of an API over a specific period of time, allowing
    clients of the API to migrate to new major versions at their own pace.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migration paths from on-premises to the cloud**: Many companies today run
    their workload on-premises, but are searching for ways to move parts of their
    workload to the cloud. Since most cloud providers today offer *Kubernetes as a
    Service*, an appealing migration approach can be to first move the workload into
    Kubernetes on-premises (as microservices or not) and then redeploy it on a Kubernetes
    as a Service offering provided by a preferred cloud provider.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good design principles for microservices, the 12-factor app**: The 12-factor
    app ([https://12factor.net](https://12factor.net)) is a set of design principles
    for building software that can be deployed in the cloud. Most of these design
    principles are applicable to building microservices independently of where and
    how they will be deployed, that is, in the cloud or on-premises. Some of these
    principles will be covered in this book, such as config, processes, and logs,
    but not all.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it for the first chapter! I hope it gave you a good basic idea of microservices
    and the challenges that come with them, as well as an overview of what we will
    cover in this book.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this introductory chapter, I described my own way into microservices and
    delved into a bit of their history. We defined what a microservice is – a kind
    of autonomous distributed component with some specific requirements. We also went
    through both the good and challenging aspects of microservice-based architecture.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: To handle these challenges, we defined a set of design patterns and briefly
    mapped the capabilities of open source products such as Spring Boot, Spring Cloud,
    Kubernetes, and Istio to the design patterns.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You’re eager to develop your first microservice now, right? In the next chapter,
    you will be introduced to Spring Boot and complementary open source tools that
    we will use to develop our first microservices.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
