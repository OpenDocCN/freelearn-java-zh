- en: '*Chapter 11***: MicroProfile GraphQL**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GraphQL** is a distributed query language that addresses some of the shortcomings
    of **REpresentational State Transfer** (**REST**). In particular, GraphQL addresses
    the notions of **over-fetching** (receiving more data than the client intended)
    and **under-fetching** (requiring the client to make multiple requests to get
    the data it requires). GraphQL applications make use of a schema file that presents
    clients with the queries and mutations at its disposal, as well as the entities
    it can access and manipulate.'
  prefs: []
  type: TYPE_NORMAL
- en: The ease of use and robustness of GraphQL explains why its popularity is growing,
    especially in cloud-native applications. **MicroProfile GraphQL** (**MP GraphQL**)
    makes it easy to create GraphQL-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL basics and when to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building services with MP GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming GraphQL services with client **application programming interfaces**
    (**APIs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned what GraphQL is and when it
    is appropriate to use it, and you will be able to build your own GraphQL application
    ready to deploy in open source, cloud-ready servers such as Open Liberty.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and run the samples mentioned in this chapter, you will need a Mac
    or PC (Windows or Linux) with the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server where these code samples will execute by entering the `Chapter11` directory
    and executing the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've got the prerequisites taken care of, let's start by learning the basics
    of GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL basics and when to use it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with REST, GraphQL is a means of accessing and modifying remote data over
    web-based transports. It uses a publicly visible schema, allowing clients to know
    exactly which entities it can query, which fields can be modified, and so on.
    This is similar to how OpenAPI describes RESTful APIs. The schema acts as a contract
    between the client and the service. GraphQL strictly enforces the schema, preventing
    clients from accessing or modifying entities or fields that are not defined within
    it. This strictness provides a lot of freedom for developers of both clients and
    services, which we'll cover later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL supports the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` requests in REST.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations**: Mutations are used for modifying data—that is, creating, updating,
    and/or deleting it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriptions**: Subscriptions are used so that clients can receive notifications
    of specific events, such as when a particular entity has been created or a field
    has dropped below a certain threshold, or even unrelated events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike REST, where different parts of the API are spread out across multiple
    **HyperText Transfer Protocol** (**HTTP**) endpoints, GraphQL applications typically
    use a single HTTP endpoint, and the operations are embedded in the HTTP request's
    body.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL operations and schemas use their own syntax, but the response is in
    **JavaScript Object Notation** (**JSON**) format. This allows GraphQL services
    and clients to be written in any language. While we plan to cover creating services
    in Java, it is also currently possible to write service and client applications
    in JavaScript, Python, Go, Haskell, Perl, Ruby, Scala, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema defines the types of entities accessible for the service, as well
    as the operations that can be performed. Built-in or primitive GraphQL types are
    called **scalars**. Any service is free to define its own scalar types, but the
    GraphQL specification states that all services must use at least these five standard
    scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`—A 32-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`—Signed double-precision floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`—A sequence of characters using **Unicode Transformation Format-8**
    (**UTF-8**) encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`—`true` or `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ID`—A string that is intended to be a unique **identifier** (**ID**) for an
    entity; it is not intended to be human-readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL objects can be made up of scalars or other objects. Each operation must
    explicitly specify all fields that it wishes to view in the response. For complex
    types (types that include other types or scalars), this might mean specifying
    fields several layers deep.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring clients to specify all fields in a query ensures backward compatibility
    when you add new fields to existing objects. A client cannot be caught off guard
    if a new field appears on an object since their existing query didn't specify
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of requiring clients to specify all fields that they are interested
    in is that it avoids **over-fetching**. Over-fetching occurs when more data is
    sent over the network than is necessary. One common example of over-fetching in
    REST is weather data. If you issue a RESTful request to check the current conditions
    for a particular location from various weather sites, you will see an enormous
    amount of information, but most of that data is unused when you just wanted to
    know what the outside temperature is and whether or not it's raining.
  prefs: []
  type: TYPE_NORMAL
- en: By sending queries as the payload of an HTTP request, GraphQL also avoids **under-fetching**.
    As you've probably guessed, under-fetching occurs when the data returned is insufficient.
    Using the weather example, suppose you also wanted to know the temperature at
    your friends' homes in other cities. You'd have to issue similar RESTful requests
    to the weather site for each location. But in GraphQL, you can issue multiple
    queries in a single HTTP request, enabling you to get exactly the data you need
    with a single round trip to the server and making it fast and efficient!
  prefs: []
  type: TYPE_NORMAL
- en: Queries and mutations have their own syntax, though it is similar to JSON and
    other query languages. Generally, these operations start with `query` or `mutation`
    and then a label for the operation, then, inside curly braces, you would specify
    the query or mutation to invoke with any parameters inside parentheses. You would
    then add the fields you are interested in inside curly braces. We'll see some
    example queries and mutations later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL also allows `503` (service unavailable) error. Some data is still better
    than none, right?
  prefs: []
  type: TYPE_NORMAL
- en: Since the schema is exposed to clients, various tools can introspect the schema,
    allowing users to construct queries and mutations and test them in real time.
    One such tool, which we'll discuss later, is called **GraphiQL** ([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)).
  prefs: []
  type: TYPE_NORMAL
- en: While REST is still the more widely used communication architecture in the cloud,
    GraphQL is quickly gaining in popularity as it addresses many of the gaps in REST.
    So, which approach is right for you? The answer, as with most things, is *it depends*.
    GraphQL primarily only works with JSON as the response type; if you want to use
    other data types, you might want to consider REST or an alternative approach.
    If your data is hierarchical in nature, it might lend itself better to REST.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is security-based in relation to `/public/*`) while restricting
    access to other entities (for example, `/private/*`). This isn't possible in GraphQL
    without splitting the service into separate public and private services, which
    might not be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, HTTP caching is more complicated with GraphQL. Since REST uses URI
    paths, both clients and servers can cache entity results based on the path used.
    It is possible to cache based on paths in GraphQL, but this would require clients
    to pass their queries as HTTP `GET` query parameters. This could be cumbersome
    for the client, as well as being a potential security risk as proxy servers would
    be able to see query parameters, and you may still have issues with caching, depending
    on the spacing and formatting of the query. Fortunately, most implementations
    of GraphQL use query caching on the server side to reduce unnecessary duplication
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: So, when would you use GraphQL? GraphQL tends to cost a little more on the server
    (in order to filter results to get the client exactly what it wants), but that
    trade-off means that client-side processing is significantly reduced. So, if you
    have a lot of clients or want to optimize your client performance, GraphQL is
    a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL tends to reduce network traffic since it avoids under-fetching and over-fetching.
    In environments where network bandwidth is expensive, GraphQL is ideal.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that nothing prevents you from writing both GraphQL
    and RESTful APIs for the same service. This might add more maintenance, but it
    allows your clients to choose.
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand what GraphQL is and when we should use it, let's explore how
    we can build GraphQL applications using MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: Building services with MP GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to develop a GraphQL application using the
    MP GraphQL APIs and runtime framework. We'll cover building queries and mutations,
    and how to invoke them using an interactive web tool called **GraphiQL**. We'll
    also cover entities and enumerated types. Finally, we'll cover a technique to
    reduce unnecessary server-side computations and deliver partial results.
  prefs: []
  type: TYPE_NORMAL
- en: Most GraphQL APIs for Java require you to write a schema first and then build
    the Java code around it. This approach tends to cause some level of dual maintenance,
    and it can slow down development as you evolve your application. MP GraphQL uses
    a `Hello World` query service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with JAX-RS, MP GraphQL is based on annotations. The first annotation to
    consider is `@GraphQLApi`. This annotation is a **Contexts and Dependency Injection**
    (**CDI**) bean-defining annotation, which means that when you apply this annotation
    to a class, it becomes a CDI bean. This enables the CDI framework to manage its
    life cycle and inject dependencies. This annotation is required on classes that
    contain query or mutation methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next annotation we''ll consider is `@Query`. When this annotation is applied
    to methods, it tells the MP GraphQL runtime to create a top-level query in the
    schema. Let''s see a simple example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@GraphQLApi` annotation tells the runtime to manage the life cycle of
    this bean, and the `@Query` annotation tells the runtime to generate a query in
    the schema with no parameters that returns a `String` scalar. If we run this example
    in an MP GraphQL server such as Open Liberty, we can then see the schema file
    by browsing to `http://localhost:9080/ch11/graphql/schema.graphql`. Then, we''ll
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `http://localhost:9080/ch11/graphql-ui` and then enter this query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, click the triangular *play* button to see the results. You should see
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Simple query in GraphiQL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Simple query in GraphiQL
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the result is a JSON object with a field labeled `data`. The results
    of the query are always under the `data` field. If an error were to occur, there
    would be a separate `errors` field instead of, or in addition to, the `data` field.
    This field would include details of the error(s).
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice start, and you can probably guess that you could have multiple
    query methods in this class that could return different data, but queries are
    much more powerful when they have parameters. In previous chapters, we've been
    working with the **Stock Trader** application. Let's GraphQL-ize that application
    in our following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want the client to be able to specify parameters to a query, we simply
    add Java method parameters to the `@Query`-annotated methods. Let''s take a look
    at what we might do for the `Portfolio` service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few new things to consider here. First, we inject `PortfolioDatabase`
    instance. This is nothing more than a wrapper around a `HashMap`, but it could
    just as well access a real relational or NoSQL database to retrieve stock portfolio
    data. CDI injects this for us. *Muchas gracias!*
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `portfolio` query method also has a `@Description` annotation applied
    to it. This allows us to specify a human-readable description that will appear
    in the generated schema, which is useful for describing the intent of the query
    and its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of parameters, the method takes a `String` parameter called `owner`.
    The `@Name` annotation tells the runtime which name to use when generating the
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Use `@Name` annotations on parameters for portability. Some MP GraphQL implementations
    may not be able to determine the parameter name from the code and will end up
    writing the schema with parameter names such as `arg0`, `arg1`, and so on. The
    `@Name` annotation guarantees that the runtime will generate the specified parameter
    name in the schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing worth noting in the aforementioned code is that instead of returning
    a `string` or other primitive, we are returning a `Portfolio` object. This is
    a custom object in our application. By doing so, the runtime will introspect the
    `Portfolio` Java object and will generate it as an entity in the schema. It will
    also generate any other object that it references. Let''s take a look at the schema
    generated from this code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we see the `Portfolio` type (entity) and its various fields and their
    types. So, the `accountID` field is a `string`; the `total` field is a `float`,
    with the exclamation mark indicating that the value for this field must be non-null;
    the `stocks` field is an array of `Stock` objects, with the square brackets indicating
    an **array**.
  prefs: []
  type: TYPE_NORMAL
- en: We also see the text description for our query. The query section indicates
    that the `portfolio` query takes a single `String` parameter called `owner` and
    returns a `Portfolio` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stock` type is pulled in because it is referenced by the `Portfolio` type.
    Likewise, the `Loyalty` `Portfolio` type. Enums in GraphQL are generated from
    Java `enums` and behave similarly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one last look at the code that generated this schema, and we''ll
    see that the `portfolio` method throws an `UnknownPortfolioException` exception.
    This exception is handled by the framework. When the exception is thrown, the
    framework will return an error response to the client. Let''s see what happens
    when we query for two portfolios—one that exists and one that doesn''t, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.2* shows us that we can send multiple queries in the same request.
    It also shows us that we can receive partial results. In this case, the query
    to find portfolio details for `Emily J` was successful, but the query to find
    portfolio details for `Andy M` failed because his portfolio is not yet in the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a basic understanding of how to create query methods, let's take
    a look at how we can create mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Developing mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we think of **create, read, update, and delete** (**CRUD**) operations,
    queries are the *read* part, while mutations are everything else. That said, queries
    and mutations are just labels—a GraphQL query could certainly create, update,
    or delete entities, and a mutation could simply return a view of an entity, but
    that is not the intended practice.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Query methods should never manipulate entity data. Use queries for returning
    the current state of entities and mutations for changing that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a mutation method, you would just apply the `@Mutation` annotation
    to your Java method. In most cases, mutation methods will take parameters to indicate
    what sort of change to make and/or to specify which entities to update or delete.
    Let''s take a look at how we might use a mutation method to create a `Portfolio`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to notice here. First, the `createNewPortfolio` method
    returns the `Portfolio` object it just created—it actually calls the `portfolio`
    method we wrote in the last section to ensure that the new `Portfolio` object
    was created successfully in the database. Mutations, as with queries, must always
    return something. Void mutation or query methods are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Suggestion
  prefs: []
  type: TYPE_NORMAL
- en: If you really don't want to return anything, consider returning a `boolean`
    value to indicate whether the mutation was completed successfully, or consider
    returning an `int` value, indicating how many entities were created/updated/deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing to notice about this code is that it accepts a complex object
    as a parameter. This will cause some new entries to be generated in the schema.
    Let''s take a look, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These input types look very similar to the types we saw when we generated the
    schema for our query method. The difference is that these types are appended with
    `input`. GraphQL differentiates between types used for input and types used for
    output. One advantage of this is that it means it might be possible for clients
    to view things that they cannot modify or vice versa. So, what might the mutation
    look like in **GraphiQL**? Let''s take a look, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Mutation creating a new portfolio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Mutation creating a new portfolio
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.3* shows how to specify a complex parameter, `portfolio`. The syntax
    is very similar to JSON, but not exactly—notice that the field names are not in
    quotes. Notice also that the mutation specifies a return value, `owner`—a valid
    query or mutation must contain at least one return value.'
  prefs: []
  type: TYPE_NORMAL
- en: A note about parameters and pagination
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in a query or mutation do not need to be related to the underlying
    business entity. You could also use parameters for `pageNumber` and `entriesPerPage`
    so that the client can process the portfolios at its own pace.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've covered queries and mutations, let's take a closer look at entities
    and how we can shape them into what we want in the GraphQL world!
  prefs: []
  type: TYPE_NORMAL
- en: Writing entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities are all complex types (not **scalars**) used for input or output. The
    MP GraphQL runtime will compute all entities that are referenced by root-level
    queries and mutations, and it will automatically add them to the schema. It will
    differentiate between entities that are used as parameters (input) and entities
    used as return values (output). And, as we discovered in the last section, the
    framework will also add entities referenced by other entities that may not necessarily
    be directly referenced by root-level queries and mutations. This includes classes,
    enums, and **interfaces**.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already covered basic classes and enums as entities, so let''s now take
    a look at interfaces. Just as with interfaces in Java, GraphQL interfaces can
    be implemented by concrete GraphQL types. One difference is that input types cannot
    implement interfaces, which can make things tricky. Let''s take a look at an example
    to get a better understanding. Suppose we want to have a portfolio owner *profile*
    that contains the contact information of the account owner. Since some portfolio
    accounts might be managed by somebody other than the owner, we might want two
    different types of profiles—one for single-person owners and one for accounts
    with a designated manager. To meet this requirement, we might code up something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we see the `@Interface` annotation applied to
    the `OwnerProfile` interface. This tells the MP GraphQL framework to treat this
    interface as a GraphQL interface in the schema. The framework will then search
    for implementations of this interface and add them to the schema as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at what the API class might look like, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the API class has separate mutation methods for creating each type
    of profile. This is an unfortunate side effect of GraphQL not allowing input types
    to implement interfaces—even though the Java code implements the interface, the
    GraphQL code does not. This means that the parameters must not be interfaces.
    On the other hand, output types don''t have this limitation, so we can use a single-query
    method that will handle both profile types. The combination of this API class
    and the entity interface and classes will generate a schema that looks like this
    (abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''d expect, the `ManagedOwnerProfileImpl` type implements the `OwnerProfile`
    interface. It has the same fields as the interface, and it also has a couple of
    extra fields. So, how do we access these extra fields in a query? The magic happens
    on *lines 6* and *14* of the query, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Query using interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Query using interfaces
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 11.4*, the `… on ManagedOwnerProfileImpl` code is similar
    to casting the interface to the implementation class and then invoking getter
    methods that only exist on the implementation class in Java. Notice in the output
    that the profile type returned for `Emily J` is not a `ManagedOwnerProfileImpl`
    type, so it does not contain the additional fields.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with Java, interfaces can be quite useful for organizing and reusing
    entities. Now, let's look at how we can further refine entities.
  prefs: []
  type: TYPE_NORMAL
- en: Using entity annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not uncommon to have an entity class that you want to expose as part of
    the GraphQL schema, but maybe rename a field (or exclude one) or make a field
    read-only, or make some other modification. This is possible using annotations
    on entity fields and/or getter/setter methods. Since MP GraphQL integrates with
    **JSON Binding** (**JSON-B**), many of the MP GraphQL-specific annotations can
    be replaced by JSON-B annotations to avoid annotation overload.
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen the `@Name` annotation used on parameters in query/mutation
    methods, but we can also use this annotation on entity fields and getters/setters
    to *rename* the field in the generated GraphQL schema. As with all of the annotations
    described in this section, if you put the annotation on the getter method it will
    only apply to the output type. If you put the annotation on the setter method,
    it will only apply to the input type. If you put it on the field, it will apply
    to both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the annotations that can be quite useful when adding
    entities to your GraphQL applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_11.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents
  prefs: []
  type: TYPE_NORMAL
- en: Applying these annotations to your entity types allows you to better control
    the external view of your model classes and better reuse existing classes.
  prefs: []
  type: TYPE_NORMAL
- en: Outsourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you have an entity with a field that is expensive to compute—maybe it
    requires intensive mathematical computation, or perhaps it requires querying a
    remote database, and so on. It seems wasteful to compute that field when the client
    isn't interested in it. Fortunately, it's possible to avoid expensive computation
    by `@Source` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that the profile service wants to be able to check
    the loyalty level of a given portfolio owner, but that information is in the portfolio
    database, not the profile database. So, in this example, a client wanting to see
    profile data would end up asking the server to connect to two different databases
    to get the results. We can optimize this situation by only checking the portfolio
    database if the client requests the loyalty field. We do this by putting a `getLoyalty(@Source
    OwnerProfileImpl profile)` method in the `ProfileGraphQLApi` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What this does is *adds* a new field, `loyalty`, to the `OwnerProfileImpl` entity
    in the schema. From the client's view, this new field is just like any other field,
    but the `getLoyalty` method is only invoked if the client specifically requests
    that field. This is a useful way to avoid paying for expensive operations when
    the client has no use for the resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Use the `@Source` annotation for expensive data fetching in order to optimize
    server-side performance. This also enables you to reduce memory consumption on
    the server for large queries.
  prefs: []
  type: TYPE_NORMAL
- en: If the `@Source` method throws an exception, the MP GraphQL framework will return
    a null result for that field and will send error data but will continue to send
    the data from other fields as partial results.
  prefs: []
  type: TYPE_NORMAL
- en: Sending partial results using GraphQLException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now seen two ways that we can send `@Source` annotation to outsource a
    field's data fetcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way to send partial results is by using a `GraphQLException` exception.
    This exception allows you to include partial results before throwing the exception
    back to the MP GraphQL framework. The framework will then attempt to send the
    partial results with the error data back to the client. Here is an example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This mutation allows clients to create multiple new portfolios in one request.
    If the client attempts to create a portfolio for an owner that already exists,
    this will cause an exception, but all of the other portfolios will still be created
    and their results will be sent back to the client, along with a list of portfolios
    that could not be created in the error data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to construct a server-side GraphQL application
    in Java using MP GraphQL. While not specifically covered in this section, it should
    be noted that MP GraphQL integrates nicely with other MicroProfile features, such
    as Fault Tolerance and Metrics. The MP GraphQL 1.0 specification is officially
    released and supported in open source Java servers such as Open Liberty, Quarkus,
    and WildFly. Future versions of the specification will add new features such as
    support for subscriptions, the ability to define custom scalars, union types,
    built-in pagination support, and client APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to write simple and advanced GraphQL services
    using MicroProfile APIs. So far, we've only invoked these services using the **GraphiQL**
    tool. In the next section, we'll learn how we can invoke these services using
    Java APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming GraphQL services with client APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client APIs are not officially part of the MP GraphQL specification yet.
    At the time of writing, these APIs are still under development in the **SmallRye
    GraphQL** project, with the intention of formalizing them into the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  prefs: []
  type: TYPE_NORMAL
- en: Since these APIs are not official yet, they are subject to change. The information
    in this section pertains to the SmallRye GraphQL version 1.2.3 client APIs. These
    APIs may change when added to the official MP GraphQL specification, so please
    check with the official documentation at [https://github.com/eclipse/microprofile-graphql](https://github.com/eclipse/microprofile-graphql)
    for any changes.
  prefs: []
  type: TYPE_NORMAL
- en: The MP GraphQL project intends to support two flavors of client APIs. Similar
    to the JAX-RS client and the MicroProfile REST client (see [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*), there is a **dynamic client** API and
    a **type-safe client** API. As with the JAX-RS client, the dynamic client allows
    users to specify the nitty-gritty details of the request, while the type-safe
    client allows users to construct an interface to model the remote service and
    simply invokes it when it wants to make a new request.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these client APIs are demonstrated as integration tests in the GitHub
    repository at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client).
    They test an `allProfiles` query that returns all of the profiles known to the
    server. In our example, we've created two profiles for testing purposes. Let's
    take a look at the dynamic client first.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dynamic client works by building a `DynamicGraphQLClient` instance and
    then passing it as either a `Request` or a `Document` object. The `Request` object
    usually contains a plain text string with the query or mutation you wish to execute,
    while a `Document` object must be constructed programmatically. Let''s take a
    look at the `Request` approach first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we create a new `DynamicGraphQLClient` instance using
    the builder pattern and specifying the `http://localhost:9080/ch11/graphql`. We
    then call the `executeSync` method on that client instance, passing it as `RequestImpl`
    with our query in a plain text string. This returns a `Response` object that we
    can extract a JSON-P `JsonObject` instance from that contains the data from the
    GraphQL result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that we could write this is more like a builder pattern, where
    we build each part of the query into a `Document` object using Java code. Here
    is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we create an `allProfiles` field for the query itself, and then
    create the sub-fields we are interested in: `ownerId` and `emailAddress`. We then
    construct an `Operation` from the query field and a `Document` object from the
    `Operation`. We then pass the `Document` object to the `executeSync` method in
    order to invoke the query, and our `Response` object is the same as in the previous
    code snippet. This may seem more complicated than simply writing up the query
    in plain text, but the advantage is that you could use this approach to build
    more complicated queries depending on the situation—for example, you could programmatically
    request additional fields in your query for certain situations.'
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic client is a nice way to write GraphQL queries and mutations that
    might require changes, depending on when they are invoked. For situations where
    you expect the query to be somewhat static, the type-safe client is more appropriate.
    Let's see what that looks like next.
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type-safe client borrows a lot of its design from the MicroProfile REST
    client. It uses annotations and interfaces to represent the remote service and
    then either a builder pattern or CDI injection to create a client instance. Let''s
    take a look at how we might code this up in an integration test case. First, we''ll
    need to represent the actual response object, the `OwnerProfile` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the same class on the server side. Let''s now see what
    the client interface looks like, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface is annotated with `@GraphQLClientApi` to indicate that it represents
    the remote service. Because we are only interested in the `allProfiles` query,
    we only have one method: `allProfiles`. We could add other methods to match other
    queries or mutations. Since this is a single-query method, we don''t need to annotate
    it with `@Query`, but if we wanted to include mutations, then we would need to
    specify which methods are which, with the `@Query` and `@Mutation` annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now tie this all together with the builder code and the execution, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We build an instance of the `ProfileApi` client interface using `TypesafeGraphQLClientBuilder`.
    Then, once we invoke a method on this interface, the query is sent to the server
    and returns with a list of owner profiles identical to the data returned using
    the dynamic client in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these client options provide a lot of power and flexibility for invoking
    remote GraphQL services, even those not built with MicroProfile—or even Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned about GraphQL and how it addresses some of the
    gaps in REST. We've also learned how to create and consume GraphQL services using
    MP GraphQL, without the overhead of maintaining a schema in addition to Java code.
    We've learned that we can build queries and mutations by applying annotations
    to our API classes and that we can enrich them by adding descriptions, parameters,
    formatting, and more. By outsourcing, we've learned that we can avoid executing
    expensive operations when they are not necessary. We've also learned how to send
    partial results when exceptions occur. We've learned that there are some useful
    tools such as **GraphiQL** that can simplify testing. And while the client APIs
    aren't fully supported from the specification, we've been able to view two different
    clients, and we've seen how we could use them for integration testing or to consume
    GraphQL services.
  prefs: []
  type: TYPE_NORMAL
- en: With what we've learned in this chapter, combined with the tools available at
    our disposal, we are now able to develop and test cloud-native GraphQL applications
    or apply a GraphQL frontend to our existing applications. Our microservices can
    now avoid over-fetching and under-fetching, reducing network traffic and giving
    clients exactly what they want.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the future of MicroProfile and see
    what changes we can expect to see in the years to come.
  prefs: []
  type: TYPE_NORMAL
