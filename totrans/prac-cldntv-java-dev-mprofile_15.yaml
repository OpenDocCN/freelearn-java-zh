- en: '*Chapter 11***: MicroProfile GraphQL**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章***：MicroProfile GraphQL**'
- en: '**GraphQL** is a distributed query language that addresses some of the shortcomings
    of **REpresentational State Transfer** (**REST**). In particular, GraphQL addresses
    the notions of **over-fetching** (receiving more data than the client intended)
    and **under-fetching** (requiring the client to make multiple requests to get
    the data it requires). GraphQL applications make use of a schema file that presents
    clients with the queries and mutations at its disposal, as well as the entities
    it can access and manipulate.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 是一种分布式查询语言，它解决了 **REpresentational State Transfer** （**REST**）
    的一些缺点。特别是，GraphQL 解决了 **过度获取**（接收比客户端预期更多的数据）和 **不足获取**（要求客户端发出多个请求以获取所需的数据）的概念。GraphQL
    应用程序利用一个模式文件，向客户端展示其可用的查询和突变，以及它可以访问和操作的对象。'
- en: The ease of use and robustness of GraphQL explains why its popularity is growing,
    especially in cloud-native applications. **MicroProfile GraphQL** (**MP GraphQL**)
    makes it easy to create GraphQL-based applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的易用性和健壮性解释了为什么它的受欢迎程度在增长，尤其是在云原生应用中。**MicroProfile GraphQL** （**MP GraphQL**）
    使得创建基于 GraphQL 的应用变得简单。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding GraphQL basics and when to use it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GraphQL 基础知识及其适用场景
- en: Building services with MP GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MP GraphQL 构建服务
- en: Consuming GraphQL services with client **application programming interfaces**
    (**APIs**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端 **应用程序编程接口** （**APIs**） 消费 GraphQL 服务
- en: By the end of this chapter, you will have learned what GraphQL is and when it
    is appropriate to use it, and you will be able to build your own GraphQL application
    ready to deploy in open source, cloud-ready servers such as Open Liberty.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 GraphQL 是什么以及何时适合使用它，并且您将能够构建自己的 GraphQL 应用程序，准备在开源、云就绪服务器（如 Open
    Liberty）上部署。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To build and run the samples mentioned in this chapter, you will need a Mac
    or PC (Windows or Linux) with the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中提到的示例，您需要一个装有以下软件的 Mac 或 PC（Windows 或 Linux）：
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包** （**JDK**） 版本 8 或更高 ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 客户端 ([https://git-scm.com/](https://git-scm.com/))
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码都可以在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11)。
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server where these code samples will execute by entering the `Chapter11` directory
    and executing the following command from the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经克隆了 GitHub 仓库，您可以通过进入 `Chapter11` 目录并在命令行中执行以下命令来启动 Open Liberty 服务器，这些代码示例将在其中执行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过按 *Ctrl + C* 在同一个命令窗口中停止服务器。
- en: Now we've got the prerequisites taken care of, let's start by learning the basics
    of GraphQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了先决条件，让我们从学习 GraphQL 的基础知识开始。
- en: Understanding GraphQL basics and when to use it
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GraphQL 基础知识及其适用场景
- en: As with REST, GraphQL is a means of accessing and modifying remote data over
    web-based transports. It uses a publicly visible schema, allowing clients to know
    exactly which entities it can query, which fields can be modified, and so on.
    This is similar to how OpenAPI describes RESTful APIs. The schema acts as a contract
    between the client and the service. GraphQL strictly enforces the schema, preventing
    clients from accessing or modifying entities or fields that are not defined within
    it. This strictness provides a lot of freedom for developers of both clients and
    services, which we'll cover later in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL supports the following operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` requests in REST.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations**: Mutations are used for modifying data—that is, creating, updating,
    and/or deleting it.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriptions**: Subscriptions are used so that clients can receive notifications
    of specific events, such as when a particular entity has been created or a field
    has dropped below a certain threshold, or even unrelated events.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike REST, where different parts of the API are spread out across multiple
    **HyperText Transfer Protocol** (**HTTP**) endpoints, GraphQL applications typically
    use a single HTTP endpoint, and the operations are embedded in the HTTP request's
    body.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL operations and schemas use their own syntax, but the response is in
    **JavaScript Object Notation** (**JSON**) format. This allows GraphQL services
    and clients to be written in any language. While we plan to cover creating services
    in Java, it is also currently possible to write service and client applications
    in JavaScript, Python, Go, Haskell, Perl, Ruby, Scala, and many others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema defines the types of entities accessible for the service, as well
    as the operations that can be performed. Built-in or primitive GraphQL types are
    called **scalars**. Any service is free to define its own scalar types, but the
    GraphQL specification states that all services must use at least these five standard
    scalars:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`int`—A 32-bit signed integer'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`—Signed double-precision floating-point number'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`—A sequence of characters using **Unicode Transformation Format-8**
    (**UTF-8**) encoding'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`—`true` or `false`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ID`—A string that is intended to be a unique **identifier** (**ID**) for an
    entity; it is not intended to be human-readable'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL objects can be made up of scalars or other objects. Each operation must
    explicitly specify all fields that it wishes to view in the response. For complex
    types (types that include other types or scalars), this might mean specifying
    fields several layers deep.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Requiring clients to specify all fields in a query ensures backward compatibility
    when you add new fields to existing objects. A client cannot be caught off guard
    if a new field appears on an object since their existing query didn't specify
    it!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of requiring clients to specify all fields that they are interested
    in is that it avoids **over-fetching**. Over-fetching occurs when more data is
    sent over the network than is necessary. One common example of over-fetching in
    REST is weather data. If you issue a RESTful request to check the current conditions
    for a particular location from various weather sites, you will see an enormous
    amount of information, but most of that data is unused when you just wanted to
    know what the outside temperature is and whether or not it's raining.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: By sending queries as the payload of an HTTP request, GraphQL also avoids **under-fetching**.
    As you've probably guessed, under-fetching occurs when the data returned is insufficient.
    Using the weather example, suppose you also wanted to know the temperature at
    your friends' homes in other cities. You'd have to issue similar RESTful requests
    to the weather site for each location. But in GraphQL, you can issue multiple
    queries in a single HTTP request, enabling you to get exactly the data you need
    with a single round trip to the server and making it fast and efficient!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Queries and mutations have their own syntax, though it is similar to JSON and
    other query languages. Generally, these operations start with `query` or `mutation`
    and then a label for the operation, then, inside curly braces, you would specify
    the query or mutation to invoke with any parameters inside parentheses. You would
    then add the fields you are interested in inside curly braces. We'll see some
    example queries and mutations later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL also allows `503` (service unavailable) error. Some data is still better
    than none, right?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Since the schema is exposed to clients, various tools can introspect the schema,
    allowing users to construct queries and mutations and test them in real time.
    One such tool, which we'll discuss later, is called **GraphiQL** ([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: While REST is still the more widely used communication architecture in the cloud,
    GraphQL is quickly gaining in popularity as it addresses many of the gaps in REST.
    So, which approach is right for you? The answer, as with most things, is *it depends*.
    GraphQL primarily only works with JSON as the response type; if you want to use
    other data types, you might want to consider REST or an alternative approach.
    If your data is hierarchical in nature, it might lend itself better to REST.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is security-based in relation to `/public/*`) while restricting
    access to other entities (for example, `/private/*`). This isn't possible in GraphQL
    without splitting the service into separate public and private services, which
    might not be ideal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, HTTP caching is more complicated with GraphQL. Since REST uses URI
    paths, both clients and servers can cache entity results based on the path used.
    It is possible to cache based on paths in GraphQL, but this would require clients
    to pass their queries as HTTP `GET` query parameters. This could be cumbersome
    for the client, as well as being a potential security risk as proxy servers would
    be able to see query parameters, and you may still have issues with caching, depending
    on the spacing and formatting of the query. Fortunately, most implementations
    of GraphQL use query caching on the server side to reduce unnecessary duplication
    of work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: So, when would you use GraphQL? GraphQL tends to cost a little more on the server
    (in order to filter results to get the client exactly what it wants), but that
    trade-off means that client-side processing is significantly reduced. So, if you
    have a lot of clients or want to optimize your client performance, GraphQL is
    a good approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL tends to reduce network traffic since it avoids under-fetching and over-fetching.
    In environments where network bandwidth is expensive, GraphQL is ideal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that nothing prevents you from writing both GraphQL
    and RESTful APIs for the same service. This might add more maintenance, but it
    allows your clients to choose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand what GraphQL is and when we should use it, let's explore how
    we can build GraphQL applications using MicroProfile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Building services with MP GraphQL
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to develop a GraphQL application using the
    MP GraphQL APIs and runtime framework. We'll cover building queries and mutations,
    and how to invoke them using an interactive web tool called **GraphiQL**. We'll
    also cover entities and enumerated types. Finally, we'll cover a technique to
    reduce unnecessary server-side computations and deliver partial results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Most GraphQL APIs for Java require you to write a schema first and then build
    the Java code around it. This approach tends to cause some level of dual maintenance,
    and it can slow down development as you evolve your application. MP GraphQL uses
    a `Hello World` query service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Developing queries
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with JAX-RS, MP GraphQL is based on annotations. The first annotation to
    consider is `@GraphQLApi`. This annotation is a **Contexts and Dependency Injection**
    (**CDI**) bean-defining annotation, which means that when you apply this annotation
    to a class, it becomes a CDI bean. This enables the CDI framework to manage its
    life cycle and inject dependencies. This annotation is required on classes that
    contain query or mutation methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The next annotation we''ll consider is `@Query`. When this annotation is applied
    to methods, it tells the MP GraphQL runtime to create a top-level query in the
    schema. Let''s see a simple example, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `@GraphQLApi` annotation tells the runtime to manage the life cycle of
    this bean, and the `@Query` annotation tells the runtime to generate a query in
    the schema with no parameters that returns a `String` scalar. If we run this example
    in an MP GraphQL server such as Open Liberty, we can then see the schema file
    by browsing to `http://localhost:9080/ch11/graphql/schema.graphql`. Then, we''ll
    see something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GraphQLApi`注解告诉运行时管理此bean的生命周期，而`@Query`注解告诉运行时在模式中生成一个无参数的查询，该查询返回一个`String`标量。如果我们在一个MP
    GraphQL服务器（如Open Liberty）上运行此示例，然后我们可以通过浏览到`http://localhost:9080/ch11/graphql/schema.graphql`来查看模式文件。然后，我们会看到类似这样的：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `http://localhost:9080/ch11/graphql-ui` and then enter this query string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`http://localhost:9080/ch11/graphql-ui`然后输入以下查询字符串：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, click the triangular *play* button to see the results. You should see
    something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击三角形的*播放*按钮查看结果。你应该看到类似这样的：
- en: '![Figure 11.1 – Simple query in GraphiQL'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – GraphiQL中的简单查询'
- en: '](img/B17377_11_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_11_01.jpg)'
- en: Figure 11.1 – Simple query in GraphiQL
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – GraphiQL中的简单查询
- en: Notice that the result is a JSON object with a field labeled `data`. The results
    of the query are always under the `data` field. If an error were to occur, there
    would be a separate `errors` field instead of, or in addition to, the `data` field.
    This field would include details of the error(s).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果是带有标签`data`的JSON对象。查询的结果始终位于`data`字段下。如果发生错误，将会有一个单独的`errors`字段，而不是`data`字段，或者与`data`字段一起。该字段将包括错误详情。
- en: This is a nice start, and you can probably guess that you could have multiple
    query methods in this class that could return different data, but queries are
    much more powerful when they have parameters. In previous chapters, we've been
    working with the **Stock Trader** application. Let's GraphQL-ize that application
    in our following examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的开始，你可能会猜到在这个类中可以有多个查询方法，它们可以返回不同的数据，但带有参数的查询要强大得多。在之前的章节中，我们一直在处理**股票交易员**应用程序。让我们在我们的后续示例中将该应用程序GraphQL化。
- en: 'If we want the client to be able to specify parameters to a query, we simply
    add Java method parameters to the `@Query`-annotated methods. Let''s take a look
    at what we might do for the `Portfolio` service, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让客户端能够指定查询的参数，我们只需将Java方法参数添加到`@Query`注解的方法中。让我们看看`Portfolio`服务可能的做法，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few new things to consider here. First, we inject `PortfolioDatabase`
    instance. This is nothing more than a wrapper around a `HashMap`, but it could
    just as well access a real relational or NoSQL database to retrieve stock portfolio
    data. CDI injects this for us. *Muchas gracias!*
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新事物需要考虑。首先，我们注入`PortfolioDatabase`实例。这不过是一个`HashMap`的包装器，但它也可以访问真实的SQL或NoSQL数据库来检索股票投资组合数据。CDI为我们注入了它。*非常感谢！*
- en: Next, the `portfolio` query method also has a `@Description` annotation applied
    to it. This allows us to specify a human-readable description that will appear
    in the generated schema, which is useful for describing the intent of the query
    and its parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`portfolio`查询方法也应用了`@Description`注解。这允许我们指定一个人类可读的描述，该描述将出现在生成的模式中，这对于描述查询及其参数的意图很有用。
- en: Speaking of parameters, the method takes a `String` parameter called `owner`.
    The `@Name` annotation tells the runtime which name to use when generating the
    schema.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 说到参数，该方法接受一个名为`owner`的`String`参数。`@Name`注解告诉运行时在生成模式时使用哪个名称。
- en: Best practice
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use `@Name` annotations on parameters for portability. Some MP GraphQL implementations
    may not be able to determine the parameter name from the code and will end up
    writing the schema with parameter names such as `arg0`, `arg1`, and so on. The
    `@Name` annotation guarantees that the runtime will generate the specified parameter
    name in the schema.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Name`注解在参数上以实现可移植性。某些MP GraphQL实现可能无法从代码中确定参数名称，并最终使用`arg0`、`arg1`等参数名称编写模式。`@Name`注解确保运行时将在模式中生成指定的参数名称。
- en: 'Another thing worth noting in the aforementioned code is that instead of returning
    a `string` or other primitive, we are returning a `Portfolio` object. This is
    a custom object in our application. By doing so, the runtime will introspect the
    `Portfolio` Java object and will generate it as an entity in the schema. It will
    also generate any other object that it references. Let''s take a look at the schema
    generated from this code, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we see the `Portfolio` type (entity) and its various fields and their
    types. So, the `accountID` field is a `string`; the `total` field is a `float`,
    with the exclamation mark indicating that the value for this field must be non-null;
    the `stocks` field is an array of `Stock` objects, with the square brackets indicating
    an **array**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We also see the text description for our query. The query section indicates
    that the `portfolio` query takes a single `String` parameter called `owner` and
    returns a `Portfolio` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `Stock` type is pulled in because it is referenced by the `Portfolio` type.
    Likewise, the `Loyalty` `Portfolio` type. Enums in GraphQL are generated from
    Java `enums` and behave similarly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one last look at the code that generated this schema, and we''ll
    see that the `portfolio` method throws an `UnknownPortfolioException` exception.
    This exception is handled by the framework. When the exception is thrown, the
    framework will return an error response to the client. Let''s see what happens
    when we query for two portfolios—one that exists and one that doesn''t, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2 – Multiple queries: one successful, one failing with an expected
    exception'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.2* shows us that we can send multiple queries in the same request.
    It also shows us that we can receive partial results. In this case, the query
    to find portfolio details for `Emily J` was successful, but the query to find
    portfolio details for `Andy M` failed because his portfolio is not yet in the
    database.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a basic understanding of how to create query methods, let's take
    a look at how we can create mutations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Developing mutations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we think of **create, read, update, and delete** (**CRUD**) operations,
    queries are the *read* part, while mutations are everything else. That said, queries
    and mutations are just labels—a GraphQL query could certainly create, update,
    or delete entities, and a mutation could simply return a view of an entity, but
    that is not the intended practice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Query methods should never manipulate entity data. Use queries for returning
    the current state of entities and mutations for changing that data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a mutation method, you would just apply the `@Mutation` annotation
    to your Java method. In most cases, mutation methods will take parameters to indicate
    what sort of change to make and/or to specify which entities to update or delete.
    Let''s take a look at how we might use a mutation method to create a `Portfolio`
    object, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a few things to notice here. First, the `createNewPortfolio` method
    returns the `Portfolio` object it just created—it actually calls the `portfolio`
    method we wrote in the last section to ensure that the new `Portfolio` object
    was created successfully in the database. Mutations, as with queries, must always
    return something. Void mutation or query methods are not allowed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Suggestion
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: If you really don't want to return anything, consider returning a `boolean`
    value to indicate whether the mutation was completed successfully, or consider
    returning an `int` value, indicating how many entities were created/updated/deleted.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing to notice about this code is that it accepts a complex object
    as a parameter. This will cause some new entries to be generated in the schema.
    Let''s take a look, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These input types look very similar to the types we saw when we generated the
    schema for our query method. The difference is that these types are appended with
    `input`. GraphQL differentiates between types used for input and types used for
    output. One advantage of this is that it means it might be possible for clients
    to view things that they cannot modify or vice versa. So, what might the mutation
    look like in **GraphiQL**? Let''s take a look, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Mutation creating a new portfolio'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Mutation creating a new portfolio
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.3* shows how to specify a complex parameter, `portfolio`. The syntax
    is very similar to JSON, but not exactly—notice that the field names are not in
    quotes. Notice also that the mutation specifies a return value, `owner`—a valid
    query or mutation must contain at least one return value.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: A note about parameters and pagination
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in a query or mutation do not need to be related to the underlying
    business entity. You could also use parameters for `pageNumber` and `entriesPerPage`
    so that the client can process the portfolios at its own pace.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Now we've covered queries and mutations, let's take a closer look at entities
    and how we can shape them into what we want in the GraphQL world!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Writing entities
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities are all complex types (not **scalars**) used for input or output. The
    MP GraphQL runtime will compute all entities that are referenced by root-level
    queries and mutations, and it will automatically add them to the schema. It will
    differentiate between entities that are used as parameters (input) and entities
    used as return values (output). And, as we discovered in the last section, the
    framework will also add entities referenced by other entities that may not necessarily
    be directly referenced by root-level queries and mutations. This includes classes,
    enums, and **interfaces**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL interfaces
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already covered basic classes and enums as entities, so let''s now take
    a look at interfaces. Just as with interfaces in Java, GraphQL interfaces can
    be implemented by concrete GraphQL types. One difference is that input types cannot
    implement interfaces, which can make things tricky. Let''s take a look at an example
    to get a better understanding. Suppose we want to have a portfolio owner *profile*
    that contains the contact information of the account owner. Since some portfolio
    accounts might be managed by somebody other than the owner, we might want two
    different types of profiles—one for single-person owners and one for accounts
    with a designated manager. To meet this requirement, we might code up something
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we see the `@Interface` annotation applied to
    the `OwnerProfile` interface. This tells the MP GraphQL framework to treat this
    interface as a GraphQL interface in the schema. The framework will then search
    for implementations of this interface and add them to the schema as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at what the API class might look like, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the API class has separate mutation methods for creating each type
    of profile. This is an unfortunate side effect of GraphQL not allowing input types
    to implement interfaces—even though the Java code implements the interface, the
    GraphQL code does not. This means that the parameters must not be interfaces.
    On the other hand, output types don''t have this limitation, so we can use a single-query
    method that will handle both profile types. The combination of this API class
    and the entity interface and classes will generate a schema that looks like this
    (abbreviated):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we''d expect, the `ManagedOwnerProfileImpl` type implements the `OwnerProfile`
    interface. It has the same fields as the interface, and it also has a couple of
    extra fields. So, how do we access these extra fields in a query? The magic happens
    on *lines 6* and *14* of the query, as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Query using interfaces'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_11_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Query using interfaces
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 11.4*, the `… on ManagedOwnerProfileImpl` code is similar
    to casting the interface to the implementation class and then invoking getter
    methods that only exist on the implementation class in Java. Notice in the output
    that the profile type returned for `Emily J` is not a `ManagedOwnerProfileImpl`
    type, so it does not contain the additional fields.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Just as with Java, interfaces can be quite useful for organizing and reusing
    entities. Now, let's look at how we can further refine entities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Using entity annotations
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not uncommon to have an entity class that you want to expose as part of
    the GraphQL schema, but maybe rename a field (or exclude one) or make a field
    read-only, or make some other modification. This is possible using annotations
    on entity fields and/or getter/setter methods. Since MP GraphQL integrates with
    **JSON Binding** (**JSON-B**), many of the MP GraphQL-specific annotations can
    be replaced by JSON-B annotations to avoid annotation overload.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen the `@Name` annotation used on parameters in query/mutation
    methods, but we can also use this annotation on entity fields and getters/setters
    to *rename* the field in the generated GraphQL schema. As with all of the annotations
    described in this section, if you put the annotation on the getter method it will
    only apply to the output type. If you put the annotation on the setter method,
    it will only apply to the input type. If you put it on the field, it will apply
    to both.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the annotations that can be quite useful when adding
    entities to your GraphQL applications:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_11.1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Applying these annotations to your entity types allows you to better control
    the external view of your model classes and better reuse existing classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Outsourcing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you have an entity with a field that is expensive to compute—maybe it
    requires intensive mathematical computation, or perhaps it requires querying a
    remote database, and so on. It seems wasteful to compute that field when the client
    isn't interested in it. Fortunately, it's possible to avoid expensive computation
    by `@Source` annotation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that the profile service wants to be able to check
    the loyalty level of a given portfolio owner, but that information is in the portfolio
    database, not the profile database. So, in this example, a client wanting to see
    profile data would end up asking the server to connect to two different databases
    to get the results. We can optimize this situation by only checking the portfolio
    database if the client requests the loyalty field. We do this by putting a `getLoyalty(@Source
    OwnerProfileImpl profile)` method in the `ProfileGraphQLApi` class, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What this does is *adds* a new field, `loyalty`, to the `OwnerProfileImpl` entity
    in the schema. From the client's view, this new field is just like any other field,
    but the `getLoyalty` method is only invoked if the client specifically requests
    that field. This is a useful way to avoid paying for expensive operations when
    the client has no use for the resulting data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Use the `@Source` annotation for expensive data fetching in order to optimize
    server-side performance. This also enables you to reduce memory consumption on
    the server for large queries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If the `@Source` method throws an exception, the MP GraphQL framework will return
    a null result for that field and will send error data but will continue to send
    the data from other fields as partial results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Sending partial results using GraphQLException
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now seen two ways that we can send `@Source` annotation to outsource a
    field's data fetcher.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way to send partial results is by using a `GraphQLException` exception.
    This exception allows you to include partial results before throwing the exception
    back to the MP GraphQL framework. The framework will then attempt to send the
    partial results with the error data back to the client. Here is an example of
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This mutation allows clients to create multiple new portfolios in one request.
    If the client attempts to create a portfolio for an owner that already exists,
    this will cause an exception, but all of the other portfolios will still be created
    and their results will be sent back to the client, along with a list of portfolios
    that could not be created in the error data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to construct a server-side GraphQL application
    in Java using MP GraphQL. While not specifically covered in this section, it should
    be noted that MP GraphQL integrates nicely with other MicroProfile features, such
    as Fault Tolerance and Metrics. The MP GraphQL 1.0 specification is officially
    released and supported in open source Java servers such as Open Liberty, Quarkus,
    and WildFly. Future versions of the specification will add new features such as
    support for subscriptions, the ability to define custom scalars, union types,
    built-in pagination support, and client APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to write simple and advanced GraphQL services
    using MicroProfile APIs. So far, we've only invoked these services using the **GraphiQL**
    tool. In the next section, we'll learn how we can invoke these services using
    Java APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Consuming GraphQL services with client APIs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client APIs are not officially part of the MP GraphQL specification yet.
    At the time of writing, these APIs are still under development in the **SmallRye
    GraphQL** project, with the intention of formalizing them into the specification.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Since these APIs are not official yet, they are subject to change. The information
    in this section pertains to the SmallRye GraphQL version 1.2.3 client APIs. These
    APIs may change when added to the official MP GraphQL specification, so please
    check with the official documentation at [https://github.com/eclipse/microprofile-graphql](https://github.com/eclipse/microprofile-graphql)
    for any changes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The MP GraphQL project intends to support two flavors of client APIs. Similar
    to the JAX-RS client and the MicroProfile REST client (see [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*), there is a **dynamic client** API and
    a **type-safe client** API. As with the JAX-RS client, the dynamic client allows
    users to specify the nitty-gritty details of the request, while the type-safe
    client allows users to construct an interface to model the remote service and
    simply invokes it when it wants to make a new request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Both of these client APIs are demonstrated as integration tests in the GitHub
    repository at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client).
    They test an `allProfiles` query that returns all of the profiles known to the
    server. In our example, we've created two profiles for testing purposes. Let's
    take a look at the dynamic client first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic client
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dynamic client works by building a `DynamicGraphQLClient` instance and
    then passing it as either a `Request` or a `Document` object. The `Request` object
    usually contains a plain text string with the query or mutation you wish to execute,
    while a `Document` object must be constructed programmatically. Let''s take a
    look at the `Request` approach first, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code snippet, we create a new `DynamicGraphQLClient` instance using
    the builder pattern and specifying the `http://localhost:9080/ch11/graphql`. We
    then call the `executeSync` method on that client instance, passing it as `RequestImpl`
    with our query in a plain text string. This returns a `Response` object that we
    can extract a JSON-P `JsonObject` instance from that contains the data from the
    GraphQL result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that we could write this is more like a builder pattern, where
    we build each part of the query into a `Document` object using Java code. Here
    is an example of this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, we create an `allProfiles` field for the query itself, and then
    create the sub-fields we are interested in: `ownerId` and `emailAddress`. We then
    construct an `Operation` from the query field and a `Document` object from the
    `Operation`. We then pass the `Document` object to the `executeSync` method in
    order to invoke the query, and our `Response` object is the same as in the previous
    code snippet. This may seem more complicated than simply writing up the query
    in plain text, but the advantage is that you could use this approach to build
    more complicated queries depending on the situation—for example, you could programmatically
    request additional fields in your query for certain situations.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic client is a nice way to write GraphQL queries and mutations that
    might require changes, depending on when they are invoked. For situations where
    you expect the query to be somewhat static, the type-safe client is more appropriate.
    Let's see what that looks like next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe client
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type-safe client borrows a lot of its design from the MicroProfile REST
    client. It uses annotations and interfaces to represent the remote service and
    then either a builder pattern or CDI injection to create a client instance. Let''s
    take a look at how we might code this up in an integration test case. First, we''ll
    need to represent the actual response object, the `OwnerProfile` object, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is very similar to the same class on the server side. Let''s now see what
    the client interface looks like, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This interface is annotated with `@GraphQLClientApi` to indicate that it represents
    the remote service. Because we are only interested in the `allProfiles` query,
    we only have one method: `allProfiles`. We could add other methods to match other
    queries or mutations. Since this is a single-query method, we don''t need to annotate
    it with `@Query`, but if we wanted to include mutations, then we would need to
    specify which methods are which, with the `@Query` and `@Mutation` annotations.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now tie this all together with the builder code and the execution, as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We build an instance of the `ProfileApi` client interface using `TypesafeGraphQLClientBuilder`.
    Then, once we invoke a method on this interface, the query is sent to the server
    and returns with a list of owner profiles identical to the data returned using
    the dynamic client in the previous section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Both of these client options provide a lot of power and flexibility for invoking
    remote GraphQL services, even those not built with MicroProfile—or even Java.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned about GraphQL and how it addresses some of the
    gaps in REST. We've also learned how to create and consume GraphQL services using
    MP GraphQL, without the overhead of maintaining a schema in addition to Java code.
    We've learned that we can build queries and mutations by applying annotations
    to our API classes and that we can enrich them by adding descriptions, parameters,
    formatting, and more. By outsourcing, we've learned that we can avoid executing
    expensive operations when they are not necessary. We've also learned how to send
    partial results when exceptions occur. We've learned that there are some useful
    tools such as **GraphiQL** that can simplify testing. And while the client APIs
    aren't fully supported from the specification, we've been able to view two different
    clients, and we've seen how we could use them for integration testing or to consume
    GraphQL services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: With what we've learned in this chapter, combined with the tools available at
    our disposal, we are now able to develop and test cloud-native GraphQL applications
    or apply a GraphQL frontend to our existing applications. Our microservices can
    now avoid over-fetching and under-fetching, reducing network traffic and giving
    clients exactly what they want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the future of MicroProfile and see
    what changes we can expect to see in the years to come.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
