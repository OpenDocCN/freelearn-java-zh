<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Playing with Data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Playing with Data</h1></div></div></div><div class="blockquote"><blockquote class="blockquote1"><p class="calibre20">"Any program is only as good as it is useful."</p><p class="calibre20">—Linus Torvalds</p></blockquote></div><p class="calibre9">Enterprise applications store, retrieve, transmit, manipulate, and analyze data. Storing, processing, and analyzing data is very critical to any business. The <span class="strong"><strong class="calibre10">Business Intelligence</strong></span> (<span class="strong"><strong class="calibre10">BI</strong></span>) process transforms data into meaningful information for business. BI analyzes statistical data and helps with decision making and predictions for businesses, such as risk assessment, planning and forecasting, and analyzing buying trends. Information can<a id="id612" class="calibre1"/> be stored in a file or to a database. Querying and accessing data from a relational database is easier than the file system. This chapter covers the unit testing of the database layer. The following topics are covered in depth:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Separation of concerns</li><li class="listitem">Unit testing the persistence layer</li><li class="listitem">Writing clean data access code using Spring JDBC</li><li class="listitem">Integration testing of JDBC code</li><li class="listitem">Integration testing of Spring JDBC</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Playing with Data">
<div class="book" title="Separating concerns"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec42" class="calibre1"/>Separating concerns</h1></div></div></div><p class="calibre9">This section elaborates on the separation of concerns. Enterprise application information can be represented using the following building blocks:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre10">What</strong></span>: This represents the<a id="id613" class="calibre1"/> information to store. We cannot store everything; so, categorization of the data to<a id="id614" class="calibre1"/> be stored is<a id="id615" class="calibre1"/> very important.</li><li class="listitem"><span class="strong"><strong class="calibre10">Who</strong></span>: This represents the actors. Information is <a id="id616" class="calibre1"/>a sensitive thing and it's important to control access across users; for example, an employee<a id="id617" class="calibre1"/> should not be able to access the salary information of <a id="id618" class="calibre1"/>another employee, but a manager or member of HR staff can access salary data of the staff.</li><li class="listitem"><span class="strong"><strong class="calibre10">Data store</strong></span>: This<a id="id619" class="calibre1"/> represents information<a id="id620" class="calibre1"/> and its <a id="id621" class="calibre1"/>accessibility.</li><li class="listitem"><span class="strong"><strong class="calibre10">Process</strong></span>: This represents the<a id="id622" class="calibre1"/> processing <a id="id623" class="calibre1"/>of data. Any information doesn't make <a id="id624" class="calibre1"/>any sense unless some action is performed on it.</li></ul></div><p class="calibre9">The following diagram describes the key information blocks of an enterprise application:</p><div class="mediaobject"><img src="../images/00112.jpeg" alt="Separating concerns" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">This section covers the <span class="strong"><strong class="calibre10">Store</strong></span> block and unit testing the data access layer.</p><p class="calibre9">The following diagram represents the components of a loosely coupled application:</p><div class="mediaobject"><img src="../images/00113.jpeg" alt="Separating concerns" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The view component represents<a id="id625" class="calibre1"/> the JSPs, taglibs, widgets, and so on. Writing automated JUnit tests for the view components is not easy and requires manual effort. We'll skip the view components in this chapter.</p><p class="calibre9">We unit tested the controller logic component in <a class="calibre1" title="Chapter 7. Unit Testing the Web Tier" href="part0043_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre11">Unit Testing the Web Tier</em></span>.</p><p class="calibre9">Controller logic component<a id="id626" class="calibre1"/> accesses the business logic component. The business logic component performs the business logic and delegates data access to the persistence logic component. We'll cover the unit testing of business logic in the forthcoming chapters. Mock objects are used to mimic the persistence or data access layer.</p><p class="calibre9">The persistence <a id="id627" class="calibre1"/>logic layer or database client layer is responsible for managing the database connection, retrieving data from a database, and storing data back in the database. Unit testing the data access layer is very important; if anything goes wrong in this layer, the application will fail. We can unit test the data access logic in isolation from the database, and perform the integration test to verify the application and database integrity.</p><p class="calibre9">You can have 100 percent test coverage of your database access code. However, if this code is misused by the controllers and/or the view layer, the whole application is useless. You need integration tests to verify the wiring, which will be covered later.</p><p class="calibre9">Databases represent a data store or a relational database.</p><p class="calibre9">Separating the data access layer from the business logic layer helps us to make changes to the database without affecting the business logic layer, and it allows us to unit test the business logic layer in isolation from the database. Suppose you are using the MySQL database and you want to migrate to SQL server. Then, in that case, you don't have to touch the business logic layer.</p></div></div>
<div class="book" title="Unit testing the persistence logic"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec43" class="calibre1"/>Unit testing the persistence logic</h1></div></div></div><p class="calibre9">In this section, we'll build a Phonebook application and store phone numbers. We'll use the <span class="strong"><strong class="calibre10">Apache Derby</strong></span> database for persistence. Derby <a id="id628" class="calibre1"/>can be downloaded from <a class="calibre1" href="http://db.apache.org/derby/">http://db.apache.org/derby/</a>.</p><p class="calibre9">You can use better built-in databases such as H2. It has more features and is less restrictive than Derby; however, we're using Derby for simplicity.</p><p class="calibre9">The following are the <a id="id629" class="calibre1"/>steps to run Derby:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Download the binary media file and extract the media to a preferred location. We'll refer to it as <code class="literal">DERBY_HOME</code> in the next steps.</li><li class="listitem" value="2">On a Windows<a id="id630" class="calibre1"/> machine, go to <code class="literal">DERBY_HOME\bin</code> and execute the <code class="literal">startNetworkServer.bat</code> file.</li><li class="listitem" value="3">It will launch a command prompt and print a message to the console that the database server has started, such as <span class="strong"><strong class="calibre10">started and ready to accept connections on port 1527</strong></span>.</li></ol><div class="calibre17"/></div><p class="calibre9">We will create a Java project to test the Phonebook application. Follow the ensuing steps to build the application:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Launch Eclipse and create a<a id="id631" class="calibre1"/> Java project named <span class="strong"><strong class="calibre10">DatabaseAccess</strong></span>.</li><li class="listitem" value="2">Add a <code class="literal">PhoneEntry</code> class to store phone details. The following are the class details:<div class="informalexample"><pre class="programlisting">package com.packt.database.model;

public class PhoneEntry implements Serializable {

  private static final long serialVersionUID = 1L;

  private String phoneNumber;
  private String firstName;
  private String lastName;
  
  // getters and setters
}</pre></div></li><li class="listitem" value="3">Create a data access interface<a id="id632" class="calibre1"/> for Phonebook. The following <a id="id633" class="calibre1"/>are the API details:<div class="informalexample"><pre class="programlisting">package com.packt.database.dao;

import java.util.List;
import com.packt.database.model.PhoneEntry;

public interface PhoneBookDao {
  boolean create(PhoneEntry entry);

  boolean update(PhoneEntry entryToUpdate);

  List&lt;PhoneEntry&gt; searchByNumber(String number);

  List&lt;PhoneEntry&gt; searchByFirstName(String firstName);

  List&lt;PhoneEntry&gt; searchByLastName(String lastName);

  boolean delete(String number);
}</pre></div></li><li class="listitem" value="4">Create a database access interface implementation to communicate with the database. The following are the data access object details:<div class="informalexample"><pre class="programlisting">public class PhoneBookDerbyDao implements PhoneBookDao {

  private String driver = "org.apache.derby.jdbc.EmbeddedDriver";
  private String protocol = "jdbc:derby:";
  private String userId = "dbo";
  private String dbName = "phoneBook";

  public PhoneBookDerbyDao() {
    <span class="strong"><strong class="calibre10">loadDriver</strong></span>();
  }

  protected void <span class="strong"><strong class="calibre10">loadDriver</strong></span>() {
    try {
      Class.forName(driver).newInstance();
    } catch (ClassNotFoundException cnfe) {
      cnfe.printStackTrace(System.err);
    } catch (InstantiationException ie) {
      ie.printStackTrace(System.err);
    } catch (IllegalAccessException iae) {
      iae.printStackTrace(System.err);
    }
  }

  protected Connection getConnection() throws SQLException {
    Connection conn = null;
    Properties props = new Properties();        
    props.put("user", userId);
    <span class="strong"><strong class="calibre10">conn = DriverManager.getConnection(protocol + dbName + ";create=true",props);</strong></span>
    conn.setAutoCommit(false);
    return conn;
  }
}</pre></div><p class="calibre15">Note that the <code class="literal">PhoneBookDerbyDao</code> class is a Derby implementation of the dao. It has configuration attributes such as <code class="literal">driver</code>, <code class="literal">protocol</code>, and <code class="literal">dbName</code>, and getters or setters. The <code class="literal">loadDriver()</code> method<a id="id634" class="calibre1"/> loads the database driver <a id="id635" class="calibre1"/>and gets invoked from the <code class="literal">PhoneBookDerbyDao</code> constructor. The <a id="id636" class="calibre1"/>
<code class="literal">getConnection()</code> method connects to a Derby database and establishes a connection.</p></li><li class="listitem" value="5">Implement<a id="id637" class="calibre1"/> the <code class="literal">create</code> behavior, as follows:<div class="informalexample"><pre class="programlisting">  @Override
  public boolean create(PhoneEntry entry) {
    PreparedStatement preparedStmt = null;
    Connection conn = null;
    try {
    conn = getConnection();
    preparedStmt = conn.prepareStatement("insert into PhoneBook values (?,?,?)");

    preparedStmt.setString(1, entry.getPhoneNumber());
    preparedStmt.setString(2, entry.getFirstName());
    preparedStmt.setString(3, entry.getLastName());
    preparedStmt.executeUpdate();
    // Note that it can cause problems on some dbs if //autocommit mode is on
    conn.commit();
      return true;
    } catch (SQLException e) {
      e.printStackTrace();
    } finally {

      if (preparedStmt != null) {
        try {
          preparedStmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }

      if (conn != null) {
        try {
          conn.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }

    return false;
  }</pre></div><p class="calibre15">The <code class="literal">create</code> method first acquires a database connection and creates a prepared<a id="id638" class="calibre1"/> statement from <code class="literal">connection</code>. Then, it populates the prepared statement with the <code class="literal">PhoneEntry</code> values, executes the prepared statement, and then <a id="id639" class="calibre1"/>commits the connection. The <code class="literal">finally</code> block closes the resources. Then, the prepared statement is closed and the connection is closed.</p></li><li class="listitem" value="6">We need to unit test the JDBC API call since we didn't configure the database yet. We'll unit test the <code class="literal">create()</code> behavior in isolation from the database. Create a <code class="literal">PhoneBookDerbyDaoTest</code> JUnit test under the <code class="literal">test\com.packt.database.dao</code> package. To run the test in isolation from the database, we need to bypass the <code class="literal">loadDriver</code> and <code class="literal">getConnection</code> methods. So, we need a fake object to test the class and need mock objects to mock out the JDBC configuration classes, such as <code class="literal">Connection</code>, <code class="literal">ResultSet</code>, and <code class="literal">PreparedStatement</code>.<p class="calibre15">
<code class="literal">TestablePhoneBookDerbyDao</code> is the fake object implementation of the dao. We created a mock <code class="literal">Connection</code> object and returned from the fake object's <code class="literal">getConnection</code> method. The <a id="id640" class="calibre1"/>following is the<a id="id641" class="calibre1"/> JUnit test for the dao class:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class )
public class PhoneBookDerbyDaoTest {
  @Mock
  Connection connection;
  

  class TestablePhoneBookDerbyDao extends PhoneBookDerbyDao{
    protected void loadDriver() {
    }
    
    protected Connection getConnection() throws SQLException {
      return connection;
    }
  }
}</pre></div></li><li class="listitem" value="7"><code class="literal">PhoneBookDerbyDao</code> needs <code class="literal">PreparedStatement</code> to pass the <code class="literal">PhoneEntry</code> details to the database. Create the mock <code class="literal">PreparedStatement</code> and <code class="literal">connection</code> methods. Update the test class and add the following lines:<div class="informalexample"><pre class="programlisting">  @Mock
   Connection connection;
  @Mock
  PreparedStatement statement;
  
  PhoneBookDerbyDao dao;
  

  @Before
  public void setUp(){
    dao = new TestablePhoneBookDerbyDao();
  }</pre></div><p class="calibre15">Invoke the <code class="literal">create</code> method with <code class="literal">PhoneEntry</code> and verify whether the <code class="literal">PhoneEntry</code> detail was passed to the <code class="literal">statement</code> object. Finally, verify whether <code class="literal">connection</code> was<a id="id642" class="calibre1"/> committed, and <code class="literal">statement</code> and <a id="id643" class="calibre1"/>
<code class="literal">connection</code> were closed, as follows:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void creates_phone_entry() throws Exception {
    //Setting up sample object
    PhoneEntry johnDoe= new PhoneEntry();
    johnDoe.setFirstName("John");
    johnDoe.setLastName("Doe");
    johnDoe.setPhoneNumber("123");
    
    //Stubbing the connection obj to return the mocked statement
    when(connection.prepareStatement(anyString())).thenReturn(statement;
    
    //Calling the actual method
    boolean succeed = dao.create(johnDoe);
    assertTrue(succeed);
    
    //Creating argument captors  
    ArgumentCaptor&lt;String&gt; stringArgCaptor = ArgumentCaptor.forClass(String.class);
    ArgumentCaptor&lt;Integer&gt; intArgCaptor = ArgumentCaptor.forClass(Integer.class);

    //verifying that the mocked statement's setString is //invoked 3 times for firstName, lastName and //phoneNumber  
    verify(statement, new Times(3)).setString(intArgCaptor.
    capture(), stringArgCaptor.capture());
    
    //Verify the arguments passed to the statement object
    assertEquals("123", stringArgCaptor.getAllValues().get(0));
    assertEquals("John", stringArgCaptor.getAllValues().get(1));
    assertEquals("Doe", stringArgCaptor.getAllValues().get(2));
    
    verify(connection).prepareStatement(stringArgCaptor.capture());
    assertEquals(PhoneBookDerbyDao.INSERT_INTO_PHONE_BOOK_VALUES    stringArgCaptor.getValue());
    
    //verify that the mock resources were used and closed
    verify(statement).executeUpdate();
    verify(connection).commit();
    verify(statement).close();
    verify(connection).close();
        
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre9">Overuse of argument captors can lead to fragile tests because your system under test is no longer a black box.</p></div></li><li class="listitem" value="8">We'll verify the data <a id="id644" class="calibre1"/>retrieval logic and enhance<a id="id645" class="calibre1"/> the <code class="literal">searchByNumber()</code> method to retrieve <code class="literal">PhoneEntry</code> by number. The following is the logic:<div class="informalexample"><pre class="programlisting">  @Override
  public List&lt;PhoneEntry&gt; searchByNumber(String number) {
    PreparedStatement preparedStmt = null;
    Connection conn = null;
    ResultSet resultSet = null;
    List&lt;PhoneEntry&gt; entries = new ArrayList&lt;PhoneEntry&gt;();
    try {
      <span class="strong"><strong class="calibre10">conn = getConnection();</strong></span>
      preparedStmt = conn.<span class="strong"><strong class="calibre10">prepareStatement</strong></span>("SELECT * FROM PhoneBook where num=?");

      preparedStmt.setString(1, number);
      <span class="strong"><strong class="calibre10">resultSet = preparedStmt.executeQuery();</strong></span>
      while (<span class="strong"><strong class="calibre10">resultSet.next()</strong></span>) {
        PhoneEntry entry = new PhoneEntry();
        entry.setFirstName(resultSet.getString("fname"));
        entry.setLastName(resultSet.getString("lname"));
        entry.setPhoneNumber(resultSet.getString("num"));
        entries.add(entry);
      }
      return entries;
    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      
      try {
        if (<span class="strong"><strong class="calibre10">resultSet</strong></span> != null) {
          <span class="strong"><strong class="calibre10">resultSet.close();</strong></span>
          resultSet = null;
        }
      } catch (SQLException e) {
        e.printStackTrace();
      }

      if (<span class="strong"><strong class="calibre10">preparedStmt</strong></span> != null) {
        try {
          <span class="strong"><strong class="calibre10">preparedStmt.close();</strong></span>
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }

      if (conn != null) {
        try {
          <span class="strong"><strong class="calibre10">conn.close();</strong></span>
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }
    return null;
  }</pre></div><p class="calibre15">In the preceding code, the <a id="id646" class="calibre1"/>following statements<a id="id647" class="calibre1"/> are executed in sequence:</p><div class="book"><ol class="orderedlist1"><li class="listitem" value="1">A database <code class="literal">Connection</code> is acquired. Then, <code class="literal">PreparedStatement</code> is created from the <code class="literal">Connection</code> object.</li><li class="listitem" value="2">After this, <code class="literal">PreparedStatement</code> is populated.</li><li class="listitem" value="3">Now, <code class="literal">PreparedStatement</code> is executed and <code class="literal">ResultSet</code> is returned.</li><li class="listitem" value="4"><code class="literal">ResultSet</code> is iterated and the <code class="literal">PhoneEntry</code> objects are populated from <code class="literal">ResultSet</code>.</li><li class="listitem" value="5">Finally, the JDBC resources are closed.</li></ol><div class="calibre17"/></div></li><li class="listitem" value="9">To unit test this logic, we need mock <code class="literal">ResultSet</code>, <code class="literal">PreparedStatement</code>, and <code class="literal">Connection</code> objects. The <code class="literal">ResultSet</code> object will be stubbed to return a <code class="literal">PhoneEntry</code> object, the <code class="literal">PreparedStatement</code> object will be stubbed to return the mock <code class="literal">ResultSet</code> object, and the <code class="literal">Connection</code> object will be stubbed to return the mock <code class="literal">PreparedStatement</code> object.<div class="note" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre9">In a persistence<a id="id648" class="calibre1"/> logic unit test, the following things are verified:</p><div class="book"><ul class="itemizedlist1"><li class="listitem">The JDBC API call sequence, such as connection, was committed</li><li class="listitem">Resources were closed or cleaned up</li><li class="listitem">Mapping <code class="literal">ResultSet</code> to model object (POJO)</li></ul></div></div><p class="calibre15">The following is the test code to verify the logic:</p><div class="informalexample"><pre class="programlisting">  @Test
  public void retrieves_phone_entry() throws Exception {

    //Stub JDBC resources to return mock objects
    <span class="strong"><strong class="calibre10">when(mockConn.prepareStatement(anyString())).</strong></span>      <span class="strong"><strong class="calibre10">thenReturn(mockPrepStmt);</strong></span>
    <span class="strong"><strong class="calibre10">when(mockPrepStmt.executeQuery()).</strong></span>      <span class="strong"><strong class="calibre10">thenReturn(mockResultSet);</strong></span>
    <span class="strong"><strong class="calibre10">when(mockResultSet.next()).thenReturn(true).</strong></span>      <span class="strong"><strong class="calibre10">thenReturn(false);</strong></span>
    
    //Stub the resultSet to return value
    when(mockResultSet.getString("fname")).thenReturn("John");
    when(mockResultSet.getString("lname")).thenReturn("Doe");
    when(mockResultSet.getString("num")).thenReturn("123");
    
    //Execute  
    List&lt;PhoneEntry&gt; phoneEntries = dao.searchByNumber("123");
    
    assertEquals(1, phoneEntries.size());
    PhoneEntry johnDoe = phoneEntries.get(0);
    
    //verify mapping
    assertEquals("John", johnDoe.getFirstName());
    assertEquals("Doe", johnDoe.getLastName());
    assertEquals("123", johnDoe.getPhoneNumber());

    //Verify Resource Clean up 
    verify(mockResultSet).close();
    verify(mockPrepStmt).close();
    verify(mockConn).close();
  }</pre></div><p class="calibre15">We should write a unit test for <code class="literal">update</code>, <code class="literal">delete</code>, and <code class="literal">serachByXXX</code> behaviors.</p></li></ol><div class="calibre17"/></div></div>
<div class="book" title="Simplifying persistence with Spring"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec44" class="calibre1"/>Simplifying persistence with Spring</h1></div></div></div><p class="calibre9">Look at the <a id="id649" class="calibre1"/>
<code class="literal">PhoneBookDerbyDao</code> class. It has 398 lines to support create, read, update, and delete (CRUD) operations. Every method performs almost similar tasks. The following tasks are<a id="id650" class="calibre1"/> invoked from the CRUD methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Passing connection parameters</li><li class="listitem">Opening a connection</li><li class="listitem">Creating a statement</li><li class="listitem">Preparing the statement</li><li class="listitem">Executing the statement</li><li class="listitem">Iterating through the results (only in the read method)</li><li class="listitem">Populating the model objects (only in the read method)</li><li class="listitem">Processing any exception</li><li class="listitem">Handling transactions</li><li class="listitem">Closing the ResultSet (only in the read method)</li><li class="listitem">Closing the statement</li><li class="listitem">Closing the connection</li></ul></div><p class="calibre9">The Spring framework provides APIs to reduce JDBC code duplication. Spring JDBC hides the low-level details and allows us to concentrate on business logic. We'll implement <code class="literal">PhoneBookDao</code> using Spring JDBC.</p><p class="calibre9">Download the latest <a id="id651" class="calibre1"/>version of JDBC JAR and its dependencies from <a class="calibre1" href="http://maven.springframework.org/release/org/springframework/spring/">http://maven.springframework.org/release/org/springframework/spring/</a>.</p><p class="calibre9">Follow the ensuing steps to<a id="id652" class="calibre1"/> implement Spring JDBC and simplify the code:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Launch Eclipse, open the <code class="literal">DatabaseAccess</code> project, and edit <code class="literal">.classpath</code> to add the following Spring dependencies shown in the screenshot:<div class="mediaobject"><img src="../images/00114.jpeg" alt="Simplifying persistence with Spring" class="calibre12"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">Create a <code class="literal">PhoneBookDerbySpringDao</code> class that implements the <code class="literal">PhoneBookDao</code> interface. The following<a id="id653" class="calibre1"/> is the Spring implementation of the <code class="literal">create</code> method:<div class="informalexample"><pre class="programlisting">  public class PhoneBookDerbySpringDao  implements
    PhoneBookDao {

  private final JdbcTemplate jdbcTemplate;
  
    public <span class="strong"><strong class="calibre10">PhoneBookDerbySpringDao</strong></span>(JdbcTemplate jdbcTemplate) {
    this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public boolean create(PhoneEntry entry) {
      int rowCount = <span class="strong"><strong class="calibre10">jdbcTemplate.update("insert into PhoneBook values (?,?,?)",</strong></span>
<span class="strong"><strong class="calibre10">        new Object[]{entry.getPhoneNumber(), entry.getFirstName(),</strong></span>
<span class="strong"><strong class="calibre10">            entry.getLastName()</strong></span>
<span class="strong"><strong class="calibre10">        })</strong></span>;
      return rowCount == 1;
    }
  }</pre></div><p class="calibre15">
<code class="literal">JdbcTemplate</code> simplifies the use of JDBC; it handles the resources and helps to avoid common errors such as not closing the connection. It creates and populates the <code class="literal">statement</code> object, iterates through the <code class="literal">ResultSet</code> object, which leaves the application code to provide SQL, and extracts results. <code class="literal">PhoneBookDerbySpringDao</code> contains a <code class="literal">JdbcTemplate</code> instance and delegates the database tasks to the <code class="literal">jdbcTemplate</code>.</p><p class="calibre15">
<code class="literal">JdbcTemplate</code> has an update method for insert and update operations. It takes a SQL query and parameters. The new Spring version of the <code class="literal">create()</code> method invokes the <code class="literal">update()</code> method on <code class="literal">jdbcTemplate</code> and passes <code class="literal">PhoneEntry</code> details. Now the <code class="literal">create</code> method looks simple, just two lines of code. The Spring framework handles the resource life cycle.</p></li><li class="listitem" value="3">Create a JUnit class named <code class="literal">PhoneBookDerbySpringDaoTest</code> for unit testing. We'll create a <code class="literal">jdbcTemplate</code> mock<a id="id654" class="calibre1"/> and pass it to dao. The following is the JUnit implementation:<div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class PhoneBookDerbySpringDaoTest {

  @Mock
  JdbcTemplate mockJdbcTemplate;

  PhoneBookDerbySpringDao springDao;

  @Before
  public void init() {
    <span class="strong"><strong class="calibre10">springDao = new PhoneBookDerbySpringDao(mockJdbcTemplate);</strong></span>
  }

  @Test
  public void creates_PhoneEntry() throws Exception {
    //create PhoneEntry
    String charlsPhoneNumber = "1234567";
    String charlsFirstName = "Charles";
    String charlsLastName = "Doe";

    PhoneEntry charles = new PhoneEntry();
    charles.setFirstName(charlsFirstName);
    charles.setLastName(charlsLastName);
    charles.setPhoneNumber(charlsPhoneNumber);

    //Stub jdbcTemplate's update to return 1
    <span class="strong"><strong class="calibre10">when(mockJdbcTemplate.update(anyString(), anyObject(), anyObject(), anyObject())).thenReturn(1);</strong></span>

    //Execute
    assertTrue(springDao.create(charles));

    //Create argument capture
    ArgumentCaptor&lt;Object&gt; varArgs = ArgumentCaptor.forClass(Object.class);

    ArgumentCaptor&lt;String&gt; strArg = ArgumentCaptor.forClass(String.class);

    //Verify update method was called and capture args
    verify(mockJdbcTemplate).update(strArg.capture(),varArgs.capture(),varArgs.capture(), varArgs.capture());
    
    //Verify 1st dynamic argument was the phone number
    assertEquals(charlsPhoneNumber, varArgs.getAllValues().get(0));
    //Verify the name arguments
    assertEquals(charlsFirstName, 
      varArgs.getAllValues().get(1));
    assertEquals(charlsLastName, varArgs.getAllValues().get(2));
  }
}</pre></div><p class="calibre15">Look at the new Spring dao; it is only 54 lines long. The class<a id="id655" class="calibre1"/> looks neat, simple, and readable. It doesn't handle resources, it rather concentrates on data access.</p></li></ol><div class="calibre17"/></div></div>
<div class="book" title="Verifying the system integrity"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Verifying the system integrity</h1></div></div></div><p class="calibre9">Integration tests let us find bugs that unit testing couldn't catch. We have unit tested the JDBC API usages in isolation from the database, but we need to test the integration of data and data access API, such as the JDBC driver, connection, and rollback. In this section, we'll test the data access layer with a database.</p><p class="calibre9">We need to create the<a id="id656" class="calibre1"/> database table before we start writing tests. Download the code from the Packt Publishing website and import the project <code class="literal">DatabaseAccess</code> in your Eclipse workspace, go to the <code class="literal">com.packt.database.util</code> package and run the <code class="literal">DatabaseManager</code> class. It will create the table. The following is the fairly simple table creation code:</p><div class="informalexample"><pre class="programlisting">    conn = DriverManager.getConnection(url, props);
    conn.setAutoCommit(false);
    statement = conn.createStatement();
    statement.execute("<span class="strong"><strong class="calibre10">create table PhoneBook</strong></span>      <span class="strong"><strong class="calibre10">(num varchar(50), fname varchar(40),lname varchar(40))</strong></span>");
    conn.commit();</pre></div><p class="calibre9">The following are the steps to test the JDBC code:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a source folder<a id="id657" class="calibre1"/> named <code class="literal">integration</code> for the database<a id="id658" class="calibre1"/> centric tests, such as <code class="literal">src</code> or <code class="literal">test</code>.</li><li class="listitem" value="2">Create a new JUnit test named <code class="literal">PhoneBookDerbyJdbcDaoIntegrationTest</code> and add the following lines to test the create, search, update, and delete functionalities:<div class="informalexample"><pre class="programlisting">public class PhoneBookDerbyJdbcDaoIntegrationTest {
  PhoneBookDerbyDao jdbcDao;
 
  @Before
  public void init() {
    jdbcDao = new PhoneBookDerbyDao();
  }
  
  @Test
  public void integration() throws Exception {
    PhoneEntry entry = new PhoneEntry();
    entry.setFirstName("john");
    entry.setLastName("smith");
    entry.setPhoneNumber("12345");
    
    assertTrue(jdbcDao.create(entry));
    List&lt;PhoneEntry&gt; phoneEntries = 
    jdbcDao.searchByFirstName("john");

    //verify create
    assertFalse(phoneEntries.isEmpty());

    //modify last name
    entry.setLastName("doe");

    //update
    assertTrue(jdbcDao.update(entry));

    //retrieve
    phoneEntries = jdbcDao.searchByFirstName("john");

    //verify update
    assertFalse(phoneEntries.isEmpty());
    assertEquals("doe", phoneEntries.get(0).getLastName());

    //delete
    jdbcDao.delete(entry.getPhoneNumber());

    //retrieve
    phoneEntries = jdbcDao.searchByFirstName("john");

    //verify delete
    assertTrue(phoneEntries.isEmpty());
  }

}</pre></div></li></ol><div class="calibre17"/></div><p class="calibre9">The integration test<a id="id659" class="calibre1"/> creates a <code class="literal">PhoneBookDerbyJdbcDao</code> instance and calls the <code class="literal">PhoneBookDerbyJdbcDao</code> method to<a id="id660" class="calibre1"/> assert results.</p></div>
<div class="book" title="Writing integration tests with Spring"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec46" class="calibre1"/>Writing integration tests with Spring</h1></div></div></div><p class="calibre9">Spring provides the module or utility<a id="id661" class="calibre1"/> library for integration tests. The following are the steps to write JUnit tests using the Spring transaction management<a id="id662" class="calibre1"/> API and <code class="literal">SpringJUnit4ClassRunner</code>:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Spring supports XML-based configuration and wiring beans. Create an XML file named <code class="literal">integration.xml</code> in the <code class="literal">integration</code> source package. Modify the XML file and define the <code class="literal">dataSource</code>, <code class="literal">transactionManager</code>, and <code class="literal">JdbcTemplate</code> Spring beans. The following is the XML body:<div class="informalexample"><pre class="programlisting">&lt;beans 
  
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
 
  &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="url" value="jdbc:derby:derbyDB;create=true"/&gt;
    &lt;property name="username" value="dbo"/&gt;
  &lt;/bean&gt; 
 
  &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;constructor-arg ref="dataSource"/&gt;
  &lt;/bean&gt;
    
  &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre9">To find out more about Spring beans, visit <a class="calibre1" href="http://docs.spring.io/spring/docs/1.2.9/reference/beans.html">http://docs.spring.io/spring/docs/1.2.9/reference/beans.html</a>.</p></div><p class="calibre15">A <code class="literal">dataSource</code> bean is defined with <code class="literal">driverClassName</code>, <code class="literal">url</code>, and <code class="literal">username</code>. The <code class="literal">dataSource</code> reference is passed to the <code class="literal">jdbcTemplate</code> and <code class="literal">transactionManager</code> beans.</p></li><li class="listitem" value="2">Spring supports automatic transaction<a id="id663" class="calibre1"/> rollback after test execution. It helps us to shield the development database against getting corrupted. The test runner needs to have a reference to a transaction manager bean before test execution. <code class="literal">SpringJUnit4ClassRunner</code> handles<a id="id664" class="calibre1"/> the integration tests. Add a <code class="literal">PhoneBookDerbySpringDaoIntegrationTest</code> JUnit test and add the following lines to it:<div class="informalexample"><pre class="programlisting">@ContextConfiguration({ "classpath:integration.xml" })
@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback = true)
@Transactional
@RunWith(SpringJUnit4ClassRunner.class)
public class PhoneBookDerbySpringDaoIntegrationTest {

  @Autowired
  JdbcTemplate jdbcTemplate;

  PhoneBookDerbySpringDao springDao;

  @Before
  public void init() {
    springDao = new PhoneBookDerbySpringDao(jdbcTemplate);
  }

  @Test
  public void integration() throws Exception {
    PhoneEntry entry = newEntry("12345", "John", "Smith");

    //create
    assertTrue(springDao.create(entry));

    //retrieve
    List&lt;PhoneEntry&gt; phoneEntries = 
      springDao.searchByFirstName("John");

    //verify create
    assertFalse(phoneEntries.isEmpty());

    //modify last name
    entry.setLastName("Kallis");

    //update
    assertTrue(springDao.update(entry));

    //retrieve
    phoneEntries = springDao.searchByFirstName("John");

    //verify update
    assertFalse(phoneEntries.isEmpty());
    assertEquals("Kallis", 
      phoneEntries.get(0).getLastName());

    //delete
    springDao.delete(entry.getPhoneNumber());

    //retrieve
    phoneEntries = springDao.searchByFirstName("John");

    //verify delete
    assertTrue(phoneEntries.isEmpty());
  }
}</pre></div></li></ol><div class="calibre17"/></div><p class="calibre9">The <code class="literal">@ContextConfiguration({ "classpath:integration.xml" })</code> annotation instructs the JUnit runner to load Spring beans from a classpath location. It will load three beans from the <code class="literal">integration.xml</code> file.</p><p class="calibre9">The class level <code class="literal">@Transactional</code> annotation<a id="id665" class="calibre1"/> makes all methods transactional.</p><p class="calibre9">The <code class="literal">@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback = true)</code> annotation defines the transaction manager, and the <code class="literal">defaultRollback</code> attribute tells the transaction manager to roll back all transactions after the end of a given test.</p><p class="calibre9">The following things happen <a id="id666" class="calibre1"/>when the JUnit test is run:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Spring beans are loaded from the <code class="literal">integration.xml</code> file.</li><li class="listitem">A transaction manager is configured to roll back all transactions.</li><li class="listitem">The <code class="literal">jdbcTemplate</code> bean is automatically wired to the test class member <code class="literal">jdbcTemplate</code>.</li><li class="listitem">The <code class="literal">init</code> method creates a new instance of the dao class and passes the <code class="literal">jdbcTemplate</code> bean to the dao.</li><li class="listitem">The test first executes and then creates, updates, and deletes <code class="literal">PhoneEntry</code>.</li><li class="listitem">After test execution, the transaction manager rolls back the transaction. No data is created or modified or deleted from or to the <code class="literal">PhoneBook</code> table.</li></ul></div><p class="calibre9">When the JUnit test runs, the following Spring console log is shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre10">INFO: Began transaction (1): transaction manager [org.springframework.jdbc.datasource.DataSourceTransactionManager@569c60]; rollback [true]</strong></span>
<span class="strong"><strong class="calibre10">Apr 11, 2014 10:02:25 PM org.springframework.test.context.transaction.TransactionalTestExecutionListener endTransaction</strong></span>
<span class="strong"><strong class="calibre10">INFO: Rolled back transaction after test execution for test context [[TestContext@134eb84 testClass = PhoneBookDerbySpringDaoIntegrationTest, testInstance = com.packt.database.dao.PhoneBookDerbySpringDaoIntegrationTest@1522de2, testMethod = integration@PhoneBookDerbySpringDaoIntegrationTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@425743 testClass = PhoneBookDerbySpringDaoIntegrationTest, locations = '{classpath:integration.xml}', classes = '{}', activeProfiles = '{}', contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader']]]</strong></span>
</pre></div><p class="calibre9">The log shows that a transaction has begun, and finally the transaction is rolled back. However, the transaction was not rolled back due to any exception, rather it got rolled back due to the transactional <a id="id667" class="calibre1"/>setting <code class="literal">[defaultRollback = true]</code>. The log shows that <code class="literal">testException</code> is equal to <code class="literal">null</code>, which<a id="id668" class="calibre1"/> implies that no exception was thrown.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec47" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter explained the unit testing strategy for the database layer; it provided an example of unit testing in isolation from the database, writing clean JDBC code with Spring, and writing integration tests with database. We also learned about the configured automatic transaction rollback in Spring JDBC integration tests.</p><p class="calibre9">You should now be able to unit test the data access layer components in isolation from the database, write neat JDBC code using Spring, and write integration tests using Spring API.</p><p class="calibre9">The next chapter covers the service layer and testing legacy code testing.</p></div></body></html>