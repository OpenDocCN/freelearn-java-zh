<html><head></head><body>
		<div id="_idContainer027">
			<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor172"/>10</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Connection Pooling</h1>
			<p><strong class="bold">Connection pooling</strong> is a technique used in software development<a id="_idIndexMarker480"/> to manage database connections. These connections can be reused during program execution and conventional wisdom dictates that anything that can be reused should be created once and reused as needed. That has been the premise throughout this book as we strive to achieve higher-performing Java applications. This chapter covers the concept of connection pooling, providing fundamental principles, implementation approaches, and examples. Our coverage includes establishing connections, managing them, and terminating them when no longer needed. Best practices related to connection pooling will also <span class="No-Break">be covered.</span></p>
			<p>The following main topics are covered in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Connection <span class="No-Break">pooling concepts</span></li>
				<li>Implementing <span class="No-Break">connection pools</span></li>
				<li>Best practices with <span class="No-Break">connection pools</span></li>
			</ul>
			<p>By the end of the chapter, you should have a thorough understanding of connection pooling, be able to implement a connection pool, and strategically design an approach to leverage connection pools for <span class="No-Break">performance enhancement.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Connection pooling concepts</h1>
			<p>Most modern systems<a id="_idIndexMarker481"/> include multiple<a id="_idIndexMarker482"/> databases, especially when <strong class="bold">microservices architectures</strong> are implemented. This makes the concept of connection pooling a critical component of efficient <span class="No-Break">Java applications.</span></p>
			<p class="callout-heading">Microservices architecture</p>
			<p class="callout">Microservices are independent<a id="_idIndexMarker483"/> components of a software system tied to a specific business function. They often have their own database so they can be decoupled from the main application and updated independently of <span class="No-Break">other microservices.</span></p>
			<p>The key issue is that software applications need to connect to databases and those connections draw on system resources. The concept of connection pooling is to establish a connection to the required databases and when they are no longer in use, return them to a pool. Obtaining a connection from a pool is quicker and less resource intensive than creating new connections every time a database operation <span class="No-Break">is required.</span></p>
			<p>The following illustration shows the process<a id="_idIndexMarker484"/> of connection pooling, which is also considered the <strong class="bold">connection pool </strong><span class="No-Break"><strong class="bold">life cycle</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 10.1 – Connection pool life cycle&#13;&#10;" src="image/B21942_10_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Connection pool life cycle</p>
			<p>Connection pools are initialized when the application initially loads. Part of the initialization involves establishing the number of connections. We will walk through an example later in this chapter. For now, you should<a id="_idIndexMarker485"/> understand that we will use a <strong class="bold">connection pool library</strong> for <span class="No-Break">our implementation.</span></p>
			<p>The second component is <strong class="bold">connection borrowing</strong>. Whenever a database operation<a id="_idIndexMarker486"/> is necessary, a connection is obtained from the pool. The term “borrowing” suggests that once a connection is no longer required by a service, it is returned to the pool. That is the connection return component’s segment of the life cycle. Unused connections are returned to the pool<a id="_idIndexMarker487"/> so they can be <span class="No-Break">used again.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>Advantages of connection pooling</h2>
			<p>There are three primary advantages<a id="_idIndexMarker488"/> of connection pooling. First, the use of connection pooling can result in higher performance. This improvement is possible because connects are reused, resulting in faster <span class="No-Break">database operations.</span></p>
			<p>Another advantage of implementing connection pooling in our applications is that we are better equipped to optimize resource utilization. The number of database connections open at any given time is reduced because the unused connections are in a pool. This results in lower application and database <span class="No-Break">server overhead.</span></p>
			<p>An additional advantage of connection pooling is that it supports scalability. This is possible because when our applications use connection pooling, they can handle many simultaneous <span class="No-Break">database operations.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Challenges of connection pooling</h2>
			<p>There are challenges and concerns<a id="_idIndexMarker489"/> with virtually every high-performance approach we implement in our Java applications and connection pooling is no exception. There are three primary areas <span class="No-Break">of concern.</span></p>
			<p>First, it is critical that we establish an optimal <strong class="bold">size</strong> for our connection pool. If we do not permit enough connections, our applications can become sluggish or unresponsive. Bottlenecks can also occur when our connection pools are too small. On the other hand, if our connection pool is too large, we could possibly overtask database servers, leading to overall system <span class="No-Break">performance degradation.</span></p>
			<p><strong class="bold">Connection leaks</strong> are another area of concern. It is important<a id="_idIndexMarker490"/> that we manage the connection pool life cycle, with a focus on connection borrowing and returning operations. When we fail to manage these operations properly, connection leaks <span class="No-Break">are possible.</span></p>
			<p class="callout-heading">Connection leaks</p>
			<p class="callout">Connection leaks occur when we fail to properly<a id="_idIndexMarker491"/> return connections to the pool. This can lead to the connection pool’s resources <span class="No-Break">being depleted.</span></p>
			<p>You should now have a foundational understanding of connection pooling and its advantages and challenges. The next section walks through <span class="No-Break">implementation examples.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Implementing connection pools</h1>
			<p>We should now understand what connection pools<a id="_idIndexMarker492"/> are and the associated advantages and challenges. Let’s extend our knowledge by implementing connection pools using Java. In this section, we will look at connection pool libraries, set up a connection pool, integrate our connection pool with application logic, and explore how to monitor our <span class="No-Break">connection pools.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Connection pool libraries</h2>
			<p>Once we decide to use connection pools<a id="_idIndexMarker493"/> in an application, we need to select an appropriate connection pool library. There are several connection pool libraries available to us for Java, and which one we select is based on our application’s requirements. Let’s look at three popular connection <span class="No-Break">pool libraries.</span></p>
			<p><strong class="bold">Apache Commons Database Connection Pooling</strong> (<strong class="bold">DBCP</strong>) is a mature library that is considered stable<a id="_idIndexMarker494"/> and has wide applicability. As the name suggests, this is an open-source library from Apache. While this is a proven library, it is less efficient than more <span class="No-Break">modern libraries.</span></p>
			<p>The <strong class="bold">C3PO</strong> (<strong class="bold">Cloud-Based Confidentiality-Preserving Continuous Query Processing</strong>) connection pool library is another<a id="_idIndexMarker495"/> viable option. It includes a robust set of features to include automatic connection retries when connections cannot be established. This library is a bit more versatile than the Apache Commons <span class="No-Break">DBCP library.</span></p>
			<p>A third connection pool library option is the <strong class="bold">Hikari Connection Pool</strong> (<strong class="bold">HikariCP</strong>). This is a newer library<a id="_idIndexMarker496"/> than the previous two and is lauded for its simplicity and its performance. With the goal of improving the performance of our Java applications, HikariCP is a great choice for connection pooling and is the library featured in the remainder of <span class="No-Break">this chapter.</span></p>
			<p>There are six primary factors you should consider<a id="_idIndexMarker497"/> when selecting a connection <span class="No-Break">pool library:</span></p>
			<ul>
				<li><strong class="bold">Compatibility</strong>: You should check to ensure the library is compatible with your version of Java as well as any database drivers or tools you plan <span class="No-Break">to use.</span></li>
				<li><strong class="bold">Familiarity</strong>: If you and your development team are already familiar with a specific connection pool library, you can introduce faster development and fewer bugs if you continue to use a library you are familiar with. The downside to this is that you might be sacrificing features and runtime performance for <span class="No-Break">development efficiencies.</span></li>
				<li><strong class="bold">Features</strong>: The full list of features should be reviewed to ensure the library you choose can do what you expect <span class="No-Break">it to.</span></li>
				<li><strong class="bold">Maintenance</strong>: We should always gravitate toward libraries that <span class="No-Break">are maintainable.</span></li>
				<li><strong class="bold">Performance</strong>: This is a paramount factor. You want to ensure that your chosen library does not underperform when under stress (high and persistent workloads). This is something you should test before formally adopting a connection <span class="No-Break">pool library.</span></li>
				<li><strong class="bold">Support</strong>: Check the official website to ensure there is ample documentation. Additionally, you want to select a library that has robust community support. This can help you when you experience development challenges and <span class="No-Break">when troubleshooting.</span></li>
			</ul>
			<p>When selecting a connection pool library, overall application performance should be heavily considered. This may require trial and error with multiple libraries. Reviewing the features of each library<a id="_idIndexMarker498"/> can help you make an informed decision. The following table can help with <span class="No-Break">your review.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Apache DBCP</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">C3P0</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">HikariCP</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Performance</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Great</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Connection timeout</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Statement caching</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Idle connection <span class="No-Break">test/validation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Connection validation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Pool <span class="No-Break">sizing flexibility</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Great</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Documentation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Great</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Community support</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Great</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Configuration ease</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Moderately Complex</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Moderately Complex</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Simple</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Modern <span class="No-Break">framework integration</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Poor</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Good</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Great</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Table 10.1 – Library features</p>
			<p>As you can see in the preceding<a id="_idIndexMarker499"/> table, many of the features are rated the same across all three connection libraries. This suggests that a deeper dive might be required. The comparison is only provided as a high-level overview and provides insights into areas you might consider <span class="No-Break">researching further.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Setting up a connection pool</h2>
			<p>Now that a connection pool library<a id="_idIndexMarker500"/> has been selected, HikariCP in our case, we need to follow a few specific steps. Let’s walk through an example using Maven for our <span class="No-Break">build tool:</span></p>
			<ol>
				<li><strong class="bold">Add the library to </strong><span class="No-Break"><strong class="bold">your project</strong></span><span class="No-Break">:</span><p class="list-inset">We need to edit our pom.xml file to add HikariCP to our dependencies. This is how we would <span class="No-Break">do that:</span></p><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
    &lt;version&gt;2.6.3&lt;/version&gt;
&lt;/dependency&gt;</pre></li>				<li><strong class="bold">Connection </strong><span class="No-Break"><strong class="bold">pool configuration</strong></span><span class="No-Break">:</span><p class="list-inset">Note that the following source code<a id="_idIndexMarker501"/> is just an example and will not run on its own. It is provided to help explain how to configure a connection pool. As you can see, we create <strong class="source-inline">dataSource</strong> and set several parameters to configure our <span class="No-Break">connection pool:</span></p><pre class="source-code">
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
public class DatabaseConfig {
  private static HikariDataSource dataSource;
  static {
    HikariConfig config = new HikariConfig();
    config.setJdbcUrl( "jdbc:postgresql://localhost:5432/
    myDatabase");
    config.setUsername("databaseUser");
    config.setPassword("databasePassword");
    // Pool configuration
    config.setMaximumPoolSize(10);
    config.setMinimumIdle(5);
    config.setIdleTimeout(600000);
    config.setMaxLifetime(1800000);
    config.setConnectionTimeout(30000);
    dataSource = new HikariDataSource(config);
  }
  public static HikariDataSource getDataSource() {
    return dataSource;
  }
}</pre></li>				<li><span class="No-Break"><strong class="bold">Pool initialization</strong></span><span class="No-Break">:</span><p class="list-inset">In the previous code snippet, we initialized<a id="_idIndexMarker502"/> a <strong class="source-inline">static</strong> connection pool in the <strong class="source-inline">DatabaseConfig</strong> class. We implement this approach so our connection pool is initialized and ready when the class loads. The global access point to our connection is established with the <strong class="source-inline">getDataSource()</strong> method. This facilitates connections to be borrowed from the pool by our <span class="No-Break">application’s methods.</span></p></li>
				<li><strong class="bold">Using </strong><span class="No-Break"><strong class="bold">the pool</strong></span><span class="No-Break">:</span><p class="list-inset">With our connection pool configured and loaded, we are ready to start using it. Since we already implemented the <strong class="source-inline">getDataSource()</strong> method, we can access the pool and obtain connections. Here is a method of accomplishing that task. As previously stated, this is not a complete application; rather, it is a representative code snippet to demonstrate how to use a <span class="No-Break">connection pool:</span></p><pre class="source-code">
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
public class DatabaseOperations {
  public void executeQuery(String query) {
    try (Connection conn = DatabaseConfig.getDataSource().
    getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(query)) {
      while (rs.next()) {
        // Here you would process the result set
      }
    } catch (Exception e) {
        e.printStackTrace();
    }
  }
}</pre></li>			</ol>
			<p>As shown previously, we implemented<a id="_idIndexMarker503"/> the <strong class="source-inline">try-with-resources</strong> statement to automatically close our database connection, which returns the connection to the pool so it can be <span class="No-Break">used again.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Integrating connection pools</h2>
			<p>Integrating connection pools<a id="_idIndexMarker504"/> into our Java applications requires us to create code (as demonstrated in the previous section) that creates, uses, and closes database connections. We highlighted that we no longer need to open a new database connection every time a database connection is required. Instead, we borrow from the pool and return our connections when we are done <span class="No-Break">with them.</span></p>
			<p>The primary integration points are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Managing connections</span></li>
				<li><span class="No-Break">Obtaining connections</span></li>
				<li><span class="No-Break">Handling errors</span></li>
			</ul>
			<p>Once we have our connection pool<a id="_idIndexMarker505"/> in place, we need to monitor them during runtime and perform tuning as needed. Let’s look at those tasks in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Monitoring connection pools</h2>
			<p>Connection pools are an important<a id="_idIndexMarker506"/> component of modern software systems, and they can represent a tremendous boon to overall system performance. This underscores the importance of monitoring their performance during runtime. We can accomplish this by reviewing logs and using monitoring tools. Most connection pool libraries come with tools sufficient for <span class="No-Break">the task.</span></p>
			<p>In addition to errors, we should look for <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Connection leaks</span></li>
				<li>Long <span class="No-Break">wait times</span></li>
				<li>Improper <span class="No-Break">pool sizes</span></li>
			</ul>
			<p>Part of monitoring connection pools includes the need to establish key metrics. Simply watching system logs is not enough; we need a set of metrics or benchmarks to properly measure the success and performance of our <span class="No-Break">connection pools.</span></p>
			<p>As we continue to monitor our connection pool performance, we can make configuration changes that are applied when the application starts up. For always-on systems, you may need to restart a service or server. A mindset of continual performance improvement can help ensure we get the best possible performance from our connection pools and positively impact our system’s <span class="No-Break">overall performance.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Best practices with connection pools</h1>
			<p>Connection pool implementation <a id="_idIndexMarker507"/>is relatively straightforward and, like most programming tasks, you will quickly have your own code base that you can refactor for follow-up programming projects. This is often a critical component to your system’s success as it provides the mechanism for your application to access data. Some factors should be considered as part of your connection pool strategy. Let’s look at the <span class="No-Break">primary factors.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>Connection pool sizing</h2>
			<p>Ensuring your connection pool<a id="_idIndexMarker508"/> is properly sized is the first factor you should consider. We should strive to find the ideal balance between performance and resource usage. If our pool is too small, the access wait times can increase, which will negatively impact performance. Oversized connection pools can result in wasted resources such as idle connections requiring <span class="No-Break">system resources.</span></p>
			<p>The challenge is knowing what the ideal connection pool size is. This can take some trial and error. Initially, we can estimate the number of database connections our application might need at one time. There is no magic formula for this, so consider the following when making your <span class="No-Break">initial estimates:</span></p>
			<ul>
				<li>The number of services that your application has that need a database connection to <span class="No-Break">fully function</span></li>
				<li>The number of concurrent connections you <span class="No-Break">will need</span></li>
				<li>Review the <span class="No-Break">usage patterns</span></li>
				<li>The peak <span class="No-Break">load conditions</span></li>
			</ul>
			<p>Using our <strong class="source-inline">HikariCP</strong> example from earlier, we can set the size of our connection pool with a single line of code in our <span class="No-Break"><strong class="source-inline">DataSourceConfig</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
    config.setMaximumPoolSize(10);
    config.setMinimumIdle(5);</pre>			<p>As you can see, we set the maximum number of connections to <strong class="source-inline">10</strong> and the minimum number of idle connections that the pool maintains <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></p>
			<p>Once you make your initial connection pool size decision, continue monitoring the performance and adjusting your configuration as needed. You can use tools that come with your connection pool library<a id="_idIndexMarker509"/> as well as external tools such as <strong class="bold">application performance monitoring</strong> (<span class="No-Break"><strong class="bold">APM</strong></span><span class="No-Break">) tools.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>Handling connection leaks</h2>
			<p>Once your application is running, you should commit<a id="_idIndexMarker510"/> yourself to continually monitoring your connection pool performance. While you hope not to experience connection leaks, the best practice is to be prepared for them. As a reminder, a connection leak occurs when a connection is not returned to the pool after it is no longer in use. This can lead to depleting the available connections in the pool. Ultimately, this can lead to your <span class="No-Break">application failing.</span></p>
			<p>There are two primary approaches to handling connection leaks, and they can be used in concert with <span class="No-Break">one another.</span></p>
			<h3>Timeout settings</h3>
			<p>We can set a timeout period<a id="_idIndexMarker511"/> for connections that are borrowed. If a connection has been borrowed from the pool for what you consider to be too long, then we can have it reclaimed or at least a log entry made to help with your <span class="No-Break">monitoring efforts.</span></p>
			<p>Let’s review the pool configuration part of the code snippet from earlier in <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
    config.setIdleTimeout(600000);
    config.setMaxLifetime(1800000);
    config.setConnectionTimeout(30000);</pre>			<p>As seen in the preceding code snippet, we set the maximum amount of time a connection can be in the pool, in an idle state to 60,000 milliseconds (about 1 minute). The second line of code sets the maximum lifetime of a connection in the pool to approximately 30 minutes, and the third line sets the amount of time to wait for a connection from <span class="No-Break">the pool.</span></p>
			<h3>Connection handling patterns</h3>
			<p>We should review our code <a id="_idIndexMarker512"/>to ensure connections are always closed. This can be done in a <strong class="source-inline">finally</strong> block or in the <strong class="source-inline">try-with-resource</strong> statement we used earlier in this chapter. Let’s look at an example <span class="No-Break">of each.</span></p>
			<p>The first code snippet is in an abbreviated format for illustration purposes only. It demonstrates how we can ensure the connections are closed. In the following example, we assume that all appropriate import statements will be included and that <strong class="source-inline">dataSource</strong> has been initialized elsewhere in the application. In the <strong class="source-inline">finally</strong> block, we ensure that resources are closed<a id="_idIndexMarker513"/> to help avoid <span class="No-Break">connection leaks:</span></p>
			<pre class="source-code">
// import statements
public class DatabaseUtil {
    private DataSource dataSource;
    public void executeQuery(String query) {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = dataSource.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery(query);
            // Process the result set
            while (rs.next()) {
                // Handle data
            }
        } catch (Exception e) {
            // Handle exception
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</pre>			<p>While implementing the <strong class="source-inline">finally</strong> block can help ensure<a id="_idIndexMarker514"/> that resources are closed to help avoid connection leaks, another approach is to use the <strong class="source-inline">try-with-resources</strong> statement. Here is an example of <span class="No-Break">that statement:</span></p>
			<pre class="source-code">
public void executeQuery(String query) {
    try (Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(query)) {
        // Process the result set
        while (rs.next()) {
            // Handle data
        }
    } catch (Exception e) {
        // Handle exception
        e.printStackTrace();
    }
}</pre>			<p>This approach results in the resources automatically being closed once the try-catch block is exited. This exit can occur based on normal program flow or when an exception is caught. In both cases, the resource will be automatically closed. As you saw, there was no need for a <strong class="source-inline">finally</strong> block with this approach<a id="_idIndexMarker515"/> and it is therefore the <span class="No-Break">recommended approach.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>Connection pool security</h2>
			<p>Connection pools facilitate access<a id="_idIndexMarker516"/> to our databases, and we must always protect them. Maintaining a pool of database connections could represent a tremendous security risk. There are two types of protection we <span class="No-Break">can implement.</span></p>
			<p>First, we can encrypt our configuration files. These files contain our database connection information and should be considered sensitive information. Encryption and decryption can take processing time resulting in a small downtick in performance, but this is a necessary component of <span class="No-Break">your application.</span></p>
			<p>Another type of protection<a id="_idIndexMarker517"/> is to use the concept of <strong class="bold">least privilege</strong>, only granting the minimum privileges necessary for the application to run. For example, if you have a service that merely needs to search a customer database to display key information such as names, emails, and account numbers, do not give that service create, update, or delete access to the database. In this scenario, you only need to grant the service <span class="No-Break">read access.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Advanced topics</h2>
			<p>There are a few connection pool topics that go beyond the basics and are worth considering as we aim to optimize the performance of our connection pools. Let’s look at four of those <span class="No-Break">topics here:</span></p>
			<ul>
				<li><strong class="bold">Cloud native</strong>: When we are working with cloud-based<a id="_idIndexMarker518"/> applications, we can leverage features native to the cloud environment. This can include features aimed at improving resiliency, reliability, and scalability. Ideally, our database selection will be based on cloud-native database services to further optimize <span class="No-Break">connection pooling.</span></li>
				<li><strong class="bold">Connection validation</strong>: It is a good idea to periodically execute<a id="_idIndexMarker519"/> a function to validate the connections in the pool. This can ensure they remain valid and can prevent <span class="No-Break">costly problems.</span></li>
				<li><strong class="bold">Failover</strong>: Database redundancy<a id="_idIndexMarker520"/> is a key feature of cloud computing environments. Specific to connection pools, we can implement a failover schema that shifts to a backup database if the first <span class="No-Break">one fails.</span></li>
				<li><strong class="bold">Redundancy</strong>: To support failover, and as part of normal<a id="_idIndexMarker521"/> practice, we should implement database redundancy. Taking advantage of cloud computing database services can make this relatively easy <span class="No-Break">to configure.</span></li>
			</ul>
			<p>Following the best practices presented in this section can help you implement connection pools in a manner that contributes to the high performance of your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Summary</h1>
			<p>This chapter took a deep look at the foundational concepts and components of connection pools with a focus on increasing the performance, resilience, reliability, and scalability of our Java applications. We also explored implementation strategies and best practices for optimizing our use of connection pools. Specifically, we highlighted how connection pools work, their advantages, and related challenges for developers. We reviewed the features of multiple connection pool libraries and selected the HikariCP library for our code examples. You should have a firm understanding of connection pools, why we should use them, and how to create, monitor, and <span class="No-Break">fine-tune them.</span></p>
			<p>In the next chapter, we will look at the <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>). This protocol is used to transmit data and is the backbone of data communication over the web. Our focus will be on how to leverage HTTP for our Java applications to communicate with web browsers and web servers. The chapter aims to help you learn how to use HTTP in Java web applications while maintaining high performance, how to implement strategies for effectively using HTTP with Java, and how to use HTTP to communicate between Java applications <span class="No-Break">and APIs.</span></p>
		</div>
	</body></html>