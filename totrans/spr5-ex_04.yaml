- en: Kotlin Basics and Spring Data Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot allows developers to create different styles of application. In
    [Chapter 2](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml), *Starting in the Spring
    World – the CMS Application*, and [Chapter 3](827e9516-ff3d-44d7-8a16-95579684f453.xhtml),* Persistence
    with Spring Data and Reactive Fashion*, we have created a portal application,
    and now we will create an application based on message-driven architecture. It
    demonstrates how the Spring Framework fits well in a wide range of application
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start to create an application which keeps the tracked
    hashtags on the Redis database. The application will get hashtags and put them
    in a couple of queues to our other projects, and consume and handle them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: As we have been doing in our previous projects, we will continue to use the
    Reactive Foundation to provide scalable characteristics in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this chapter, we will have:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned Kotlin basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created the project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created the Reactive Redis repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied some techniques in reactive programming, using the Reactive Redis Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start right now.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Kotlin basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language was released officially in February 2016\. JetBrains created
    it and has been developing the language ever since. The company is the owner of
    the IntelliJ IDEA IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In February 2012, JetBrains made the language open source under the Apache v2
    license; the license allows developers to create applications.
  prefs: []
  type: TYPE_NORMAL
- en: The language is one option for **JVM** (**Java Virtual Machine**) languages
    such as Clojure and Scala, which means that the language can compile bytecode
    for JVM. As we will see, Kotlin has many similarities with Scala. Kotlin has the
    Scala language as a reference, but the JetBrains teams believe that Scala has
    problems with the compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin was becoming an adopted language in the Android world and because of
    this, in the Google I/O, 2017, the Google Team announced official support for
    the Android ecosystem. Since then, the language has been growing year by year
    and increasing in popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Main characteristics of Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language was designed to maintain the interoperability with Java
    code. It means we can start to code with Java idioms in the Kotlin file.
  prefs: []
  type: TYPE_NORMAL
- en: The language is statically-typed, and it is an excellent attribute because it
    can help us find some problems at compilation time. Also, statically-typed languages
    are much faster than dynamic languages. The IDEs can help developers much better
    than dynamic languages, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax is different from Java syntax. At first glance, it can be a problem
    but after some hours of playing with Kotlin, it is not a problem at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two interesting reserved words to understand the usage and concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var`: This is a variable declaration. It indicates the variable is mutable
    and can be reassigned, as developers need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val`: This is a variable declaration which indicates the variable is immutable
    and cannot be reassigned anymore. This definition is like a final declaration
    in the Java language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable declarations have a name, and after the desired data type, the
    colon is necessary in the middle as a separator. If the variable is initialized,
    the type is not necessary because the compiler can infer the correct data type.
    Let's try it out to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a variable with the data type specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to keep the data type because the variable is not initialized,
    then the compiler cannot infer the type. The variable, `bookName`, can be reassigned
    because of the modifier `var`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a variable without the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is not a necessity to declare the data type because we have initialized the
    variable with the value, `Spring 5.0 by Example`. The compiler can infer the type
    is a kind of *syntactic sugar.* The variable cannot be reassigned because of the
    modifier `val`. If we try to reassign the instruction, we will get a compilation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The semicolons are optional in Kotlin, the compiler can detect the statement
    terminator. This is another point where Kotlin diverges from the Java programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The semicolons were not provided, and the instructions were compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable programming in the Kotlin language is recommended. It performs better
    on the multi-core environments. Also, it makes the developer's life easier to
    debug and troubleshoot scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, there are classes and functions. However, there is no method anymore.
    The `fun` keyword should be used to declare a function.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin gets some concepts of the Scala language and brings some special classes
    such as Data classes and Object classes (which we will learn soon). Before that,
    we will understand how to declare a function in Kotlin. Let's do that!
  prefs: []
  type: TYPE_NORMAL
- en: Declaring functions in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many variations in function declarations. We will create some declarations
    to understand the slight difference from Java methods.
  prefs: []
  type: TYPE_NORMAL
- en: Simple function with parameters and return type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This simple function has two parameters and a String as a return type. Take
    a look at a parameter declaration and observe the order, name and data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the type of argument which comes after the variable name is
    the same as on the variable declarations. The return type comes after the arguments
    list is separated with semicolons. The same function can be declared in the following
    way in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are some differences here. Firstly, there are semicolons in the Java code,
    and we can see the order of the methods and functions declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Simple function without return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how we can construct functions without a return value, the
    following function will not return any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is one difference, in this case, the `Unit` was introduced; this type
    of object corresponds to `void` in Java language. Then, in the preceding code,
    we have a function without a return. The `Unit` object can be removed if you want
    the compiler to understand the function has no return value.
  prefs: []
  type: TYPE_NORMAL
- en: Single expressions functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the function has a single expression we can remove the curly braces, the
    same as in Scala, and the function body should be specified after the `=` symbol.
    Let''s refactor our first function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can remove the `return` keyword, as well. Our function is pretty concise
    now. We removed `return` and the type of return as well. As we can see, the code
    is more readable now. If you want, the return type can be declared too.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To override a function on Kotlin, it is necessary to put an `override` keyword
    on the function declaration, and the base function needs to have the `open` keyword
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This way is more explicit than Java, it increases the legibility of the code
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes are the right solution when we want to hold and transfer data between
    system layers. Like in Scala, these classes offer some built-in functionalities
    such as `getters/setters`, `equals` and `hashCode`, `toString` method and the `copy`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have some interesting things in the code. The first thing we notice is that
    all of the attributes are immutable. It means there are no setters for all of
    them. The second is that in the class declaration, we can see a list of attributes.
    In this case, Kotlin will create a constructor with all attributes present in
    this class and because they are `val` it means final attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there is no default constructor anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature in Kotlin is that it enables developers to have
    default values on constructors, in our case the `new` attribute, if omitted, will
    assume the `false` value. We can get the same behavior in the parameters list
    in functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is a fantastic way to copy objects. The `copy` method allows
    developers to copy objects with named parameters. This means we can change only
    attributes as we need. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first object, we have created a book instance with `false` for the `new`
    attribute, then we copied a new object with `true` for the `new` attribute, and
    the other attributes are not changed. Goodbye to the complex clone logic and nice
    to meet the new way to copy objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b9b01fb-bf93-4708-9fee-443e96cb94d9.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, only the `new` attribute is changed and the `toString` function
    was generated in good shape as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are some restrictions on Data classes. They cannot be abstract, open,
    sealed, or inner.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern is commonly used in applications, and Kotlin provides
    an easy way to do that without much boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: We can instruct Kotlin to create a singleton object using the `object` keyword.
    Once again,  Kotlin used Scala as a reference because there are the same functionalities
    in the Scala language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a formatter to return a message with the book name. Then, we
    try to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function format can be called in a static context. There is no instance
    to call the function because it is a singleton object.
  prefs: []
  type: TYPE_NORMAL
- en: Companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **companion object** is an object which is common for all instances of that
    class. It means there are many instances of a book, for example, but there is
    a single instance of their companion object. Usually, the developers use companion
    objects as a factory method. Let''s create our first `companion object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name of the `companion object` was omitted, the function could be called
    in a singleton way, without an instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is like an `object` behavior. We can call it in a static context.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Koltin idioms are a kind of syntax sugar for Java programmers. It is a collection
    of pieces of code which help developers to create a concise code in Kotlin languages.
    Let's take a look at common Kotlin idioms.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports string interpolation, it is a little bit complex to do it in
    the Java language but it is not a problem for Kotlin. We do not require a lot
    of code to do this task as Kotlin supports it natively. It makes the code easier
    to read and understand. Let''s create an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see,  it is a piece of cake to interpolate strings in Kotlin. Goodbye
    `String.format()` with a lot of arguments. We can use `$bookName` to replace the
    `bookName` variable value. Also, we can access the functions present in objects,
    but for that, we need to put curly braces. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thanks, Kotlin we appreciate this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports the feature called Smart Casts which enables developers to
    use the cast operators automatically. After checking the variable type, in Java,
    the cast operator must be explicit. Let''s check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the cast operator is not present anymore. After checking the
    type, Kotlin can infer the expected type. Let''s check the Java version for the
    same piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It makes the cast safer because we do not need to check and apply the cast operator.
  prefs: []
  type: TYPE_NORMAL
- en: Range expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Range expressions permit developers to work with ranges in `for` loops and `if`
    comparison. There are a lot of ways to work with ranges in Kotlin. We will take
    a look at most of the common ones here.
  prefs: []
  type: TYPE_NORMAL
- en: Simple case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at one simple case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It will iterate from `1` to `5` inclusive because we have used them in the `in` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The until case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also can use the `until` keyword in `for` loops, in this case, the end element
    will be excluded from the interaction. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `5` value will not be printed on the console, because the
    end element is not included in the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: The downTo case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `downTo` keyword enables developers to interact with the numbers in reverse
    order. The instruction is self-explanatory, as well. Let''s see it in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is pretty easy as well. The interaction will occur in the reverse order,
    in this case, the value `1` will be included. As we can see, the code is pretty
    easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Step case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to interact over values but with the arbitrary steps, not
    one by one, for example. Then we can use the `step` instruction. Let''s practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will see the following output: `135`, because the interaction will
    start on the `1` value and will be increased by two points.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome. The Kotlin ranges can add more readability to our source code and help
    to increase the quality of code as well.
  prefs: []
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has amazing stuff to work with null references. The null reference is
    a nightmare for Java developers. The Java 8 has an `Optional` object, which helps
    developers work with nullable objects, but is not concise like in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore how Kotlin can help developers to avoid the `NullPointerException`.
    Let's understand.
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin type system makes a distinction between references which can hold
    null and those which cannot hold null. Due to this, the code is more concise and
    readable because it is a kind of advice for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the reference does not allow null, the declaration should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding variable cannot be assigned to a null reference, if we do this,
    we will get a compilation error. Look how easy the code is to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to allow for a variable to have null references, in these
    cases, we can use the `?` as an operator, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Easy. Pay attention to a variable declaration on the `?` operator, it makes
    the variable accept null references.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways to avoid the `NullPointerReference` in Kotlin.
    The first one can be called **safe calls**, and the other can be called the **Elvis
    Operator**. Let's take a look at those.
  prefs: []
  type: TYPE_NORMAL
- en: Safe calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The safe call can be written using the `.?`. It can be called when the reference
    holds a non-null value when the value holds a null reference then the null value
    will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the `hash?` holds null, the null value will be assigned to a `queueString`
    attribute. If the `hash?` has a valid reference, the queue attribute will be assigned
    to a `queueString` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Elvis operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be used when developers expect to return a default value when the reference
    is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the value holds null, the default value will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Time to use Kotlin in the real world. Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can use the basics of the Kotlin language. We saw some examples and
    practiced a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the main concepts of Kotlin. We have learned how data classes can
    help developers to transfer data between application layers. Also, we learned
    about singleton and companion objects. Now we can try to create a real project
    with the pretty new support from Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will create a project using the Kotlin language, for
    now, we can forget about the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have a good idea about how we can use programming in Kotlin language.
    In this section, we will create the basic structure for our new project in which
    the main feature is consuming the Twitter stream. Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Project use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to code, we need to track the application requirements. The
    application is message-driven, we will use a broker to provide the messaging infrastructure.
    We choose the RabbitMQ broker because it provides reliability, high availability,
    and clustering options. Also, the RabbitMQ is a popular choice for the modern
    message-driven applications.
  prefs: []
  type: TYPE_NORMAL
- en: The software is powered by the Pivotal company, the same company which maintains Spring
    Framework. There is a huge community which supports the project.
  prefs: []
  type: TYPE_NORMAL
- en: We will have three projects. These three projects will collect the Twitter stream
    and send it to a recipient to show Tweets in a formatted way to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: The first one, which will be created in this chapter, will be responsible for
    keeping the tracked hashtags on the Redis cache.
  prefs: []
  type: TYPE_NORMAL
- en: When the new hashtags are registered, it will send a message to the second project
    which will start to consume the Twitter stream and redirect it to the desired
    queue. This queue will be consumed by the other project which will format the
    Tweet, and finally, show them to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: We will have three microservices. Let's create these things.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project with Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to use the Spring Initializr page. We will go to the page
    and then select the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reactive Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reactive Redis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The page content should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba757251-3e98-4c43-8957-d017f813ea1a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can choose the group and artifact. There is no problem with using the different
    name. Then, we can click on Generate Project and wait until the download ends.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Jackson for Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add Jackson for Kotlin dependencies for Maven projects. In fact,
    we need a Kotlin standard library on our `pom.xml`. Also, we need to put `jackson-module-kotlin`,
    it allows us to work with JSON on Kotlin, there are some differences from Java
    in these parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part is pretty simple, and we will add these following dependencies in
    the dependencies sections in `pom.xml`. The dependencies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the dependencies configured, and we can set the plugins to compile
    the Kotlin source code. In the next section, we will do that.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for the Maven plugins for Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project was created with Kotlin configured successfully. Now, we will take
    a look at the Maven plugin in our `pom.xml`. The configuration is necessary to
    instruct Maven on how to compile the Kotlin source code and add in the artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the following plugins in the plugins section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more thing to do. Take a look how Maven configures the path for
    our Kotlin code. It is easy peasy. Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We added our Kotlin folders in the source paths.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, the project structure is ready, and we can start coding!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker network for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create isolation for our application, we will create a custom Docker network.
    This network was created using the bridge driver. Let''s do that using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, now we can check the network list by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The Twitter network should be on the list, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab7b12b-2cbb-4e31-9c38-b64a7abdaf4f.png)'
  prefs: []
  type: TYPE_IMG
- en: The last one is our Twitter network. Let's pull the Redis image from the Docker
    Hub. Take a look at the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling the Redis image from the Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is download the Redis image from the Docker Hub.
    To do that, it is necessary to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have used the alpine version from Redis because it is smaller than the others
    and has a reasonable security. While the image is downloaded, we can see the downloading
    status progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the result using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6b1b2df-7c96-42c3-b1e0-f55f5ddecc29.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the images downloaded. The Redis must be on the list.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, now we will start the Redis instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Redis instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The image was downloaded, then we will start the Redis instance for our application.
    The command can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have interesting attributes here. We named our Redis instance with `redis`, it
    will be useful for running our application in containers in the next chapters.
    Also, we exposed the Redis container ports to the host machine, the command argument
    used for that is `-p`. Finally, we attached the container to our Twitter network.
  prefs: []
  type: TYPE_NORMAL
- en: Good, the Redis instance is ready to use. Let's check out the Spring Data Reactive
    Redis stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the redis-cli  tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an excellent tool to connect with the Redis instance which is called
    `redis-cli`. There are some Docker images for that, but we will install it on
    our Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Excellent, now we can connect and interact with our Redis container. The tool
    can perform the read and write instructions, then we need to be careful to avoid instructions
    unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect. The default configuration is enough for us because we have
    exported the port `6379` on the `run` instruction. Type the following command
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will connect with our running instance. The command line should display
    the Redis host and port, like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6f4c049-3109-4ddf-b08b-88fe1ae2ea19.png)'
  prefs: []
  type: TYPE_IMG
- en: Excellent, the client is configured and tested.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will execute some Redis commands on our container.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is an open source in-memory data structure. Redis fits well for a database
    cache and is not common, but it can be used as a message broker using the publish-subscribe
    feature, it can be useful to decouple applications.
  prefs: []
  type: TYPE_NORMAL
- en: There are some interesting features supported by Redis such as transactions,
    atomic operations, and support for time-to-live keys. Time-to-live is useful for
    giving a time for the key, the eviction strategy is always hard to implement,
    and Redis has a built-in solution for us.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of supported data types by Redis. The most common ones are strings,
    hashes, lists, and sorted sets. We will understand each of these a little bit
    because it is important to help us to choose the correct data type for our use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are the more basic data type of Redis. The string value can be at max
    512 MB in length. We can store it as a JSON in the value of the key, or maybe
    as an image as well because the Redis is binary safe.
  prefs: []
  type: TYPE_NORMAL
- en: Main commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some important commands we would need:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SET`: It sets the key and holds the value. It is a simple and basic command
    of Redis. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The return of the command should be `OK`. It indicates the instruction has been
    executed with success.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This command gets the value of the requested key. Remember `GET` can
    only be used with a string data type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the return of that command should be `joe`.
  prefs: []
  type: TYPE_NORMAL
- en: '`INCR`:The `INCR` command increments the key by one. It can be useful to handle
    sequential numbers atomically in distributed systems. The number increment will
    be returned as a command output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `INCR` command returned `1` as a command output and then
    we can check this using the `GET` and obtain the value.
  prefs: []
  type: TYPE_NORMAL
- en: '`DECR`: The `DECR` command is opposite of `INCR`, it will decrement the value
    atomically as well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `users` key was decremented by one and then transformed to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`INCRBY`:It will increment the value of the key by the argument. The new incremented
    value will be returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The new value was returned as a command output.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lists** are simple lists of strings. They are ordered by the insertion order.
    Redis also offers instructions to add new elements at the head or tail of the
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists can be useful for storing groups of things, groups of categories, for
    example, grouped by the `categories` key.
  prefs: []
  type: TYPE_NORMAL
- en: Main commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LPUSH`: Insert the new element at the head of the key. The command also supports
    multiple arguments, in this case, the values will be stored in the reverse order
    as we passed on the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some command examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the `LRANGE` output, as we can see the value of the `movie` is
    the first one on the list because the `LPUSH` inserted the new element on the
    head.
  prefs: []
  type: TYPE_NORMAL
- en: '`RPUSH`: Insert the new element at the tail of the key. The command supports
    multiple arguments as well, in this case, the values will respect the respective
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some command examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in the `LRANGE` output, the new values are inserted at the tail
    of the values. It is the behavior of the `RPUSH` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`LSET`:It sets the element on the requested index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some command examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The new value of the zero index is `series`. The `LSET` command does that for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: '`LRANGE`: It returns the specified elements of the key. The command arguments
    are the key, the start index, and finally the stop element. The `-1` on the stop
    argument will return the whole list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the first command will return three elements because the zero
    index will be grouped.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **set** is a collection of strings. They have a property which does not allow
    repeated values. It means that if we add the pre-existing value on the sets, it
    will result in the same element, in this case, the advantage is not necessary
    to verify if the element exists on the set. Another important characteristic is
    that the sets are unordered. This behavior is different from the Redis lists.
    It can be useful in different use cases such as count the unique visitor, track
    the unique IPs, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Main commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the main commands listed with their usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SADD`:It adds the element in a requested key. Also, the return of this command
    is the number of the element added to the set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the command returned one because we added one user each time.
  prefs: []
  type: TYPE_NORMAL
- en: '`SMEMBERS`:It returns all the members of a requested key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The command will return `joe` and `mary` because those are the values stored
    in the `unique-visitors` key.
  prefs: []
  type: TYPE_NORMAL
- en: '`SCARD`: It returns the numbers of elements of a requested key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The command will return the number of elements stored in the requested keys,
    in this case, the output will be `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Reactive Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data Redis provides an easy way to interact with the Redis Server from
    Spring Boot Apps. The project is part of the Spring Data family and provides high-level
    and low-level abstractions for the developers.
  prefs: []
  type: TYPE_NORMAL
- en: The Jedis and Lettuce connectors are supported as a driver for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The project offers a lot of features and facilities to interact with Redis.
    The `Repository` interfaces are supported as well. There is a `CrudRepository`
    for Redis like in other implementations, Spring Data JPA, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The central class for this project is the `RedisTemplate` which provides a high-level
    API  to perform Redis operations and serialization support. We will use this class
    to interact with set data structures on Redis.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive implementation is supported by this project, these are important
    characteristics for us because we are looking for Reactive implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the ReactiveRedisConnectionFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure the `ReactiveRedisConnectionFactory`, we can use the `application.yaml
    file`, because it is easier to maintain and centralize our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle is the same as other Spring Data Projects, we should provide
    the host and port configurations in the `application.yaml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration file, we point the Redis configuration to the `localhost`, as
    we can see. The configuration is pretty simple and easy to understand as well.
  prefs: []
  type: TYPE_NORMAL
- en: Done. The connection factory is configured. The next step is to provide a `RedisTemplate`
    to interact with our Redis instance. Take a look at the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a ReactiveRedisTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main class from Spring Data Redis is the `ReactiveRedisTemplate`, then we
    need to configure and provide an instance for the Spring container.
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide an instance and configure the correct serializer for the
    desired `ReactiveRedisTemplate`. `Serializers` is the way Spring Data Redis uses
    to serialize and deserialize objects from raw bytes stored in Redis in the `Key` and
    `Value` fields.
  prefs: []
  type: TYPE_NORMAL
- en: We will use only the `StringRedisSerializer` because our `Key` and `Value` are
    simple strings and the Spring Data Redis has this serializer ready for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s produce our `ReactiveRedisTemplate`. The implementation should look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Awesome. That is our first code using Kotlin in the Spring Framework. The keyword
    `open` is the opposite of Java's `final` keyword. It means this function can be
    inherited from this class. By default, all classes in Kotlin are final. Spring
    Framework requires non-final functions on `@Bean` on the `@Configuration` class
    and then we need to insert `open`.
  prefs: []
  type: TYPE_NORMAL
- en: We received `ReactiveRedisConnectionFactory` as a parameter. Spring knows which
    we produced in the `application.yaml` file using the configurations for Redis.
    Then the container can inject the factory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare `ReactiveRedisTemplate<String, String>` as a return value
    for our function.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting work, we are ready to work with our Redis template. Now, we will
    implement our first repository for Redis. See you in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tracked Hashtag repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created the `ReactiveRedisTemplate`, then we can use this object in
    our repository implementation. We will create a simple repository to interact
    with Redis, remember the repository should be reactive, it is an important characteristic
    of our application. Then we need to return `Mono` or `Flux` to make the repository
    Reactive. Let''s look at our repository implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We received the `ReactiveRedisTemplate<String, String>` as an injection on our
    class, the Spring Framework can detect the constructor and inject the correct
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we need these two functions. The first one is responsible for inserting
    our entity, `TrackedHashTag` on the set structure from Redis. We add the value
    of the `hash-tags` key on Redis. This function returns a `Mono` with the `TrackedHashTag`
    value. Pay attention to the `save` function. We have created a pattern for our
    value, the pattern follows the `hashtag`, `queue` where the hashtag is the value
    to gather Tweets and the queue we will use in the next sections to send to a RabbitMQ
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: The second function returns all values from the `hash-tags`key, it means all
    tracked hashtags from our system. Moreover, we need to do some logic to create
    our model, `TrackedHashTag`, as well.
  prefs: []
  type: TYPE_NORMAL
- en: The repository is finished, now we can create our service layer to encapsulate
    the repository. Let's do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our repository is ready to use, now we can create our service layer. This layer
    is responsible for orchestrating our repository calls. In our case, it is pretty
    simple but in some complex scenarios, it can help us to encapsulate the repository
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our service will be called  `TrackedHashTagService`, which will be responsible
    for interacting with our repository created previously. The implementation should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Well done. Here, there is basic stuff. We have the construct which injects our
    repository to interact with Redis. The interesting point here is the function
    declarations. There is not a body and return type because the Kotlin compiler
    can infer the return type, it helps the developer to avoid writing boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the REST resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have created the repository and service layer, and we are ready to
    expose our service through HTTP endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty concise and simple. Take a look at how concise this piece
    of code is. The preceding code is an example of how Kotlin helps developers to
    create readable codes. Thanks, Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Twitter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we will need to configure an application on the Twitter platform.
    It is necessary, because we will use Twitter's API to search Tweets, for example,
    and the Twitter account is the requirement for that. We will not explain how to
    create a Twitter account. There are plenty of articles about that on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Twitter account is created, we need to go to [https://apps.twitter.com/](https://apps.twitter.com/)
    and create a new app. The page is quite similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e51796d-f765-40b5-9ef2-a4213313e2b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will click on the Create New App button to start the creation process. When
    we click on that button, the following page will be displayed. We need to fill
    the required fields and accept the Twitter agreements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c320ffd1-053a-45d3-a6aa-bafa36a77bc8.png)'
  prefs: []
  type: TYPE_IMG
- en: We can choose the application name, fill in the description, and website. These
    details are up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to accept the agreements and click on Create your Twitter application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/534b0919-c437-4e2b-b6c9-e608c3a862a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome job. Our Twitter application is almost ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just need to configure the application for usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to check if our Keys and Access Tokens are correctly configured. Let''s
    click on the Keys and Access Tokens tab and check the values, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a159e216-d108-4936-80b5-757625629a85.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there are some important configurations in the preceding screenshot.
    The Consumer Key and Consumer Secret are mandatory to authenticate with Twitter
    APIs. Another important point here is the Access Level; be sure it is configured
    as read-only, as in the preceding screenshot, we will not do write actions on
    Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's Dockerize it.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome. We have the system which keeps the tracked hashtags on the Redis instance.
    The application is fully Reactive and has no blocking threads.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will configure the Maven plugin to generate the Docker images. The configuration
    is quite similar to what we did in [Chapter 3](827e9516-ff3d-44d7-8a16-95579684f453.xhtml), *Persistence
    with Spring Data and Reactive Fashion*. However, now we will create a first container
    which we will run with the Kotlin language. Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will configure our `pom.xml` to be able to generate our Docker image.
    The first thing we need to change is our final name artifact because Docker images
    do not allow the - character, then we need to configure properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration is pretty simple, put the `<finalName>` tag on the `<build>`
    node. Let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Good. We have configured the final name properly to generate the Docker image
    correctly. Now, we will configure the Maven Docker plugin to generate the Docker
    image by the Maven goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the plugins section inside the build node, we should put in the following
    plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The configuration is pretty simple. We did this before. In the configuration
    section, we configured from the image, in our case the `openjdk:latest`, Docker
    entry point and exposed ports as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our Docker image in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our project was previously configured with the Maven Docker plugin. We can generate
    the Docker image with the Maven Docker plugin using the `docker:build` goal. Then,
    it is time to generate our Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the Docker image, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, we must wait for the Maven build and check if the Docker image was generated
    with success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Docker images and we should see the new image generated. To do this,
    we can use the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Right, we should see the `springfivebyexample/tracked_hashtag:latest` on the
    image list, like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c5c8842-0851-44f5-aa01-6694dced52d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, our Docker image is ready to run with our first Spring Boot Application
    in the Kotlin language. Let's run it right now.
  prefs: []
  type: TYPE_NORMAL
- en: Running the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's run our container. Before that, we need to keep in mind some things. The
    container should be run on the Twitter network to be able to connect to our Redis
    instance which is running on the Twitter network as well. Remember the `localhost`
    address for Redis does not work anymore when running in the containers infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our container, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, our application is running in the Docker container and connected
    to our Redis instance. Let's create and test our APIs to check the desired behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our container is running. Now, we can try to call the APIs to check the behaviors.
    In this part, we will use the `curl` command line. The `curl` allows us to call
    APIs by the command line on Linux. Also, we will use `jq` to make the JSON readable
    on the command line, if you do not have these, look at the Tip Box to install
    these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our create API, remember to create we can use the `POST` method
    in the base path of API. Then type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are interesting things here. The `-H` argument instructs `curl` to put
    it in the request headers and `-d` indicates the request body. Moreover, finally,
    we have the server address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the new `tracked-hash-tag`. Let''s check our `GET` API to obtain
    this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome, we called the `curl` tool and printed the JSON value with the `jq`
    tool. The command output should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78a874e0-1f2d-44cd-a9fc-3b323f458a48.png)'
  prefs: []
  type: TYPE_IMG
- en: To install `curl` on Ubuntu, we can use `sudo apt-get install curl -y`. Moreover,
    to install `jq,` we can use `sudo apt-get install jq -y`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been introduced to the Kotlin language, which is the
    most prominent language for the JVM, because it has a super-fast compiler, if
    we compare it to Scala, for example. It also brings the simplicity of code and
    helps developers to create more concise and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: We have also created our first application in the Spring Framework using Kotlin
    as the basic concepts of the language, and we saw how Kotlin helps the developers
    in a practical way.
  prefs: []
  type: TYPE_NORMAL
- en: We have introduced Redis as a cache and Spring Data Reactive Redis, which supports 
    Redis in a Reactive paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we learned how to create a Twitter application
    which required us to create our next application, and start to consume the Twitter
    API in reactive programming with a Reactive Rest Client.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump to the next chapter and learn more about Spring Reactive.
  prefs: []
  type: TYPE_NORMAL
