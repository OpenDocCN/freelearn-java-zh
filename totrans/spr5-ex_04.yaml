- en: Kotlin Basics and Spring Data Redis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 基础和 Spring Data Redis
- en: Spring Boot allows developers to create different styles of application. In
    [Chapter 2](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml), *Starting in the Spring
    World – the CMS Application*, and [Chapter 3](827e9516-ff3d-44d7-8a16-95579684f453.xhtml),* Persistence
    with Spring Data and Reactive Fashion*, we have created a portal application,
    and now we will create an application based on message-driven architecture. It
    demonstrates how the Spring Framework fits well in a wide range of application
    architectures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 允许开发者创建不同风格的应用程序。在[第 2 章](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml)“从
    Spring 世界开始——CMS 应用程序”和[第 3 章](827e9516-ff3d-44d7-8a16-95579684f453.xhtml)“使用
    Spring Data 和响应式风格的持久化”中，我们已经创建了一个门户应用程序，现在我们将创建一个基于消息驱动架构的应用程序。它展示了 Spring 框架如何很好地适应各种应用程序架构。
- en: In this chapter, we will start to create an application which keeps the tracked
    hashtags on the Redis database. The application will get hashtags and put them
    in a couple of queues to our other projects, and consume and handle them appropriately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始创建一个应用程序，该应用程序将跟踪的标签存储在 Redis 数据库中。该应用程序将获取标签并将它们放入几个队列中，供我们的其他项目使用，并适当地消费和处理它们。
- en: As we have been doing in our previous projects, we will continue to use the
    Reactive Foundation to provide scalable characteristics in the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在以前的项目中所做的那样，我们将继续使用 Reactive Foundation 为应用程序提供可伸缩的特性。
- en: 'At the end of this chapter, we will have:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将：
- en: Learned Kotlin basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Kotlin 基础
- en: Created the project structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了项目结构
- en: Created the Reactive Redis repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了 Reactive Redis 存储库
- en: Applied some techniques in reactive programming, using the Reactive Redis Client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Reactive Redis 客户端应用了一些响应式编程技术
- en: Let's start right now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就让我们开始吧。
- en: Learning Kotlin basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Kotlin 基础
- en: The Kotlin language was released officially in February 2016\. JetBrains created
    it and has been developing the language ever since. The company is the owner of
    the IntelliJ IDEA IDE.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 语言于 2016 年 2 月正式发布。JetBrains 创建了它，并从那时起一直在开发这门语言。该公司是 IntelliJ IDEA IDE
    的所有者。
- en: In February 2012, JetBrains made the language open source under the Apache v2
    license; the license allows developers to create applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2012 年 2 月，JetBrains 在 Apache v2 许可证下将语言开源；该许可证允许开发者创建应用程序。
- en: The language is one option for **JVM** (**Java Virtual Machine**) languages
    such as Clojure and Scala, which means that the language can compile bytecode
    for JVM. As we will see, Kotlin has many similarities with Scala. Kotlin has the
    Scala language as a reference, but the JetBrains teams believe that Scala has
    problems with the compilation time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 语言是 JVM（Java 虚拟机）语言之一，如 Clojure 和 Scala，这意味着该语言可以为 JVM 编译字节码。正如我们将看到的，Kotlin
    与 Scala 有很多相似之处。Kotlin 以 Scala 语言为参考，但 JetBrains 团队认为 Scala 在编译时间上存在问题。
- en: Kotlin was becoming an adopted language in the Android world and because of
    this, in the Google I/O, 2017, the Google Team announced official support for
    the Android ecosystem. Since then, the language has been growing year by year
    and increasing in popularity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 正在成为 Android 世界中广泛采用的语言，因此，在 2017 年的 Google I/O 上，谷歌团队宣布了对 Android 生态系统的官方支持。从那时起，这门语言每年都在增长，并且越来越受欢迎。
- en: Main characteristics of Kotlin
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 的主要特性
- en: The Kotlin language was designed to maintain the interoperability with Java
    code. It means we can start to code with Java idioms in the Kotlin file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 语言被设计成与 Java 代码保持互操作性。这意味着我们可以在 Kotlin 文件中使用 Java 代码风格开始编码。
- en: The language is statically-typed, and it is an excellent attribute because it
    can help us find some problems at compilation time. Also, statically-typed languages
    are much faster than dynamic languages. The IDEs can help developers much better
    than dynamic languages, as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 语言是静态类型的，这是一个非常好的属性，因为它可以帮助我们在编译时找到一些问题。此外，静态类型语言比动态语言要快得多。IDEs（集成开发环境）在帮助开发者方面也比动态语言做得更好。
- en: Syntax
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: The syntax is different from Java syntax. At first glance, it can be a problem
    but after some hours of playing with Kotlin, it is not a problem at all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与 Java 语法不同。乍一看，这可能是个问题，但经过几个小时对 Kotlin 的实践，这根本不是问题。
- en: 'There are two interesting reserved words to understand the usage and concepts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个有趣的保留词可以帮助理解其用法和概念：
- en: '`var`: This is a variable declaration. It indicates the variable is mutable
    and can be reassigned, as developers need.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`：这是一个变量声明。它表示变量是可变的，可以根据开发者的需要重新分配。'
- en: '`val`: This is a variable declaration which indicates the variable is immutable
    and cannot be reassigned anymore. This definition is like a final declaration
    in the Java language.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`：这是一个变量声明，表示该变量是不可变的，不能再重新分配。这种定义类似于Java语言中的final声明。'
- en: The variable declarations have a name, and after the desired data type, the
    colon is necessary in the middle as a separator. If the variable is initialized,
    the type is not necessary because the compiler can infer the correct data type.
    Let's try it out to understand it better.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明有一个名称，在所需的数据类型之后，中间需要用冒号作为分隔符。如果变量被初始化，则不需要类型，因为编译器可以推断正确的数据类型。让我们试一试，以便更好地理解。
- en: 'Here is a variable with the data type specified:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个指定了数据类型的变量：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, we need to keep the data type because the variable is not initialized,
    then the compiler cannot infer the type. The variable, `bookName`, can be reassigned
    because of the modifier `var`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要保留数据类型，因为变量没有被初始化，编译器无法推断类型。由于`var`修饰符，变量`bookName`可以被重新分配。
- en: 'Here is a variable without the data type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个没有指定数据类型的变量：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is not a necessity to declare the data type because we have initialized the
    variable with the value, `Spring 5.0 by Example`. The compiler can infer the type
    is a kind of *syntactic sugar.* The variable cannot be reassigned because of the
    modifier `val`. If we try to reassign the instruction, we will get a compilation
    error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 声明数据类型不是必需的，因为我们已经用值`Spring 5.0 by Example`初始化了变量。由于`val`修饰符，变量不能被重新分配。如果我们尝试重新分配指令，将会得到编译错误。
- en: 'The semicolons are optional in Kotlin, the compiler can detect the statement
    terminator. This is another point where Kotlin diverges from the Java programming
    language:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中分号是可选的，编译器可以检测语句终止符。这是Kotlin与Java编程语言不同的另一个点：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The semicolons were not provided, and the instructions were compiled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供分号，指令被编译。
- en: Immutable programming in the Kotlin language is recommended. It performs better
    on the multi-core environments. Also, it makes the developer's life easier to
    debug and troubleshoot scenarios.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin语言中推荐使用不可变编程。它在多核环境中性能更优。同时，它使开发者更容易调试和排查问题场景。
- en: Semantics
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义
- en: In Kotlin, there are classes and functions. However, there is no method anymore.
    The `fun` keyword should be used to declare a function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，有类和函数。然而，不再有方法。应该使用`fun`关键字来声明函数。
- en: Kotlin gets some concepts of the Scala language and brings some special classes
    such as Data classes and Object classes (which we will learn soon). Before that,
    we will understand how to declare a function in Kotlin. Let's do that!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin借鉴了一些Scala语言的概念，并带来了一些特殊的类，如数据类和对象类（我们很快就会学习）。在那之前，我们将了解如何在Kotlin中声明函数。让我们来做这件事！
- en: Declaring functions in Kotlin
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中声明函数
- en: There are many variations in function declarations. We will create some declarations
    to understand the slight difference from Java methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明有很多变体。我们将创建一些声明来理解与Java方法之间的细微差别。
- en: Simple function with parameters and return type
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数和返回类型的简单函数
- en: This simple function has two parameters and a String as a return type. Take
    a look at a parameter declaration and observe the order, name and data type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数有两个参数，返回类型为String。看看参数声明并观察其顺序、名称和数据类型。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, the type of argument which comes after the variable name is
    the same as on the variable declarations. The return type comes after the arguments
    list is separated with semicolons. The same function can be declared in the following
    way in Java:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，变量名后面的参数类型与变量声明中的类型相同。返回类型在分号分隔的参数列表之后。以下方式可以在Java中声明相同的函数：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are some differences here. Firstly, there are semicolons in the Java code,
    and we can see the order of the methods and functions declarations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些差异。首先，Java代码中有分号，我们可以看到方法和函数声明的顺序。
- en: Simple function without return
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无返回值的简单函数
- en: 'Let''s understand how we can construct functions without a return value, the
    following function will not return any value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何构造无返回值的函数，以下函数将不会返回任何值：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is one difference, in this case, the `Unit` was introduced; this type
    of object corresponds to `void` in Java language. Then, in the preceding code,
    we have a function without a return. The `Unit` object can be removed if you want
    the compiler to understand the function has no return value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个区别，在这种情况下，引入了 `Unit`；这种类型的对象对应于 Java 语言中的 `void`。然后，在前面的代码中，我们有一个没有返回值的函数。如果你想编译器理解函数没有返回值，可以移除
    `Unit` 对象。
- en: Single expressions functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单表达式函数
- en: 'When the function has a single expression we can remove the curly braces, the
    same as in Scala, and the function body should be specified after the `=` symbol.
    Let''s refactor our first function, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数只有一个表达式时，我们可以移除大括号，就像在 Scala 中一样，函数体应该在 `=` 符号之后指定。让我们重构我们的第一个函数，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can remove the `return` keyword, as well. Our function is pretty concise
    now. We removed `return` and the type of return as well. As we can see, the code
    is more readable now. If you want, the return type can be declared too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以移除 `return` 关键字。我们的函数现在非常简洁。我们移除了 `return` 和返回类型。正如我们所看到的，代码现在更易读。如果你想，也可以声明返回类型。 '
- en: Overriding a function
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写函数
- en: To override a function on Kotlin, it is necessary to put an `override` keyword
    on the function declaration, and the base function needs to have the `open` keyword
    as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kotlin 中重写一个函数，需要在函数声明上放置一个 `override` 关键字，并且基函数也需要有 `open` 关键字。
- en: 'Let''s look at an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way is more explicit than Java, it increases the legibility of the code
    as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式比 Java 更明确，它也增加了代码的可读性。
- en: Data classes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Data classes are the right solution when we want to hold and transfer data between
    system layers. Like in Scala, these classes offer some built-in functionalities
    such as `getters/setters`, `equals` and `hashCode`, `toString` method and the `copy`
    function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在系统层之间持有和传输数据时，数据类是正确的解决方案。就像在 Scala 中一样，这些类提供了一些内置功能，如 `getters/setters`、`equals`
    和 `hashCode`、`toString` 方法以及 `copy` 函数。
- en: 'Let''s create an example for that:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个例子创建一个示例：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have some interesting things in the code. The first thing we notice is that
    all of the attributes are immutable. It means there are no setters for all of
    them. The second is that in the class declaration, we can see a list of attributes.
    In this case, Kotlin will create a constructor with all attributes present in
    this class and because they are `val` it means final attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中有一些有趣的事情。我们首先注意到所有的属性都是不可变的。这意味着它们都没有设置器。第二是，在类声明中，我们可以看到一个属性列表。在这种情况下，Kotlin
    将创建一个包含这个类中所有属性的构造函数，因为它们是 `val`，这意味着它们是最终属性。
- en: In this case, there is no default constructor anymore.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不再有默认构造函数。
- en: Another interesting feature in Kotlin is that it enables developers to have
    default values on constructors, in our case the `new` attribute, if omitted, will
    assume the `false` value. We can get the same behavior in the parameters list
    in functions as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 另一个有趣的功能是它允许开发者为构造函数提供默认值，在我们的例子中，如果省略了 `new` 属性，它将假设 `false` 值。我们也可以在函数的参数列表中得到相同的行为。
- en: 'Finally, there is a fantastic way to copy objects. The `copy` method allows
    developers to copy objects with named parameters. This means we can change only
    attributes as we need. Let''s take a look at an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个复制对象的绝佳方法。`copy` 方法允许开发者使用命名参数来复制对象。这意味着我们可以根据需要只更改属性。让我们来看一个例子：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first object, we have created a book instance with `false` for the `new`
    attribute, then we copied a new object with `true` for the `new` attribute, and
    the other attributes are not changed. Goodbye to the complex clone logic and nice
    to meet the new way to copy objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个对象中，我们使用 `false` 为 `new` 属性创建了一个书实例，然后我们使用 `true` 为 `new` 属性复制了一个新对象，其他属性没有改变。告别复杂的克隆逻辑，欢迎新的复制对象方式。
- en: 'The output of this code should look like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出应该如下所示：
- en: '![](img/3b9b01fb-bf93-4708-9fee-443e96cb94d9.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b9b01fb-bf93-4708-9fee-443e96cb94d9.png)'
- en: As we can see, only the `new` attribute is changed and the `toString` function
    was generated in good shape as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，只有 `new` 属性被更改，并且 `toString` 函数也被良好地生成。
- en: There are some restrictions on Data classes. They cannot be abstract, open,
    sealed, or inner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类有一些限制。它们不能是抽象的、开放的、密封的或内部的。
- en: Objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: The singleton pattern is commonly used in applications, and Kotlin provides
    an easy way to do that without much boilerplate code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式在应用程序中常用，Kotlin 提供了一种简单的方法来做这件事，而不需要太多的样板代码。
- en: We can instruct Kotlin to create a singleton object using the `object` keyword.
    Once again,  Kotlin used Scala as a reference because there are the same functionalities
    in the Scala language.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指示 Kotlin 使用 `object` 关键字创建一个单例对象。再次强调，Kotlin 使用 Scala 作为参考，因为在 Scala 语言中也有相同的功能。
- en: 'Let''s try it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have created a formatter to return a message with the book name. Then, we
    try to use this function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个格式化器，用于返回带有书名的消息。然后，我们尝试使用这个函数：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function format can be called in a static context. There is no instance
    to call the function because it is a singleton object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数格式可以在静态上下文中调用。因为没有实例来调用函数，因为它是一个单例对象。
- en: Companion objects
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'A **companion object** is an object which is common for all instances of that
    class. It means there are many instances of a book, for example, but there is
    a single instance of their companion object. Usually, the developers use companion
    objects as a factory method. Let''s create our first `companion object`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**companion object** 是一个对所有该类实例都通用的对象。这意味着有很多书籍的实例，但它们的伴生对象只有一个实例。通常，开发者使用伴生对象作为工厂方法。让我们创建我们的第一个
    `companion object`：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the name of the `companion object` was omitted, the function could be called
    in a singleton way, without an instance, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了 `companion object` 的名称，函数可以通过单例方式调用，无需实例，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is like an `object` behavior. We can call it in a static context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像 `object` 的行为。我们可以在静态上下文中调用它。
- en: Kotlin idioms
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 习惯用法
- en: Koltin idioms are a kind of syntax sugar for Java programmers. It is a collection
    of pieces of code which help developers to create a concise code in Kotlin languages.
    Let's take a look at common Kotlin idioms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 习惯用法是 Java 程序员的一种语法糖。它是一组代码片段，帮助开发者以 Kotlin 语言创建简洁的代码。让我们看看常见的 Kotlin
    习惯用法。
- en: String interpolation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'Kotlin supports string interpolation, it is a little bit complex to do it in
    the Java language but it is not a problem for Kotlin. We do not require a lot
    of code to do this task as Kotlin supports it natively. It makes the code easier
    to read and understand. Let''s create an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持字符串插值，在 Java 语言中做这个稍微复杂一些，但对于 Kotlin 来说不是问题。我们不需要很多代码来完成这个任务，因为 Kotlin
    本地支持它。这使得代码更容易阅读和理解。让我们创建一个示例：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we can see,  it is a piece of cake to interpolate strings in Kotlin. Goodbye
    `String.format()` with a lot of arguments. We can use `$bookName` to replace the
    `bookName` variable value. Also, we can access the functions present in objects,
    but for that, we need to put curly braces. Check the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 Kotlin 中插值字符串是一件轻而易举的事情。再见 `String.format()` 和它的许多参数。我们可以使用 `$bookName`
    来替换 `bookName` 变量的值。此外，我们还可以访问对象中存在的函数，但为此我们需要使用花括号。查看以下代码：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thanks, Kotlin we appreciate this feature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢，Kotlin，我们感谢这个特性。
- en: Smart Casts
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能转换
- en: 'Kotlin supports the feature called Smart Casts which enables developers to
    use the cast operators automatically. After checking the variable type, in Java,
    the cast operator must be explicit. Let''s check it out:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持一个名为智能转换的功能，它允许开发者自动使用类型转换操作符。在 Java 中，在检查变量类型后，类型转换操作符必须是显式的。让我们来看看：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, the cast operator is not present anymore. After checking the
    type, Kotlin can infer the expected type. Let''s check the Java version for the
    same piece of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，类型转换操作符已经不再存在。在检查类型后，Kotlin 可以推断出期望的类型。让我们检查一下相同代码的 Java 版本：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It makes the cast safer because we do not need to check and apply the cast operator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它使类型转换更安全，因为我们不需要检查和应用类型转换操作符。
- en: Range expressions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围表达式
- en: Range expressions permit developers to work with ranges in `for` loops and `if`
    comparison. There are a lot of ways to work with ranges in Kotlin. We will take
    a look at most of the common ones here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 范围表达式允许开发者在使用 `for` 循环和 `if` 比较时处理范围。在 Kotlin 中处理范围有很多方法。我们在这里将查看其中大部分的常见方法。
- en: Simple case
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单案例
- en: 'Let''s look at one simple case:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的案例：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It will iterate from `1` to `5` inclusive because we have used them in the `in` keyword.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它将迭代从 `1` 到 `5`（包括 `1` 和 `5`），因为我们使用了 `in` 关键字。
- en: The until case
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: until 情况
- en: 'We also can use the `until` keyword in `for` loops, in this case, the end element
    will be excluded from the interaction. Let''s see an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `for` 循环中使用 `until` 关键字，在这种情况下，结束元素将被排除在交互之外。让我们看看一个示例：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the `5` value will not be printed on the console, because the
    end element is not included in the interaction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`5` 的值不会在控制台上打印出来，因为交互不包括最后一个元素。
- en: The downTo case
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: downTo 情况
- en: 'The `downTo` keyword enables developers to interact with the numbers in reverse
    order. The instruction is self-explanatory, as well. Let''s see it in practice:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`downTo` 关键字使开发者能够以相反的顺序与数字进行交互。指令也是不言自明的。让我们看看实际应用：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is pretty easy as well. The interaction will occur in the reverse order,
    in this case, the value `1` will be included. As we can see, the code is pretty
    easy to understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很容易。交互将以相反的顺序发生，在这种情况下，值 `1` 将被包含。正如我们所看到的，代码非常容易理解。
- en: Step case
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤情况
- en: 'Sometimes we need to interact over values but with the arbitrary steps, not
    one by one, for example. Then we can use the `step` instruction. Let''s practice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要以任意步骤而不是逐个与值交互，例如。然后我们可以使用 `step` 指令。让我们来练习一下：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we will see the following output: `135`, because the interaction will
    start on the `1` value and will be increased by two points.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到以下输出：`135`，因为交互将从 `1` 值开始，并增加两个点。
- en: Awesome. The Kotlin ranges can add more readability to our source code and help
    to increase the quality of code as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 极佳。Kotlin 的范围可以增加我们源代码的可读性，并有助于提高代码质量。
- en: Null safety
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全
- en: Kotlin has amazing stuff to work with null references. The null reference is
    a nightmare for Java developers. The Java 8 has an `Optional` object, which helps
    developers work with nullable objects, but is not concise like in Kotlin.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 有处理空引用的惊人功能。空引用对 Java 开发者来说是一个噩梦。Java 8 有一个 `Optional` 对象，它帮助开发者处理可空对象，但不像
    Kotlin 那样简洁。
- en: Now, we will explore how Kotlin can help developers to avoid the `NullPointerException`.
    Let's understand.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨 Kotlin 如何帮助开发者避免 `NullPointerException`。让我们来理解一下。
- en: The Kotlin type system makes a distinction between references which can hold
    null and those which cannot hold null. Due to this, the code is more concise and
    readable because it is a kind of advice for developers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的类型系统在可以持有空引用和不能持有空引用的引用之间做出区分。因此，代码更加简洁和易读，因为它为开发者提供了一种建议。
- en: 'When the reference does not allow null, the declaration should be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用不允许为空时，声明应该是这样的：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding variable cannot be assigned to a null reference, if we do this,
    we will get a compilation error. Look how easy the code is to understand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的变量不能分配给空引用，如果我们这样做，我们会得到编译错误。看看代码是多么容易理解。
- en: 'Sometimes, we need to allow for a variable to have null references, in these
    cases, we can use the `?` as an operator, such as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要允许变量有空引用，在这些情况下，我们可以使用 `?` 作为操作符，例如以下所示：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Easy. Pay attention to a variable declaration on the `?` operator, it makes
    the variable accept null references.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。注意 `?` 操作符上的变量声明，它使变量能够接受空引用。
- en: There are two different ways to avoid the `NullPointerReference` in Kotlin.
    The first one can be called **safe calls**, and the other can be called the **Elvis
    Operator**. Let's take a look at those.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方法可以避免 Kotlin 中的 `NullPointerReference`。第一种可以称为 **安全调用**，另一种可以称为 **Elvis
    操作符**。让我们来看看这些。
- en: Safe calls
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全调用
- en: 'The safe call can be written using the `.?`. It can be called when the reference
    holds a non-null value when the value holds a null reference then the null value
    will be returned:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安全调用可以使用 `.?` 来编写。当引用持有非空值时可以调用，如果值持有空引用，则返回空值：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the `hash?` holds null, the null value will be assigned to a `queueString`
    attribute. If the `hash?` has a valid reference, the queue attribute will be assigned
    to a `queueString` attribute.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `hash?` 持有空值时，空值将被分配给 `queueString` 属性。如果 `hash?` 有有效的引用，队列属性将被分配给 `queueString`
    属性。
- en: Elvis operator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elvis 操作符
- en: 'It can be used when developers expect to return a default value when the reference
    is null:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在开发者期望在引用为空时返回默认值时使用：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the value holds null, the default value will be returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当值持有空时，将返回默认值。
- en: Time to use Kotlin in the real world. Let's begin.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在现实世界中使用 Kotlin 了。让我们开始吧。
- en: Wrapping it up
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now, we can use the basics of the Kotlin language. We saw some examples and
    practiced a little bit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Kotlin 语言的基础知识。我们看到了一些示例并实践了一下。
- en: We looked at the main concepts of Kotlin. We have learned how data classes can
    help developers to transfer data between application layers. Also, we learned
    about singleton and companion objects. Now we can try to create a real project
    with the pretty new support from Spring Framework.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了 Kotlin 的主要概念。我们学习了数据类如何帮助开发者在应用程序层之间传输数据。我们还了解了单例和伴随对象。现在我们可以尝试使用 Spring
    框架的新支持创建一个真实的项目。
- en: In the next sections, we will create a project using the Kotlin language, for
    now, we can forget about the Java language.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用 Kotlin 语言创建一个项目，目前我们可以暂时忘记 Java 语言。
- en: Creating the project
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: Now, we have a good idea about how we can use programming in Kotlin language.
    In this section, we will create the basic structure for our new project in which
    the main feature is consuming the Twitter stream. Let's do that.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了一个很好的想法，了解我们如何使用 Kotlin 语言进行编程。在本节中，我们将为我们的新项目创建基本结构，其中主要功能是消费 Twitter
    流。让我们来做这件事。
- en: Project use case
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目用例
- en: Before we start to code, we need to track the application requirements. The
    application is message-driven, we will use a broker to provide the messaging infrastructure.
    We choose the RabbitMQ broker because it provides reliability, high availability,
    and clustering options. Also, the RabbitMQ is a popular choice for the modern
    message-driven applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要跟踪应用程序需求。该应用程序是消息驱动的，我们将使用代理来提供消息基础设施。我们选择 RabbitMQ 代理，因为它提供可靠性、高可用性和集群选项。此外，RabbitMQ
    是现代消息驱动应用程序的流行选择。
- en: The software is powered by the Pivotal company, the same company which maintains Spring
    Framework. There is a huge community which supports the project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件由 Pivotal 公司提供支持，该公司维护 Spring 框架。有一个庞大的社区支持该项目。
- en: We will have three projects. These three projects will collect the Twitter stream
    and send it to a recipient to show Tweets in a formatted way to the end user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有三个项目。这三个项目将收集 Twitter 流并将其发送给接收者，以便以格式化的方式向最终用户展示推文。
- en: The first one, which will be created in this chapter, will be responsible for
    keeping the tracked hashtags on the Redis cache.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，在本章中创建的，将负责在 Redis 缓存中保持跟踪的标签。
- en: When the new hashtags are registered, it will send a message to the second project
    which will start to consume the Twitter stream and redirect it to the desired
    queue. This queue will be consumed by the other project which will format the
    Tweet, and finally, show them to the end user.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当新标签注册时，它将向第二个项目发送消息，该项目将开始消费 Twitter 流并将其重定向到所需的队列。这个队列将被其他项目消费，该项目将格式化推文，并最终将它们展示给最终用户。
- en: We will have three microservices. Let's create these things.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有三个微服务。让我们创建这些服务。
- en: Creating the project with Spring Initializr
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Initializr 创建项目
- en: 'We have learned how to use the Spring Initializr page. We will go to the page
    and then select the following modules:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 Spring Initializr 页面。我们将访问该页面，然后选择以下模块：
- en: '`Reactive Web`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应式 Web`'
- en: '`Reactive Redis`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应式 Redis`'
- en: 'The page content should look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 页面内容应该看起来像这样：
- en: '![](img/ba757251-3e98-4c43-8957-d017f813ea1a.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba757251-3e98-4c43-8957-d017f813ea1a.png)'
- en: We can choose the group and artifact. There is no problem with using the different
    name. Then, we can click on Generate Project and wait until the download ends.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择组和工件。使用不同的名称没有问题。然后，我们可以点击生成项目并等待下载完成。
- en: Adding Jackson for Kotlin
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Kotlin 添加 Jackson
- en: We need to add Jackson for Kotlin dependencies for Maven projects. In fact,
    we need a Kotlin standard library on our `pom.xml`. Also, we need to put `jackson-module-kotlin`,
    it allows us to work with JSON on Kotlin, there are some differences from Java
    in these parts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 Maven 项目添加 Jackson for Kotlin 依赖项。实际上，我们需要在 `pom.xml` 中有一个 Kotlin 标准库。此外，我们需要添加
    `jackson-module-kotlin`，它允许我们在 Kotlin 中处理 JSON，在这些部分与 Java 有一些不同。
- en: 'This part is pretty simple, and we will add these following dependencies in
    the dependencies sections in `pom.xml`. The dependencies are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分相当简单，我们将在 `pom.xml` 的依赖项部分添加以下依赖项。依赖项如下：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we have the dependencies configured, and we can set the plugins to compile
    the Kotlin source code. In the next section, we will do that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了依赖项，我们可以设置插件来编译 Kotlin 源代码。在下一节中，我们将这样做。
- en: Looking for the Maven plugins for Kotlin
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 Kotlin 的 Maven 插件
- en: The project was created with Kotlin configured successfully. Now, we will take
    a look at the Maven plugin in our `pom.xml`. The configuration is necessary to
    instruct Maven on how to compile the Kotlin source code and add in the artifacts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已成功配置 Kotlin。现在，我们将查看 `pom.xml` 中的 Maven 插件。配置是必要的，以指导 Maven 如何编译 Kotlin 源代码并添加到工件中。
- en: 'We will add the following plugins in the plugins section:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在插件部分添加以下插件：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is one more thing to do. Take a look how Maven configures the path for
    our Kotlin code. It is easy peasy. Look at the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有件事要做。看看 Maven 是如何配置我们的 Kotlin 代码路径的。这很简单。看看下面的：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We added our Kotlin folders in the source paths.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在源路径中添加了我们的 Kotlin 文件夹。
- en: Awesome, the project structure is ready, and we can start coding!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，项目结构已经准备好了，我们可以开始编码了！
- en: Creating a Docker network for our application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建 Docker 网络
- en: 'To create isolation for our application, we will create a custom Docker network.
    This network was created using the bridge driver. Let''s do that using the following
    command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的应用程序创建隔离，我们将创建一个自定义的 Docker 网络。这个网络是使用 bridge 驱动程序创建的。让我们使用以下命令来做这件事：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Good, now we can check the network list by typing the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以通过输入以下命令来检查网络列表：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The Twitter network should be on the list, like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 网络应该像下面这样在列表中：
- en: '![](img/dab7b12b-2cbb-4e31-9c38-b64a7abdaf4f.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dab7b12b-2cbb-4e31-9c38-b64a7abdaf4f.png)'
- en: The last one is our Twitter network. Let's pull the Redis image from the Docker
    Hub. Take a look at the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是我们的 Twitter 网络。让我们从 Docker Hub 拉取 Redis 镜像。看看下一节。
- en: Pulling the Redis image from the Docker Hub
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Docker Hub 拉取 Redis 镜像
- en: 'The first thing we need to do is download the Redis image from the Docker Hub.
    To do that, it is necessary to execute the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从 Docker Hub 下载 Redis 镜像。为此，必须执行以下命令：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have used the alpine version from Redis because it is smaller than the others
    and has a reasonable security. While the image is downloaded, we can see the downloading
    status progress.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Redis 的 Alpine 版本，因为它比其他版本更小，并且安全性合理。当镜像下载时，我们可以看到下载状态进度。
- en: 'We can check the result using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来检查结果：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result should look like the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像下面这样：
- en: '![](img/d6b1b2df-7c96-42c3-b1e0-f55f5ddecc29.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6b1b2df-7c96-42c3-b1e0-f55f5ddecc29.png)'
- en: Take a look at the images downloaded. The Redis must be on the list.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下载的镜像。Redis 必须在列表中。
- en: Awesome, now we will start the Redis instance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在我们将启动 Redis 实例。
- en: Running the Redis instance
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Redis 实例
- en: 'The image was downloaded, then we will start the Redis instance for our application.
    The command can be:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像已下载，然后我们将为我们的应用程序启动 Redis 实例。命令可以是：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have interesting attributes here. We named our Redis instance with `redis`, it
    will be useful for running our application in containers in the next chapters.
    Also, we exposed the Redis container ports to the host machine, the command argument
    used for that is `-p`. Finally, we attached the container to our Twitter network.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一些有趣的属性。我们用 `redis` 命名了我们的 Redis 实例，它将在下一章中运行容器化应用程序时很有用。此外，我们将 Redis
    容器的端口暴露给了主机机器，用于此的命令参数是 `-p`。最后，我们将容器连接到了我们的 Twitter 网络中。
- en: Good, the Redis instance is ready to use. Let's check out the Spring Data Reactive
    Redis stuff.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Redis 实例已经准备好使用了。让我们检查一下 Spring Data Reactive Redis 相关的内容。
- en: Configuring the redis-cli  tool
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 redis-cli 工具
- en: There is an excellent tool to connect with the Redis instance which is called
    `redis-cli`. There are some Docker images for that, but we will install it on
    our Linux machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很好的工具可以连接到 Redis 实例，它被称为 `redis-cli`。为此有一些 Docker 镜像，但我们将在我们 Linux 机器上安装它。
- en: 'To install it, we can execute the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，我们可以执行以下命令：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Excellent, now we can connect and interact with our Redis container. The tool
    can perform the read and write instructions, then we need to be careful to avoid instructions
    unintentionally.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在我们可以连接并交互我们的 Redis 容器。该工具可以执行读写指令，然后我们需要小心避免意外执行指令。
- en: 'Let''s connect. The default configuration is enough for us because we have
    exported the port `6379` on the `run` instruction. Type the following command
    in the Terminal:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接。默认配置对我们来说足够了，因为我们已经在 `run` 指令中导出了端口 `6379`。在终端中输入以下命令：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we will connect with our running instance. The command line should display
    the Redis host and port, like the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将连接到我们的运行实例。命令行应显示Redis的主机和端口，如下面的截图所示：
- en: '![](img/d6f4c049-3109-4ddf-b08b-88fe1ae2ea19.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6f4c049-3109-4ddf-b08b-88fe1ae2ea19.png)'
- en: Excellent, the client is configured and tested.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，客户端已配置并测试。
- en: Now, we will execute some Redis commands on our container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的容器上执行一些Redis命令。
- en: Understanding Redis
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Redis
- en: Redis is an open source in-memory data structure. Redis fits well for a database
    cache and is not common, but it can be used as a message broker using the publish-subscribe
    feature, it can be useful to decouple applications.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个开源的内存数据结构。Redis非常适合作为数据库缓存，虽然不常见，但可以使用发布/订阅功能作为消息代理，这对于解耦应用程序非常有用。
- en: There are some interesting features supported by Redis such as transactions,
    atomic operations, and support for time-to-live keys. Time-to-live is useful for
    giving a time for the key, the eviction strategy is always hard to implement,
    and Redis has a built-in solution for us.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Redis支持一些有趣的功能，如事务、原子操作和对生存时间键的支持。生存时间对于为键设置时间非常有用，驱逐策略总是很难实现，而Redis为我们提供了一个内置的解决方案。
- en: Data types
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: There are a lot of supported data types by Redis. The most common ones are strings,
    hashes, lists, and sorted sets. We will understand each of these a little bit
    because it is important to help us to choose the correct data type for our use
    case.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Redis支持很多数据类型。最常见的是字符串、散列、列表和有序集合。我们将稍微了解每个数据类型，因为这对我们选择正确的数据类型来满足我们的用例非常重要。
- en: Strings
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are the more basic data type of Redis. The string value can be at max
    512 MB in length. We can store it as a JSON in the value of the key, or maybe
    as an image as well because the Redis is binary safe.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Redis更基本的数据类型。字符串值最大长度为512 MB。我们可以将其存储为键的值中的JSON，或者也可以作为图像存储，因为Redis是二进制安全的。
- en: Main commands
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要命令
- en: 'Let''s look at some important commands we would need:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要的一些重要命令：
- en: '`SET`: It sets the key and holds the value. It is a simple and basic command
    of Redis. Here''s an example:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET`:它设置键并保持值。这是Redis的一个简单且基本的命令。以下是一个示例：'
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The return of the command should be `OK`. It indicates the instruction has been
    executed with success.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的返回值应该是`OK`。这表示指令已成功执行。
- en: '`GET`: This command gets the value of the requested key. Remember `GET` can
    only be used with a string data type:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`:此命令获取请求键的值。记住`GET`只能用于字符串数据类型：'
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the return of that command should be `joe`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该命令的返回值应该是`joe`。
- en: '`INCR`:The `INCR` command increments the key by one. It can be useful to handle
    sequential numbers atomically in distributed systems. The number increment will
    be returned as a command output:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCR`:`INCR`命令通过一个原子操作将键值增加一。在分布式系统中处理顺序数字时非常有用。数值增加将作为命令输出返回：'
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, the `INCR` command returned `1` as a command output and then
    we can check this using the `GET` and obtain the value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`INCR`命令返回了命令输出`1`，然后我们可以使用`GET`来检查这个值。
- en: '`DECR`: The `DECR` command is opposite of `INCR`, it will decrement the value
    atomically as well:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECR`:`DECR`命令是`INCR`的反操作，它将以原子方式减少值：'
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The value of the `users` key was decremented by one and then transformed to `0`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`users`键的值减少了一个，然后转换为`0`。'
- en: '`INCRBY`:It will increment the value of the key by the argument. The new incremented
    value will be returned:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCRBY`:它将根据参数增加键的值。新的增加值将作为命令输出返回：'
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The new value was returned as a command output.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 新值作为命令输出返回。
- en: Lists
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: '**Lists** are simple lists of strings. They are ordered by the insertion order.
    Redis also offers instructions to add new elements at the head or tail of the
    list.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是简单的字符串列表。它们按插入顺序排序。Redis还提供了在列表头部或尾部添加新元素的指令。'
- en: Lists can be useful for storing groups of things, groups of categories, for
    example, grouped by the `categories` key.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以用于存储事物组，例如按`categories`键分组的事物组。
- en: Main commands
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要命令
- en: '`LPUSH`: Insert the new element at the head of the key. The command also supports
    multiple arguments, in this case, the values will be stored in the reverse order
    as we passed on the arguments.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`LPUSH`:在键的头部插入新元素。该命令也支持多个参数，在这种情况下，值将按我们传递的参数的相反顺序存储。'
- en: 'Here are some command examples:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些命令示例：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Take a look at the `LRANGE` output, as we can see the value of the `movie` is
    the first one on the list because the `LPUSH` inserted the new element on the
    head.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`LRANGE`输出，正如我们所见，`movie`的值是列表中的第一个，因为`LPUSH`在头部插入了新元素。
- en: '`RPUSH`: Insert the new element at the tail of the key. The command supports
    multiple arguments as well, in this case, the values will respect the respective
    order.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPUSH`: 在键的尾部插入新元素。该命令也支持多个参数，在这种情况下，值将按照相应的顺序排列。'
- en: 'Here are some command examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些命令示例：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, in the `LRANGE` output, the new values are inserted at the tail
    of the values. It is the behavior of the `RPUSH` command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在`LRANGE`输出中，新值被插入到值的尾部。这是`RPUSH`命令的行为。
- en: '`LSET`:It sets the element on the requested index.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`LSET`: 它设置在请求索引上的元素。'
- en: 'Here are some command examples:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些命令示例：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The new value of the zero index is `series`. The `LSET` command does that for
    us.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 零索引的新值是`series`。这是`LSET`命令为我们做的。
- en: '`LRANGE`: It returns the specified elements of the key. The command arguments
    are the key, the start index, and finally the stop element. The `-1` on the stop
    argument will return the whole list:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`LRANGE`: 它返回键的指定元素。命令参数是键、起始索引和最终停止元素。停止参数上的`-1`将返回整个列表：'
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can see, the first command will return three elements because the zero
    index will be grouped.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，第一个命令将返回三个元素，因为零索引将被分组。
- en: Sets
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A **set** is a collection of strings. They have a property which does not allow
    repeated values. It means that if we add the pre-existing value on the sets, it
    will result in the same element, in this case, the advantage is not necessary
    to verify if the element exists on the set. Another important characteristic is
    that the sets are unordered. This behavior is different from the Redis lists.
    It can be useful in different use cases such as count the unique visitor, track
    the unique IPs, and much more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是一组字符串。它们有一个不允许重复值的属性。这意味着如果我们向集合中添加预存在的值，它将导致相同的元素，在这种情况下，优势是不必要验证元素是否存在于集合中。另一个重要特征是集合是无序的。这种行为与Redis列表不同。它在不同的用例中可能很有用，例如统计唯一访客、跟踪唯一IP等。'
- en: Main commands
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要命令
- en: 'The following are the main commands listed with their usages:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列出其主要命令及其用法的以下内容：
- en: '`SADD`:It adds the element in a requested key. Also, the return of this command
    is the number of the element added to the set:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SADD`: 它在请求键中添加元素。此外，此命令的返回值是添加到集合中的元素数量：'
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, the command returned one because we added one user each time.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，命令返回一个，因为我们每次都添加了一个用户。
- en: '`SMEMBERS`:It returns all the members of a requested key:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMEMBERS`: 它返回请求键的所有成员：'
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The command will return `joe` and `mary` because those are the values stored
    in the `unique-visitors` key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回`joe`和`mary`，因为这些值存储在`unique-visitors`键中。
- en: '`SCARD`: It returns the numbers of elements of a requested key:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCARD`: 它返回请求键的元素数量：'
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The command will return the number of elements stored in the requested keys,
    in this case, the output will be `2`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回请求键中存储的元素数量，在这种情况下，输出将是`2`。
- en: Spring Data Reactive Redis
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data Reactive Redis
- en: Spring Data Redis provides an easy way to interact with the Redis Server from
    Spring Boot Apps. The project is part of the Spring Data family and provides high-level
    and low-level abstractions for the developers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Redis为从Spring Boot应用与Redis服务器交互提供了一个简单的方法。该项目是Spring Data家族的一部分，并为开发人员提供了高级和低级抽象。
- en: The Jedis and Lettuce connectors are supported as a driver for this project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Jedis和Lettuce连接器作为此项目的驱动程序得到支持。
- en: The project offers a lot of features and facilities to interact with Redis.
    The `Repository` interfaces are supported as well. There is a `CrudRepository`
    for Redis like in other implementations, Spring Data JPA, for example.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目提供了许多功能和便利来与Redis交互。`Repository`接口也得到了支持。有一个类似于其他实现（例如Spring Data JPA）的`CrudRepository`用于Redis。
- en: The central class for this project is the `RedisTemplate` which provides a high-level
    API  to perform Redis operations and serialization support. We will use this class
    to interact with set data structures on Redis.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的核心类是`RedisTemplate`，它提供了一个高级API来执行Redis操作和序列化支持。我们将使用此类与Redis上的集合数据结构交互。
- en: The Reactive implementation is supported by this project, these are important
    characteristics for us because we are looking for Reactive implementations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的支持是反应式实现，对我们来说，这些是重要的特性，因为我们正在寻找反应式实现。
- en: Configuring the ReactiveRedisConnectionFactory
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 ReactiveRedisConnectionFactory
- en: To configure the `ReactiveRedisConnectionFactory`, we can use the `application.yaml
    file`, because it is easier to maintain and centralize our configuration.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 `ReactiveRedisConnectionFactory`，我们可以使用 `application.yaml` 文件，因为它更容易维护和集中我们的配置。
- en: 'The principle is the same as other Spring Data Projects, we should provide
    the host and port configurations in the `application.yaml` file, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 原则与其他 Spring Data 项目相同，我们应该在 `application.yaml` 文件中提供主机和端口配置，如下所示：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding configuration file, we point the Redis configuration to the `localhost`, as
    we can see. The configuration is pretty simple and easy to understand as well.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置文件中，我们将 Redis 配置指向了 `localhost`，正如我们所看到的。配置相当简单且易于理解。
- en: Done. The connection factory is configured. The next step is to provide a `RedisTemplate`
    to interact with our Redis instance. Take a look at the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。连接工厂已配置。下一步是提供一个 `RedisTemplate` 来与我们的 Redis 实例交互。请看下一节。
- en: Providing a ReactiveRedisTemplate
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供一个 ReactiveRedisTemplate
- en: The main class from Spring Data Redis is the `ReactiveRedisTemplate`, then we
    need to configure and provide an instance for the Spring container.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Redis 的主要类是 `ReactiveRedisTemplate`，然后我们需要为 Spring 容器配置并提供一个实例。
- en: We need to provide an instance and configure the correct serializer for the
    desired `ReactiveRedisTemplate`. `Serializers` is the way Spring Data Redis uses
    to serialize and deserialize objects from raw bytes stored in Redis in the `Key` and
    `Value` fields.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个实例并配置正确的序列化器以用于所需的 `ReactiveRedisTemplate`。`Serializers` 是 Spring Data
    Redis 用于将对象从存储在 Redis 的原始字节序列化和反序列化的方式。
- en: We will use only the `StringRedisSerializer` because our `Key` and `Value` are
    simple strings and the Spring Data Redis has this serializer ready for us.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用 `StringRedisSerializer`，因为我们的 `Key` 和 `Value` 都是简单的字符串，Spring Data Redis
    已经为我们准备好了这个序列化器。
- en: 'Let''s produce our `ReactiveRedisTemplate`. The implementation should look
    like the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成我们的 `ReactiveRedisTemplate`。实现应该看起来像以下这样：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Awesome. That is our first code using Kotlin in the Spring Framework. The keyword
    `open` is the opposite of Java's `final` keyword. It means this function can be
    inherited from this class. By default, all classes in Kotlin are final. Spring
    Framework requires non-final functions on `@Bean` on the `@Configuration` class
    and then we need to insert `open`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。这是我们使用 Kotlin 在 Spring 框架中的第一个代码。关键字 `open` 是 Java 的 `final` 关键字的相反。这意味着这个函数可以从这个类继承。默认情况下，Kotlin
    中的所有类都是 final 的。Spring 框架要求在 `@Configuration` 类的 `@Bean` 上使用非 final 函数，然后我们需要插入
    `open`。
- en: We received `ReactiveRedisConnectionFactory` as a parameter. Spring knows which
    we produced in the `application.yaml` file using the configurations for Redis.
    Then the container can inject the factory.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为参数接收了 `ReactiveRedisConnectionFactory`。Spring 知道我们在 `application.yaml` 文件中使用了哪些配置来生成
    Redis。然后容器可以注入这个工厂。
- en: Finally, we declare `ReactiveRedisTemplate<String, String>` as a return value
    for our function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明 `ReactiveRedisTemplate<String, String>` 作为我们函数的返回值。
- en: Interesting work, we are ready to work with our Redis template. Now, we will
    implement our first repository for Redis. See you in the next section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的工作，我们准备好使用我们的 Redis 模板了。现在，我们将实现我们的第一个 Redis 存储库。下一节再见。
- en: Creating Tracked Hashtag repository
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建跟踪标签存储库
- en: 'We have created the `ReactiveRedisTemplate`, then we can use this object in
    our repository implementation. We will create a simple repository to interact
    with Redis, remember the repository should be reactive, it is an important characteristic
    of our application. Then we need to return `Mono` or `Flux` to make the repository
    Reactive. Let''s look at our repository implementation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `ReactiveRedisTemplate`，然后我们可以在我们的存储库实现中使用这个对象。我们将创建一个简单的存储库来与 Redis
    交互，记住存储库应该是反应式的，这是我们应用程序的一个重要特性。然后我们需要返回 `Mono` 或 `Flux` 来使存储库反应式。让我们看看我们的存储库实现：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We received the `ReactiveRedisTemplate<String, String>` as an injection on our
    class, the Spring Framework can detect the constructor and inject the correct
    implementation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的类中作为注入接收了 `ReactiveRedisTemplate<String, String>`，Spring 框架可以检测构造函数并注入正确的实现。
- en: For now, we need these two functions. The first one is responsible for inserting
    our entity, `TrackedHashTag` on the set structure from Redis. We add the value
    of the `hash-tags` key on Redis. This function returns a `Mono` with the `TrackedHashTag`
    value. Pay attention to the `save` function. We have created a pattern for our
    value, the pattern follows the `hashtag`, `queue` where the hashtag is the value
    to gather Tweets and the queue we will use in the next sections to send to a RabbitMQ
    queue.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们需要这两个函数。第一个函数负责将我们的实体，`TrackedHashTag`，插入到Redis的集合结构中。我们在Redis上添加`hash-tags`键的值。这个函数返回一个包含`TrackedHashTag`值的`Mono`。请注意`save`函数。我们已经为我们的值创建了一个模式，该模式遵循`hashtag`，`queue`，其中标签是收集推文的值，而队列是我们将在下一节中用于发送到RabbitMQ队列的队列。
- en: The second function returns all values from the `hash-tags`key, it means all
    tracked hashtags from our system. Moreover, we need to do some logic to create
    our model, `TrackedHashTag`, as well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数返回`hash-tags`键的所有值，这意味着我们系统跟踪的所有标签。此外，我们还需要进行一些逻辑操作来创建我们的模型，`TrackedHashTag`。
- en: The repository is finished, now we can create our service layer to encapsulate
    the repository. Let's do that in the next section.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库已完成，现在我们可以创建我们的服务层来封装存储库。让我们在下一节中这样做。
- en: Creating the service layer
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务层
- en: Our repository is ready to use, now we can create our service layer. This layer
    is responsible for orchestrating our repository calls. In our case, it is pretty
    simple but in some complex scenarios, it can help us to encapsulate the repository
    calls.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储库已经准备好使用，现在我们可以创建我们的服务层。这一层负责编排我们的存储库调用。在我们的案例中，这相当简单，但在一些复杂场景中，它可以帮助我们封装存储库调用。
- en: 'Our service will be called  `TrackedHashTagService`, which will be responsible
    for interacting with our repository created previously. The implementation should
    look like the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将被命名为`TrackedHashTagService`，它将负责与我们之前创建的存储库交互。实现应该看起来像以下这样：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Well done. Here, there is basic stuff. We have the construct which injects our
    repository to interact with Redis. The interesting point here is the function
    declarations. There is not a body and return type because the Kotlin compiler
    can infer the return type, it helps the developer to avoid writing boilerplate
    code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。在这里，有一些基本的东西。我们有一个注入我们的存储库以与Redis交互的构造函数。这里有趣的是函数声明。没有函数体和返回类型，因为Kotlin编译器可以推断返回类型，这有助于开发者避免编写样板代码。
- en: Exposing the REST resources
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开REST资源
- en: 'Now, we have created the repository and service layer, and we are ready to
    expose our service through HTTP endpoints:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了存储库和服务层，我们准备通过HTTP端点公开我们的服务：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code is pretty concise and simple. Take a look at how concise this piece
    of code is. The preceding code is an example of how Kotlin helps developers to
    create readable codes. Thanks, Kotlin.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简洁简单。看看这段代码有多简洁。前面的代码是Kotlin如何帮助开发者创建可读代码的一个例子。谢谢，Kotlin。
- en: Creating a Twitter application
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Twitter应用程序
- en: For this project, we will need to configure an application on the Twitter platform.
    It is necessary, because we will use Twitter's API to search Tweets, for example,
    and the Twitter account is the requirement for that. We will not explain how to
    create a Twitter account. There are plenty of articles about that on the internet.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要在Twitter平台上配置一个应用程序。这是必要的，因为我们将会使用Twitter的API来搜索推文，例如，而Twitter账户是这一需求的前提。我们不会解释如何创建Twitter账户。互联网上有很多关于这个的文章。
- en: 'After the Twitter account is created, we need to go to [https://apps.twitter.com/](https://apps.twitter.com/)
    and create a new app. The page is quite similar to the following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Twitter账户后，我们需要前往[https://apps.twitter.com/](https://apps.twitter.com/)并创建一个新的应用程序。页面与以下截图非常相似：
- en: '![](img/4e51796d-f765-40b5-9ef2-a4213313e2b6.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e51796d-f765-40b5-9ef2-a4213313e2b6.png)'
- en: 'We will click on the Create New App button to start the creation process. When
    we click on that button, the following page will be displayed. We need to fill
    the required fields and accept the Twitter agreements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将点击创建新应用程序按钮以开始创建过程。当我们点击该按钮时，将显示以下页面。我们需要填写所需的字段并接受Twitter协议：
- en: '![](img/c320ffd1-053a-45d3-a6aa-bafa36a77bc8.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c320ffd1-053a-45d3-a6aa-bafa36a77bc8.png)'
- en: We can choose the application name, fill in the description, and website. These
    details are up to you.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择应用程序名称，填写描述和网站。这些细节由你决定。
- en: 'Then, we need to accept the agreements and click on Create your Twitter application:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要接受协议并点击创建你的Twitter应用程序：
- en: '![](img/534b0919-c437-4e2b-b6c9-e608c3a862a8.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/534b0919-c437-4e2b-b6c9-e608c3a862a8.png)'
- en: Awesome job. Our Twitter application is almost ready to use.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。我们的Twitter应用程序几乎准备就绪可以使用。
- en: Now, we just need to configure the application for usage.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要配置应用程序以供使用。
- en: 'We need to check if our Keys and Access Tokens are correctly configured. Let''s
    click on the Keys and Access Tokens tab and check the values, shown as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查我们的密钥和访问令牌是否正确配置。让我们点击“密钥和访问令牌”标签并检查值，如下所示：
- en: '![](img/a159e216-d108-4936-80b5-757625629a85.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a159e216-d108-4936-80b5-757625629a85.png)'
- en: As we can see, there are some important configurations in the preceding screenshot.
    The Consumer Key and Consumer Secret are mandatory to authenticate with Twitter
    APIs. Another important point here is the Access Level; be sure it is configured
    as read-only, as in the preceding screenshot, we will not do write actions on
    Twitter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在前面的截图中有一些重要的配置。消费者密钥和消费者密钥是认证Twitter API所必需的。这里的一个重要点是访问级别；确保它配置为只读，如前一个截图所示，我们不会在Twitter上执行写操作。
- en: Let's Dockerize it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其Docker化。
- en: Awesome. We have the system which keeps the tracked hashtags on the Redis instance.
    The application is fully Reactive and has no blocking threads.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。我们有一个系统，它将跟踪的标签存储在Redis实例上。该应用程序是完全响应式的，没有阻塞线程。
- en: Now, we will configure the Maven plugin to generate the Docker images. The configuration
    is quite similar to what we did in [Chapter 3](827e9516-ff3d-44d7-8a16-95579684f453.xhtml), *Persistence
    with Spring Data and Reactive Fashion*. However, now we will create a first container
    which we will run with the Kotlin language. Let's do that.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置Maven插件以生成Docker镜像。配置与我们在[第3章](827e9516-ff3d-44d7-8a16-95579684f453.xhtml)中做的配置相当相似，*使用Spring
    Data和响应式模式进行持久化*。然而，现在我们将创建一个容器，我们将使用Kotlin语言运行它。让我们来做这件事。
- en: Configuring pom.xml
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置pom.xml
- en: Now, we will configure our `pom.xml` to be able to generate our Docker image.
    The first thing we need to change is our final name artifact because Docker images
    do not allow the - character, then we need to configure properly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置我们的`pom.xml`文件，以便能够生成我们的Docker镜像。首先我们需要更改的是我们的最终名称工件，因为Docker镜像不允许使用-字符，然后我们需要正确配置。
- en: 'The configuration is pretty simple, put the `<finalName>` tag on the `<build>`
    node. Let''s do that:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 配置相当简单，将`<finalName>`标签放在`<build>`节点上。让我们来做这件事：
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Good. We have configured the final name properly to generate the Docker image
    correctly. Now, we will configure the Maven Docker plugin to generate the Docker
    image by the Maven goal.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们已经正确配置了最终名称以正确生成Docker镜像。现在，我们将配置Maven Docker插件，通过Maven目标生成Docker镜像。
- en: 'In the plugins section inside the build node, we should put in the following
    plugin configuration:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建节点内的插件部分，我们应该放入以下插件配置：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The configuration is pretty simple. We did this before. In the configuration
    section, we configured from the image, in our case the `openjdk:latest`, Docker
    entry point and exposed ports as well.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 配置相当简单。我们之前已经这样做过了。在配置部分，我们配置了从镜像开始，在我们的例子中是`openjdk:latest`，Docker入口点和暴露的端口。
- en: Let's create our Docker image in the next section.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节创建我们的Docker镜像。
- en: Creating the image
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建镜像
- en: Our project was previously configured with the Maven Docker plugin. We can generate
    the Docker image with the Maven Docker plugin using the `docker:build` goal. Then,
    it is time to generate our Docker image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目之前已经配置了Maven Docker插件。我们可以使用Maven Docker插件通过`docker:build`目标生成Docker镜像。然后，是时候生成我们的Docker镜像了。
- en: 'To generate the Docker image, type the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成Docker镜像，请输入以下命令：
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, we must wait for the Maven build and check if the Docker image was generated
    with success.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须等待Maven构建并检查Docker镜像是否成功生成。
- en: 'Check the Docker images and we should see the new image generated. To do this,
    we can use the `docker images` command:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Docker镜像，我们应该看到新生成的镜像。为此，我们可以使用`docker images`命令：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Right, we should see the `springfivebyexample/tracked_hashtag:latest` on the
    image list, like the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，我们应该在镜像列表中看到`springfivebyexample/tracked_hashtag:latest`，如下面的截图所示：
- en: '![](img/0c5c8842-0851-44f5-aa01-6694dced52d3.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c5c8842-0851-44f5-aa01-6694dced52d3.png)'
- en: Awesome, our Docker image is ready to run with our first Spring Boot Application
    in the Kotlin language. Let's run it right now.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的Docker镜像已经准备好运行我们的第一个使用Kotlin语言的Spring Boot应用程序了。让我们现在运行它。
- en: Running the container
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: Let's run our container. Before that, we need to keep in mind some things. The
    container should be run on the Twitter network to be able to connect to our Redis
    instance which is running on the Twitter network as well. Remember the `localhost`
    address for Redis does not work anymore when running in the containers infrastructure.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的容器。在此之前，我们需要记住一些事情。容器应该运行在Twitter网络上，以便能够连接到同样运行在Twitter网络上的我们的Redis实例。记住，当在容器基础设施中运行时，Redis的`localhost`地址不再有效。
- en: 'To run our container, we can execute the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的容器，我们可以执行以下命令：
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Congratulations, our application is running in the Docker container and connected
    to our Redis instance. Let's create and test our APIs to check the desired behaviors.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们的应用程序正在Docker容器中运行，并且连接到了我们的Redis实例。让我们创建并测试我们的API以检查期望的行为。
- en: Testing APIs
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API
- en: Our container is running. Now, we can try to call the APIs to check the behaviors.
    In this part, we will use the `curl` command line. The `curl` allows us to call
    APIs by the command line on Linux. Also, we will use `jq` to make the JSON readable
    on the command line, if you do not have these, look at the Tip Box to install
    these tools.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用容器正在运行。现在，我们可以尝试调用API来检查行为。在这一部分，我们将使用`curl`命令行。`curl`允许我们在Linux上通过命令行调用API。此外，我们还将使用`jq`使命令行上的JSON可读，如果您没有这些工具，请查看提示框以安装这些工具。
- en: 'Let''s call our create API, remember to create we can use the `POST` method
    in the base path of API. Then type the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用我们的创建API，记住创建时我们可以在API的基本路径中使用`POST`方法。然后输入以下命令：
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are interesting things here. The `-H` argument instructs `curl` to put
    it in the request headers and `-d` indicates the request body. Moreover, finally,
    we have the server address.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情。`-H`参数指示`curl`将其放入请求头中，`-d`表示请求体。此外，最后我们有服务器地址。
- en: 'We have created the new `tracked-hash-tag`. Let''s check our `GET` API to obtain
    this data:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了新的`tracked-hash-tag`。让我们检查我们的`GET` API以获取这些数据：
- en: '[PRE59]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Awesome, we called the `curl` tool and printed the JSON value with the `jq`
    tool. The command output should look like the following screenshot:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们调用了`curl`工具，并使用`jq`工具打印了JSON值。命令输出应该看起来像以下截图：
- en: '![](img/78a874e0-1f2d-44cd-a9fc-3b323f458a48.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78a874e0-1f2d-44cd-a9fc-3b323f458a48.png)'
- en: To install `curl` on Ubuntu, we can use `sudo apt-get install curl -y`. Moreover,
    to install `jq,` we can use `sudo apt-get install jq -y`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu上安装`curl`，我们可以使用`sudo apt-get install curl -y`。此外，要安装`jq`，我们可以使用`sudo
    apt-get install jq -y`。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have been introduced to the Kotlin language, which is the
    most prominent language for the JVM, because it has a super-fast compiler, if
    we compare it to Scala, for example. It also brings the simplicity of code and
    helps developers to create more concise and readable code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Kotlin语言，这是JVM上最突出的语言，因为它有一个超级快的编译器，如果我们以Scala为例，它也带来了代码的简洁性和可读性，帮助开发者创建更简洁和可读的代码。
- en: We have also created our first application in the Spring Framework using Kotlin
    as the basic concepts of the language, and we saw how Kotlin helps the developers
    in a practical way.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用Kotlin作为语言的基本概念，在Spring框架中创建了我们的第一个应用程序，并看到了Kotlin如何以实际的方式帮助开发者。
- en: We have introduced Redis as a cache and Spring Data Reactive Redis, which supports 
    Redis in a Reactive paradigm.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Redis作为缓存和Spring Data Reactive Redis，它支持以响应式范式使用Redis。
- en: In the last part of the chapter, we learned how to create a Twitter application
    which required us to create our next application, and start to consume the Twitter
    API in reactive programming with a Reactive Rest Client.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们学习了如何创建Twitter应用程序，这要求我们创建下一个应用程序，并开始使用响应式编程和Reactive Rest Client来消费Twitter
    API。
- en: Let's jump to the next chapter and learn more about Spring Reactive.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到下一章，了解更多关于Spring Reactive的内容。
