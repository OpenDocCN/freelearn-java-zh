- en: 11\. Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will quickly look at how Java handles processes. You will
    start by exploring the Runtime and `ProcessBuilder` classes, their functions,
    and how to launch them, in order to then create a process from either class. You'll
    then learn to send and receive data between parent and child, and how to store
    the outcomes of a process in a file. In this chapter's final activity, you will
    use these skills to create a parent process which will launch a child that will
    print an outcome (then captured by the parent) to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.lang.Process` class is used to look for information about, and launch,
    runtime processes. If you want to understand how the `Process` class works, you
    can start by looking at the `Runtime` class. All Java programs include an instance
    of the `Runtime` class. It is possible to get information about the `Runtime`
    class by calling the `getRuntime()` method and assigning its outcome to a variable
    of the `Runtime` class. With that, it is possible to obtain information about
    the **JVM** environment that commands your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Processes carry the information relating to a program being launched on a computer.
    Each operating system handles processes differently. What the `Process` class
    is an opportunity to control them in the same way. This is done through a single
    method of the `Runtime` class, called `exec()`, which returns an object of the
    `Process` class. `Exec` has different implementations that allow you to simply
    issue a command, or to do so by modifying the environmental variable and even
    the directory the program will run from.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a process is launched with `exec()`. Let''s look at a
    simple example where we will call the Java compiler, something that is done the
    same way from the terminal on any operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When running this example, if you happen to have Firefox installed, it will
    launch automatically. You could change that to be any other application on your
    computer. The program will exit with no error, but it will not do anything besides
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a couple of lines to the previous example so that the program
    you just opened will be closed after 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `waitFor(timeOut, timeUnit)` method will wait for the process to end for
    5 seconds. If it was `waitFor()` without parameters, it would wait for the program
    to end by itself. Following the 5-second timeout, the process variable will call
    the `destroy()` method, which will stop the process immediately. For this reason,
    opening and closing an application over a short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative way of launching a process that doesn''t require the
    creation of a `Runtime` object. This other method makes use of the `ProcessBuilder`
    class. The construction of a `ProcessBuilder` object will require the actual command
    to be executed as a parameter. The following example is a revision of the previous
    one, with the addition of this new constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things you should be aware of. First, the process includes
    the call to the command as an argument in the constructor. However, that does
    not launch the process until you call `processBuilder.start()`. The only issue
    is that the object resulting from `ProcessBuilder` does not include the same method
    as the one coming from the `Process` API. For example, methods such as `waitFor()`
    and `destroy()` are not available, therefore, if those were needed, you would
    have to instantiate an object of `Process` before you could call it in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Input to a Child Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the process is running, it would be interesting to pass over some data
    to it. Let''s make a small program that will `echo` whatever you type on the CLI
    back to it. Later, we will write a program that will launch the first application
    and that will send text for it to print. This simple `echo` program could be like
    the one in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this simple program will be reading from the `System.in` stream
    until you press *Enter*. Once that happens, it will exit gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line of the preceding output, we enter the string ''`Hello World`''
    for this example, which is echoed on the next line. Next, you can make another
    program that will launch this example and send some text to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example has two interesting tricks that you need to look into. The first
    is the call to the previous example. Since we have to launch a Java application,
    we need to call the `java` executable with the `cp` parameter, which will indicate
    the directory in which **JVM** should be looking for the example compiled. You
    just compiled and tried out *Example05*, which means that there is already a compiled
    class in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After the call to the `cp` parameter, in Linux/macOS, you need to add a colon
    (`:`) before the name of the class, whereas in the case of Windows, you should
    use a semicolon (`;`).
  prefs: []
  type: TYPE_NORMAL
- en: Once you compile this example, its relative path to the previous example is
    `../../../../Example05/out/production/Example05`. This might be completely different
    in your case, depending on how you named your project folders.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note is also highlighted in the code listing. There, you
    can see the declaration of the `OutStream` that is linked to the one coming from
    the process. In other words, we are linking an outgoing stream from *Example06*
    to the `System.in` in the *Example05* application. In order to be able to write
    strings to it, we construct a `Writer` object that exposes a `write` method with
    the ability to send strings to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this example from the CLI using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result is nothing. The reason for this is that `System.out` on the echo
    example (*Example05*) is not made available to the application that initiated
    the process. If we want to use it, we need to capture it inside *Example06*. We
    will see how to do that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the Output of a Child Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have two different programs; one that can run by itself (*Example05*),
    and one that is executed from another one, which will also try to send information
    to it and capture its output. The purpose of this section is to capture the output
    from *Example05* and print it out to a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture whatever is being sent by the child process to `System.out`, we
    need to create a `BufferedReader` in the parent class that will be fed from the
    `InputStream` that can be instantiated from the process. In other words, we need
    to enhance *Example06* with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The reason for needing a `BufferedReader` is that we are using the end of the
    line (`EOL` or "`\n`") as a marker for a message between processes. That allows
    the utilization of methods such as `readLine()`, which will block the program
    until it captures an EOL; otherwise, we could stick to the `Reader` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added that to the example, calling the previous program from
    the terminal will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After this output, the program will end.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect to consider is that since `BufferedReader` is of a buffered
    nature, it requires the use of `flush()` as a way to force the data we sent to
    the buffer to be sent out to the child process. Otherwise, it will be waiting
    forever when **JVM** gives it a priority, which eventually could bring the program
    to a stall.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the Output of a Child Process in a File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wouldn''t it be useful to store the data in a file? This is one of the reasons
    why you may be interested in having a process to run a program (or a series of
    programs) â€“ capturing their output in a log file to study them. By adding a small
    modification to the process launcher, you could capture whatever it is that is
    sent to `System.out` by the other program. This is really powerful as you could
    make a program that could be used to launch any existing command in your operating
    system and capture all of its output, which could be used later to conduct some
    sort of forensic analysis of the outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The outcome will be not just writing the result to the terminal, but also creating
    a `data.log` file that will contain the exact same sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Making a Parent Process to Launch a Child Process'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will create a parent process that will launch a child process
    that will print out an increasing series of numbers. The outcomes of the child
    process will be captured by the parent, which will print them to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: To stop the program from running forever to reach infinity, the child process
    should stop when a certain number is reached. Let's take `50` as a limit for this
    activity, at which point the counter will exit.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the parent process will read the inputs and compare them with
    a certain number, for example, 37, after which the counter should restart. To
    ask the child process to restart, the parent should send a single-byte command
    to the child. Let's use an asterisk (`*`) for this activity. You should use the
    `sleep()` command so that printing on the terminal doesn't happen too quickly.
    A good configuration would be `sleep(200)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the abovementioned brief, the expected output from running the child
    program on its own is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But, when called from the parent program, the outcome should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The child should have an algorithm that looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, there is a call to `System.in.available()` to check whether there is any
    data in the output buffer from the child program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the other hand, the parent program should consider including something along
    the lines of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would detect whether the number that just arrived as a `String` will be
    converted to an `Integer`, and from there it would be compared to the limit we
    suggested for the counting to reset.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't go in-depth in terms of all of the methods offered by the `Process`
    class. It is therefore recommended to wrap the work in this chapter in good old-school
    reference documentation and visit JavaDoc to see what else this class has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found at page 559\. You can read more
    about the `Process` class on Oracle''s official documentation: [https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html](https://www.packtpub.com/application-development/mastering-java-9).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, you were introduced to the `Process` class in Java. You
    got to see how a process that outputs to `System.out` can be captured in the parent
    program. At the same time, you also saw how the parent can easily send data to
    the child. The examples showed that it is possible to launch not just your own
    programs, but also any other program, such as a web browser. The possibilities
    for building software automation with programs that include the `Process` API
    are endless.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw the importance of streams in terms of intra-process communication.
    Basically, you have to create streams on top of streams to develop more complex
    data structures, which will allow the code to run a lot faster. The next chapter
    will cover regular expressions.
  prefs: []
  type: TYPE_NORMAL
