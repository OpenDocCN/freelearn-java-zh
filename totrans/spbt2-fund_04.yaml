- en: The MVC Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, we will learn how to build a web-based application in Spring that uses
    web pages to interact with the user. As an example, we will be using a simple
    blog application. For that, we will first look at the Model–View–Controller (MVC)
    design pattern and how we can benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern is a very commonly used application design model. This
    model breaks an application into three interconnected parts. This is done to reduce
    the time taken to create object-oriented applications that have user interfaces.
    This model allows for the decoupling of the different models, views, and controllers,
    thereby facilitating the reuse of code and the simultaneous development of different
    sections of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the Model–View–Controller (MVC) pattern and its benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the role of the model, the view, and the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguish between a request-based and a component-based MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct your first real-life Spring Web MVC application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the MVC Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When web applications are built with a **User Interface** (**UI**), it can be
    cumbersome to develop the application when multiple developers are involved. In
    addition, maintenance can be difficult if too many concerns are mixed in parts
    of the written code.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern called MVC solves that problem. By separating the concerns
    for rendering and manipulating application data, it allows multiple programmers
    of a team to work on different aspects of the application in parallel. While one
    developer concentrates on the view, another one is able to implement the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also patterns to solve common software development problems. A popular
    set of these patterns has been introduced in the book *Design Patterns: Elements
    of Reusable Object-Oriented Software*, by Erich Gamma, Richard Helm, Ralph Johnson,
    and John Vlissides.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in the history of the MVC pattern, you can still find the
    original description of the MVC pattern on the pages of Trygve M H Reenskaug at
    [https://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](https://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html).
    Additionally, the original MVC reports are available at [http://folk.uio.no/trygver/2007/MVC_Originals.pdf](http://folk.uio.no/trygver/2007/MVC_Originals.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The MVC Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three components that are defined are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The application state or data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Renders the application data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Mediates between model, view, and the outside world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Model, View, and Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following table, which highlights the main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1613014f-6d55-4bdc-abb1-b62da0c71a1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Interacting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learnt about the MVC components, let''s take a look at how
    they interact with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fa1d4b8-fa5d-453d-ac6c-fecfcdece32b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical interaction consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The client makes a request to the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller manipulates the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model updates the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view is rendered and sent to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps illustrate the separation of concerns, as each component has a very
    well-defined task to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: MVC uses another design pattern called the **observer pattern**. It describes
    how a subject (the model) will update a number of observers (the view or parts
    of it) about changes that have been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about the observer pattern, you can find more information
    in the book *Design Patterns: Elements of Reusable Object-Oriented Software*,
    which we mentioned previously. Another good starting point is the entry about
    this pattern at [https://springframework.guru/gang-of-four-designpatterns/observer-pattern/](https://springframework.guru/gang-of-four-designpatterns/observer-pattern/).'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and Disadvantages of the MVC Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantages of the MVC pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simultaneous development**: Interfaces are well-defined and leverage developers
    with different skills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High cohesion**: Groups code that belongs together and that helps with maintenance,
    improvement, and refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple views**: Implements separate views for different media and keeps
    a single implementation of business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loosely coupled**: Only a small amount of knowledge is shared between components,
    and changes can be restricted to isolated parts of the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the MVC pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigating through the source code**: Source code can become very scattered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple implementations**: Developers have to keep track of multiple implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the pattern**: Developers have to understand the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-Based versus Component-Based MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to implement the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the request-based MVC approach, the developer has to handle the incoming
    requests themselves. This means that data has to be converted and validated manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, in a component-based MVC application, the framework will
    take care of the processing and builds components that resemble the parts rendered
    by the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49cd8c7a-41d9-4c46-87b1-a718a34211c9.png)'
  prefs: []
  type: TYPE_IMG
- en: While the request-based MVC architecture requires a lot of boilerplate code,
    it gives you fine control over the whole process and output. When you have very
    complex requirements to your view, this approach may be the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the request-based approach introduces more complexity, while
    the component-based method raises the developer's burden of component customization.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Web MVC Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learnt about the Model–View–Controller pattern, we will now
    take a look at how Spring Web MVC leverages this pattern to enable the development
    of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about web applications, we usually mean that the view is rendered
    in a browser. But before getting into the details, we will have a short discussion
    about two different ways that such a front-end can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Page Applications Versus Multi-Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to implement the client side of a web application that
    is also called the "frontend". The most commonly used architectures today are
    **Single-Page A****pplications** (**SPA**). Requests only change parts of the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, **Multi-Page Applications** (**MPA**) render a new page for every
    request.
  prefs: []
  type: TYPE_NORMAL
- en: In an MPA, the HTML of the view gets rendered on the server and is then sent
    back to the browser. Each action taken by the user results in a request made to
    the server, which responds with another full page or view.
  prefs: []
  type: TYPE_NORMAL
- en: SPA versus MPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following table that highlights the main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98401246-5187-439b-b3d6-59a5296af0d0.png)![](img/c130cbc5-45db-4194-83dd-5f08ac2842ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will be focusing on how to build a multi-page application.
    Next, you will get to know how to architect and implement an API that can build
    the back-end side of an SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Java Servlet API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now discover the Java Servlet API that builds an important foundation
    for any kind of web application in the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the level of knowledge, you may choose to focus on this sub-section
    or go ahead to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Servlet API is an architecture that aims to process HTTP requests that
    are made to a so-called container. It is developed under the **Java Community
    Process** (**JCP**) and is currently available in Version 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Popular containers that follow this specification are Apache Tomcat and Jetty.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet API Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following block diagram shows a typical relationship among the various
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59d3414e-4c34-4077-9920-b6f92a9affcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following table, which highlights the main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab9d0b47-e1ed-4f67-bbe8-38c7782486ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Web MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have been looking at all the basic patterns and technologies that are
    required to build and understand a working web application, we are now going to
    see how all of this can be applied to a Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot uses "starter dependencies" to add various features and capabilities
    to an application. In our case, we want to implement a web application that will
    require a web server to run. We also need support for the MVC pattern. The Spring
    Framework includes all that is required for building rich and modern web applications
    based on the MVC design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To leverage these features, all that is required is to include the spring-boot-starter-web
    dependency in our Maven `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Spring Web MVC Starter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim is to display an output on the web page using Spring Web MVC Starter.
    The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a CMD window and navigate to [https://bit.ly/2DmTaQA](https://bit.ly/2DmTaQA).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that your `JAVA_HOME` path is set correctly and start the project
    using the `mvnw spring-boot:run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f27559f7-b5e2-4bee-a3d5-cede5a82ae80.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the application stopping immediately after startup.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate the browser to `http://localhost:8080/hello.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d450b7e-c18c-4e13-ac87-ee448f3638f5.png)'
  prefs: []
  type: TYPE_IMG
- en: The browser cannot connect to the server and therefore displays an error page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to your `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start the project again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:8080/hello.html` to see a greeting page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Ctrl+C to stop the program. You can safely ignore the error message here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have obtained the expected greeting page using Spring Web MVC Starter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following output screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/239a6f9e-966e-4f56-a603-043a0a905570.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2OfiTwW](https://bit.ly/2OfiTwW) to access the code for
    the `WebstarterExerciseApplication.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Embedded Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the auto-configuration features of Spring Boot, the only thing you
    have to do is add the spring-boot-starter-web dependency to your Maven build file.
    By default, this will add an embedded Apache Tomcat server to your build. It will
    also build an executable JAR file that will start the server and deploy your application
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use a different web server, you can choose to do so by excluding
    the spring-boot-starter-tomcat dependency and add one of the following dependencies
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5f3b11d-a2b6-416e-8ab5-0a47d4cfcd73.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring DispatcherServlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Web MVC handles incoming requests by providing a servlet called `DispatcherServlet`.
    It is also called a **Front Controller** since it is the first part of the controller
    that handles incoming requests and dispatches them to other controller implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `DispatcherServlet` will be called for every request that is
    made to a URL starting with `/`. You can change this so-called context path by
    setting the `server.servlet.contextPath` property in the application.properties
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server.servlet.contextPath=/my-app`'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `DispatcherServlet`, and thus your application,
    will only respond to URLs starting with `/my-app`.
  prefs: []
  type: TYPE_NORMAL
- en: DispatcherServlet Interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following block diagram shows a typical relationship among the various
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36a3b584-6b32-4dfb-a664-fb06f0d097a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `DispatcherServlet` does all the heavy lifting when it comes to handling
    incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Determines which controller to call depending on the request URI. For this,
    it uses a `HandlerMapping` that is able to retrieve the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the controller method, optionally passing in the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the controller has finished, it returns the name of a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the view based on the name returned from the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolves the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renders the view back to the client, passing in the model to be rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very simple view on what takes place for incoming requests. We will
    get into more detail later when we look at some of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Controller as Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the `DispatcherServlet` is the front controller of the application responding
    to each incoming request, the business logic is implemented in its own method.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed in the previous section, a `HandlerMapper` is used to map
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a `RequestMappingHandlerMapping` is installed, which finds methods
    annotated with `@RequestMapping` contained within Spring components annotated
    with `@Controller`. We will learn more about this kind of mapping in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Static Views with HTML and Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every web application will require some kind of static view or asset. Take an
    "About" page, for example. However, since you cannot embed data from your model
    into this kind of page, you may not have much use for them. On the other hand,
    you will be required to serve some kind of static assets such as CSS files, JavaScript,
    or images. Spring Web MVC is able to serve this kind of content that is placed
    in a folder called `static`. If you're using a build tool such as Maven or Gradle,
    as we do, the full path will be `/src/main/resources/static` from the project
    root.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Client-Side Web Libraries Through WebJars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides using the static folder to provide static assets, there is another mechanism
    called WebJars.
  prefs: []
  type: TYPE_NORMAL
- en: A **WebJar** is a client-side web library packed as a Java-Archive. Examples
    of these libraries include JQuery for common JavaScript tasks related to web pages,
    or **Bootstrap**, a library to build responsive web designs. It can be easily
    downloaded and deployed as a dependency when using a build tool such as Maven.
    In addition, transitive dependencies will also be downloaded and provided automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The content structure of a WebJar archive is standardized and includes folder
    structure as well as certain files that need to be present.
  prefs: []
  type: TYPE_NORMAL
- en: If a WebJar is present on the classpath, Spring Boot will configure your application
    to map HTTP requests to `/webjars to the /META-INF/resources/webjars` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you include multiple WebJars in your classpath, they will all be available
    under the same `/webjars URI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can include the WebJar of Bootstrap by adding the following
    dependency to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the main CSS file for this library, include the following line in
    your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the library is referenced under the `/webjars` folder by its
    name (bootstrap). After this, the version number is added, followed by the path
    to the required resource, which depends on the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want to add the library version to the URI, you can add the `webjar-locator`
    dependency to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this dependency in place, you can change the link tag in your HTML file
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that after adding the webjars-locator, the mapping for static files
    in the `/static` folder will no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the WebJar standard, visit [http://www.webjars.org](http://www.webjars.org)
    to find an exhaustive list of libraries including a search engine and snippets
    generator. There is also more information about the standard and its application
    in the documentation available on this site.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim is to style a page using Bootstrap and WebJar. The steps for completion
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the folder present at [https://bit.ly/2z8QQd6](https://bit.ly/2z8QQd6)[.](https://bit.ly/2z8QQd6)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application with `mvnw spring-boot:run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate the browser to `http://localhost:8080/hello.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the page is unstyled.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate the browser to `http://localhost:8080/webjars/bootstrap/4.0.0-2/css/bootstrap.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser will show an error page, since the resource is missing (**errorCode=404**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to include the Bootstrap WebJar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate the browser to `http://localhost:8080/welcome.html` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The page now has some styling applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate the browser to `http://localhost:8080/webjars/bootstrap/4.0.0-2/css/bootstrap.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of the error page, you should now see some CSS.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that you now have added styling to the web page using Bootstrap
    and WebJar.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2Obb4Il](https://bit.ly/2Obb4Il) to access the code for
    the `WebstarterExerciseApplication.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the Template Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following block diagram shows a typical relationship among the various
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6648d38f-798c-4374-a7c6-2988cadbdfcc.png)'
  prefs: []
  type: TYPE_IMG
- en: In web applications, we expect views to be rendered as HTML pages. As the MVC
    pattern encourages us to separate the model from the view, there has to be an
    entity that transforms our model data into the final representation.
  prefs: []
  type: TYPE_NORMAL
- en: This is where a template engine comes into play. As the name suggests, a template
    engine will take a template containing HTML with placeholders for the data derived
    from the model. It will then render the final HTML that gets sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf Snippet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following block diagram shows a typical relationship among the various
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60e039c9-219b-4787-8484-bb47353d19a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As an example, imagine the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If our model contains an attribute called hello with the content Good Morning!,
    the template engine will render the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As with other frameworks, Spring Boot offers an easy way to add a template engine
    to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Data Along with Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, an element called `model` is used to pass data between the controller
    and the view. Spring Web MVC is automatically passing the model between these
    components and provides many mechanisms to access and bind attributes. In addition,
    a lot of basic tasks such as conversion and validation are done by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The model is bound to the current request and represented by an instance of
    the `org.springframework.ui.Model` class. Any object can be bound to the model.
    It's also possible to bind individual attributes of the model to method parameters
    when using annotated request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how to use the model in *[Chapter 5](ae829ce0-b16f-454e-84c9-37eb73bc9de5.xhtml):
    Displaying Information Using Web Pages*, when we display dynamic information on
    web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Web MVC Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now see what Spring Web MVC includes, allowing us to implement the controllers
    of our application. The framework handles incoming requests and thus allows us
    to concentrate on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The @RequestMapping Annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that the `DispatcherServlet` uses a `HandlerMapping` to determine
    how incoming requests are handled.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Web MVC will install and use a `RequestMappingHandlerMapping`
    that allows us to use annotations to determine which controller and method to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block diagram shows a typical relationship between the various
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43043db1-d375-4532-9f84-05772aa85cca.png)'
  prefs: []
  type: TYPE_IMG
- en: Any component will be inspected for a `@RequestMapping` annotation. If this
    annotation is present, a mapping will be created depending on the path attribute.
    In addition, the method annotation specifies the HTTP method for the mapping.
    To make it more obvious that the given Bean is meant to be a controller, there
    is a special `@Controller` annotation that can be used on the class.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring 4.3, there have been convenience annotations for each HTTP method.
    These annotations are called `@GetMapping`, `@PostMapping`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `@RequestMapping` annotation is present on the class level, it is used
    as a prefix for all methods that are annotated with `@RequestMapping` or any of
    the method-specific annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2MsHOvc](https://bit.ly/2MsHOvc) to access the complete
    code for the `@RequestMapping` annotation example.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Annotations and Parameters for Handler Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are additional annotations that can be applied to a handler method. We
    will take a look at the most important parameters here.
  prefs: []
  type: TYPE_NORMAL
- en: '@RequestParam'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A request that is sent to the application can contain any number of parameters
    in the query. The parameters are delimited from the path by a question mark (`?`).
    These parameters are parsed automatically and can be passed to the handler method
    by using the `@RequestParam` annotation. If required, the value will be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '@RequestHeader'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@RequestHeader` annotation allows you to inject one or more HTTP headers
    into method parameters. This is done by annotating one or more method parameters
    with `@RequestHeader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '@CookieValue'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This annotation allows you to retrieve the content of cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '@PathVariable'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to use parts of a URL path as a parameter that gets passed into
    the handler method. This can be done by using the `@PathVariable` annotation.
    If required, the value will be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '@ModelAttribute'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `@ModelAttribute` annotation on a parameter of a request handler
    method, you can inject an attribute that is bound to the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get into more details on how to work with this model in a future chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '@RequestBody'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you need to access the body of the request. By using `@RequestBody`
    in conjunction with a method parameter, you can inject the request body. The Spring
    Framework will try and convert the body to the given type. If you''re specifying
    a string, you will get access to the raw body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '@ResponseBody'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, a request handler method will return the name of the view to be rendered.
    If you want to return the rendered response body, you can annotate the method
    with `@ResponseBody`. In this case, the value that is returned will be sent as
    a response. In case the type of the returned value is not a string, it will be
    converted before it gets sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Additional Content – Properties to Configure Web MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest strengths of Spring Boot is its automatic configuration using
    predefined values. However, in some cases, you need to alter parts of the configuration.
    For example, the servlet container will listen on port 8080 by default. This will
    allow you to install an HTTP server on the same machine. If you don't need a dedicated
    web server and want your application to be listening on port 80, you can configure
    the web container that is embedded by Spring Boot by setting `server. port=80`
    in your `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some common configuration properties that you can
    change to fit your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a59b9b18-f52a-4564-9ea8-e7a86d9c9ad8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can find an exhaustive list of all available configuration properties in
    the Spring documentation at [https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties).
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learnt about filters in a previous section regarding the Servlet API.
    Filters are organized in a chain and called by the container before the actual
    servlet is called. Finally, they can process the response in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot makes installing a filter very easy. As often is the case in Spring
    Boot, there are multiple ways to achieve this. First, you have to implement a
    Bean implementing the `javax.servlet.filter` interface. Instead of having to add
    a configuration into the `web.xml`, any Spring Bean that implements the filter
    interface will be automatically installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2xeD5b4](https://bit.ly/2xeD5b4) to access the complete
    code for the Filter code example.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Spring Web MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing and configuring a web application is always a comprehensive task. Thankfully,
    Spring Boot again takes care of the heavy lifting. But in many cases, you need
    to modify or, more importantly, extend the configuration. This includes additional
    mappings and security configuration.
  prefs: []
  type: TYPE_NORMAL
- en: All available configuration methods are provided by the `WebMvcConfigurer` interface.
    Usually, the configuration methods are passed a configurer object that can then
    be used to modify a certain aspect.
  prefs: []
  type: TYPE_NORMAL
- en: In prior versions of the Spring Framework, you had to implement a Bean extending
    the abstract `WebConfigurerAdapter` class. The adapter class is responsible for
    providing default implementations, so you could concentrate on the methods you
    wanted to customize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Version 5, this is no longer required. Instead, you can now provide an
    implementation of the `WebMvcConfigurer` interface with only the methods you want
    to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Creating Your First Web MVC Controller'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To set up a Spring Web MVC project, add a static welcome page, and create a
    controller pointing to the view.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You are asked to set up a web application that displays a static welcome page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://start.spring.io](https://start.spring.io) and enter the required
    dependencies on the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Group: `com.packt.springboot`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Artifact: `blogmania`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9271ee-e3d2-4cd6-ac90-abade8eea5ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Download a ZIP file containing the initial project files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded file to the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the dependency for the Bootstrap Webjars archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `welcome.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a controller to render the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now start the application by using the Maven command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your browser to navigate to `http://localhost:8080` to view the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting Spring Web MVC project and posts are visible on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e30ccd-450b-4d42-9978-5ec0c873fab8.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2QpmQR9](https://bit.ly/2QpmQR9) to access the code for
    the `BlogManiaApplicationTests.java` file. To refer to the detailed steps, go
    to the *Solutions* section at the end of this book on page 252.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learnt about the Model-View-Controller (MVC) pattern.
    It separates the main concerns of a web application into a model, a view, and
    a controller.
  prefs: []
  type: TYPE_NORMAL
- en: We then distinguished between a request- and a component-based MVC, which differs
    in how the framework handles incoming requests by either taking care of conversion,
    validation, and so on, or leaving the developer to handle these aspects, resulting
    in different code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented our first Spring Web MVC application, to handle incoming
    requests and display a simple page output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply the MVC pattern to Spring Boot.
  prefs: []
  type: TYPE_NORMAL
