- en: Chapter 3. Building a Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen the ease of using Gradle for building a command-line Java
    application, we shouldn't be surprised to know that building web applications
    based on Java servlet specification is also equally easy with Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a simple web application first, which is distributed
    as a `WAR` file that can be deployed to any servlet container. Then, we will take
    a look at how dependencies and repositories are configured in a build file.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Java web project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we will keep our application as minimal as possible and create a web-enabled
    version of the application, which we developed in the last chapter. The application
    will provide the user a form to input their name and a **Submit** button. When
    the user clicks on the **Submit** button, the greeting will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The application will be based on Servlet 3.1 specification. We will reuse the
    `GreetService` that we developed in the previous chapter. The form will be served
    by a static HTML file, which can post data to our servlet. The servlet will create
    a greeting message and forward it to a JSP for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on Servlet specification 3.1, go to [https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating source files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the root of the project as `hello-web`. The structure is similar
    to what we had seen for a simple Java application, with one addition, which is
    the web app root. The Web app root, by default, is located at `src/main/webapp`.
    Those who are familiar with Maven will immediately notice that it's the same path
    used by Maven as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Web app root (`webapp`) contains all the public resources required to run
    a web application, which includes dynamic pages such as JSPs or the files required
    for other view template engines such as Thymeleaf, FreeMarker, Velocity, and so
    on; as well as static resources such as HTML, CSS, JavaScript, and image files;
    and other configuration files such as `web.xml` in the special directory called
    `WEB-INF`. The files stored in `WEB-INF` are not directly accessible to the client;
    hence, it is a perfect place to store protected files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with creating the directory structure for what the final application
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first add the familiar `GreetingService` from the last chapter to our
    sources. We might notice that copying the Java source file is not a right way
    to reuse. There are much better ways to organize such dependencies. One such way
    is with multimodule projects. We will see this in [Chapter 5](part0035_split_000.html#11C3M1-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 5. Multiprojects Build"), *Multiprojects Build*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following content to the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file starts with an HTML 5 `doctype` declaration, which is the most simple
    `doctype` we can use. Then, we create a form that will post to `greet` endpoint
    (it is a relative path to the page).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, at the heart of this application, there is the `GreetServlet` that responds
    to the post request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code , the `WebServlet` annotation's value maps this servlet
    to the `/greet` path relative to the context of the application. Then, an instance
    of `GreetService` is made available in this servlet. The overridden method `doPost`
    extracts the name from the `request` object, generates the greeting message, sets
    this message back in the `request` as an attribute so that it's accessible in
    the JSP, and then finally forwards the request to the `greet.jsp` file that is
    located at `/WEB-INF/greet.jsp`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This brings us to the `greet.jsp` file, which is kept in `WEB-INF` so that
    it''s not directly accessible and the request has to always come through the servlet
    that sets the right request attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This JSP just prints the `message` that is available in the request attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a build file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s create the file we''ve been waiting for—the `build.gradle`
    file —in the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to understand this file now:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line applies the `war` plugin to the project. This plugin adds a `war`
    task to the project. One might wonder why we don't need to apply the `java` plugin
    to compile the classes. This is because the `war` plugin extends the `java` plugin;
    so all the tasks that were available when we applied the `java` plugin are still
    available to us in addition to the `war` task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, comes the `repositories` section that configures our build to look for
    all the dependencies in the Maven central repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, in the `dependencies` block, we add `servlet-api` to the `providedCompile`
    configuration (scope). This tells Gradle not to package the servlet API with the
    application, as it will already be available on the container where the application
    will be deployed. The `providedCompile` configuration is added by the `war` plugin
    (it also adds `providedRuntime`). If we had any other dependency that needs to
    be packaged with our application, it would have been declared using the compile
    configuration. For example, if our app depends on the Spring Framework, then the
    dependencies section might have looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if it feels like the details on `repositories`, `configurations`
    and `dependencies` are a bit sketchy. We will soon see them again, in more detail,
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the artifact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our source files are ready with the build file, we must build the
    deployable WAR file. Let''s verify the tasks available for our build using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will notice the `war` task there, which depends on `classes` (task). We
    don''t need to explicitly compile and build the Java sources, which is automatically
    taken care of by the `classes` task. So all that we need to do now is, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is complete, we will see the directory''s structure similar
    to following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The war file is created at `/build/libs/hello-web.war`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `war` file is nothing but a ZIP file with a different file extension. The
    same holds true for an `.ear` or `.jar` file for that matter. We can use the standard
    zip/unzip tools too or use the JDK's `jar` utility to perform various operations
    on these files. To list the contents of WAR, use `jar -tf build/libs/hello-web.war`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the content of this WAR file once:'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. The compiled classes landed into the `WEB-INF/classes` directory. The
    servlet API's JAR is not included as it was in the `providedCompile` scope.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise**'
  prefs: []
  type: TYPE_NORMAL
- en: Add `compile 'org.springframework:spring-context:4.0.6.RELEASE'` in the `dependencies`
    section and then do a `gradle war` file and see the content of the created WAR.
  prefs: []
  type: TYPE_NORMAL
- en: Running the web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have come a long way in creating the web-app. However, to use it, it must
    be deployed to a servlet container. It can be classically deployed to a servlet
    container by copying the `.war` file in the servlet container's designated directory
    (such as `webapps` in the case of Tomcat). Alternatively, a more recent technique
    can be used to embed a Servlet container into a Java app, which is packaged as
    a `.jar` and is run as any other `java –jar` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web apps are typically run in three modes, development, functional testing,
    and production. The key characteristics of all the three modes differ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The key characteristics of running web in development mode is faster deployment
    (preferably hot reloads), quick server start and shutdown, very low server footprint,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in functional testing, we typically deploy `web-app` once for the entire
    test suite's run. We need to mimic production-like behavior of an app as much
    as possible. We need to set up and destroy the web-app's state (such as databases),
    using lightweight databases (preferably in-memory) for all tests. We also need
    to mock external services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas, in production deployments, the app-servers' (whether standalone or
    embedded) configuration, security, optimization of app, caches, and so on, takes
    more precedence, features such as hot reloading deployments are rarely used; faster
    startup time takes lesser precedence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only cover the development scenario in this chapter. We will start with
    the traditional way to highlight its problems and then move on to Gradle's way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we need to deploy the war in a manual way. We can choose any Java servlet
    container such as Jetty or Tomcat to run our web-app. In this example, let''s
    use Tomcat. Assuming Tomcat is installed at`~/tomcat` or `C:\tomcat` (based on
    the OS that we are using):'
  prefs: []
  type: TYPE_NORMAL
- en: If the server is running, ideally we should stop it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the WAR file to the Tomcat's `webapp` (`~/tomcat/webapps`) directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, start the Tomcat server using `~/tomcat/bin/startup.sh` or `C:\tomcat\bin\startup.bat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, this kind of deployment feels outdated in Gradle's age. Especially,
    while developing the web-app, we have to constantly package the application as
    a `war`, copy the latest version to the container, and restart the container to
    get the latest code running. When we say build automation, it implicitly means
    that no manual intervention should be expected and things should work in one click
    (or one command in Gradle's case). Also, luckily, there are many options to achieve
    this level of automation.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins to the rescue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Out of the box, Gradle has no support for modern servlet containers. However,
    this is the beauty of Gradle's architecture. Innovation and/or implementation
    does not have to come from a selected few who are creating Gradle. With the help
    of plugins API, anyone can create functionally rich plugins. We are going to use
    a plugin called Gretty for our web-app's development time deployment, but you
    should also check out others to see what works the best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a `jetty` plugin available, which is shipped with Gradle. However,
    it has not been actively updated; hence, it officially supports only Jetty 6.x
    (as of this writing). So we can use it if our web application is based on Servlet
    2.5 specification or lower.
  prefs: []
  type: TYPE_NORMAL
- en: A Gretty plugin can be found at a Gradle plugin portal (look at the references
    below). This plugin adds numerous tasks to the build and supports various versions
    of Tomcat and Jetty. Installing it cannot be any easier. The code for this uses
    the same `hello-web` source from the last section, but updates the `build.gradle`
    file. An entire source code for this example can be found in the `chapter-03/hello-gretty`
    directory of the book's sample code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just include the following at the first line of `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it—we are done. This is relatively a new syntax for applying plugins
    to builds, which was added in Gradle 2.1\. This is especially useful for applying
    third-party plugins. Unlike calling the `apply` method to apply the plugin, we
    start with the plugin block on the first line. Then, we specify the plugin''s
    ID. For applying an external plugin, we must use the fully qualified plugin ID
    and version. We can include the `war` plugin''s application inside this block.
    For internal plugins, we don''t need to specify a version. It will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we run `gradle tasks` now, we must have an `appRun` task under the `Gretty`
    group. There are many more tasks in this group, which are added by the Gretty
    plugin. If we run the `appRun` task, without configuring the plugin explicitly,
    then by default a Jetty 9 will be run on `http://localhot:8080`. We can open the
    browser and verify.
  prefs: []
  type: TYPE_NORMAL
- en: There are many configurations exposed by the plugin, in order to control aspects
    such as server version, port number, and many more. Add a `gretty` block to the
    `build.gradle` files as follows`:`
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use Tomcat 8 on port 8080, we''ll add the following lines of
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to use Jetty 9 on 9080, we''ll add the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are many more configuration options available in Gretty; we would recommend
    you to check Gretty's online documentation. See the link to Gretty in the references
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the running application looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plugins to the rescue](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the **Submit** button is pressed, we''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plugins to the rescue](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Gradle, refer to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle plugin portal: [https://plugins.gradle.org/](https://plugins.gradle.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Gretty, refer to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gretty plugin: [https://plugins.gradle.org/plugin/org.akhikhl.gretty](https://plugins.gradle.org/plugin/org.akhikhl.gretty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gretty documentation: [http://akhikhl.github.io/gretty-doc/](http://akhikhl.github.io/gretty-doc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are various plugins available to automate the deployment. Some of them
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo plugin: [https://github.com/bmuschko/gradle-cargo-plugin](https://github.com/bmuschko/gradle-cargo-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arquillian plugin: [https://github.com/arquillian/arquillian-gradle-plugin](https://github.com/arquillian/arquillian-gradle-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tomcat plugin: [https://github.com/bmuschko/gradle-tomcat-plugin](https://github.com/bmuschko/gradle-tomcat-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real life, we work on a lot more complex applications than what we have just
    seen. Such applications rely on other specialized components to provide some functionality.
    For example, an Enterprise Java application's build may depend on various components
    such as open source libraries in Maven central, libraries developed and hosted
    in-house, and (maybe) even on another subprojects. Such dependencies are, themselves,
    located at various locations like, local intranet, local filesystem, and so on.
    They need to be resolved, downloaded, and brought into the appropriate configuration
    (such as `compile`, `testCompile`, and so on) of the build.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle does an excellent job in locating and making dependencies available in
    the appropriate `classpath` and packaging if required. Let's begin with the most
    common kind of dependencies—external libraries.
  prefs: []
  type: TYPE_NORMAL
- en: External libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost all real-world projects depend on external libraries for reusing the
    proven and tested components. Such dependencies include language utilities, database
    drivers, web frameworks, XML/JSON serialization libraries, ORMs, logging utilities,
    and many more.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies of a project are declared in the `dependencies` section in
    the build file.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle provides an extremely succinct syntax for declaring the coordinates of
    an artifact. It usually takes a form of `group:name:version`. Note that each value
    is separated by a colon (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Spring Framework''s core library can be referenced using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those who don't enjoy terseness, dependencies can be referred in a more
    descriptive format (called map format).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify multiple dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Where `configurationName` represents the configuration such as `compile`, `testCompile`
    and so on, we are soon going to see what configuration is in this context.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The version of our dependencies keep on updating every now and then. Also, when
    we are in the development phase, we don't want keep on checking manually whether
    a new version is available.
  prefs: []
  type: TYPE_NORMAL
- en: In such situations, we can add a `+` to denote the version mentioned above,
    given the number of artifacts. For example, `org.slf4j:slf4j-nop:1.7+` declares
    any version of SLF4J that is above 1.7\. Let's include this in a `build.gradle`
    file and check what Gradle brings in for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the following code in our `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we run the `dependencies` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We see that Gradle chose the 1.7.7 version, as it's the latest version available
    as of the writing of this book. If you observe the second line, it tells us that
    `slf4j-nop` depends on `slf4j-api`; hence, it's a transitive dependency for our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution here is, always use `+` for only minor version upgrades (such
    as `1.7+` in the preceding example). Letting the major version automatically update
    (for example, just image is spring automatically updates from 3 to 4, `compile
    'org.springframework:spring-core:+'`) is nothing but a gamble. A dynamic dependency
    resolution is a nice feature, but it should be used with care. It should ideally
    only be used at the development stage of the project and not for releases candidates.
  prefs: []
  type: TYPE_NORMAL
- en: We get a flaky build whenever the dependency's version updates to some incompatible
    version with our app. We should target for reproducible builds, such a build should
    produce the exact same artifact, be it today or one year down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Gradle resolves transitive dependencies quite intelligently, giving
    preference to the latest conflicting versions, if any. However, for some reason,
    if we want to disable transitive dependencies, all we need to provide is an extra
    block to our dependency declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we check the output of the `dependencies` task, we see that no other
    dependency is included anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also force a given version of the library so that, even if the same
    artifacts, the later version comes through the transitive dependency; the version
    we forced will win:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running dependencies task now will produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This shows the older version of `slf4j-api` won, even though a later version
    could have been fetched by the transitive dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle provides a very elegant way to declare dependencies that are required
    for building different groups of sources in various stages of a project build.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These groups of sources are known as **source sets**. The simplest and well-understood
    examples of source sets are `main` and `test`. The `main` source set contains
    files that will be compiled and built as a JAR file and will be deployed somewhere
    or published to some repository. The `test` source set, on the other hand, contains
    files that will be executed by a testing tool such as JUnit, but will not make
    it to production. Now, both the source sets have different requirements for the
    dependencies, building, packaging, and execution. We will see how to add new source
    sets in [Chapter 7](part0045_split_000.html#1AT9A1-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 7. Testing and Reporting with Gradle"), *Testing and Reporting with Gradle*,
    for integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have defined the group of related sources in a source set, dependencies
    are also defined as a group called **configuration**. Each configuration has its
    name such as `compile`, `testCompile`, and so on. Dependencies included in various
    configurations also differ. Configurations are grouped by the characteristics
    of dependencies. For example, the following are configurations that are added
    by the `java` and `war` plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`: This is added by the `java` plugin. Adding a dependency to this
    configuration implies that the dependency is required to compile the source. In
    the case of `war`, these will also get copied in `WEB-INF/lib`. Examples of such
    dependencies are libraries such as Spring Framework, Hibernate, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: This is added by the `java` plugin. This includes the `compile`
    dependencies by default. Dependencies in this group are required at runtime for
    the compiled source code, but they are not required to compile it. Dependencies
    such as JDBC drivers are runtime dependencies only. We do not need them on our
    classpath to compile the source code as we code against the standard JDBC API
    interfaces available in JDK. However, for our application to run properly, we
    need a specific driver implementation at run time. For example, `runtime ''mysql:mysql-connector-java:5.1.37''`
    includes the MySQL driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testCompile`: This is added by the `java` plugin. This includes the `compile`
    dependencies by default. Dependencies added to this configuration are only available
    to test sources. Examples are testing libraries such as JUnit, TestNG, and so
    on, or any libraries that are exclusively used by test source such as Mockito.
    They are neither required to compile, nor required at runtime for the main source
    set. They do not get included in `war` in the case of building a `web-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testRuntime`: This is added by the `java` plugin. This includes `testCompile`
    and `runtime` dependencies by default. Dependencies in this configuration are
    only required to test sources at the runtime (that is, while running tests). Hence,
    they are not included in the compilation classpath of tests. This is just like
    the runtime configuration, but only for test sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providedCompile`: This is added by the `war` plugin. Dependencies such as
    servlet APIs are provided by application servers and hence need not be packaged
    in our `war`. Anything that we expect to be already included in the server runtime
    can be added to this configuration. However, it has to be present at the time
    of compilation of the source code. Hence, we can declare such dependencies as
    `providedCompile`. Examples are servlet API and any Java EE implementations that
    are available at server runtime. Such dependencies are not included in `war`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providedRuntime`: This is added by the `war` plugin. Dependencies that will
    be made available at application runtime by the server and application do not
    need to be included while compiling because there is no direct reference to the
    implementation. Such libraries can be added to this configuration. Such dependencies
    will not be included in `war`. Hence, we should make sure to have implementation
    available in the application runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we know, when we apply the `war` plugin, the `java` plugin also gets applied.
    That's why all six configurations are available when we are building a web application.
    More configurations can be added by plugins, or we can declare them ourselves
    in our build script.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, configuration does not just include dependencies, but also the
    artifacts produced by this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The repositories section configures the repositories where Gradle will look
    for dependencies. Gradle downloads the dependencies into its own cache so that
    the download doesn''t need to happen every time Gradle is run. We can configure
    multiple repositories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Repositories such as Maven, Ivy, and flat directory (filesystem) are supported
    for dependency resolution and uploading artifacts. There are some more specific
    convenience methods available for commonly used Maven repositories such as `mavenCentral()`,
    `jcenter()`, and `mavenLocal()`. However, more Maven repos can be easily configured
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before the central repositories, projects used to manage the libraries on filesystem,
    which were mostly checked in along with the source code. Some projects still do
    it; although we discourage this, people have their reasons to do so and Gradle
    has no reason to not support that.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that Gradle does not automatically assume any repository
    to search and download dependencies from. We have to explicitly configure at least
    one repository in the `repositories` block where Gradle will search for artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include Apache Commons Lang library to convert the message to title case using
    the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Capitalize all the whitespace-separated words in a string.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first developed a web application using Gradle. We generated
    the WAR artifact by building the application and then deployed it to a local Tomcat.
    Then, we learned a few basics about dependency management, configurations, and
    supported repositories in Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reader should spend some more time reading these concepts in detail at Gradle's
    official documentation at [https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide)
    .
  prefs: []
  type: TYPE_NORMAL
- en: For now, we should be good to build the most common type of Java applications
    with Gradle. In the next chapter, we will try to understand the Groovy DSL that
    Gradle provides and also understand the basic project model.
  prefs: []
  type: TYPE_NORMAL
