- en: Customizing Concurrency Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义并发类
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Customizing the ThreadPoolExecutor class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义ThreadPoolExecutor类
- en: Implementing a priority-based Executor class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于优先级的Executor类
- en: Implementing the ThreadFactory interface to generate custom threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ThreadFactory接口以生成自定义线程
- en: Using our ThreadFactory in an Executor object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Executor对象中使用我们的ThreadFactory
- en: Customizing tasks running in a scheduled thread pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义在计划线程池中运行的任务
- en: Implementing the ThreadFactory interface to generate custom threads for the
    fork/join framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ThreadFactory接口以生成fork/join框架的自定义线程
- en: Customizing tasks running in the fork/join framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义在fork/join框架中运行的任务
- en: Implementing a custom Lock class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义锁类
- en: Implementing a transfer queue-based on priorities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于优先级的传输队列
- en: Implementing your own atomic object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现您自己的原子对象
- en: Implementing your own stream generator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现您自己的流生成器
- en: Implementing your own asynchronous stream
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现您自己的异步流
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Java Concurrency API provides a lot of interfaces and classes to implement
    concurrent applications. They provide low-level mechanisms, such as the `Thread`
    class, the `Runnable` or `Callable` interfaces, or the `synchronized` keyword.
    They also provide high-level mechanisms, such as the `Executor` framework and
    the fork/join framework added in the Java 7 release, or the `Stream` framework
    added in Java 8, to process big sets of data. Despite this, you may find yourself
    developing a program where the default configuration and/or implementation of
    the Java API doesn't meet your needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了许多接口和类来实现并发应用程序。它们提供了低级机制，例如`Thread`类、`Runnable`或`Callable`接口，或者`synchronized`关键字。它们还提供了高级机制，例如`Executor`框架和Java
    7版本中添加的fork/join框架，或者Java 8中添加的`Stream`框架，以处理大量数据集。尽管如此，您可能会发现自己正在开发一个程序，其中Java
    API的默认配置和/或实现不符合您的需求。
- en: 'In this case, you may need to implement your own custom concurrent utilities,
    based on the ones provided by Java. Basically, you can:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能需要根据Java提供的实现实现您自己的自定义并发工具。基本上，您可以：
- en: Implement an interface to provide the functionality defined by that interface,
    for example, the `ThreadFactory` interface.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个接口以提供该接口定义的功能，例如`ThreadFactory`接口。
- en: Override some methods of a class to adapt its behavior to your needs. For example,
    overriding the `onAdvance()` method of the `Phaser` class that, by default, does
    nothing useful and is supposed to be overridden to offer some functionality.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖一个类的一些方法以适应您的需求。例如，覆盖`Phaser`类的`onAdvance()`方法，默认情况下该方法不执行任何有用的操作，并应被覆盖以提供一些功能。
- en: Through the recipes of this chapter, you will learn how to change the behavior
    of some Java concurrency API classes without the need to design a concurrency
    framework from scratch. You can use these recipes as an initial point to implement
    your own customizations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的食谱，您将学习如何在不从头设计并发框架的情况下更改一些Java并发API类的行为。您可以将这些食谱作为实现您自己的自定义的起点。
- en: Customizing the ThreadPoolExecutor class
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义ThreadPoolExecutor类
- en: 'The `Executor` framework is a mechanism that allows you to separate thread
    creation from its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces with the `ThreadPoolExecutor` class that implements both the interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks and execute them in the pooled threads. These tasks are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`框架是一种机制，允许您将线程创建与其执行分离。它基于`Executor`和`ExecutorService`接口，`ThreadPoolExecutor`类实现了这两个接口。它有一个内部线程池，并提供方法允许您发送两种类型的任务并在池线程中执行它们。这些任务是：'
- en: The `Runnable` interface to implement tasks that don't return a result
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Runnable`接口的任务不返回结果
- en: The `Callable` interface to implement tasks that return a result
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现返回结果的`Callable`接口的任务
- en: In both cases, you only send the task to the executor. The executor uses one
    of its pooled threads or creates a new one to execute those tasks. It also decides
    the moment in which the task is executed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您只需将任务发送给执行器。执行器使用其池中的线程之一或创建一个新的线程来执行这些任务。它还决定任务执行的时刻。
- en: In this recipe, you will learn how to override some methods of the `ThreadPoolExecutor`
    class to calculate the execution time of the tasks that you will execute in the
    executor and write about the executor in console statistics when it completes
    its execution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何重写 `ThreadPoolExecutor` 类的一些方法来计算你将在执行器中执行的任务的执行时间，并在执行器完成执行时在控制台统计信息中写入关于执行器的内容：
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java 项目：
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyExecutor` that extends the `ThreadPoolExecutor` class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyExecutor` 的类，该类扩展了 `ThreadPoolExecutor` 类：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a private `ConcurrentHashMap` attribute parameterized by the `String`
    and `Date` classes, named `startTimes`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `startTimes` 的私有 `ConcurrentHashMap` 属性，该属性由 `String` 和 `Date` 类参数化：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the constructor for the class. Call a constructor of the parent class
    using the `super` keyword and initialize the `startTime` attribute:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。使用 `super` 关键字调用父类的构造函数并初始化 `startTime` 属性：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Override the `shutdown()` method. Write in the console information about the
    executed, running, and pending tasks. Then, call the `shutdown()` method of the
    parent class using the `super` keyword:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `shutdown()` 方法。在控制台输出已执行、正在运行和挂起的任务信息。然后，使用 `super` 关键字调用父类的 `shutdown()`
    方法：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Override the `shutdownNow()` method. Write in the console information about
    the executed, running, and pending tasks. Then, call the `shutdownNow()` method
    of the parent class using the `super` keyword:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `shutdownNow()` 方法。在控制台输出已执行、正在运行和挂起的任务信息。然后，使用 `super` 关键字调用父类的 `shutdownNow()`
    方法：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Override the `beforeExecute()` method. Write a message in the console with
    the name of the thread that is going to execute the task and the hash code of
    the task. Store the start date in `HashMap` using the hash code of the task as
    the key:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `beforeExecute()` 方法。在控制台输出将要执行任务的线程名称和任务的哈希码。使用任务的哈希码作为键在 `HashMap` 中存储开始日期：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `afterExecute()` method. Write a message in the console with the
    result of the task and calculate the running time of the task after subtracting
    the start date of the task stored in `HashMap` of the current date:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `afterExecute()` 方法。在控制台输出任务的结果，并计算任务运行时间，通过从存储在 `HashMap` 中的当前日期的任务开始日期中减去：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a class named `SleepTwoSecondsTask` that implements the `Callable` interface
    parameterized by the `String` class. Implement the `call()` method. Put the current
    thread to sleep for 2 seconds and return the current date converted into a `String`
    type:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SleepTwoSecondsTask` 的类，该类实现了由 `String` 类参数化的 `Callable` 接口。实现 `call()`
    方法。使当前线程休眠2秒，并返回当前日期转换为 `String` 类型：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并实现一个 `main()` 方法来实现示例的主类：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `MyExecutor` object named `myExecutor`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `myExecutor` 的 `MyExecutor` 对象：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a list of `Future` objects parameterized by the `String` class to store
    the resultant objects of the tasks you''re going to send to the executor:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由 `String` 类参数化的 `Future` 对象列表，用于存储您将要发送给执行器的任务的输出结果：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Submit 10 `Task` objects:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交10个 `Task` 对象：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get the result of the execution of the first five tasks using the `get()` method.
    Write them in the console:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `get()` 方法获取前五个任务的执行结果。在控制台写入它们：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finish the execution of the executor using the `shutdown()` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法完成执行器的执行：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the result of the execution of the last five tasks using the `get()` method.
    Write them in the console:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `get()` 方法获取最后五个任务的执行结果。在控制台写入它们：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wait for the completion of the executor using the `awaitTermination()` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `awaitTermination()` 方法等待执行器的完成：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a message indicating the end of the execution of the program:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出一条消息，表明程序执行的结束：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we implemented our custom executor by extending the `ThreadPoolExecutor`
    class and overriding four of its methods. The `beforeExecute()` and `afterExecute()`
    methods were used to calculate the execution time of a task. The `beforeExecute()`
    method is executed before the execution of a task; in this case, we used `HashMap`
    to store the start date of the task in it. The `afterExecute()` method is executed
    after the execution of the task. You got `startTime` of the task that had finished
    from `HashMap` and then calculate the difference between the actual date and and
    the `startTime` to get the execution time of the task. You also overrode the `shutdown()`
    and `shutdownNow()` methods to write statistics about the tasks executed in the
    executor to the console. These tasks included:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过扩展`ThreadPoolExecutor`类并重写其四个方法来实现自定义执行器。`beforeExecute()`和`afterExecute()`方法用于计算任务的执行时间。`beforeExecute()`方法在任务执行之前执行；在这种情况下，我们使用`HashMap`来存储任务的开始日期。`afterExecute()`方法在任务执行之后执行。你可以从`HashMap`中获取已完成的任务的`startTime`，然后计算实际日期和`startTime`之间的差异以获取任务的执行时间。你还重写了`shutdown()`和`shutdownNow()`方法，将执行器中执行的任务的统计信息写入控制台。这些任务包括：
- en: The executed tasks, using the `getCompletedTaskCount()` method
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getCompletedTaskCount()`方法获取已执行的任务
- en: The tasks that were running at the current time, using the `getActiveCount()`
    method
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getActiveCount()`方法获取当前正在运行的任务
- en: The pending tasks, using the `size()` method of the blocking queue where the
    executor stores the pending tasks
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器存储待处理任务的阻塞队列的`size()`方法获取待处理任务
- en: The `SleepTwoSecondsTask` class that implements the `Callable` interface puts
    its execution thread to sleep for 2 seconds and the `Main` class, where you send
    10 tasks to your executor, uses it and the other classes to demo their features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Callable`接口的`SleepTwoSecondsTask`类将其执行线程休眠2秒，而`Main`类，你向其中发送10个任务到你的执行器，使用它和其他类来演示其功能。
- en: Execute the program and you will see how the program shows the time span of
    each task that is running and the statistics of the executor upon calling the
    `shutdown()` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，你将看到程序如何显示每个正在运行的任务的时间跨度以及调用`shutdown()`方法时的执行器统计信息。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736)的*创建线程执行器并控制其拒绝的任务*示例中，*线程执行器*
- en: The *Using our ThreadFactory in an Executor object* recipe in this chapter
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*在Executor对象中使用我们的ThreadFactory*示例
- en: Implementing a priority-based Executor class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于优先级的执行器类
- en: In the first version of the Java Concurrency API, you had to create and run
    all the threads of your application. In Java version 5, with the appearance of
    the Executor framework, a new mechanism was introduced for the execution of concurrency
    tasks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java并发API的第一个版本中，你必须创建和运行你应用程序的所有线程。在Java 5版本中，随着Executor框架的出现，引入了一种新的并发任务执行机制。
- en: With the Executor framework, you only have to implement your tasks and send
    them to the executor. The executor is responsible for the creation and execution
    of the threads that execute your tasks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Executor框架，你只需要实现你的任务并将它们发送到执行器。执行器负责创建和执行执行你的任务的线程。
- en: Internally, an executor uses a blocking queue to store pending tasks. These
    are stored in the order of their arrival at the executor. One possible alternative
    is to use a priority queue to store new tasks. This way, if a new task with high
    priority arrives to the executor, it will be executed before all the other threads
    that have already been waiting but have comparatively lower priority.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，执行器使用阻塞队列来存储待处理任务。这些任务按照到达执行器的顺序存储。一个可能的替代方案是使用优先队列来存储新任务。这样，如果一个具有高优先级的任务到达执行器，它将在所有其他已经等待但优先级相对较低的其他线程之前执行。
- en: In this recipe, you will learn how to adapt an executor that will use a priority
    queue to store the tasks you send for execution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何调整一个执行器，该执行器将使用优先队列来存储你发送给执行器执行的任务。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码是在Eclipse IDE中实现的。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤实现示例：
- en: 'Create a class named `MyPriorityTask` that implements the `Runnable` and `Comparable`
    interfaces parameterized by the `MyPriorityTask` class interface:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyPriorityTask`的类，该类实现了`Runnable`和`Comparable`接口，并使用`MyPriorityTask`类接口进行参数化：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare a private `int` attribute named `priority`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`priority`的私有`int`属性：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare a private String attribute called name:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement a method to return the value of the priority attribute:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来返回优先级属性值：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement the `compareTo()` method declared in the `Comparable` interface.
    It receives a `MyPriorityTask` object as a parameter and compares the priorities
    of the two objects: the current one and the parameter. You let tasks with higher
    priority be executed before tasks with lower priority:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现声明在`Comparable`接口中的`compareTo()`方法。它接收一个`MyPriorityTask`对象作为参数，并比较两个对象的优先级：当前对象和参数对象。你让优先级更高的任务先于优先级低的任务执行：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `run()` method. Put the current thread to sleep for 2 seconds:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。将当前线程休眠2秒：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a `ThreadPoolExecutor` object named `executor`. Use `PriorityBlockingQueue`,
    parameterized by the `Runnable` interface, as the queue that this executor will
    use to store its pending tasks:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`executor`的`ThreadPoolExecutor`对象。使用参数化由`Runnable`接口的`PriorityBlockingQueue`作为此执行器将用于存储其挂起任务的队列：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Send 10 tasks to the executor using the counter of the loop as the priority
    of the tasks. Use the `execute()` method to send the tasks to the executor:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环计数器作为任务优先级的依据，向执行器发送10个任务。使用`execute()`方法将任务发送到执行器：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Put the current thread to sleep for 1 second:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前线程休眠1秒：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Send 10 additional tasks to the executor using the counter of the loop as the
    priority of the tasks. Use the `execute()` method to send the tasks to the executor:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环计数器作为任务优先级的依据，向执行器发送10个额外的任务。使用`execute()`方法将任务发送到执行器：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Shut down the executor using the `shutdown()` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的最终化：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Write a message in the console indicating the finalization of the program:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入一条消息，指示程序的最终化：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Converting a regular executor into a priority-based executor is simple. You
    only have to pass a `PriorityBlockingQueue` object, parameterized by the `Runnable`
    interface, as a parameter. But with the executor, you should know that all the
    objects stored in a priority queue have to implement the `Comparable` interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将普通执行器转换为基于优先级的执行器很简单。你只需要传递一个参数化由`Runnable`接口的`PriorityBlockingQueue`对象作为参数。但与执行器一起，你应该知道存储在优先队列中的所有对象都必须实现`Comparable`接口。
- en: You implemented the `MyPriorityTask` class that implements the `Runnable` interface,
    which will act as a task, and the `Comparable` interface to be stored in the priority
    queue. This class has a `Priority` attribute that is used to store the priority
    of the tasks. If a task has a higher value for this attribute, it will be executed
    earlier. The `compareTo()` method determines the order of the tasks in the priority
    queue. In the `Main` class, you sent 20 tasks to the executor with different priorities.
    The first tasks you sent to the executor were the first tasks to be executed.
    As the executor was idle waiting for the tasks, it executed the first tasks immediately,
    as soon as they arrived. You created the executor with four execution threads,
    so the first four tasks will be the first ones that are executed. Then, the rest
    of the tasks will be executed based on their priority.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了实现了`Runnable`接口的`MyPriorityTask`类，该类将作为任务执行，并实现了`Comparable`接口以便存储在优先队列中。这个类有一个`Priority`属性，用于存储任务的优先级。如果一个任务的这个属性值更高，它将更早被执行。`compareTo()`方法决定了任务在优先队列中的顺序。在`Main`类中，你向执行器发送了20个不同优先级的任务。你首先发送给执行器的任务将是首先被执行的任务。由于执行器空闲等待任务，所以一旦任务到达，它就会立即执行。你创建了具有四个执行线程的执行器，所以前四个任务将是首先被执行的。然后，其余的任务将根据它们的优先级执行。
- en: 'The following screenshot shows one execution of this example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的一次执行：
- en: '![](img/00050.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can configure `Executor` to use any implementation of the `BlockingQueue`
    interface. One interesting implementation is `DelayQueue`. This class is used
    to store elements with delayed activation. It provides methods that only return
    active objects. You can use this class to implement your own version of the `ScheduledThreadPoolExecutor`
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置`Executor`以使用任何实现`BlockingQueue`接口的实现。一个有趣的实现是`DelayQueue`。此类用于存储具有延迟激活的元素。它提供仅返回活动对象的方法。您可以使用此类来实现自己的`ScheduledThreadPoolExecutor`类版本。
- en: See also
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736)，“线程执行器”中的*创建线程执行器并控制其拒绝的任务*食谱
- en: The *Customizing the ThreadPoolExecutor class* recipe in this chapter
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*自定义ThreadPoolExecutor类*食谱
- en: The *Using blocking thread-safe queue ordered by priority* recipe in [Chapter
    7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736), *Concurrent Collections*
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736)，“并发集合”中的*使用按优先级排序的阻塞线程安全队列*食谱
- en: Implementing the ThreadFactory interface to generate custom threads
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ThreadFactory接口以生成自定义线程
- en: Factory pattern is a widely used design pattern in the object-oriented programming
    world. It is a creational pattern and its objective is to develop a class whose
    mission is to create objects of one or several classes. Then, when we want to
    create an object of one of those classes, we use the factory instead of using
    the new operator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是面向对象编程世界中广泛使用的设计模式。它是一种创建型模式，其目标是开发一个具有创建一个或多个类对象使命的类。然后，当我们想要创建这些类中的一个对象时，我们使用工厂而不是使用new运算符。
- en: With this factory, we centralize the creation of objects, thereby gaining the
    advantage of easily changing the class of objects created or the way we create
    these objects, considering the limitations we have in creating objects with limited
    resources. For example, we can only have *N* objects of a type that has the ability
    to easily generate statistical data about the creation of objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工厂，我们将对象的创建集中化，从而获得易于更改创建对象类别或创建这些对象的方式的优势，考虑到我们在使用有限资源创建对象时的限制。例如，我们只能拥有具有易于生成对象创建统计数据的能力的*N*个此类对象。
- en: Java provides the `ThreadFactory` interface to implement a `Thread` object factory.
    Some advanced utilities of the Java concurrency API, such as the `Executor` framework
    or the fork/join framework, use thread factories to create threads. Another example
    of the factory pattern in the Java Concurrency API is the `Executors` class. It
    provides a lot of methods to create different kinds of `Executor` objects. In
    this recipe, you will extend the `Thread` class by adding new functionalities,
    and you will implement a thread factory class to generate threads of this new
    class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`ThreadFactory`接口来实现`Thread`对象工厂。Java并发API的一些高级实用工具，如`Executor`框架或fork/join框架，使用线程工厂来创建线程。Java并发API中工厂模式的另一个例子是`Executors`类。它提供了许多创建不同类型的`Executor`对象的方法。在本食谱中，您将通过添加新功能来扩展`Thread`类，并将实现一个线程工厂类来生成此类线程。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyThread` that extends the `Thread` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyThread`的类，该类扩展了`Thread`类：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare three private `Date` attributes named `creationDate`, `startDate`,
    and `finishDate`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个名为`creationDate`、`startDate`和`finishDate`的私有`Date`属性：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement a constructor of the class. It receives the name and the `Runnable`
    object to be executed as parameters. Initialize the creation date of the thread:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它接收要执行的名称和`Runnable`对象作为参数。初始化线程的创建日期：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the `run()` method. Store the start date of the thread, call the
    `run()` method of the parent class, and store the finish date of the execution:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现run()方法。存储线程的起始日期，调用父类的run()方法，并存储执行完成日期：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement a method to establish the value of the `startDate` attribute:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来设置`startDate`属性值：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement a method to establish the value of the `finishDate` attribute:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来设置`finishDate`属性值：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement a method named `getExecutionTime()` that calculates the execution
    time of the thread as the difference between start and finish dates:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `getExecutionTime()` 的方法，该方法计算线程的执行时间，即开始和结束日期之间的差异：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Override the `toString()` method to return the creation date and execution
    time of the thread:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `toString()` 方法以返回线程的创建日期和执行时间：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a class named `MyThreadFactory` that implements the `ThreadFactory`
    interface:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyThreadFactory` 的类，该类实现了 `ThreadFactory` 接口：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Declare a private `AtomicInteger` attribute named `counter`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `counter` 的私有 `AtomicInteger` 属性：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare a private `String` attribute named `prefix`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `prefix` 的私有 `String` 属性：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the `newThread()` method. Create a `MyThread` object and increment
    the `counter` attribute:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `newThread()` 方法。创建一个 `MyThread` 对象并增加 `counter` 属性：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a class named `MyTask` that implements the `Runnable` interface. Implement
    the `run()` method. Put the current thread to sleep for 2 seconds:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyTask` 的类，该类实现了 `Runnable` 接口。实现 `run()` 方法。将当前线程休眠 2 秒：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并实现 `main()` 方法来实现示例的主类：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a `MyThreadFactory` object:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `MyThreadFactory` 对象：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a `Task` object:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Task` 对象：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a `MyThread` object to execute the task using the `newThread()` method
    of the factory:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工厂的 `newThread()` 方法创建一个 `MyThread` 对象来执行任务：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Start the thread and wait for its finalization:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程并等待其最终化：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write information about the thread using the `toString()` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `toString()` 方法编写有关线程的信息：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you implemented a custom `MyThread` class extending the `Thread`
    class. This class has three attributes to store the creation date, the start date
    of its execution, and the end date of its execution. Using the start date and
    end date attributes, you implemented the `getExecutionTime()` method that returns
    the total time the thread spent in executing its task. Finally, you overrode the
    `toString()` method to generate information about a thread.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你实现了一个自定义的 `MyThread` 类，该类扩展了 `Thread` 类。这个类有三个属性来存储创建日期、执行开始日期和执行结束日期。使用开始日期和结束日期属性，你实现了
    `getExecutionTime()` 方法，该方法返回线程执行任务所花费的总时间。最后，你重写了 `toString()` 方法以生成有关线程的信息。
- en: 'Once you had your own thread class, you implemented a factory to create objects
    of that class by implementing the `ThreadFactory` interface. It''s not mandatory
    to make use of the interface if you''re going to use your factory as an independent
    object, but if you want to use this factory with other classes of the Java Concurrency
    API, you must construct your factory by implementing this interface. The `ThreadFactory`
    interface has only one method: the `newThread()` method. This method receives
    a `Runnable` object as a parameter and returns a `Thread` object to execute the
    `Runnable` object. In your case, you returned a `MyThread` object.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了自己的线程类，你通过实现 `ThreadFactory` 接口来实现一个工厂来创建该类的对象。如果你打算将你的工厂作为一个独立对象使用，则不需要使用该接口，但如果你想要将此工厂与
    Java 并发 API 的其他类一起使用，你必须通过实现该接口来构建你的工厂。`ThreadFactory` 接口只有一个方法：`newThread()`
    方法。该方法接收一个 `Runnable` 对象作为参数，并返回一个 `Thread` 对象以执行 `Runnable` 对象。在你的情况下，你返回了一个
    `MyThread` 对象。
- en: To check these two classes, you implemented the `MyTask` class that implemented
    the `Runnable` object. This is the task to be executed in threads managed by the
    `MyThread` object. A `MyTask` instance puts its execution thread to sleep for
    2 seconds.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这两个类，你实现了 `MyTask` 类，该类实现了 `Runnable` 对象。这是由 `MyThread` 对象管理的线程要执行的任务。一个
    `MyTask` 实例将其执行线程休眠 2 秒。
- en: 'In the main method of the example, you created a `MyThread` object using a
    `MyThreadFactory` factory to execute a `Task` object. If you execute the program,
    you will see a message with the start date and the execution time of the thread
    executed.The following screenshot shows the output generated by this example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的主方法中，你使用 `MyThreadFactory` 工厂创建了一个 `MyThread` 对象来执行 `Task` 对象。如果你执行程序，你将看到一条消息，其中包含执行线程的开始日期和执行时间。以下截图显示了此示例生成的输出：
- en: '![](img/00051.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Java Concurrency API provides the `Executors` class to generate thread executors,
    usually objects of the `ThreadPoolExecutor` class. You can also use this class
    to obtain the most basic implementation of the `ThreadFactory` interface, using
    the `defaultThreadFactory()` method. The factory generated by this method generates
    basic `Thread` objects that belong to the same `ThreadGroup` object. You can use
    the `ThreadFactory` interface in your program for any purpose, not necessarily
    related only to the Executor framework.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了`Executors`类来生成线程执行器，通常是`ThreadPoolExecutor`类的对象。您也可以使用此类通过`defaultThreadFactory()`方法获取`ThreadFactory`接口的最基本实现。此方法生成的工厂将生成属于同一`ThreadGroup`对象的基本`Thread`对象。您可以在程序中出于任何目的使用`ThreadFactory`接口，而不仅仅是与Executor框架相关。
- en: Using our ThreadFactory in an Executor object
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Executor对象中使用我们的ThreadFactory
- en: In the previous recipe, we introduced the factory pattern and provided an example
    of how to implement a factory of threads implementing the `ThreadFactory` interface.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们介绍了工厂模式，并提供了如何实现实现`ThreadFactory`接口的线程工厂的示例。
- en: 'The Executor framework is a mechanism that allows you to separate thread creation
    and its execution. It''s based on the `Executor` and `ExecutorService` interfaces
    and the `ThreadPoolExecutor` class that implements both these interfaces. It has
    an internal pool of threads and provides methods that allow you to send two kinds
    of tasks to execute them in the pooled threads. These two kinds of tasks are as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架是一种机制，允许您分离线程创建和执行。它基于`Executor`和`ExecutorService`接口以及实现这两个接口的`ThreadPoolExecutor`类。它有一个内部线程池，并提供允许您将两种类型的任务发送到池中执行的方法。这两种类型任务如下：
- en: Classes that implement the `Runnable` interface, to implement tasks that don't
    return a result
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Runnable`接口的类，用于实现不返回结果的任务
- en: Classes that implement the `Callable` interface, to implement tasks that return
    a result
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Callable`接口的类，用于实现返回结果的任务
- en: Internally, the `Executor` framework uses a `ThreadFactory` interface to create
    threads that it uses to generate new threads. In this recipe, you will learn how
    to implement your own thread class, a thread factory to create threads of this
    class, and how to use this factory in an executor so the executor will execute
    your threads.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`Executor`框架使用`ThreadFactory`接口来创建它使用的线程，以生成新的线程。在本食谱中，您将学习如何实现自己的线程类，一个线程工厂来创建此类线程，以及如何在Executor中使用此工厂，以便Executor执行您的线程。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe and implement its example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的食谱并实现其示例。
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或另一个IDE，例如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Copy the `MyThread`, `MyThreadFactory`, and `MyTask` classes into the project.
    They were implemented in the *Implementing the ThreadFactory interface to generate
    custom threads for the fork/join framework* recipe. You are going to use them
    in this example.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MyThread`、`MyThreadFactory`和`MyTask`类复制到项目中。它们是在`实现ThreadFactory接口以生成fork/join框架的自定义线程`食谱中实现的。您将在本示例中使用它们。
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a new `MyThreadFactory` object named `threadFactory`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`threadFactory`的`MyThreadFactory`对象：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a new `Executor` object using the `newCachedThreadPool()` method of
    the `Executors` class. Pass the factory object created earlier as a parameter.
    The new `Executor` object will use this factory to create the necessary threads,
    so it will execute `MyThread` threads:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个新的`Executor`对象。将之前创建的工厂对象作为参数传递。新的`Executor`对象将使用此工厂创建必要的线程，因此它将执行`MyThread`线程：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a new `Task` object and send it to the executor using the `submit()`
    method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象，并使用`submit()`方法将其发送到执行器：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Shut down the executor using the `shutdown()` method:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的最终化：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Write a message to indicate the end of the program:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息以指示程序结束：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the *How it works...* section of the previous recipe, you have a detailed
    explanation of how the `MyThread`, `MyThreadFactory`, and `MyTask` classes work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中的 *How it works...* 部分中，你有一个关于 `MyThread`、`MyThreadFactory` 和 `MyTask`
    类如何工作的详细解释。
- en: In the `main()` method of the example, you created an `Executor` object using
    the `newCachedThreadPool()` method of the `Executors` class. You passed the factory
    object created earlier as a parameter, so the `Executor` object created will use
    that factory to create the threads it needs and also execute threads of the `MyThread`
    class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的 `main()` 方法中，你使用 `Executors` 类的 `newCachedThreadPool()` 方法创建了一个 `Executor`
    对象。你将之前创建的工厂对象作为参数传递，因此创建的 `Executor` 对象将使用该工厂创建所需的线程并执行 `MyThread` 类的线程。
- en: 'Execute the program and you will see a message with information about the thread''s
    start date and its execution time. The following screenshot shows the output generated
    by this example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，你将看到一条包含线程开始日期和执行时间的消息。以下截图显示了此示例生成的输出：
- en: '![](img/00052.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: See also
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* recipe in this chapter
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *实现 ThreadFactory 接口以生成 fork/join 框架的自定义线程* 的配方
- en: Customizing tasks running in a scheduled thread pool
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义在计划线程池中运行的任务
- en: 'Scheduled thread pool is an extension of the basic thread pool of the `Executor`
    framework that allows you to schedule the execution of tasks to be executed after
    a period of time. It''s implemented by the `ScheduledThreadPoolExecutor` class,
    and it permits the execution of the following two kinds of tasks:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 计划线程池是 `Executor` 框架的基本线程池的扩展，允许你安排在一段时间后执行的任务的执行。它由 `ScheduledThreadPoolExecutor`
    类实现，并允许执行以下两种类型的任务：
- en: '**Delayed tasks**: These kinds of tasks are executed only once after a period
    of time'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟任务**：这类任务在一段时间后只执行一次'
- en: '**Periodic tasks**: These kinds of tasks are executed after a delay and then
    periodically, every so often'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期性任务**：这类任务在延迟后执行，然后定期执行'
- en: Delayed tasks can execute both `Callable` and `Runnable` objects, but periodic
    tasks can only execute `Runnable` objects. All the tasks executed by a scheduled
    pool are an implementation of the `RunnableScheduledFuture` interface. In this
    recipe, you will learn how to implement your own implementation of the `RunnableScheduledFuture`
    interface to execute both delayed and periodic tasks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟任务可以执行 `Callable` 和 `Runnable` 对象，但周期性任务只能执行 `Runnable` 对象。由计划池执行的所有任务都是 `RunnableScheduledFuture`
    接口的一个实现。在本配方中，你将学习如何实现自己的 `RunnableScheduledFuture` 接口实现以执行延迟和周期性任务。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to implement the example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyScheduledTask` parameterized by a generic type named
    `V`. It extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyScheduledTask` 的类，该类由一个名为 `V` 的泛型类型参数化。它扩展了 `FutureTask` 类并实现了 `RunnableScheduledFuture`
    接口：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Declare a private`RunnableScheduledFuture` attribute named `task`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `task` 的私有 `RunnableScheduledFuture` 属性：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare a private`ScheduledThreadPoolExecutor` class named `executor`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `executor` 的私有 `ScheduledThreadPoolExecutor` 类：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Declare a private `long` attribute named `period`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `period` 的私有 `long` 属性：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare a private `long` attribute named `startDate`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `startDate` 的私有 `long` 属性：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement a constructor of the class. It receives the `Runnable` object that
    is going to be executed by a task, the result that will be returned by this task,
    the `RunnableScheduledFuture` task that will be used to create the `MyScheduledTask`
    object, and the `ScheduledThreadPoolExecutor` object that is going to execute
    the task. Call the constructor of its parent class and store the task and `executor`
    attributes:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它接收将要由任务执行的 `Runnable` 对象，该任务将返回的结果，用于创建 `MyScheduledTask` 对象的 `RunnableScheduledFuture`
    任务，以及将要执行任务的 `ScheduledThreadPoolExecutor` 对象。调用其父类的构造函数并存储任务和 `executor` 属性：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the `getDelay()` method. If the task is periodic and the `startDate`
    attribute has a value other than zero, calculate the returned value as the difference
    between the `startDate` attribute and the actual date. Otherwise, return the delay
    of the original task stored in the task attribute. Don''t forget that you have
    to return the result in the time unit passed as a parameter:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`getDelay()`方法。如果任务是周期性的并且`startDate`属性具有非零值，则计算返回值作为`startDate`属性和实际日期之间的差异。否则，返回存储在任务属性中的原始任务的延迟。别忘了你必须以传递的时间单位返回结果：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implement the `compareTo()` method. Call the `compareTo()` method of the original
    task:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`compareTo()`方法。调用原始任务的`compareTo()`方法：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the `isPeriodic()` method. Call the `isPeriodic()` method of the
    original task:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`isPeriodic()`方法。调用原始任务的`isPeriodic()`方法：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the `run()` method. If it''s a periodic task, you have to update
    its `startDate` attribute with the start date of the next execution of the task.
    Calculate it as the sum of the actual date and period. Then, add the task again
    to the queue of the `ScheduledThreadPoolExecutor` object:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法。如果是周期性任务，你必须使用下一个执行任务的开始日期更新其`startDate`属性。计算它为实际日期和周期的总和。然后，再次将任务添加到`ScheduledThreadPoolExecutor`对象的队列中：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Print a message to the console with the actual date. Execute the task calling
    the `runAndReset()` method and then print another message to the console with
    the actual date:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`runAndReset()`方法调用任务并打印实际日期的消息到控制台。然后，再次使用实际日期打印另一条消息到控制台：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the`setPeriod()` method to establish the period of this task:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`setPeriod()`方法来设置此任务的周期：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a class named `MyScheduledThreadPoolExecutor` to implement a `ScheduledThreadPoolExecutor`
    object that executes `MyScheduledTask` tasks. Specify that this class extends
    the `ScheduledThreadPoolExecutor` class:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyScheduledThreadPoolExecutor`的类来实现一个执行`MyScheduledTask`任务的`ScheduledThreadPoolExecutor`对象。指定这个类扩展`ScheduledThreadPoolExecutor`类：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement a constructor of the class that merely calls the constructor of its
    parent class:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个仅调用其父类构造函数的类构造函数：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Implement the `decorateTask()` method. It receives the `Runnable` object that
    is going to be executed as a parameter and the `RunnableScheduledFuture` task
    that will execute this `Runnable` object. Create and return a `MyScheduledTask`
    task using these objects to construct them:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`decorateTask()`方法。它接收即将执行的`Runnable`对象和将执行此`Runnable`对象的`RunnableScheduledFuture`任务作为参数。使用这些对象创建并返回一个`MyScheduledTask`任务来构建它们：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Override the `scheduledAtFixedRate()` method. Call the method of its parent
    class, convert the returned object into a `MyScheduledTask` object, and establish
    the period of that task using the `setPeriod()` method:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`scheduledAtFixedRate()`方法。调用其父类的方法，将返回的对象转换为`MyScheduledTask`对象，并使用`setPeriod()`方法设置该任务的周期：
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`Runnable`接口的名为`Task`的类：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Implement the `run()` method. Print a message at the start of the task, put
    the current thread to sleep for 2 seconds, and print another message at the end
    of the task:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法。在任务开始时打印一条消息，将当前线程休眠2秒，并在任务结束时打印另一条消息：
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE79]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a `MyScheduledThreadPoolExecutor` object named executor. Use `4` as
    a parameter to have two threads in the pool:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`executor`的`MyScheduledThreadPoolExecutor`对象。使用`4`作为参数以在池中有两个线程：
- en: '[PRE80]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a `Task` object named `task`. Write the actual date in the console:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`task`的`Task`对象。在控制台写入实际日期：
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Send a delayed task to the executor using the `schedule()` method. The task
    will be executed after a 1-second delay:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`schedule()`方法将延迟任务发送到执行器。任务将在延迟1秒后执行：
- en: '[PRE82]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Put the main thread to sleep for `3` seconds:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主线程休眠`3`秒：
- en: '[PRE83]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create another `Task` object. Print the actual date in the console again:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`Task`对象。再次在控制台打印实际日期：
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Send a periodic task to the executor using the `scheduleAtFixedRate()` method.
    The task will be executed after a 1-second delay and then it will be executed
    every 3 seconds:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scheduleAtFixedRate()`方法将周期性任务发送到执行器。任务将在延迟1秒后执行，然后每3秒执行一次：
- en: '[PRE85]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Put the main thread to sleep for 10 seconds:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主线程休眠10秒：
- en: '[PRE86]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Shut down the executor using the `shutdown()` method. Wait for the finalization
    of the executor using the `awaitTermination()` method:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法关闭执行器。使用 `awaitTermination()` 方法等待执行器的最终化：
- en: '[PRE87]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Write a message in the console indicating the end of the program:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入一条消息，指示程序的结束：
- en: '[PRE88]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you implemented the `MyScheduledTask` class to implement a custom
    task that can be executed on a `ScheduledThreadPoolExecutor` executor. This class
    extends the `FutureTask` class and implements the `RunnableScheduledFuture` interface.
    It implements the `RunnableScheduledFuture` interface because all the tasks executed
    in a scheduled executor must implement this interface and extend the `FutureTask`
    class. This is because this class provides valid implementations of the methods
    declared in the `RunnableScheduledFuture` interface. All the interfaces and classes
    mentioned earlier are parameterized classes and they possess the type of data
    that will be returned by the tasks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你实现了 `MyScheduledTask` 类，以实现一个可以在 `ScheduledThreadPoolExecutor` 执行器上执行的自定义任务。这个类扩展了
    `FutureTask` 类，并实现了 `RunnableScheduledFuture` 接口。它实现了 `RunnableScheduledFuture`
    接口，因为所有在计划执行器中执行的任务都必须实现这个接口并扩展 `FutureTask` 类。这是因为这个类提供了 `RunnableScheduledFuture`
    接口中声明的方法的有效实现。所有之前提到的接口和类都是参数化类，并且它们具有任务将返回的数据类型。
- en: To use a `MyScheduledTask` task in a scheduled executor, you override the `decorateTask()`
    method in the `MyScheduledThreadPoolExecutor` class. This class extends the `ScheduledThreadPoolExecutor`
    executor, and the method provides a mechanism to convert the default scheduled
    tasks implemented by the `ScheduledThreadPoolExecutor` executor into `MyScheduledTask`
    tasks. So, when you implement your own version of scheduled tasks, you have to
    implement your own version of a scheduled executor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计划执行器中使用 `MyScheduledTask` 任务，你需要在 `MyScheduledThreadPoolExecutor` 类中重写 `decorateTask()`
    方法。这个类扩展了 `ScheduledThreadPoolExecutor` 执行器，该方法提供了一个机制，将 `ScheduledThreadPoolExecutor`
    执行器实现的默认计划任务转换为 `MyScheduledTask` 任务。因此，当你实现自己的计划任务版本时，你必须实现自己的计划执行器版本。
- en: The `decorateTask()` method simply creates a new `MyScheduledTask` object with
    four parameters. The first one is a `Runnable` object that is going to be executed
    in the task. The second one is the object that is going to be returned by the
    task. In this case, the task won't return a result, so you used the null value.
    The third one is the task that the new object is going to replace in the pool
    and the latest is the executor that will execute the task. In this case, you use
    the this keyword to reference the executor that is creating the task.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorateTask()` 方法简单地创建一个新的 `MyScheduledTask` 对象，并带有四个参数。第一个参数是一个将要被执行的任务中的
    `Runnable` 对象。第二个参数是任务将要返回的对象。在这种情况下，任务不会返回结果，所以使用了 null 值。第三个参数是新的对象将要替换的池中的任务，最后一个是将要执行任务的执行器。在这种情况下，你使用
    this 关键字来引用创建任务的执行器。'
- en: The `MyScheduledTask` class can execute delayed and periodic tasks. You implemented
    two methods with all of the necessary logic to execute both kinds of tasks. They
    are the `getDelay()` and `run()` methods.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyScheduledTask` 类可以执行延迟和周期性任务。你实现了两个方法，包含了执行这两种任务所需的所有逻辑。它们是 `getDelay()`
    和 `run()` 方法。'
- en: The `getDelay()` method is called by the scheduled executor to know whether
    it has to execute a task. The behavior of this method changes in delayed and periodic
    tasks. As mentioned earlier, the constructor of the `MyScheduledClass` class receives
    the original `ScheduledRunnableFuture` object that was going to execute the `Runnable`
    object and stores it as an attribute of the class to have access to its methods
    and data. When we execute a delayed task, the `getDelay()` method returns the
    delay of the original task; however, in the case of a periodic task, the `getDelay()`
    method returns the difference between the `startDate` attribute and the actual
    date.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDelay()` 方法由计划执行器调用，以确定是否需要执行一个任务。这个方法在延迟和周期性任务中的行为会发生变化。如前所述，`MyScheduledClass`
    类的构造函数接收将要执行 `Runnable` 对象的原始 `ScheduledRunnableFuture` 对象，并将其存储为类的属性，以便访问其方法和数据。当我们执行一个延迟任务时，`getDelay()`
    方法返回原始任务的延迟；然而，在周期性任务的情况下，`getDelay()` 方法返回 `startDate` 属性和实际日期之间的差异。'
- en: The `run()` method is the one that executes the task. One particularity of periodic
    tasks is that you have to put the next execution of the task in the queue of the
    executor as a new task if you want the task to be executed again. So, if you're
    executing a periodic task, you establish the `startDate` attribute value and add
    it to the actual date and period of the execution of the task and store the task
    again in the queue of the executor. The `startDate` attribute stores the date
    when the next execution of the task will begin. Then, you execute the task using
    the `runAndReset()` method provided by the `FutureTask` class. In the case of
    delayed tasks, you don't have to put them in the queue of the executor because
    they can only be executed once.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法是执行任务的方法。周期性任务的一个特殊性是，如果您想再次执行任务，必须将任务的下一次执行放入执行器的队列中作为一个新任务。因此，如果您正在执行周期性任务，您需要设置
    `startDate` 属性的值，并将其添加到任务的实际执行日期和周期中，然后将任务再次存储在执行器的队列中。`startDate` 属性存储了任务下一次执行开始的时间。然后，您使用
    `FutureTask` 类提供的 `runAndReset()` 方法执行任务。在延迟任务的情况下，您不需要将它们放入执行器的队列中，因为它们只能执行一次。'
- en: You also have to take into account whether the executor has been shut down.
    If yes, you don't have to store the periodic tasks in the queue of the executor
    again.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须考虑执行器是否已关闭。如果是这样，您不需要再次将周期性任务存储在执行器的队列中。
- en: Finally, you overrode the `scheduleAtFixedRate()` method in the `MyScheduledThreadPoolExecutor`
    class. We mentioned earlier that for periodic tasks, you establish the value of
    the `startDate` attribute using the period of the task, but you haven't initialized
    that period yet. You have to override this method that receives this period as
    a parameter; do this to pass it to the `MyScheduledTask` class so it can use it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您在 `MyScheduledThreadPoolExecutor` 类中重写了 `scheduleAtFixedRate()` 方法。我们之前提到，对于周期性任务，您需要使用任务的周期来设置
    `startDate` 属性的值，但您还没有初始化这个周期。您必须重写这个接收该周期作为参数的方法；这样做是为了将其传递给 `MyScheduledTask`
    类，以便它可以使用它。
- en: 'The example is complete with the `Task` class that implements the `Runnable`
    interface, and it is the task executed in the scheduled executor. The main class
    of the example creates a `MyScheduledThreadPoolExecutor` executor and sends the
    following two tasks to them:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例完整地包含了实现 `Runnable` 接口的 `Task` 类，它是计划执行器中执行的任务。示例的主类创建了一个 `MyScheduledThreadPoolExecutor`
    执行器，并将以下两个任务发送给它：
- en: A delayed task, which is to be executed 1 second after the actual date
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个延迟任务，将在实际日期后 1 秒执行
- en: A periodic task, which is to be executed for the first time a second after the
    actual date and then every 3 seconds
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个周期性任务，将在实际日期后的第一次执行 1 秒，然后每 3 秒执行一次
- en: 'The following screenshot shows part of the execution of this example. You can
    check whether the two kinds of tasks are executed properly:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的部分执行情况。您可以检查两种任务是否正确执行：
- en: '![](img/00053.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: There's more...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ScheduledThreadPoolExecutor` class provides another version of the `decorateTask()`
    method that receives a `Callable` object as a parameter, instead of a `Runnable`
    object.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor` 类提供了一个接收 `Callable` 对象作为参数的 `decorateTask()`
    方法的另一个版本，而不是 `Runnable` 对象。'
- en: See also
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Running a task in an executor after a delay* and *Running a task in an
    executor periodically* recipes in [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Executors*
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 4 章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736) 的 *线程执行器* 部分中，*在执行器中延迟执行任务*
    和 *在执行器中周期性执行任务* 的食谱
- en: Implementing the ThreadFactory interface to generate custom threads for the
    fork/join framework
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ThreadFactory 接口以生成 fork/join 框架的自定义线程
- en: One of the most interesting features of Java 9 is the fork/join framework. It's
    an implementation of the `Executor` and `ExecutorService` interfaces that allows
    you to execute the `Callable` and `Runnable` tasks without managing the threads
    that execute them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 最有趣的功能之一是 fork/join 框架。它是对 `Executor` 和 `ExecutorService` 接口的实现，允许您执行
    `Callable` 和 `Runnable` 任务，而无需管理执行它们的线程。
- en: 'This executor is oriented to execute tasks that can be divided into smaller
    parts. Its main components are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此执行器面向执行可以分解为更小部分的任务。其主要组件如下：
- en: It's a special kind of task, which is implemented by the `ForkJoinTask` class.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种特殊类型的任务，由 `ForkJoinTask` 类实现。
- en: It provides two operations for dividing a task into subtasks (the fork operation)
    and to wait for the finalization of these subtasks (the join operation).
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了两个操作来将任务分割成子任务（fork 操作）以及等待这些子任务的最终化（join 操作）。
- en: It's an algorithm, denominating the work-stealing algorithm, that optimizes
    the use of the threads of the pool. When a task waits for its subtasks, the thread
    that was executing it is used to execute another thread.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个算法，称为工作窃取算法，它优化了线程池中线程的使用。当任务等待其子任务时，执行它的线程被用来执行另一个线程。
- en: 'The main class of the fork/join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join 框架的主类是 `ForkJoinPool` 类。内部，它有两个以下元素：
- en: A queue of tasks that are waiting to be executed
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一队列等待执行的任务
- en: A pool of threads that execute the tasks
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组执行任务的线程池
- en: The `ForkJoinWorkerThread` adds new methods to the `Thread` class, such as the
    `onStart()` method that's executed when the thread is created and the `onTermination()`
    method that's called to clean up the resources used by the thread. The `ForkJoinPool`
    class uses an implementation of the `ForkJoinWorkerThreadFactory` interface to
    create the worker threads it uses.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinWorkerThread` 类为 `Thread` 类添加了新方法，例如当线程创建时执行的 `onStart()` 方法以及用于清理线程使用的资源的
    `onTermination()` 方法。`ForkJoinPool` 类使用 `ForkJoinWorkerThreadFactory` 接口的一个实现来创建它所使用的工作线程。'
- en: In this recipe, you will learn how to implement a customized worker thread to
    be used in a `ForkJoinPool` class and how to use it with a factory extending the
    `ForkJoinPool` class and implementing the `ForkJoinWorkerThreadFactory` interface.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何实现一个用于 `ForkJoinPool` 类的自定义工作线程，以及如何使用它，通过扩展 `ForkJoinPool` 类并实现
    `ForkJoinWorkerThreadFactory` 接口来创建工厂。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyWorkerThread` that extends the `ForkJoinWorkerThread`
    class:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyWorkerThread` 的类，该类扩展了 `ForkJoinWorkerThread` 类：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Declare and create a private `ThreadLocal` attribute parameterized by the `Integer`
    class named `taskCounter`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建一个由 `Integer` 类参数化的私有 `ThreadLocal` 属性 `taskCounter`：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Implement a constructor of the class:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数：
- en: '[PRE91]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Override the `onStart()` method. Call the method on its parent class, print
    a message to the console, and set the value of the `taskCounter` attribute of
    this thread to zero:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onStart()` 方法。在其父类中调用该方法，向控制台打印一条消息，并将此线程的 `taskCounter` 属性值设置为零：
- en: '[PRE92]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Override the `onTermination()` method. Write the value of the `taskCounter`
    attribute of this thread in the console:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onTermination()` 方法。将此线程的 `taskCounter` 属性值写入控制台：
- en: '[PRE93]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Implement the `addTask()` method. Increment the value of the `taskCounter`
    attribute:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `addTask()` 方法。增加 `taskCounter` 属性的值：
- en: '[PRE94]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a class named `MyWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface. Implement the `newThread()` method. Create and return a `MyWorkerThread`
    object:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyWorkerThreadFactory` 的类，该类实现了 `ForkJoinWorkerThreadFactory` 接口。实现
    `newThread()` 方法。创建并返回一个 `MyWorkerThread` 对象：
- en: '[PRE95]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a class named `MyRecursiveTask` that extends the `RecursiveTask` class
    parameterized by the `Integer` class:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyRecursiveTask` 的类，该类扩展了由 `Integer` 类参数化的 `RecursiveTask` 类：
- en: '[PRE96]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Declare a private `int` array named `array`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `array` 的私有 `int` 数组：
- en: '[PRE97]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Declare two private `int` attributes named `start` and `end`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `start` 和 `end` 的私有 `int` 属性：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Implement the constructor of the class that initializes its attributes:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化其属性：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Implement the `compute()` method to sum all the elements of the array between
    the start and end positions. First, convert the thread that is executing the task
    into a `MyWorkerThread` object and use the `addTask()` method to increment the
    counter of tasks for that thread:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `compute()` 方法来计算数组中起始位置和结束位置之间的所有元素的总和。首先，将执行任务的线程转换为 `MyWorkerThread`
    对象，并使用 `addTask()` 方法增加该线程的任务计数器：
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If the difference between the start and end positions in the array is higher
    than 100 elements, we calculate the position in the middle and create two new
    `MyRecursiveTask` tasks to process the first and second halves, respectively.
    If the difference is equal to or lower than 100, we calculate the sum of all the
    elements between the start and end positions:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组中起始位置和结束位置之间的差异大于100个元素，我们计算中间位置并创建两个新的`MyRecursiveTask`任务来分别处理第一部分和第二部分。如果差异等于或小于100，我们计算起始位置和结束位置之间所有元素的总和：
- en: '[PRE101]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Put the thread to sleep for 10 milliseconds and return the result of the task:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠10毫秒，并返回任务的执行结果：
- en: '[PRE102]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Implement the `addResults()` method. Calculate and return the sum of the results
    of the two tasks received as parameters:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`addResults()`的方法。计算并返回作为参数接收的两个任务的结果总和：
- en: '[PRE103]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类：
- en: '[PRE104]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create a `MyWorkerThreadFactory` object named `factory`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`factory`的`MyWorkerThreadFactory`对象：
- en: '[PRE105]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create a `ForkJoinPool` object named `pool`. Pass the `factory` object, created
    earlier, to the constructor:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pool`的`ForkJoinPool`对象。将之前创建的`factory`对象传递给构造函数：
- en: '[PRE106]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create an array of 100,000 integers. Initialize all the elements to 1:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100,000个整数的数组。初始化所有元素为1：
- en: '[PRE107]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a new `task` object to sum all the elements of the array:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`task`对象来计算数组中所有元素的总和：
- en: '[PRE108]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Send the task to the pool using the `execute()` method:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`execute()`方法将任务发送到线程池：
- en: '[PRE109]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Wait for the end of the task using the `join()` method:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待任务的结束：
- en: '[PRE110]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Shut down the pool using the `shutdown()` method:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭线程池：
- en: '[PRE111]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的最终化：
- en: '[PRE112]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Write the result of the task in the console, using the `get()` method:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`get()`方法将任务的执行结果写入控制台：
- en: '[PRE113]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Write a message in the console indicating the end of the example:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入一条消息，表明示例结束：
- en: '[PRE114]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Threads used by the fork/join framework are called worker threads. Java includes
    the `ForkJoinWorkerThread` class that extends the `Thread` class and implements
    the worker threads used by the fork/join framework.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/Join框架使用的线程被称为工作线程。Java包括一个名为`ForkJoinWorkerThread`的类，它扩展了`Thread`类并实现了Fork/Join框架使用的工作线程。
- en: In this recipe, you implemented the `MyWorkerThread` class that extends the
    `ForkJoinWorkerThread` class and overrides two methods of the `ForkJoinWorkerThread`
    class. Your objective is to implement a counter of tasks in each worker thread
    so that you can know how many tasks a worker thread has executed. You implemented
    the counter with a `ThreadLocal` attribute. This way, each thread will have its
    own counter in a transparent way for you, the programmer.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你实现了`MyWorkerThread`类，该类扩展了`ForkJoinWorkerThread`类并重写了`ForkJoinWorkerThread`类的两个方法。你的目标是实现每个工作线程中的任务计数器，以便你可以知道一个工作线程执行了多少个任务。你使用`ThreadLocal`属性实现了计数器。这样，每个线程都会以对你，即程序员来说透明的方式拥有自己的计数器。
- en: You overrode the `onStart()` method of the `ForkJoinWorkerThread` class to initialize
    the task counter. This method is called when the worker thread begins its execution.
    You also overrode the `onTermination()` method to print the value of the task
    counter to the console. This method is called when the worker thread finishes
    its execution. In addition, you implemented a method in the `MyWorkerThread` class.
    The `addTask()` method increments the task counter of each thread.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你重写了`ForkJoinWorkerThread`类的`onStart()`方法来初始化任务计数器。当工作线程开始执行时，会调用此方法。你还重写了`onTermination()`方法，将任务计数器的值打印到控制台。当工作线程完成执行时，会调用此方法。此外，你在`MyWorkerThread`类中实现了一个方法。`addTask()`方法增加每个线程的任务计数器。
- en: The `ForkJoinPool` class, like with all the executors in the Java Concurrency
    API, creates its threads using a factory. So, if you want to use the `MyWorkerThread`
    thread in a `ForkJoinPool` class, you have to implement your thread factory. For
    the fork/join framework, this factory has to implement the `ForkJoinPool.ForkJoinWorkerThreadFactory`
    class. You implemented the `MyWorkerThreadFactory` class for this purpose. This
    class only has one method that creates a new `MyWorkerThread` object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you only have to initialize a `ForkJoinPool` class with the factory
    you have created. You did this in the `Main` class, using the constructor of the
    `ForkJoinPool` class.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: You can see how the `ForkJoinPool` object has executed four worker threads and
    how many tasks have executed each one of them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take into account that the `onTermination()` method provided by the `ForkJoinWorkerThread`
    class is called when a thread finishes normally or throws an exception. The method
    receives a `Throwable` object as a parameter. If the parameter takes the null
    value, the worker thread finishes normally; however, if the parameter takes a
    value, the thread throws an exception. You have to include the necessary code
    to process this situation.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating threads through a factory* recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Management*
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the fork/join framework
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework separates task creation and its execution. With it,
    you only have to implement the `Runnable` objects and use an `Executor` object.
    You just need to send the `Runnable` tasks to the executor and it creates, manages,
    and finalizes the necessary threads to execute these tasks.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 provides a special kind of executor in the fork/join framework (introduced
    in Java 7). This framework is designed to solve problems that can be broken down
    into smaller tasks using the divide and conquer technique. Inside a task, you
    have to check the size of the problem you want to resolve; if it's bigger than
    the established size, you divide the problem into two or more tasks and execute
    them using the framework. If the size of the problem is smaller than the established
    size, you resolve the problem directly in the task; optionally, it returns a result.
    The fork/join framework implements the work-stealing algorithm that improves the
    overall performance of these kinds of problems.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` class of the fork/join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the tasks executed by a `ForkJoinPool` class are objects of the
    `ForkJoinTask` class. You can also send the `Runnable` and `Callable` objects
    to a `ForkJoinPool` class, but they can''t take advantage of all the benefits
    of the fork/join framework. Normally, you will send one of two subclasses of the
    `ForkJoinTask` class to the `ForkJoinPool` object:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，由`ForkJoinPool`类执行的任务是`ForkJoinTask`类的对象。您也可以将`Runnable`和`Callable`对象发送到`ForkJoinPool`类，但它们无法充分利用分叉/合并框架的所有优点。通常，您会将`ForkJoinTask`类的两个子类之一发送到`ForkJoinPool`对象：
- en: '`RecursiveAction`: If your tasks don''t return a result'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecursiveAction`：如果您的任务不返回结果'
- en: '`RecursiveTask`: If your tasks return a result'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecursiveTask`：如果您的任务返回结果'
- en: In this recipe, you will learn how to implement your own tasks for the fork/join
    framework by implementing a task that extends the `ForkJoinTask` class. The task
    you're going to implement measures and writes its execution time in the console
    so you can control its evolution. You can also implement your own fork/join task
    to write log information, to get resources used in the tasks, or to postprocess
    the results of the tasks.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何通过实现一个扩展`ForkJoinTask`类的任务来为分叉/合并框架实现自己的任务。您将要实现的任务将测量并写入其执行时间，以便您可以控制其演变。您还可以实现自己的分叉/合并任务来写入日志信息，获取任务中使用的资源，或后处理任务的输出结果。
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyWorkerTask` and specify that it extends the `ForkJoinTask`
    class parameterized by the `Void` type:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyWorkerTask`的类，并指定它扩展由`Void`类型参数化的`ForkJoinTask`类：
- en: '[PRE115]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Declare a private `String` attribute called `name` to store the name of the
    task:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性来存储任务的名称：
- en: '[PRE116]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE117]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Implement the `getRawResult()` method. This is one of the abstract methods
    of the `ForkJoinTask` class. As the `MyWorkerTask` tasks won''t return any results,
    this method must return null:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回`null`的`getRawResult()`方法。这是`ForkJoinTask`类的抽象方法之一。由于`MyWorkerTask`任务不会返回任何结果，因此此方法必须返回`null`：
- en: '[PRE118]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Implement the `setRawResult()` method. This is another abstract method of the
    `ForkJoinTask` class. As the `MyWorkerTask` tasks won''t return any results, leave
    the body of this method empty:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setRawResult()`方法。这是`ForkJoinTask`类的另一个抽象方法。由于`MyWorkerTask`任务不会返回任何结果，因此请留空此方法的主体：
- en: '[PRE119]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implement the `exec()` method. This is the `main` method of the task. In this
    case, delegate the logic of the task to the `compute()` method. Calculate the
    execution time of this method and write it in the console:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`exec()`方法。这是任务的主方法。在这种情况下，将任务的逻辑委托给`compute()`方法。计算此方法的执行时间并将其写入控制台：
- en: '[PRE120]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Implement the `getName()` method to return the name of the task:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回任务名称的`getName()`方法：
- en: '[PRE121]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Declare the abstract method `compute()`. As mentioned earlier, this method
    will implement the logic of the tasks, and it must be implemented by the child
    classes of the `MyWorkerTask` class:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明抽象方法`compute()`。如前所述，此方法将实现任务的逻辑，并且必须由`MyWorkerTask`类的子类实现：
- en: '[PRE122]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a class named `Task` that extends the `MyWorkerTask` class:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类扩展了`MyWorkerTask`类：
- en: '[PRE123]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Declare a private array of `int` values named `array`:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`array`的私有`int`值数组：
- en: '[PRE124]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Implement a constructor of the class that initializes its attributes:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE125]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Implement the `compute()` method. This method increments the block of elements
    of the array determined by the start and end attributes. If this block of elements
    has more than 100 elements, divide the block into two parts and create two `Task`
    objects to process each part. Send these tasks to the pool using the `invokeAll()`
    method:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`compute()`方法。此方法根据起始和结束属性增加数组元素块。如果此元素块包含超过100个元素，则将块分成两部分，并创建两个`Task`对象来处理每一部分。使用`invokeAll()`方法将这些任务发送到池中：
- en: '[PRE126]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'If the block of elements has less than 100 elements, increment all the elements
    using a `for` loop:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素块少于100个元素，使用`for`循环增加所有元素：
- en: '[PRE127]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Finally, put the thread that is executing the task to sleep for 50 milliseconds:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让执行任务的线程休眠50毫秒：
- en: '[PRE128]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Next, implement the main class of the example by creating a class named `Main`
    with a `main()` method:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE129]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create an `int` array of 10,000 elements:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10,000个元素的`int`数组：
- en: '[PRE130]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Create a `ForkJoinPool` object named `pool`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pool`的`ForkJoinPool`对象：
- en: '[PRE131]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Create a `Task` object to increment all the elements of the array. The parameter
    of the constructor is given `Task` as the name of the task, the array object,
    and the values 0 and 10000 to indicate to this task that it has to process the
    entire array:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Send the task to the pool using the `execute()` method:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Shut down the `pool` using the `shutdown()` method:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Write a message in the console indicating the end of the program:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: How it works...
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyWorkerTask` class that extends the `ForkJoinTask`
    class. It's your own base class to implement tasks that can be executed in a `ForkJoinPool`
    executor and that can take advantage of all the benefits of the executor, as it's
    a work-stealing algorithm. This class is equivalent to the `RecursiveAction` and
    `RecursiveTask` classes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'When you extend the `ForkJoinTask` class, you have to implement the following
    three methods:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '`setRawResult()`: This method is used to establish the result of the task.
    As your tasks don''t return any results, leave this method empty.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRawResult()`: This method is used to return the result of the task. As
    your tasks don''t return any results, this method returns null.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec()`: This method implements the logic of the task. In this case, you delegated
    the logic to the abstract `compute()` method (as the `RecursiveAction` and `RecursiveTask`
    classes). However, in the `exec()` method, you measure the execution time of the
    method, writing it in the console.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the main class of the example, you created an array of 10,000 elements,
    a `ForkJoinPool` executor, and a `Task` object to process the whole array. Execute
    the program and you'll see how the different tasks that are executed write their
    execution time in the console.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* recipe in this chapter
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom Lock class
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Locks are one of the basic synchronization mechanisms provided by the Java
    Concurrency API. They allow programmers to protect a critical section of code
    so only one thread can execute that block of code at a time. It provides the following
    two operations:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '`lock()`: You call this operation when you want to access a critical section.
    If there is another thread running this critical section, other threads are blocked
    until they''re woken up by the lock to get access to the critical section.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock()`: You call this operation at the end of a critical section to allow
    other threads to access it.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Java Concurrency API, locks are declared in the `Lock` interface and
    implemented in some classes, for example, the `ReentrantLock` class.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own `Lock` object by implementing
    a class that implements the `Lock` interface, which can be used to protect a critical
    section.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyAbstractQueuedSynchronizer` that extends the `AbstractQueuedSynchronizer`
    class:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Declare a private `AtomicInteger` attribute named `state`:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Implement the `tryAcquire()` method. This method tries to change the value
    of the state variable from zero to one. If it can, it returns the `true` value;
    else, it returns `false`:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Implement the `tryRelease()` method. This method tries to change the value
    of the state variable from one to zero. If it can, it returns `true`; else, it
    returns `false`:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create a class named `MyLock` and specify that it implements the `Lock` interface:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Declare a private `AbstractQueuedSynchronizer` attribute named `sync`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Implement the constructor of the class to initialize the `sync` attribute with
    a new `MyAbstractQueueSynchronizer` object:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Implement the `lock()` method. Call the `acquire()` method of the `sync` object:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Implement the `lockInterruptibly()` method. Call the `acquireInterruptibly()`
    method of the sync object:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Implement the `tryLock()` method. Call the `tryAcquireNanos()` method of the
    `sync` object:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Implement another version of the `tryLock()` method with two parameters: a
    long parameter named time and a `TimeUnit` parameter named unit. Call the `tryAcquireNanos()`
    method of the sync object:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Implement the `unlock()` method. Call the `release()` method of the `sync`
    object:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Implement the `newCondition()` method. Create a new object of the internal
    class of the `sync` object, namely `ConditionObject`:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Declare a private `MyLock` attribute named `lock`:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Declare a private `String` attribute called `name`:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Implement the `run()` method of the class. Acquire the `lock`, put the thread
    to sleep for 2 seconds, and then release the lock object:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Create a `MyLock` object named `lock`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Create and execute 10 `Task` tasks:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Try to get the lock using the `tryLock()` method. Wait for a second, and if
    you don''t get the lock, write a message and try again:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Write a message indicating that you got the lock and release it:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Write a message indicating the end of the program:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: How it works...
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java Concurrency API provides a class that can be used to implement synchronization
    mechanisms with features of locks or semaphores. It''s called `AbstractQueuedSynchronizer`,
    and as the name suggests, it''s an abstract class. It provides operations to control
    access to a critical section and manage a queue of threads that are blocked and
    are awaiting access to the section. The operations are based on two abstract methods:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method is called to try and get access to a critical section.
    If the thread that calls it can access the critical section, the method returns
    the `true` value. Otherwise, it returns the `false` value.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryRelease()`: This method is called to try and release access to a critical
    section. If the thread that calls it can release access, the method returns the
    `true` value. Else, it returns the `false` value.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these methods, you have to implement the mechanism you use to control access
    to a critical section. In this case, you implemented the `MyAbstractQueuedSynchonizer`
    class that extends the `AbstractQueuedSyncrhonizer` class and implements the abstract
    methods using an `AtomicInteger` variable to control access to the critical section.
    This variable will store the value `0` if the lock is free, so a thread can have
    access to the critical section, and the value `1` if the lock is blocked, so a
    thread 'doesn't have access to the critical section.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: You used the `compareAndSet()` method provided by the `AtomicInteger` class
    that tries to change the value you specify as the first parameter with the value
    you specify as the second parameter. To implement the `tryAcquire()` method, you
    try to change the value of the atomic variable from zero to one. Similarly, to
    implement the `tryRelease()` method, you try to change the value of the atomic
    variable from one to zero.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: You have to implement `AtomicInteger` class because other implementations of
    the `AbstractQueuedSynchronizer` class (for example, the one used by `ReentrantLock`)
    are implemented as private classes internally. This is carried out in the class
    that uses it, so you don't have access to it.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Then, you implemented the `MyLock` class. This class implements the `Lock` interface
    and has a `MyQueuedSynchronizer` object as an attribute. To implement all the
    methods of the `Lock` interface, you used methods of the `MyQueuedSynchronizer`
    object.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implemented the `Task` class that implements the `Runnable` interface
    and uses a `MyLock` object to get access to the critical section. This critical
    section puts the thread to sleep for 2 seconds. The `main` class creates a `MyLock`
    object and runs 10 `Task` objects that share the lock. The `main` class also tries
    to get access to the lock using the `tryLock()` method.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the example, you can see how only one thread has access to
    the critical section, and when that thread finishes, another one gets access to
    it.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: You can use your own `Lock` interface to write log messages about its utilization,
    control the time that it's locked, or implement advanced synchronization mechanisms
    to control, for example, access to a resource so that it's only available at certain
    times.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AbstractQueuedSynchronizer` class provides two methods that can be used
    to manage the state of the lock. They are the `getState()` and `setState()` methods.
    These methods receive and return an integer value with the state of the lock.
    You could have used them instead of the `AtomicInteger` attribute to store the
    state of the lock.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The Java Concurrency API provides another class to implement synchronization
    mechanisms. It's the `AbstractQueuedLongSynchronizer` class, which is equivalent
    to `AbstractQueuedSynchronizer` but uses a long attribute to store the state of
    the threads.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with locks* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer queue-based on priorities
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java 9 API provides several data structures to work with concurrent applications.
    From these, we want to highlight the following two data structures:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedTransferQueue`: This data structure is supposed to be used in programs
    that have a producer/consumer structure. In such applications, you have one or
    more producers of data and one or more consumers of data, and a data structure
    is shared by all of them. Producers put data in the data structure and consumers
    take it from there. If the data structure is empty, consumers are blocked until
    they have data to consume. If it is full, producers are blocked until they have
    space to put data.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue`: In this data structure, elements are stored in an
    ordered way. They have to implement the `Comparable` interface with the `compareTo()`
    method. When you insert an element in the structure, it''s compared to the elements
    of the structure until it finds its position.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of `LinkedTransferQueue` are stored in the same order as they arrive,
    so the ones that arrived earlier are consumed first. It may be the case when you
    want to develop a producer/consumer program, where data is consumed according
    to some priority instead of arrival time. In this recipe, you will learn how to
    implement a data structure to be used in the producer/consumer problem whose elements
    will be ordered by priority; elements with higher priority will be consumed first.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyPriorityTransferQueue` that extends the `PriorityBlockingQueue`
    class and implements the `TransferQueue` interface:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Declare a private `AtomicInteger` attribute named `counter` to store the number
    of consumers that are waiting to consume elements:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Declare a private `LinkedBlockingQueue` attribute named `transferred`:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Declare a private `ReentrantLock` attribute named `lock`:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Implement the `tryTransfer()` method. This method tries to send the element
    to a waiting consumer immediately, if possible. If there isn''t any consumer waiting,
    the method returns `false`:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Implement the `transfer()` method. This method tries to send the element to
    a waiting consumer immediately, if possible. If there is no consumer waiting,
    the method stores the element in a special queue to be sent to the first consumer
    that tries to get an element and blocks the thread until the element is consumed:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Implement the `tryTransfer()` method that receives three parameters: the element,
    the time to wait for a consumer if there is none, and the unit of time used to
    specify the wait. If there is a consumer waiting, it sends the element immediately.
    Otherwise, it converts the time specified into milliseconds and uses the `wait()`
    method to put the thread to sleep. When the consumer takes the element, if the
    thread is sleeping in the `wait()` method, you need to wake it up using the `notify()`
    method, as you''ll see in a moment:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Implement the `hasWaitingConsumer()` method. Use the value of the counter attribute
    to calculate the return value of this method. If the counter has a value that
    is bigger than zero, it returns `true`; else, it returns `false`:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Implement the `getWaitingConsumerCount()` method. Return the value of the `counter`
    attribute:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Implement the `take()` method. This method is called by the consumers when
    they want to consume an element. First, get the lock defined earlier and increment
    the number of waiting consumers:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'If there aren''t any elements in the transferred queue, free the lock and try
    to get an element from the queue using the `take()` element and get the lock again.
    If there aren''t any elements in the queue, this method will put the thread to
    sleep until there are elements to consume:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Otherwise, take the element from the transferred queue and wake up the thread
    that is waiting to consume that element, if there is one. Take into account that
    you are synchronizing an object coming to this class from the outside. You have
    to guarantee that the object wouldn''t be used for locking in other parts of the
    application:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Finally, decrement the counter of waiting consumers and free the lock:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Next, implement a class named `Event` that extends the `Comparable` interface
    parameterized by the `Event` class:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Declare a private `String` attribute named `thread` to store the name of the
    thread that creates the event:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Declare a private `int` attribute named `priority` to store the priority of
    the event:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Implement a method to return the value of the `thread` attribute:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Implement a method to return the value of the `priority` attribute:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Implement the `compareTo()` method. This method compares the actual event with
    the event received as a parameter. Return `-1` if the actual event has a higher
    priority than the parameter, `1` if the actual event has a lower priority than
    the parameter, and `0` if both the events have the same priority. You will get
    the list ordered by priority in descending order. Events with a higher priority
    will be stored first in the queue:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Implement a class named `Producer` that implements the `Runnable` interface:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Declare a private `MyPriorityTransferQueue` attribute parameterized by the
    `Event` class named `buffer` to store the events generated by this producer:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Implement the `run()` method of the class. Create 100 `Event` objects using
    its order of creation as priority (the latest event will have the highest priority)
    and insert them into the queue using the `put()` method:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Implement a class named `Consumer` that implements the `Runnable` interface:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Declare a private `MyPriorityTransferQueue` attribute parameterized by the
    `Event` class named `buffer` to get the events consumed by this class:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Implement the `run()` method. It consumes 1,002 events (all the events generated
    in the example) using the `take()` method and writes the number of threads that
    generated the event and their priority in the console:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Create a `MyPriorityTransferQueue` object named `buffer`:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Create a `Producer` task and launch 10 threads to execute this task:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Create and launch a `Consumer` task:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Write the actual consumer count in the console:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Transfer an event to the consumer using the `transfer()` method:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Wait for the finalization of the producers using the `join()` method:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Put the thread to sleep for 1 second:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Write the actual consumer count:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Transfer another event using the `transfer()` method:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Wait for the finalization of the consumer using the `join()` method:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Write a message indicating the end of the program:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: How it works...
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyPriorityTransferQueue` data structure.
    It's a data structure to be used in the producer/consumer problem, but its elements
    are ordered by priority, not by their order of arrival. As Java doesn't allow
    multiple inheritances, the first decision you took was in relation to the base
    class of the `MyPriorityTransferQueue` class. You extend the class to use the
    operations implemented in the `PriorityBlockingQueue,` not to implement them.
    You also implemented the `TransferQueue` interface to add the methods related
    to the producer/consumer. We made this choice because we think it is easier to
    implement the methods of the `TransferQueue` interface than the methods implemented
    in the `PriorityBlockingQueue` class. However, you can implement the class that
    extends from the `LinkedTransferQueue` class and implements the necessary methods
    to get your own version of the `PriorityBlockingQueue` class.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MyPriortyTransferQueue` class has the following three attributes:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AtomicInteger` attribute named `counter`: This attribute stores the number
    of consumers that are waiting to take an element from the data structure. When
    a consumer calls the `take()` operation to take an element from the data structure,
    the counter is incremented. When the consumer finishes the execution of the `take()`
    operation, the counter is decremented again. This counter is used in the implementation
    of the `hasWaitingConsumer()` and `getWaitingConsumerCount()` methods.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `ReentrantLock` attribute named `lock`: This attribute is used to control
    access to implemented operations. Only one thread is allowed to work with the
    data structure, as per this attribute.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it has a `LinkedBlockingQueue` list to store transferred elements.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You implemented some methods in `MyPriorityTransferQueue`. All the methods
    are declared in the `TransferQueue` interface, and the `take()` method is implemented
    in the `PriorityBlockingQueue` interface. Both of these were described earlier.
    Here is a description of the rest:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '`tryTransfer(E e)`: This method tries to send an element directly to a consumer.
    If there is a consumer waiting, it stores the element in the priority queue to
    be consumed immediately by the consumer and then returns the `true` value. If
    no one''s waiting, it returns the `false` value.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer(E e)`: This method transfers an element directly to a consumer. If
    there is a consumer waiting, it stores the element in the priority queue to be
    consumed immediately by the consumer. Otherwise, the element is stored in the
    list of transferred elements, and the thread is blocked until the element is consumed.
    While the thread is put to sleep, you have to free the lock because, if you don''t
    do this, you will block the queue.'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryTransfer(E e, long timeout, TimeUnit unit)`: This method is similar to
    the `transfer()` method, but here, the thread blocks the period of time determined
    by its parameters. While the thread is put to sleep, you have to free the lock
    because, if you don''t, you will block the queue.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns the next element to be consumed. If there are
    elements in the list of transferred elements, the element is taken from the list.
    Otherwise, it is taken from the priority queue.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you implemented the data structure, you implemented the `Event` class.
    It is the class of the elements you have stored in the data structure. The `Event`
    class has two attributes to store the ID of the producer and the priority of the
    event, and it implements the `Comparable` interface because it is a requirement
    of your data structure.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Then, you implemented the `Producer` and `Consumer` classes. In the example,
    you had 10 producers and a consumer and they shared the same buffer. Each producer
    generated 100 events with incremental priority, so the events with a higher priority
    were the last generated ones.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: The main class of the example created a `MyPriorityTransferQueue` object, 10
    producers, and a consumer, and used the `transfer()` method of the `MyPriorityTransferQueue`
    buffer to transfer two events to the buffer.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
- en: You can see how events with a higher priority are consumed first and that a
    consumer consumes the transferred event.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe queue ordered by priority* and *Using blocking
    thread-safe deques* recipes in [Chapter 7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736),
    *Concurrent Collections*
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic variables were introduced in Java version 5; they provide atomic operations
    on single variables. When a thread does an operation with an atomic variable,
    the implementation of the class includes a mechanism to check that the operation
    is done atomically.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to extend an atomic object and implement
    two operations that follow the mechanisms of the atomic objects to guarantee that
    all the operations are done in one step.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ParkingCounter` and specify that it extends the `AtomicInteger`
    class:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Declare a private `int` attribute named `maxNumber` to store the maximum number
    of cars admitted into the parking lot:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Implement the `carIn()` method. This method increments the counter of cars
    if it has a value smaller than the established maximum value. Construct an infinite
    loop and get the value of the internal counter using the `get()` method:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'If the value is equal to the `maxNumber` attribute, the counter can''t be incremented
    (the parking lot is full and the car can''t enter). In this case, the method returns
    the `false` value:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Otherwise, increment the value and use the `compareAndSet()` method to change
    the old value with the new one. This method returns the `false` value; the counter
    was not incremented, so you have to begin the loop again. If it returns `true`,
    it means the change was made and then you return the `true` value:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Implement the `carOut()` method. This method decrements the counter of cars
    if it has a value bigger than `0`. Construct an infinite loop and get the value
    of the internal counter using the `get()` method:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Create a class named `Sensor1` that implements the `Runnable` interface:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Declare a private `ParkingCounter` attribute named `counter`:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Implement the `run()` method. Call the `carIn()` and `carOut()` operations
    several times:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Create a class named `Sensor2` that implements the `Runnable` interface:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Declare a private `ParkingCounter` attribute named `counter`:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Implement the `run()` method. Call the `carIn()` and `carOut()` operations
    several times:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Create a `ParkingCounter` object named `counter`:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Create and launch a `Sensor1` and `Sensor2` task:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Wait for the finalization of both the tasks:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Write the actual value of the counter in the console:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Write a message indicating the end of the program in the console:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: How it works...
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParkingCounter` class extends the `AtomicInteger` class with two atomic
    operations: `carIn()` and `carOut()`. The example simulates a system that controls
    the number of cars inside a parking lot. The parking lot can admit a number of
    cars, represented by the `maxNumber` attribute.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: 'The `carIn()` operation compares the actual number of cars in the parking lot
    with the maximum value. If they are equal, the car can''t enter the parking lot
    and the method returns the `false` value. Otherwise, it uses the following structure
    of the atomic operations:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Get the value of the atomic object in a local variable.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the new value in a different variable.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `compareAndSet()` method to try and replace the old value with the new
    one. If this method returns `true`, it means the old value you sent as a parameter
    was the value of the variable; therefore, it changes the values. The operation
    was made in an atomic way as the `carIn()` method returns `true`. If the `compareAndSet()`
    method returns `false`, it means the old value you sent as a parameter is not
    the value of the variable (the other thread modified it); therefore, the operation
    can't be done in an atomic way. The operation begins again until it can be done
    in an atomic way.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `carOut()` method is analogous to the `carIn()` method. You also implemented
    two `Runnable` objects that use the `carIn()` and `carOut()` methods to simulate
    the activity of parking. When you execute the program, you can see that the parking
    lot never exceeds the maximum value of cars.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in [Chapter 7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736),
    *Concurrent Collections*
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own stream generator
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream is a sequence of data that allows you to apply a sequence of operations
    (usually represented with lambda expressions) to it in a sequential or parallel
    way in order to filter, transform, sort, reduce, or construct a new data structure.
    It was introduced in Java 8 and was one of the most important features introduced
    in that version.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are based on the `Stream` interface and some related classes and interfaces
    included in the `java.util.stream` package. They have also provoked the introduction
    of new methods in a lot of classes to generate streams from different data structures.
    You can create a `Stream` interface from every data structure that implements
    the `Collection` interface: from `File`, `Directory`, `Array`, and a lot of other
    sources.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also included different mechanisms to create streams from your own sources.
    The most important ones are:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Supplier` interface: This interface defines the `get()` method. It will
    be called by `Stream` when it needs to process another object. You can create
    `Stream` from a `Supplier` interface using the `generate()` static method of the
    `Stream` class. Take into account that this source is potentially infinite, so
    you must use a method such as `limit()` or similar to limit the number of elements
    in `Stream`.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Stream.Builder` interface: This interface provides the `accept()` and
    `add()` elements to add elements to `Stream` and the `build()` method, which returns
    the `Stream` interface created with the elements added before.'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Spliterator` interface: This interface defines the necessary methods to
    traverse and split the elements of a source. You can use the `stream()` method
    of the `StreamSupport` class to generate the `Stream` interface to process the
    elements of `Spliterator`.'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement your own `Spliterator` interface
    and how to create a `Stream` interface to process its data. We will work with
    a matrix of elements. A normal `Stream` interface should process one element at
    a time, but we will use the `Spliterator` class to implement one row at a time.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Item` to store the information of each element of the
    matrix. It will have three private attributes: a `String` attribute named `name`
    and two integer attributes named `row` and `column`. Create the methods to get
    and set the values of these attributes. The code of this class is very simple,
    so it won''t be included here.'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `MySpliterator`. Specify that it implements the `Spliterator`
    interface parameterized by the `Item` class. This class has four attributes: a
    matrix of `Item` objects named `items` and three integer attributes named `start`,
    `end`, and `current` to store the first and last elements that will be processed
    by this `Spliterator` interface and the current element that is being processed.
    Implement the constructor of the class to initialize all these attributes:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Implement `characteristics()`. This method will return an `int` value that
    describes the behavior of `Spliterator`. The meaning of this value will be explained
    later in the *How it Works...* section:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Implement `estimatedSize()`. This method will return the number of elements
    to be processed by this `Spliterator`. We will calculate it as the difference
    between the end and current attributes:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Now implement `tryAdvance()`. This method will be called to try and process
    an element of the `Spliterator`. The input parameter of the `tryAdvance()` method
    is and object that implements the `Consumer` interface. It will be called by the
    Stream API, so we only have to worry about its implementation. In our case, as
    mentioned in the introduction to this chapter, we have a matrix of `Item` objects
    and we''re going to process a row each time. The `Consumer` function received
    will process an `Item` object. Therefore, if the `Spliterator` interface still
    has elements to process, we will process all the items of the current row using
    the `accept()` method of the `Consumer` function:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Now implement `forEachRemaining()`. This method will receive an implementation
    of the `Consumer` interface and will apply this function to the remaining elements
    of `Spliterator`. In our case, we will call the `tryAdvance()` method for all
    the remaining elements:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Finally, implement `trySplit()`. This method will be called by parallel streams
    to split `Spliterator` into two subsets. It will return a new `Spliterator` object
    with the elements that will be processed by another thread. The current thread
    will process the rest of the elements. If the `spliterator` object can''t be split,
    you have to return a null value. In our case, we will calculate the element in
    the middle of the elements we have to process. The first half will be processed
    by the current thread, and the second half will be processed by another thread:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Now implement the `Main` class of the project with the `main()` method. First,
    declare and initialize a matrix with 10 rows and 10 columns of `Item` objects:'
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Then, create a `MySpliterator` object to process all the elements of the matrix:'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Finally, use the `stream()` method of the `StreamSupport` class to create a
    stream from `Spliterator`. Pass the `true` value as the second parameter to indicate
    that our stream will be in parallel. Then, use the `forEach()` method of the `Stream`
    class to write information about each element:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: How it works...
  id: totrans-718
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main element of this example is `Spliterator`. This interface defines methods
    that can be used to process and partition a source of elements to be used, for
    example, the source of a `Stream` object. You will rarely need to use a `Spliterator`
    object directly. Only if you want a different behavior--that is, if you want to
    implement your own data structure and create `Stream` from it--use a `Spliterator`
    object.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '`Spliterator` has a set of characteristics that defines its behavior. They
    are as follows:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '`CONCURRENT`: The data source can be safely modified concurrently'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT`: All the elements of the data source are distinct'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMMUTABLE`: Elements can be added, deleted, or replaced in the data source'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NONNULL`: There''s no null element in the data source'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDERED`: There''s an encounter ordered in the elements of the data source'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIZED`: The value returned by the `estimateSize()` method is the exact size
    of the `Spliterator`'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SORTED`: The elements of `Spliterator` are sorted'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUBSIZED`: After you call the `trySplit()` method, you can obtain the exact
    size of both the parts of `Spliterator`'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we defined `Spliterator` with the `DISTINCT`, `IMMUTABLE`, `NONNULL`,
    `ORDERED`, `SIZED`, and `SUBSIZED` characteristics.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implemented all the methods defined by the `Spliterator` interface
    that don''t have a default implementation:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '`characteristics()`: This method returns the characteristics of the `Spliterator`
    object. Specifically, it returns an integer value you calculate using the bitwise
    `or` operator (`|`) between the individual characteristics of your `Spliterator`
    object. Take into account that the value returned should be consistent with the
    real characteristics of your `Spliterator` object.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`estimatedSize()`: This method returns the number of elements that would be
    processed by the `forEachRemaining()` method if it were called at the current
    moment. In our case, we returned the exact value as we know it, but the definition
    of the method talks about the estimated size.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAdvance()`: This method applies the function specified as a parameter to
    the next element to be processed, if there''s one, and returns true. If there''s
    no element to process, it will return false. In our case, this method received
    a `Consumer` that processed an Item object, but we processed a row of Item objects
    at a time. So we traversed all the items of the row and called the `accept()`
    method of `Consumer`.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trySplit()`: This method is used to divide the current `Spliterator` into
    two different parts so each one can be processed by different threads. In an ideal
    case, you should divide the data source into two halves with the same number of
    elements. But, in our case, we calculated the element in the middle between the
    start and end index and generated two blocks of elements. The start to the mid
    element part was processed by the current `Spliterator`, and the mid to the end
    element part was processed by the new `Spliterator` object. If you can''t split
    the data source, this method returns a null value. In our case, the `Spliterator`
    had only two elements, so it won''t be split.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other methods of the `Spliterator` interface have a default implementation,
    but we overrode the `forEachRemaining()` method. This method applies the function
    received as a parameter (an implementation of the `Consumer` interface) to the
    elements of the `Spliterator` that haven't been processed yet. We implemented
    our own version to write a message in the console. We used the `tryAdvance()`
    method to process each individual item.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of this example:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
- en: First, the `trySplit()` method is called to divide the data source, then the
    `forEachRemaining()` method is called to process all the elements of each `Spliterator`
    generated by the `trySplit()` method.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can obtain an implementation of the `Spliterator` interface from different
    data sources. The `BaseStream` class provides the `spliterator()` method that
    returns a `Spliterator` from the elements of the `Stream`. Other data structures,
    such as `ConcurrentLinkedDeque`, `ConcurrentLinkedQueue`, or `Collection`, also
    provide the `spliterator()` method to get an implementation of that interface
    to process the elements of those data structures.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own asynchronous stream
  id: totrans-743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive streams ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    defines a mechanism to provide asynchronous stream processing with non-blocking
    back pressure.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive streams are based on three elements:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: It is a publisher of information
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has one or more subscribers of this information
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides subscription between the publisher and a consumer
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 has included three interfaces--`Flow.Publisher`, `Flow.Subscriber`, and
    `Flow.Subscription`--and a utility class, `SubmissionPublisher`, to allow us to
    implement reactive stream applications.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own reactive application
    using only three interfaces. Take into account that we will implement the expected
    behavior between the three elements. The publisher will only send elements to
    those subscribers who have requested them, and it will do this in a concurrent
    way. But you can modify this behavior easily by modifying the implementation of
    the methods.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Implement a class named `News`. This class implements the elements sent from
    the publisher to the subscriber. It will have two private `String` attributes,
    named `title` and `content`, and a `Date` attribute named `date`. It will also
    have the methods to get and set the values of these attributes. The source code
    of this class is very simple, so it won't be included here.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `Consumer` and specify that it implements the `Subscriber`
    interface parameterized by the `News` class. It will have two private attributes:
    a `Subscription` object named subscription and a `String` attribute called name.
    Implement the constructor of the class to initialize the name attribute:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Implement the `onComplete()` method. This method should be called by the publisher
    when it doesn''t send any additional elements. In our case, we only write a message
    in the console:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Implement the `onError()` method. This method should be called by the publisher
    when an error has occurred. In our case, we only write a message in the console:'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Then, implement `onNext()`. This method receives a `News` object as a parameter,
    and it should be called by the publisher when he or she sends an item to the subscriber.
    In our case, we write the value of the attributes of the `News` object in the
    console, and we use the `request()` method of the `Subscription` object to request
    an additional item:'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Finally, implement `onSubscription()`. This method will be called by the publisher,
    and it will be the first method of `Subscriber` invoked by it. It receives the
    `Subscription` between the publisher and the subscriber. In our case, we store
    the `Subscription` object and request the first item to be processed by the subscriber
    using the `request()` method:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Implement a class named `MySubscription` and specify that it implements the
    `Subscription` interface. It will have a private `Boolean` attribute named canceled
    and a private integer attribute named requested:'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Implement the `cancel()` method provided by the `Subscription` interface to
    cancel the communication between the publisher and the subscriber. In our case,
    we set to `true` the canceled attribute:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Implement the `request()` method provided by the `Subscription` interface.
    This method is used by the subscriber to request elements from the publisher.
    It receives as parameter the number of elements requested by the subscriber. In
    our case, we increment the value of the requested attribute:'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Implement the `isCanceled()` method to obtain the value of the canceled attribute,
    the `getRequested()` method to obtain the value of the requested attribute and
    the `decreaseRequested()` to decrease the value of the requested attribute:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Implement a class named `ConsumerData`. This class will be used by the publisher
    to store the information of every subscriber. It will have a private `Consumer`
    attribute named consumer and a private `MySubscription` attribute named subscription.
    It will also have the methods to `get()` and `set()` the value of those attributes.
    The source code of this class is very simple, so it won't be included here.
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a class named `PublisherTask` and specify that it implements the
    `Runnable` interface. It will have a private `ConsumerData` attribute named `consumerData`
    and a private `News` attribute named news. Implement a constructor to initialize
    both the attributes:'
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Implement the `run()` method. It will get the `MySubscription` object of the
    `ConsumerData` attribute. If the subscription is not canceled and it has requested
    elements (the value of the attribute is bigger than 0), we send the `News` object
    to the subscriber using its `onNext()` method and then decrement the value of
    the requested attribute:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Then, implement a class named `MyPublisher` and specify that it implements
    the `Publisher` interface parameterized by the `News` class. It will store a private
    `ConcurrentLinkedDeque` of `ConsumerData` objects and a `ThreadPoolExecutor` object
    named `executor`. Implement the constructor of the class to initialize both the
    attributes:'
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Now, implement `subscribe()`. This method will receive a `Subscriber` object
    that wants to receive the items of this publisher in the form of a parameter.
    We create `MySubscription` and `ConsumerData` objects, store `ConsumerData` in
    `ConcurrentLinkedDeque`, and call the `onSubscribe()` method of the subscriber
    to send the subscription object to the `Subscriber` object:'
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Now implement the `publish()` method. This method receives a `News` parameter
    and sends it to the subscribers that meet the conditions explained before. To
    do this, we create a `PublisherTask` method per `Subscriber` and send these tasks
    to the executor:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Finally, implement the `Main` class of the example with its `main()` method.
    We create a publisher and two subscribers and subscribe them to the publisher:'
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Then, create a `News` object, send it to the publisher, sleep the main thread
    for a second, create another `News` object, and send it to the publisher again:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: How it works...
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we implemented a reactive streams communication between a publisher
    and a subscriber using the interfaces provided by the Java 9 API and just followed
    the expected behavior defined in the reactive streams' specification.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: We had a publisher implemented by the `MyPublisher` class and subscribers implemented
    by the `Consumer` class. There are subscriptions between the publishers, and each
    subscriber is implemented by the `MySubscription` object.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: The cycle of the communication starts when a subscriber calls the `subscribe()`
    method of a publisher. The publisher has to create the subscription between them
    and send that subscription to the subscriber using the `onSubscribe()` method.
    The subscriber must use the `request()` method of the subscription to indicate
    that it's ready to process more elements from the publisher. When the publisher
    publishes an item, it will send it to all its subscribers who have requested elements
    from the publisher using the subscription between them.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: We added all the necessary elements to guarantee this behavior in a concurrent
    way.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to create an application that uses reactive streams is to use
    the `SubsmissionPublisher` class. This class implements the `Publisher` interface
    and provides the necessary methods to use it as the publisher part of the application.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reactive programming with reactive streams* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
