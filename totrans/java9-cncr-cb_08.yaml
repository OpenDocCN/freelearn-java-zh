- en: Customizing Concurrency Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ThreadPoolExecutor class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a priority-based Executor class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using our ThreadFactory in an Executor object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in a scheduled thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads for the
    fork/join framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the fork/join framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom Lock class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer queue-based on priorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own stream generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own asynchronous stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Concurrency API provides a lot of interfaces and classes to implement
    concurrent applications. They provide low-level mechanisms, such as the `Thread`
    class, the `Runnable` or `Callable` interfaces, or the `synchronized` keyword.
    They also provide high-level mechanisms, such as the `Executor` framework and
    the fork/join framework added in the Java 7 release, or the `Stream` framework
    added in Java 8, to process big sets of data. Despite this, you may find yourself
    developing a program where the default configuration and/or implementation of
    the Java API doesn't meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you may need to implement your own custom concurrent utilities,
    based on the ones provided by Java. Basically, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an interface to provide the functionality defined by that interface,
    for example, the `ThreadFactory` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override some methods of a class to adapt its behavior to your needs. For example,
    overriding the `onAdvance()` method of the `Phaser` class that, by default, does
    nothing useful and is supposed to be overridden to offer some functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the recipes of this chapter, you will learn how to change the behavior
    of some Java concurrency API classes without the need to design a concurrency
    framework from scratch. You can use these recipes as an initial point to implement
    your own customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ThreadPoolExecutor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Executor` framework is a mechanism that allows you to separate thread
    creation from its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces with the `ThreadPoolExecutor` class that implements both the interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks and execute them in the pooled threads. These tasks are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Runnable` interface to implement tasks that don't return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Callable` interface to implement tasks that return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, you only send the task to the executor. The executor uses one
    of its pooled threads or creates a new one to execute those tasks. It also decides
    the moment in which the task is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to override some methods of the `ThreadPoolExecutor`
    class to calculate the execution time of the tasks that you will execute in the
    executor and write about the executor in console statistics when it completes
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyExecutor` that extends the `ThreadPoolExecutor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ConcurrentHashMap` attribute parameterized by the `String`
    and `Date` classes, named `startTimes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor for the class. Call a constructor of the parent class
    using the `super` keyword and initialize the `startTime` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `shutdown()` method. Write in the console information about the
    executed, running, and pending tasks. Then, call the `shutdown()` method of the
    parent class using the `super` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `shutdownNow()` method. Write in the console information about
    the executed, running, and pending tasks. Then, call the `shutdownNow()` method
    of the parent class using the `super` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `beforeExecute()` method. Write a message in the console with
    the name of the thread that is going to execute the task and the hash code of
    the task. Store the start date in `HashMap` using the hash code of the task as
    the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `afterExecute()` method. Write a message in the console with the
    result of the task and calculate the running time of the task after subtracting
    the start date of the task stored in `HashMap` of the current date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `SleepTwoSecondsTask` that implements the `Callable` interface
    parameterized by the `String` class. Implement the `call()` method. Put the current
    thread to sleep for 2 seconds and return the current date converted into a `String`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyExecutor` object named `myExecutor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `Future` objects parameterized by the `String` class to store
    the resultant objects of the tasks you''re going to send to the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit 10 `Task` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the result of the execution of the first five tasks using the `get()` method.
    Write them in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the execution of the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the result of the execution of the last five tasks using the `get()` method.
    Write them in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the completion of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating the end of the execution of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented our custom executor by extending the `ThreadPoolExecutor`
    class and overriding four of its methods. The `beforeExecute()` and `afterExecute()`
    methods were used to calculate the execution time of a task. The `beforeExecute()`
    method is executed before the execution of a task; in this case, we used `HashMap`
    to store the start date of the task in it. The `afterExecute()` method is executed
    after the execution of the task. You got `startTime` of the task that had finished
    from `HashMap` and then calculate the difference between the actual date and and
    the `startTime` to get the execution time of the task. You also overrode the `shutdown()`
    and `shutdownNow()` methods to write statistics about the tasks executed in the
    executor to the console. These tasks included:'
  prefs: []
  type: TYPE_NORMAL
- en: The executed tasks, using the `getCompletedTaskCount()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tasks that were running at the current time, using the `getActiveCount()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pending tasks, using the `size()` method of the blocking queue where the
    executor stores the pending tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SleepTwoSecondsTask` class that implements the `Callable` interface puts
    its execution thread to sleep for 2 seconds and the `Main` class, where you send
    10 tasks to your executor, uses it and the other classes to demo their features.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the program and you will see how the program shows the time span of
    each task that is running and the statistics of the executor upon calling the
    `shutdown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using our ThreadFactory in an Executor object* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a priority-based Executor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first version of the Java Concurrency API, you had to create and run
    all the threads of your application. In Java version 5, with the appearance of
    the Executor framework, a new mechanism was introduced for the execution of concurrency
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With the Executor framework, you only have to implement your tasks and send
    them to the executor. The executor is responsible for the creation and execution
    of the threads that execute your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, an executor uses a blocking queue to store pending tasks. These
    are stored in the order of their arrival at the executor. One possible alternative
    is to use a priority queue to store new tasks. This way, if a new task with high
    priority arrives to the executor, it will be executed before all the other threads
    that have already been waiting but have comparatively lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to adapt an executor that will use a priority
    queue to store the tasks you send for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyPriorityTask` that implements the `Runnable` and `Comparable`
    interfaces parameterized by the `MyPriorityTask` class interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `priority`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private String attribute called name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to return the value of the priority attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compareTo()` method declared in the `Comparable` interface.
    It receives a `MyPriorityTask` object as a parameter and compares the priorities
    of the two objects: the current one and the parameter. You let tasks with higher
    priority be executed before tasks with lower priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Put the current thread to sleep for 2 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ThreadPoolExecutor` object named `executor`. Use `PriorityBlockingQueue`,
    parameterized by the `Runnable` interface, as the queue that this executor will
    use to store its pending tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Send 10 tasks to the executor using the counter of the loop as the priority
    of the tasks. Use the `execute()` method to send the tasks to the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the current thread to sleep for 1 second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Send 10 additional tasks to the executor using the counter of the loop as the
    priority of the tasks. Use the `execute()` method to send the tasks to the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the finalization of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting a regular executor into a priority-based executor is simple. You
    only have to pass a `PriorityBlockingQueue` object, parameterized by the `Runnable`
    interface, as a parameter. But with the executor, you should know that all the
    objects stored in a priority queue have to implement the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: You implemented the `MyPriorityTask` class that implements the `Runnable` interface,
    which will act as a task, and the `Comparable` interface to be stored in the priority
    queue. This class has a `Priority` attribute that is used to store the priority
    of the tasks. If a task has a higher value for this attribute, it will be executed
    earlier. The `compareTo()` method determines the order of the tasks in the priority
    queue. In the `Main` class, you sent 20 tasks to the executor with different priorities.
    The first tasks you sent to the executor were the first tasks to be executed.
    As the executor was idle waiting for the tasks, it executed the first tasks immediately,
    as soon as they arrived. You created the executor with four execution threads,
    so the first four tasks will be the first ones that are executed. Then, the rest
    of the tasks will be executed based on their priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows one execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can configure `Executor` to use any implementation of the `BlockingQueue`
    interface. One interesting implementation is `DelayQueue`. This class is used
    to store elements with delayed activation. It provides methods that only return
    active objects. You can use this class to implement your own version of the `ScheduledThreadPoolExecutor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing the ThreadPoolExecutor class* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe queue ordered by priority* recipe in [Chapter
    7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factory pattern is a widely used design pattern in the object-oriented programming
    world. It is a creational pattern and its objective is to develop a class whose
    mission is to create objects of one or several classes. Then, when we want to
    create an object of one of those classes, we use the factory instead of using
    the new operator.
  prefs: []
  type: TYPE_NORMAL
- en: With this factory, we centralize the creation of objects, thereby gaining the
    advantage of easily changing the class of objects created or the way we create
    these objects, considering the limitations we have in creating objects with limited
    resources. For example, we can only have *N* objects of a type that has the ability
    to easily generate statistical data about the creation of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides the `ThreadFactory` interface to implement a `Thread` object factory.
    Some advanced utilities of the Java concurrency API, such as the `Executor` framework
    or the fork/join framework, use thread factories to create threads. Another example
    of the factory pattern in the Java Concurrency API is the `Executors` class. It
    provides a lot of methods to create different kinds of `Executor` objects. In
    this recipe, you will extend the `Thread` class by adding new functionalities,
    and you will implement a thread factory class to generate threads of this new
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyThread` that extends the `Thread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare three private `Date` attributes named `creationDate`, `startDate`,
    and `finishDate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class. It receives the name and the `Runnable`
    object to be executed as parameters. Initialize the creation date of the thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Store the start date of the thread, call the
    `run()` method of the parent class, and store the finish date of the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to establish the value of the `startDate` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to establish the value of the `finishDate` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `getExecutionTime()` that calculates the execution
    time of the thread as the difference between start and finish dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `toString()` method to return the creation date and execution
    time of the thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyThreadFactory` that implements the `ThreadFactory`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicInteger` attribute named `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `prefix`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `newThread()` method. Create a `MyThread` object and increment
    the `counter` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyTask` that implements the `Runnable` interface. Implement
    the `run()` method. Put the current thread to sleep for 2 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyThreadFactory` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyThread` object to execute the task using the `newThread()` method
    of the factory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the thread and wait for its finalization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Write information about the thread using the `toString()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented a custom `MyThread` class extending the `Thread`
    class. This class has three attributes to store the creation date, the start date
    of its execution, and the end date of its execution. Using the start date and
    end date attributes, you implemented the `getExecutionTime()` method that returns
    the total time the thread spent in executing its task. Finally, you overrode the
    `toString()` method to generate information about a thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you had your own thread class, you implemented a factory to create objects
    of that class by implementing the `ThreadFactory` interface. It''s not mandatory
    to make use of the interface if you''re going to use your factory as an independent
    object, but if you want to use this factory with other classes of the Java Concurrency
    API, you must construct your factory by implementing this interface. The `ThreadFactory`
    interface has only one method: the `newThread()` method. This method receives
    a `Runnable` object as a parameter and returns a `Thread` object to execute the
    `Runnable` object. In your case, you returned a `MyThread` object.'
  prefs: []
  type: TYPE_NORMAL
- en: To check these two classes, you implemented the `MyTask` class that implemented
    the `Runnable` object. This is the task to be executed in threads managed by the
    `MyThread` object. A `MyTask` instance puts its execution thread to sleep for
    2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main method of the example, you created a `MyThread` object using a
    `MyThreadFactory` factory to execute a `Task` object. If you execute the program,
    you will see a message with the start date and the execution time of the thread
    executed.The following screenshot shows the output generated by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Concurrency API provides the `Executors` class to generate thread executors,
    usually objects of the `ThreadPoolExecutor` class. You can also use this class
    to obtain the most basic implementation of the `ThreadFactory` interface, using
    the `defaultThreadFactory()` method. The factory generated by this method generates
    basic `Thread` objects that belong to the same `ThreadGroup` object. You can use
    the `ThreadFactory` interface in your program for any purpose, not necessarily
    related only to the Executor framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using our ThreadFactory in an Executor object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we introduced the factory pattern and provided an example
    of how to implement a factory of threads implementing the `ThreadFactory` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Executor framework is a mechanism that allows you to separate thread creation
    and its execution. It''s based on the `Executor` and `ExecutorService` interfaces
    and the `ThreadPoolExecutor` class that implements both these interfaces. It has
    an internal pool of threads and provides methods that allow you to send two kinds
    of tasks to execute them in the pooled threads. These two kinds of tasks are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that implement the `Runnable` interface, to implement tasks that don't
    return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that implement the `Callable` interface, to implement tasks that return
    a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, the `Executor` framework uses a `ThreadFactory` interface to create
    threads that it uses to generate new threads. In this recipe, you will learn how
    to implement your own thread class, a thread factory to create threads of this
    class, and how to use this factory in an executor so the executor will execute
    your threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the previous recipe and implement its example.
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `MyThread`, `MyThreadFactory`, and `MyTask` classes into the project.
    They were implemented in the *Implementing the ThreadFactory interface to generate
    custom threads for the fork/join framework* recipe. You are going to use them
    in this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `MyThreadFactory` object named `threadFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Executor` object using the `newCachedThreadPool()` method of
    the `Executors` class. Pass the factory object created earlier as a parameter.
    The new `Executor` object will use this factory to create the necessary threads,
    so it will execute `MyThread` threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Task` object and send it to the executor using the `submit()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to indicate the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *How it works...* section of the previous recipe, you have a detailed
    explanation of how the `MyThread`, `MyThreadFactory`, and `MyTask` classes work.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` method of the example, you created an `Executor` object using
    the `newCachedThreadPool()` method of the `Executors` class. You passed the factory
    object created earlier as a parameter, so the `Executor` object created will use
    that factory to create the threads it needs and also execute threads of the `MyThread`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the program and you will see a message with information about the thread''s
    start date and its execution time. The following screenshot shows the output generated
    by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in a scheduled thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scheduled thread pool is an extension of the basic thread pool of the `Executor`
    framework that allows you to schedule the execution of tasks to be executed after
    a period of time. It''s implemented by the `ScheduledThreadPoolExecutor` class,
    and it permits the execution of the following two kinds of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delayed tasks**: These kinds of tasks are executed only once after a period
    of time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Periodic tasks**: These kinds of tasks are executed after a delay and then
    periodically, every so often'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayed tasks can execute both `Callable` and `Runnable` objects, but periodic
    tasks can only execute `Runnable` objects. All the tasks executed by a scheduled
    pool are an implementation of the `RunnableScheduledFuture` interface. In this
    recipe, you will learn how to implement your own implementation of the `RunnableScheduledFuture`
    interface to execute both delayed and periodic tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyScheduledTask` parameterized by a generic type named
    `V`. It extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private`RunnableScheduledFuture` attribute named `task`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private`ScheduledThreadPoolExecutor` class named `executor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `long` attribute named `period`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `long` attribute named `startDate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class. It receives the `Runnable` object that
    is going to be executed by a task, the result that will be returned by this task,
    the `RunnableScheduledFuture` task that will be used to create the `MyScheduledTask`
    object, and the `ScheduledThreadPoolExecutor` object that is going to execute
    the task. Call the constructor of its parent class and store the task and `executor`
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getDelay()` method. If the task is periodic and the `startDate`
    attribute has a value other than zero, calculate the returned value as the difference
    between the `startDate` attribute and the actual date. Otherwise, return the delay
    of the original task stored in the task attribute. Don''t forget that you have
    to return the result in the time unit passed as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compareTo()` method. Call the `compareTo()` method of the original
    task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `isPeriodic()` method. Call the `isPeriodic()` method of the
    original task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. If it''s a periodic task, you have to update
    its `startDate` attribute with the start date of the next execution of the task.
    Calculate it as the sum of the actual date and period. Then, add the task again
    to the queue of the `ScheduledThreadPoolExecutor` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Print a message to the console with the actual date. Execute the task calling
    the `runAndReset()` method and then print another message to the console with
    the actual date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the`setPeriod()` method to establish the period of this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyScheduledThreadPoolExecutor` to implement a `ScheduledThreadPoolExecutor`
    object that executes `MyScheduledTask` tasks. Specify that this class extends
    the `ScheduledThreadPoolExecutor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class that merely calls the constructor of its
    parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `decorateTask()` method. It receives the `Runnable` object that
    is going to be executed as a parameter and the `RunnableScheduledFuture` task
    that will execute this `Runnable` object. Create and return a `MyScheduledTask`
    task using these objects to construct them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `scheduledAtFixedRate()` method. Call the method of its parent
    class, convert the returned object into a `MyScheduledTask` object, and establish
    the period of that task using the `setPeriod()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Print a message at the start of the task, put
    the current thread to sleep for 2 seconds, and print another message at the end
    of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyScheduledThreadPoolExecutor` object named executor. Use `4` as
    a parameter to have two threads in the pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object named `task`. Write the actual date in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Send a delayed task to the executor using the `schedule()` method. The task
    will be executed after a 1-second delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the main thread to sleep for `3` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another `Task` object. Print the actual date in the console again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Send a periodic task to the executor using the `scheduleAtFixedRate()` method.
    The task will be executed after a 1-second delay and then it will be executed
    every 3 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the main thread to sleep for 10 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the executor using the `shutdown()` method. Wait for the finalization
    of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyScheduledTask` class to implement a custom
    task that can be executed on a `ScheduledThreadPoolExecutor` executor. This class
    extends the `FutureTask` class and implements the `RunnableScheduledFuture` interface.
    It implements the `RunnableScheduledFuture` interface because all the tasks executed
    in a scheduled executor must implement this interface and extend the `FutureTask`
    class. This is because this class provides valid implementations of the methods
    declared in the `RunnableScheduledFuture` interface. All the interfaces and classes
    mentioned earlier are parameterized classes and they possess the type of data
    that will be returned by the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To use a `MyScheduledTask` task in a scheduled executor, you override the `decorateTask()`
    method in the `MyScheduledThreadPoolExecutor` class. This class extends the `ScheduledThreadPoolExecutor`
    executor, and the method provides a mechanism to convert the default scheduled
    tasks implemented by the `ScheduledThreadPoolExecutor` executor into `MyScheduledTask`
    tasks. So, when you implement your own version of scheduled tasks, you have to
    implement your own version of a scheduled executor.
  prefs: []
  type: TYPE_NORMAL
- en: The `decorateTask()` method simply creates a new `MyScheduledTask` object with
    four parameters. The first one is a `Runnable` object that is going to be executed
    in the task. The second one is the object that is going to be returned by the
    task. In this case, the task won't return a result, so you used the null value.
    The third one is the task that the new object is going to replace in the pool
    and the latest is the executor that will execute the task. In this case, you use
    the this keyword to reference the executor that is creating the task.
  prefs: []
  type: TYPE_NORMAL
- en: The `MyScheduledTask` class can execute delayed and periodic tasks. You implemented
    two methods with all of the necessary logic to execute both kinds of tasks. They
    are the `getDelay()` and `run()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDelay()` method is called by the scheduled executor to know whether
    it has to execute a task. The behavior of this method changes in delayed and periodic
    tasks. As mentioned earlier, the constructor of the `MyScheduledClass` class receives
    the original `ScheduledRunnableFuture` object that was going to execute the `Runnable`
    object and stores it as an attribute of the class to have access to its methods
    and data. When we execute a delayed task, the `getDelay()` method returns the
    delay of the original task; however, in the case of a periodic task, the `getDelay()`
    method returns the difference between the `startDate` attribute and the actual
    date.
  prefs: []
  type: TYPE_NORMAL
- en: The `run()` method is the one that executes the task. One particularity of periodic
    tasks is that you have to put the next execution of the task in the queue of the
    executor as a new task if you want the task to be executed again. So, if you're
    executing a periodic task, you establish the `startDate` attribute value and add
    it to the actual date and period of the execution of the task and store the task
    again in the queue of the executor. The `startDate` attribute stores the date
    when the next execution of the task will begin. Then, you execute the task using
    the `runAndReset()` method provided by the `FutureTask` class. In the case of
    delayed tasks, you don't have to put them in the queue of the executor because
    they can only be executed once.
  prefs: []
  type: TYPE_NORMAL
- en: You also have to take into account whether the executor has been shut down.
    If yes, you don't have to store the periodic tasks in the queue of the executor
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you overrode the `scheduleAtFixedRate()` method in the `MyScheduledThreadPoolExecutor`
    class. We mentioned earlier that for periodic tasks, you establish the value of
    the `startDate` attribute using the period of the task, but you haven't initialized
    that period yet. You have to override this method that receives this period as
    a parameter; do this to pass it to the `MyScheduledTask` class so it can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example is complete with the `Task` class that implements the `Runnable`
    interface, and it is the task executed in the scheduled executor. The main class
    of the example creates a `MyScheduledThreadPoolExecutor` executor and sends the
    following two tasks to them:'
  prefs: []
  type: TYPE_NORMAL
- en: A delayed task, which is to be executed 1 second after the actual date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A periodic task, which is to be executed for the first time a second after the
    actual date and then every 3 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the execution of this example. You can
    check whether the two kinds of tasks are executed properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScheduledThreadPoolExecutor` class provides another version of the `decorateTask()`
    method that receives a `Callable` object as a parameter, instead of a `Runnable`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running a task in an executor after a delay* and *Running a task in an
    executor periodically* recipes in [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads for the
    fork/join framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting features of Java 9 is the fork/join framework. It's
    an implementation of the `Executor` and `ExecutorService` interfaces that allows
    you to execute the `Callable` and `Runnable` tasks without managing the threads
    that execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This executor is oriented to execute tasks that can be divided into smaller
    parts. Its main components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a special kind of task, which is implemented by the `ForkJoinTask` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides two operations for dividing a task into subtasks (the fork operation)
    and to wait for the finalization of these subtasks (the join operation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's an algorithm, denominating the work-stealing algorithm, that optimizes
    the use of the threads of the pool. When a task waits for its subtasks, the thread
    that was executing it is used to execute another thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main class of the fork/join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ForkJoinWorkerThread` adds new methods to the `Thread` class, such as the
    `onStart()` method that's executed when the thread is created and the `onTermination()`
    method that's called to clean up the resources used by the thread. The `ForkJoinPool`
    class uses an implementation of the `ForkJoinWorkerThreadFactory` interface to
    create the worker threads it uses.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement a customized worker thread to
    be used in a `ForkJoinPool` class and how to use it with a factory extending the
    `ForkJoinPool` class and implementing the `ForkJoinWorkerThreadFactory` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyWorkerThread` that extends the `ForkJoinWorkerThread`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare and create a private `ThreadLocal` attribute parameterized by the `Integer`
    class named `taskCounter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onStart()` method. Call the method on its parent class, print
    a message to the console, and set the value of the `taskCounter` attribute of
    this thread to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onTermination()` method. Write the value of the `taskCounter`
    attribute of this thread in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `addTask()` method. Increment the value of the `taskCounter`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface. Implement the `newThread()` method. Create and return a `MyWorkerThread`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyRecursiveTask` that extends the `RecursiveTask` class
    parameterized by the `Integer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` array named `array`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes named `start` and `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method to sum all the elements of the array between
    the start and end positions. First, convert the thread that is executing the task
    into a `MyWorkerThread` object and use the `addTask()` method to increment the
    counter of tasks for that thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'If the difference between the start and end positions in the array is higher
    than 100 elements, we calculate the position in the middle and create two new
    `MyRecursiveTask` tasks to process the first and second halves, respectively.
    If the difference is equal to or lower than 100, we calculate the sum of all the
    elements between the start and end positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 10 milliseconds and return the result of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `addResults()` method. Calculate and return the sum of the results
    of the two tasks received as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyWorkerThreadFactory` object named `factory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object named `pool`. Pass the `factory` object, created
    earlier, to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of 100,000 integers. Initialize all the elements to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `task` object to sum all the elements of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the task to the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the end of the task using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the pool using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the result of the task in the console, using the `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the end of the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads used by the fork/join framework are called worker threads. Java includes
    the `ForkJoinWorkerThread` class that extends the `Thread` class and implements
    the worker threads used by the fork/join framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyWorkerThread` class that extends the
    `ForkJoinWorkerThread` class and overrides two methods of the `ForkJoinWorkerThread`
    class. Your objective is to implement a counter of tasks in each worker thread
    so that you can know how many tasks a worker thread has executed. You implemented
    the counter with a `ThreadLocal` attribute. This way, each thread will have its
    own counter in a transparent way for you, the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: You overrode the `onStart()` method of the `ForkJoinWorkerThread` class to initialize
    the task counter. This method is called when the worker thread begins its execution.
    You also overrode the `onTermination()` method to print the value of the task
    counter to the console. This method is called when the worker thread finishes
    its execution. In addition, you implemented a method in the `MyWorkerThread` class.
    The `addTask()` method increments the task counter of each thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class, like with all the executors in the Java Concurrency
    API, creates its threads using a factory. So, if you want to use the `MyWorkerThread`
    thread in a `ForkJoinPool` class, you have to implement your thread factory. For
    the fork/join framework, this factory has to implement the `ForkJoinPool.ForkJoinWorkerThreadFactory`
    class. You implemented the `MyWorkerThreadFactory` class for this purpose. This
    class only has one method that creates a new `MyWorkerThread` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you only have to initialize a `ForkJoinPool` class with the factory
    you have created. You did this in the `Main` class, using the constructor of the
    `ForkJoinPool` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the `ForkJoinPool` object has executed four worker threads and
    how many tasks have executed each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take into account that the `onTermination()` method provided by the `ForkJoinWorkerThread`
    class is called when a thread finishes normally or throws an exception. The method
    receives a `Throwable` object as a parameter. If the parameter takes the null
    value, the worker thread finishes normally; however, if the parameter takes a
    value, the thread throws an exception. You have to include the necessary code
    to process this situation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating threads through a factory* recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Management*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the fork/join framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework separates task creation and its execution. With it,
    you only have to implement the `Runnable` objects and use an `Executor` object.
    You just need to send the `Runnable` tasks to the executor and it creates, manages,
    and finalizes the necessary threads to execute these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 provides a special kind of executor in the fork/join framework (introduced
    in Java 7). This framework is designed to solve problems that can be broken down
    into smaller tasks using the divide and conquer technique. Inside a task, you
    have to check the size of the problem you want to resolve; if it's bigger than
    the established size, you divide the problem into two or more tasks and execute
    them using the framework. If the size of the problem is smaller than the established
    size, you resolve the problem directly in the task; optionally, it returns a result.
    The fork/join framework implements the work-stealing algorithm that improves the
    overall performance of these kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` class of the fork/join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the tasks executed by a `ForkJoinPool` class are objects of the
    `ForkJoinTask` class. You can also send the `Runnable` and `Callable` objects
    to a `ForkJoinPool` class, but they can''t take advantage of all the benefits
    of the fork/join framework. Normally, you will send one of two subclasses of the
    `ForkJoinTask` class to the `ForkJoinPool` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecursiveAction`: If your tasks don''t return a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecursiveTask`: If your tasks return a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own tasks for the fork/join
    framework by implementing a task that extends the `ForkJoinTask` class. The task
    you're going to implement measures and writes its execution time in the console
    so you can control its evolution. You can also implement your own fork/join task
    to write log information, to get resources used in the tasks, or to postprocess
    the results of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyWorkerTask` and specify that it extends the `ForkJoinTask`
    class parameterized by the `Void` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name` to store the name of the
    task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getRawResult()` method. This is one of the abstract methods
    of the `ForkJoinTask` class. As the `MyWorkerTask` tasks won''t return any results,
    this method must return null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `setRawResult()` method. This is another abstract method of the
    `ForkJoinTask` class. As the `MyWorkerTask` tasks won''t return any results, leave
    the body of this method empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `exec()` method. This is the `main` method of the task. In this
    case, delegate the logic of the task to the `compute()` method. Calculate the
    execution time of this method and write it in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getName()` method to return the name of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the abstract method `compute()`. As mentioned earlier, this method
    will implement the logic of the tasks, and it must be implemented by the child
    classes of the `MyWorkerTask` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` that extends the `MyWorkerTask` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private array of `int` values named `array`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class that initializes its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method. This method increments the block of elements
    of the array determined by the start and end attributes. If this block of elements
    has more than 100 elements, divide the block into two parts and create two `Task`
    objects to process each part. Send these tasks to the pool using the `invokeAll()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'If the block of elements has less than 100 elements, increment all the elements
    using a `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, put the thread that is executing the task to sleep for 50 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the main class of the example by creating a class named `Main`
    with a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `int` array of 10,000 elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object named `pool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object to increment all the elements of the array. The parameter
    of the constructor is given `Task` as the name of the task, the array object,
    and the values 0 and 10000 to indicate to this task that it has to process the
    entire array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the task to the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the `pool` using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyWorkerTask` class that extends the `ForkJoinTask`
    class. It's your own base class to implement tasks that can be executed in a `ForkJoinPool`
    executor and that can take advantage of all the benefits of the executor, as it's
    a work-stealing algorithm. This class is equivalent to the `RecursiveAction` and
    `RecursiveTask` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you extend the `ForkJoinTask` class, you have to implement the following
    three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setRawResult()`: This method is used to establish the result of the task.
    As your tasks don''t return any results, leave this method empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRawResult()`: This method is used to return the result of the task. As
    your tasks don''t return any results, this method returns null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec()`: This method implements the logic of the task. In this case, you delegated
    the logic to the abstract `compute()` method (as the `RecursiveAction` and `RecursiveTask`
    classes). However, in the `exec()` method, you measure the execution time of the
    method, writing it in the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the main class of the example, you created an array of 10,000 elements,
    a `ForkJoinPool` executor, and a `Task` object to process the whole array. Execute
    the program and you'll see how the different tasks that are executed write their
    execution time in the console.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom Lock class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Locks are one of the basic synchronization mechanisms provided by the Java
    Concurrency API. They allow programmers to protect a critical section of code
    so only one thread can execute that block of code at a time. It provides the following
    two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lock()`: You call this operation when you want to access a critical section.
    If there is another thread running this critical section, other threads are blocked
    until they''re woken up by the lock to get access to the critical section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock()`: You call this operation at the end of a critical section to allow
    other threads to access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Java Concurrency API, locks are declared in the `Lock` interface and
    implemented in some classes, for example, the `ReentrantLock` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own `Lock` object by implementing
    a class that implements the `Lock` interface, which can be used to protect a critical
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyAbstractQueuedSynchronizer` that extends the `AbstractQueuedSynchronizer`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicInteger` attribute named `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryAcquire()` method. This method tries to change the value
    of the state variable from zero to one. If it can, it returns the `true` value;
    else, it returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryRelease()` method. This method tries to change the value
    of the state variable from one to zero. If it can, it returns `true`; else, it
    returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyLock` and specify that it implements the `Lock` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AbstractQueuedSynchronizer` attribute named `sync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize the `sync` attribute with
    a new `MyAbstractQueueSynchronizer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `lock()` method. Call the `acquire()` method of the `sync` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `lockInterruptibly()` method. Call the `acquireInterruptibly()`
    method of the sync object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryLock()` method. Call the `tryAcquireNanos()` method of the
    `sync` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement another version of the `tryLock()` method with two parameters: a
    long parameter named time and a `TimeUnit` parameter named unit. Call the `tryAcquireNanos()`
    method of the sync object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `unlock()` method. Call the `release()` method of the `sync`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `newCondition()` method. Create a new object of the internal
    class of the `sync` object, namely `ConditionObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `MyLock` attribute named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the class. Acquire the `lock`, put the thread
    to sleep for 2 seconds, and then release the lock object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyLock` object named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and execute 10 `Task` tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to get the lock using the `tryLock()` method. Wait for a second, and if
    you don''t get the lock, write a message and try again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating that you got the lock and release it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java Concurrency API provides a class that can be used to implement synchronization
    mechanisms with features of locks or semaphores. It''s called `AbstractQueuedSynchronizer`,
    and as the name suggests, it''s an abstract class. It provides operations to control
    access to a critical section and manage a queue of threads that are blocked and
    are awaiting access to the section. The operations are based on two abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method is called to try and get access to a critical section.
    If the thread that calls it can access the critical section, the method returns
    the `true` value. Otherwise, it returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryRelease()`: This method is called to try and release access to a critical
    section. If the thread that calls it can release access, the method returns the
    `true` value. Else, it returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these methods, you have to implement the mechanism you use to control access
    to a critical section. In this case, you implemented the `MyAbstractQueuedSynchonizer`
    class that extends the `AbstractQueuedSyncrhonizer` class and implements the abstract
    methods using an `AtomicInteger` variable to control access to the critical section.
    This variable will store the value `0` if the lock is free, so a thread can have
    access to the critical section, and the value `1` if the lock is blocked, so a
    thread 'doesn't have access to the critical section.
  prefs: []
  type: TYPE_NORMAL
- en: You used the `compareAndSet()` method provided by the `AtomicInteger` class
    that tries to change the value you specify as the first parameter with the value
    you specify as the second parameter. To implement the `tryAcquire()` method, you
    try to change the value of the atomic variable from zero to one. Similarly, to
    implement the `tryRelease()` method, you try to change the value of the atomic
    variable from one to zero.
  prefs: []
  type: TYPE_NORMAL
- en: You have to implement `AtomicInteger` class because other implementations of
    the `AbstractQueuedSynchronizer` class (for example, the one used by `ReentrantLock`)
    are implemented as private classes internally. This is carried out in the class
    that uses it, so you don't have access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you implemented the `MyLock` class. This class implements the `Lock` interface
    and has a `MyQueuedSynchronizer` object as an attribute. To implement all the
    methods of the `Lock` interface, you used methods of the `MyQueuedSynchronizer`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implemented the `Task` class that implements the `Runnable` interface
    and uses a `MyLock` object to get access to the critical section. This critical
    section puts the thread to sleep for 2 seconds. The `main` class creates a `MyLock`
    object and runs 10 `Task` objects that share the lock. The `main` class also tries
    to get access to the lock using the `tryLock()` method.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the example, you can see how only one thread has access to
    the critical section, and when that thread finishes, another one gets access to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your own `Lock` interface to write log messages about its utilization,
    control the time that it's locked, or implement advanced synchronization mechanisms
    to control, for example, access to a resource so that it's only available at certain
    times.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AbstractQueuedSynchronizer` class provides two methods that can be used
    to manage the state of the lock. They are the `getState()` and `setState()` methods.
    These methods receive and return an integer value with the state of the lock.
    You could have used them instead of the `AtomicInteger` attribute to store the
    state of the lock.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Concurrency API provides another class to implement synchronization
    mechanisms. It's the `AbstractQueuedLongSynchronizer` class, which is equivalent
    to `AbstractQueuedSynchronizer` but uses a long attribute to store the state of
    the threads.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with locks* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer queue-based on priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java 9 API provides several data structures to work with concurrent applications.
    From these, we want to highlight the following two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedTransferQueue`: This data structure is supposed to be used in programs
    that have a producer/consumer structure. In such applications, you have one or
    more producers of data and one or more consumers of data, and a data structure
    is shared by all of them. Producers put data in the data structure and consumers
    take it from there. If the data structure is empty, consumers are blocked until
    they have data to consume. If it is full, producers are blocked until they have
    space to put data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue`: In this data structure, elements are stored in an
    ordered way. They have to implement the `Comparable` interface with the `compareTo()`
    method. When you insert an element in the structure, it''s compared to the elements
    of the structure until it finds its position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of `LinkedTransferQueue` are stored in the same order as they arrive,
    so the ones that arrived earlier are consumed first. It may be the case when you
    want to develop a producer/consumer program, where data is consumed according
    to some priority instead of arrival time. In this recipe, you will learn how to
    implement a data structure to be used in the producer/consumer problem whose elements
    will be ordered by priority; elements with higher priority will be consumed first.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyPriorityTransferQueue` that extends the `PriorityBlockingQueue`
    class and implements the `TransferQueue` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicInteger` attribute named `counter` to store the number
    of consumers that are waiting to consume elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `LinkedBlockingQueue` attribute named `transferred`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ReentrantLock` attribute named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryTransfer()` method. This method tries to send the element
    to a waiting consumer immediately, if possible. If there isn''t any consumer waiting,
    the method returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `transfer()` method. This method tries to send the element to
    a waiting consumer immediately, if possible. If there is no consumer waiting,
    the method stores the element in a special queue to be sent to the first consumer
    that tries to get an element and blocks the thread until the element is consumed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryTransfer()` method that receives three parameters: the element,
    the time to wait for a consumer if there is none, and the unit of time used to
    specify the wait. If there is a consumer waiting, it sends the element immediately.
    Otherwise, it converts the time specified into milliseconds and uses the `wait()`
    method to put the thread to sleep. When the consumer takes the element, if the
    thread is sleeping in the `wait()` method, you need to wake it up using the `notify()`
    method, as you''ll see in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `hasWaitingConsumer()` method. Use the value of the counter attribute
    to calculate the return value of this method. If the counter has a value that
    is bigger than zero, it returns `true`; else, it returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getWaitingConsumerCount()` method. Return the value of the `counter`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `take()` method. This method is called by the consumers when
    they want to consume an element. First, get the lock defined earlier and increment
    the number of waiting consumers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'If there aren''t any elements in the transferred queue, free the lock and try
    to get an element from the queue using the `take()` element and get the lock again.
    If there aren''t any elements in the queue, this method will put the thread to
    sleep until there are elements to consume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, take the element from the transferred queue and wake up the thread
    that is waiting to consume that element, if there is one. Take into account that
    you are synchronizing an object coming to this class from the outside. You have
    to guarantee that the object wouldn''t be used for locking in other parts of the
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, decrement the counter of waiting consumers and free the lock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement a class named `Event` that extends the `Comparable` interface
    parameterized by the `Event` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `thread` to store the name of the
    thread that creates the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `priority` to store the priority of
    the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to return the value of the `thread` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method to return the value of the `priority` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compareTo()` method. This method compares the actual event with
    the event received as a parameter. Return `-1` if the actual event has a higher
    priority than the parameter, `1` if the actual event has a lower priority than
    the parameter, and `0` if both the events have the same priority. You will get
    the list ordered by priority in descending order. Events with a higher priority
    will be stored first in the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `Producer` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `MyPriorityTransferQueue` attribute parameterized by the
    `Event` class named `buffer` to store the events generated by this producer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the class. Create 100 `Event` objects using
    its order of creation as priority (the latest event will have the highest priority)
    and insert them into the queue using the `put()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `Consumer` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `MyPriorityTransferQueue` attribute parameterized by the
    `Event` class named `buffer` to get the events consumed by this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It consumes 1,002 events (all the events generated
    in the example) using the `take()` method and writes the number of threads that
    generated the event and their priority in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyPriorityTransferQueue` object named `buffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Producer` task and launch 10 threads to execute this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch a `Consumer` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the actual consumer count in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer an event to the consumer using the `transfer()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the producers using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 1 second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the actual consumer count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer another event using the `transfer()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the consumer using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented the `MyPriorityTransferQueue` data structure.
    It's a data structure to be used in the producer/consumer problem, but its elements
    are ordered by priority, not by their order of arrival. As Java doesn't allow
    multiple inheritances, the first decision you took was in relation to the base
    class of the `MyPriorityTransferQueue` class. You extend the class to use the
    operations implemented in the `PriorityBlockingQueue,` not to implement them.
    You also implemented the `TransferQueue` interface to add the methods related
    to the producer/consumer. We made this choice because we think it is easier to
    implement the methods of the `TransferQueue` interface than the methods implemented
    in the `PriorityBlockingQueue` class. However, you can implement the class that
    extends from the `LinkedTransferQueue` class and implements the necessary methods
    to get your own version of the `PriorityBlockingQueue` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MyPriortyTransferQueue` class has the following three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AtomicInteger` attribute named `counter`: This attribute stores the number
    of consumers that are waiting to take an element from the data structure. When
    a consumer calls the `take()` operation to take an element from the data structure,
    the counter is incremented. When the consumer finishes the execution of the `take()`
    operation, the counter is decremented again. This counter is used in the implementation
    of the `hasWaitingConsumer()` and `getWaitingConsumerCount()` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `ReentrantLock` attribute named `lock`: This attribute is used to control
    access to implemented operations. Only one thread is allowed to work with the
    data structure, as per this attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it has a `LinkedBlockingQueue` list to store transferred elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You implemented some methods in `MyPriorityTransferQueue`. All the methods
    are declared in the `TransferQueue` interface, and the `take()` method is implemented
    in the `PriorityBlockingQueue` interface. Both of these were described earlier.
    Here is a description of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tryTransfer(E e)`: This method tries to send an element directly to a consumer.
    If there is a consumer waiting, it stores the element in the priority queue to
    be consumed immediately by the consumer and then returns the `true` value. If
    no one''s waiting, it returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer(E e)`: This method transfers an element directly to a consumer. If
    there is a consumer waiting, it stores the element in the priority queue to be
    consumed immediately by the consumer. Otherwise, the element is stored in the
    list of transferred elements, and the thread is blocked until the element is consumed.
    While the thread is put to sleep, you have to free the lock because, if you don''t
    do this, you will block the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryTransfer(E e, long timeout, TimeUnit unit)`: This method is similar to
    the `transfer()` method, but here, the thread blocks the period of time determined
    by its parameters. While the thread is put to sleep, you have to free the lock
    because, if you don''t, you will block the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns the next element to be consumed. If there are
    elements in the list of transferred elements, the element is taken from the list.
    Otherwise, it is taken from the priority queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you implemented the data structure, you implemented the `Event` class.
    It is the class of the elements you have stored in the data structure. The `Event`
    class has two attributes to store the ID of the producer and the priority of the
    event, and it implements the `Comparable` interface because it is a requirement
    of your data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you implemented the `Producer` and `Consumer` classes. In the example,
    you had 10 producers and a consumer and they shared the same buffer. Each producer
    generated 100 events with incremental priority, so the events with a higher priority
    were the last generated ones.
  prefs: []
  type: TYPE_NORMAL
- en: The main class of the example created a `MyPriorityTransferQueue` object, 10
    producers, and a consumer, and used the `transfer()` method of the `MyPriorityTransferQueue`
    buffer to transfer two events to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how events with a higher priority are consumed first and that a
    consumer consumes the transferred event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe queue ordered by priority* and *Using blocking
    thread-safe deques* recipes in [Chapter 7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736),
    *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic variables were introduced in Java version 5; they provide atomic operations
    on single variables. When a thread does an operation with an atomic variable,
    the implementation of the class includes a mechanism to check that the operation
    is done atomically.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to extend an atomic object and implement
    two operations that follow the mechanisms of the atomic objects to guarantee that
    all the operations are done in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ParkingCounter` and specify that it extends the `AtomicInteger`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `maxNumber` to store the maximum number
    of cars admitted into the parking lot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `carIn()` method. This method increments the counter of cars
    if it has a value smaller than the established maximum value. Construct an infinite
    loop and get the value of the internal counter using the `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is equal to the `maxNumber` attribute, the counter can''t be incremented
    (the parking lot is full and the car can''t enter). In this case, the method returns
    the `false` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, increment the value and use the `compareAndSet()` method to change
    the old value with the new one. This method returns the `false` value; the counter
    was not incremented, so you have to begin the loop again. If it returns `true`,
    it means the change was made and then you return the `true` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `carOut()` method. This method decrements the counter of cars
    if it has a value bigger than `0`. Construct an infinite loop and get the value
    of the internal counter using the `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Sensor1` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ParkingCounter` attribute named `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Call the `carIn()` and `carOut()` operations
    several times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Sensor2` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ParkingCounter` attribute named `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Call the `carIn()` and `carOut()` operations
    several times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ParkingCounter` object named `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch a `Sensor1` and `Sensor2` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of both the tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the actual value of the counter in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message indicating the end of the program in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParkingCounter` class extends the `AtomicInteger` class with two atomic
    operations: `carIn()` and `carOut()`. The example simulates a system that controls
    the number of cars inside a parking lot. The parking lot can admit a number of
    cars, represented by the `maxNumber` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `carIn()` operation compares the actual number of cars in the parking lot
    with the maximum value. If they are equal, the car can''t enter the parking lot
    and the method returns the `false` value. Otherwise, it uses the following structure
    of the atomic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the value of the atomic object in a local variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the new value in a different variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `compareAndSet()` method to try and replace the old value with the new
    one. If this method returns `true`, it means the old value you sent as a parameter
    was the value of the variable; therefore, it changes the values. The operation
    was made in an atomic way as the `carIn()` method returns `true`. If the `compareAndSet()`
    method returns `false`, it means the old value you sent as a parameter is not
    the value of the variable (the other thread modified it); therefore, the operation
    can't be done in an atomic way. The operation begins again until it can be done
    in an atomic way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `carOut()` method is analogous to the `carIn()` method. You also implemented
    two `Runnable` objects that use the `carIn()` and `carOut()` methods to simulate
    the activity of parking. When you execute the program, you can see that the parking
    lot never exceeds the maximum value of cars.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in [Chapter 7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736),
    *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own stream generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream is a sequence of data that allows you to apply a sequence of operations
    (usually represented with lambda expressions) to it in a sequential or parallel
    way in order to filter, transform, sort, reduce, or construct a new data structure.
    It was introduced in Java 8 and was one of the most important features introduced
    in that version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are based on the `Stream` interface and some related classes and interfaces
    included in the `java.util.stream` package. They have also provoked the introduction
    of new methods in a lot of classes to generate streams from different data structures.
    You can create a `Stream` interface from every data structure that implements
    the `Collection` interface: from `File`, `Directory`, `Array`, and a lot of other
    sources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also included different mechanisms to create streams from your own sources.
    The most important ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Supplier` interface: This interface defines the `get()` method. It will
    be called by `Stream` when it needs to process another object. You can create
    `Stream` from a `Supplier` interface using the `generate()` static method of the
    `Stream` class. Take into account that this source is potentially infinite, so
    you must use a method such as `limit()` or similar to limit the number of elements
    in `Stream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Stream.Builder` interface: This interface provides the `accept()` and
    `add()` elements to add elements to `Stream` and the `build()` method, which returns
    the `Stream` interface created with the elements added before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Spliterator` interface: This interface defines the necessary methods to
    traverse and split the elements of a source. You can use the `stream()` method
    of the `StreamSupport` class to generate the `Stream` interface to process the
    elements of `Spliterator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement your own `Spliterator` interface
    and how to create a `Stream` interface to process its data. We will work with
    a matrix of elements. A normal `Stream` interface should process one element at
    a time, but we will use the `Spliterator` class to implement one row at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Item` to store the information of each element of the
    matrix. It will have three private attributes: a `String` attribute named `name`
    and two integer attributes named `row` and `column`. Create the methods to get
    and set the values of these attributes. The code of this class is very simple,
    so it won''t be included here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `MySpliterator`. Specify that it implements the `Spliterator`
    interface parameterized by the `Item` class. This class has four attributes: a
    matrix of `Item` objects named `items` and three integer attributes named `start`,
    `end`, and `current` to store the first and last elements that will be processed
    by this `Spliterator` interface and the current element that is being processed.
    Implement the constructor of the class to initialize all these attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `characteristics()`. This method will return an `int` value that
    describes the behavior of `Spliterator`. The meaning of this value will be explained
    later in the *How it Works...* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `estimatedSize()`. This method will return the number of elements
    to be processed by this `Spliterator`. We will calculate it as the difference
    between the end and current attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement `tryAdvance()`. This method will be called to try and process
    an element of the `Spliterator`. The input parameter of the `tryAdvance()` method
    is and object that implements the `Consumer` interface. It will be called by the
    Stream API, so we only have to worry about its implementation. In our case, as
    mentioned in the introduction to this chapter, we have a matrix of `Item` objects
    and we''re going to process a row each time. The `Consumer` function received
    will process an `Item` object. Therefore, if the `Spliterator` interface still
    has elements to process, we will process all the items of the current row using
    the `accept()` method of the `Consumer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement `forEachRemaining()`. This method will receive an implementation
    of the `Consumer` interface and will apply this function to the remaining elements
    of `Spliterator`. In our case, we will call the `tryAdvance()` method for all
    the remaining elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement `trySplit()`. This method will be called by parallel streams
    to split `Spliterator` into two subsets. It will return a new `Spliterator` object
    with the elements that will be processed by another thread. The current thread
    will process the rest of the elements. If the `spliterator` object can''t be split,
    you have to return a null value. In our case, we will calculate the element in
    the middle of the elements we have to process. The first half will be processed
    by the current thread, and the second half will be processed by another thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `Main` class of the project with the `main()` method. First,
    declare and initialize a matrix with 10 rows and 10 columns of `Item` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `MySpliterator` object to process all the elements of the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the `stream()` method of the `StreamSupport` class to create a
    stream from `Spliterator`. Pass the `true` value as the second parameter to indicate
    that our stream will be in parallel. Then, use the `forEach()` method of the `Stream`
    class to write information about each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main element of this example is `Spliterator`. This interface defines methods
    that can be used to process and partition a source of elements to be used, for
    example, the source of a `Stream` object. You will rarely need to use a `Spliterator`
    object directly. Only if you want a different behavior--that is, if you want to
    implement your own data structure and create `Stream` from it--use a `Spliterator`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '`Spliterator` has a set of characteristics that defines its behavior. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONCURRENT`: The data source can be safely modified concurrently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT`: All the elements of the data source are distinct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMMUTABLE`: Elements can be added, deleted, or replaced in the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NONNULL`: There''s no null element in the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDERED`: There''s an encounter ordered in the elements of the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIZED`: The value returned by the `estimateSize()` method is the exact size
    of the `Spliterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SORTED`: The elements of `Spliterator` are sorted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUBSIZED`: After you call the `trySplit()` method, you can obtain the exact
    size of both the parts of `Spliterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we defined `Spliterator` with the `DISTINCT`, `IMMUTABLE`, `NONNULL`,
    `ORDERED`, `SIZED`, and `SUBSIZED` characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implemented all the methods defined by the `Spliterator` interface
    that don''t have a default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`characteristics()`: This method returns the characteristics of the `Spliterator`
    object. Specifically, it returns an integer value you calculate using the bitwise
    `or` operator (`|`) between the individual characteristics of your `Spliterator`
    object. Take into account that the value returned should be consistent with the
    real characteristics of your `Spliterator` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`estimatedSize()`: This method returns the number of elements that would be
    processed by the `forEachRemaining()` method if it were called at the current
    moment. In our case, we returned the exact value as we know it, but the definition
    of the method talks about the estimated size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAdvance()`: This method applies the function specified as a parameter to
    the next element to be processed, if there''s one, and returns true. If there''s
    no element to process, it will return false. In our case, this method received
    a `Consumer` that processed an Item object, but we processed a row of Item objects
    at a time. So we traversed all the items of the row and called the `accept()`
    method of `Consumer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trySplit()`: This method is used to divide the current `Spliterator` into
    two different parts so each one can be processed by different threads. In an ideal
    case, you should divide the data source into two halves with the same number of
    elements. But, in our case, we calculated the element in the middle between the
    start and end index and generated two blocks of elements. The start to the mid
    element part was processed by the current `Spliterator`, and the mid to the end
    element part was processed by the new `Spliterator` object. If you can''t split
    the data source, this method returns a null value. In our case, the `Spliterator`
    had only two elements, so it won''t be split.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other methods of the `Spliterator` interface have a default implementation,
    but we overrode the `forEachRemaining()` method. This method applies the function
    received as a parameter (an implementation of the `Consumer` interface) to the
    elements of the `Spliterator` that haven't been processed yet. We implemented
    our own version to write a message in the console. We used the `tryAdvance()`
    method to process each individual item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, the `trySplit()` method is called to divide the data source, then the
    `forEachRemaining()` method is called to process all the elements of each `Spliterator`
    generated by the `trySplit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can obtain an implementation of the `Spliterator` interface from different
    data sources. The `BaseStream` class provides the `spliterator()` method that
    returns a `Spliterator` from the elements of the `Stream`. Other data structures,
    such as `ConcurrentLinkedDeque`, `ConcurrentLinkedQueue`, or `Collection`, also
    provide the `spliterator()` method to get an implementation of that interface
    to process the elements of those data structures.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own asynchronous stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive streams ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    defines a mechanism to provide asynchronous stream processing with non-blocking
    back pressure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive streams are based on three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a publisher of information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has one or more subscribers of this information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides subscription between the publisher and a consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 has included three interfaces--`Flow.Publisher`, `Flow.Subscriber`, and
    `Flow.Subscription`--and a utility class, `SubmissionPublisher`, to allow us to
    implement reactive stream applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own reactive application
    using only three interfaces. Take into account that we will implement the expected
    behavior between the three elements. The publisher will only send elements to
    those subscribers who have requested them, and it will do this in a concurrent
    way. But you can modify this behavior easily by modifying the implementation of
    the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a class named `News`. This class implements the elements sent from
    the publisher to the subscriber. It will have two private `String` attributes,
    named `title` and `content`, and a `Date` attribute named `date`. It will also
    have the methods to get and set the values of these attributes. The source code
    of this class is very simple, so it won't be included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `Consumer` and specify that it implements the `Subscriber`
    interface parameterized by the `News` class. It will have two private attributes:
    a `Subscription` object named subscription and a `String` attribute called name.
    Implement the constructor of the class to initialize the name attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onComplete()` method. This method should be called by the publisher
    when it doesn''t send any additional elements. In our case, we only write a message
    in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onError()` method. This method should be called by the publisher
    when an error has occurred. In our case, we only write a message in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement `onNext()`. This method receives a `News` object as a parameter,
    and it should be called by the publisher when he or she sends an item to the subscriber.
    In our case, we write the value of the attributes of the `News` object in the
    console, and we use the `request()` method of the `Subscription` object to request
    an additional item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement `onSubscription()`. This method will be called by the publisher,
    and it will be the first method of `Subscriber` invoked by it. It receives the
    `Subscription` between the publisher and the subscriber. In our case, we store
    the `Subscription` object and request the first item to be processed by the subscriber
    using the `request()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `MySubscription` and specify that it implements the
    `Subscription` interface. It will have a private `Boolean` attribute named canceled
    and a private integer attribute named requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `cancel()` method provided by the `Subscription` interface to
    cancel the communication between the publisher and the subscriber. In our case,
    we set to `true` the canceled attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `request()` method provided by the `Subscription` interface.
    This method is used by the subscriber to request elements from the publisher.
    It receives as parameter the number of elements requested by the subscriber. In
    our case, we increment the value of the requested attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `isCanceled()` method to obtain the value of the canceled attribute,
    the `getRequested()` method to obtain the value of the requested attribute and
    the `decreaseRequested()` to decrease the value of the requested attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `ConsumerData`. This class will be used by the publisher
    to store the information of every subscriber. It will have a private `Consumer`
    attribute named consumer and a private `MySubscription` attribute named subscription.
    It will also have the methods to `get()` and `set()` the value of those attributes.
    The source code of this class is very simple, so it won't be included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a class named `PublisherTask` and specify that it implements the
    `Runnable` interface. It will have a private `ConsumerData` attribute named `consumerData`
    and a private `News` attribute named news. Implement a constructor to initialize
    both the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It will get the `MySubscription` object of the
    `ConsumerData` attribute. If the subscription is not canceled and it has requested
    elements (the value of the attribute is bigger than 0), we send the `News` object
    to the subscriber using its `onNext()` method and then decrement the value of
    the requested attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement a class named `MyPublisher` and specify that it implements
    the `Publisher` interface parameterized by the `News` class. It will store a private
    `ConcurrentLinkedDeque` of `ConsumerData` objects and a `ThreadPoolExecutor` object
    named `executor`. Implement the constructor of the class to initialize both the
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement `subscribe()`. This method will receive a `Subscriber` object
    that wants to receive the items of this publisher in the form of a parameter.
    We create `MySubscription` and `ConsumerData` objects, store `ConsumerData` in
    `ConcurrentLinkedDeque`, and call the `onSubscribe()` method of the subscriber
    to send the subscription object to the `Subscriber` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `publish()` method. This method receives a `News` parameter
    and sends it to the subscribers that meet the conditions explained before. To
    do this, we create a `PublisherTask` method per `Subscriber` and send these tasks
    to the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the `Main` class of the example with its `main()` method.
    We create a publisher and two subscribers and subscribe them to the publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `News` object, send it to the publisher, sleep the main thread
    for a second, create another `News` object, and send it to the publisher again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we implemented a reactive streams communication between a publisher
    and a subscriber using the interfaces provided by the Java 9 API and just followed
    the expected behavior defined in the reactive streams' specification.
  prefs: []
  type: TYPE_NORMAL
- en: We had a publisher implemented by the `MyPublisher` class and subscribers implemented
    by the `Consumer` class. There are subscriptions between the publishers, and each
    subscriber is implemented by the `MySubscription` object.
  prefs: []
  type: TYPE_NORMAL
- en: The cycle of the communication starts when a subscriber calls the `subscribe()`
    method of a publisher. The publisher has to create the subscription between them
    and send that subscription to the subscriber using the `onSubscribe()` method.
    The subscriber must use the `request()` method of the subscription to indicate
    that it's ready to process more elements from the publisher. When the publisher
    publishes an item, it will send it to all its subscribers who have requested elements
    from the publisher using the subscription between them.
  prefs: []
  type: TYPE_NORMAL
- en: We added all the necessary elements to guarantee this behavior in a concurrent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to create an application that uses reactive streams is to use
    the `SubsmissionPublisher` class. This class implements the `Publisher` interface
    and provides the necessary methods to use it as the publisher part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reactive programming with reactive streams* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
