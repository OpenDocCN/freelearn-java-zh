- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory Leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory leaks occur as a result of improper memory management and can directly
    impact the performance of an application. These leaks occur when memory is improperly
    deallocated or when it is allocated but becomes inaccessible. Improper memory
    management not only negatively impacts performance but can also hinder scalability,
    result in system crashes due to `OutOfMemoryError`, and ruin the user experience.
    Many developers implicitly trust Java’s garbage collector (covered in [*Chapter
    1*](B21942_01.xhtml#_idTextAnchor014)) to manage memory while their applications
    run; however, despite the garbage collector’s incredible capabilities, memory
    leaks are a persistent issue.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector is not faulty; rather, memory leaks occur when the garbage
    collector is unable to reclaim memory that stores objects that are no longer needed
    by the application. Improper referencing is the primary culprit, and fortunately,
    we can avoid this. This chapter provides techniques, design patterns, coding examples,
    and best practices to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Proper referencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listeners and loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a comprehensive understanding of
    what can lead to memory leaks at runtime and the potential devastation they can
    inflict on our Java applications, and you will know how to prevent them purposefully
    and efficiently. You can gain confidence in implementing your own memory leak
    prevention strategy by experimenting with the sample code provided.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Proper referencing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is undeniable – memory leaks can result in a gradual decrease in resource
    availability and lead to sluggish systems and potential system crashes. The good
    news is that there are two major components that offer a solution. One component
    is the garbage collector that is part of the **Java Virtual Machine** (**JVM**).
    It is highly capable and one of the shining characteristics of the Java language.
    The second, and more important, component is the developer. As Java developers,
    we have the power to minimize and even eliminate memory leaks by taking a purposeful
    approach to memory management in our code.
  prefs: []
  type: TYPE_NORMAL
- en: To support the developer component of the solution to eradicate memory leaks,
    this section will focus on how to properly reference objects so that they do not
    lead to memory leaks, how to identify memory leaks, and the strategies to avoid
    them.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most important aspect of avoiding memory leaks is to use proper
    referencing. This should be encouraged, since it puts control in the developer’s
    hands. Java offers a great toolbox to aid our efforts in this area. Specifically,
    there are several types of references, each with its own purpose and associated
    garbage collector behavior.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: In Java, references are pointers to memory locations and are a critical component
    of memory management and memory leak mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the various types of referencing in Java, strong, soft, weak,
    and phantom, so we can determine which method is the most appropriate for any
    given use case. Remember, our overall purpose is to have efficient memory management
    and avoid memory links to increase the overall performance of our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Strong references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Strong referencing** is the most important reference type for us to focus
    on. Not only is it the default reference type in Java, but it is also the most
    common source of memory leaks. Objects that have a strong reference type are not
    eligible for garbage collection. To create a strong reference, we simply use a
    variable to directly reference an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example code, we create a strong reference to an object using
    the `sampleCorgiObject` variable. As long as that variable contains a reference
    to the `SampleCorgiObject` instance, we will have that object in memory and the
    garbage collector will not be able to deallocate its memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the default reference type in Java for a reason. The typical use case
    is when we have objects that we need the entire time our application is running,
    such as configuration properties. We should use strong referencing with caution,
    especially when the objects are large. A best practice is to set our references
    to `null` as soon as they are no longer needed. This will empower the garbage
    collector to deallocate associated memory.
  prefs: []
  type: TYPE_NORMAL
- en: Soft references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`OutOfMemoryError` and system crashes. When we create soft references, those
    objects are retained in memory only when there is sufficient space. This makes
    soft referencing an ideal solution to cache large objects.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that the JVM collects these objects that have
    soft references to them only when necessary. The JVM’s garbage collector will
    collect everything else it can first and then, as a final effort, collect objects
    with soft references, and only then if the system is running out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a soft reference, we use the `SoftReference` class that is a part
    of the `java.lang-ref` package. Let’s look at an example in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our application by importing `SoftReference`. Then, we create our
    class header and initially create `MyBougieObject`, using strong referencing by
    `myBougieObject`. We then wrap it with `SoftReference<MyBougieObject>` to establish
    the soft reference. Note that we set `myBougieObject` to null, which ensures that
    our `MyBougieObject` instance is only accessible through the soft reference we
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section of code, we attempt to review `myBougieObject` from the
    soft reference. We use `System.gc()` to provide a way to observe the behavior
    of our software references under normal conditions and then simulate memory pressure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This last section implies our `MyBougieObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the output might look like. Of course, the results will depend
    on your system’s available memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Weak references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have covered **strong references** that prevent garbage collection
    and **soft references** that allow garbage collection as a last-ditch effort to
    reclaim memory. **Weak references** are unique in that they permit garbage collection
    only if the weak reference is the only reference to the specific object. This
    approach can be especially useful when we want more flexibility in our memory
    management solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use of weak references is in caching when we want objects to remain
    in memory but not prevent them from being reclaimed by JVM’s garbage collection
    when a system runs low on memory. To implement a weak reference, we use the `WeakReference`
    class that is a part of the `java.lang-ref` package. Let’s look at an example
    in code. We start our code with the necessary `import` statement and the class
    declaration. As you can see in the following code block, we wrap our `CacheCorgiObject`
    in `WeakReference`, which can initially be accessed via the weak reference. When
    we set the strong reference (`cacheCorgiObject`) to null, we call `System.gc()`
    to invoke the JVM’s garbage collector. Depending on your system’s memory, the
    object might be collected, as it is available. Following the garbage collection,
    we call `weakCacheCorgiObject.get()`, and `null` is returned if the object collection
    took place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a sample output from our program. Results will vary, depending on the
    system’s available memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Phantom references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our last type of reference is a **phantom reference**. This reference type does
    not permit direct retrieval of the referenced object; instead, it provides a method
    to determine whether the object has been finalized and reclaimed by the JVM garbage
    collector. This happens without preventing the object from being collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation requires two classes from the `java.lang.ref` package – `PhantomReference`
    and `ReferenceQueue`. Our example code demonstrates the garbage collector determining
    whether an object with a phantom reference is reachable. This means that the object
    has been **finalized** and is ready for garbage collection. When this is the case,
    the reference is queued, and our application is able to respond accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adopting the phantom reference approach enables us to invoke our own memory-cleaning
    actions, based on an object with a phantom reference’s collection. This approach
    does not interfere with the normal garbage collection operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the finalize() method
  prefs: []
  type: TYPE_NORMAL
- en: The `finalize()` method has been depreciated and is scheduled for removal from
    Java in a future release. It is used in the previous code example simply to demonstrate
    the phantom reference approach and does not suggest using `finalize()`. Consult
    the Java documentation for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed proper referencing, we should have an appreciation
    for how much developer intervention can solve the memory leak problem. Further,
    examination of the coding examples should lead to confidence in implementing proper
    referencing throughout our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important things we should implement in our Java applications
    is the ability to identify memory leaks. Our goal is to create high-performance
    Java applications, and memory leaks are counter to that goal. In order to identify
    memory leaks, we need to understand what symptoms indicate that a memory leak
    exists. These symptoms include increased garbage collection activity, `OutOfMemoryError`,
    and progressive performance degradation. Let’s look at five methods to identify
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important methods to identify memory leaks is to review our
    code to ensure that we follow best practices and avoid common pitfalls, such as
    failing to clear static collections, not removing **listeners** after use, and
    caches that grow out of control. We will cover listeners later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A second method involves using a tool that can reveal which of our application’s
    objects consumes the most memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third method is to use a tool to generate a heap dump, which is a moment-in-time
    snapshot of all objects currently in memory. This can help you analyze and detect
    potential issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When reviewing object retention, look for unusual or unwanted patterns. Examples
    include when objects have a longer life cycle than expected or a large number
    of objects of a specific type that you do not expect to see large numbers of.
  prefs: []
  type: TYPE_NORMAL
- en: A fifth method to identify memory leaks is to continually and iteratively test
    and profile your application. Once you identify a memory leak, you implement a
    fix, and should then retest.
  prefs: []
  type: TYPE_NORMAL
- en: We can use tools to help us identify memory leaks, including **JProfiler**,
    **YourKit**, **Java Flight Recorder** (**JFR**), **VisualVM**, and the Eclipse
    **Memory Analyzer Tool** (**MAT**). If you want to take memory leak identification
    seriously, you should research these tools to see how you can leverage their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak avoidance strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proper object referencing, as detailed earlier in this chapter, is a primary
    strategy to avoid memory leaks in your Java applications. Identifying and fixing
    memory leaks is another strategy, albeit a reactive one. These two strategies
    are important and have already been covered. Let’s briefly look at some additional
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: A third memory leak avoidance strategy is to properly manage collection objects.
    It is not uncommon for objects to be put into collections and then ignored or
    forgotten. This can result in memory leaks. So, to avoid this, we should develop
    our applications so that they regularly remove objects that are no longer required
    by our application. Using weak references can help with this. We should also be
    careful when using static collections. This type of collection has its life cycle
    linked with the class loader.
  prefs: []
  type: TYPE_NORMAL
- en: We should also be mindful of how we implement caches. The use of caches can
    significantly improve an application’s performance but can also result in memory
    leaks. When implementing caches, we should use soft references, set finite cache
    size limits, and continuously monitor cache usage.
  prefs: []
  type: TYPE_NORMAL
- en: A fifth strategy is to continuously use a profiling tool and test your application.
    This strategy requires a never-ending dedication to detecting and removing memory
    leaks in your application. It is an important strategy that should not be taken
    lightly.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement a set of memory leak avoidance strategies, we have a better
    chance of ensuring our applications have high performance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will review how listeners and loaders can be used to help avoid memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Listeners and loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several aspects of our Java applications can impact performance and, more specifically,
    result in memory leaks. Two of those aspects are **listeners** and **loaders**.
    This section looks specifically at **event listeners** and **class loaders** and
    includes strategies to mitigate the risks of using them, without sacrificing the
    power and efficiencies they can provide to our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event listeners are used to allow objects to react to events. This approach
    is used heavily in interactive applications and is a critical component of event-driven
    programming. These listeners can result in a highly interactive application; however,
    if not properly managed, they can be the source of memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the issue better, it is important to note that event listeners
    must subscribe to event sources so that they can receive notifications that need
    to be acted upon (e.g., a button click, or a non-player character in a game entering
    a predefined zone). As you would expect, each event listener maintains references
    to the event sources they subscribe to. A problem arises when an event source
    is no longer needed but is referenced by one or more listeners; this prevents
    the garbage collector from collecting the event source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices to avoid memory leaks when working with event
    listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: Use weak references, as detailed earlier in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly deregister listeners from event sources when applicable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement static nested classes for listeners because they do not have implicit
    references to outer class instances. This approach should be used instead of implementing
    non-static inner classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align your event listener life cycles with those of their associated event sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class loaders enable us to dynamically load classes, making them a key component
    of **Java’s Runtime Environment** (**JRE**). Class loaders offer great power and
    flexibility through the support of polymorphism and extensibility. When our applications
    load classes dynamically, it illustrates that Java does not need to know about
    these classes at compile time. With this powerful flexibility comes the potential
    for memory leaks, which we need to mitigate, if not eliminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JVM has a class loading delegation model that involves several class loader
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: A **bootstrap class loader** that loads Java’s core API classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `java.ext.dirs` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `classpath`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class loaders are necessary, and when the loaded classes are retained in memory
    for longer than necessary, they can introduce memory leaks. The culprits here
    are typically with static fields in classes holding reference to objects that
    should otherwise be collected by the garbage collector, objects of loaded classes
    that are referenced by objects that have long lifespans, and a cache that retains
    class instances without proper management. Here are a few strategies to mitigate
    these risks:'
  prefs: []
  type: TYPE_NORMAL
- en: Use weak references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the use of static fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that custom class loaders are available to the garbage collection
    when no longer needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor, profile, and refine as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have a thorough understanding of loaders and listeners as well as strategies
    to mitigate their associated risks, we improve our chances of minimizing memory
    leaks in our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explores caching strategies, thread management, and the effective
    use of Java concurrency utilities. These are important concepts to embrace as
    we continue our journey of developing high-performance Java applications. We will
    explore these concepts, the associated best practices, and techniques to mitigate
    the risk of memory leaks introduced by their use.
  prefs: []
  type: TYPE_NORMAL
- en: Caching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming, we use **caching** to temporarily store data in memory locations
    to permit rapid access. This allows us to repeatedly access the data without causing
    lag or system crashes. The benefits of caching include more responsible applications
    and less load on longer-term storage solutions, such as databases and database
    servers. Of course, there are pitfalls. If we do not properly manage our caches,
    we can introduce significant memory leaks into our applications.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple caching strategies for us to consider; two of them you should
    already be familiar with, as they were covered earlier in this chapter, albeit
    not specific to caching. The first familiar strategy is to use weak references.
    When we use weak references with caching, we allow garbage collection when memory
    runs low. The second familiar strategy is using soft references. This strategy
    enables higher retention priority during garbage collection cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Another caching strategy is referred to as **Least Recently Used** (**LRU**),
    and as the name suggests, we remove the least accessed items first, as they are
    the least likely to be used by our application again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to Live** (**TTL**) is another useful caching strategy. The TTL approach
    tracks cache insertion times and automatically expires items based on a prescribed
    amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: One additional caching strategy is using **size-based eviction**. This strategy
    ensures that caches do not exceed the amount of memory you set as the maximum
    boundary. The boundary can be set in terms of memory usage or the total number
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement caching, we should be mindful of introducing memory leaks
    due to poor implementation. This purposeful approach requires us to conduct capacity
    planning, establish an eviction policy for the LRU and TTL approaches, and monitor
    our system. This monitoring requires subsequent fine-tuning and retesting.
  prefs: []
  type: TYPE_NORMAL
- en: Thread management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use **threads** in our applications to facilitate multiple concurrent operations.
    This makes better use of modern CPUs and improves the responsiveness of our Java
    applications. When we manage our threads manually, we can introduce memory leaks
    due to the complexity and error-prone nature of managing threads.
  prefs: []
  type: TYPE_NORMAL
- en: We can create threads in Java by extending the `Thread` class, or even by implementing
    the `Runnable` interface. These methods are a direct and easy way to use threads;
    however, it is not a recommended approach for large systems because they directly
    create and utilize threads, resulting in significant overhead. Instead of the
    direct approach, consider using Java’s **Executor** framework to abstract thread
    management from the main application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some best practices for thread management include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Favor Executor over direct thread creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of thread pools you use to a minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support thread interruptions in your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor and refine consistently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to demonstrate proper thread usage. We will
    use the `Executor` framework. As you will see, the following application creates
    a fixed thread pool to run a set of tasks. Each task simulates a real-world operation
    by sleeping for a defined amount of time. As you walk through the code, you will
    see that the `Executor` framework is efficiently used to manage threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sample application provides an efficient method of managing concurrency
    in a Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Java concurrency utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are fortunate that the `java.util.concurrent` package contains a set of utilities
    we can use for **concurrency**. These utilities empower us to write thread-safe
    applications that are reliable and scalable. The utilities help us address common
    pitfalls and challenges in concurrent programming, including data consistency,
    life cycle management, and synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using the concurrency utilities that are part of the `java.util.concurrent`
    package includes making our applications more reliable, making them perform at
    a higher level, and simplifying the programming effort. Let’s look at five specific
    concurrency utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Our first concurrency utility is the `Executor` framework that we previously
    covered. Looking at this framework closely reveals that there are multiple types
    of Executor services, including the `ScheduledExecutorService` interface. This
    interface can be used to introduce an execution delay. The primary interface,
    `ExecutorService`, empowers us to manage thread termination and helps us track
    our synchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '`CountDownLatch`, `CyclicBarrier`, `Exchanger`, `Phaser`, and `Semaphore`.
    If you need to improve your thread management in your Java application, these
    methods are worth reviewing in the Java documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Three additional concurrency utilities are `java.util.concurrent.atomic package`.
    Locks, available in the `java.util.concurrent.locks` package, allow us to lock
    threads and waits until a specific condition is met. Lastly, concurrent collections
    provide thread-safe collections that have full support for concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we explored caching strategies, thread management, and the effective
    use of Java concurrency utility, you should be well-equipped to continue building
    high-performance Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took a deep look at the complexities of managing memory effectively
    to help prevent memory leaks. These leaks must be avoided at all costs because
    they can degrade our systems, ruin the user experience, and even result in system
    crashes. We identified that memory leaks typically occur due to improper referencing,
    which inhibits the garbage collector’s ability to deallocate memory. We focused
    on proper referencing, listeners and loaders, and caching and threads. You should
    now be equipped and confident to implement efficient memory leak avoidance strategies
    in your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Concurrency Strategies*, we will cover the concepts of
    threads, synchronization, volatile, atomic classes, locks, and so on. We will
    leverage the thread-related content covered in this chapter to give us a head
    start as we dive deeper into concurrency. Through a hands-on approach, you can
    gain insights into concurrency in Java and adopt strategies to help make your
    Java programs highly performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Concurrency and Networking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency and networking are essential for modern Java applications, especially
    those requiring high throughput and low latency. This part introduces advanced
    concurrency strategies to manage multiple threads efficiently. It also covers
    connection pooling techniques to optimize network performance and explores the
    intricacies of hypertext transfer protocols. By understanding and applying these
    concepts, you will create highly responsive and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21942_09.xhtml#_idTextAnchor159), *Concurrency Strategies* *and
    Models*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21942_10.xhtml#_idTextAnchor172), *Connection Pooling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21942_11.xhtml#_idTextAnchor189), *Hypertext Transfer Protocols*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
