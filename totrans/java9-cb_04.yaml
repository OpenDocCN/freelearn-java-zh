- en: Going Functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces a programming paradigm called functional programming and
    its applicability in Java 9\. We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating a functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and invoking lambda-friendly APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging lambda expressions in your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming--the ability to treat a certain piece of functionality
    as an object and to pass it as a parameter or the return value of a method--is
    a feature present in many programming languages. It avoids the changing of an
    object state and mutable data. The result of a function depends only on the input
    data, no matter how many times it is called. This style makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Its introduction to Java also allows you to improve parallel programming capabilities
    in Java 8 by shifting the responsibility of parallelism from the client code to
    the library. Before this, in order to process elements of Java collections, the
    client code had to acquire an iterator from the collection and organize the processing
    of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 8, new (default) methods were added that accept a function (implementation
    of a functional interface) as a parameter and then apply it to each element of
    the collection. So, it is the library's responsibility to organize parallel processing. One
    example is the `forEach(Consumer)` method that is available in every `Iterable` interface,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate)` method
    that is available for every `Collection` interface, where `Predicate` is a functional
    interface too. Then we have the `sort(Comparator)` and `replaceAll(UnaryOperator)` methods
    that are available for `List` and several other methods, such as `compute()` for
    `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Forty-three functional interfaces are provided in the `java.util.function` package.
    Each of them contains only one abstract method. Lambda expressions take advantage
    of the one-abstract-method limitation and significantly simplifies the implementation
    of such an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Without functional programming, the only way to pass some functionality as a
    parameter in Java would be through writing a class that implements an interface,
    creating its object, and then passing it as a parameter. But even the least involved
    style--using an anonymous class--requires writing too much of code. Using functional
    interfaces and lambda expressions makes the code shorter, clearer, and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we will define and explain these new Java features--functional
    interfaces and lambda expressions--and demonstrate their applicability in code
    examples. Bringing these new features into Java makes functions first-class citizens
    of the language. But taking advantage of their power requires, for those not exposed
    to functional programming yet, a new way of thinking and organizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating these features and sharing the best practices of using them is
    the purpose of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating a functional interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about functional interfaces that are supported
    since Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any interface that has one and only one abstract method is called a functional
    interface. To help avoid a runtime error, the `@FunctionalInterface` annotation
    was introduced in Java 8 that tells the compiler about the intent. In our demo
    code in the previous chapters, we''ve already had an example of a functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of `enum` types or any implemented (default or static) methods
    does not make it a non-functional interface. Only abstract (not implemented) methods
    count. So, this is an example of a functional interface too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To recap what you have already learned about interfaces in one of the previous
    chapters, the implementation of the `getWeightPounds()` method will return `-1`
    when called by `getWeightKg()`. However, this is true only if the `getWeightPounds()`
    method is not implemented in a class. Otherwise, the class implementation will
    be used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to default and static interface methods, a functional interface
    can include any and all abstract methods of the base `java.lang.Object`. In Java,
    every object is provided with the default implementation of `java.lang.Object`
    methods, so the compiler and Java runtime ignore such abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a functional interface too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is not a functional interface, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the `Car` interface has two abstract methods: its own `getPassengersCount()`
    method and the `setSpeedModel()` method inherited from the `Vehicle` interface.
    Say, we add the `@FunctionalInterface` annotation to the `Car` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, the compiler will generate the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d457737f-7b1c-49f2-a9bc-cc493febdc0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the `@FunctionalInterface` annotation helps to not only catch errors at
    compile time, but it also secures reliable communication of the design intent.
    It helps you or other programmers remember that this interface cannot have more
    than one abstract method, which is especially important in case code exists already
    that relies on such an assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the `Runnable` and `Callable` interfaces (they existed
    in Java since its earlier versions) in Java 8 were annotated as `@FunctionalInterface` to
    make this distinction explicit and remind the users about it or those attempting
    to add another abstract method to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you create your own functional interface that you plan to use as a parameter
    for a method, consider avoiding it using one of the forty-three functional interfaces
    provided in the `java.util.function` package first. Most of them are specializations
    of the following four interfaces: `Function`, `Consumer`, `Supplier`, and `Predicate`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps you can follow to get familiar with functional
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the functional interface `Function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its Javadoc, *Accepts one argument of type T and produces result of
    type R. The functional method is apply(Object).* You can create an implementation
    of this interface using an anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Its only method, namely `apply()`, accepts the value of the type `Integer` (or
    the primitive `int`, which is going to be autoboxed) as a parameter, then multiplies
    it by `10`, and returns the value of the type `Double` (or unboxed to the primitive
    `double`) so we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c88fe54-f8a0-4f08-8bfc-36529d7aac51.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next recipe, we will introduce a lambda expression and show you how its
    usage makes the implementation much shorter. But for now, we will continue using
    an anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the functional interface `Consumer` (the name helps to remember that
    the method of this interface accepts a value but does not return anything--it
    only consumes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this interface can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accepts()` method receives the parameter value of the type `String` and
    prints it. Say, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba791e29-423b-48ed-be9e-cad408a7aa89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the functional interface `Supplier` (the name helps to remember that
    the method of this interface does not accept any value but does return something--only
    supplies):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It means that the only method of this interface is `get()`, which has no input
    parameter and returns the value of the type `T`. Based on this, we can create
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(get()` method does something and then returns the value of the type `String`,
    so we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ffd7bc3-6c96-4ee4-9f52-963e982b0a64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the functional interface `Predicate` (the name helps to remember that
    the method of this interface returns a boolean--predicates something):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Its JavaDoc states: *Represents a predicate (boolean-valued function) of one
    argument of type T. The functional method is test(Object)*. It means that the
    only method of this interface is `test(Object)` that accepts an input parameter
    of the type `T` and returns the value of the type `boolean`. Let''s create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Its `test()` method accepts a value of the type `Double` as a parameter and
    returns the value of the type `boolean` so we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/065dc324-ec5a-4355-80da-f432f7dce0c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the other 39 functional interfaces in the `java.util.function` package.
    Notice that they are variations of the four interfaces we have discussed already.
    These variations are created for the following reasons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For better performance by avoiding autoboxing and unboxing via the explicit
    usage of the `int`, `double`, or `long` primitives
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: For accepting two input parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For a shorter notation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following functional interfaces are just a few examples from the list of
    39 interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional interface `IntFunction<R>` (its only abstract method is `apply(int)`),
    accepts an `int` primitive and returns the value of the type `R`. It provides
    a shorter notation (without generics for the parameter type) and avoids autoboxing
    (by defining the `int` primitive as the parameter). Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional interface `BiFunction<T,U,R>` (the `apply(T,U)` method) accepts
    two parameters of the types `T` and `U` and returns the value of the type `R`.
    Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional interface `BinaryOperator<T>` (the `apply(T,T)` method) accepts
    two parameters of the type `T` and returns the value of the type `T`. It provides
    a shorter notation by avoiding repeating the same type three times. Here''s an
    example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional interface `IntBinaryOperator` (the `applyAsInt(int,int)` method)
    accepts two parameters of the type `int` and returns the value of the type `int` too.
    Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will see examples of the usage of such specializations in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create and pass around an implementation of any functional interface
    as you do with any object. For example, let''s write a method that creates `Function<Integer,
    Double>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Better yet, we can create a generic method that uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a434b198-33f7-4ae1-a5c2-659d7663861f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can have factory methods that create the `Function<Double, Double>` function,
    the `Consumer<String>` function, and the `Supplier<String>` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the preceding functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19d773c-2d8d-4a2f-8c58-39ce517fd946.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also have factory methods that create different versions of the `Predicate<Double>` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the preceding methods as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use them, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/413eabe8-c132-4df0-b53f-f090dff46400.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If needed, a function with more complex logic can be composed of several already
    existing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create it by passing the `multiplyBy10`, `multiplyBy30`, and `isSmallerThan20` functions
    to the factory method, which we have created before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, you''ll get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49834ab6-22fd-46a6-a0b1-305cfd0c4c13.png)'
  prefs: []
  type: TYPE_IMG
- en: The first and the third lines come from the `isSmallerThan20` function, while
    the second and fourth line come from the `compare1By10And20` and `compare1By30And20`
    functions, correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: As you see, the introduction of functional interfaces enhances Java by allowing
    passing functions as parameters. An application developer can now concentrate
    on the implementation of the function (business process) and not worry about the
    plumbing of applying it to each element of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the functional interfaces in the `java.util.function` package have
    default methods that not only enhance their functionality, but also allow you
    to chain the functions and pass the result of one as an input parameter to another.
    For example, we can use the default method `andThen(Function after)` of the `Function` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `after` function is applied to the result of this function, so naturally,
    the input type of the `after` function has to be the same or a base type of the
    result of this function. The result of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could achieve the same result using another default method of the `Function`
    interface called `compose(Function before)`, which applies the `before` function
    first before applying this function. Naturally, in this case, we would need to
    switch positions of the `multiplyBy30` function and the `subtract7`: function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Consumer` interface has the `andThen(Consumer after)` method too, so we
    can create a dialog using the `sayHappyToSee` function we have created before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/432a6e8d-bf34-480b-a221-23e999eabf3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Supplier` interface does not have default methods, while the `Predicate`
    interface has one `isEqual(Object targetRef)` static method and three default
    methods: `and(Predicate other)`, `negate()`, and `or(Predicate other)`. We will
    demonstrate the usage of the `and(Predicate other)` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a predicate, using the already created functions `isSmallerThan20`
    and `isBiggerThan18`, that checks whether the input value falls between the two
    values. But before this, we need to overload the `applyCompareAndSay()` factory
    method by adding another parameter to the signature named `message` that matches
    the new predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54b0267a-5ebe-4f00-a0ab-4b4552cc747b.png)'
  prefs: []
  type: TYPE_IMG
- en: If this coding looks a bit over-engineered and convoluted, it is true. We did
    it for demo purposes. Good news is that lambda expressions (presented in the next
    recipe) allow you to achieve the same results in a much more straightforward and
    clear way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we end this recipe, we would like to mention that functional interfaces
    of the `java.util.function` package have other helpful default methods. The one
    that stands out is the `identity()` method, which returns a function that always
    returns its input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4be0aa15-0428-46c9-bc68-984fc6c4b2fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The `identity()` method is very helpful when some procedure requires you to
    provide a certain function, but you do not want this function to modify the result.
  prefs: []
  type: TYPE_NORMAL
- en: Other default methods are mostly related to conversion and boxing and unboxing
    and extracting min and max of two parameters. We encourage you to walk through
    the API of all the functional interfaces of the `java.util.function` package and
    get a feeling of the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about lambda expressions that are supported since
    Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples in the previous recipe (that used anonymous classes for functional
    interfaces' implementation) looked bulky and felt excessively verbose. For one,
    there was no need to repeat the interface name because we had declared it already
    as the type for the object reference. Second, in the case of a functional interface (that
    had only one abstract method), there was no need to specify the method name to
    be implemented. The compiler and Java runtime can figure it out anyway. All we
    needed was to provide the new functionality. This is where a lambda expression
    comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will help you to understand lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Rewrite it using lambda expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and you''ll get the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a00634a-788a-4c8b-9c48-999ea420d64c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of a lambda expression includes the list of parameters, an arrow
    token (`->`), and a body. The list of parameters can be empty (`()`), without
    brackets (if there is only one parameter, as in our examples), or a comma-separated
    list of parameters surrounded by brackets. The body can be a single expression
    (as in our preceding code) or a statement block. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cdd87cf-be5b-48ae-8393-aa5f5fabf643.png)'
  prefs: []
  type: TYPE_IMG
- en: Braces are required only in the case of a statement block. They are optional
    in a one-line lambda expression, whether the function returns a value or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the code we wrote before using lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eaf6140-d6ac-436e-abf1-3bb7768056ee.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the results are exactly the same, but the code is much simpler and
    captures only the essence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factory method can be rewritten and simplified using lambda expressions
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We don't repeat the name of the implemented `Supplier<String>` interface anymore
    because it is specified as the return type in the method signature. And we do
    not specify the name of the implemented `test()` method either because it is the
    only method of the `Supplier` interface that has to be implemented. Writing such
    a compact and efficient code became possible because of the combination of a lambda
    expression and functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in an anonymous class, the variable created outside and used inside a lambda
    expression becomes effectively final and cannot be modified. You can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you cannot change the value of the variable `v` outside the lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot change it inside the expression as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this restriction is that a function can be passed and executed
    for different arguments in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would frustrate the original idea
    of the distributed evaluation of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One principal difference between an anonymous class and lambda expression is
    the interpretation of the `this` keyword. Inside an anonymous class, it refers
    to the instance of the anonymous class. Inside the lambda expression, `this` refers
    to the instance of the class that surrounds the expression. Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b355229c-dd29-4b91-aeef-4b48703a7312.png)'
  prefs: []
  type: TYPE_IMG
- en: The lambda expression is not an inner class and cannot be referred to by `this`.
    According to the Java specification, such an approach allows you to have more
    flexibility of implementation by treating reference `this` as coming from the
    surrounding context.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look how simpler and less convoluted the demo code becomes. We can create functions
    on the fly while passing them as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the result does not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/599e058b-51ed-40a4-bfc1-8234aa557e00.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the power and beauty of lambda expressions in combination with functional
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating a functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream
    Operations and Pipelines*
  prefs: []
  type: TYPE_NORMAL
- en: Using method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a method reference, the constructor
    reference being one of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the cases, when a one-line lambda expression consists of a reference to an
    existing method only (implemented somewhere else), it is possible to further simplify
    the notation using the method reference. The reference method can be static or
    non-static (the latter can be bound to a particular object or not) or can be a
    constructor with or without parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found.
    The two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a method reference is straightforward and can be easily illustrated by
    a few examples for each case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the static method reference. If a `Food` class has a static
    method, named `String getFavorite()`, then the lambda expression may look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Foo` class has another method, named `String getFavorite(int num)`,
    the lambda expression that uses it may look exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is in the interface that this lambda expression implements.
    It allows the compiler and Java runtime to identify the method to be used. Let''s
    look at the code. Here is the `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use its static methods as the implementation of the functional interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/243fe333-473d-483a-aebf-68e988515afd.png)'
  prefs: []
  type: TYPE_IMG
- en: Second, we have the method reference to a constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume that the `Food` class does not have an explicit constructor or
    has one without parameters. The closest to such a signature is a functional interface
    called `Supplier<Food>` because it does not take any parameter either. Let''s
    add the following to our `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/254a9d0b-de8b-4633-8769-dfa1d41c53a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding non-static method reference was bound to a particular instance
    of the `Food` class. We will come back to it and also discuss an unbound non-static
    method reference later. But, for now, we will add another constructor with one
    parameter to the `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do this, we will express it via the method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b7d338-980c-4b3f-822a-7833c90bf457.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same manner, we can add a constructor with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do this, we can express it via `BiFunction<String, String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7216db59-3d5f-49fb-943d-030db088c859.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To express a constructor that accepts more than two parameters, we can create
    a custom functional interface with any number of parameters. For example, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it for different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of this custom interface and the name of its only method can be anything
    we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Third, we have the bound and unbound non-static methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The method reference we used for the `sayFavorite()` method requires (bound
    to) the class instance. This means that we cannot change the instance of the class
    used in the function after the function is created. To demonstrate this, let''s
    create three instances of the `Food` class and three instances of the `Supplier<String>`
    interface that capture the functionality of the `sayFavorite()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, after the supplier is created, we can only call the `get()`
    method on it and cannot change the instance (of the `Food` class) to which it
    was bound (the `get()` method refers to the method of the objects `food1`, `food2`,
    or `food3`). The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cecb1b6-cc9e-4cbc-b5ab-895055fa6efa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By contrast, we can create an unbound master reference with the instance of
    the `Function<Food, String>` interface (notice that the method location is specified
    as a class name called `Food`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can use a different instance of the `Food` class for every call
    of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is why this method reference is called **unbound**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can overload the `sayFavorite()` method (in the same way we did
    it for the static method `getFavorite()`) by adding the `sayFavorite(String name)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can show that the compiler and Java runtime can still understand
    (using the signature of the specified functional interface) our intent and invoke
    the correct method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a2625f3-e5d8-4e9b-8ef1-e74acc1c38d5.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several simple but useful lambda expressions and method references
    often used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run them, the results would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ca72d7c-0e95-4351-a9ab-2ae57f7d3c14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are a few useful methods for working with arrays and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06ceb52f-9e96-4b4a-a4ed-b73c7f1a7530.png)'
  prefs: []
  type: TYPE_IMG
- en: We leave it up to you to analyze how they were created and used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating a functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream
    Operations and Pipelines*
  prefs: []
  type: TYPE_NORMAL
- en: Creating and invoking lambda-friendly APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create lambda-friendly APIs and the best
    practices of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an idea of a new API first comes up, it usually looks clean and well focused.
    Even the first implemented version often preserves the same qualities. But then
    "one-offs" and other small deviations from the main use cases become pressing,
    and the API starts to grow (and becomes increasingly complex and more difficult
    to use) as the variety of use cases increases. Life does not always comply with
    our vision of it. That's why any API designer at some point faces the question
    of how generic and flexible the API should be. A too-generic API makes it difficult
    to understand in terms of the specific business domain, while a very flexible
    API makes the implementation more complex and difficult to test, maintain, and
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces as parameters facilitate flexibility but require writing new
    code that implements them. Functional interfaces and lambda expressions allow
    the decreasing of the scope of such code to a minimum by capturing the functionality
    with almost no plumbing. The granularity of such an implementation can be as fine
    or as coarse as needed without the need to create new classes, their object factories,
    and other traditional infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is possible to push the flexibility too far and overuse the power
    of the new features to the point when it defeats the purpose by making the API
    difficult to understand and next to impossible to use. To warn about certain pitfalls
    and share the best practices of a lambda-friendly API design is the purpose of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practices of a lambda-friendly API design include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer the interfaces of the `java.util.function` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid overloading methods by the type of the functional interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `@FunctionalInterface` annotation for custom functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the functional interface as a parameter instead of creating several
    methods that are different only as per some step of the functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about the first two of the listed practices in the *Understanding
    and creating a functional interface* recipe. The advantage of using the interfaces
    of the `java.util.function` package is based on two facts. First, any standardization
    facilitates better understanding and ease of API usage. Second, it facilitates
    minimal code writing.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate these considerations, let's try to create an API and call it `GrandApi`--an
    interface that is going to be implemented in the `GrandApiImpl` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a method to our new API that allows the client to pass a function
    that calculates something. Such an arrangement allows a client to customize the
    behavior of the API as needed. This design is called a delegation pattern. It
    helps with an object composition, which we have discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we demonstrate the traditional object-oriented approach and introduce
    a `Calculator` interface that has a method that calculates something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the first method of our new interface can have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this method may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a `CalucaltorImpl` class that implements the `Calculator`
    interface and pass the object of `CalculatorImpl` to the `doSomething()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the client would want to use another `Calculator` implementation, this approach
    would require you to either create a new class or use an anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: These were the two options available for a client before Java 8\. And if the
    client is forced to use a certain `Calculator` implementation (developed by a
    third party, for example), the anonymous class could not be used; therefore, only
    one option would remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Java 8, the client can take advantage of the `Calculator` interface that
    has one abstract method only (so, it is being a functional interface). Say, a
    client is forced to use a third-party implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The client could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If they do this, they''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
  prefs: []
  type: TYPE_IMG
- en: The compiler and Java runtime match the functional interface primarily by the number
    of input parameters and the presence or absence of the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the usage of a third-party implementation is not mandatory, the client can
    use a lambda expression, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'They can alternatively use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In both these cases, they will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4b4875-90b6-4d2c-ba26-f211b37b2a25.png)'
  prefs: []
  type: TYPE_IMG
- en: However, all of these is possible only as long as the `Calculator` interface
    has only one abstract method. So, we better have the `@FunctionalInterface` annotation
    added to it, if we can. This is because the client code with lambda will break
    as soon as `Calculator` gains another abstract method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can avoid creating a custom interface if we use one of the standard
    functional interfaces from the `java.util.function` package. The matching one,
    in this case, would be `Supplier<Double>`, and we can change our first API method
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are sure that the client code with lambda will never break, and the
    client code will be much shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'It could also be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In either case, the result will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the client is forced to use the existing implementation, the code can be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It will still yield the same result for the `AnyImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is why using standard functional interfaces is highly advisable because
    it allows more flexibility and less client code writing. That said, one should
    be careful not to get into an overloading of the methods by the type of functional
    interface only. The problem is that the algorithm that identifies the method by
    its functional interface parameter often does not have much to work with, especially
    if the method invocation includes an inline lambda expression only. The algorithm
    checks the number of input parameters (arity) and the presence or absence (`void`)
    of the return value. But even this may be not enough, and the API user may have
    a serious debugging problem. Let''s look at an example and add these two methods
    to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'For a human eye, these methods have very different signatures. They are resolved
    correctly as long as the passed-in instance of a functional interface is explicitly
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the functional interface can be also specified using typecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the code that does not specify the type of the passed-in functional
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not even compile, and gives the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41807ce9-ca2b-4604-a011-eee52b892265.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for the error is that both the interfaces (`Function<Integer, Integer>`
    and `Consumer<String>`) have the same number of input parameters, while the different
    return type (`Integer` and `void` ) apparently is not enough to resolve the method
    overload in this case. So, instead of overloading the method using different functional
    interfaces, use different method names. For example, check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the best practices for constructing a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep it stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid a block statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a method reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rely on effectively final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not work around effectively final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid specifying the parameter type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid brackets for a single parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid braces and the return statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API designer should keep these guidelines in mind too because the API clients
    will probably use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping lambda expressions stateless means that the result of the function
    evaluation must depend only on the input parameters, no matter how often the expression
    is evaluated or which parameters were used for the previous call. For example,
    this would be a bug-prone code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because it yields different results every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c89a1037-79a6-44ba-96b4-c94608f85055.png)'
  prefs: []
  type: TYPE_IMG
- en: This example also covers recommendations to rely on effectively final and not
    to work around it. By specifying `final int[] arr` in the preceding example, one
    gets an illusion that the code is bulletproof while, in fact, it hides the defect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other best practices of a lambda help to keep the code clear to better express
    its main logic, which otherwise might be lost in long-winded code and a multitude
    of notations. Just compare the following lines. Here''s the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The second line is much cleaner and clearer, especially in the case of several
    parameters and complex logic in the block statement. We will see examples of block
    statements and how to avoid them in the next recipe. Any modern editor helps to
    remove unnecessary notation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging lambda expressions in your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)\uFEFF\
    , *Stream Operations and Pipelines*"
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging lambda expressions in your programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to apply a lambda expression to your code.
    We will get back to the demo application and modify it by introducing a lambda
    where it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Equipped with functional interfaces, lambda expressions, and the best practices
    of a lambda-friendly API design, we can substantially improve our speed-calculating
    application by making its design more flexible and user friendly. Let's set up
    some background, the motivation, and the infrastructure as close to a real-life
    problem as possible without making it too complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The driverless cars and related problems are on the front pages today, and
    there is a good reason to believe it is going be this way for quite some time.
    One of the tasks in this domain is the analysis and modeling of the traffic flow
    in an urban area based on real data. A lot of such data already exists and will
    continue to be collected in future. Let''s assume that we have access to such
    a database by date, time, and geographical location. Let''s also assume that the
    traffic data from this database comes in units, each capturing details about one
    vehicle and its driving conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where `VehicleType`, `RoadCondition`, and `TireCondition` are `enum`
    types we have already constructed in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of accessing traffic data may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'So the possible call could be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where `17` refers to an hour of the day (5 p.m.), and `Main1035` is
    a traffic light identification, or the call can request multiple results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Where `20` is the number of the requested units of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, such a traffic factory provides data about traffic in a particular
    location at a particular time (between 5 p.m. and 6 p.m. in our example). Each
    call to the factory yields a different result, while the list of traffic units
    describes statistically correct data (including the most probable weather conditions)
    in the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also change the interfaces of `FactoryVehicle` and `FactorySpeedModel` so
    they could build `Vehicle` and `SpeedModel` based on the `TrafficUnit` interface.
    The resulting demo code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Where method `printResult()` has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecdb20f0-5281-4fdf-80bd-bb6ac0dade0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we use the "real" data now, every run of this program produces a different
    result, based on the statistical properties of the data. In a certain location,
    a car or dry weather would appear more often at that date and time, while in another
    location, a truck or snow would be more typical.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this run, the traffic unit brought a wet road, new tires, and `Truck` with
    such an engine power and load that in 10 seconds it was able to reach the speed
    of 22 mph. The formula which we used to calculate the speed (inside an object
    of `SpeedModel`) is familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `traction` value comes from `TrafficUnit` (see its interface we just
    discussed). In the class that implements the `TrafficUnit` interface, the method
    `getTraction()` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The methods `getRoadCondition()` and `getTireCondition()` return the elements
    of the corresponding `enum` types we just described.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to improve our speed-calculating application using the new
    features of Java we discussed in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building an API. We will call it `Traffic`. Without using functional
    interfaces, it might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write sample code that uses this interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We get results similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d60df2-8a6c-4572-a6de-5d40af385cff.png)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned before, since we are using real data, the same code does not produce
    exactly the same result every time. One should not expect to see the speed values
    as in the preceding screenshot but something that looks very similar instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a lambda expression. The preceding API is quite limited. For example,
    it does not allow you to test different speed calculation formulas without changing
    `FactorySpeedModel`. Meanwhile, the `SpeedModel` interface has only one abstract
    method called `getSpeedMph()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it a functional interface, and we can take advantage of this fact
    and add another method to our API that is able to accept the `SpeedModel` implementation
    as a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem though is that the `traction` value does not come as a parameter
    to the `getSpeedMph()` method, so we cannot implement it as a function before
    passing it to our API method. Look closer at the speed calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do this, you notice that `traction` acts as a simple multiplier to
    the value of `speed`, so we can apply it after the speed calculation (and avoid
    calling `FactorySpeedModel`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This change allows the API users to pass `SpeedModel` as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code is the same as `SpeedModel` generated by `FactorySpeedModel`.
    But now the API users can come up with their own speed-calculating function. For
    example, they can write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1b90891-2535-41cc-b37c-3eef5007afc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Annotate the `SpeedModel` interface as `@FunctionalInterface`, so everybody
    who tries to add another method to it would be dutifully warned and would not
    be able to add another abstract method without removing this annotation and being
    aware of the risk of breaking the code of the existing clients that have implemented
    this functional interface already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improve the API by adding various criteria that slice all of the possible traffic
    into segments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, API users might want to analyze only cars, trucks, cars that have
    an engine bigger than 300 horsepower, trucks with an engine bigger than 400 horsepower,
    and so on. The traditional way to accomplish this would be by creating methods
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can just add standard functional interfaces to the existing method
    and let the API user decide which slice of traffic to extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation would look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The API users can call it, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are now limited to the cars with an engine smaller than 250 hp
    and trucks with an engine smaller than 400 hp:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3af413f-cd39-410d-ad62-574945845fac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, an API user can now apply any criteria for limiting the traffic as
    long as they are applicable to the values in the `TrafficUnit` object. A user
    can write, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they can write any other combination of limits on the values
    that come from `TrafficUnit`. If a user decides to remove the limit and analyze
    all of the traffic, this code will do it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow including the value of the calculated speed in the list of the criteria.
    One way to do this is to change the implementation this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The API would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This example limits traffic by the speed that exceeds a different cushion in
    different driving conditions. If needed, it can disregard the speed at all and
    limit traffic exactly the same way the previous predicate did. The only drawback
    of this implementation is that it is slightly less efficient because the predicate
    is applied after the speed calculations. This means that the speed calculation
    will be done for each generated traffic unit, not to a limited number, as in the
    previous implementation. If this is a concern, you might leave all the different
    signatures in the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Once you leave them, let the user decide which of the methods to use, more flexible
    or more efficient (if the default speed calculation implementation is acceptable).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we did not leave the API user a choice of the output format. Currently,
    it is implemented as the method `printResult()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it more flexible, we can add another parameter to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we take the `timeSec` value not as one of the function parameters,
    but from the enclosed scope of the function. We can do this because it remains
    constant (and can be effectively final) throughout the calculations. In the same
    manner, we can add any other object to the `output` function--a filename or another
    output device, for example--thus leaving all the output-related decisions to the
    API user. To accommodate this new function, the API implementation changes to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: It took us a while to come to this point where the power of functional programming
    starts shining and justifying the effort of learning it. Yet, in conjunction with
    Reactive Streams, described in the next chapter, this Java addition yields even
    more power. In the next chapter, the motivation for this enhancement becomes even
    more apparent and fully appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream Operations
    and Pipelines*
  prefs: []
  type: TYPE_NORMAL
