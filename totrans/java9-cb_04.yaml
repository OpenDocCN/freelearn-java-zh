- en: Going Functional
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走向函数式编程
- en: 'This chapter introduces a programming paradigm called functional programming and
    its applicability in Java 9\. We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了名为函数式编程的编程范式及其在 Java 9 中的适用性。我们将涵盖以下食谱：
- en: Understanding and creating a functional interface
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和创建函数式接口
- en: Understanding lambda expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 lambda 表达式
- en: Using method references
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: Creating and invoking lambda-friendly APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和调用 lambda 友好的 API
- en: Leveraging lambda expressions in your programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的程序中利用 lambda 表达式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Functional programming--the ability to treat a certain piece of functionality
    as an object and to pass it as a parameter or the return value of a method--is
    a feature present in many programming languages. It avoids the changing of an
    object state and mutable data. The result of a function depends only on the input
    data, no matter how many times it is called. This style makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程——将某些功能作为对象处理，并将其作为参数或方法的返回值的能力——是许多编程语言中存在的一个特性。它避免了对象状态的改变和可变数据。函数的结果仅取决于输入数据，无论它被调用多少次。这种风格使结果更具可预测性，这是函数式编程最具吸引力的方面。
- en: Its introduction to Java also allows you to improve parallel programming capabilities
    in Java 8 by shifting the responsibility of parallelism from the client code to
    the library. Before this, in order to process elements of Java collections, the
    client code had to acquire an iterator from the collection and organize the processing
    of the collection.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 Java 中的引入也允许您通过将并行性的责任从客户端代码转移到库中来提高 Java 8 的并行编程能力。在此之前，为了处理 Java 集合的元素，客户端代码必须从集合中获取迭代器并组织集合的处理。
- en: In Java 8, new (default) methods were added that accept a function (implementation
    of a functional interface) as a parameter and then apply it to each element of
    the collection. So, it is the library's responsibility to organize parallel processing. One
    example is the `forEach(Consumer)` method that is available in every `Iterable` interface,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate)` method
    that is available for every `Collection` interface, where `Predicate` is a functional
    interface too. Then we have the `sort(Comparator)` and `replaceAll(UnaryOperator)` methods
    that are available for `List` and several other methods, such as `compute()` for
    `Map`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，添加了新的（默认）方法，这些方法接受一个函数（函数式接口的实现）作为参数，并将其应用于集合的每个元素。因此，组织并行处理的责任在库。一个例子是每个
    `Iterable` 接口都有的 `forEach(Consumer)` 方法，其中 `Consumer` 是一个函数式接口。另一个例子是每个 `Collection`
    接口都有的 `removeIf(Predicate)` 方法，其中 `Predicate` 也是一个函数式接口。然后我们有 `sort(Comparator)`
    和 `replaceAll(UnaryOperator)` 方法，这些方法在 `List` 和其他几个方法中可用，例如 `Map` 的 `compute()`
    方法。
- en: Forty-three functional interfaces are provided in the `java.util.function` package.
    Each of them contains only one abstract method. Lambda expressions take advantage
    of the one-abstract-method limitation and significantly simplifies the implementation
    of such an interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function` 包提供了四十三种函数式接口。每个接口都只包含一个抽象方法。Lambda 表达式利用单抽象方法限制，显著简化了此类接口的实现。'
- en: Without functional programming, the only way to pass some functionality as a
    parameter in Java would be through writing a class that implements an interface,
    creating its object, and then passing it as a parameter. But even the least involved
    style--using an anonymous class--requires writing too much of code. Using functional
    interfaces and lambda expressions makes the code shorter, clearer, and more expressive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有函数式编程，Java 中传递某些功能作为参数的唯一方法是通过编写一个实现接口的类，创建其对象，然后将其作为参数传递。但即使是最低程度的参与方式——使用匿名类——也需要编写过多的代码。使用函数式接口和
    lambda 表达式可以使代码更短、更清晰、更具表现力。
- en: Throughout the chapter, we will define and explain these new Java features--functional
    interfaces and lambda expressions--and demonstrate their applicability in code
    examples. Bringing these new features into Java makes functions first-class citizens
    of the language. But taking advantage of their power requires, for those not exposed
    to functional programming yet, a new way of thinking and organizing the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义和解释这些新的 Java 特性——功能性接口和 lambda 表达式——并在代码示例中展示它们的适用性。将这些新特性引入 Java
    使得函数成为语言的第一等公民。但对于尚未接触过函数式编程的人来说，利用它们的强大功能需要一种新的思考方式和代码组织方式。
- en: Demonstrating these features and sharing the best practices of using them is
    the purpose of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这些特性并分享使用它们的最佳实践是本章的目的。
- en: Understanding and creating a functional interface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和创建功能性接口
- en: In this recipe, you will learn about functional interfaces that are supported
    since Java 8.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解自 Java 8 以来支持的功能性接口。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Any interface that has one and only one abstract method is called a functional
    interface. To help avoid a runtime error, the `@FunctionalInterface` annotation
    was introduced in Java 8 that tells the compiler about the intent. In our demo
    code in the previous chapters, we''ve already had an example of a functional interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何只有一个抽象方法的接口被称为功能性接口。为了帮助避免运行时错误，Java 8 中引入了 `@FunctionalInterface` 注解，它告诉编译器关于意图的信息。在我们前几章的演示代码中，我们已经有一个功能性接口的例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The presence of `enum` types or any implemented (default or static) methods
    does not make it a non-functional interface. Only abstract (not implemented) methods
    count. So, this is an example of a functional interface too:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 存在 `enum` 类型或任何已实现的（默认或静态）方法并不会使其成为非功能性接口。只有抽象（未实现）的方法才算数。因此，这也是一个功能性接口的例子：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To recap what you have already learned about interfaces in one of the previous
    chapters, the implementation of the `getWeightPounds()` method will return `-1`
    when called by `getWeightKg()`. However, this is true only if the `getWeightPounds()`
    method is not implemented in a class. Otherwise, the class implementation will
    be used at runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾你在前几章中关于接口所学的内容，`getWeightPounds()` 方法的实现会在被 `getWeightKg()` 调用时返回 `-1`。然而，这只有在
    `getWeightPounds()` 方法在类中没有实现的情况下才成立。否则，将在运行时使用类的实现。
- en: In addition to default and static interface methods, a functional interface
    can include any and all abstract methods of the base `java.lang.Object`. In Java,
    every object is provided with the default implementation of `java.lang.Object`
    methods, so the compiler and Java runtime ignore such abstract methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认和静态接口方法之外，功能性接口还可以包括基类 `java.lang.Object` 的任何和所有抽象方法。在 Java 中，每个对象都提供了 `java.lang.Object`
    方法的默认实现，因此编译器和 Java 运行时忽略这些抽象方法。
- en: 'For example, this is a functional interface too:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这也是一个功能性接口：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is not a functional interface, though:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下不是功能性接口：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is because the `Car` interface has two abstract methods: its own `getPassengersCount()`
    method and the `setSpeedModel()` method inherited from the `Vehicle` interface.
    Say, we add the `@FunctionalInterface` annotation to the `Car` interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `Car` 接口有两个抽象方法：它自己的 `getPassengersCount()` 方法以及从 `Vehicle` 接口继承的 `setSpeedModel()`
    方法。比如说，我们给 `Car` 接口添加 `@FunctionalInterface` 注解：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we do this, the compiler will generate the following error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，编译器将生成以下错误：
- en: '![](img/d457737f-7b1c-49f2-a9bc-cc493febdc0d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d457737f-7b1c-49f2-a9bc-cc493febdc0d.png)'
- en: Using the `@FunctionalInterface` annotation helps to not only catch errors at
    compile time, but it also secures reliable communication of the design intent.
    It helps you or other programmers remember that this interface cannot have more
    than one abstract method, which is especially important in case code exists already
    that relies on such an assumption.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@FunctionalInterface` 注解不仅有助于在编译时捕获错误，而且还能确保设计意图的可靠传达。它帮助你或其他程序员记住，这个接口不能有超过一个抽象方法，这在代码已经存在且依赖于这种假设的情况下尤为重要。
- en: 'For the same reason, the `Runnable` and `Callable` interfaces (they existed
    in Java since its earlier versions) in Java 8 were annotated as `@FunctionalInterface` to
    make this distinction explicit and remind the users about it or those attempting
    to add another abstract method to them:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，Java 8 中的 `Runnable` 和 `Callable` 接口（它们在 Java 的早期版本中就已经存在）被标注为 `@FunctionalInterface`，以使这种区分明确，并提醒用户或试图向它们添加另一个抽象方法的人：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before you create your own functional interface that you plan to use as a parameter
    for a method, consider avoiding it using one of the forty-three functional interfaces
    provided in the `java.util.function` package first. Most of them are specializations
    of the following four interfaces: `Function`, `Consumer`, `Supplier`, and `Predicate`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你打算用作方法参数的自定义功能接口之前，首先考虑使用`java.util.function`包中提供的四十三种功能接口之一。其中大多数是以下四个接口的特化：`Function`、`Consumer`、`Supplier`和`Predicate`。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'The following are the steps you can follow to get familiar with functional
    interfaces:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循以下步骤来熟悉功能接口：
- en: 'Look at the functional interface `Function`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下功能接口`Function`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is its Javadoc, *Accepts one argument of type T and produces result of
    type R. The functional method is apply(Object).* You can create an implementation
    of this interface using an anonymous class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其Javadoc，*接受一个类型为T的参数并产生类型为R的结果。功能方法是apply(Object)*。你可以使用匿名类来实现这个接口：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Its only method, namely `apply()`, accepts the value of the type `Integer` (or
    the primitive `int`, which is going to be autoboxed) as a parameter, then multiplies
    it by `10`, and returns the value of the type `Double` (or unboxed to the primitive
    `double`) so we can write the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它的唯一方法，即`apply()`，接受类型为`Integer`（或原始的`int`，它将被自动装箱）的值作为参数，然后乘以`10`，并返回类型为`Double`（或解箱为原始的`double`）的值，因此我们可以编写以下代码：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result will be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/5c88fe54-f8a0-4f08-8bfc-36529d7aac51.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c88fe54-f8a0-4f08-8bfc-36529d7aac51.png)'
- en: In the next recipe, we will introduce a lambda expression and show you how its
    usage makes the implementation much shorter. But for now, we will continue using
    an anonymous class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将介绍lambda表达式，并展示其使用如何使实现更加简洁。但到目前为止，我们仍将继续使用匿名类。
- en: 'Look at the functional interface `Consumer` (the name helps to remember that
    the method of this interface accepts a value but does not return anything--it
    only consumes):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下功能接口`Consumer`（名称有助于记住该接口的方法接受一个值但不返回任何内容——它只消费）：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The implementation of this interface can look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的实现可以如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `accepts()` method receives the parameter value of the type `String` and
    prints it. Say, we write the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`accepts()`方法接收类型为`String`的参数值并打印它。比如说，我们编写以下代码：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of this will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/ba791e29-423b-48ed-be9e-cad408a7aa89.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba791e29-423b-48ed-be9e-cad408a7aa89.png)'
- en: 'Look at the functional interface `Supplier` (the name helps to remember that
    the method of this interface does not accept any value but does return something--only
    supplies):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下功能接口`Supplier`（名称有助于记住该接口的方法不接受任何值但返回某些内容——仅提供）：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It means that the only method of this interface is `get()`, which has no input
    parameter and returns the value of the type `T`. Based on this, we can create
    a function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该接口的唯一方法是`get()`，它没有输入参数并返回类型为`T`的值。基于此，我们可以创建一个函数：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `(get()` method does something and then returns the value of the type `String`,
    so we can write the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`(get()`方法执行某些操作然后返回类型为`String`的值，因此我们可以编写以下代码：'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result of this will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/1ffd7bc3-6c96-4ee4-9f52-963e982b0a64.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ffd7bc3-6c96-4ee4-9f52-963e982b0a64.png)'
- en: 'Look at the functional interface `Predicate` (the name helps to remember that
    the method of this interface returns a boolean--predicates something):'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下功能接口`Predicate`（名称有助于记住该接口的方法返回一个布尔值——断言某事）：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Its JavaDoc states: *Represents a predicate (boolean-valued function) of one
    argument of type T. The functional method is test(Object)*. It means that the
    only method of this interface is `test(Object)` that accepts an input parameter
    of the type `T` and returns the value of the type `boolean`. Let''s create a function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它的JavaDoc声明：*表示一个类型为T的单参数谓词（布尔值函数）。功能方法是test(Object)*。这意味着该接口的唯一方法是`test(Object)`，它接受一个类型为`T`的输入参数并返回一个布尔值。让我们创建一个函数：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Its `test()` method accepts a value of the type `Double` as a parameter and
    returns the value of the type `boolean` so we can write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`test()`方法接受一个`Double`类型的参数并返回一个`boolean`类型的值，因此我们可以编写以下代码：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result of this will be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/065dc324-ec5a-4355-80da-f432f7dce0c8.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/065dc324-ec5a-4355-80da-f432f7dce0c8.png)'
- en: 'Look at the other 39 functional interfaces in the `java.util.function` package.
    Notice that they are variations of the four interfaces we have discussed already.
    These variations are created for the following reasons:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看 `java.util.function` 包中的其他 39 个功能接口。注意，它们是我们已经讨论过的四个接口的变体。这些变体是为了以下原因而创建的：
- en: For better performance by avoiding autoboxing and unboxing via the explicit
    usage of the `int`, `double`, or `long` primitives
  id: totrans-72
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式使用 `int`、`double` 或 `long` 原始类型来避免自动装箱和拆箱，以获得更好的性能
- en: For accepting two input parameters
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于接受两个输入参数
- en: For a shorter notation
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简短的表示法
- en: The following functional interfaces are just a few examples from the list of
    39 interfaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能接口只是 39 个接口列表中的几个例子。
- en: 'The functional interface `IntFunction<R>` (its only abstract method is `apply(int)`),
    accepts an `int` primitive and returns the value of the type `R`. It provides
    a shorter notation (without generics for the parameter type) and avoids autoboxing
    (by defining the `int` primitive as the parameter). Here''s an example of this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口 `IntFunction<R>`（其唯一抽象方法是 `apply(int)`）接受一个 `int` 原始类型，并返回类型为 `R` 的值。它提供了一种简短的表示法（参数类型不使用泛型）并避免了自动装箱（通过将
    `int` 原始类型定义为参数）。以下是一个例子：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The functional interface `BiFunction<T,U,R>` (the `apply(T,U)` method) accepts
    two parameters of the types `T` and `U` and returns the value of the type `R`.
    Here''s an example of this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口 `BiFunction<T,U,R>`（`apply(T,U)` 方法）接受类型为 `T` 和 `U` 的两个参数，并返回类型为 `R` 的值。以下是一个例子：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The functional interface `BinaryOperator<T>` (the `apply(T,T)` method) accepts
    two parameters of the type `T` and returns the value of the type `T`. It provides
    a shorter notation by avoiding repeating the same type three times. Here''s an
    example of this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口 `BinaryOperator<T>`（`apply(T,T)` 方法）接受两个类型为 `T` 的参数，并返回类型为 `T` 的值。它通过避免重复三次相同的类型来提供简短的表示法。以下是一个例子：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The functional interface `IntBinaryOperator` (the `applyAsInt(int,int)` method)
    accepts two parameters of the type `int` and returns the value of the type `int` too.
    Here''s an example of this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口 `IntBinaryOperator`（`applyAsInt(int,int)` 方法）接受两个类型为 `int` 的参数，并返回类型为 `int`
    的值。以下是一个例子：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will see examples of the usage of such specializations in the following recipes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的菜谱中看到此类特殊化的使用示例。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can create and pass around an implementation of any functional interface
    as you do with any object. For example, let''s write a method that creates `Function<Integer,
    Double>`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建并传递任何功能接口的实现，就像传递任何对象一样。例如，让我们编写一个创建 `Function<Integer, Double>` 的方法：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Better yet, we can create a generic method that uses the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以创建一个使用以下内容的泛型方法：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can write this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以写出这个：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The results will be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/a434b198-33f7-4ae1-a5c2-659d7663861f.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a434b198-33f7-4ae1-a5c2-659d7663861f.png)'
- en: 'Similarly, we can have factory methods that create the `Function<Double, Double>` function,
    the `Consumer<String>` function, and the `Supplier<String>` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以有创建 `Function<Double, Double>` 函数、`Consumer<String>` 函数和 `Supplier<String>`
    函数的工厂方法：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s use the preceding functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的函数：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The results will be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/a19d773c-2d8d-4a2f-8c58-39ce517fd946.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a19d773c-2d8d-4a2f-8c58-39ce517fd946.png)'
- en: 'We can also have factory methods that create different versions of the `Predicate<Double>` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有创建不同版本的 `Predicate<Double>` 函数的工厂方法：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s use the preceding methods as following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方法使用前面的方法：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we use them, we get the following results:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用它们时，我们得到以下结果：
- en: '![](img/413eabe8-c132-4df0-b53f-f090dff46400.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/413eabe8-c132-4df0-b53f-f090dff46400.png)'
- en: 'If needed, a function with more complex logic can be composed of several already
    existing functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，具有更复杂逻辑的函数可以由几个已存在的函数组合而成：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can create it by passing the `multiplyBy10`, `multiplyBy30`, and `isSmallerThan20` functions
    to the factory method, which we have created before:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `multiplyBy10`、`multiplyBy30` 和 `isSmallerThan20` 函数传递给之前创建的工厂方法来创建它：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we run the preceding code, you''ll get the following results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，你会得到以下结果：
- en: '![](img/49834ab6-22fd-46a6-a0b1-305cfd0c4c13.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49834ab6-22fd-46a6-a0b1-305cfd0c4c13.png)'
- en: The first and the third lines come from the `isSmallerThan20` function, while
    the second and fourth line come from the `compare1By10And20` and `compare1By30And20`
    functions, correspondingly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和第三行来自 `isSmallerThan20` 函数，而第二行和第四行来自 `compare1By10And20` 和 `compare1By30And20`
    函数，相应地。
- en: As you see, the introduction of functional interfaces enhances Java by allowing
    passing functions as parameters. An application developer can now concentrate
    on the implementation of the function (business process) and not worry about the
    plumbing of applying it to each element of a collection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，函数式接口的引入通过允许传递函数作为参数来增强了Java。现在，应用程序开发者可以专注于函数（业务流程）的实现，而不用担心将其应用到集合的每个元素。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Many of the functional interfaces in the `java.util.function` package have
    default methods that not only enhance their functionality, but also allow you
    to chain the functions and pass the result of one as an input parameter to another.
    For example, we can use the default method `andThen(Function after)` of the `Function` interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中的许多函数式接口都有默认方法，这些方法不仅增强了它们的功能，还允许你链式调用函数，并将一个函数的结果作为另一个函数的输入参数。例如，我们可以使用`Function`接口的默认方法`andThen(Function
    after)`：'
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `after` function is applied to the result of this function, so naturally,
    the input type of the `after` function has to be the same or a base type of the
    result of this function. The result of this code is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`after`函数应用于这个函数的结果，因此，`after`函数的输入类型必须与这个函数的结果类型相同或为其基类型。这段代码的结果如下：'
- en: '![](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
- en: 'We could achieve the same result using another default method of the `Function`
    interface called `compose(Function before)`, which applies the `before` function
    first before applying this function. Naturally, in this case, we would need to
    switch positions of the `multiplyBy30` function and the `subtract7`: function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Function`接口的另一个默认方法`compose(Function before)`来达到相同的结果，该方法首先应用`before`函数，然后再应用这个函数。自然地，在这种情况下，我们需要交换`multiplyBy30`函数和`subtract7`函数的位置：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dab16363-d953-4944-bf4a-3c2511b2f31a.png)'
- en: 'The `Consumer` interface has the `andThen(Consumer after)` method too, so we
    can create a dialog using the `sayHappyToSee` function we have created before:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer`接口也有`andThen(Consumer after)`方法，因此我们可以使用之前创建的`sayHappyToSee`函数来创建一个对话：'
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result will be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/432a6e8d-bf34-480b-a221-23e999eabf3b.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/432a6e8d-bf34-480b-a221-23e999eabf3b.png)'
- en: 'The `Supplier` interface does not have default methods, while the `Predicate`
    interface has one `isEqual(Object targetRef)` static method and three default
    methods: `and(Predicate other)`, `negate()`, and `or(Predicate other)`. We will
    demonstrate the usage of the `and(Predicate other)` method.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier`接口没有默认方法，而`Predicate`接口有一个`isEqual(Object targetRef)`静态方法和三个默认方法：`and(Predicate
    other)`、`negate()`和`or(Predicate other)`。我们将演示`and(Predicate other)`方法的用法。'
- en: 'We can create a predicate, using the already created functions `isSmallerThan20`
    and `isBiggerThan18`, that checks whether the input value falls between the two
    values. But before this, we need to overload the `applyCompareAndSay()` factory
    method by adding another parameter to the signature named `message` that matches
    the new predicate:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个谓词，使用已经创建的函数`isSmallerThan20`和`isBiggerThan18`来检查输入值是否介于这两个值之间。但在做这个之前，我们需要通过向签名中添加另一个名为`message`的参数来重载`applyCompareAndSay()`工厂方法：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can write the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以写出以下内容：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get the following results:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](img/54b0267a-5ebe-4f00-a0ab-4b4552cc747b.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54b0267a-5ebe-4f00-a0ab-4b4552cc747b.png)'
- en: If this coding looks a bit over-engineered and convoluted, it is true. We did
    it for demo purposes. Good news is that lambda expressions (presented in the next
    recipe) allow you to achieve the same results in a much more straightforward and
    clear way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来有点过度设计且复杂，这是真的。我们这样做是为了演示目的。好消息是lambda表达式（在下一道菜谱中介绍）允许你以更直接、更清晰的方式达到相同的结果。
- en: 'Before we end this recipe, we would like to mention that functional interfaces
    of the `java.util.function` package have other helpful default methods. The one
    that stands out is the `identity()` method, which returns a function that always
    returns its input argument:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这道菜谱之前，我们想提到，`java.util.function`包中的函数式接口有其他有用的默认方法。其中最突出的是`identity()`方法，它返回一个总是返回其输入参数的函数：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will get the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/4be0aa15-0428-46c9-bc68-984fc6c4b2fd.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4be0aa15-0428-46c9-bc68-984fc6c4b2fd.png)'
- en: The `identity()` method is very helpful when some procedure requires you to
    provide a certain function, but you do not want this function to modify the result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些过程需要你提供一个特定函数，但你又不想这个函数修改结果时，`identity()` 方法非常有用。
- en: Other default methods are mostly related to conversion and boxing and unboxing
    and extracting min and max of two parameters. We encourage you to walk through
    the API of all the functional interfaces of the `java.util.function` package and
    get a feeling of the possibilities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其他默认方法大多与转换、装箱和拆箱以及提取两个参数的最小和最大值有关。我们鼓励你遍历 `java.util.function` 包中所有函数式接口的 API，并感受其可能性。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Understanding lambda expressions
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 lambda 表达式
- en: Using method references
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: Understanding lambda expressions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 lambda 表达式
- en: In this recipe, you will learn about lambda expressions that are supported since
    Java 8.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将了解自 Java 8 以来支持的 lambda 表达式。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The examples in the previous recipe (that used anonymous classes for functional
    interfaces' implementation) looked bulky and felt excessively verbose. For one,
    there was no need to repeat the interface name because we had declared it already
    as the type for the object reference. Second, in the case of a functional interface (that
    had only one abstract method), there was no need to specify the method name to
    be implemented. The compiler and Java runtime can figure it out anyway. All we
    needed was to provide the new functionality. This is where a lambda expression
    comes to the rescue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱（使用匿名类实现函数式接口）中的例子看起来很庞大，感觉过于冗长。首先，我们没有必要重复接口名称，因为我们已经将其声明为对象引用的类型。其次，在函数式接口（只有一个抽象方法）的情况下，没有必要指定要实现的方法名称。编译器和
    Java 运行时无论如何都能弄清楚。我们需要的只是提供新的功能。这就是 lambda 表达式发挥作用的地方。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps will help you to understand lambda expressions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你理解 lambda 表达式：
- en: 'Consider the following code, for example:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码，例如：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Rewrite it using lambda expressions:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 lambda 表达式重写它：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run it and you''ll get the same result:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它，你会得到相同的结果：
- en: '![](img/3a00634a-788a-4c8b-9c48-999ea420d64c.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a00634a-788a-4c8b-9c48-999ea420d64c.png)'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The syntax of a lambda expression includes the list of parameters, an arrow
    token (`->`), and a body. The list of parameters can be empty (`()`), without
    brackets (if there is only one parameter, as in our examples), or a comma-separated
    list of parameters surrounded by brackets. The body can be a single expression
    (as in our preceding code) or a statement block. Here is another example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式的语法包括参数列表、箭头符号 (`->`) 和主体。参数列表可以是空的 (`()`), 没有括号（如果只有一个参数，如我们的示例所示），或者是一个用括号包围的逗号分隔的参数列表。主体可以是一个单独的表达式（如我们前面的代码所示）或一个语句块。以下是一个例子：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result of this example is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的结果如下：
- en: '![](img/6cdd87cf-be5b-48ae-8393-aa5f5fabf643.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cdd87cf-be5b-48ae-8393-aa5f5fabf643.png)'
- en: Braces are required only in the case of a statement block. They are optional
    in a one-line lambda expression, whether the function returns a value or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在语句块的情况下才需要大括号。在单行 lambda 表达式中，无论函数是否返回值，大括号都是可选的。
- en: 'Let''s rewrite the code we wrote before using lambda expressions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 lambda 表达式重写我们之前写的代码：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run this, we get the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们会得到以下结果：
- en: '![](img/9eaf6140-d6ac-436e-abf1-3bb7768056ee.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eaf6140-d6ac-436e-abf1-3bb7768056ee.png)'
- en: As you see, the results are exactly the same, but the code is much simpler and
    captures only the essence.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果完全相同，但代码更简单，只捕捉了本质。
- en: 'The factory method can be rewritten and simplified using lambda expressions
    too:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法也可以用 lambda 表达式重写和简化：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We don't repeat the name of the implemented `Supplier<String>` interface anymore
    because it is specified as the return type in the method signature. And we do
    not specify the name of the implemented `test()` method either because it is the
    only method of the `Supplier` interface that has to be implemented. Writing such
    a compact and efficient code became possible because of the combination of a lambda
    expression and functional interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再重复实现 `Supplier<String>` 接口的名称，因为它已经在方法签名中指定为返回类型。我们也不再指定实现 `test()` 方法的名称，因为它必须是
    `Supplier` 接口中唯一必须实现的方法。编写这样紧凑高效的代码成为可能，是因为 lambda 表达式和函数式接口的结合。
- en: 'As in an anonymous class, the variable created outside and used inside a lambda
    expression becomes effectively final and cannot be modified. You can write the
    following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类一样，在lambda表达式外部创建并在内部使用的变量成为实际上是final的，不能被修改。你可以编写以下代码：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, you cannot change the value of the variable `v` outside the lambda
    expression:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你无法在lambda表达式外部更改变量`v`的值：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You cannot change it inside the expression as well:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也无法在表达式中更改它：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The reason for this restriction is that a function can be passed and executed
    for different arguments in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would frustrate the original idea
    of the distributed evaluation of functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制的原因是，一个函数可以在不同的上下文中（例如不同的线程）为不同的参数传递和执行，尝试同步这些上下文将违背函数分布式评估的原始想法。
- en: 'One principal difference between an anonymous class and lambda expression is
    the interpretation of the `this` keyword. Inside an anonymous class, it refers
    to the instance of the anonymous class. Inside the lambda expression, `this` refers
    to the instance of the class that surrounds the expression. Here is the demo code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类和lambda表达式之间一个主要的不同之处在于`this`关键字的解释。在匿名类内部，它指的是匿名类的实例。在lambda表达式内部，`this`指的是包围表达式的类的实例。以下是一个演示代码示例：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of this code is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![](img/b355229c-dd29-4b91-aeef-4b48703a7312.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b355229c-dd29-4b91-aeef-4b48703a7312.png)'
- en: The lambda expression is not an inner class and cannot be referred to by `this`.
    According to the Java specification, such an approach allows you to have more
    flexibility of implementation by treating reference `this` as coming from the
    surrounding context.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式不是一个内部类，不能通过`this`来引用。根据Java规范，这种做法通过将`this`引用视为来自周围上下文，允许你拥有更多的实现灵活性。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Look how simpler and less convoluted the demo code becomes. We can create functions
    on the fly while passing them as parameters:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 看看演示代码如何变得更加简单和复杂度更低。我们可以在传递参数的同时动态创建函数：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, the result does not change:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结果并没有改变：
- en: '![](img/599e058b-51ed-40a4-bfc1-8234aa557e00.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/599e058b-51ed-40a4-bfc1-8234aa557e00.png)'
- en: This is the power and beauty of lambda expressions in combination with functional
    interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是lambda表达式与函数式接口结合的强大和美丽之处。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下菜谱：
- en: Understanding and creating a functional interface
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和创建函数式接口
- en: Using method references
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream
    Operations and Pipelines*
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请参阅[第5章](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)，*流操作和管道*
- en: Using method references
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: In this recipe, you will learn how to use a method reference, the constructor
    reference being one of the cases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用方法引用，构造器引用只是其中的一种情况。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the cases, when a one-line lambda expression consists of a reference to an
    existing method only (implemented somewhere else), it is possible to further simplify
    the notation using the method reference. The reference method can be static or
    non-static (the latter can be bound to a particular object or not) or can be a
    constructor with or without parameters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，当一行lambda表达式仅由对现有方法的引用组成（在别处实现）时，可以使用方法引用进一步简化表示法。引用方法可以是静态的或非静态的（后者可以绑定到特定的对象或不行）或带有或不带有参数的构造器。
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found.
    The two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的语法是`Location::methodName`，其中`Location`表示`methodName`方法可以在哪里（在哪个对象或类）找到。两个冒号（`::`）作为位置和方法名之间的分隔符。如果在指定位置有多个具有相同名称的方法（由于方法重载），则通过lambda表达式实现的函数式接口的抽象方法的签名来识别引用方法。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Using a method reference is straightforward and can be easily illustrated by
    a few examples for each case:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法引用很简单，可以通过每个案例的几个示例来轻松说明：
- en: 'First, we have the static method reference. If a `Food` class has a static
    method, named `String getFavorite()`, then the lambda expression may look like
    this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有静态方法引用。如果一个`Food`类有一个名为`String getFavorite()`的静态方法，那么lambda表达式可能看起来像这样：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the `Foo` class has another method, named `String getFavorite(int num)`,
    the lambda expression that uses it may look exactly the same:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Foo`类还有一个名为`String getFavorite(int num)`的方法，使用它的lambda表达式可能看起来完全一样：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The difference is in the interface that this lambda expression implements.
    It allows the compiler and Java runtime to identify the method to be used. Let''s
    look at the code. Here is the `Food` class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于这个lambda表达式实现的接口。它允许编译器和Java运行时识别要使用的方法。让我们看看代码。以下是`Food`类：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can use its static methods as the implementation of the functional interfaces:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它的静态方法作为函数式接口的实现：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result is going to be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会如下：
- en: '![](img/243fe333-473d-483a-aebf-68e988515afd.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/243fe333-473d-483a-aebf-68e988515afd.png)'
- en: Second, we have the method reference to a constructor.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们有构造函数的方法引用。
- en: 'Let''s assume that the `Food` class does not have an explicit constructor or
    has one without parameters. The closest to such a signature is a functional interface
    called `Supplier<Food>` because it does not take any parameter either. Let''s
    add the following to our `Food` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Food`类没有显式的构造函数，或者有一个不带参数的构造函数。最接近这种签名的函数式接口是`Supplier<Food>`，因为它也不接受任何参数。让我们向我们的`Food`类添加以下内容：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then we can write the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以写出以下内容：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we write this, we get the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样写，我们会得到以下输出：
- en: '![](img/254a9d0b-de8b-4633-8769-dfa1d41c53a6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/254a9d0b-de8b-4633-8769-dfa1d41c53a6.png)'
- en: 'The preceding non-static method reference was bound to a particular instance
    of the `Food` class. We will come back to it and also discuss an unbound non-static
    method reference later. But, for now, we will add another constructor with one
    parameter to the `Food` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之前非静态方法引用绑定到了`Food`类的特定实例。我们稍后会回到它，并讨论非绑定非静态方法引用。但现在，我们将向`Food`类添加另一个带有一个参数的构造函数：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we do this, we will express it via the method reference:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们将通过方法引用来表示它：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This results in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下代码：
- en: '![](img/15b7d338-980c-4b3f-822a-7833c90bf457.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15b7d338-980c-4b3f-822a-7833c90bf457.png)'
- en: 'In the same manner, we can add a constructor with two parameters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以添加一个带有两个参数的构造函数：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once we do this, we can express it via `BiFunction<String, String>`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就可以通过`BiFunction<String, String>`来表示它：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This results in the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下结果：
- en: '![](img/7216db59-3d5f-49fb-943d-030db088c859.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7216db59-3d5f-49fb-943d-030db088c859.png)'
- en: 'To express a constructor that accepts more than two parameters, we can create
    a custom functional interface with any number of parameters. For example, consider
    the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示接受超过两个参数的构造函数，我们可以创建一个具有任意数量参数的自定义函数式接口。例如，考虑以下内容：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can use it for different types:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来处理不同类型：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The name of this custom interface and the name of its only method can be anything
    we like:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义接口的名称及其唯一方法的名称可以是我们喜欢的任何名称：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Third, we have the bound and unbound non-static methods.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，我们有绑定和非绑定非静态方法。
- en: 'The method reference we used for the `sayFavorite()` method requires (bound
    to) the class instance. This means that we cannot change the instance of the class
    used in the function after the function is created. To demonstrate this, let''s
    create three instances of the `Food` class and three instances of the `Supplier<String>`
    interface that capture the functionality of the `sayFavorite()` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于`sayFavorite()`方法的引用方法需要（绑定到）类实例。这意味着在函数创建之后，我们无法更改函数中使用的类实例。为了演示这一点，让我们创建三个`Food`类的实例和三个捕获`sayFavorite()`方法功能的`Supplier<String>`接口的实例：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see, after the supplier is created, we can only call the `get()`
    method on it and cannot change the instance (of the `Food` class) to which it
    was bound (the `get()` method refers to the method of the objects `food1`, `food2`,
    or `food3`). The results are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在创建供应商之后，我们只能调用其上的`get()`方法，并且不能更改绑定到其上的实例（`Food`类的实例）（`get()`方法指的是`food1`、`food2`或`food3`对象的方法）。结果如下：
- en: '![](img/5cecb1b6-cc9e-4cbc-b5ab-895055fa6efa.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cecb1b6-cc9e-4cbc-b5ab-895055fa6efa.png)'
- en: 'By contrast, we can create an unbound master reference with the instance of
    the `Function<Food, String>` interface (notice that the method location is specified
    as a class name called `Food`):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们可以使用`Function<Food, String>`接口的实例创建一个未绑定的主引用（注意，方法位置被指定为名为`Food`的类名）：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This means we can use a different instance of the `Food` class for every call
    of this function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以为这个函数的每次调用使用`Food`类的不同实例：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is why this method reference is called **unbound**.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么这个方法引用被称为**未绑定**的。
- en: 'Finally, we can overload the `sayFavorite()` method (in the same way we did
    it for the static method `getFavorite()`) by adding the `sayFavorite(String name)`
    method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过添加`sayFavorite(String name)`方法（与我们对静态方法`getFavorite()`所做的方式相同）来重载`sayFavorite()`方法：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this, we can show that the compiler and Java runtime can still understand
    (using the signature of the specified functional interface) our intent and invoke
    the correct method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以证明编译器和Java运行时仍然可以通过指定的功能接口签名理解我们的意图并调用正确的方法：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The results are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/4a2625f3-e5d8-4e9b-8ef1-e74acc1c38d5.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a2625f3-e5d8-4e9b-8ef1-e74acc1c38d5.png)'
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several simple but useful lambda expressions and method references
    often used in practice:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，经常使用一些简单但有用的lambda表达式和方法引用：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we run them, the results would be as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它们，结果将如下所示：
- en: '![](img/5ca72d7c-0e95-4351-a9ab-2ae57f7d3c14.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ca72d7c-0e95-4351-a9ab-2ae57f7d3c14.png)'
- en: 'Here are a few useful methods for working with arrays and lists:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用于处理数组和列表的有用方法：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here are the results of the preceding code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的结果：
- en: '![](img/06ceb52f-9e96-4b4a-a4ed-b73c7f1a7530.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06ceb52f-9e96-4b4a-a4ed-b73c7f1a7530.png)'
- en: We leave it up to you to analyze how they were created and used.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析它们是如何创建和使用的留给你。
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下菜谱：
- en: Understanding and creating a functional interface
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和创建功能接口
- en: Understanding lambda expressions
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解lambda表达式
- en: Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream
    Operations and Pipelines*
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请参阅[第5章](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)，*流操作和管道*
- en: Creating and invoking lambda-friendly APIs
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和调用lambda友好的API
- en: In this recipe, you will learn how to create lambda-friendly APIs and the best
    practices of doing it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建lambda友好的API以及最佳实践。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When an idea of a new API first comes up, it usually looks clean and well focused.
    Even the first implemented version often preserves the same qualities. But then
    "one-offs" and other small deviations from the main use cases become pressing,
    and the API starts to grow (and becomes increasingly complex and more difficult
    to use) as the variety of use cases increases. Life does not always comply with
    our vision of it. That's why any API designer at some point faces the question
    of how generic and flexible the API should be. A too-generic API makes it difficult
    to understand in terms of the specific business domain, while a very flexible
    API makes the implementation more complex and difficult to test, maintain, and
    use.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的API的想法首次出现时，它通常看起来干净且聚焦良好。即使是第一个实现的版本也往往保持相同的品质。但随后，“一次性”和其他与主要用例的小偏差变得紧迫，随着用例种类的增加，API开始增长（并且变得越来越复杂，更难使用）。生活并不总是符合我们对它的愿景。这就是为什么任何API设计者在某个时候都会面临如何使API既通用又灵活的问题。过于通用的API在特定业务领域难以理解，而非常灵活的API会使实现更加复杂，更难测试、维护和使用。
- en: Using interfaces as parameters facilitate flexibility but require writing new
    code that implements them. Functional interfaces and lambda expressions allow
    the decreasing of the scope of such code to a minimum by capturing the functionality
    with almost no plumbing. The granularity of such an implementation can be as fine
    or as coarse as needed without the need to create new classes, their object factories,
    and other traditional infrastructure.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将接口用作参数可以促进灵活性，但需要编写实现它们的新代码。功能接口和lambda表达式允许通过几乎不需要管道的方式捕获功能，从而将此类代码的范围减少到最小。这种实现的粒度可以细到或粗到所需，无需创建新类、它们的对象工厂和其他传统基础设施。
- en: However, it is possible to push the flexibility too far and overuse the power
    of the new features to the point when it defeats the purpose by making the API
    difficult to understand and next to impossible to use. To warn about certain pitfalls
    and share the best practices of a lambda-friendly API design is the purpose of
    this recipe.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过度追求灵活性是有可能的，过度使用新功能的力量，以至于它通过使API难以理解和使用几乎不可能来违背初衷。本食谱的目的是警告某些陷阱并分享适合lambda表达式的API设计的最佳实践。
- en: 'The best practices of a lambda-friendly API design include the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 适合lambda表达式使用的API设计最佳实践包括以下内容：
- en: Prefer the interfaces of the `java.util.function` package
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用`java.util.function`包中的接口
- en: Avoid overloading methods by the type of the functional interface
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免通过函数式接口的类型来过度加载方法
- en: Use the `@FunctionalInterface` annotation for custom functional interfaces
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@FunctionalInterface`注解来定义自定义函数式接口
- en: Consider the functional interface as a parameter instead of creating several
    methods that are different only as per some step of the functionality
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数式接口作为参数考虑，而不是创建几个只在功能步骤上有所不同的方法
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We talked about the first two of the listed practices in the *Understanding
    and creating a functional interface* recipe. The advantage of using the interfaces
    of the `java.util.function` package is based on two facts. First, any standardization
    facilitates better understanding and ease of API usage. Second, it facilitates
    minimal code writing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*理解和创建函数式接口*的食谱中讨论了所列出的前两种实践。使用`java.util.function`包中的接口的优势基于两个事实。首先，任何标准化都促进了更好的理解和API使用的便利性。其次，它促进了代码编写的最小化。
- en: To illustrate these considerations, let's try to create an API and call it `GrandApi`--an
    interface that is going to be implemented in the `GrandApiImpl` class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些考虑，让我们尝试创建一个API，并将其命名为`GrandApi`——一个将在`GrandApiImpl`类中实现的接口。
- en: Let's add a method to our new API that allows the client to pass a function
    that calculates something. Such an arrangement allows a client to customize the
    behavior of the API as needed. This design is called a delegation pattern. It
    helps with an object composition, which we have discussed in [Chapter 2](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml), *Fast
    Track to OOP - Classes and Interfaces*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新的API中添加一个方法，允许客户端传递一个计算某个值的函数。这种安排允许客户端根据需要自定义API的行为。这种设计被称为委托模式。它有助于对象组合，这在[第2章](8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml)中讨论过，*快速掌握面向对象
    - 类和接口*。
- en: 'First, we demonstrate the traditional object-oriented approach and introduce
    a `Calculator` interface that has a method that calculates something:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们演示传统的面向对象方法，并引入一个具有计算方法`Calculator`接口：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'So, the first method of our new interface can have the following method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们新接口的第一个方法可以有如下方法：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The implementation of this method may look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的实现可能如下所示：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now create a `CalucaltorImpl` class that implements the `Calculator`
    interface and pass the object of `CalculatorImpl` to the `doSomething()` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个实现`Calculator`接口的`CalucaltorImpl`类，并将`CalculatorImpl`对象的实例传递给`doSomething()`方法：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The result will be as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
- en: 'If the client would want to use another `Calculator` implementation, this approach
    would require you to either create a new class or use an anonymous class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端想要使用另一个`Calculator`实现，这种方法将需要你创建一个新的类或使用匿名类：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: These were the two options available for a client before Java 8\. And if the
    client is forced to use a certain `Calculator` implementation (developed by a
    third party, for example), the anonymous class could not be used; therefore, only
    one option would remain.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，客户端有两个可用的选项。如果客户端被迫使用某个`Calculator`实现（例如，由第三方开发），则不能使用匿名类；因此，只剩下一个选项。
- en: 'With Java 8, the client can take advantage of the `Calculator` interface that
    has one abstract method only (so, it is being a functional interface). Say, a
    client is forced to use a third-party implementation:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，客户端可以利用只有一个抽象方法的`Calculator`接口（因此，它是一个函数式接口）。比如说，客户端被迫使用第三方实现：
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The client could write the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以编写以下代码：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If they do this, they''ll get the following result:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们这样做，将会得到以下结果：
- en: '![](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
- en: The compiler and Java runtime match the functional interface primarily by the number
    of input parameters and the presence or absence of the return value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和Java运行时主要根据输入参数的数量以及返回值的是否存在来匹配功能接口。
- en: 'If the usage of a third-party implementation is not mandatory, the client can
    use a lambda expression, for example, the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用第三方实现不是强制性的，客户端可以使用lambda表达式，例如以下内容：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'They can alternatively use this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还可以使用以下方法：
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In both these cases, they will get this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，他们都会得到以下结果：
- en: '![](img/bc4b4875-90b6-4d2c-ba26-f211b37b2a25.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc4b4875-90b6-4d2c-ba26-f211b37b2a25.png)'
- en: However, all of these is possible only as long as the `Calculator` interface
    has only one abstract method. So, we better have the `@FunctionalInterface` annotation
    added to it, if we can. This is because the client code with lambda will break
    as soon as `Calculator` gains another abstract method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些只有在`Calculator`接口只有一个抽象方法的情况下才可能。因此，如果我们能的话，最好给它添加`@FunctionalInterface`注解。这是因为一旦`Calculator`获得另一个抽象方法，带有lambda表达式的客户端代码就会崩溃。
- en: 'However, we can avoid creating a custom interface if we use one of the standard
    functional interfaces from the `java.util.function` package. The matching one,
    in this case, would be `Supplier<Double>`, and we can change our first API method
    to this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`java.util.function`包中的一个标准功能接口，我们可以避免创建一个自定义接口。在这种情况下，匹配的接口将是`Supplier<Double>`，我们可以将我们的第一个API方法更改为以下内容：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we are sure that the client code with lambda will never break, and the
    client code will be much shorter:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们确信带有lambda表达式的客户端代码永远不会崩溃，并且客户端代码将会更短：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It could also be this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以是这样的：
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In either case, the result will be the same:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，结果都将相同：
- en: '![](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88382a8e-acde-4623-bfbe-51e25c1dc10c.png)'
- en: 'If the client is forced to use the existing implementation, the code can be
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端被迫使用现有的实现，代码可以如下所示：
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It will still yield the same result for the `AnyImpl` class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`AnyImpl`类，它仍然会产生相同的结果：
- en: '![](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png)'
- en: 'This is why using standard functional interfaces is highly advisable because
    it allows more flexibility and less client code writing. That said, one should
    be careful not to get into an overloading of the methods by the type of functional
    interface only. The problem is that the algorithm that identifies the method by
    its functional interface parameter often does not have much to work with, especially
    if the method invocation includes an inline lambda expression only. The algorithm
    checks the number of input parameters (arity) and the presence or absence (`void`)
    of the return value. But even this may be not enough, and the API user may have
    a serious debugging problem. Let''s look at an example and add these two methods
    to our API:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么使用标准功能接口非常推荐的原因，因为它允许更多的灵活性，并且减少了客户端代码的编写。然而，一个人应该小心不要仅仅通过功能接口的类型来过度加载方法。问题在于，通过功能接口参数识别方法的算法通常没有太多可以工作的，特别是如果方法调用只包含内联lambda表达式。算法检查输入参数的数量（arity）以及返回值的是否存在（`void`）。但这可能还不够，API用户可能会遇到严重的调试问题。让我们看一个例子，并将这两个方法添加到我们的API中：
- en: '[PRE80]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For a human eye, these methods have very different signatures. They are resolved
    correctly as long as the passed-in instance of a functional interface is explicitly
    specified:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类眼睛来说，这些方法具有非常不同的签名。只要传递给功能接口的实例是明确指定的，它们就会被正确解析：
- en: '[PRE81]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The type of the functional interface can be also specified using typecasting:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口的类型也可以通过类型转换来指定：
- en: '[PRE82]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now consider the code that does not specify the type of the passed-in functional
    interface:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑不指定传入功能接口类型的代码：
- en: '[PRE83]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'It does not even compile, and gives the following error message:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至无法编译，并给出以下错误信息：
- en: '![](img/41807ce9-ca2b-4604-a011-eee52b892265.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41807ce9-ca2b-4604-a011-eee52b892265.png)'
- en: 'The reason for the error is that both the interfaces (`Function<Integer, Integer>`
    and `Consumer<String>`) have the same number of input parameters, while the different
    return type (`Integer` and `void` ) apparently is not enough to resolve the method
    overload in this case. So, instead of overloading the method using different functional
    interfaces, use different method names. For example, check out the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因是，这两个接口（`Function<Integer, Integer>`和`Consumer<String>`）具有相同数量的输入参数，而不同的返回类型（`Integer`和`void`）显然不足以解决这种情况下的方法重载。因此，不要使用不同的函数式接口来重载方法，而应使用不同的方法名。例如，看看以下内容：
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There's more...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following are the best practices for constructing a lambda expression:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为构建lambda表达式最佳实践：
- en: Keep it stateless
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持无状态
- en: Avoid a block statement
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用块语句
- en: Use a method reference
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: Rely on effectively final
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖有效的最终状态
- en: Do not work around effectively final
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要绕过有效的最终状态
- en: Avoid specifying the parameter type
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免指定参数类型
- en: Avoid brackets for a single parameter
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免为单个参数使用括号
- en: Avoid braces and the return statement
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用大括号和返回语句
- en: An API designer should keep these guidelines in mind too because the API clients
    will probably use them.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: API设计者也应牢记这些指南，因为API客户端可能会使用它们。
- en: 'Keeping lambda expressions stateless means that the result of the function
    evaluation must depend only on the input parameters, no matter how often the expression
    is evaluated or which parameters were used for the previous call. For example,
    this would be a bug-prone code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 保持lambda表达式无状态意味着函数评估的结果必须仅依赖于输入参数，无论表达式评估多少次或使用了哪些参数。例如，这将是一个容易出错的代码：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is because it yields different results every time:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它每次都会产生不同的结果：
- en: '![](img/c89a1037-79a6-44ba-96b4-c94608f85055.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c89a1037-79a6-44ba-96b4-c94608f85055.png)'
- en: This example also covers recommendations to rely on effectively final and not
    to work around it. By specifying `final int[] arr` in the preceding example, one
    gets an illusion that the code is bulletproof while, in fact, it hides the defect.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还涵盖了依赖有效的最终状态而不是绕过它的建议。通过在先前的示例中指定`final int[] arr`，给人一种代码无懈可击的错觉，而实际上它隐藏了缺陷。
- en: 'Other best practices of a lambda help to keep the code clear to better express
    its main logic, which otherwise might be lost in long-winded code and a multitude
    of notations. Just compare the following lines. Here''s the first line:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其他lambda表达式最佳实践有助于使代码更清晰，更好地表达其主要逻辑，否则可能会在冗长的代码和众多符号中丢失。只需比较以下行。这是第一行：
- en: '[PRE86]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here''s the second line:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二行：
- en: '[PRE87]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The second line is much cleaner and clearer, especially in the case of several
    parameters and complex logic in the block statement. We will see examples of block
    statements and how to avoid them in the next recipe. Any modern editor helps to
    remove unnecessary notation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行更加简洁明了，尤其是在块语句中有多个参数和复杂逻辑的情况下。我们将在下一配方中看到块语句的示例以及如何避免它们。任何现代编辑器都有助于移除不必要的符号。
- en: See also
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章中的以下配方：
- en: Leveraging lambda expressions in your programs
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的程序中利用lambda表达式
- en: "Also, refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)\uFEFF\
    , *Stream Operations and Pipelines*"
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 还请参考[第5章](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)，“流操作和管道”
- en: Leveraging lambda expressions in your programs
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的程序中利用lambda表达式
- en: In this recipe, you will learn how to apply a lambda expression to your code.
    We will get back to the demo application and modify it by introducing a lambda
    where it makes sense.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何将lambda表达式应用到你的代码中。我们将回到演示应用，并通过引入lambda表达式来修改它，使其变得有意义。
- en: Getting ready
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Equipped with functional interfaces, lambda expressions, and the best practices
    of a lambda-friendly API design, we can substantially improve our speed-calculating
    application by making its design more flexible and user friendly. Let's set up
    some background, the motivation, and the infrastructure as close to a real-life
    problem as possible without making it too complex.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配备函数式接口、lambda表达式和lambda友好的API设计最佳实践，我们可以显著提高我们的速度计算应用，使其设计更加灵活和用户友好。让我们尽可能接近现实生活中的问题来设置一些背景、动机和基础设施，同时不要让它过于复杂。
- en: 'The driverless cars and related problems are on the front pages today, and
    there is a good reason to believe it is going be this way for quite some time.
    One of the tasks in this domain is the analysis and modeling of the traffic flow
    in an urban area based on real data. A lot of such data already exists and will
    continue to be collected in future. Let''s assume that we have access to such
    a database by date, time, and geographical location. Let''s also assume that the
    traffic data from this database comes in units, each capturing details about one
    vehicle and its driving conditions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 无人驾驶汽车和相关问题现在是头条新闻，有很好的理由相信这种情况将持续相当长一段时间。这个领域的一个任务是基于真实数据分析和建模城市地区的交通流量。已经存在大量此类数据，并且未来还将继续收集。让我们假设我们通过日期、时间和地理位置可以访问这样的数据库。让我们还假设从这个数据库中来的交通数据以单元为单位，每个单元都捕捉到一辆车及其驾驶条件的详细信息：
- en: '[PRE88]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is where `VehicleType`, `RoadCondition`, and `TireCondition` are `enum`
    types we have already constructed in the previous chapter:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`VehicleType`、`RoadCondition`和`TireCondition`是我们已经在上一章中构建的`enum`类型：
- en: '[PRE89]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The interface of accessing traffic data may look like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 访问交通数据的接口可能看起来像这样：
- en: '[PRE90]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'So the possible call could be done as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可能的调用可以这样进行：
- en: '[PRE91]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This is where `17` refers to an hour of the day (5 p.m.), and `Main1035` is
    a traffic light identification, or the call can request multiple results as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`17`指的是一天中的某个小时（下午5点），而`Main1035`是交通灯识别，或者调用可以请求多个结果，如下所示：
- en: '[PRE92]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Where `20` is the number of the requested units of traffic.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`20`是请求的交通单元数量。
- en: As you can see, such a traffic factory provides data about traffic in a particular
    location at a particular time (between 5 p.m. and 6 p.m. in our example). Each
    call to the factory yields a different result, while the list of traffic units
    describes statistically correct data (including the most probable weather conditions)
    in the specified location.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这样的交通工厂提供了特定地点特定时间（以我们的例子中的下午5点到6点为例）的交通数据。每次调用工厂都会产生不同的结果，而交通单元列表描述了指定地点的统计正确数据（包括最可能的天气条件）。
- en: 'We will also change the interfaces of `FactoryVehicle` and `FactorySpeedModel` so
    they could build `Vehicle` and `SpeedModel` based on the `TrafficUnit` interface.
    The resulting demo code is as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更改`FactoryVehicle`和`FactorySpeedModel`的接口，以便它们可以根据`TrafficUnit`接口构建`Vehicle`和`SpeedModel`。生成的示例代码如下：
- en: '[PRE93]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Where method `printResult()` has the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`printResult()`方法具有以下代码：
- en: '[PRE94]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of this code may look like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可能看起来像这样：
- en: '![](img/ecdb20f0-5281-4fdf-80bd-bb6ac0dade0e.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecdb20f0-5281-4fdf-80bd-bb6ac0dade0e.png)'
- en: Since we use the "real" data now, every run of this program produces a different
    result, based on the statistical properties of the data. In a certain location,
    a car or dry weather would appear more often at that date and time, while in another
    location, a truck or snow would be more typical.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在使用的是“真实”数据，因此每次运行此程序都会产生不同的结果，这取决于数据的统计特性。在某个地点，在特定日期和时间，汽车或干燥天气可能会更频繁地出现，而在另一个地点，卡车或雪可能会更典型。
- en: 'In this run, the traffic unit brought a wet road, new tires, and `Truck` with
    such an engine power and load that in 10 seconds it was able to reach the speed
    of 22 mph. The formula which we used to calculate the speed (inside an object
    of `SpeedModel`) is familiar to you:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次运行中，交通单元带来了一条湿滑的道路、新轮胎，以及具有这样发动机功率和负载的`Truck`，在10秒内它能够达到22英里/小时的速度。我们用来计算速度的公式（在`SpeedModel`对象内部）对您来说应该是熟悉的：
- en: '[PRE95]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here, the `traction` value comes from `TrafficUnit` (see its interface we just
    discussed). In the class that implements the `TrafficUnit` interface, the method
    `getTraction()` looks like the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`traction`值来自`TrafficUnit`（参见我们刚才讨论的其接口）。在实现`TrafficUnit`接口的类中，`getTraction()`方法看起来如下：
- en: '[PRE96]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The methods `getRoadCondition()` and `getTireCondition()` return the elements
    of the corresponding `enum` types we just described.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRoadCondition()`和`getTireCondition()`方法返回我们刚才描述的相应`enum`类型的元素。'
- en: Now we are ready to improve our speed-calculating application using the new
    features of Java we discussed in the previous recipes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用之前菜谱中讨论的Java新特性来改进我们的速度计算应用程序。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to learn how to use lambda expressions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用lambda表达式：
- en: 'Let''s start building an API. We will call it `Traffic`. Without using functional
    interfaces, it might look like this:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始构建一个API。我们将称之为`Traffic`。不使用功能接口，它可能看起来像这样：
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Its implementation may be as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现可能如下所示：
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now let''s write sample code that uses this interface:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写使用此接口的示例代码：
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We get results similar to the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下类似的结果：
- en: '![](img/61d60df2-8a6c-4572-a6de-5d40af385cff.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61d60df2-8a6c-4572-a6de-5d40af385cff.png)'
- en: As mentioned before, since we are using real data, the same code does not produce
    exactly the same result every time. One should not expect to see the speed values
    as in the preceding screenshot but something that looks very similar instead.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于我们使用的是真实数据，相同的代码每次并不产生完全相同的结果。不应该期望看到与前面的截图中的速度值相同，而应该看到非常相似的结果。
- en: 'Let''s use a lambda expression. The preceding API is quite limited. For example,
    it does not allow you to test different speed calculation formulas without changing
    `FactorySpeedModel`. Meanwhile, the `SpeedModel` interface has only one abstract
    method called `getSpeedMph()`:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用lambda表达式。前面的API相当有限。例如，它不允许你在不更改`FactorySpeedModel`的情况下测试不同的速度计算公式。同时，`SpeedModel`接口只有一个名为`getSpeedMph()`的抽象方法：
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This makes it a functional interface, and we can take advantage of this fact
    and add another method to our API that is able to accept the `SpeedModel` implementation
    as a lambda expression:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这使其成为一个功能接口，我们可以利用这一事实，并添加另一个方法到我们的API中，该方法能够接受`SpeedModel`实现作为lambda表达式：
- en: '[PRE101]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The problem though is that the `traction` value does not come as a parameter
    to the `getSpeedMph()` method, so we cannot implement it as a function before
    passing it to our API method. Look closer at the speed calculation:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于`牵引力`值并不是作为参数传递给`getSpeedMph()`方法的，因此我们无法在将其传递给我们的API方法之前将其实现为一个函数。更仔细地看看速度计算：
- en: '[PRE102]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When you do this, you notice that `traction` acts as a simple multiplier to
    the value of `speed`, so we can apply it after the speed calculation (and avoid
    calling `FactorySpeedModel`):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会注意到`牵引力`作为`速度`值的简单乘数，因此我们可以在速度计算之后应用它（并避免调用`FactorySpeedModel`）：
- en: '[PRE103]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This change allows the API users to pass `SpeedModel` as a function:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改允许API用户将`SpeedModel`作为函数传递：
- en: '[PRE104]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The result of this code is the same as `SpeedModel` generated by `FactorySpeedModel`.
    But now the API users can come up with their own speed-calculating function. For
    example, they can write the following:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码的结果与`FactorySpeedModel`生成的`SpeedModel`相同。但现在API用户可以提出他们自己的速度计算函数。例如，他们可以编写以下内容：
- en: '[PRE105]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The result will be as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/f1b90891-2535-41cc-b37c-3eef5007afc1.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1b90891-2535-41cc-b37c-3eef5007afc1.png)'
- en: Annotate the `SpeedModel` interface as `@FunctionalInterface`, so everybody
    who tries to add another method to it would be dutifully warned and would not
    be able to add another abstract method without removing this annotation and being
    aware of the risk of breaking the code of the existing clients that have implemented
    this functional interface already.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SpeedModel`接口注释为`@FunctionalInterface`，这样任何试图向其中添加另一个方法的人都会得到忠告，并且在没有移除此注释并意识到破坏已实现此功能接口的现有客户端代码的风险的情况下，将无法添加另一个抽象方法。
- en: Improve the API by adding various criteria that slice all of the possible traffic
    into segments.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加各种标准，将所有可能的流量切割成各个部分，来改进API。
- en: 'For example, API users might want to analyze only cars, trucks, cars that have
    an engine bigger than 300 horsepower, trucks with an engine bigger than 400 horsepower,
    and so on. The traditional way to accomplish this would be by creating methods
    such as these:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，API用户可能只想分析汽车、卡车、发动机功率大于300马力的汽车、发动机功率大于400马力的卡车等等。完成此任务的传统方法可能是创建如下方法：
- en: '[PRE106]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Instead, we can just add standard functional interfaces to the existing method
    and let the API user decide which slice of traffic to extract:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只需向现有方法添加标准功能接口，并让API用户决定提取哪部分流量：
- en: '[PRE107]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The implementation would look like as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来可能如下所示：
- en: '[PRE108]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The API users can call it, for example, as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: API用户可以像以下这样调用它：
- en: '[PRE109]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The results are now limited to the cars with an engine smaller than 250 hp
    and trucks with an engine smaller than 400 hp:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果仅限于发动机功率小于250马力的汽车和发动机功率小于400马力的卡车：
- en: '![](img/f3af413f-cd39-410d-ad62-574945845fac.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3af413f-cd39-410d-ad62-574945845fac.png)'
- en: 'In fact, an API user can now apply any criteria for limiting the traffic as
    long as they are applicable to the values in the `TrafficUnit` object. A user
    can write, for example, the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，API用户现在可以应用任何适用于`TrafficUnit`对象中值的限制标准。例如，用户可以编写以下内容：
- en: '[PRE110]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Alternatively, they can write any other combination of limits on the values
    that come from `TrafficUnit`. If a user decides to remove the limit and analyze
    all of the traffic, this code will do it too:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可以编写任何其他来自`TrafficUnit`的值限制的组合。如果用户决定移除限制并分析所有交通，此代码也将执行此操作：
- en: '[PRE111]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Allow including the value of the calculated speed in the list of the criteria.
    One way to do this is to change the implementation this way:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许将计算出的速度值包含在标准中。一种方法是将实现更改如下：
- en: '[PRE112]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The API would then look like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API将看起来像这样：
- en: '[PRE113]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The client code may be as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码可能如下所示：
- en: '[PRE114]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This example limits traffic by the speed that exceeds a different cushion in
    different driving conditions. If needed, it can disregard the speed at all and
    limit traffic exactly the same way the previous predicate did. The only drawback
    of this implementation is that it is slightly less efficient because the predicate
    is applied after the speed calculations. This means that the speed calculation
    will be done for each generated traffic unit, not to a limited number, as in the
    previous implementation. If this is a concern, you might leave all the different
    signatures in the API:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过超出不同驾驶条件下不同缓冲区的速度来限制交通。如果需要，它可以完全忽略速度，并以与先前谓词相同的方式限制交通。这种实现的唯一缺点是它稍微不太高效，因为谓词是在速度计算之后应用的。这意味着速度计算将针对每个生成的交通单元进行，而不是像先前实现中那样限制在有限的数量。如果这是一个问题，你可以在API中保留所有不同的签名：
- en: '[PRE115]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Once you leave them, let the user decide which of the methods to use, more flexible
    or more efficient (if the default speed calculation implementation is acceptable).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你离开它们，让用户决定使用哪种方法，更灵活还是更高效（如果默认的速度计算实现是可以接受的）。
- en: There's more...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'So far, we did not leave the API user a choice of the output format. Currently,
    it is implemented as the method `printResult()`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有给API用户提供输出格式的选择。目前，它实现为`printResult()`方法：
- en: '[PRE116]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To make it more flexible, we can add another parameter to our API:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加灵活，我们可以在我们的API中添加另一个参数：
- en: '[PRE117]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Notice that we take the `timeSec` value not as one of the function parameters,
    but from the enclosed scope of the function. We can do this because it remains
    constant (and can be effectively final) throughout the calculations. In the same
    manner, we can add any other object to the `output` function--a filename or another
    output device, for example--thus leaving all the output-related decisions to the
    API user. To accommodate this new function, the API implementation changes to
    the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是将`timeSec`值作为函数参数之一，而是从函数的封闭作用域中获取。我们可以这样做，因为它在整个计算过程中保持不变（并且可以有效地视为final）。以同样的方式，我们可以将任何其他对象添加到`output`函数中——例如，一个文件名或另一个输出设备——从而将所有与输出相关的决策留给API用户。为了适应这个新函数，API实现改为以下：
- en: '[PRE118]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: It took us a while to come to this point where the power of functional programming
    starts shining and justifying the effort of learning it. Yet, in conjunction with
    Reactive Streams, described in the next chapter, this Java addition yields even
    more power. In the next chapter, the motivation for this enhancement becomes even
    more apparent and fully appreciated.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很长时间才达到这个点，即函数式编程的力量开始闪耀并证明学习它的努力是值得的。然而，结合下一章中描述的响应式流，这个Java新增功能带来了更多的力量。在下一章中，这种增强的动机变得更加明显和完全得到认可。
- en: See also
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [Chapter 5](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml), *Stream Operations
    and Pipelines*
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第5章 [Stream Operations and Pipelines](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml)，*流操作和管道*
