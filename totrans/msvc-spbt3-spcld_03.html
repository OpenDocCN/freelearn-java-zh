<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer085" class="Basic-Text-Frame">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-88" class="chapterTitle">Creating a Set of Cooperating Microservices</h1>
    <p class="normal">In this chapter, we will build our first couple of microservices. We will learn how to create cooperating microservices with minimalistic functionality. In upcoming chapters, we will add more and more functionality to these microservices. By the end of this chapter, we will have a RESTful API exposed by a composite microservice. The composite microservice will call three other microservices using their RESTful APIs to create an aggregated response.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Introducing the microservice landscape</li>
      <li class="bulletList">Generating skeleton microservices</li>
      <li class="bulletList">Adding RESTful APIs</li>
      <li class="bulletList">Adding a composite microservice</li>
      <li class="bulletList">Adding error handling</li>
      <li class="bulletList">Testing the APIs manually</li>
      <li class="bulletList">Adding automated tests of microservices in isolation</li>
      <li class="bulletList">Adding semi-automated tests to a microservice landscape</li>
    </ul>
    <h1 id="_idParaDest-89" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install tools used in this book and how to access the source code for this book, see the following:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter03</code>. With the tools and source code in place, we can start learning about the system landscape of microservices that we will create in this chapter.</p>
    <h1 id="_idParaDest-90" class="heading-1">Introducing the microservice landscape</h1>
    <p class="normal">In <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, we were briefly introduced to the microservice-based system<a id="_idIndexMarker179"/> landscape that we will use throughout this book:</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_01.png" alt="Diagram  Description automatically generated" width="877" height="309"/></figure>
    <p class="packt_figref">Figure 3.1: The microservice landscape</p>
    <p class="normal">It consists of three core microservices, the <strong class="keyWord">product, review</strong>, and <strong class="keyWord">recommendation</strong> services, all of which deal with one type of resource, and a composite <a id="_idIndexMarker180"/>microservice called the <strong class="keyWord">Product Composite</strong> service, which aggregates information from the three core services.</p>
    <h2 id="_idParaDest-91" class="heading-2">Information handled by the microservices</h2>
    <p class="normal">To keep the source code examples in this book easy to understand, they have a minimal amount of business logic. The information model for the business objects they process is kept minimal for the same reason. In this section, we will go through the information that’s handled by <a id="_idIndexMarker181"/>each microservice, including infrastructure-related information.</p>
    <h3 id="_idParaDest-92" class="heading-3">The product service</h3>
    <p class="normal">The product service manages<a id="_idIndexMarker182"/> product information and describes each product with the following attributes:</p>
    <ul>
      <li class="bulletList">Product ID</li>
      <li class="bulletList">Name</li>
      <li class="bulletList">Weight</li>
    </ul>
    <h3 id="_idParaDest-93" class="heading-3">The review service</h3>
    <p class="normal">The review service <a id="_idIndexMarker183"/>manages product reviews and stores the following information about each review:</p>
    <ul>
      <li class="bulletList">Product ID</li>
      <li class="bulletList">Review ID</li>
      <li class="bulletList">Author</li>
      <li class="bulletList">Subject</li>
      <li class="bulletList">Content</li>
    </ul>
    <h3 id="_idParaDest-94" class="heading-3">The recommendation service</h3>
    <p class="normal">The recommendation service manages product recommendations and stores the following information <a id="_idIndexMarker184"/>about each recommendation:</p>
    <ul>
      <li class="bulletList">Product ID</li>
      <li class="bulletList">Recommendation ID</li>
      <li class="bulletList">Author</li>
      <li class="bulletList">Rate</li>
      <li class="bulletList">Content</li>
    </ul>
    <h3 id="_idParaDest-95" class="heading-3">The product composite service</h3>
    <p class="normal">The product composite service aggregates information from the three core services and presents<a id="_idIndexMarker185"/> information about a product as follows:</p>
    <ul>
      <li class="bulletList">Product information, as described in the product service</li>
      <li class="bulletList">A list of product reviews for the specified product, as described in the review service</li>
      <li class="bulletList">A list of product recommendations for the specified product, as described in the recommendation service</li>
    </ul>
    <h3 id="_idParaDest-96" class="heading-3">Infrastructure-related information</h3>
    <p class="normal">Once we start to run our<a id="_idIndexMarker186"/> microservices as containers that are managed by the infrastructure (first Docker and later on Kubernetes), it will be of interest to track which containers actually responded to our requests. As a simple solution, a <code class="inlineCode">serviceAddress</code> attribute has been added to all responses, formatted as <code class="inlineCode">hostname/ip-address:port</code>.</p>
    <div class="packt_tip">
      <p class="normal">In <em class="chapterRef">Chapter 18</em>, <em class="italic">Using a Service Mesh to Improve Observability and Management</em>, and <em class="chapterRef">Chapter 19</em>, <em class="italic">Centralized Logging with the EFK Stack</em>, we will learn about more powerful solutions to track requests that are processed by the microservices.</p>
    </div>
    <h2 id="_idParaDest-97" class="heading-2">Temporarily replacing service discovery</h2>
    <p class="normal">Since, at this stage, we<a id="_idIndexMarker187"/> don’t have any service discovery mechanism in place, we will run all microservices on <code class="inlineCode">localhost</code> and use hardcoded port numbers for each microservice. We will use the following ports:</p>
    <ul>
      <li class="bulletList">The product composite service: <code class="inlineCode">7000</code></li>
      <li class="bulletList">The product service: <code class="inlineCode">7001</code></li>
      <li class="bulletList">The review service: <code class="inlineCode">7002</code></li>
      <li class="bulletList">The recommendation service: <code class="inlineCode">7003</code></li>
    </ul>
    <div class="packt_tip">
      <p class="normal">We will get rid of the hardcoded ports later when we start using Docker and Kubernetes!</p>
    </div>
    <p class="normal">In this section, we have been introduced to the microservices we are going to create and the information <a id="_idIndexMarker188"/>that they will handle. In the next section, we will use Spring Initializr to create skeleton code for the microservices.</p>
    <h1 id="_idParaDest-98" class="heading-1">Generating skeleton microservices</h1>
    <p class="normal">Now it’s time to see how we can create projects for our microservices. The final result for this topic can be found in the <code class="inlineCode">$BOOK_HOME/Chapter03/1-spring-init</code> folder. To simplify setting up the projects, we will use <strong class="keyWord">Spring Initializr</strong> to generate a skeleton<a id="_idIndexMarker189"/> project for each microservice. A skeleton project contains the necessary files for building the project, along with an empty <code class="inlineCode">main</code> class and test class for the microservice. After that, we will see how we can build all our microservices with one command using multi-project builds in the build tool that we will use, Gradle.</p>
    <h2 id="_idParaDest-99" class="heading-2">Using Spring Initializr to generate skeleton code</h2>
    <p class="normal">To get started with developing our microservices, we will use a tool called Spring Initializr to generate skeleton <a id="_idIndexMarker190"/>code for us. Spring Initializr is provided by the Spring team and can be used to configure and generate new Spring Boot applications. The tool helps developers to choose <a id="_idIndexMarker191"/>additional Spring modules to be used by the application and ensures that dependencies are configured to use compatible versions of the selected modules. The tool supports the use of either Maven or Gradle as a build system and can generate source code for either Java, Kotlin, or Groovy.</p>
    <p class="normal">It can either be invoked from a web browser using the URL <a href="https://start.spring.io/"><span class="url">https://start.spring.io/</span></a> or using a <a id="_idIndexMarker192"/>command-line tool, <code class="inlineCode">spring init</code>. To make it easier to reproduce the creation of the microservices, we will use the command-line tool.</p>
    <p class="normal">For each microservice, we will create a Spring Boot project that does the following:</p>
    <ul>
      <li class="bulletList">Uses Gradle as a build tool</li>
      <li class="bulletList">Generates code for Java 8</li>
      <li class="bulletList">Packages the project as a fat JAR file</li>
      <li class="bulletList">Brings in dependencies for the <code class="inlineCode">Actuator</code> and <code class="inlineCode">WebFlux</code> Spring modules</li>
      <li class="bulletList">Is based on Spring Boot v3.0.4 (which depends on Spring Framework v6.0.6)</li>
    </ul>
    <div class="note">
      <p class="normal"><strong class="keyWord">Spring Boot Actuator</strong> enables a number of <a id="_idIndexMarker193"/>valuable endpoints for management and monitoring. We will see them in action later on. <strong class="keyWord">Spring WebFlux</strong> will be used here to create our RESTful APIs.</p>
    </div>
    <p class="normal">To create the skeleton code <a id="_idIndexMarker194"/>for our microservices, we <a id="_idIndexMarker195"/>need to run the following command for <code class="inlineCode">product-service</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">spring init \
--boot-version=3.0.4 \
--type=gradle-project \
--java-version=17 \
--packaging=jar \
--name=product-service \
--package-name=se.magnus.microservices.core.product \
--groupId=se.magnus.microservices.core.product \
--dependencies=actuator,webflux \
--version=1.0.0-SNAPSHOT \
product-service
</code></pre>
    <div class="packt_tip">
      <p class="normal">If you want to learn more about the <code class="inlineCode">spring init</code> CLI, you can run the <code class="inlineCode">spring help init</code> command. To see what dependencies you can add, run the <code class="inlineCode">spring init --list</code> command.</p>
    </div>
    <p class="normal">If you want to create the four projects on your own instead of using the source code in this book’s GitHub repository, try out <code class="inlineCode">$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash</code>, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir some-temp-folder
cd some-temp-folder
<span class="hljs-con-meta">$</span>BOOK_HOME/Chapter03/1-spring-init/create-projects.bash
</code></pre>
    <p class="normal">After creating our four projects using <code class="inlineCode">create-projects.bash</code>, we will have the following file structure:</p>
    <pre class="programlisting code"><code class="hljs-code">microservices/
├── product-composite-service 
├── product-service
├── recommendation-service
└── review-service
</code></pre>
    <p class="normal">For each project, we can<a id="_idIndexMarker196"/> list the created files. Let’s do <a id="_idIndexMarker197"/>this for the <code class="inlineCode">product-service</code> project:</p>
    <pre class="programlisting con"><code class="hljs-con">find microservices/product-service -type f
</code></pre>
    <p class="normal">We will receive the following output:</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_02.png" alt="Text  Description automatically generated" width="878" height="250"/></figure>
    <p class="packt_figref">Figure 3.2: Listing the files we created for product-service</p>
    <p class="normal">Spring Initializr created a number of files for Gradle, a <code class="inlineCode">.gitignore</code> file, and three Spring Boot files:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ProductServiceApplication.java</code>, our main application class</li>
      <li class="bulletList"><code class="inlineCode">application.properties</code>, an empty property file</li>
      <li class="bulletList"><code class="inlineCode">ProductServiceApplicationTests.java</code>, a test class that’s been configured to run tests on our Spring Boot application using JUnit</li>
    </ul>
    <p class="normal">The <code class="inlineCode">main</code> application class, <code class="inlineCode">ProductServiceApplication.java</code>, looks as we’d expect based on the <em class="italic">The magic @SpringBootApplication annotation</em> section in the previous chapter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.microservices.core.product;
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceApplication</span> {
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
      SpringApplication.run(ProductServiceApplication.class, args);
   }
}
</code></pre>
    <p class="normal">The test class looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.microservices.core.product;
<span class="code-highlight"><strong class="hljs-meta-slc">@SpringBootTest</strong></span>
<span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceApplicationTests</span> {
   <span class="hljs-meta">@Test</span>
   <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> {
   }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">@SpringBootTest</code> annotation will initialize our application in the same way that <code class="inlineCode">@SpringBootApplication</code> does when running the application; that is, the Spring application <a id="_idIndexMarker198"/>context will be set up<a id="_idIndexMarker199"/> before the tests are executed using component scanning and auto-configuration, as described in the previous chapter.</p>
    <p class="normal">Let’s also look at the most important Gradle file, <code class="inlineCode">build.gradle</code>. The content of this file describes how to build the project – for example, how to resolve dependencies and compile, test, and package the source code. The Gradle file starts by listing what plugins to apply:</p>
    <pre class="programlisting code"><code class="hljs-code">plugins {
    id <span class="hljs-string">'java'</span>
    id <span class="hljs-string">'org.springframework.boot'</span> version <span class="hljs-string">'3.0.4'</span>
    id <span class="hljs-string">'io.spring.dependency-management'</span> version <span class="hljs-string">'</span><span class="hljs-string">1.1.0'</span>
}
</code></pre>
    <p class="normal">The declared plugins are used as follows:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">java</code> plugin adds the Java compiler to the project.</li>
      <li class="bulletList">The plugins <code class="inlineCode">org.springframework.boot</code> and <code class="inlineCode">io.spring.dependency-management</code> are declared, which together ensure that Gradle will build a fat JAR file and that we don’t need to specify any explicit version numbers on our Spring Boot starter dependencies. Instead, they are implied by the version of the <code class="inlineCode">org.springframework.boot</code> plugin, that is, 3.0.4.</li>
    </ul>
    <p class="normal">In the rest of the build file, we <a id="_idIndexMarker200"/>basically declare a group name and version for our project, Java version, and its dependencies:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">group</strong></span> = <span class="hljs-string">'se.magnus.microservices.composite.product'</span>
<span class="code-highlight"><strong class="hljs-slc">version</strong></span> = <span class="hljs-string">'1.0.0-SNAPSHOT'</span>
<span class="code-highlight"><strong class="hljs-slc">sourceCompatibility</strong></span> = <span class="hljs-string">'17'</span>
repositories {
    mavenCentral()
}
<span class="code-highlight"><strong class="hljs-slc">dependencies</strong></span> {
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-actuator'</span>
    implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-webflux'</span>
    testImplementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>
    testImplementation <span class="hljs-string">'io.projectreactor:reactor-test'</span>
}
<span class="code-highlight"><strong class="hljs-slc">tasks.named('test') {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    useJUnitPlatform()</strong></span>
<span class="code-highlight"><strong class="hljs-slc">}</strong></span>
</code></pre>
    <p class="normal">Some notes regarding the<a id="_idIndexMarker201"/> dependencies used and the final test declaration:</p>
    <ul>
      <li class="bulletList">Dependencies are, as with the preceding plugins, fetched from the central Maven repository.</li>
      <li class="bulletList">Dependencies are set up as specified in the Actuator and WebFlux modules, along with a couple of useful test dependencies.</li>
      <li class="bulletList">Finally, JUnit is configured to be used to run our tests in the Gradle builds.</li>
    </ul>
    <p class="normal">We can build each microservice separately with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">cd microservices/product-composite-service; ./gradlew build; cd -; \
cd microservices/product-service;           ./gradlew build; cd -; \
cd microservices/recommendation-service;    ./gradlew build; cd -; \
cd microservices/review-service;            ./gradlew build; cd -; 
</code></pre>
    <div class="packt_tip">
      <p class="normal">Note how we <a id="_idIndexMarker202"/>use the <code class="inlineCode">gradlew</code> executables that are created by Spring Initializr; that is, we don’t need to have Gradle installed!</p>
      <p class="normal">The first time we run a command with <code class="inlineCode">gradlew</code>, it will download Gradle automatically. The Gradle version that’s used is determined by the <code class="inlineCode">distributionUrl</code> property in the <code class="inlineCode">gradle/wrapper/gradle-wrapper.properties</code> files.</p>
    </div>
    <h2 id="_idParaDest-100" class="heading-2">Setting up multi-project builds in Gradle</h2>
    <p class="normal">To make it a bit simpler to <a id="_idIndexMarker203"/>build all the microservices with one command, we can set up a multi-project build in Gradle. The steps<a id="_idIndexMarker204"/> are as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we create the <code class="inlineCode">settings.gradle</code> file, which describes what projects Gradle should build:
        <pre class="programlisting con"><code class="hljs-con">cat &lt;&lt;EOF &gt; settings.gradle
include ':microservices:product-service'
include ':microservices:review-service'
include ':microservices:recommendation-service'
include ':microservices:product-composite-service'
EOF
</code></pre>
      </li>
      <li class="numberedList">Next, we copy the Gradle executable files that were generated from one of the projects so that we can reuse them for the multi-project builds:
        <pre class="programlisting con"><code class="hljs-con">cp -r microservices/product-service/gradle .
cp microservices/product-service/gradlew .
cp microservices/product-service/gradlew.bat .
cp microservices/product-service/.gitignore .
</code></pre>
      </li>
      <li class="numberedList">We no longer need the generated Gradle executable files in each project, so we can remove them with the following commands:
        <pre class="programlisting con"><code class="hljs-con">find microservices -depth -name "gradle" -exec rm -rfv "{}" \; 
find microservices -depth -name "gradlew*" -exec rm -fv "{}" \; 
</code></pre>
        <p class="normal">The result should be similar to the code you can find in the folder <code class="inlineCode">$BOOK_HOME/Chapter03/1-spring-init</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Now, we can build all the microservices with one command:
        <pre class="programlisting con"><code class="hljs-con">./gradlew build
</code></pre>
      </li>
    </ol>
    <p class="normal">If you haven’t run the preceding commands, you can simply go to the book’s source <a id="_idIndexMarker205"/>code and build the microservices from<a id="_idIndexMarker206"/> there:</p>
    <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter03/1-spring-init
./gradlew build
</code></pre>
    <p class="normal">This should result in the following output:</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_03.png" alt="Text  Description automatically generated" width="696" height="364"/></figure>
    <p class="packt_figref">Figure 3.3: Output upon successful build</p>
    <p class="normal">With skeleton projects<a id="_idIndexMarker207"/> for the microservices created using Spring Initializr and successfully built using Gradle, we are ready to add some code to the microservices in the next section.</p>
    <div class="note">
      <p class="normal">From a DevOps perspective, a multi-project setup might not be preferred. Instead, to enable each microservice to have its own build and release cycle, setting up a separate build pipeline for each microservice project would probably be preferred. However, for the purposes of this book, we will use the multi-project setup to<a id="_idIndexMarker208"/> make it easier to build and deploy the whole system landscape with a single command.</p>
    </div>
    <h1 id="_idParaDest-101" class="heading-1">Adding RESTful APIs</h1>
    <p class="normal">Now that we <a id="_idIndexMarker209"/>have projects set up for our microservices, let’s add some RESTful APIs to our three core microservices!</p>
    <p class="normal">The final result of this and the remaining topics in this chapter can be found in the <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services</code> folder.</p>
    <p class="normal">First, we will add two projects (<code class="inlineCode">api</code> and <code class="inlineCode">util</code>) that will contain code that is shared by the microservice <a id="_idIndexMarker210"/>projects, and then we will implement the RESTful APIs.</p>
    <h2 id="_idParaDest-102" class="heading-2">Adding an API and a util project</h2>
    <p class="normal">To add an <code class="inlineCode">api</code> project, we need to do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we will set up a <a id="_idIndexMarker211"/>separate Gradle project where we can place our API definitions. We will use Java interfaces in order to describe our RESTful APIs and model classes to describe the data that the API uses in its requests and responses. To describe what types of errors can be returned by the API, a number of exception classes are also defined. Describing a RESTful API in a Java interface instead of directly in the Java class is, to me, a good way of separating the API definition from its implementation. We will further extend this pattern later in this book when we add more API information in the Java interfaces to be exposed in an OpenAPI specification. See <em class="chapterRef">Chapter 5</em>, <em class="italic">Adding an API Description Using OpenAPI</em>, for more information.</li>
    </ol>
    <div class="note">
      <p class="normal">It is debatable whether it is a good practice to store API definitions for a group of microservices in a common API module. It could potentially cause undesired dependencies between the microservices, resulting in monolithic characteristics, for example, causing a more complex and slow development process. To me, it is a good choice for microservices that are part of the same delivery organization, that is, whose releases are governed by the same organization (compare<a id="_idIndexMarker212"/> this to a <strong class="keyWord">bounded context</strong> in <strong class="keyWord">domain-driven design</strong>, where <a id="_idIndexMarker213"/>our microservices are placed in a single bounded context). As already discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, microservices within the same bounded context need to have API definitions that are based on a common information model, so storing these API definitions in the same API module doesn’t add any undesired dependencies.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Next, we will create a <code class="inlineCode">util</code> project that can hold some helper classes that are shared by our microservices, for example, for handling errors in a uniform way.</li>
    </ol>
    <div class="note">
      <p class="normal">Again, from a DevOps perspective, it would be preferable to build all the projects in their own build pipeline and have version-controlled dependencies for the <code class="inlineCode">api</code> and <code class="inlineCode">util</code> projects in the microservice projects, that is, so that each microservice can choose what versions of the <code class="inlineCode">api</code> and <code class="inlineCode">util</code> projects to use. But to keep the build and <a id="_idIndexMarker214"/>deployment steps simple in the context of this book, we will make the <code class="inlineCode">api</code> and <code class="inlineCode">util</code> projects part of the multi-project build.</p>
    </div>
    <h3 id="_idParaDest-103" class="heading-3">The api project</h3>
    <p class="normal">The <code class="inlineCode">api</code> project will be packaged as a library; that is, it won’t have its own <code class="inlineCode">main</code> application class. Unfortunately, Spring Initializr doesn’t support the creation of library projects. Instead, a library project has to be created manually from scratch. The source code for the API project is available at <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services/api</code>.</p>
    <p class="normal">The structure of a library project is the same as for an application project, except that we no longer have<a id="_idIndexMarker215"/> the <code class="inlineCode">main</code> application class, as well as some minor differences in the <code class="inlineCode">build.gradle</code> file. The Gradle plugin <code class="inlineCode">org.springframework.boot</code> is replaced with an <code class="inlineCode">implementation platform</code> section:</p>
    <pre class="programlisting code"><code class="hljs-code">ext {
    springBootVersion = <span class="hljs-string">'3.0.4'</span>
}
dependencies {
    implementation <span class="hljs-title">platform</span><span class="hljs-params">(</span><span class="hljs-string">"org.springframework.boot:spring-boot-dependencies:${springBootVersion}"</span><span class="hljs-params">)</span>
</code></pre>
    <p class="normal">This allows us to retain Spring Boot dependency management while we are replacing the construction of a fat JAR in the build step with the creation of a normal JAR file that only contains the project’s own classes and property files.</p>
    <p class="normal">The Java files in the <code class="inlineCode">api</code> project for our three core microservices are as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">$BOOK_HOME/Chapter03/2-basic-rest-services/api/src/main/java/se/magnus/api/core
├── product
│   ├── Product.java
│   └── ProductService.java
├── recommendation
│   ├── Recommendation.java
│   └── RecommendationService.java
└── review
    ├── Review.java
    └── ReviewService.java
</code></pre>
    <p class="normal">The structure of the Java classes looks very similar for the three core microservices, so we will only go through the source code for the <code class="inlineCode">product</code> service.</p>
    <p class="normal">First, we will look at the <code class="inlineCode">ProductService.java</code> Java interface, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.api.core.product;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ProductService</span> {
    <span class="code-highlight"><strong class="hljs-meta-slc">@GetMapping</strong></span><span class="hljs-meta">(</span>
<span class="hljs-meta">        value    = "/product/{productId}",</span>
<span class="hljs-meta">        produces = "application/json")</span>
     Product <span class="code-highlight"><strong class="hljs-title-slc">getProduct</strong><strong class="hljs-params-slc">(</strong><strong class="hljs-meta-slc">@PathVariable</strong></span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
</code></pre>
    <p class="normal">The Java interface<a id="_idIndexMarker216"/> declaration works as follows:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">product</code> service only exposes one API method, <code class="inlineCode">getProduct()</code> (we will extend the API later in this book, in <em class="chapterRef">Chapter 6, </em><em class="italic">Adding Persistence</em>).</li>
      <li class="bulletList">To map the method to an HTTP <code class="inlineCode">GET</code> request, we use the <code class="inlineCode">@GetMapping</code> Spring annotation, where we specify what URL path the method will be mapped to (<code class="inlineCode">/product/{productId}</code>) and what format the response will be in– in this case, JSON.</li>
      <li class="bulletList">The <code class="inlineCode">{productId}</code> part of the path maps to a path variable named <code class="inlineCode">productId</code>.</li>
      <li class="bulletList">The <code class="inlineCode">productId</code> method parameter is annotated with <code class="inlineCode">@PathVariable</code>, which will map the value that’s passed in the HTTP request to the parameter. For example, an HTTP <code class="inlineCode">GET</code> request to <code class="inlineCode">/product/123</code> will result in the <code class="inlineCode">getProduct()</code> method being called with the <code class="inlineCode">productId</code> parameter set to <code class="inlineCode">123</code>.</li>
    </ul>
    <p class="normal">The method returns a <code class="inlineCode">Product</code> object, a plain POJO-based model class with the member variables corresponding to attributes for <code class="inlineCode">Product</code>, as described at the start of this chapter. <code class="inlineCode">Product.java</code> looks as follows (with constructors and getter methods excluded):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="code-highlight"><strong class="hljs-title-slc">Product</strong></span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> productId;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> weight;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceAddress;
}
</code></pre>
    <div class="note">
      <p class="normal">This type of<a id="_idIndexMarker217"/> POJO class is also known as a <strong class="keyWord">Data Transfer Object</strong> (<strong class="keyWord">DTO</strong>) as it is used to transfer data between the API implementation and the caller of the API. When we get to <em class="chapterRef">Chapter 6</em>, <em class="italic">Adding Persistence</em>, we will look at another type of POJO that can be used to describe how data is stored in the<a id="_idIndexMarker218"/> databases, also known as entity objects.</p>
    </div>
    <p class="normal">The API project also<a id="_idIndexMarker219"/> contains the exception classes <code class="inlineCode">InvalidInputException</code> and <code class="inlineCode">NotFoundException</code>.</p>
    <h3 id="_idParaDest-104" class="heading-3">The util project</h3>
    <p class="normal">The <code class="inlineCode">util</code> project will be<a id="_idIndexMarker220"/> packaged as a library in the same way as the <code class="inlineCode">api</code> project. The source code for the <code class="inlineCode">util</code> project is available at <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services/util</code>. The project contains the following utility classes: <code class="inlineCode">GlobalControllerExceptionHandler</code>, <code class="inlineCode">HttpErrorInfo</code>, and <code class="inlineCode">ServiceUtil</code>.</p>
    <p class="normal">Except for the code in <code class="inlineCode">ServiceUtil.java</code>, these classes are reusable utility classes that we can use to map Java exceptions to proper HTTP status codes, as described in the later section <em class="italic">Adding error handling</em>. The main purpose of <code class="inlineCode">ServiceUtil.java</code> is to find out the hostname, IP address, and port used by the microservice. The class exposes a method, <code class="inlineCode">getServiceAddress()</code>, that can be used by the microservices to find their hostname, IP address, and port, as described in the previous section, <em class="italic">Infrastructure-related information</em>.</p>
    <h2 id="_idParaDest-105" class="heading-2">Implementing our API</h2>
    <p class="normal">Now we can start to implement <a id="_idIndexMarker221"/>our APIs in the core microservices!</p>
    <p class="normal">The implementation looks very similar for the three core microservices, so we will only go through the source code for the <code class="inlineCode">product</code> service. You can find the other files in <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services/microservices</code>. Let’s see how we go about this:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We need to add the <code class="inlineCode">api</code> and <code class="inlineCode">util</code> projects as dependencies to our <code class="inlineCode">build.gradle</code> file, in the <code class="inlineCode">product-service</code> project:
        <pre class="programlisting code"><code class="hljs-code">dependencies {
   implementation <span class="hljs-title">project</span><span class="hljs-params">(</span><span class="hljs-string">':api'</span><span class="hljs-params">)</span>
   implementation <span class="hljs-title">project</span><span class="hljs-params">(</span><span class="hljs-string">':util'</span><span class="hljs-params">)</span>
</code></pre>
      </li>
      <li class="numberedList">To enable Spring Boot’s autoconfiguration feature to detect Spring Beans in the <code class="inlineCode">api</code> and <code class="inlineCode">util</code> projects, we also need to add a <code class="inlineCode">@ComponentScan</code> annotation to<a id="_idIndexMarker222"/> the main application class, which includes the packages of the <code class="inlineCode">api</code> and<code class="inlineCode"> util</code> projects:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ComponentScan("se.magnus")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceApplication</span> {
</code></pre>
      </li>
      <li class="numberedList">Next, we create our service implementation file, <code style="font-weight: bold;" class="codeHighlighted">ProductServiceImpl.java</code>, in order to implement the Java interface, <code style="font-weight: bold;" class="codeHighlighted">ProductService</code>, from the <code style="font-weight: bold;" class="codeHighlighted">api</code> project and annotate the class with <code style="font-weight: bold;" class="codeHighlighted">@RestController</code> so that Spring will call the methods in this class according to the mappings specified in the <code class="inlineCode">Interface</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.microservices.core.product.services;
<span class="code-highlight"><strong class="hljs-meta-slc">@RestController</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductService</span> {
}
</code></pre>
      </li>
      <li class="numberedList">To be able to use the <code class="inlineCode">ServiceUtil</code> class from the <code class="inlineCode">util</code> project, we will inject it into the constructor, as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceUtil serviceUtil;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ProductServiceImpl</span><span class="hljs-params">(ServiceUtil serviceUtil)</span> {
    <span class="hljs-built_in">this</span>.serviceUtil = serviceUtil;
}
</code></pre>
      </li>
      <li class="numberedList">Now, we can implement the API by overriding the <code class="inlineCode">getProduct()</code> method from the interface in the <code class="inlineCode">api</code> project:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(productId, <span class="hljs-string">"name-"</span> + productId, <span class="hljs-number">123</span>, 
 serviceUtil.getServiceAddress());
}
</code></pre>
        <p class="normal">Since we aren’t currently using a database, we simply return a hardcoded response based on the input of <code class="inlineCode">productId</code>, along with the service address supplied by the <code class="inlineCode">ServiceUtil</code> class.</p>
        <p class="normal">For the final result, including logging and error handling, see <code class="inlineCode">ProductServiceImpl.java</code>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Finally, we also need to <a id="_idIndexMarker223"/>set up some runtime properties – what port to use and the desired level of logging. This is added to the property file <code class="inlineCode">application.yml</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">server.port:</span> <span class="hljs-number">7001</span>
<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">root:</span> <span class="hljs-string">INFO</span>
    <span class="hljs-attr">se.magnus.microservices:</span> <span class="hljs-string">DEBUG</span>
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Note that the empty <code class="inlineCode">application.properties</code> file generated by Spring Initializr has been replaced by a YAML file, <code class="inlineCode">application.yml</code>. YAML files provide better support for grouping related properties compared to <code class="inlineCode">.properties</code> files. See the log level setting above as an example.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">We can try out the <code class="inlineCode">product</code> service on its own. Build and start the microservice with the following commands:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter03/2-basic-rest-services
./gradlew build
java -jar microservices/product-service/build/libs/*.jar &amp;
</code></pre>
        <p class="normal">Wait until the following is printed in the Terminal:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_03_04.png" alt="Text  Description automatically generated" width="812" height="269"/></figure>
    <figure class="mediaobject">Figure 3.4: Starting ProductServiceApplication</figure>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Make a test call to the <code class="inlineCode">product</code> service:
        <pre class="programlisting con"><code class="hljs-con">curl http://localhost:7001/product/123
</code></pre>
        <p class="normal">It should respond with something similar to the following:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_03_05.png" alt="" role="presentation" width="812" height="82"/></figure>
    <figure class="mediaobject">Figure 3.5: Expected response to test call</figure>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Finally, stop<a id="_idIndexMarker224"/> the <code class="inlineCode">product</code> service:
        <pre class="programlisting con"><code class="hljs-con">kill $(jobs -p)
</code></pre>
      </li>
    </ol>
    <p class="normal">We have now built, run, and tested our first single microservice. In the next section, we will implement the composite microservice that will use the three core microservices we’ve created so far.</p>
    <div class="packt_tip">
      <p class="normal">Starting with Spring Boot v2.5.0, two JAR files are created when running the <code class="inlineCode">./gradlew build</code> command: the ordinary JAR file, plus a plain JAR file containing only the class files resulting from compiling the Java files in the Spring Boot application. Since we don’t need the new plain JAR file, its creation has been disabled to make it possible to refer to the ordinary JAR file using a wildcard when running the Spring Boot application, for example:</p>
      <pre class="programlisting con"><code class="hljs-con">java -jar microservices/product-service/build/libs/*.jar
</code></pre>
      <p class="normal">The creation of the<a id="_idIndexMarker225"/> new plain JAR file has been disabled by adding the following lines to the <code class="inlineCode">build.gradle</code> file for each microservice:</p>
      <pre class="programlisting code"><code class="hljs-code">jar {
    enabled = <span class="hljs-literal">false</span>
}
</code></pre>
      <p class="normal">For further details, see <a href="https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives"><span class="url">https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives</span></a>.</p>
    </div>
    <h1 id="_idParaDest-106" class="heading-1">Adding a composite microservice</h1>
    <p class="normal">Now, it’s time to tie things together by adding the composite service that will call the three core services!</p>
    <p class="normal">The implementation of<a id="_idIndexMarker226"/> the composite services is divided into two parts: an integration component that handles the outgoing HTTP requests to the core services and the composite service implementation itself. The main reason for this division of responsibility is that it simplifies automated unit and integration testing; we can test the service implementation in isolation by replacing the integration component with a mock.</p>
    <div class="packt_tip">
      <p class="normal">As we will see later on in this book, this division of responsibility will also make it easier to introduce a circuit breaker!</p>
    </div>
    <p class="normal">Before we look into the source code of the two components, we need to take a look at the API classes that the composite microservices will use and also learn about how runtime properties are used to hold address information for the core microservices.</p>
    <p class="normal">The full implementation of both the integration component and the implementation of the <a id="_idIndexMarker227"/>composite service can be found in the Java package <code class="inlineCode">se.magnus.microservices.composite.product.services</code>.</p>
    <h2 id="_idParaDest-107" class="heading-2">API classes</h2>
    <p class="normal">In this section, we will take a look at the<a id="_idIndexMarker228"/> classes that describe the API of the composite component. They can be found in <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services/api</code>. The following are the API classes:</p>
    <pre class="programlisting code"><code class="hljs-code">$BOOK_HOME/Chapter03/2-basic-rest-services/api
└── src/main/java/se/magnus/api/composite
    └── product
        ├── ProductAggregate.java
        ├── ProductCompositeService.java
        ├── RecommendationSummary.java
        ├── ReviewSummary.java
        └── ServiceAddresses.java
</code></pre>
    <p class="normal">The Java interface class <code class="inlineCode">ProductCompositeService.java</code> follows the same pattern that’s used by the core services and looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.api.composite.product;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ProductCompositeService</span> {
    <span class="hljs-meta">@GetMapping(</span>
<span class="hljs-meta">        value    = "/product-composite/{productId}",</span>
<span class="hljs-meta">        produces = "application/json")</span>
    ProductAggregate <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-meta">@PathVariable</span><span class="hljs-params"> </span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
</code></pre>
    <p class="normal">The model class <code class="inlineCode">ProductAggregate.java</code> is a bit more complex than the core models since it contains fields for lists of recommendations and reviews:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.api.composite.product;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductAggregate</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> productId;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> weight;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="code-highlight"><strong class="hljs-slc">List&lt;RecommendationSummary&gt; recommendations</strong></span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="code-highlight"><strong class="hljs-slc">List&lt;ReviewSummary&gt; reviews</strong></span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceAddresses serviceAddresses;
</code></pre>
    <p class="normal">The remaining API classes are plain POJO-based model objects and have the same structure as the model <a id="_idIndexMarker229"/>objects for the core APIs.</p>
    <h2 id="_idParaDest-108" class="heading-2">Properties</h2>
    <p class="normal">To avoid hardcoding the address information for the core services into the source code of the <a id="_idIndexMarker230"/>composite microservice, the latter uses a property file where information on how to find the core services is stored. The property file, <code class="inlineCode">application.yml</code>, looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">server.port:</span> <span class="hljs-number">7000</span>
<span class="hljs-attr">app:</span>
  <span class="hljs-attr">product-service:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span>
  <span class="hljs-attr">recommendation-service:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span>
  <span class="hljs-attr">review-service:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">7003</span>
</code></pre>
    <p class="normal">This configuration will, as already noted, be replaced by a service discovery mechanism later on in this book.</p>
    <h2 id="_idParaDest-109" class="heading-2">The integration component</h2>
    <p class="normal">Let’s look at the first part <a id="_idIndexMarker231"/>of the implementation of the composite microservice, the integration component, <code class="inlineCode">ProductCompositeIntegration.java</code>. It is declared as a Spring Bean using the <code class="inlineCode">@Component</code> annotation and implements the three core services’ API interfaces:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.microservices.composite.product.services;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductCompositeIntegration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductService</span>, RecommendationService, ReviewService {
</code></pre>
    <p class="normal">The integration component uses a helper class in the Spring Framework, <code class="inlineCode">RestTemplate</code>, to perform the actual HTTP requests to the core microservices. Before we can inject it into <a id="_idIndexMarker232"/>the integration component, we need to configure it. We do that in the <code class="inlineCode">main</code> application class, <code class="inlineCode">ProductCompositeServiceApplication.java</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RestTemplate</span>();
}
</code></pre>
    <p class="normal">A <code class="inlineCode">RestTemplate</code> object is highly configurable, but we’ll leave it with its default values for now.</p>
    <div class="packt_tip">
      <p class="normal">In the <em class="italic">Spring WebFlux</em> section in <em class="chapterRef">Chapter 2,</em> <em class="italic">Introduction to Spring Boot</em>, we introduced the reactive HTTP client, <code class="inlineCode">WebClient</code>. Using <code class="inlineCode">WebClient</code> instead of <code class="inlineCode">RestTemplate</code> in this chapter would require all source code where <code class="inlineCode">WebClient</code> is used to also be reactive, including the declaration of the RESTful API in the API project and the source code in the composite microservice. In <em class="chapterRef">Chapter 7</em>, <em class="italic">Developing Reactive Microservices</em>, we will learn how to change the implementation of our microservices to follow a reactive programming model. As one of the steps in that update, we will replace the <code class="inlineCode">RestTemplate</code> helper class with the <code class="inlineCode">WebClient</code> class. But until we have learned about reactive development in Spring, we will use the <code class="inlineCode">RestTemplate</code> class.</p>
    </div>
    <p class="normal">We can now inject the <code class="inlineCode">RestTemplate</code>, along with a JSON <code class="inlineCode">mapper</code>, which is used for accessing error messages in case of errors, and the configuration values that we have set up in the property file. Let’s see how this is done:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The objects and configuration values are injected into the constructor as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper mapper;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String productServiceUrl;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String recommendationServiceUrl;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String reviewServiceUrl;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ProductCompositeIntegration</span><span class="hljs-params">(</span>
<span class="hljs-params">  RestTemplate restTemplate,</span>
<span class="hljs-params">  ObjectMapper mapper,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.product-service.host}")</span><span class="hljs-params"> </span>
<span class="hljs-params">  String productServiceHost,</span>
<span class="hljs-params">  </span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.product-service.port}")</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> productServicePort,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.recommendation-service.host}")</span>
<span class="hljs-params">  String recommendationServiceHost,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.recommendation-service.port}")</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> recommendationServicePort,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.review-service.host}")</span>
<span class="hljs-params">  String reviewServiceHost,</span>
<span class="hljs-params">  </span><span class="hljs-meta">@Value("${app.review-service.port}")</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> reviewServicePort</span>
<span class="hljs-params">)</span>
</code></pre>
      </li>
      <li class="numberedList">The body of the <a id="_idIndexMarker233"/>constructor stores the injected objects and builds the URLs based on the injected values, as follows:
        <pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-built_in">this</span>.restTemplate = restTemplate;
  <span class="hljs-built_in">this</span>.mapper = mapper;
  productServiceUrl = <span class="hljs-string">"http://"</span> + productServiceHost + <span class="hljs-string">":"</span> + 
  productServicePort + <span class="hljs-string">"/product/"</span>;
  recommendationServiceUrl = <span class="hljs-string">"</span><span class="hljs-string">http://"</span> + recommendationServiceHost
  + <span class="hljs-string">":"</span> + recommendationServicePort + <span class="hljs-string">"/recommendation?</span>
<span class="hljs-string">  productId="</span>; reviewServiceUrl = <span class="hljs-string">"http://"</span> + reviewServiceHost + 
  <span class="hljs-string">":"</span> + reviewServicePort + <span class="hljs-string">"/review?productId="</span>;
}
</code></pre>
      </li>
      <li class="numberedList">Finally, the integration component implements the API methods for the three core services by using <code style="font-weight: bold;" class="codeHighlighted">RestTemplate</code> to make the actual outgoing calls:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
 <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> productServiceUrl + productId;
 <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="code-highlight"><strong class="hljs-slc">restTemplate</strong></span>.getForObject(url, Product.class);
 <span class="hljs-keyword">return</span> product;
}
<span class="hljs-keyword">public</span> List&lt;Recommendation&gt; <span class="hljs-title">getRecommendations</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> recommendationServiceUrl + productId;
    List&lt;Recommendation&gt; recommendations = 
    <span class="code-highlight"><strong class="hljs-slc">restTemplate</strong></span>.exchange(url, GET, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> 
    <span class="code-highlight"><strong class="hljs-title-slc">ParameterizedTypeReference</strong></span>&lt;List&lt;Recommendation&gt;&gt;() 
    {}).getBody();
    <span class="hljs-keyword">return</span> recommendations;
}
<span class="hljs-keyword">public</span> List&lt;Review&gt; <span class="hljs-title">getReviews</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> reviewServiceUrl + productId;
    List&lt;Review&gt; reviews = <span class="code-highlight"><strong class="hljs-slc">restTemplate</strong></span>.exchange(url, GET, <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">new</span> <span class="code-highlight"><strong class="hljs-title-slc">ParameterizedTypeReference</strong></span>&lt;List&lt;Review&gt;&gt;() {}).getBody();
    <span class="hljs-keyword">return</span> reviews;
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Some interesting <a id="_idIndexMarker234"/>notes regarding the methods implementations:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">For the <code class="inlineCode">getProduct()</code> implementation, the <code class="inlineCode">getForObject()</code> method can be used in <code class="inlineCode">RestTemplate</code>. The expected response is a <code class="inlineCode">Product</code> object. It can be expressed in the call to <code class="inlineCode">getForObject()</code> by specifying the <code class="inlineCode">Product.class</code> class that <code class="inlineCode">RestTemplate</code> will map the JSON response to.</li>
      <li class="numberedList">For the calls to <code class="inlineCode">getRecommendations()</code> and <code class="inlineCode">getReviews()</code>, a more advanced method, <code class="inlineCode">exchange()</code>, has to be used. The reason for this is the automatic mapping from a JSON response to a model class that <code class="inlineCode">RestTemplate</code> performs. The <code class="inlineCode">getRecommendations()</code> and <code class="inlineCode">getReviews()</code> methods expect a generic list in the responses, that is, <code class="inlineCode">List&lt;Recommendation&gt;</code> and <code class="inlineCode">List&lt;Review&gt;</code>. Since generics don’t hold any type of information at runtime, we can’t specify that the methods expect a generic list in their responses. Instead, we can use a helper class from the Spring Framework, <code class="inlineCode">ParameterizedTypeReference</code>, which is designed to resolve this problem by holding the type information at runtime. This means that <code class="inlineCode">RestTemplate</code> can figure out what class to map the JSON responses to. To utilize this helper class, we have to use the more involved <code class="inlineCode">exchange()</code> method instead of the simpler <code class="inlineCode">getForObject()</code> method on <code class="inlineCode">RestTemplate</code>.</li>
    </ol>
    <h2 id="_idParaDest-110" class="heading-2">Composite API implementation</h2>
    <p class="normal">Finally, we will look at the last piece of the implementation of the composite microservice: the<a id="_idIndexMarker235"/> API implementation class <code class="inlineCode">ProductCompositeServiceImpl.java</code>. Let’s go through it step by step:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the same way that we did for the core services, the composite service implements its API interface, <code class="inlineCode">ProductCompositeService</code>, and is annotated with <code class="inlineCode">@RestController</code> to mark it as a REST service:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.microservices.composite.product.services;
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductCompositeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductCompositeService</span> {
</code></pre>
      </li>
      <li class="numberedList">The implementation class requires the <code class="inlineCode">ServiceUtil</code> bean and its own integration component, so they are injected into its constructor:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceUtil serviceUtil;
<span class="hljs-keyword">private</span> ProductCompositeIntegration integration;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ProductCompositeServiceImpl</span><span class="hljs-params">(ServiceUtil serviceUtil, ProductCompositeIntegration integration)</span> {
    <span class="hljs-built_in">this</span>.serviceUtil = serviceUtil;
    <span class="hljs-built_in">this</span>.integration = integration;
}
</code></pre>
      </li>
      <li class="numberedList">Finally, the API method is implemented as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> ProductAggregate <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span> {
    
  <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> integration.getProduct(productId);
  List&lt;Recommendation&gt; recommendations = 
  integration.getRecommendations(productId);
  List&lt;Review&gt; reviews = integration.getReviews(productId);
  
  <span class="hljs-keyword">return</span> <span class="code-highlight"><strong class="hljs-slc">createProductAggregate</strong></span>(product, recommendations,
  reviews, serviceUtil.getServiceAddress());
}
</code></pre>
      </li>
    </ol>
    <p class="normal">The integration component is used to call the three core services, and a helper method, <code class="inlineCode">createProductAggregate()</code>, is used to create a response object of the <code class="inlineCode">ProductAggregate</code> type based on the responses from the calls to the integration component.</p>
    <p class="normal">The implementation <a id="_idIndexMarker236"/>of the helper method, <code class="inlineCode">createProductAggregate()</code>, is quite lengthy and not very important and so has been omitted from this chapter; however, it can be found in this book’s source code.</p>
    <p class="normal">The full implementation of both the integration component and the composite service can be found in the Java package <code class="inlineCode">se.magnus.microservices.composite.product.services</code>.</p>
    <p class="normal">That completes the implementation of the composite microservice from a functional point of view. In the next section, we will see how we handle errors.</p>
    <h1 id="_idParaDest-111" class="heading-1">Adding error handling</h1>
    <p class="normal">Handling errors in a <a id="_idIndexMarker237"/>structured and well-thought-out way is essential in a microservice landscape where a large number of microservices communicate with each other using synchronous APIs, for example, using HTTP and JSON. It is also important to separate protocol-specific handling of errors, such as HTTP status codes, from the business logic.</p>
    <div class="note">
      <p class="normal">It could be argued that a separate layer for the business logic should be added when implementing the microservices. This should ensure that business logic is separated from the protocol-specific code, making it easier both to test and reuse. To avoid unnecessary complexity in the examples provided in this book, we have left out a separate layer for business logic, so the microservices implement their business logic directly in the <code class="inlineCode">@RestController</code> components.</p>
    </div>
    <p class="normal">I have created a set of Java exceptions in the <code class="inlineCode">util</code> project that are used by both the API implementations and the API clients, initially <code class="inlineCode">InvalidInputException</code> and <code class="inlineCode">NotFoundException</code>. Look into the Java package <code class="inlineCode">se.magnus.util.exceptions</code> for details.</p>
    <h2 id="_idParaDest-112" class="heading-2">The global REST controller exception handler</h2>
    <p class="normal">To separate protocol-specific<a id="_idIndexMarker238"/> error handling from the business logic in the REST controllers, that is, the API implementations, I have created a utility class, <code class="inlineCode">GlobalControllerExceptionHandler.java</code>, in the <code class="inlineCode">util</code> project, which is annotated as <code class="inlineCode">@RestControllerAdvice</code>.</p>
    <p class="normal">For each Java exception that the API implementations throw, the utility class has an exception handler method that maps the Java exception to a proper HTTP response, that is, with a proper HTTP status and HTTP response body.</p>
    <p class="normal">For example, if an API implementation class throws <code class="inlineCode">InvalidInputException</code>, the utility class will map it to an HTTP response with the status code set to <code class="inlineCode">422</code> (<code class="inlineCode">UNPROCESSABLE_ENTITY</code>). The following code shows this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@ResponseStatus(</span><span class="code-highlight"><strong class="hljs-meta-slc">UNPROCESSABLE_ENTITY</strong></span><span class="hljs-meta">)</span>
<span class="hljs-meta">@ExceptionHandler(</span><span class="code-highlight"><strong class="hljs-meta-slc">InvalidInputException.class</strong></span><span class="hljs-meta">)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> HttpErrorInfo <span class="hljs-title">handleInvalidInputException</span><span class="hljs-params">(</span>
<span class="hljs-params">    ServerHttpRequest request, InvalidInputException ex)</span> {
    <span class="hljs-keyword">return</span> createHttpErrorInfo(UNPROCESSABLE_ENTITY, request, ex);
}
</code></pre>
    <p class="normal">In the same way, <code class="inlineCode">NotFoundException</code> is mapped to a <code class="inlineCode">404</code> (<code class="inlineCode">NOT_FOUND</code>) HTTP status code.</p>
    <p class="normal">Whenever a REST controller throws any of these exceptions, Spring will use the utility class to create an HTTP response.</p>
    <div class="note">
      <p class="normal">Note that Spring itself returns the HTTP status code <code class="inlineCode">400</code> (<code class="inlineCode">BAD_REQUEST</code>) when it detects an invalid request, for example, if the request contains a non-numeric product ID (<code class="inlineCode">productId</code> is specified as an integer in the API declaration).</p>
    </div>
    <p class="normal">For the full source code of the utility class, see <code class="inlineCode">GlobalControllerExceptionHandler.java</code>.</p>
    <h2 id="_idParaDest-113" class="heading-2">Error handling in API implementations</h2>
    <p class="normal">API implementations use the <a id="_idIndexMarker239"/>exceptions in the <code class="inlineCode">util</code> project to signal errors. They will be reported back to the REST client as HTTPS status codes indicating what went wrong. For example, the <code class="inlineCode">Product</code> microservice implementation class, <code class="inlineCode">ProductServiceImpl.java</code>, uses the <code class="inlineCode">InvalidInputException</code> exception to return an error that indicates invalid input, as well as the <code class="inlineCode">NotFoundException</code> exception to tell us that the product that was asked for does not <a id="_idIndexMarker240"/>exist. The code looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (productId &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="code-highlight"><strong class="hljs-title-slc">InvalidInputException</strong></span>(<span class="hljs-string">"Invalid productId: </span>
<span class="hljs-string">    "</span> + productId);
<span class="hljs-keyword">if</span> (productId == <span class="hljs-number">13</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="code-highlight"><strong class="hljs-title-slc">NotFoundException</strong></span>(<span class="hljs-string">"No product found for </span>
<span class="hljs-string">    productId: "</span> + productId);
</code></pre>
    <div class="packt_tip">
      <p class="normal">Since we currently aren’t using a database, we have to simulate when to throw <code class="inlineCode">NotFoundException</code>.</p>
    </div>
    <h2 id="_idParaDest-114" class="heading-2">Error handling in the API client</h2>
    <p class="normal">The API client, that is, the integration <a id="_idIndexMarker241"/>component of the <code class="inlineCode">Composite</code> microservice, does the reverse; it maps the <code class="inlineCode">422</code> (<code class="inlineCode">UNPROCESSABLE_ENTITY</code>) HTTP status code to <code class="inlineCode">InvalidInputException</code> and the <code class="inlineCode">404</code> (<code class="inlineCode">NOT_FOUND</code>) HTTP status code to <code class="inlineCode">NotFoundException</code>. See the <code class="inlineCode">getProduct()</code> method in <code class="inlineCode">ProductCompositeIntegration.java</code> for the implementation of this error-handling logic. The source code looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">catch</span> (HttpClientErrorException ex) {
    <span class="hljs-keyword">switch</span> (HttpStatus.resolve(ex.getStatusCode().value())) {
    <span class="hljs-keyword">case</span> <span class="code-highlight"><strong class="hljs-slc">NOT_FOUND</strong></span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">NotFoundException</span>(getErrorMessage(ex));
    <span class="hljs-keyword">case</span> <span class="code-highlight"><strong class="hljs-slc">UNPROCESSABLE_ENTITY</strong></span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>(getErrorMessage(ex));
    <span class="hljs-keyword">default</span>:
        LOG.warn(<span class="hljs-string">"Got an unexpected HTTP error: {}, will rethrow it"</span>, 
        ex.getStatusCode());
        LOG.warn(<span class="hljs-string">"Error body: {}"</span>, ex.getResponseBodyAsString());
        <span class="hljs-keyword">throw</span> ex;
    }
}
</code></pre>
    <p class="normal">The error handling for <code class="inlineCode">getRecommendations()</code> and <code class="inlineCode">getReviews()</code> in the integration component is a bit more relaxed – classed as best-effort, meaning that if it succeeds in getting product information but fails to get either recommendations or reviews, it is still considered to be okay. However, a warning is written to the log.</p>
    <p class="normal">For details, see <code class="inlineCode">ProductCompositeIntegration.java</code>.</p>
    <p class="normal">That completes the<a id="_idIndexMarker242"/> implementation of both the code and composite microservices. In the next section, we will test the microservices and the API that they expose.</p>
    <h1 id="_idParaDest-115" class="heading-1">Testing APIs manually</h1>
    <p class="normal">That concludes the<a id="_idIndexMarker243"/> implementation of our microservices. Let’s try them out by performing the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build and start the microservices as background processes.</li>
      <li class="numberedList">Use <code class="inlineCode">curl</code> to call the composite API.</li>
      <li class="numberedList">Stop the microservices.</li>
    </ol>
    <p class="normal">First, build and start up each microservice as a background process, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter03/2-basic-rest-services/
./gradlew build
</code></pre>
    <p class="normal">Once the build completes, we can launch our microservices as background processes to the Terminal process with the following code:</p>
    <pre class="programlisting con"><code class="hljs-con">java -jar microservices/product-composite-service/build/libs/*.jar &amp;
java -jar microservices/product-service/build/libs/*.jar &amp;
java -jar microservices/recommendation-service/build/libs/*.jar &amp;
java -jar microservices/review-service/build/libs/*.jar &amp;
</code></pre>
    <p class="normal">A lot of log messages will be written to the Terminal, but after a few seconds, things will calm down and we will find the following messages written to the log:</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_06.png" alt="Text  Description automatically generated" width="479" height="136"/></figure>
    <p class="packt_figref">Figure 3.6: Log messages after applications start</p>
    <p class="normal">This means that they<a id="_idIndexMarker244"/> are all ready to receive requests. Try this out with the following code:</p>
    <pre class="programlisting con"><code class="hljs-con">curl http://localhost:7000/product-composite/1
</code></pre>
    <p class="normal">After some log output, we will get a JSON response that looks something like the following:</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_07.png" alt="Text  Description automatically generated" width="560" height="295"/></figure>
    <p class="packt_figref">Figure 3.7: JSON response after the request</p>
    <p class="normal">To get the JSON response pretty-printed, you can use the <code class="inlineCode">jq</code> tool:</p>
    <pre class="programlisting con"><code class="hljs-con">curl http://localhost:7000/product-composite/1 -s | jq .
</code></pre>
    <p class="normal">This results in the following output (some details have been replaced by <code class="inlineCode">...</code> for increased readability):</p>
    <figure class="mediaobject"><img src="../Images/B19825_03_08.png" alt="Text  Description automatically generated" width="597" height="233"/></figure>
    <p class="packt_figref">Figure 3.8: Pretty-printed JSON response</p>
    <p class="normal">If you want to, you<a id="_idIndexMarker245"/> can also try out the following commands to verify that the error handling works as expected:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>Verify that a 404 (Not Found) error is returned <span class="hljs-con-keyword">for</span> a non-existing productId (13)
curl http://localhost:7000/product-composite/13 -i
<span class="hljs-con-meta"># </span>Verify that no recommendations are returned <span class="hljs-con-keyword">for</span> productId 113
curl http://localhost:7000/product-composite/113 -s | jq .
<span class="hljs-con-meta"># </span>Verify that no reviews are returned <span class="hljs-con-keyword">for</span> productId 213
curl http://localhost:7000/product-composite/213 -s | jq .
<span class="hljs-con-meta"># </span>Verify that a 422 (Unprocessable Entity) error is returned <span class="hljs-con-keyword">for</span> a productId that is out of range (-1)
curl http://localhost:7000/product-composite/-1 -i
<span class="hljs-con-meta"># </span>Verify that a 400 (Bad Request) error is returned <span class="hljs-con-keyword">for</span> a productId that is not a number, i.e. invalid format
curl http://localhost:7000/product-composite/invalidProductId -i
</code></pre>
    <p class="normal">Finally, you can shut down the microservices with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">kill $(jobs -p)
</code></pre>
    <p class="normal">If you are using an IDE such as Visual Studio Code with Spring Tool Suite, you can use their support for the Spring Boot Dashboard to start and stop your microservices with one click. For instructions on how to install Spring Tool Suite, see <a href="https://github.com/spring-projects/sts4/wiki/Installation"><span class="url">https://github.com/spring-projects/sts4/wiki/Installation</span></a>.</p>
    <p class="normal">The following <a id="_idIndexMarker246"/>screenshot shows the use of the Spring Boot Dashboard in Visual Studio Code:</p>
    <p class="packt_figref"><img src="../Images/B19825_03_09.png" alt="Graphical user interface, text, application  Description automatically generated" width="878" height="549"/></p>
    <p class="packt_figref">Figure 3.9: Spring Boot Dashboard in Visual Studio Code</p>
    <p class="normal">In this section, we have learned how to manually start, test, and stop the system landscape of cooperating microservices. These types of tests are time-consuming, so they clearly need to be automated. </p>
    <p class="normal">In the next two sections, we will take our first steps toward learning how to automate testing, testing both a single microservice in isolation and a whole system landscape of cooperating microservices. Throughout this book, we will improve how we test our microservices.</p>
    <h1 id="_idParaDest-116" class="heading-1">Adding automated microservice tests in isolation</h1>
    <p class="normal">Before we wrap up the implementation, we also need to write some automated tests.</p>
    <p class="normal">We don’t have much<a id="_idIndexMarker247"/> business logic to test at this time, so we don’t need to write any unit tests. Instead, we will focus on testing the APIs that our microservices expose; that is, we will start them up in integration tests with their embedded web server and then use a test client to perform HTTP requests and validate the responses. With Spring WebFlux comes a test client, <code class="inlineCode">WebTestClient</code>, that provides a fluent API for making a request and then applying assertions on its result.</p>
    <p class="normal">The following is an example where we test the composite product API by doing the following tests:</p>
    <ul>
      <li class="bulletList">Sending in <code class="inlineCode">productId</code> for an existing product and asserting that we get back <code class="inlineCode">200</code> as an HTTP response code and a JSON response that contains the requested <code class="inlineCode">productId</code> along with one recommendation and one review</li>
      <li class="bulletList">Sending in a missing <code class="inlineCode">productId</code> and asserting that we get back <code class="inlineCode">404</code> as an HTTP response code and a JSON response that contains relevant error information</li>
    </ul>
    <p class="normal">The implementation for these two tests is shown in the following code. The first test looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> <span class="code-highlight"><strong class="hljs-slc">WebTestClient client</strong></span>;
<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">getProductById</span><span class="hljs-params">()</span> {
  <span class="code-highlight"><strong class="hljs-slc">client</strong></span>.get()
    .uri(<span class="hljs-string">"/product-composite/"</span> + PRODUCT_ID_OK)
    .accept(APPLICATION_JSON_UTF8)
    .exchange()
    .expectStatus().isOk()
    .expectHeader().contentType(APPLICATION_JSON_UTF8)
    .expectBody()
    .jsonPath(<span class="hljs-string">"$.productId"</span>).isEqualTo(PRODUCT_ID_OK)
    .jsonPath(<span class="hljs-string">"$.recommendations.length()"</span>).isEqualTo(<span class="hljs-number">1</span>)
    .jsonPath(<span class="hljs-string">"$.reviews.length()"</span>).isEqualTo(<span class="hljs-number">1</span>);
}
</code></pre>
    <p class="normal">The test code works like this:</p>
    <ul>
      <li class="bulletList">The test uses the fluent <code class="inlineCode">WebTestClient</code> API to set up the URL to call <code class="inlineCode">"/product-composite/" + PRODUCT_ID_OK</code> and specify the accepted response format, JSON.</li>
      <li class="bulletList">After executing the request using the <code class="inlineCode">exchange()</code> method, the test verifies that the response status is <code class="inlineCode">OK</code> (<code class="inlineCode">200</code>) and that the response format actually is JSON (as requested).</li>
      <li class="bulletList">Finally, the test inspects the response body and verifies that it contains the expected information in terms of <code class="inlineCode">productId</code> and the number<a id="_idIndexMarker248"/> of recommendations and reviews.</li>
    </ul>
    <p class="normal">The second test looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getProductNotFound</span><span class="hljs-params">()</span> {
  client.get()
    .uri(<span class="hljs-string">"/product-composite/"</span> + PRODUCT_ID_NOT_FOUND)
    .accept(APPLICATION_JSON_UTF8)
    .exchange()
    <span class="code-highlight"><strong class="hljs-slc">.expectStatus().isNotFound()</strong></span>
    .expectHeader().contentType(APPLICATION_JSON_UTF8)
    .expectBody()
    .jsonPath(<span class="hljs-string">"$.path"</span>).isEqualTo(<span class="hljs-string">"/product-composite/"</span> + 
     PRODUCT_ID_NOT_FOUND)
    <span class="code-highlight"><strong class="hljs-slc">.jsonPath(</strong><strong class="hljs-string-slc">"$.message"</strong><strong class="hljs-slc">).isEqualTo(</strong><strong class="hljs-string-slc">"NOT FOUND: "</strong><strong class="hljs-slc"> + </strong></span>
<span class="code-highlight"><strong class="hljs-slc">     PRODUCT_ID_NOT_FOUND);</strong></span>
}
</code></pre>
    <p class="normal">One important note regarding this test code is:</p>
    <ul>
      <li class="bulletList">This negative test is very similar to the preceding test in terms of its structure; the main difference is that it verifies that it got an error status code back, <code class="inlineCode">Not Found</code> (<code class="inlineCode">404</code>), and that the response body contains the expected error message.</li>
    </ul>
    <p class="normal">To test the composite product API in isolation, we need to mock its dependencies, that is, the requests to the other three microservices that were performed by the integration component, <code class="inlineCode">ProductCompositeIntegration</code>. We use <strong class="keyWord">Mockito</strong> to do this, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="code-highlight"><strong class="hljs-variable-slc">PRODUCT_ID_OK</strong></span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="code-highlight"><strong class="hljs-variable-slc">PRODUCT_ID_NOT_FOUND</strong></span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="code-highlight"><strong class="hljs-variable-slc">PRODUCT_ID_INVALID</strong></span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
<span class="code-highlight"><strong class="hljs-meta-slc">@MockBean</strong></span>
<span class="hljs-keyword">private</span> <span class="code-highlight"><strong class="hljs-slc">ProductCompositeIntegration compositeIntegration</strong></span>;
<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> {
  when(compositeIntegration.getProduct(PRODUCT_ID_OK)).
    thenReturn(<span class="hljs-keyword">new</span> <span class="hljs-title">Product</span>(PRODUCT_ID_OK, <span class="hljs-string">"name"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"mock-address"</span>));
  when(compositeIntegration.getRecommendations(PRODUCT_ID_OK)).
    thenReturn(singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title">Recommendation</span>(PRODUCT_ID_OK, <span class="hljs-number">1</span>, 
    <span class="hljs-string">"author"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"content"</span>, <span class="hljs-string">"mock address"</span>)));
     when(compositeIntegration.getReviews(PRODUCT_ID_OK)).
    thenReturn(singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title">Review</span>(PRODUCT_ID_OK, <span class="hljs-number">1</span>, <span class="hljs-string">"author"</span>, 
    <span class="hljs-string">"subject"</span>, <span class="hljs-string">"content"</span>, <span class="hljs-string">"mock address"</span>)));
  when(compositeIntegration.getProduct(PRODUCT_ID_NOT_FOUND)).
    thenThrow(<span class="hljs-keyword">new</span> <span class="hljs-title">NotFoundException</span>(<span class="hljs-string">"NOT FOUND: "</span> + 
    PRODUCT_ID_NOT_FOUND));
  when(compositeIntegration.getProduct(PRODUCT_ID_INVALID)).
    thenThrow(<span class="hljs-keyword">new</span> <span class="hljs-title">InvalidInputException</span>(<span class="hljs-string">"INVALID: "</span> + 
    PRODUCT_ID_INVALID));
}
</code></pre>
    <p class="normal">The mock implementation <a id="_idIndexMarker249"/>works as follows:</p>
    <ul>
      <li class="bulletList">First, we declare three constants that are used in the test class: <code class="inlineCode">PRODUCT_ID_OK</code>, <code class="inlineCode">PRODUCT_ID_NOT_FOUND</code>, and <code class="inlineCode">PRODUCT_ID_INVALID</code>.</li>
      <li class="bulletList">Next, the annotation <code class="inlineCode">@MockBean</code> is used to configure Mockito to set up a mock for the <code class="inlineCode">ProductCompositeIntegration</code> interface.</li>
      <li class="bulletList">If the <code class="inlineCode">getProduct()</code>, <code class="inlineCode">getRecommendations()</code>, and <code class="inlineCode">getReviews()</code> methods are called on the integration component, and <code class="inlineCode">productId</code> is set to <code class="inlineCode">PRODUCT_ID_OK</code>, the mock will return a normal response.</li>
      <li class="bulletList">If the <code class="inlineCode">getProduct()</code> method is called with <code class="inlineCode">productId</code> set to <code class="inlineCode">PRODUCT_ID_NOT_FOUND</code>, the mock will throw <code class="inlineCode">NotFoundException</code>.</li>
      <li class="bulletList">If the <code class="inlineCode">getProduct()</code> method is called with <code class="inlineCode">productId</code> set to <code class="inlineCode">PRODUCT_ID_INVALID</code>, the mock will throw <code class="inlineCode">InvalidInputException</code>.</li>
    </ul>
    <p class="normal">The full source code for the automated integration tests on the composite product API can be found in the test class <code class="inlineCode">ProductCompositeServiceApplicationTests.java</code>.</p>
    <p class="normal">The automated integration tests on the API exposed by the three core microservices are similar, but simpler since they don’t need to mock anything! The source code for the tests can be found in each microservice’s <code class="inlineCode">test</code> folder.</p>
    <p class="normal">The tests are run<a id="_idIndexMarker250"/> automatically by Gradle when performing a build:</p>
    <pre class="programlisting con"><code class="hljs-con">./gradlew build
</code></pre>
    <p class="normal">You can, however, specify that you only want to run the tests (and not the rest of the build):</p>
    <pre class="programlisting con"><code class="hljs-con">./gradlew test
</code></pre>
    <p class="normal">This was an introduction to how to write automated tests for microservices in isolation. In the next section, we will learn how to write tests that automatically test a microservice landscape. In this chapter, these tests will only be semi-automated. In upcoming chapters, the tests will be fully automated, a significant improvement.</p>
    <h1 id="_idParaDest-117" class="heading-1">Adding semi-automated tests of a microservice landscape</h1>
    <p class="normal">Being able to automatically run unit and integration tests for each microservice in isolation using plain <a id="_idIndexMarker251"/>Java, JUnit, and Gradle is very useful during development, but insufficient when we move over<a id="_idIndexMarker252"/> to the operation side. In operation, we also need a way to automatically verify that a <em class="italic">system landscape</em> of cooperating microservices delivers what we expect. Being able to, at any time, run a script that verifies that a number of cooperating microservices all work as expected in operation is very valuable – the more microservices there are, the higher the value of such a verification script.</p>
    <p class="normal">For this reason, I have written a simple <code class="inlineCode">bash</code> script that can verify the functionality of a deployed system landscape by performing calls to the RESTful APIs exposed by the microservices. It is based on the <code class="inlineCode">curl</code> commands we learned about and used above. The script verifies return codes and parts of the JSON responses using <code class="inlineCode">jq</code>. The script contains two helper functions, <code class="inlineCode">assertCurl()</code> and <code class="inlineCode">assertEqual()</code>, to make the test code compact and easy to read.</p>
    <p class="normal">For example, making a normal request and expecting <code class="inlineCode">200</code> as the status code, as well as asserting that we <a id="_idIndexMarker253"/>get back a JSON response that returns the requested <code class="inlineCode">productId</code> along with three recommendations and three reviews, looks like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Verify that a normal request works, expect three recommendations and three reviews</span>
assertCurl <span class="hljs-number">200</span> <span class="hljs-string">"curl http://$HOST:${PORT}/product-composite/1 -s"</span>
assertEqual <span class="hljs-number">1</span> $(echo $RESPONSE | jq .productId)
assertEqual <span class="hljs-number">3</span> $(echo $RESPONSE | jq <span class="hljs-string">".recommendations | length"</span>)
assertEqual <span class="hljs-number">3</span> $(echo $RESPONSE | jq <span class="hljs-string">".reviews | length"</span>)
</code></pre>
    <p class="normal">Verifying that we get <code class="inlineCode">404 (Not Found)</code> back as an HTTP response code (when we try to look up a product that doesn’t exist) looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Verify that a 404 (Not Found) error is returned for a non-existing productId (13)</span>
assertCurl <span class="hljs-number">404</span> <span class="hljs-string">"curl http://$HOST:${PORT}/product-composite/13 -s"</span> 
</code></pre>
    <p class="normal">The test script, <code class="inlineCode">test-em-all.bash</code>, implements the manual tests that were described in the section <em class="italic">Testing APIs manually</em> and can be found in the top-level folder <code class="inlineCode">$BOOK_HOME/Chapter03/2-basic-rest-services</code>. We will extend the functionality of the test script as we add more functionality to the system landscape in later chapters.</p>
    <div class="packt_tip">
      <p class="normal">In <em class="chapterRef">Chapter 20</em>, <em class="italic">Monitoring Microservices</em>, we will learn about complementary techniques for automatically keeping an eye on a system landscape in operation. Here we will learn about a monitoring tool that continuously monitors the state of the deployed microservices and how alarms can be raised if the collected metrics exceed configured thresholds, such as overuse of CPU or memory.</p>
    </div>
    <h2 id="_idParaDest-118" class="heading-2">Trying out the test script</h2>
    <p class="normal">To try out the test script, perform<a id="_idIndexMarker254"/> the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, start the microservices, as we did previously:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter03/2-basic-rest-services
java -jar microservices/product-composite-service/build/libs/*.jar &amp; 
java -jar microservices/product-service/build/libs/*.jar &amp;
java -jar microservices/recommendation-service/build/libs/*.jar &amp;
java -jar microservices/review-service/build/libs/*.jar &amp;
</code></pre>
      </li>
      <li class="numberedList">Once they’ve all started up, run the test script:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash
</code></pre>
        <p class="normal">Expect the output to look similar to the following:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_03_10.png" alt="Text  Description automatically generated" width="646" height="598"/></figure>
    <p class="packt_figref">Figure 3.10: Output after running the test script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Wrap this up by shutting down the microservices with the following command:
        <pre class="programlisting con"><code class="hljs-con">kill $(jobs -p)
</code></pre>
      </li>
    </ol>
    <p class="normal">In this section, we have taken the first steps toward automating testing for a system landscape of<a id="_idIndexMarker255"/> cooperating microservices, all of which will be improved in upcoming chapters.</p>
    <h1 id="_idParaDest-119" class="heading-1">Summary</h1>
    <p class="normal">We have now built our first few microservices using Spring Boot. After being introduced to the microservice landscape that we will use throughout this book, we learned how to use Spring Initializr to create skeleton projects for each microservice.</p>
    <p class="normal">Next, we learned how to add APIs using Spring WebFlux for the three core services and implemented a composite service that uses the three core services’ APIs to create an aggregated view of the information in them. The composite service uses the <code class="inlineCode">RestTemplate</code> class in the Spring Framework to perform HTTP requests to APIs that are exposed by the core services. After adding logic for error handling to the services, we ran some manual tests on the microservice landscape.</p>
    <p class="normal">We wrapped this chapter up by learning how to add tests for microservices in isolation and when they work together as a system landscape. To provide controlled isolation for the composite service, we mocked its dependencies to the core services using Mockito. Testing the whole system landscape is performed by a Bash script that uses <code class="inlineCode">curl</code> to perform calls to the API of the composite service.</p>
    <p class="normal">With these skills in place, we are ready to take the next step, entering the world of Docker and containers in the next chapter! Among other things, we will learn how to use Docker to fully automate the testing of a system landscape of cooperating microservices.</p>
    <h1 id="_idParaDest-120" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the command that lists available dependencies when you create a new Spring Boot project using the <code class="inlineCode">spring init</code> Spring Initializr CLI tool?</li>
      <li class="numberedList">How can you set up Gradle to build multiple related projects with one command?</li>
      <li class="numberedList">What are the <code class="inlineCode">@PathVariable</code> and <code class="inlineCode">@RequestParam</code> annotations used for?</li>
      <li class="numberedList">How can you separate protocol-specific error handling from the business logic in an API implementation class?</li>
      <li class="numberedList">What is Mockito used for?</li>
    </ol>
  </div>
</div>
</div>
</body></html>