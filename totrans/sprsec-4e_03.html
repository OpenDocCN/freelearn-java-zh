<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-49"><a id="_idTextAnchor068"/>3</h1>
<h1 id="_idParaDest-50"><a id="_idTextAnchor069"/>Custom Authentication</h1>
<p>In <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>, we demonstrated how to use an in-memory datastore to authenticate the user. In this chapter, we’ll explore how to solve some common, real-world problems by extending Spring Security’s authentication support to use our existing set of APIs. Through this exploration, we’ll get an understanding of each of the building blocks that Spring Security uses in order to <span class="No-Break">authenticate users.</span></p>
<p>During this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Leveraging Spring Security’s annotations and <span class="No-Break">Java-based configuration</span></li>
<li>Discovering how to obtain the details of the currently <span class="No-Break">logged-in user</span></li>
<li>Adding the ability to log in after creating a <span class="No-Break">new account</span></li>
<li>Learning the simplest method for indicating to Spring Security that a user <span class="No-Break">is authenticated</span></li>
<li>Creating custom <strong class="source-inline">UserDetailsService</strong> and <strong class="source-inline">AuthenticationProvider</strong> implementations that properly decouple the rest of the application from <span class="No-Break">Spring Security</span></li>
<li>Adding domain-based authentication to demonstrate how to authenticate with more than just a username <span class="No-Break">and password</span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/5tPFD"><span class="No-Break">https://packt.link/5tPFD</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor070"/>Authentication architecture in Spring Security</h1>
<p>The realm of application<a id="_idIndexMarker125"/> security essentially involves addressing two<a id="_idIndexMarker126"/> largely independent issues: authentication (identifying <em class="italic">who you are</em>) and authorization (determining <em class="italic">what you are allowed </em><span class="No-Break"><em class="italic">to do</em></span><span class="No-Break">).</span></p>
<p>Occasionally, individuals may use the term <em class="italic">access control</em> interchangeably with <em class="italic">authorization</em>, adding a layer of <span class="No-Break">potential confusion.</span></p>
<p>However, framing it as <em class="italic">access control</em> can offer clarity, considering the multifaceted use of the term <span class="No-Break"><em class="italic">authorization</em></span><span class="No-Break"> elsewhere.</span></p>
<p>Spring Security adopts an architecture deliberately crafted to segregate authentication from authorization, providing<a id="_idIndexMarker127"/> distinct strategies and extension points for each. We will uncover in this section the main architectural components of Spring Security used <span class="No-Break">for authentication.</span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor071"/>The SecurityContextHolder class</h2>
<p>At the heart of<a id="_idIndexMarker128"/> Spring Security’s <a id="_idIndexMarker129"/>authentication model is the <strong class="source-inline">SecurityContextHolder</strong>. It contains <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">SecurityContext</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 3.1 – Spring Security’s SecurityContextHolder" height="179" src="image/B21757_03_1.jpg" width="486"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Spring Security’s SecurityContextHolder</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor072"/>The SecurityContext interface</h2>
<p><strong class="source-inline">SecurityContextHolder</strong> is where Spring <a id="_idIndexMarker130"/>Security stores the details of who is authenticated. Spring Security does not <a id="_idIndexMarker131"/>care how <strong class="source-inline">SecurityContextHolder</strong> is populated. If it contains a value, it is used as the currently <span class="No-Break">authenticated user.</span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor073"/>The Authentication interface</h2>
<p>The <strong class="bold">Authentication</strong> interface in Spring Security <a id="_idIndexMarker132"/>serves <span class="No-Break">dual purposes:</span></p>
<ul>
<li>It acts as input for <strong class="source-inline">AuthenticationManager</strong>, supplying the user’s provided credentials for authentication. In this context, the method <strong class="source-inline">isAuthenticated()</strong> <span class="No-Break">returns false.</span></li>
<li>It serves as a representation of the<a id="_idIndexMarker133"/> presently authenticated user, retrievable from <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">SecurityContext</strong></span><span class="No-Break">.</span></li>
</ul>
<p>Key components within the <strong class="bold">Authentication</strong> interface include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Principal</strong>: This identifies the user, often represented as an instance of <strong class="source-inline">UserDetails</strong>, especially in <span class="No-Break">username/password authentication.</span></li>
<li><strong class="bold">Credentials</strong>: This typically encompasses a password. In many instances, this information is cleared post-authentication to prevent <span class="No-Break">inadvertent leakage.</span></li>
<li><strong class="bold">Authorities</strong>: This comprises <strong class="source-inline">GrantedAuthority</strong> instances denoting high-level permissions granted to the user. Examples include roles <span class="No-Break">and scopes.</span></li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor074"/>The AuthenticationManager interface</h2>
<p><strong class="source-inline">AuthenticationManager</strong> serves as the<a id="_idIndexMarker134"/> API specifying how authentication is conducted by Spring Security’s Filters. The resulting <a id="_idIndexMarker135"/>authentication is subsequently established on <strong class="source-inline">SecurityContextHolder</strong> by the invoking controller (i.e., Spring Security’s <span class="No-Break"><strong class="source-inline">Filters</strong></span><span class="No-Break"> instances).</span></p>
<p>If you’re not integrating with Spring Security’s <strong class="source-inline">Filters</strong> instances, you have the option to directly set <strong class="source-inline">SecurityContextHolder</strong> without the need <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">AuthenticationManager</strong></span><span class="No-Break">.</span></p>
<p>Although the <strong class="source-inline">AuthenticationManager</strong>’s implementation can vary, the prevalent choice is <span class="No-Break">often </span><span class="No-Break"><strong class="source-inline">ProviderManager</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor075"/>The ProviderManager class</h2>
<p><strong class="source-inline">ProviderManager</strong> stands out as the<a id="_idIndexMarker136"/> frequently employed realization of <strong class="source-inline">AuthenticationManager</strong>. It delegates responsibilities to a list of <strong class="source-inline">AuthenticationProvider</strong> instances. Each <strong class="source-inline">AuthenticationProvider</strong> possesses the capability to express<a id="_idIndexMarker137"/> whether authentication should succeed, fail, or delegate the decision-making to a subsequent <strong class="source-inline">AuthenticationProvider</strong>. In the event that none of the configured <strong class="source-inline">AuthenticationProvider</strong> instances can authenticate, the authentication process results in a <strong class="source-inline">ProviderNotFoundException</strong>. This particular <strong class="source-inline">AuthenticationException</strong> signifies that the <strong class="source-inline">ProviderManager</strong> lacked configuration to support the specific <strong class="bold">authentication</strong> type provided <span class="No-Break">to it.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 3.2 – Spring Security SecurityContextHolder" height="354" src="image/B21757_03_2.jpg" width="728"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Spring Security SecurityContextHolder</p>
<p>In practical terms, every <strong class="source-inline">AuthenticationProvider</strong> is equipped to carry out a distinct authentication method. For instance, one <strong class="source-inline">AuthenticationProvider</strong> may validate a username/password, while another is capable of authenticating a <strong class="source-inline">SAML Assertion</strong>. This setup empowers each <strong class="source-inline">AuthenticationProvider</strong> to handle a specialized form of authentication, accommodating various authentication types and presenting only a singular <span class="No-Break"><strong class="source-inline">AuthenticationManager</strong></span><span class="No-Break"> bean.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 3.3 – Spring Security SecurityContextHolder" height="267" src="image/B21757_03_3.jpg" width="301"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Spring Security SecurityContextHolder</p>
<p>Additionally, <strong class="source-inline">ProviderManager</strong> enables the configuration of an optional parent <strong class="source-inline">AuthenticationManager</strong>. This parent <strong class="source-inline">AuthenticationManager</strong> is consulted when no <strong class="source-inline">AuthenticationProvider</strong> is able to execute authentication. The parent can take on any form of <strong class="source-inline">AuthenticationManager</strong>, with <strong class="source-inline">ProviderManager</strong> frequently being the <a id="_idIndexMarker138"/><span class="No-Break">chosen type.</span></p>
<p>Multiple instances of <strong class="source-inline">ProviderManager</strong> can have a shared parent <strong class="source-inline">AuthenticationManager</strong>. This<a id="_idIndexMarker139"/> occurrence is quite typical in situations where multiple <strong class="source-inline">SecurityFilterChain</strong> instances share a common authentication process (represented by the shared parent <strong class="source-inline">AuthenticationManager</strong>). However, these instances may also employ different authentication mechanisms, each managed by distinct <span class="No-Break"><strong class="source-inline">ProviderManager</strong></span><span class="No-Break"> instances.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 3.4 – Spring Security’s SecurityContextHolder" height="305" src="image/B21757_03_4.jpg" width="637"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Spring Security’s SecurityContextHolder</p>
<p>By default, <strong class="source-inline">ProviderManager</strong> attempts to remove any sensitive credential information from the <strong class="source-inline">Authentication</strong> object returned upon a successful authentication request. This precautionary<a id="_idIndexMarker140"/> measure ensures that sensitive details, such as passwords, are not<a id="_idIndexMarker141"/> stored in the <strong class="source-inline">HttpSession</strong> for longer <span class="No-Break">than necessary.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor076"/>The AuthenticationProvider interface</h2>
<p>It is possible to inject multiple<a id="_idIndexMarker142"/> instances of <strong class="source-inline">AuthenticationProviders</strong> into <strong class="source-inline">ProviderManager</strong>. Each <strong class="source-inline">AuthenticationProvider</strong> is responsible for a specific form of authentication. For instance, <strong class="source-inline">DaoAuthenticationProvider</strong> is designed for username/password-based <a id="_idIndexMarker143"/>authentication, while <strong class="source-inline">JwtAuthenticationProvider</strong> specializes in authenticating JSON <span class="No-Break">Web Tokens.</span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor077"/>Exploring the JBCP calendar architecture</h1>
<p>We will start this chapter by analyzing the domain model within the <strong class="bold">JBPC </strong><span class="No-Break"><strong class="bold">Calendar</strong></span><span class="No-Break"> architecture.</span></p>
<p>In <a href="B21757_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Anatomy of an Unsafe Application</em>, and <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>, we used the<a id="_idIndexMarker144"/> Spring <strong class="bold">Bill Of Materials</strong> (<strong class="bold">BOM</strong>) to assist in dependency management, but the rest of the code in the projects used the core Spring Framework and required manual <a id="_idIndexMarker145"/>configuration. Starting with this chapter, we will be using Spring Boot for the rest of the applications, to simplify the application configuration process. The Spring Security configuration we will be creating will be the same for both a Spring Boot and a non-Boot application. We will cover more details on Spring IO and Spring Boot in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional </em><span class="No-Break"><em class="italic">Reference Material</em></span><span class="No-Break">.</span></p>
<p>In the upcoming sections, we will delve into the domain model of the JBCP calendar application. We aim to gain insights into the process of incorporating Spring Security with personalized user configurations <span class="No-Break">and APIs.</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor078"/>The CalendarUser object</h2>
<p>Our calendar application uses a <a id="_idIndexMarker146"/>domain object named <strong class="source-inline">CalendarUser</strong>, which <a id="_idIndexMarker147"/>contains information about our users, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/CalendarUser.java
public class CalendarUser implements Serializable {
    private Integer id;
    private String firstName;
    private String lastName;
    private String email;
    private String password;
... accessor methods omitted ..
}</pre> <h2 id="_idParaDest-60"><a id="_idTextAnchor079"/>The Event object</h2>
<p>Our application<a id="_idIndexMarker148"/> has an <strong class="source-inline">Event</strong> object that <a id="_idIndexMarker149"/>contains information about <a id="_idIndexMarker150"/>each event, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Event.java
public record Event(
       Integer id,
       @NotEmpty(message = "Summary is required") String summary,
       @NotEmpty(message = "Description is required") String description,
       @NotNull(message = "When is required") Calendar dateWhen,
       @NotNull(message = "Owner is required") CalendarUser owner,
       CalendarUser attendee
) {}</pre> <h2 id="_idParaDest-61"><a id="_idTextAnchor080"/>The CalendarService interface</h2>
<p>Our application contains a <strong class="source-inline">CalendarService</strong> interface that <a id="_idIndexMarker151"/>can be used to <a id="_idIndexMarker152"/>access and store our domain objects. The code for <strong class="source-inline">CalendarService</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/CalendarService.java
public interface CalendarService {
    CalendarUser getUser(int id);
    CalendarUser findUserByEmail(String email);
    List&lt;CalendarUser&gt; findUsersByEmail(String partialEmail);
    int createUser(CalendarUser user);
    Event getEvent(int eventId);
    int createEvent(Event event);
    List&lt;Event&gt; findForUser(int userId);
    List&lt;Event&gt; getEvents();
}</pre> <p>We won’t go over the methods used in <strong class="source-inline">CalendarService</strong>, but they should be fairly straightforward. If you would<a id="_idIndexMarker153"/> like details about <a id="_idIndexMarker154"/>what each method<a id="_idTextAnchor081"/> does, please consult the Javadoc in the <span class="No-Break">sample code.</span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor082"/>The UserContext interface</h2>
<p>Like most applications, our application<a id="_idIndexMarker155"/> requires us to interact with the currently logged-in user. We have created a very simple<a id="_idIndexMarker156"/> interface called <strong class="source-inline">UserContext</strong> to manage the currently logged-in user, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/UserContext.java
public interface UserContext {
    CalendarUser getCurrentUser();
    void setCurrentUser(CalendarUser user);
}</pre> <p>This means that our application can call <strong class="source-inline">UserContext.getCurrentUser()</strong> to obtain the details of the currently logged-in user. It can also call <strong class="source-inline">UserContext.setCurrentUser(CalendarUser)</strong> to specify which user is logged in. Later in this chapter, we will explore how we can write an implementation of this interface that uses Spring Security to access our current user and obtain their details <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></p>
<p>Spring Security provides quite a few different methods for authenticating a user. However, the net result is that Spring Security will populate <strong class="source-inline">o.s.s.core.context.SecurityContext with o.s.s.core.Authentication</strong>. The <strong class="source-inline">Authentication</strong> object represents all the information we gathered at the time of<a id="_idIndexMarker157"/> authentication (username, password, roles, and so on). The <strong class="source-inline">SecurityContext</strong> interface is then set on the <strong class="source-inline">o.s.s.core.context.SecurityContextHolder</strong> interface. This means that Spring Security and developers can use <strong class="source-inline">SecurityContextHolder</strong> to obtain information about the<a id="_idIndexMarker158"/> currently logged-in user. An example of obtaining the current username is illustrated <span class="No-Break">as follows:</span></p>
<pre class="source-code">
String username = SecurityContextHolder.getContext()
       .getAuthentication()
       .getName();</pre> <p class="callout-heading">Important note</p>
<p class="callout">It should be noted that <strong class="source-inline">null</strong> checks should always be done on the <strong class="source-inline">Authentication</strong> object, as this could be <strong class="source-inline">null</strong> if the user is not <span class="No-Break">logged in.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor083"/>The SpringSecurityUserContext interface</h2>
<p>The current <strong class="source-inline">UserContext</strong> implementation, <strong class="source-inline">UserContextStub</strong>, is a stub that always returns the same user. This<a id="_idIndexMarker159"/> means that the <strong class="bold">My Events</strong> page will always display the same user no matter <a id="_idIndexMarker160"/>who is logged in. Let’s update our application to utilize the current Spring Security user’s username, to determine which events to display on the <strong class="bold">My </strong><span class="No-Break"><strong class="bold">Events</strong></span><span class="No-Break"> page.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should be starting with the sample code in <span class="No-Break"><strong class="source-inline">chapter03.00- calendar</strong></span><span class="No-Break">.</span></p>
<p>Take a look at the <span class="No-Break">following steps:</span></p>
<ol>
<li>The first step is to comment <a id="_idIndexMarker161"/>out the <strong class="source-inline">@Component</strong> attribute on <strong class="source-inline">UserContextStub</strong>, so that our application no longer uses our <span class="No-Break">scanned results.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">@Component</strong> annotation is used in conjunction with the <strong class="source-inline">@Configuration</strong> annotation found in <strong class="source-inline">com/packtpub/springsecurity/web/configuration/WebMvcConfi g.java,</strong> to automatically create a Spring bean rather than creating an explicit XML or Java configuration for each bean. You can learn more about the classpath of Spring scanning <span class="No-Break">at </span><a href="https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml"><span class="No-Break">https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml</span></a><span class="No-Break">.</span></p>
<p class="list-inset">Take a look at the following <a id="_idIndexMarker162"/><span class="No-Break">code snippet:</span></p>
<pre class="source-code">
...
@Component
public class UserContextStub implements UserContext {
...</pre> <ol>
<li value="2">The next step is to utilize <strong class="source-inline">SecurityContext</strong> to obtain the currently logged-in user. We have included <strong class="source-inline">SpringSecurityUserContext</strong> within this chapter’s code, which is wired up with the necessary dependencies but contains no <span class="No-Break">actual functionality.</span></li>
<li>Open the <strong class="source-inline">SpringSecurityUserContext.java</strong> file and add the <strong class="source-inline">@Component</strong> annotation. Next, replace the <strong class="source-inline">getCurrentUser</strong> implementation, as illustrated in the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/ SpringSecurityUserContext.java
@Component
public class SpringSecurityUserContext implements UserContext {
    private final CalendarService calendarService;
    private final UserDetailsService userDetailsService;
    public SpringSecurityUserContext(final CalendarService calendarService,
          final UserDetailsService userDetailsService) {
       if (calendarService == null) {
          throw new IllegalArgumentException("calendarService cannot be null");
       }
       if (userDetailsService == null) {
          throw new IllegalArgumentException("userDetailsService cannot be null");
       }
       this.calendarService = calendarService;
       this.userDetailsService = userDetailsService;
    }
    @Override
    public CalendarUser getCurrentUser() {
       SecurityContext context = SecurityContextHolder.getContext();
       Authentication authentication = context.getAuthentication();
       if (authentication == null) {
          return null;
       }
       User user = (User) authentication.getPrincipal();
       String email = user.getUsername();
       if (email == null) {
          return null;
       }
       CalendarUser result = calendarService.findUserByEmail(email);
       if (result == null) {
          throw new IllegalStateException(
                "Spring Security is not in synch with CalendarUsers. Could not find user with email " + email);
       }
       return result;
    }
    @Override
    public void setCurrentUser(CalendarUser user) {
       throw new UnsupportedOperationException();
    }
}</pre><p class="list-inset">Our code obtains the username from the current Spring Security <strong class="source-inline">Authentication</strong> object and utilizes that to look up the current <strong class="source-inline">CalendarUser</strong> object by <a id="_idIndexMarker163"/>email address. Since our Spring Security username is an email address, we can use the email address to link <strong class="source-inline">CalendarUser</strong> with the Spring Security user. Note that if we were to link accounts, we would normally want to do this with a<a id="_idIndexMarker164"/> key that we generated rather than something that may change (that is, an email address). We follow the good practice of returning only our domain object to the application. This ensures that our application is only aware of our <strong class="source-inline">CalendarUser</strong> object and thus is not coupled to <span class="No-Break">Spring Security.</span></p><p class="list-inset">This<span class="P---Regular-Char"> </span>code<span class="P---Regular-Char"> </span>may<span class="P---Regular-Char"> </span>seem eerily<span class="P---Regular-Char"> </span>similar<span class="P---Regular-Char"> </span>to when<span class="P---Regular-Char"> </span>we<span class="P---Regular-Char"> </span>used <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">sec:authorize=</strong></span><strong class="source-inline">
"isAuthenticated()"</strong> tag attribute in <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>, to display the current user’s username. In fact, the Spring Security tag library uses <strong class="source-inline">SecurityContextHolder</strong> in the same manner as we have done here. We could use our <strong class="source-inline">UserContext</strong> interface to place the current user on <strong class="source-inline">HttpServletRequest</strong> and thus remove our dependency on the Spring Security <span class="No-Break">tag library.</span></p></li> <li>Start up the application, visit <strong class="source-inline">http://localhost:8080/</strong>, and log in with <strong class="source-inline">admin1@example.com</strong> as the username and <strong class="source-inline">admin1</strong> as <span class="No-Break">the password.</span></li>
<li>Visit the <strong class="bold">My Events</strong> page and you will see that only the events for that current user, who is the owner or the attendee, <span class="No-Break">are displayed.</span></li>
<li>Try creating a new event; you will observe that the owner of the event is now associated with the <span class="No-Break">logged-in user.</span></li>
<li>Log out of the <a id="_idIndexMarker165"/>application and repeat these steps with <strong class="source-inline">user1@example.com</strong> as the username and <strong class="source-inline">u<a id="_idTextAnchor084"/>ser1</strong> as <span class="No-Break">the password.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.01-calendar</strong></span><span class="No-Break">.</span></p>
<p>In this section, we have<a id="_idIndexMarker166"/> covered the JBCP calendar architecture. In the next session, we will see how to manage new users <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor085"/>Logging in new users using SecurityContextHolder</h1>
<p>A common requirement is to allow <a id="_idIndexMarker167"/>users to create a new account and then automatically log them into the application. In this section, we’ll describe the simplest method for indicating that a user is authenticated, by <span class="No-Break">utilizing </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor086"/>Managing users in Spring Security</h2>
<p>The application provided in <a href="B21757_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Anatomy of an Unsafe Application</em>, provides a mechanism for creating a new <strong class="source-inline">CalendarUser</strong> object, so it should be fairly easy to create our <strong class="source-inline">CalendarUser</strong> object after a user<a id="_idIndexMarker168"/> signs up. However, Spring Security has no knowledge of <strong class="source-inline">CalendarUser</strong>. This means that we will need to add a new user in Spring<a id="_idIndexMarker169"/> Security, too. Don’t worry, we will remove the need for the dual maintenance of users later in <span class="No-Break">this chapter.</span></p>
<p>Spring Security provides an <strong class="source-inline">o.s.s.provisioning.UserDetailsManager</strong> interface for managing users. Remember our in-memory Spring <span class="No-Break">Security configuration?</span></p>
<pre class="source-code">
auth.inMemoryAuthentication(). withUser("user").password("user").roles("USER");</pre> <p>The <strong class="source-inline">SecurityConfig.userDetailsService()</strong> method creates an in-memory implementation of <strong class="source-inline">UserDetailsManager</strong>, named <strong class="source-inline">o.s.s.provisioning.InMemoryUserDetailsManager</strong>, which can be used to create a new Spring <span class="No-Break">Security user.</span></p>
<p>Let’s see how we can <a id="_idIndexMarker170"/>manage users in Spring Security by performing the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker171"/></span><span class="No-Break">steps:</span></p>
<ol>
<li>To expose <strong class="source-inline">UserDetailsManager</strong> using a Java-based configuration, we need to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">InMemoryUserDetailsManager</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public InMemoryUserDetailsManager userDetailsService() {
       UserDetails user1 = User.withDefaultPasswordEncoder()
       .username("user1@example.com")
       .password("user1")
       .roles("USER")
       .build();
       UserDetails admin1 = User.withDefaultPasswordEncoder()
       .username("admin1@example.com")
       .password("admin1")
       .roles("USER", "ADMIN")
       .build();
       return new InMemoryUserDetailsManager(user1, admin1);
}</pre></li> <li>Once we have an exposed <strong class="source-inline">UserDetailsManager</strong> interface in our Spring configuration, all we need to do is update our existing <strong class="source-inline">CalendarService</strong> implementation, <strong class="source-inline">DefaultCalendarService</strong>, to add a user in Spring Security. Make the<a id="_idIndexMarker172"/> following updates to the <span class="No-Break"><strong class="source-inline">DefaultCalendarService.java</strong></span><span class="No-Break"> file:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/ DefaultCalendarService.java
public int createUser(final CalendarUser user) {
       List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
       UserDetails userDetails = new User(user.getEmail(), user.getPassword(), authorities);
       userDetailsManager.createUser(userDetails);
       return userDao.createUser(user);
       }</pre></li> <li>To leverage <strong class="source-inline">UserDetailsManager</strong>, we first convert <strong class="source-inline">CalendarUser</strong> int<a id="_idTextAnchor087"/>o the <strong class="source-inline">UserDetails</strong> object of <span class="No-Break">Spring </span><span class="No-Break"><a id="_idIndexMarker173"/></span><span class="No-Break">Security.</span></li>
<li>Later, we use <strong class="source-inline">UserDetailsManager</strong> to save the <strong class="source-inline">UserDetails</strong> object. The conversion is necessary because Spring Security has no understanding of how to save our custom <strong class="source-inline">CalendarUser</strong> object, so we must map <strong class="source-inline">CalendarUser</strong> to an object Spring Security understands. You will notice that the <strong class="source-inline">GrantedAuthority</strong> object corresponds to the <strong class="source-inline">authorities</strong> attribute of our <strong class="source-inline">SecurityConfig</strong> file. We hardcode this for simplicity and because there is no concept of roles in our <span class="No-Break">existing system.</span></li>
</ol>
<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Logging in a new user to an application</h2>
<p>Now that we can add new users to the system, we need to indicate that the user is authenticated. Update <strong class="source-inline">SpringSecurityUserContext</strong> to set the current user on the <strong class="source-inline">SecurityContextHolder</strong> object of <a id="_idIndexMarker174"/>Spring Security, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@Override
public void setCurrentUser(CalendarUser user) {
    if (user == null) {
       throw new IllegalArgumentException("user cannot be null");
    }
    UserDetails userDetails = userDetailsService.loadUserByUsername(user.getEmail());
    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails,
          user.getPassword(), userDetails.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(authentication);
}</pre> <p>The first step we perform is to convert our <strong class="source-inline">CalendarUser</strong> object into the <strong class="source-inline">UserDetails</strong> object of Spring Security. This is necessary because, just as Spring Security didn’t know how to save our custom <strong class="source-inline">CalendarUser</strong> object, Spring Security also does not understand how<a id="_idIndexMarker175"/> to make security decisions with our custom <strong class="source-inline">CalendarUser</strong> object. We use Spring Security’s <strong class="source-inline">o.s.s.core.userdetails.UserDetailsService</strong> interface to obtain the same <strong class="source-inline">UserDetails</strong> object we saved with <strong class="source-inline">UserDetailsManager</strong>. The <strong class="source-inline">UserDetailsService</strong> interface provides a subset of the functionality provided by Spring Security’s <strong class="source-inline">UserDetailsManager</strong> object that we have <span class="No-Break">already seen.</span></p>
<p>Next, we create a <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> object and place <strong class="source-inline">UserDetails</strong>, the password, and <strong class="source-inline">GrantedAuthority</strong> in it. Lastly, we set the authentication on <strong class="source-inline">SecurityContextHolder</strong>. In a web application, Spring Security will automatically associate the <strong class="source-inline">SecurityContext</strong> object in <strong class="source-inline">SecurityContextHolder</strong> to our<a id="_idIndexMarker176"/> HTTP session <span class="No-Break">for us.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">It is important that Spring Security must not be instructed to ignore a URL (that is, using the <strong class="source-inline">permitAll()</strong> method), as discussed in <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>, in which <strong class="source-inline">SecurityContextHolder</strong> is accessed or set. This is because Spring Security will ignore the request and thus not persist <strong class="source-inline">SecurityContext</strong> for subsequent requests. The session management support is composed of a few components that work together to provide the functionality, so we used <strong class="source-inline">securityContext.requireExplicitSave(false)</strong> to persist <span class="No-Break">the session.</span></p>
<p>The advantage of this approach is that there is no need to hit the datastore again. In our case, the datastore is an in-memory datastore, but this could be backed by a database, which could have some <a id="_idIndexMarker177"/>security implications. The disadvantage of this approach is that we do not get to reuse the code much. Since this method is invoked infrequently, we opt for reusing the code. In general, it is best to evaluate each situation separately to determine which approach makes the <span class="No-Break">most sense.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor089"/>Updating SignupController</h2>
<p>The application has a <strong class="source-inline">SignupController</strong> object, which is<a id="_idIndexMarker178"/> what processes the HTTP request to create a new <strong class="source-inline">CalendarUser</strong> object. The last step is to update <strong class="source-inline">SignupController</strong> to <a id="_idIndexMarker179"/>create our user and then indicate that they are logged in. Make the following updates <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SignupController</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/SignupController.java
@PostMapping("/signup/new")
public String signup(final @Valid SignupForm signupForm,
final BindingResult result,
       RedirectAttributes redirectAttributes) {
       if (result.hasErrors()) {
       return "signup/form";
       }
       String email = signupForm.getEmail();
       if (calendarService.findUserByEmail(email) != null) {
       result.rejectValue("email", "errors.signup.email", "Email address is already in use. FOO");
       redirectAttributes.addFlashAttribute("error", "Email address is already in use. FOO");
       return "signup/form";
       }
       CalendarUser user = new CalendarUser(null, signupForm.getFirstName(), signupForm.getLastName(), email, signupForm.getPassword());
       int id = calendarService.createUser(user);
       user.setId(id);
       userContext.setCurrentUser(user);
       redirectAttributes.addFlashAttribute("message", "You have successfully signed up and logged in.");
       return "redirect:/";
       }</pre> <p>If you have not done so already, restart the<a id="_idIndexMarker180"/> application, visit <strong class="source-inline">http://localhost:8080/</strong>, create a new user, and you can see that the new user is<a id="_idIndexMarker181"/> automatically <span class="No-Break">logged in.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.02-calendar</strong></span><span class="No-Break">.</span></p>
<p>In this section, we have covered the new user signup workflow. In the next section, we will create a custom <span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break"> object.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor090"/>Creating a custom UserDetailsService object</h1>
<p>While we can link our domain model (<strong class="source-inline">CalendarUser</strong>) with Spring Security’s domain model (<strong class="source-inline">UserDetails</strong>), we have to <a id="_idIndexMarker182"/>maintain multiple representations of the user. To resolve this dual maintenance, we can implement a custom <strong class="source-inline">UserDetailsService</strong> object to translate our existing <strong class="source-inline">CalendarUser</strong> domain model into an implementation of Spring Security’s <strong class="source-inline">UserDetails</strong> interface. By translating our <strong class="source-inline">CalendarUser</strong> object into <strong class="source-inline">UserDetails</strong>, Spring Security can make security decisions using our custom domain model. This means that we will no longer need to manage two different representations of <span class="No-Break">a user.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor091"/>The CalendarUserDetailsService class</h2>
<p>Up to this point, we have needed two different <a id="_idIndexMarker183"/>representations of users: one for Spring Security to make security decisions, and one for our application to associate our domain objects to. Create a new class named <strong class="source-inline">CalendarUserDetailsService</strong> that will make Spring Security aware of our <strong class="source-inline">CalendarUser</strong> object. This will ensure that Spring Security can make decisions based on our domain model. Create a<a id="_idIndexMarker184"/> new file named <strong class="source-inline">CalendarUserDetailsService.java</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/CalendarUserDetailsService.java
@Component
public class CalendarUserDetailsService implements UserDetailsService {
    private static final Logger logger = LoggerFactory
          .getLogger(CalendarUserDetailsService.class);
    private final CalendarUserDao calendarUserDao;
    public CalendarUserDetailsService(final CalendarUserDao calendarUserDao) {
       if (calendarUserDao == null) {
          throw new IllegalArgumentException("calendarUserDao cannot be null");
       }
       this.calendarUserDao = calendarUserDao;
    }
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
       CalendarUser user = calendarUserDao.findUserByEmail(username);
       if (user == null) {
          throw new UsernameNotFoundException("Invalid username/password.");
       }
       Collection&lt;? extends GrantedAuthority&gt; authorities = CalendarUserAuthorityUtils.createAuthorities(user);
       return new User(user.getEmail(), user.getPassword(), authorities);
    }
}</pre> <p>Here, we utilize <strong class="source-inline">CalendarUserDao</strong> to obtain <strong class="source-inline">CalendarUser</strong> by using the email address. We take care not to return a null value; instead, a <strong class="source-inline">UsernameNotFoundException</strong> exception should be thrown, as returning <strong class="source-inline">null</strong> breaks the <span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break"> interface.</span></p>
<p>We then convert <strong class="source-inline">CalendarUser</strong> into <strong class="source-inline">UserDetails</strong>, implemented by the user, as we did in the <span class="No-Break">previous sections.</span></p>
<p>We now utilize a utility class<a id="_idIndexMarker185"/> named <strong class="source-inline">CalendarUserAuthorityUtils</strong> that we provided in the sample code. This will create <strong class="source-inline">GrantedAuthority</strong> based on the email address so that we can support users and administrators. If the email starts with <strong class="source-inline">admin</strong>, the user is treated as <strong class="source-inline">ROLE_ADMIN</strong> and <strong class="source-inline">ROLE_USER</strong>. Otherwise, the user is treated as <strong class="source-inline">ROLE_USER</strong>. Of course, we would not do this in a real application, <a id="_idTextAnchor092"/>but it’s this simplicity that allows us to focus on <span class="No-Break">this lesson.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor093"/>Configuring UserDetailsService</h2>
<p>Now that we have a new <strong class="source-inline">UserDetailsService</strong> object, let’s update the Spring Security configuration to utilize it. Our <strong class="source-inline">CalendarUserDetailsService</strong> class is added to our Spring configuration automatically since we leverage <strong class="source-inline">classpath</strong> scanning and the <strong class="source-inline">@Component</strong> annotation. This means we only need to update Spring Security to refer to the <strong class="source-inline">CalendarUserDetailsService</strong> class we just created. <strong class="source-inline">userDetailsService()</strong> methods, Spring<a id="_idIndexMarker186"/> Security’s in-memory implementation of <strong class="source-inline">UserDetailsService</strong> since we are now providing our own <span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break"> implementation.</span></p>
<p>Update the <strong class="source-inline">SecurityConfig.java</strong> file, as follows to declare a <strong class="source-inline">DelegatingPasswordEncoder</strong> with default mappings. Additional mappings may be added and the encoding will be updated to conform with best practices. However, due to the nature of <strong class="source-inline">DelegatingPasswordEncoder</strong>, the updates should not <span class="No-Break">impact users:</span></p>
<pre class="source-code">
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    }
   @Bean
   public PasswordEncoder encoder() {
       return PasswordEncoderFactories.createDelegatingPasswordEncoder();
   }
}</pre> <h2 id="_idParaDest-71"><a id="_idTextAnchor094"/>Removing references to UserDetailsManager</h2>
<p>We need to remove the code we added in <strong class="source-inline">DefaultCalendarService</strong> that used <strong class="source-inline">UserDetailsManager</strong> to synchronize the Spring Security <strong class="source-inline">o.s.s.core.userdetails.User</strong> interface and <strong class="source-inline">CalendarUser</strong>. First, the code is not necessary since Spring Security now<a id="_idIndexMarker187"/> refers to <strong class="source-inline">CalendarUserDetailsService</strong>. Second, since we removed the <strong class="source-inline">inMemoryAuthentication()</strong> method, there is no <strong class="source-inline">UserDetailsManager</strong> object defined in our Spring configuration. Go ahead and remove all references to <strong class="source-inline">UserDetailsManager</strong> found in <strong class="source-inline">DefaultCalendarService</strong>. The updates will look similar to the following <span class="No-Break">sample snippets:</span></p>
<p>Start up the application and see that Spring Security’s in-memory <strong class="source-inline">UserDetailsManager</strong> object is no longer necessary (we removed it from our <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file).</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.03-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor095"/>The CalendarUserDetails object</h2>
<p>We have successfully eliminated the need to <a id="_idIndexMarker188"/>manage both Spring Security users and our <strong class="source-inline">CalendarUser</strong> objects. However, it is still cumbersome for us to continually need to translate between the two objects. Instead, we will create a <strong class="source-inline">CalendarUserDetails</strong> object, which can be referred to as both <strong class="source-inline">UserDetails</strong> and <strong class="source-inline">CalendarUser</strong>. Update <strong class="source-inline">CalendarUserDetailsService</strong> to use <strong class="source-inline">CalendarUserDetails</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@Component
public class CalendarUserDetailsService implements UserDetailsService {
    private final CalendarUserDao calendarUserDao;
    public CalendarUserDetailsService(CalendarUserDao calendarUserDao) {
       if (calendarUserDao == null) {
          throw new IllegalArgumentException("calendarUserDao cannot be null");
       }
       this.calendarUserDao = calendarUserDao;
    }
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        ...
       }
       return new CalendarUserDetails(user);
    }
    private final class CalendarUserDetails extends CalendarUser implements UserDetails {
       CalendarUserDetails(CalendarUser user) {
          super(user.getId(), user.getFirstName(), user.getLastName(), user.getEmail(), user.getPassword());
       }
       @Override
       public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
          return CalendarUserAuthorityUtils.createAuthorities(this);
       }
       @Override
       public String getUsername() {
          return getEmail();}
       @Override
       public boolean isAccountNonExpired() {
          return true;}
       @Override
       public boolean isAccountNonLocked() {
          return true;}
       @Override
       public boolean isCredentialsNonExpired() {
          return true; }
       @Override
       public boolean isEnabled() {
         return true;   }
    }
}</pre> <p>In the next section, we will see that our<a id="_idIndexMarker189"/> application can now refer to the principal authentication on the current <strong class="source-inline">CalendarUser</strong> object. However, Spring Security can continue to treat <strong class="source-inline">CalendarUserDetails</strong> as a <span class="No-Break"><strong class="source-inline">UserDetails</strong></span><span class="No-Break"> object.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor096"/>The SpringSecurityUserContext simplifications</h2>
<p>We have updated <strong class="source-inline">CalendarUserDetailsService</strong> to return a <strong class="source-inline">UserDetails</strong> object that extends <strong class="source-inline">CalendarUser</strong><span class="L---Numbers-Char"> </span>and implements <strong class="source-inline">UserDetails</strong>. This means that, rather than having to translate<a id="_idIndexMarker190"/> between the two objects, we can simply refer to a <strong class="source-inline">CalendarUser</strong> object. Update <strong class="source-inline">SpringSecurityUserContext</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@Component
public class SpringSecurityUserContext implements UserContext {
    @Override
    public CalendarUser getCurrentUser() {
       SecurityContext context = SecurityContextHolder.getContext();
       Authentication authentication = context.getAuthentication();
       if (authentication == null) {
          return null;
       }
       return (CalendarUser) authentication.getPrincipal();
    }
    @Override
    public void setCurrentUser(CalendarUser user) {
       if (user == null) {
          throw new IllegalArgumentException("user cannot be null");
       }
       Collection&lt;? extends GrantedAuthority&gt; authorities = CalendarUserAuthorityUtils.createAuthorities(user);
       UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user,
             user.getPassword(), authorities);
       SecurityContextHolder.getContext().setAuthentication(authentication);
    }
}</pre> <p>The updates no longer require the use of <strong class="source-inline">CalendarUserDao</strong> or Spring Security’s <strong class="source-inline">UserDetailsService</strong> interface. Remember <a id="_idIndexMarker191"/>our <strong class="source-inline">loadUserByUsername</strong> method from the previous section? The result of this method call becomes the principal of the authentication. Since our updated <strong class="source-inline">loadUserByUsername</strong> method returns an object that extends <strong class="source-inline">CalendarUser</strong>, we can safely cast the principal of the <strong class="source-inline">Authentication</strong> object to <strong class="source-inline">CalendarUser</strong>. We can pass a <strong class="source-inline">CalendarUser</strong> object as the principal into the constructor for <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> when invoking the <strong class="source-inline">setCurrentUser</strong> method. This allows us to still cast the principal to a <strong class="source-inline">CalendarUser</strong> object when invoking the <span class="No-Break"><strong class="source-inline">getCurrentUser</strong></span><span class="No-Break"> method.</span></p>
<p>Displaying custom <span class="No-Break">user attributes</span></p>
<p>Now that <strong class="source-inline">CalendarUser</strong> is populated into Spring Security’s authentication, we can update our UI to display the name of the<a id="_idIndexMarker192"/> current user rather than the email address. Update the <strong class="source-inline">header.xhtml</strong> file with the <span class="No-Break">following code:</span></p>
<pre class="source-code">
//src/main/resources/templates/fragments/header.xhtml
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="#"&gt;Welcome &lt;span class="navbar-text"
                                               th:text="${#authentication.getPrincipal().getName()}"&gt; &lt;/span&gt;&lt;/a&gt;
&lt;/li&gt;</pre> <p>Internally, the <strong class="source-inline">"${#authentication.getPrincipal().getName()}"</strong> tag attribute executes the following code. Observe that the highlighted values correlate to the <strong class="source-inline">property</strong> attribute of the <strong class="source-inline">authentication</strong> tag we specified in the <span class="No-Break"><strong class="source-inline">header.xhtml</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
CalendarUser user = (CalendarUser) authentication.getPrincipal();
String firstAndLastName = user.getName();</pre> <p>Restart the application, visit <strong class="source-inline">http://localhost:8080/</strong>, and log in to view the updates. Instead of seeing the current user’s email, you should now see their first and <span class="No-Break">last names.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.04-calendar</strong></span><span class="No-Break">.</span></p>
<p>After configuring the <strong class="source-inline">CalendarUserDetailsService</strong> and <strong class="source-inline">UserDetailsService</strong> in the section and simplifying <strong class="source-inline">SpringSecurityUserContext</strong> to display custom user attributes, in the next section, we will explore how to<a id="_idIndexMarker193"/> create a <span class="No-Break">custom </span><span class="No-Break"><strong class="source-inline">AuthenticationProvider</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor097"/>Creating a custom AuthenticationProvider object</h1>
<p>Spring Security delegates to an <strong class="source-inline">AuthenticationProvider</strong> object to determine whether a user is authenticated or not. This <a id="_idIndexMarker194"/>means we can write custom <strong class="source-inline">AuthenticationProvider</strong> implementations to inform Spring Security how to authenticate in different ways. The good news is that Spring Security provides quite a few <strong class="source-inline">AuthenticationProvider</strong> objects, so more often than not you will not need to create one. In fact, up until this point, we have been utilizing Spring Security’s <strong class="source-inline">o.s.s.authentication.dao.DaoAuthenticationProvider</strong> object, which compares the username and password returned <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor098"/>Creating CalendarUserAuthenticationProvider</h2>
<p>Throughout the rest of this section, we are going to create a custom <strong class="source-inline">AuthenticationProvider</strong> object named <strong class="source-inline">CalendarUserAuthenticationProvider</strong> that will <a id="_idIndexMarker195"/>replace <strong class="source-inline">CalendarUserDetailsService</strong>. Then, we will use <strong class="source-inline">CalendarUserAuthenticationProvider</strong> to consider an additional parameter to support authenticating users from <span class="No-Break">multiple domains.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">We must use an <strong class="source-inline">AuthenticationProvider</strong> object rather than <strong class="source-inline">UserDetailsService</strong> because the <strong class="source-inline">UserDetails</strong> interface has no concept of a <span class="No-Break">domain parameter.</span></p>
<p>Create a new class named <strong class="source-inline">CalendarUserAuthenticationProvider</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/authentication/ CalendarUserAuthenticationProvider.java
@Component
public class CalendarUserAuthenticationProvider implements AuthenticationProvider {
    private final CalendarService calendarService;
    public CalendarUserAuthenticationProvider(final CalendarService calendarService) {
       if (calendarService == null) {
          throw new IllegalArgumentException("calendarService cannot be null");
       }
       this.calendarService = calendarService;
    }
    @Override
    public Authentication authenticate(final Authentication authentication) throws AuthenticationException {
       UsernamePasswordAuthenticationToken token = (UsernamePasswordAuthenticationToken) authentication;
       String email = token.getName();
       CalendarUser user = email == null ? null : calendarService.findUserByEmail(email);
       if (user == null) {
          throw new UsernameNotFoundException("Invalid username/password");
       }
       String password = user.getPassword();
       if (!password.equals(token.getCredentials())) {
          throw new BadCredentialsException("Invalid username/password");
       }
       Collection&lt;? extends GrantedAuthority&gt; authorities = CalendarUserAuthorityUtils.createAuthorities(user);
       return new UsernamePasswordAuthenticationToken(user, password, authorities);
    }
    @Override
    public boolean supports(final Class&lt;?&gt; authentication) {
       return UsernamePasswordAuthenticationToken.class.equals(authentication);
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Remember that you <span class="P---Regular-Char">can use your </span><strong class="bold">Integrated Development Environment</strong><span class="P---Regular-Char"> </span>(<strong class="bold">IDE</strong>)<span class="P---Regular-Char"> to add the missing imports</span>. Alternatively, you can copy<a id="_idIndexMarker196"/> the implementation <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter03.05-calendar</strong></span><span class="No-Break">.</span></p>
<p>Before Spring Security <a id="_idIndexMarker197"/>can invoke the <strong class="source-inline">authenticate</strong> method, the <strong class="source-inline">supports</strong> method must return <strong class="source-inline">true</strong> for the <strong class="source-inline">Authentication</strong> class that will be passed in. In this case, <strong class="source-inline">AuthenticationProvider</strong> can authenticate a username and password. We do not accept subclasses of <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> since there may be additional fields that we do not know how <span class="No-Break">to validate.</span></p>
<p>The <strong class="source-inline">authenticate</strong> method accepts an <strong class="source-inline">Authentication</strong> object as an argument that represents an authentication request. In practical terms, it is the input from the user that we need to attempt to validate. If authentication fails, the method should throw an <strong class="source-inline">o.s.s.core.AuthenticationException</strong><span class="L---Numbers-Char"> </span>exception. If authentication succeeds, it should return an <strong class="source-inline">Authentication</strong> object that contains the proper <strong class="source-inline">GrantedAuthority</strong> objects for the user. The returned <strong class="source-inline">Authentication</strong><span class="L---Numbers-Char"> </span>object will be<a id="_idIndexMarker198"/> set on <strong class="source-inline">SecurityContextHolder</strong>. If authentication cannot be determined, the method should <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
<p>The first step in authenticating the request is to extract the information from the <strong class="source-inline">Authentication</strong> object that we need to authenticate the user. In our case, we extract the username and lookup <strong class="source-inline">CalendarUser</strong> by email address, just as <strong class="source-inline">CalendarUserDetailsService</strong> did. If the provided username and password match <strong class="source-inline">CalendarUser</strong>, we will return a <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> object with proper <strong class="source-inline">GrantedAuthority</strong>. Otherwise, we will throw an <span class="No-Break"><strong class="source-inline">AuthenticationException</strong></span><span class="No-Break"> exception.</span></p>
<p>Remember how the login page leveraged <strong class="source-inline">SPRING_SECURITY_LAST_EXCEPTION</strong> to explain why the login failed? The message for the <strong class="source-inline">AuthenticationException</strong> exception thrown in <strong class="source-inline">Authenticat<a id="_idTextAnchor099"/>ionProvider</strong> is the last <strong class="source-inline">AuthenticationException</strong> exception and will be displayed on our login page in the event of a <span class="No-Break">failed login.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor100"/>Configuring the CalendarUserAuthenticationProvider object</h2>
<p>Let’s perform <a id="_idIndexMarker199"/>the following steps to <span class="No-Break">configure </span><span class="No-Break"><strong class="source-inline">CalendarUserAuthenticationProvider</strong></span><span class="No-Break">:</span></p>
<ol>
<li>Update the <strong class="source-inline">SecurityConfig.java</strong> file to refer to our newly created <strong class="source-inline">CalendarUserAuthenticationProvider</strong> object, and remove the reference to <strong class="source-inline">CalendarUserDetailsService</strong>, as shown <a id="_idIndexMarker200"/>in the following <span class="No-Break">code snippet:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@EnableWebSecurity
public class SecurityConfig {
    private final CalendarUserAuthenticationProvider cuap;
    public SecurityConfig(CalendarUserAuthenticationProvider cuap) {
       this.cuap = cuap;
    }
    @Bean
    public AuthenticationManager authManager(HttpSecurity http) throws Exception {
       AuthenticationManagerBuilder authenticationManagerBuilder =
             http.getSharedObject(AuthenticationManagerBuilder.class);
       authenticationManagerBuilder.authenticationProvider(cuap);
       return authenticationManagerBuilder.build();
    }
...
}</pre></li> <li>Update the <strong class="source-inline">SecurityConfig.java</strong> file, as follows, by <a id="_idIndexMarker201"/>removing the <span class="No-Break"><strong class="source-inline">PasswordEncoder</strong></span><span class="No-Break"> bean:</span><pre class="source-code">
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
...
    }
// We removed the PasswordEncoder
}</pre></li> <li>Restart the application and ensure everything is still working. As a user, we do not notice anything different. However, as a developer, we know that <strong class="source-inline">CalendarUserDetails</strong> is no longer required; we are still able to display the current user’s first and last names, and Spring Security is still able to leverage <strong class="source-inline">CalendarUser</strong> <span class="No-Break">for authentication.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.05-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor101"/>Authenticating with different parameters</h2>
<p>One of the strengths of <strong class="source-inline">AuthenticationProvider</strong> is that it can authenticate with any parameters you <a id="_idIndexMarker202"/>wish. For example, maybe your application uses a random identifier for authentication, or perhaps it is a multitenant application and requires a username, password, and domain. In the following section, we will update <strong class="source-inline">CalendarUserAuthenticationProvider</strong> to support <span class="No-Break">multiple domains.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">A domain is a way to scope our users. For example, if we deploy our application once but have multiple clients using the same deployment, each client may want a user with the username <strong class="source-inline">admin</strong>. By adding a domain to our user object, we can ensure that each user is distinct and still supports <span class="No-Break">this requirement.</span></p>
<h3>The DomainUsernamePasswordAuthenticationToken class</h3>
<p>When a user authenticates, Spring Security <a id="_idIndexMarker203"/>submits an <strong class="source-inline">Authentication</strong> object to <strong class="source-inline">AuthenticationProvider</strong> with the information provided by the user. The current <strong class="source-inline">UsernamePasswordAuthentication</strong> object only contains a username and password field. Create a <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong> object that contains a <strong class="source-inline">domain</strong> field, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/authentication/ DomainUsernamePasswordAuthenticationToken.java
public final class DomainUsernamePasswordAuthenticationToken extends
       UsernamePasswordAuthenticationToken {
    private final String domain;
    // used for attempting authentication
    public DomainUsernamePasswordAuthenticationToken(String
          principal, String credentials, String domain) {
       super(principal, credentials);
       this.domain = domain;
    }
    // used for returning to Spring Security after being
    //authenticated
    public DomainUsernamePasswordAuthenticationToken(CalendarUser
          principal, String credentials, String domain,
          Collection&lt;? extends GrantedAuthority&gt; authorities) {
       super(principal, credentials, authorities);
       this.domain = domain;
    }
    public String getDomain() {
       return domain;
    }
}</pre> <h3>Updating CalendarUserAuthenticationProvider</h3>
<p>Let’s take a look at the following steps for updating the <span class="No-Break"><strong class="source-inline">CalendarUserAuthenticationProvider.java</strong></span><span class="No-Break"> file:</span></p>
<ol>
<li>Now, we<a id="_idIndexMarker204"/> need to update <strong class="source-inline">CalendarUserAuthenticationProvider</strong> to utilize the domain field, <span class="No-Break">as follows:</span><pre class="source-code">
@Component
public class CalendarUserAuthenticationProvider implements AuthenticationProvider {
    private static final Logger logger = LoggerFactory
          .getLogger(CalendarUserAuthenticationProvider.class);
    private final CalendarService calendarService;
    @Autowired
    public CalendarUserAuthenticationProvider(CalendarService calendarService) {
       if (calendarService == null) {
          throw new IllegalArgumentException("calendarService cannot be null");
       }
       this.calendarService = calendarService;
    }
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
       DomainUsernamePasswordAuthenticationToken token = (DomainUsernamePasswordAuthenticationToken) authentication;
       String userName = token.getName();
       String domain = token.getDomain();
       String email = userName + "@" + domain;
       CalendarUser user = calendarService.findUserByEmail(email);
       logger.info("calendarUser: {}", user);
       if (user == null) {
          throw new UsernameNotFoundException("Invalid username/password");
       }
       String password = user.getPassword();
       if (!password.equals(token.getCredentials())) {
          throw new BadCredentialsException("Invalid username/password");
       }
       Collection&lt;? extends GrantedAuthority&gt; authorities = CalendarUserAuthorityUtils.createAuthorities(user);
       logger.info("authorities: {}", authorities);
       return new DomainUsernamePasswordAuthenticationToken(user, password, domain, authorities);
    }
    @Override
    public boolean supports(Class&lt;?&gt; authentication) {
       return DomainUsernamePasswordAuthenticationToken.class.equals(authentication);
    }
}</pre></li> <li>We first update the support method so that Spring Security will <span class="No-Break">pass </span><span class="No-Break"><strong class="source-inline">DomainUsername</strong></span><strong class="source-inline">
PasswordAuthenticationToken</strong> into our <span class="No-Break"><strong class="source-inline">authenticate</strong></span><span class="No-Break"> method.</span></li>
<li>We then use the domain information to create our email address and authenticate, as we had previously done. Admittedly, this example is contrived. However, the example can illustrate how to authenticate with an <span class="No-Break">additional parameter.</span></li>
<li>The <strong class="source-inline">CalendarUserAuthenticationProvider</strong> interface can now use the new domain field. However, there is no way for a user to specify the domain. For this, we <a id="_idIndexMarker205"/>must update our <span class="No-Break"><strong class="source-inline">login.xhtml</strong></span><span class="No-Break"> file.</span></li>
</ol>
<h3>Adding domain to the login page</h3>
<p>Open up the <strong class="source-inline">login.xhtml</strong> file and add a <a id="_idIndexMarker206"/>new input named <strong class="source-inline">domain</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div class="mb-3"&gt;
&lt;label class="form-label" for="username"&gt;Username&lt;/label&gt;
&lt;input autofocus="autofocus" class="form-control" id="username"
       name="username"
       type="text"/&gt;
&lt;/div&gt;
&lt;div class="mb-3"&gt;
&lt;label class="form-label" for="password"&gt;Password&lt;/label&gt;
&lt;input class="form-control" id="password" name="password"
       type="password"/&gt;
&lt;/div&gt;
&lt;div class="mb-3"&gt;
&lt;label class="form-label" for="domain"&gt;Domain&lt;/label&gt;
&lt;input class="form-control" id="domain" name="domain" type="text"/&gt;
&lt;/div&gt;</pre> <p>Now, a domain will be submitted when<a id="_idIndexMarker207"/> users attempt to log in. However, Spring Security is unaware of how to use that domain to create a <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong> object and pass it into <strong class="source-inline">AuthenticationProvider</strong>. To fix this, we will need to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">DomainUsernamePasswordAuthenticationFilter</strong></span><span class="No-Break">.</span></p>
<h3>The DomainUsernamePasswordAuthenticationFilter class</h3>
<p>Spring Security provides a number of <strong class="source-inline">Servlet Filters</strong> that act as controllers for authenticating users. The <a id="_idIndexMarker208"/>filters are invoked as one of the delegates of the <strong class="source-inline">FilterChainProxy</strong> object that we discussed in <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>. Previously, the <strong class="source-inline">formLogin()</strong> method instructed Spring Security to use <strong class="source-inline">o.s.s.web.authentication.UsernamePasswordAuthenticationFilter</strong> to act as a login controller. The filter’s job is to perform the <span class="No-Break">following tasks:</span></p>
<ul>
<li>Obtain a username and password from the <span class="No-Break">HTTP request.</span></li>
<li>Create a <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> object with the information obtained from the <span class="No-Break">HTTP request.</span></li>
<li>Request that Spring Security <span class="No-Break">validates </span><span class="No-Break"><strong class="source-inline">UsernamePasswordAuthenticationToken</strong></span><span class="No-Break">.</span></li>
<li>If the token is validated, it will set the <a id="_idIndexMarker209"/>authentication returned to it <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">SecurityContext</strong></span><strong class="source-inline">
Holder</strong>, just as we did when a new user signed up for an account. We will need to extend <strong class="source-inline">UsernamePasswordAuthenticationFilter</strong> to leverage our newly created <span class="No-Break"><strong class="source-inline">DoainUsernamePasswordAuthenticationToken</strong></span><span class="No-Break"> object.</span></li>
<li>Create a <strong class="source-inline">DomainUsernamePasswordAuthenticationFilter</strong> object, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/authentication/ DomainUsernamePasswordAuthenticationFilter.java
public final class DomainUsernamePasswordAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    public DomainUsernamePasswordAuthenticationFilter(final AuthenticationManager authenticationManager) {
       super.setAuthenticationManager(authenticationManager);
    }
    public Authentication attemptAuthentication
          (HttpServletRequest request, HttpServletResponse response) throws
          AuthenticationException {
       if (!request.getMethod().equals("POST")) {
          throw new AuthenticationServiceException
                ("Authentication method not supported: "
                      + request.getMethod());
       }
       String username = obtainUsername(request);
       String password = obtainPassword(request);
       String domain = request.getParameter("domain");
       DomainUsernamePasswordAuthenticationToken authRequest
             = new DomainUsernamePasswordAuthenticationToken(username,
             password, domain);
       setDetails(request, authRequest);
       return this.getAuthenticationManager()
             .authenticate(authRequest);
    }
}</pre></li> </ul>
<p>The new <strong class="source-inline">DomainUsernamePasswordAuthenticationFilter</strong> object will perform the <span class="No-Break">following tasks:</span></p>
<ul>
<li>Obtain a username, password, and domain from the <span class="No-Break"><strong class="source-inline">HttpServletRequest</strong></span><span class="No-Break"> method.</span></li>
<li>Create our <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong> object with information obtained from the <span class="No-Break">HTTP request.</span></li>
<li>Request that Spring Security validates <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong>. The work is delegated <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CalendarUserAuthenticationProvider</strong></span><span class="No-Break">.</span></li>
<li>If the token is validated, its<a id="_idIndexMarker210"/> superclass will set the authentication returned by <strong class="source-inline">CalendarUserAuthenticationProvider</strong> on <strong class="source-inline">SecurityContextHolder</strong>, just as we did to authenticate a user after they created a <span class="No-Break">new account.</span></li>
</ul>
<h3>Updating our configuration</h3>
<p>Now that we have created all the code <a id="_idIndexMarker211"/>required for an additional parameter, we need to configure Spring Security to be aware of it. The following code snippet includes the required updates to our <strong class="source-inline">SecurityConfig.java</strong><span class="L---Numbers-Char"> </span>file to support our <span class="No-Break">additional parameter:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final CalendarUserAuthenticationProvider cuap;
    public SecurityConfig(CalendarUserAuthenticationProvider cuap) {
       this.cuap = cuap;
    }
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, AuthenticationManager authManager) throws Exception {
       http.authorizeRequests((authz) -&gt; authz
                   .requestMatchers(antMatcher("/webjars/**")).permitAll()
                   .requestMatchers(antMatcher("/css/**")).permitAll()
                   .requestMatchers(antMatcher("/favicon.ico")).permitAll()
                   // H2 console:
                   .requestMatchers(antMatcher("/admin/h2/**")).permitAll()
                   .requestMatchers(antMatcher("/")).permitAll()
                   .requestMatchers(antMatcher("/login/*")).permitAll()
                   .requestMatchers(antMatcher("/logout")).permitAll()
                   .requestMatchers(antMatcher("/signup/*")).permitAll()
                   .requestMatchers(antMatcher("/errors/**")).permitAll()
                   .requestMatchers(antMatcher("/admin/*")).hasRole("ADMIN")
                   .requestMatchers(antMatcher("/events/")).hasRole("ADMIN")
                   .requestMatchers(antMatcher("/**")).hasRole("USER"))
             .exceptionHandling(exceptions -&gt; exceptions
                   .accessDeniedPage("/errors/403")
                   .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/login/form")))
             .logout(form -&gt; form
                   .logoutUrl("/logout")
                   .logoutSuccessUrl("/login/form?logout")
                   .permitAll())
             // CSRF is enabled by default, with Java Config
             .csrf(AbstractHttpConfigurer::disable)
             // Add custom DomainUsernamePasswordAuthenticationFilter
             .addFilterAt(domainUsernamePasswordAuthenticationFilter(authManager), UsernamePasswordAuthenticationFilter.class);
       http.securityContext((securityContext) -&gt; securityContext.requireExplicitSave(false));
       http.headers(headers -&gt; headers.frameOptions(FrameOptionsConfig::disable));
       return http.build();
    }
    @Bean
    public DomainUsernamePasswordAuthenticationFilter domainUsernamePasswordAuthenticationFilter(AuthenticationManager authManager) {
       DomainUsernamePasswordAuthenticationFilter dupaf = new
             DomainUsernamePasswordAuthenticationFilter(authManager);
       dupaf.setFilterProcessesUrl("/login");
       dupaf.setUsernameParameter("username");
       dupaf.setPasswordParameter("password");
       dupaf.setAuthenticationSuccessHandler(new SavedRequestAwareAuthenticationSuccessHandler() {{
          setDefaultTargetUrl("/default");
       }});
       dupaf.setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler() {{
          setDefaultFailureUrl("/login/form?error");
       }});
       dupaf.afterPropertiesSet();
       return dupaf;
    }
    @Bean
    public AuthenticationManager authManager(HttpSecurity http) throws Exception {
       AuthenticationManagerBuilder authenticationManagerBuilder =
             http.getSharedObject(AuthenticationManagerBuilder.class);
       authenticationManagerBuilder.authenticationProvider(cuap);
       return authenticationManagerBuilder.build();
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">The preceding code snippet configures standard beans in our Spring Security configuration. We have shown this to demonstrate that it can be done. However, throughout much of the rest of the book, we include standard bean configuration in its own file, as this makes the configuration less verbose. If you are having trouble, or prefer not to type all of this, you may copy it <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter03.06-calendar</strong></span><span class="No-Break">.</span></p>
<p>The following are a<a id="_idIndexMarker212"/> few highlights from the <span class="No-Break">configuration updates:</span></p>
<ul>
<li>We overrode <strong class="source-inline">defaultAuthenticationEntryPoint</strong> and added a reference to <strong class="source-inline">o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint</strong>, which determines what happens when a request for a protected resource occurs and the user is not authenticated. In our case, we are redirected to a <span class="No-Break">login page.</span></li>
<li>We removed the <strong class="source-inline">formLogin()</strong> method and used a <strong class="source-inline">.addFilterAt()</strong> method to insert our custom filter into <strong class="source-inline">FilterChainProxy</strong>. The position indicates the order in which the delegates of <strong class="source-inline">FilterChain</strong> are considered and cannot overlap with another filter, but can replace the filter at the current position. We replaced <strong class="source-inline">UsernamePasswordAuthenticationFilter</strong> with our <span class="No-Break">custom filter.</span><p class="list-inset">Take a look at the following diagram for <span class="No-Break">your reference:</span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 3.5 – Custom Authentication implementation" height="627" src="image/B21757_03_5.jpg" width="1195"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Custom Authentication implementation</p>
<p>You can now restart the application <a id="_idIndexMarker213"/>and try the following steps, depicted in the preceding diagram, to understand how all the pieces <span class="No-Break">fit together:</span></p>
<ol>
<li><span class="No-Break">Visit </span><span class="No-Break"><strong class="source-inline">http://localhost:8080/events</strong></span><span class="No-Break">.</span></li>
<li>Spring Security will intercept the secured URL and use <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">LoginUrlAuthentication</strong></span><strong class="source-inline">
EntryPoint</strong> object to <span class="No-Break">process it.</span></li>
<li>The <strong class="source-inline">LoginUrlAuthenticationEntryPoint</strong> object will send the user to the login page. Enter <strong class="source-inline">admin1</strong> as the username, <strong class="source-inline">example.com</strong> as the domain, and <strong class="source-inline">admin1</strong> as <span class="No-Break">the password.</span></li>
<li>The <strong class="source-inline">DomainUsernamePasswordAuthenticationFilter</strong> object will intercept the process of the login request. It will then obtain the username, domain, and password from the HTTP request and create a <span class="No-Break"><strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong></span><span class="No-Break"> object.</span></li>
<li>The <strong class="source-inline">DomainUsernamePasswordAuthenticationFilter</strong> object submits <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CalendarUser</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">AuthenticationProvider</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="source-inline">CalendarUserAuthenticationProvider</strong> interface <span class="No-Break">validates </span><span class="No-Break"><strong class="source-inline">DomainUsername</strong></span><strong class="source-inline">
PasswordAuthenticationToken</strong> and then returns an <span class="No-Break">authenticated </span><span class="No-Break"><strong class="source-inline">DomainUsername</strong></span><strong class="source-inline">
PasswordAuthenticationToken</strong> object (that is, <strong class="source-inline">isAuthenticated()</strong> <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">).</span></li>
<li>The <strong class="source-inline">DomainUserPasswordAuthenticationFilter</strong> object updates <strong class="source-inline">SecurityContext</strong> with <strong class="source-inline">DomainUsernamePasswordAuthenticationToken</strong> and places it <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">SecurityContextHolder</strong></span><span class="No-Break">.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter03.06-calendar</strong></span><span class="No-Break">.</span></p>
<p>Now that we have covered the<a id="_idIndexMarker214"/> users sign-up workflow and how to create custom <strong class="source-inline">UserDetailsService</strong> and <strong class="source-inline">AuthenticationProvider</strong> objects, we will discuss in the next section which authentication method should <span class="No-Break">be used.</span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor102"/>Which authentication method should you use?</h1>
<p>We have covered the three main methods of authenticating, so, which one is the best? Like all solutions, each comes with its pros and cons. You can find a summary <a id="_idTextAnchor103"/>of when to use a specific type of authentication by referring<a id="_idIndexMarker215"/> to the <span class="No-Break">following list:</span></p>
<ul>
<li><strong class="source-inline">SecurityContextHolder</strong>: Interacting directly with <strong class="source-inline">SecurityContextHolder</strong> is certainly the easiest way of authenticating a user. It works well when you are authenticating a newly created user or authenticating unconventionally. By using <strong class="source-inline">SecurityContextHolder</strong> directly, we do not have to interact with so many Spring Security layers. The downside is that we do not get some of the more advanced features that Spring Security provides automatically. For example, if we want to send the user to the previously requested page after logging in, we will have to manually integrate that into <span class="No-Break">our controller.</span></li>
<li><strong class="source-inline">UserDetailsService</strong>: Creating a custom <strong class="source-inline">UserDetailsService</strong> object is an easy mechanism that allows Spring Security to make security decisions based on our custom domain model. It also provides a mechanism to hook into other Spring Security features. For example, Spring Security requires <strong class="source-inline">UserDetailsService</strong> to use the built-in remember-me support covered in <a href="B21757_07.xhtml#_idTextAnchor220"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Remember-me Services</em>. The <strong class="source-inline">UserDetailsService</strong> object does not work when authentication is not based on a username <span class="No-Break">and password.</span></li>
<li><strong class="source-inline">AuthenticationProvider</strong>: This is<a id="_idIndexMarker216"/> the most flexible method for extending Spring Security. It allows a user to authenticate with any parameters that they wish. However, if we wish to leverage features such as Spring Security’s remember-me, we will still <span class="No-Break">need </span><span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break">.</span></li>
</ul>
<h1 id="_idParaDest-79"><a id="_idTextAnchor104"/>Summary</h1>
<p>This chapter has used real-world problems to introduce the basic building blocks used in Spring Security. It also demonstrates to us how we can make Spring Security authenticate against our custom domain objects by extending those basic building blocks. In short, we have learned that the <strong class="source-inline">SecurityContextHolder</strong> interface is the central location for determining the current user. Not only can it be used by developers to access the current user, but also to set the currently <span class="No-Break">logged-in user.</span></p>
<p>We also explored how to create custom <strong class="source-inline">UserDetailsService</strong> and <strong class="source-inline">AuthenticationProvider</strong><span class="L---Numbers-Char"> </span>objects and how to perform authentication with more than just a username <span class="No-Break">and password.</span></p>
<p>In the next chapter, we will explore some of the built-in support for <strong class="bold">Java Database Connectivity</strong> (<span class="No-Break"><strong class="bold">JDBC</strong></span><span class="No-Break">)-based authentication.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer032">
<h1 id="_idParaDest-80" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor105"/>Part 2: Authentication Techniques</h1>
<p>In this part, we explore various authentication methods and services provided by Spring Security. First, we delve into authenticating users against a database using Spring Security’s JDBC support. Additionally, we discuss securing passwords with Spring Security’s cryptography module to <span class="No-Break">enhance security.</span></p>
<p>Moving on, we will explore the integration of Spring Data with Spring Security, utilizing JPA to authenticate against relational databases and MongoDB for <span class="No-Break">document databases.</span></p>
<p>Next, we will introduce the <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) and its integration with Spring Security. We explore how LDAP can provide authentication, authorization, and user information services within a Spring <span class="No-Break">Security-enabled application.</span></p>
<p>Then, we uncover the functionality of the remember-me feature in Spring Security and its configuration. Additionally, we address considerations when implementing the remember-me functionality, enabling applications to remember users even after session expiration and <span class="No-Break">browser closure.</span></p>
<p>Lastly, we will explore alternative authentication methods that are available to accommodate various credential types. We transcend traditional form-based authentication to delve into the realm of authentication using trusted client-side certificates. Spring Security provides robust support for these diverse authentication requirements, offering a framework to implement and manage authentication using client-side certificates, thus enhancing security measures <span class="No-Break">within applications.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21757_04.xhtml#_idTextAnchor106"><em class="italic">Chapter 4</em></a>, <em class="italic">JDBC-</em><em class="italic">based</em><em class="italic"> Authentication</em></li>
<li><a href="B21757_05.xhtml#_idTextAnchor150"><em class="italic">Chapter 5</em></a>, <em class="italic">Authentication with Spring Data</em></li>
<li><a href="B21757_06.xhtml#_idTextAnchor180"><em class="italic">Chapter 6</em></a>, <em class="italic">LDAP Directory Services</em></li>
<li><a href="B21757_07.xhtml#_idTextAnchor220"><em class="italic">Chapter 7</em></a>, <em class="italic">Remember-</em><em class="italic">me</em><em class="italic"> Services</em></li>
<li><a href="B21757_08.xhtml#_idTextAnchor261"><em class="italic">Chapter 8</em></a>, <em class="italic">Client Certificate Authentication with TLS</em></li>
</ul>
</div>
<div>
<div id="_idContainer033">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer034">
</div>
</div>
</div></body></html>