<html><head></head><body>
		<div>
			<div id="_idContainer302" class="Content">
			</div>
		</div>
		<div id="_idContainer303" class="Content">
			<h1 id="_idParaDest-331"><a id="_idTextAnchor431"/>15. The Frontend: A ClojureScript UI</h1>
		</div>
		<div id="_idContainer311" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will go over the basics of React's virtual DOM and lifecycle and then provide the tools necessary to build a rich user interface for the data application outlined in the previous chapters. We will see how to call JavaScript code from ClojureScript and how to convert between JavaScript and ClojureScript objects.</p>
			<p class="callout">By the end of this chapter, you will be able to build a rich user interface for a data application.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor432"/>Introduction</h1>
			<p>Clojure is a hosted language, which means that it runs on top of another language. In the same way that Clojure runs on top of the JVM, ClojureScript runs on top of JavaScript. More precisely, a ClojureScript program is transpiled into a JavaScript program that can run in the browser, on the server side, and in any environment where JavaScript is supported. For example, consider Node.js, an open source JavaScript server environment that allows us to execute JavaScript programs.</p>
			<p>In this chapter, we will learn the basics of ClojureScript and how to create a ClojureScript program that runs in the browser. We will build a small frontend application on top of the Reagent framework that connects to an HTTP endpoint and displays <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) components that the user can interact with. We will use Hiccup as a markup language for the UI components and discover how to execute JavaScript code from ClojureScript.</p>
			<p>We will build an application using Figwheel, which supports hot code reloading. When your application is up, you will modify it either by changing its code or by evaluating code in the REPL. Your application will be magically updated without ever needing to refresh the page.</p>
			<p>We will learn how to organize the different components of a Reagent application: the CSS, the HTML, and the <strong class="source-inline">cljs</strong> files. We will build several Reagent components that access and modify the state of the app and fetch data from the network.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor433"/>Hiccup instead of HTML</h1>
			<p>Hiccup is a library for representing HTML in Clojure. In <em class="italic">Activity 6.01</em>, <em class="italic">Generating HTML from Clojure Vectors</em>, you implemented a simplified version of Hiccup. As you'll remember, Hiccup uses:</p>
			<ul>
				<li>Vectors to represent elements</li>
				<li>Maps to represent an element's attributes (including styles)</li>
			</ul>
			<p>In a Hiccup vector, the first element is a keyword that specifies the corresponding HTML element:</p>
			<ul>
				<li><strong class="source-inline">:div</strong> for a <strong class="source-inline">&lt;div&gt;</strong> tag</li>
				<li><strong class="source-inline">:span</strong> for a <strong class="source-inline">&lt;span&gt;</strong> tag</li>
				<li><strong class="source-inline">:img</strong> for a <strong class="source-inline">&lt;img&gt;</strong> tag</li>
			</ul>
			<p>In Hiccup, an empty <strong class="source-inline">&lt;div&gt;</strong> is represented by <strong class="source-inline">[:div]</strong>.</p>
			<p>The second element is an optional map that represents the element's attributes where the names of the attributes follow the kebab-case convention: we separate the words with one underscore character (<strong class="source-inline">on-click</strong> instead of <strong class="source-inline">onClick</strong>).</p>
			<p>For example, <strong class="source-inline">[:div {:class "myDiv"}]</strong> represents <strong class="source-inline">&lt;div class="myDiv"&gt;&lt;/div&gt;</strong>.</p>
			<p>Notice that in HTML, the <strong class="source-inline">style</strong> attribute is a string while in Hiccup it is a map where the keys follow the kebab-case convention. For example, consider the following example:</p>
			<p class="source-code">[:div </p>
			<p class="source-code">  {:style {:color "white"</p>
			<p class="source-code">           :background-color "blue" }}</p>
			<p class="source-code">   "Hello Hiccup"] </p>
			<p>This represents the following in HTML:</p>
			<p class="source-code">&lt;div style="color: white; background-color: blue;"&gt;Hello Hiccup&lt;/div&gt;</p>
			<p>Here, color: white denotes that the color of the <strong class="source-inline">Hello Hiccup</strong> text and <strong class="source-inline">background-color</strong> will be blue within the <strong class="source-inline">div</strong> tag.</p>
			<p>Following the optional map of attributes, we have the children—as many as we want. For example, consider the following:</p>
			<p class="source-code">[:div "Hello " "my " "friends!"]</p>
			<p>It represents the following:</p>
			<p class="source-code">&lt;div&gt;Hello my friends&lt;/div&gt;</p>
			<p>We can nest Hiccup elements as children of Hiccup elements. For instance, consider the following:</p>
			<p class="source-code">[:div </p>
			<p class="source-code"> [:img {:src "https://picsum.photos/id/10/2500/1667"}]</p>
			<p class="source-code">   [:div "A beautiful image"]]</p>
			<p>This represents the following HTML code:</p>
			<p class="source-code">&lt;div&gt;</p>
			<p class="source-code">  &lt;img src="https://picsum.photos/id/10/2500/1667"&gt; &lt;/img&gt;</p>
			<p class="source-code">  &lt;div&gt;A beautiful image &lt;/div&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>In Hiccup, we can specify the class of an element in two ways:</p>
			<ul>
				<li>Specifying an element's attributes:<p class="source-code">[:div {:class "myClass"} "Life is beautiful"]</p></li>
				<li>Using Hiccup shorthand, by appending a dot and the name of the class:<p class="source-code">[:div.myClass "Life is beautiful"]</p></li>
			</ul>
			<p>Compared to HTML, Hiccup is more compact and more readable.</p>
			<p>In addition, we can blend code and data in Hiccup to generate UI components dynamically without requiring an additional template language, like we usually do in JavaScript.</p>
			<p>For instance, let's say we want to create a list of 10 <strong class="source-inline">todo</strong> items. We would usually write them down manually as follows:</p>
			<p class="source-code">[:ul</p>
			<p class="source-code"> [:li "todo 1"]</p>
			<p class="source-code"> [:li "todo 2"]</p>
			<p class="source-code"> [:li "todo 3"]</p>
			<p class="source-code">...]</p>
			<p>However, we can generate the exact same Hiccup element with <strong class="source-inline">map</strong> and <strong class="source-inline">into</strong>:</p>
			<p class="source-code">  (into [:ul] </p>
			<p class="source-code">     <a id="_idTextAnchor434"/>(map (fn [num] [:li (str "todo " num)]) (range 10)))</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor435"/>Getting Started with Reagent</h2>
			<p>Reagent is a minimalistic ClojureScript wrapper for React.js. React.js is a JavaScript library for building a UI.</p>
			<p>A Reagent component is similar to a Hiccup component except that the first element can be either a keyword or a function. When it's a keyword, it is a Hiccup component and when it's a function, Reagent calls the function in order to render the component and passes to the function the remaining parts of the vector. </p>
			<p>A Reagent app is made of three parts: the ClojureScript code, the HTML page, and the CSS rules.</p>
			<p>In Reagent, like in React, the HTML page is minimalistic: it is mainly a <strong class="source-inline">&lt;div&gt;</strong> element with an ID, usually <strong class="source-inline">&lt;div id="app"&gt;</strong>. </p>
			<p>The CSS rules work the same as in any JavaScript application. The ClojureScript code usually starts at the core.cljs file, which renders the main component of the application. In the exercises and the activities of this chapter, the app will be made of a single namespace, but in a production application, the application is split into several namespaces, like in Clojure.</p>
			<p>In Reagent, the state of the application is stored in a ratom (shorthand for reagent/atom), which has the same interface as regular Clojure atoms. The difference between a ratom and a Clojure atom is that when a ratom changes, the UI is rerendered. </p>
			<p>React.js embraces the functional programming approach and encourages the developer to build their frontend application from components that manipulate data structures. The data structures are rendered by React in the browser's <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) in a very efficient way. React keeps the developer's mind free from having to deal with the DOM at a low level, enabling them to focus on the business logic.</p>
			<p>Clojure's data-oriented approach, its immutable data structures, and the way it manages changes via atoms make React and ClojureScript a powerful combination. </p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor436"/>The Virtual DOM and Component Lifecycle</h1>
			<p>When we build an application in React.js, we don't deal directly with the DOM, which is the browser's rendering mechanism and object model. Instead, React exposes a virtual DOM to the developer and keeps the implementation details hidden from them. This is what makes React so powerful. In a nutshell, when developing a React application, the developer writes React components that return data structures and the React frameworks automatically update the DOM and render the component on the UI.</p>
			<p>Moreover, React is smart enough to calculate the smallest amount of DOM changes that are required in order to update the state of the UI, which makes React applications highly performant. </p>
			<p>If a complex component's behavior is required by the application, such as doing something special as soon as the component is mounted or just before the component is updated, React provides lifecycle methods that the component can interact with.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor437"/>Exercise 15.01: Creating a Reagent Application</h2>
			<p>In this exercise, we're going to create a very simple Hiccup component in Reagent: an image with a couple of CSS properties. The CSS properties that we are going to use through the chapter are:</p>
			<ul>
				<li>Padding: 7px; // the inner padding</li>
				<li>Cursor: pointer; // the type of cursor</li>
				<li>Margin-left: 10px; // horizontal spacing between elements</li>
				<li>Margin-bottom: 10px; // vertical spacing between elements</li>
				<li>Border: 1px solid gray; // a 1px solid border of color gray</li>
				<li>Border-radius: 10px; // the radius of the corners</li>
				<li>Color: gray; // the text color</li>
				<li>Font-size: 15px; // the size of the font</li>
				<li>Float: left; horizontal alignment instead of the default vertical alignment </li>
			</ul>
			<ol>
				<li>At the command-line prompt, create a new Figwheel project using the following Leiningen command:<p class="source-code">lein new figwheel packt-clj.reagent-sandbox -- --reagent</p></li>
				<li>Change folder to the <strong class="source-inline">packt-clj.reagent-sandbox/</strong> directory and type the following command to launch the application:<p class="source-code">lein figwheel</p><p>After a few seconds, your browser should open to the default Figwheel page:</p><div id="_idContainer304" class="IMG---Figure"><img src="image/B14502_15_01.jpg" alt="Figure 15.1: A fresh ClojureScript project waiting for your code&#13;&#10;"/></div><p class="figure-caption">Figure 15.1: A fresh ClojureScript project waiting for your code</p></li>
				<li>Under the current folder, open the <strong class="source-inline">src/packt_clj/reagent_sandbox/core.cljs</strong> file in your preferred editor and take a look at the following expression:<p class="source-code">(reagent/render-component [hello-world]</p><p class="source-code">                          (. js/document (getElementById "app")))</p><p>This code renders the UI by calling the <strong class="source-inline">reagent/render-component</strong> function with two arguments. The first is the Reagent component to render <strong class="source-inline">[hello-world]</strong> and the HTML element where the component is going to be rendered – in our case, the element whose ID is <strong class="source-inline">app</strong>. </p></li>
				<li>Let's look now at the <strong class="source-inline">hello-world</strong> function that renders the main component of the application:<p class="source-code">(defn hello-world []</p><p class="source-code">  [:div</p><p class="source-code">   [:h1 (:text @app-state)]</p><p class="source-code">   [:h3 "Edit this and watch it change!"]])</p><p><strong class="source-inline">hello-world</strong> returns a vector, a Hiccup component of type <strong class="source-inline">:div</strong>, with two children. The first child is <strong class="source-inline">[:h1 (:text @app-state)]</strong>, which is an <strong class="source-inline">:h1</strong> component with text that comes from the <strong class="source-inline">:text</strong> value of the dereferencing of the <strong class="source-inline">app-state</strong> atom (see <em class="italic">Chapter 12</em>, <em class="italic">Concurrency</em>, about atoms). The second child is <strong class="source-inline">[:h3 "Edit this and watch it change!"]</strong>, which is an <strong class="source-inline">:h3</strong> component with fixed text. Let's see that in action!</p></li>
				<li>Go back to the Terminal window where you ran lein figwheel. You are in a Figwheel REPL. You should see a prompt like this:<p class="source-code">dev:cljs.user =&gt;</p></li>
				<li>Now, let's switch to the packt-clj.reagent-sandbox.core namespace by typing the following in the REPL:<p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; (require 'packt-clj.reagent-sandbox.core)</p><p class="source-code">nil</p><p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; (in-ns 'packt-clj.reagent-sandbox.core)</p><p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; </p></li>
				<li>Now, let's inspect the state of our app:<p class="source-code">dev:packt-clj.reagent-sandbox.core!{:conn 2}=&gt; app-state</p><p class="source-code">#&lt;Atom: {:text "Hello world!"}&gt;</p></li>
				<li>And let's modify the value of <strong class="source-inline">:text</strong> in the atom:<p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; (swap! app-state assoc-in [:text] "Hello Reagent!")</p><p class="source-code">{:text "Hello Reagent!"}</p><p>The application immediately updates with the new text:</p><div id="_idContainer305" class="IMG---Figure"><img src="image/B14502_15_02.jpg" alt="Figure 15.2: Printing the updated text&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 15.2: Printing the updated text</p>
			<p>As we mentioned before, <strong class="source-inline">app-state</strong> is a ratom; therefore, when it changes, Reagent rerenders the UI.</p>
			<h2 id="_idParaDest-337">Ex<a id="_idTextAnchor438"/>ercise 15.02: Displaying an Image with Style</h2>
			<p>Let's render an image with a couple of CSS properties:</p>
			<ol>
				<li value="1">Edit <strong class="source-inline">src/packt_clj/reagent_sandbox/core.cljs</strong>:<p class="source-code">(defn image [url]</p><p class="source-code">  [:img {:src url</p><p class="source-code">         :style {:width "500px" </p><p class="source-code">                 :border "solid gray 3px"</p><p class="source-code">                 :border-radius "10px"}}])</p><p class="source-code">(defn hello-world []</p><p class="source-code">  [:div</p><p class="source-code">   [:h1 (:text @app-state)]</p><p class="source-code">   [:div [image «https://picsum.photos/id/0/5616/3744»]]</p><p class="source-code">   [:h3 "Edit this and watch it change!"]])</p><p>The first part creates an image component and the second part includes an instance of the image component as part of the main component of the app. The moment you save the file, your app should look like this:</p><div id="_idContainer306" class="IMG---Figure"><img src="image/B14502_15_03.jpg" alt="Figure 15.3: Rendering the image&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 15.3: Rendering the image</p>
			<p>This is what we call hot code reloading: you change the code and the app updates immediately without refreshing the page.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor439"/>Managing Component State</h2>
			<p>In Reagent, the behavior of a component depends on the state of the component. The state is stored in two places:</p>
			<ul>
				<li>The arguments passed to the component when the component is instantiated</li>
				<li>A ratom</li>
			</ul>
			<p>Arguments passed to the component cannot be modified by the component but a ratom can be modified. This is useful when we want to allow a component to change the state of itself (or of another component) upon user interaction (for example, a click).</p>
			<p>To build real-life production applications with complex application state, we use a framework on top of Reagent, for instance, Reframe, a popular framework for writing single-page applications on top of Reagent.</p>
			<h2 id="_idParaDest-339">Exe<a id="_idTextAnchor440"/>rcise 15.03: A Button that Modifies Its Text</h2>
			<p>Let's create a toggle button whose initial text is "ON" and that changes its text to "OFF" when we click on it:</p>
			<ol>
				<li value="1">Edit <strong class="source-inline">src/packt_clj/reagent_sandbox/core.cljs</strong>. We add to the <strong class="source-inline">app-state</strong> ratom information about whether the button is on or off by including a :<strong class="source-inline">button-on?</strong> key whose initial value is <strong class="source-inline">true</strong>:<p class="source-code">(defonce app-state (atom {:text "Hello world!"</p><p class="source-code">                          :button-on? true}))</p></li>
				<li>Now we create the <strong class="source-inline">button</strong> component with the text of the button depending on the value of <strong class="source-inline">:button-on?</strong> and the click handler toggles the value of <strong class="source-inline">:button-on?</strong>. Notice that the click handler is referenced by <strong class="source-inline">:on-click</strong> (while in plain HTML, it's <strong class="source-inline">onClick</strong>):<p class="source-code">(defn button []</p><p class="source-code">  (let [text (if (get-in @app-state [:button-on?]) "ON" "OFF")]</p><p class="source-code">    [:button</p><p class="source-code">     {:on-click #(swap! app-state update-in [:button-on?] not)}</p><p class="source-code">     text]))</p></li>
				<li>Finally, we instantiate the button as part of our app:<p class="source-code">(defn hello-world []</p><p class="source-code">  [:div</p><p class="source-code">   [:h1 (:text @app-state)]</p><p class="source-code">   [button]</p><p class="source-code">   [:div [image "https://picsum.photos/id/0/5616/3744"]]</p><p class="source-code">   [:h3 "Edit this and watch it change!"]])</p><p>Switch to your browser window, <strong class="bold">refresh the page</strong>, click on the button, and see how the text modifies itself. In this case, we have to refresh the page because we have changed the initial state of the app.</p></li>
				<li>You can also change the state of the button via the REPL:<p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; (swap! app-state assoc-in [:button-on?] true)</p><p class="source-code">{:text "Hello world!", :button-on? true}</p><p>The UI is updated immediately. We don't need to refresh the page due to hot reload. Clicking on the button or swapping the ratom are two equivalent ways to update the state of the app.</p></li>
			</ol>
			<h2 id="_idParaDest-340">Com<a id="_idTextAnchor441"/>ponents with Children Components</h2>
			<p>As we saw when we introduced Hiccup, we can programmatically generate child components inside a Reagent component. For instance, we can start from an array of image URLs and convert each URL into an image component. This way, we are able to programmatically generate a grid of images.</p>
			<h2 id="_idParaDest-341">Exe<a id="_idTextAnchor442"/>rcise 15.04: Creating a Grid of Images</h2>
			<p>Let's create a component that renders a collection of images in a grid:</p>
			<ol>
				<li value="1">Edit <strong class="source-inline">src/packt_clj/reagent_sandbox/core.cljs</strong>. First, we create an <strong class="source-inline">image-with-width</strong> component that receives the image width as an argument:<p class="source-code">(defn image-with-width [url width]</p><p class="source-code">  [:img {:src url</p><p class="source-code">              :style {:width width</p><p class="source-code">                      :border "solid gray 3px"</p><p class="source-code">                      :border-radius "10px"}}])</p></li>
				<li>Create a grid component as follows:<p class="source-code">(defn image-grid [images]</p><p class="source-code">  (into [:div]</p><p class="source-code">        (map (fn [image-data] </p><p class="source-code">               [:div {:style {:float "left" </p><p class="source-code">                              :margin-left "20px"}}</p><p class="source-code">                [image-with-width image-data "50px"]])</p><p class="source-code">             images)))</p></li>
				<li>Now, we create a vector of image URLs:<p class="source-code">(def my-images</p><p class="source-code">  ["https://picsum.photos/id/0/5616/3744"</p><p class="source-code">   "https://picsum.photos/id/1/5616/3744"</p><p class="source-code">   "https://picsum.photos/id/10/2500/1667"</p><p class="source-code">   "https://picsum.photos/id/100/2500/1656"</p><p class="source-code">   "https://picsum.photos/id/1000/5626/3635"</p><p class="source-code">   "https://picsum.photos/id/1001/5616/3744"</p><p class="source-code">   "https://picsum.photos/id/1002/4312/2868"</p><p class="source-code">   "https://picsum.photos/id/1003/1181/1772"</p><p class="source-code">   "https://picsum.photos/id/1004/5616/3744"</p><p class="source-code">   "https://picsum.photos/id/1005/5760/3840"])</p></li>
				<li>Finally, we instantiate the image grid with <strong class="source-inline">my-images</strong>:<p class="source-code">(defn hello-world []</p><p class="source-code">  [:div</p><p class="source-code">    [:h1 (:text @app-state)]</p><p class="source-code">    [image-grid my-images]])</p><p>Now, when we switch to the browser window, we see the following:</p><div id="_idContainer307" class="IMG---Figure"><img src="image/B14502_15_04.jpg" alt="Figure 15.4: The image grid&#13;&#10;"/></div><p class="figure-caption">Figure 15.4: The image grid</p></li>
				<li>In order to get a better understanding of <strong class="source-inline">image-grid</strong>, let's inspect the <strong class="source-inline">Hiccup</strong> vector returned by the <strong class="source-inline">image-grid</strong> function in the REPL when we pass to it the first three elements of <strong class="source-inline">my-images</strong>:<p class="source-code">dev:packt-clj.reagent-sandbox.core=&gt; (image-grid (take 3 my-images))</p><p>This will return the following:</p><p class="source-code">[:div</p><p class="source-code"> [:div</p><p class="source-code">  {:style {:float "left", :margin-left "20px"}}</p><p class="source-code">  [#object[packt_clj$reagent_sandbox$core$image_with_width]</p><p class="source-code">   «https://picsum.photos/id/0/5616/3744»</p><p class="source-code">   «50px»]]</p><p class="source-code"> [:div</p><p class="source-code">  {:style {:float "left", :margin-left "20px"}}</p><p class="source-code">  [#object[packt_clj$reagent_sandbox$core$image_with_width]</p><p class="source-code">   «https://picsum.photos/id/1/5616/3744»</p><p class="source-code">   «50px»]]</p><p class="source-code"> [:div</p><p class="source-code">  {:style {:float "left", :margin-left "20px"}}</p><p class="source-code">  [#object[packt_clj$reagent_sandbox$core$image_with_width]</p><p class="source-code">   «https://picsum.photos/id/10/2500/1667»</p><p class="source-code">   «50px»]]]</p></li>
			</ol>
			<p>It's a <strong class="source-inline">:div</strong> component with three children, where each child is a <strong class="source-inline">:div</strong> element with a <strong class="source-inline">style</strong> map and a nested <strong class="source-inline">image-with-width-component</strong>.</p>
			<h2 id="_idParaDest-342">Hot <a id="_idTextAnchor443"/>Reload</h2>
			<p>Have you noticed that <strong class="source-inline">app-state</strong> is defined via <strong class="source-inline">defonce</strong> and not via <strong class="source-inline">def</strong>, like we usually define vars in Clojure?</p>
			<p>The difference between <strong class="source-inline">defonce</strong> and <strong class="source-inline">def</strong> is that when <strong class="source-inline">defonce</strong> is called twice, the second call has no effect.</p>
			<p>Let's take a look at a simple example:</p>
			<p class="source-code">(defonce a 1)</p>
			<p class="source-code">(defonce a 2)</p>
			<p>The value of <strong class="source-inline">a</strong> is now <strong class="source-inline">1</strong>. In the context of hot reloading, defonce is crucial. The reason is that with hot code reloading, we want:</p>
			<ul>
				<li>The code to be reloaded</li>
				<li>The state of the app to remain the same</li>
			</ul>
			<p>Those two desires seem contradictory because the initial state of the <strong class="source-inline">app</strong> is defined in the code. As a consequence, reloading the code seems to imply re-initializing the state of the <strong class="source-inline">app</strong>. Here, <strong class="source-inline">defonce</strong> comes to the rescue. The code that sets the initial state of the <strong class="source-inline">app</strong> is called only once!</p>
			<p>If you are curious, you can, just for the sake of understanding the difference between <strong class="source-inline">defonce</strong> and <strong class="source-inline">def</strong>, replace <strong class="source-inline">defonce</strong> with <strong class="source-inline">def</strong> in the code of the app you built and see how the app comes back to its initial state each time we save a code change. </p>
			<h2 id="_idParaDest-343">Java<a id="_idTextAnchor444"/>Script Interop</h2>
			<p>Now it's time to learn how in ClojureScript, we can interop with the underlying JavaScript language. By interop, we mean mainly:</p>
			<ul>
				<li>Accessing the window global object from ClojureScript </li>
				<li>Calling a JavaScript function from ClojureScript code </li>
				<li>Converting between JavaScript and ClojureScript objects</li>
			</ul>
			<p>In order to access the window scope, we use the <strong class="source-inline">js/</strong> prefix. For instance, <strong class="source-inline">js/document</strong> represents the document object and <strong class="source-inline">js/Math.abs</strong> represents the <strong class="source-inline">abs</strong> function in the <strong class="source-inline">Math</strong> scope. In order to call a method on a JavaScript object, we use dot notation, as follows:</p>
			<ul>
				<li><strong class="source-inline">(. js/Math abs -3)</strong> is equivalent to <strong class="source-inline">Math/abs(3)</strong>.</li>
				<li><strong class="source-inline">(. js/document (getElementById "app"))</strong> corresponds to <strong class="source-inline">document. getElementById("app")</strong>. </li>
			</ul>
			<p>Now, you can fully understand the expression in <strong class="source-inline">src/packt_clj/reagent_sandbox/core.cljs</strong> that renders the UI:</p>
			<p class="source-code">(reagent/render-component [hello-world]</p>
			<p class="source-code">                          (. js/document (getElementById "app")))</p>
			<p>When we want to convert between JavaScript and ClojureScript objects, we use the js-&gt;clj and clj-&gt;js functions.</p>
			<p>Consider the following example:</p>
			<p class="source-code">(clj-&gt;js {"total" 42}) </p>
			<p>This returns the JavaScript object {total: 42}, represented in the REPL as #js {:total 42}.</p>
			<p>Notice that ClojureScript keywords are converted into strings:</p>
			<p class="source-code">(clj-&gt;js {:total 42})</p>
			<p>This returns the JavaScript object <strong class="source-inline">{total: 42}</strong>.</p>
			<p><strong class="source-inline">clj-&gt;js</strong> works recursively, which means that nested objects are also converted to JavaScript objects. Consider the following example:</p>
			<p class="source-code">(clj-&gt;js {"total" 42</p>
			<p class="source-code">                "days" ["monday" "tuesday"]})</p>
			<p>This will return the following:</p>
			<p class="source-code">{total: 42, </p>
			<p class="source-code">  days: ["monday" "tuesday"]}</p>
			<p>You can also use the <strong class="source-inline">#js</strong> notation to generate a JavaScript object, but note that it is not recursive. <strong class="source-inline">#js {:total 42}</strong> in ClojureScript generates <strong class="source-inline">{total: 42}</strong> in JavaScript.</p>
			<p>What about the other direction, from JavaScript to ClojureScript? You use the <strong class="source-inline">js-&gt;clj</strong> function. <strong class="source-inline">(js-&gt;clj #js {"total" 42})</strong> returns the ClojureScript object <strong class="source-inline">{"total" 42}</strong>.</p>
			<p>If you want JavaScript strings to be converted to ClojureScript keywords, you need to keywordize the keys by passing extra args to <strong class="source-inline">js-&gt;clj</strong>:</p>
			<p class="source-code">(js-&gt;clj #js {"total" 42} :keywordize-keys true)</p>
			<p>This returns the ClojureScript object <strong class="source-inline">{:total 42}</strong>.</p>
			<h2 id="_idParaDest-344">Exer<a id="_idTextAnchor445"/>cise 15.05: Fetching Data from an HTTP Endpoint</h2>
			<p>Let's use our JavaScript interop knowledge to fetch data from an HTTP endpoint that returns JSON, namely <a href="https://packt.live/2RURzar">https://packt.live/2RURzar</a>. This endpoint returns a JSON array made of three objects with data about images:</p>
			<ol>
				<li value="1">In JavaScript, we would fetch the JSON by using the JavaScript <strong class="source-inline">fetch</strong> function and two promises to convert the server response into a JSON object:<p class="source-code">fetch("https://picsum.photos/v2/list?limit=3")</p><p class="source-code">.then((function (response){</p><p class="source-code">  return response.json();</p><p class="source-code">}))</p><p class="source-code">.then((function (json){</p><p class="source-code">  return console.log(json);</p><p class="source-code">}))</p></li>
				<li>In ClojureScript, the preceding code translates to the following:<p class="source-code">(-&gt; (js/fetch "https://picsum.photos/v2/list?limit=3")</p><p class="source-code">    (.then (fn [response] (.json response)))</p><p class="source-code">    (.then (fn [json] (println  (js-&gt;clj json :keywordize-keys true)))))</p><p>It prints a ClojureScript vector to the console with three ClojureScript objects:</p><p class="source-code">[{:id "0",</p><p class="source-code">  :author "Alejandro Escamilla",</p><p class="source-code">  :width 5616,</p><p class="source-code">  :height 3744,</p><p class="source-code">  :url "https://unsplash.com/photos/yC-Yzbqy7PY",</p><p class="source-code">  :download_url "https://picsum.photos/id/0/5616/3744"}</p><p class="source-code"> {:id "1",</p><p class="source-code">  :author "Alejandro Escamilla",</p><p class="source-code">  :width 5616,</p><p class="source-code">  :height 3744,</p><p class="source-code">  :url "https://unsplash.com/photos/LNRyGwIJr5c",</p><p class="source-code">  :download_url "https://picsum.photos/id/1/5616/3744"}</p><p class="source-code"> {:id "10",</p><p class="source-code">  :author "Paul Jarvis",</p><p class="source-code">  :width 2500,</p><p class="source-code">  :height 1667,</p><p class="source-code">  :url "https://unsplash.com/photos/6J--NXulQCs",</p><p class="source-code">  :download_url "https://picsum.photos/id/10/2500/1667"}]</p></li>
			</ol>
			<p>All the pieces are now in place to build a small frontend application that displays a grid of images from the internet.</p>
			<h2 id="_idParaDest-345">Acti<a id="_idTextAnchor446"/><a id="_idTextAnchor447"/>vity 15.01: Displaying a Grid of Images from the Internet</h2>
			<p>You are asked to write a frontend application for a freelancer graphics editor that displays a grid of six images from and two buttons:</p>
			<ul>
				<li>A button that clears the images</li>
				<li>A button that hides the authors' names</li>
			</ul>
			<p>This button can be used by the graphics editor to see the author names to add to the images.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Create a new Figwheel project.</li>
				<li>Create two buttons; one will clear images and the other will hide author names.</li>
				<li>Add the images.</li>
			</ol>
			<p>Upon completing the activity, you should be able to see something like this:</p>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="image/B14502_15_05.jpg" alt="Figure 15.5: Expected outcome&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5: Expected outcome</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 758.</p>
			<h2 id="_idParaDest-346">Activ<a id="_idTextAnchor448"/><a id="_idTextAnchor449"/>ity 15.02: Tennis Players with Ranking</h2>
			<p>Let's wrap up this chapter by combining the knowledge gained from it with the material we covered in <em class="italic">Chapter 14</em>, <em class="italic">HTTP with Ring</em>. In the activity of <em class="italic">Chapter 14</em>, <em class="italic">HTTP with Ring</em>, we built an HTTP API server that returned data about tennis players. In the current activity, you are asked to build a frontend for this HTTP server.</p>
			<p>You have to build a web app that:</p>
			<ul>
				<li>Displays the names of all the tennis players </li>
				<li>Displays the ranking of any tennis player when the user clicks on their name </li>
			</ul>
			<p>Before starting, you need to perform the activity from <em class="italic">Chapter 14</em>, <em class="italic">HTTP with Ring</em>, with a slight change in the code of the server to support API requests from the web app we are going to build. The current activity is going to request data from this server. By default, web servers don't allow requests that come from another host. In our case, the API server runs on port <strong class="source-inline">8080</strong> while the frontend server runs on port <strong class="source-inline">3449</strong>. In order to allow requests that come from the frontend app to be served by the API server, we need to configure the API server so that it allows <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>).</p>
			<p>Before starting the activity, you'll need to make the following changes:</p>
			<ol>
				<li value="1">Open the folder that contains the code of <em class="italic">Activity 14.01</em>, <em class="italic">Exposing Historic Tennis Results and ELO Calculations via REST</em>.</li>
				<li>Add the following dependency to the <strong class="source-inline">deps.edn</strong> file:<p class="source-code">jumblerg/ring-cors {:mvn/version "2.0.0"}</p></li>
				<li>Open the <strong class="source-inline">packt-clj/src/packt_clj/tennis/api.clj</strong> file and add the following line in the <strong class="source-inline">require</strong> expression at the top of the file:<p class="source-code">[jumblerg.middleware.cors :refer [wrap-cors]]</p></li>
				<li>Open the <strong class="source-inline">packt-clj/src/packt_clj/tennis/api.clj</strong> file and add the following two lines in the definition of the <strong class="source-inline">run</strong> function at the end of the file:<p class="source-code">(wrap-cors ".*")</p><p class="source-code">(wrap-cors identity)</p><p>The <strong class="source-inline">run</strong> function should now look like this:</p><p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty</p><p class="source-code">    (-&gt; routes</p><p class="source-code">        middleware/wrap-format</p><p class="source-code">        params/wrap-params</p><p class="source-code">        (wrap-cors ".*")</p><p class="source-code">        (wrap-cors identity))</p><p class="source-code">    {:port  8080</p><p class="source-code">     :join? false}))</p></li>
				<li>Now, run the server as explained in <em class="italic">Activity 14.01</em>, Exposing Historic Tennis Results and ELO Calculations via REST.</li>
			</ol>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Set up a new Figwheel project that uses Reagent.</li>
				<li>Write code that fetches tennis player data from the server from <em class="italic">Chapter 14</em>, HTTP with Ring, and inserts it into the application state of your new ClojureScript app. You'll also want a field in the application state for the current player when a player has been selected.</li>
				<li>Write views for displaying the list of players and for displaying a single player with their data.</li>
				<li>Incorporate handlers for the links that select the player to view, and for the buttons that load and clear the list of players.<p>Upon completing the current activity, you should see something like this in your browser:</p><div id="_idContainer309" class="IMG---Figure"><img src="image/B14502_15_06.jpg" alt="Figure 15.6: List of players&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 15.6: List of players</p>
			<p>And when the user clicks on Michael Stich, the app looks like this:</p>
			<div>
				<div id="_idContainer310" class="IMG---Figure">
					<img src="image/B14502_15_07.jpg" alt="Figure 15.7: The rating of a player&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7: The rating of a player</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 762.</p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor450"/>Summary</h1>
			<p>In this chapter, you have learned the basics of how to build a frontend application in ClojureScript using Reagent, a wrapper around React.js.</p>
			<p>We built a couple of Reagent components using the Hiccup markup language, which uses Clojure collections to define the HTML structure and properties. The state of the application is stored in a Reagent atom that you interacted with through the REPL.</p>
			<p>We saw how to call JavaScript code from ClojureScript and how to convert between JavaScript and ClojureScript objects. You used these interop features to fetch image data from an HTTP server and convert the data into a ClojureScript object.</p>
			<p>We've reached the end of the book. You've seen a lot of new things since the first pages of <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>. Beyond the syntactic basics, you've learned a lot about functional programming and, even more importantly, how to think in a functional way. It's one thing to know what immutability is and something else entirely to know how to accomplish tasks using immutable data. By focusing intensively on collections, we were able to show you some of Clojure's most distinctive features, such as lazy sequences, while building up your mental library of useful patterns for solving problems. Clojure is often considered a data-centric language, so collections are a key part of that. Programming is more than just mastering language features. </p>
			<p>Our other focus has been on getting things done with Clojure, and that means knowing how to navigate in the Clojure tooling ecosystem. You've learned how to set up projects, how to use Leiningen for both Clojure and ClojureScript projects, and how to organize your namespaces. Platforms and interop are an important part of that picture too: you know the basics of using Java or JavaScript features in your Clojure(Script). Testing is another necessary skill for any real-world project. You know about that too now. You've also seen enough of macros and Clojure's concurrency tools that you will know where to start the first time you need them to solve a complex problem.</p>
			<p>Finally, you've worked with databases and web servers. On just about any software project, at least one of those two technologies will be present. Often, both will be. These are both vast topics in their own right, of course, but by now you have an idea of how to approach them in a Clojure way—and in a ClojureScript way, as you've done in this chapter. And beyond the details, we hope that your first steps in Clojure have opened your eyes to new ways of thinking about programming. That way, you'll be able to learn whatever you need down the road.</p>
		</div>
		<div>
			<div id="_idContainer312" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer313" class="Content">
			</div>
		</div>
	</body></html>