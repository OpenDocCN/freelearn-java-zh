<html><head></head><body>
<div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.2.1">Creating Adapters to Interact with the Outside World</span></h1>
<p><span class="koboSpan" id="kobo.3.1">There is a time in software development at which we need to decide which technologies will be supported by a system. </span><span class="koboSpan" id="kobo.3.2">We’ve discussed in previous chapters how technological choices should not be the primary driver for developing hexagonal applications. </span><span class="koboSpan" id="kobo.3.3">In fact, applications based on this architecture present a high degree of changeability, enabling a system to be integrated with different technologies with as little friction as possible. </span><span class="koboSpan" id="kobo.3.4">This is because the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">hexagonal architecture</span></strong><span class="koboSpan" id="kobo.5.1"> establishes a clear frontier between which part of the code is related to business and which is related </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to technology.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to explore the hexagonal approach to establishing this frontier. </span><span class="koboSpan" id="kobo.7.2">We’ll learn about the role adapters play when we need to set up technologies or protocols to enable a hexagonal application to communicate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">outside world.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll learn about the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Understanding adapters</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Using input adapters to allow </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">driving operations</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Using output adapters to speak with different </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">data sources</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">By the end of this chapter, you’ll know how input adapters, in conjunction with input ports, can be used to expose the same software features to work with different technologies. </span><span class="koboSpan" id="kobo.16.2">In the same vein, you will learn how output adapters are powerful in making your application more versatile when it needs to talk to different data </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">source technologies.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.21.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.23.1"> installed on your computer. </span><span class="koboSpan" id="kobo.23.2">To interact with the adapters, we also recommend installing </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">curl</span></strong><span class="koboSpan" id="kobo.25.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">jq</span></strong><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">All those tools are available for </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Linux</span></strong><span class="koboSpan" id="kobo.29.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">Mac</span></strong><span class="koboSpan" id="kobo.31.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Windows</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.33.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.38.1">Understanding adapters</span></h1>
<p><span class="koboSpan" id="kobo.39.1">In hexagonal architecture, adapters have a different role from those employed as a design pattern in object-oriented languages. </span><span class="koboSpan" id="kobo.39.2">As a design pattern, we use adapters to make the interfaces of two diverging classes compatible. </span><span class="koboSpan" id="kobo.39.3">In the hexagonal architecture, we use adapters to allow a system to be compatible with different technologies or protocols. </span><span class="koboSpan" id="kobo.39.4">Although the </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.40.1">adapter’s role as a hexagonal architecture concept or as a design pattern may differ, it would be correct to state that both approaches share the same purpose: to adapt something to fit correctly into </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">another thing.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">A practical analogy to understand the role adapters play in hexagonal architecture is about remote connections to a computer. </span><span class="koboSpan" id="kobo.42.2">Every modern operating system is compatible with remote connection protocols. </span><span class="koboSpan" id="kobo.42.3">In the past (and even today in certain situations), it was common to use </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Telnet</span></strong><span class="koboSpan" id="kobo.44.1"> to open a remote </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.45.1">connection to a computer. </span><span class="koboSpan" id="kobo.45.2">Over time, other protocols</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.46.1"> emerged, such as </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">SSH</span></strong><span class="koboSpan" id="kobo.48.1"> for console connections, </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">RDP</span></strong><span class="koboSpan" id="kobo.50.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Virtual Network Computing</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.53.1">VNC</span></strong><span class="koboSpan" id="kobo.54.1">) for </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.55.1">a </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">graphical alternative.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Those protocols only define how you’re going to access the operating system, and once you’re there, you can execute commands and have access to the features that an operating system provides. </span><span class="koboSpan" id="kobo.57.2">It’s not uncommon for an operating system to offer more than one protocol to allow remote connection. </span><span class="koboSpan" id="kobo.57.3">That’s good because it widens the communication possibilities. </span><span class="koboSpan" id="kobo.57.4">There may be situations in which it’s necessary to support both Telnet and SSH connections simultaneously, maybe because there is an unusual client that works only </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">with Telnet.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">By using the preceding analogy, we can replace the operating system with an application developed using </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Java</span></strong><span class="koboSpan" id="kobo.61.1">, or any other </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.62.1">programming language, and we can replace remote connection protocols such as SSH and Telnet with HTTP-based communication </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.63.1">protocols, such as </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">REST</span></strong><span class="koboSpan" id="kobo.65.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">gRPC</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">Assuming our</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.68.1"> Java application is a hexagonal one, the features offered by such applications are organized into use cases, ports, and business rules from the </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">Application</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">Domain</span></strong><span class="koboSpan" id="kobo.72.1"> hexagons. </span><span class="koboSpan" id="kobo.72.2">If you want to make those features available for both REST and gRPC clients, you need to create REST and gRPC adapters. </span><span class="koboSpan" id="kobo.72.3">Adapters used to expose application features are called </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">input adapters</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">To</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.75.1"> connect those input adapters to the rest of our system, we associate input ports with input adapters, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.77.1"><img alt="Figure 4.1 – The relationship between adapters and ports" src="image/B19777_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.78.1">Figure 4.1 – The relationship between adapters and ports</span></p>
<p><span class="koboSpan" id="kobo.79.1">We can define </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.80.1">input adapters to allow users and other systems to interact with the application. </span><span class="koboSpan" id="kobo.80.2">In the same way, we can also define output adapters to translate data generated by the hexagonal application and communicate with external systems. </span><span class="koboSpan" id="kobo.80.3">Here we can see that both input and output adapters live in the extremities of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.81.1">Framework</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1"> hexagon:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 4.2 – The location of input and output adapters" src="image/B19777_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 4.2 – The location of input and output adapters</span></p>
<p><span class="koboSpan" id="kobo.85.1">Let’s explore in the next section how we can work with </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">input adapters.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.87.1">Using input adapters to allow driving operations</span></h1>
<p><span class="koboSpan" id="kobo.88.1">You may have heard before that if there’s something we can always count on, it’s that things will always change. </span><span class="koboSpan" id="kobo.88.2">And</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.89.1"> when we talk about technological changes, that statement is even stronger. </span><span class="koboSpan" id="kobo.89.2">We live in an era where computers are </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.90.1">not as expensive as they used to be in the past. </span><span class="koboSpan" id="kobo.90.2">No matter whether we’re dealing with desktops, mobile, or cloud computing, year by year, computer resources, in general, become cheaper and more accessible to everyone. </span><span class="koboSpan" id="kobo.90.3">This accessibility means that more people tend to be involved and can collaborate with software </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">development initiatives.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">That growing collaboration results in newer programming languages, tools, and development frameworks to support the creative effort to solve people’s problems with better and modern solutions. </span><span class="koboSpan" id="kobo.92.2">In this innovative and technological heterogeneous context, a good amount of current software development is made. </span><span class="koboSpan" id="kobo.92.3">One of the concerns that arises when developing software in this context is how a system will stay relevant and profitable in the face of constant technological changes. </span><span class="koboSpan" id="kobo.92.4">If a system is designed to intertwine business rules with technological details, it won’t be easy to incorporate new technology without significant refactoring. </span><span class="koboSpan" id="kobo.92.5">In hexagonal architecture, input adapters are the elements that help us to make the software compatible with </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">different technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Input adapters are like the remote communication protocols mentioned in the example presented in the previous section. </span><span class="koboSpan" id="kobo.94.2">That comparison is valid because input adapters work like protocols, defining which technologies are supported as a means to access the features provided by a hexagonal system. </span><span class="koboSpan" id="kobo.94.3">Input adapters mark a clear frontier between what is inside the hexagon and what is outside, and perform what we call </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">driving operations.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">From outside the hexagon, there may be users or other systems interacting with the hexagonal application. </span><span class="koboSpan" id="kobo.96.2">We have learned that these users and systems are also known as primary actors, playing a pivotal </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.97.1">role in shaping application use cases. </span><span class="koboSpan" id="kobo.97.2">The interaction between primary actors and the hexagonal application occurs through input adapters. </span><span class="koboSpan" id="kobo.97.3">Such interaction is defined by driving operations. </span><span class="koboSpan" id="kobo.97.4">We call them driving because primary actors drive, in the sense that they initiate and influence the state and behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">hexagonal systems.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Input adapters, when put together, form the hexagonal application’s API. </span><span class="koboSpan" id="kobo.99.2">Because input adapters are in this boundary that exposes the hexagonal system to the outside world, they naturally become the interface for anyone interested in interacting with the system. </span><span class="koboSpan" id="kobo.99.3">As we progress in the book, we’ll see how to leverage the input adapters’ arrangement to structure and expose the </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.100.1">application APIs, using tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.102.1">Swagger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">We have emphasized the adapters’ characteristics to make a system compatible with different technologies </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.105.1">or protocols. </span><span class="koboSpan" id="kobo.105.2">A more </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.107.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.108.1">DDD</span></strong><span class="koboSpan" id="kobo.109.1">) approach suggests other purposes for using </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">an adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">A prevalent concern in DDD-based architectures is about integrating the elements of a legacy system into a new one. </span><span class="koboSpan" id="kobo.111.2">This occurs in scenarios where a legacy system with relevant knowledge crunched into its </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.112.1">domain model solves some important problems but also shows inconsistencies in its design. </span><span class="koboSpan" id="kobo.112.2">You don’t want to give up the legacy system, but you also don’t want</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.113.1"> the new system design to be influenced by the legacy system’s design. </span><span class="koboSpan" id="kobo.113.2">To tackle this situation, you can employ what </span><em class="italic"><span class="koboSpan" id="kobo.114.1">Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.115.1"> by Vaughn Vernon and </span><em class="italic"><span class="koboSpan" id="kobo.116.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.117.1"> by Eric Evans call an </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">anti-corruption layer</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">This </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.120.1">layer is based on the adapters used to integrate bounded contexts from both the legacy and the new systems. </span><span class="koboSpan" id="kobo.120.2">In such a scenario, the adapters are responsible for preventing the new system’s design from being contaminated by the legacy </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">system’s design.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Although we’re not applying this kind of usage of adapters in the hexagonal architecture, it’s important to be aware that we can use this DDD-based adapter approach for a </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">We learned that the connection between primary actors and the hexagonal application occurs through input adapters. </span><span class="koboSpan" id="kobo.124.2">Let’s see now how to make input adapters connect to other hexagons in </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the system.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.126.1">Creating input adapters</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.127.1">Input ports</span></strong><span class="koboSpan" id="kobo.128.1"> are</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.129.1"> the means through which we implement use cases, specifying how an</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.130.1"> input port performs the operations to achieve use case goals. </span><span class="koboSpan" id="kobo.130.2">The input port object needs to receive what Jacobson (1992) called a </span><em class="italic"><span class="koboSpan" id="kobo.131.1">stimulus</span></em><span class="koboSpan" id="kobo.132.1"> to perform its</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.133.1"> operations. </span><span class="koboSpan" id="kobo.133.2">This stimulus is nothing more than an object calling another. </span><span class="koboSpan" id="kobo.133.3">The input port object receives all the necessary data to conduct its operations through the stimulus sent by an input adapter. </span><span class="koboSpan" id="kobo.133.4">However, it’s at this stage that eventual transformations may take place to convert input data into a format that’s compatible with the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">In the previous chapter, we created a use case to add networks to a router. </span><span class="koboSpan" id="kobo.135.2">To achieve the use case goals, we’ll create two input adapters: an adapter for communication through HTTP REST and another for command-line execution. </span><span class="koboSpan" id="kobo.135.3">In the following UML diagram, we have </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.137.1"> as an abstract parent class extended</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.138.1"> by the </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">RouterNetworkRestAdapter</span></strong><span class="koboSpan" id="kobo.140.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.141.1">RouterNetworkCLIAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.142.1"> classes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.143.1"><img alt="Figure 4.3 – UML representation of input adapters" src="image/B19777_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 4.3 – UML representation of input adapters</span></p>
<p><span class="koboSpan" id="kobo.145.1">We will define an adapter abstract base class, followed by two implementations, one for an adapter to receive data from HTTP REST connections and another for the console </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">STDIN</span></strong><span class="koboSpan" id="kobo.147.1"> connection. </span><span class="koboSpan" id="kobo.147.2">To simulate access to these two adapters, we’ll create a client class to bootstrap </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the application.</span></span></p>
<h3><span class="koboSpan" id="kobo.149.1">The base adapter</span></h3>
<p><span class="koboSpan" id="kobo.150.1">Let’s </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.151.1">start </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.152.1">by defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.154.1"> abstract </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
public abstract class RouterNetworkAdapter {
    protected Router router;
    protected RouterNetworkUseCase;
    public Router addNetworkToRouter(
    Map&lt;String, String&gt; params){
        var routerId = RouterId.
</span><span class="koboSpan" id="kobo.156.2">               withId(params.get("routerId"));
        var network = new Network(IP.fromAddress(
               params.get("address")),
               params.get("name"),
               Integer.valueOf(params.get("cidr")));
        return routerNetworkUseCase.
</span><span class="koboSpan" id="kobo.156.3">               addNetworkToRouter(routerId, network);
    }
    public abstract Router processRequest(
                           Object requestParams);
}</span></pre> <p><span class="koboSpan" id="kobo.157.1">The idea of this base </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.158.1">adapter is to provide standard operations for communicating with the adapter’s</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.159.1"> correspondent input port. </span><span class="koboSpan" id="kobo.159.2">In that case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.161.1"> adapter method to receive the parameters required to build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">RouterID</span></strong><span class="koboSpan" id="kobo.163.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Network</span></strong><span class="koboSpan" id="kobo.165.1"> objects, which are utilized to start the use case operation to add the network to a router. </span><span class="koboSpan" id="kobo.165.2">These parameters may come from different sources, either via an HTTP request or via the shell/console with </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">STDIN</span></strong><span class="koboSpan" id="kobo.167.1">, but they are treated the same way once they arrive at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">addNetworkToRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">We don’t refer to input ports directly. </span><span class="koboSpan" id="kobo.170.2">Instead, we utilize a use case interface reference. </span><span class="koboSpan" id="kobo.170.3">This use</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.171.1"> case</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.172.1"> reference is passed and initialized by the input </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">adapter’s constructor.</span></span></p>
<h3><span class="koboSpan" id="kobo.174.1">The REST input adapter</span></h3>
<p><span class="koboSpan" id="kobo.175.1">Now</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.176.1"> that </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.177.1">we have defined the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.179.1"> abstract class, we can proceed to create the REST adapter. </span><span class="koboSpan" id="kobo.179.2">We start by defining the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">RouterNetworkRestAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
public RouterNetworkRestAdapter(RouterNetworkUseCase rout
  erNetworkUseCase){
    this.routerNetworkUseCase = routerNetworkUseCase;
}</span></pre> <p><span class="koboSpan" id="kobo.183.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">RouterNetworkRestAdapter</span></strong><span class="koboSpan" id="kobo.185.1"> constructor to receive and initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">RouterNetworkUseCase</span></strong><span class="koboSpan" id="kobo.187.1"> use </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">case reference.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">The following code shows us how a client could call-initialize this </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">RouterNetworkRestAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.191.1">input adapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
RouterNetworkOutputPort outputPort = RouterNet
  workH2Adapter.getInstance();
RouterNetworkUseCase usecase = new RouterNetworkInput
  Port(outputPort);
RouterManageNetworkAdapter inputAdapter = new RouterNet
  workRestAdapter(usecase);</span></pre> <p><span class="koboSpan" id="kobo.193.1">The intent here is to express that the REST input adapter requires an H2 in-memory database output adapter. </span><span class="koboSpan" id="kobo.193.2">Here, we’re explicitly stating which output adapter object the input adapter needs to perform its activities. </span><span class="koboSpan" id="kobo.193.3">That can be considered a vanilla approach, where we don’t use framework-based dependency injection techniques such as </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">CDI beans</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">Later</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.196.1"> on, all those adapter constructors can be removed to use dependency </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.197.1">injection </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.198.1">annotations from frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Quarkus</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.200.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.201.1">Spring</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">After </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.204.1">defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.206.1"> constructor, we </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.207.1">then implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">processRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
/**
* When implementing a REST adapter, the processRequest
  method receives an Object type parameter
* that is always cast to an HttpServer type.
</span><span class="koboSpan" id="kobo.210.2">*/
@Override
public Router (Object requestParams){
/** code omitted **/
    httpserver.createContext("/network/add", (exchange -&gt; {
      if ("GET".equals(exchange.getRequestMethod())) {
       var query = exchange.getRequestURI().getRawQuery();
       httpParams(query, params);
       router = this.addNetworkToRouter(params);
       ObjectMapper mapper = new ObjectMapper();
       var routerJson = mapper.writeValueAsString(
       RouterJsonFileMapper.toJson(router));
       exchange.getResponseHeaders().
</span><span class="koboSpan" id="kobo.210.3">       set("Content-Type","application/json");
       exchange.sendResponseHeaders(
       200,routerJson.getBytes().length);
       OutputStream output = exchange.getResponseBody();
       output.write(routerJson.getBytes());
       output.flush();
      } else {
        exchange.sendResponseHeaders(405, -1);
      }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.211.1">This method receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">httpServer</span></strong><span class="koboSpan" id="kobo.213.1"> object, which is used to create the HTTP endpoint to receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">GET</span></strong><span class="koboSpan" id="kobo.215.1"> requests at </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">/network/add</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">The client code that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">processRequest</span></strong><span class="koboSpan" id="kobo.219.1"> is similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">following excerpt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
var httpserver = HttpServer.create(new InetSocket
  Address(8080), 0);
routerNetworkAdapter.processRequest(httpserver);</span></pre> <p><span class="koboSpan" id="kobo.222.1">The REST adapter receives user data via an HTTP request, parses request parameters, and uses them to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.224.1"> defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">RouterNetworkAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.226.1">parent class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
router = this.addNetworkToRouter(params);</span></pre> <p><span class="koboSpan" id="kobo.228.1">Remember that the input adapter is responsible for converting user data into suitable parameters used to trigger an input port by using its use </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">case reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
routerNetworkUseCase.addNetworkToRouter(routerId, network);</span></pre> <p><span class="koboSpan" id="kobo.231.1">At this moment, the</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.232.1"> data leaves the Framework hexagon and goes to the </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">Application hexagon</span></strong><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">Now, let’s see how to connect another adapter to the same input port. </span><span class="koboSpan" id="kobo.234.3">The difference, though, is</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.235.1"> that this adapter is used for command-line</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.236.1"> execution. </span><span class="koboSpan" id="kobo.236.2">This time, the system will not receive data from an HTTP request but rather through a user typing via the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">keyboard (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">STDIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.240.1">The CLI input adapter</span></h3>
<p><span class="koboSpan" id="kobo.241.1">To create</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.242.1"> the second input adapter, we again extend the base </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">adapter class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
public class RouterNetworkCLIAdapter extends RouterNetwork
  Adapter {
    public RouterNetworkCLIAdapter(
    RouterNetworkUseCase routerNetworkUseCase){
        this.routerNetworkUseCase = routerNetworkUseCase;
    }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.245.1">We define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">RouterNetworkCLIAdapter</span></strong><span class="koboSpan" id="kobo.247.1"> constructor to receive and initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">RouterNetworkUseCase</span></strong><span class="koboSpan" id="kobo.249.1"> use case that this input </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">adapter needs.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">For the CLI input adapter, we use a different output adapter. </span><span class="koboSpan" id="kobo.251.2">Instead of persisting an in-memory database, this output adapter uses </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the filesystem.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The following code shows us how a client could initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">RouterNetworkCLIAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.255.1">input adapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
RouterNetworkOutputPort outputPort = RouterNetworkFileA
  dapter.getInstance();
RouterNetworkUseCase usecase = new RouterNetworkInput
  Port(outputPort);
RouterManageNetworkAdapter inputAdapter = new RouterNet
  workCLIAdapter(routerNetworkUseCase);</span></pre> <p><span class="koboSpan" id="kobo.257.1">First, we </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.258.1">get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">RouterNetworkOutputPort</span></strong><span class="koboSpan" id="kobo.260.1"> output port reference. </span><span class="koboSpan" id="kobo.260.2">Then, with that reference, we retrieve a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">RouterNetworkUseCase</span></strong><span class="koboSpan" id="kobo.262.1"> use case. </span><span class="koboSpan" id="kobo.262.2">Finally, we get </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">RouterNetworkAdapter</span></strong><span class="koboSpan" id="kobo.264.1"> using the use case </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">defined previously.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">The following is how we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">processRequest</span></strong><span class="koboSpan" id="kobo.268.1"> method for the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">CLI adapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
@Override
public Router processRequest(Object requestParams){
    var params = stdinParams(requestParams);
    router = this.addNetworkToRouter(params);
    ObjectMapper mapper = new ObjectMapper();
    try {
        var routerJson = mapper.writeValueAsString
                     (RouterJsonFileMapper.toJson(router));
        System.out.println(routerJson);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
    }
    return router;
}</span></pre> <p><span class="koboSpan" id="kobo.271.1">In the REST adapter, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">httpParams</span></strong><span class="koboSpan" id="kobo.273.1"> method to retrieve data from an HTTP request. </span><span class="koboSpan" id="kobo.273.2">Now, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">processRequest</span></strong><span class="koboSpan" id="kobo.275.1"> from the CLI adapter, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">stdinParams</span></strong><span class="koboSpan" id="kobo.277.1"> method to retrieve data from </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">processRequest</span></strong><span class="koboSpan" id="kobo.281.1"> methods from the REST and CLI adapters have differences in how they handle input data, but both have one thing in common. </span><span class="koboSpan" id="kobo.281.2">Once they capture input data into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">params</span></strong><span class="koboSpan" id="kobo.283.1"> variable, they both call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.285.1"> method inherited from the adapter </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
router = this.addNetworkToRouter(params);</span></pre> <p><span class="koboSpan" id="kobo.288.1">From this point on, the data follows the same flow as the one described in the REST adapter scenario, where the input adapter calls the input port through a use case </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">interface reference.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Now that </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.291.1">we’ve finished creating the REST and CLI input adapters, let’s see how to call </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">these adapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.293.1">Calling the input adapters</span></h3>
<p><span class="koboSpan" id="kobo.294.1">Here is the </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.295.1">client code to control which adapter </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">to choose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
public class App {
/** code omitted **/
    void setAdapter(String adapter) {
        switch (adapter){
            case "rest" -&gt; {
                outputPort =
                RouterNetworkH2Adapter.getInstance();
                usecase =
                new RouterNetworkInputPort(outputPort);
                inputAdapter =
                new RouterNetworkRestAdapter(usecase);
                rest();
            }
            default -&gt; {
                outputPort =
                RouterNetworkFileAdapter.getInstance();
                usecase =
                new RouterNetworkInputPort(outputPort);
                inputAdapter =
                new RouterNetworkCLIAdapter(usecase);
                cli();
            }
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.298.1">If we </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.299.1">pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">rest</span></strong><span class="koboSpan" id="kobo.301.1"> as a parameter when executing the program, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">switch</span></strong><span class="koboSpan" id="kobo.303.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">case</span></strong><span class="koboSpan" id="kobo.305.1"> condition will create a REST adapter instance and call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">rest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
private void rest() {
    try {
        System.out.println("REST endpoint listening on
                           port 8080...");
        var httpserver = HttpServer.create(
        new netSocketAddress(8080), 0);
        routerNetworkAdapter.processRequest(httpserver);
    } catch (IOException e){
        e.printStackTrace();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.309.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">rest</span></strong><span class="koboSpan" id="kobo.311.1"> method, in turn, calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">processRequest</span></strong><span class="koboSpan" id="kobo.313.1"> method from the REST </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">input adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Otherwise, if we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">cli</span></strong><span class="koboSpan" id="kobo.317.1"> parameter when executing the program, </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">switch</span></strong><span class="koboSpan" id="kobo.319.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">case</span></strong><span class="koboSpan" id="kobo.321.1"> will, by default, create a CLI adapter and call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">cli</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.323.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.324.1">
private void cli() {
    Scanner = new Scanner(System.in);
    routerNetworkAdapter.processRequest(scanner);
}</span></pre> <p><span class="koboSpan" id="kobo.325.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">cli</span></strong><span class="koboSpan" id="kobo.327.1"> method</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.328.1"> then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">processRequest</span></strong><span class="koboSpan" id="kobo.330.1"> method from the CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">input adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Here are the steps for calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">input adapters:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.334.1">With the code sample from GitHub within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">chapter4</span></strong><span class="koboSpan" id="kobo.336.1"> directory, you can compile the application by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.338.1">mvn clean package</span></strong></pre></li> <li><span class="koboSpan" id="kobo.339.1">To call the REST adapter, you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">.jar</span></strong><span class="koboSpan" id="kobo.341.1"> file with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">rest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1"> parameter:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.344.1">$ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar rest</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.345.1">REST endpoint listening on port 8080…</span></strong></pre></li> <li><span class="koboSpan" id="kobo.346.1">Once the application is up, you can fire up an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">GET</span></strong><span class="koboSpan" id="kobo.348.1"> request to create and add </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">a network:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.350.1">curl -vv "http://localhost:8080/network/add?routerId=ca23800e-9b5a-11eb-a8b3-0242ac130003&amp;address=40.0.0.0&amp;name=Finance&amp;cidr=8"</span></strong></pre></li> <li><span class="koboSpan" id="kobo.351.1">To call the CLI adapter, you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">.jar</span></strong><span class="koboSpan" id="kobo.353.1"> file with </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">no parameters:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.355.1">$ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar cli</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.356.1">Please inform the Router ID:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.357.1">ca23800e-9b5a-11eb-a8b3-0242ac130003</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.358.1">Please inform the IP address:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.359.1">40.0.0.0</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.360.1">Please inform the Network Name:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.361.1">Finance</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.362.1">Please inform the CIDR:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">8</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.364.1">The application will ask you to specify the router ID and other network additional details for calling the CLI adapter. </span><span class="koboSpan" id="kobo.364.2">Here, we gave the same data as used to call the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">REST adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">In this section, we</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.367.1"> learned how to use input adapters to expose hexagonal application features. </span><span class="koboSpan" id="kobo.367.2">By defining first a base input adapter, we extended it to create a REST adapter for HTTP requests and a CLI adapter for console/</span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">STDIN</span></strong><span class="koboSpan" id="kobo.369.1"> requests. </span><span class="koboSpan" id="kobo.369.2">This arrangement helped us grasp the fundamental role input adapters play in exploring different ways to access the same functionality in the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Input adapters are the front doors through which we access all the features a hexagonal application can provide. </span><span class="koboSpan" id="kobo.371.2">With input adapters, we can easily make the system accessible through different technologies without disturbing business logic. </span><span class="koboSpan" id="kobo.371.3">By the same token, we can make the hexagonal application speak to varying data sources. </span><span class="koboSpan" id="kobo.371.4">We accomplish that with output adapters, which we’ll see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">next section.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.373.1">Using output adapters to speak with different  data sources</span></h1>
<p><span class="koboSpan" id="kobo.374.1">What characterizes an object-oriented</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.375.1"> system is its ability to treat data and behavior as closely related things. </span><span class="koboSpan" id="kobo.375.2">This proximity happens to mimic the way things are in the real world. </span><span class="koboSpan" id="kobo.375.3">Both animate and inanimate beings have attributes and can perform or be the target of some action. </span><span class="koboSpan" id="kobo.375.4">For people starting to learn object-oriented programming, we present examples such as a car, which has four wheels and can drive – wheels being the data and driving the behavior. </span><span class="koboSpan" id="kobo.375.5">Examples such as this express the fundamental principle that data and behavior should not be treated as separate things but should be united inside what we </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">call objects.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">This object idea has laid the ground for the development of vast and complex systems over the last decades. </span><span class="koboSpan" id="kobo.377.2">A good part of those systems is business applications running on enterprise environments. </span><span class="koboSpan" id="kobo.377.3">The object paradigm has conquered enterprise development because its high-level approach has allowed people to be more productive and precise when creating software to solve business problems. </span><span class="koboSpan" id="kobo.377.4">The procedural paradigm was cumbersome and too low-level for the demands </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">of enterprises.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">In addition to object-oriented languages, enterprise software also relies on ways to obtain and persist data. </span><span class="koboSpan" id="kobo.379.2">It’s hard to imagine a system that is not integrated with data sources such as databases, message queues, or file servers, for example. </span><span class="koboSpan" id="kobo.379.3">The need to store things has always been present in computation. </span><span class="koboSpan" id="kobo.379.4">The problem, though, has been how this need has influenced and dictated the whole software structure. </span><span class="koboSpan" id="kobo.379.5">With the advent of </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">RDBMSs</span></strong><span class="koboSpan" id="kobo.381.1">, there comes the requirement to formalize data through </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">schemas</span></strong><span class="koboSpan" id="kobo.383.1"> as well. </span><span class="koboSpan" id="kobo.383.2">These </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.384.1">schemas, then, serve as a reference for establishing data relationships and how the application deals with such relationships. </span><span class="koboSpan" id="kobo.384.2">After some time, people started to look for alternatives to avoid the formalism and strict normalization principles imposed by RDBMSs. </span><span class="koboSpan" id="kobo.384.3">The problem is not in the formalism per se but in using RDBMSs where there’s no need </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">As an alternative to RDBMSs, there came </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">NoSQL</span></strong><span class="koboSpan" id="kobo.388.1"> databases, proposing a</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.389.1"> way to store data that didn’t rely on tables, columns, and schemas as a means of data organization. </span><span class="koboSpan" id="kobo.389.2">The NoSQL approach offers different data storage techniques, based on documents, key-value stores, wide-column stores, and graphs. </span><span class="koboSpan" id="kobo.389.3">Not constrained solely by the RDBMS approach, software developers then started using these NoSQL techniques to meet business requirements in a better way and avoid cumbersome solutions that relied on RDBMSs because there were </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">no alternatives.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">Aside from databases, other data sources have been used to fulfill software needs to handle data. </span><span class="koboSpan" id="kobo.391.2">Filesystems, message brokers, directory-based storage (</span><strong class="bold"><span class="koboSpan" id="kobo.392.1">LDAP</span></strong><span class="koboSpan" id="kobo.393.1">), and mainframe storage, to name a few, are some of the ways software can handle data. </span><span class="koboSpan" id="kobo.393.2">In the world of cloud computing, it’s becoming more natural to integrate a system with different technologies to send or receive data. </span><span class="koboSpan" id="kobo.393.3">This integration presents some challenges in software development because the system now needs to understand and make itself understandable in a heterogeneous technological context. </span><span class="koboSpan" id="kobo.393.4">That situation is even more exacerbated by architectures such as microservices that promote this heterogeneity. </span><span class="koboSpan" id="kobo.393.5">To tackle this challenge, we need techniques to overcome the challenges of technologically </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">heterogeneous environments.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">We saw in the previous section</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.396.1"> that we can plug multiple input adapters into the same input port. </span><span class="koboSpan" id="kobo.396.2">This also applies to output adapters and ports. </span><span class="koboSpan" id="kobo.396.3">Next, we’ll see how to create output adapters and plug them into the hexagon system </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">output ports.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.398.1">Creating output adapters</span></h2>
<p><span class="koboSpan" id="kobo.399.1">Together with</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.400.1"> input adapters, output adapters are the second component that comprises the Framework hexagon. </span><span class="koboSpan" id="kobo.400.2">The output adapter’s role in a hexagonal architecture is to deal with driven operations. </span><span class="koboSpan" id="kobo.400.3">Remember, driven operations are those initiated by the hexagonal application itself to interact with external systems to send or receive some data. </span><span class="koboSpan" id="kobo.400.4">These driven operations are described through use cases and are triggered by operations present in the use case’s input port implementations. </span><span class="koboSpan" id="kobo.400.5">Whenever a use case states the need to deal with data that lives in external systems, this means the hexagonal application will require at least one output adapter and port to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">such requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">We learned that output ports present in the Application hexagon express interactions with external systems in abstract ways. </span><span class="koboSpan" id="kobo.402.2">Output adapters, in turn, have the responsibility to describe, in concrete terms, how these interactions will occur. </span><span class="koboSpan" id="kobo.402.3">With output adapters, we make up our minds about which technologies the system will use to allow data persistence and other types of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">external integration.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Until now, we have talked about data based solely on the requirements expressed by the domain model we created in the Domain hexagon. </span><span class="koboSpan" id="kobo.404.2">After all, it’s the domain model from the Domain hexagon that drives the shape of the whole hexagonal system. </span><span class="koboSpan" id="kobo.404.3">Technological concerns are just mere details that must adhere to the domain model and not the other </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">way around.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">By using the output port as an interface in the Application hexagon and the output adapter as the implementation of that interface in the Framework hexagon, we are structuring the hexagonal system to support different technologies. </span><span class="koboSpan" id="kobo.406.2">In this structure, the output adapter in the Framework hexagon </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.407.1">must conform to the output port interface in the Application hexagon, which, in turn, must rely on the domain model from the </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">In the previous section, you may have noticed the usage of two different output adapters – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">RouterNetworkH2Adapter</span></strong><span class="koboSpan" id="kobo.411.1"> adapter to deal with data from in-memory databases and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">RouterNetworkFileAdapter</span></strong><span class="koboSpan" id="kobo.413.1"> adapter to read and persist files from a local filesystem. </span><span class="koboSpan" id="kobo.413.2">These two output adapters are implementations of the output ports we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">Application hexagon:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.415.1"><img alt="Figure 4.4 – UML representation of output adapters" src="image/B19777_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.416.1">Figure 4.4 – UML representation of output adapters</span></p>
<p><span class="koboSpan" id="kobo.417.1">We’ll start by implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">RouterNetworkH2Adapter</span></strong><span class="koboSpan" id="kobo.419.1">. </span><span class="koboSpan" id="kobo.419.2">It uses an H2 in-memory database to set up all the required tables and relationships. </span><span class="koboSpan" id="kobo.419.3">This adapter implementation shows us how to adapt the domain model data to a relational database. </span><span class="koboSpan" id="kobo.419.4">Then, we proceed to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">RouterNetworkFileAdapter</span></strong><span class="koboSpan" id="kobo.421.1">, which</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.422.1"> uses a </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">JSON</span></strong><span class="koboSpan" id="kobo.424.1"> file-backed data structure. </span><span class="koboSpan" id="kobo.424.2">Both H2 and JSON file implementations are based on the data provided by the topology</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.425.1"> and inventory sample system we’ve been working on. </span><span class="koboSpan" id="kobo.425.2">These two adapters will allow two ways to attach an additional network to an </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">existing switch:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.427.1"><img alt="Figure 4.5 – Topology and inventory system with a finance network" src="image/B19777_04_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.428.1">Figure 4.5 – Topology and inventory system with a finance network</span></p>
<p><span class="koboSpan" id="kobo.429.1">Using the same input </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.430.1">data from the previous section, we’ll attach </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Finance Network</span></strong><span class="koboSpan" id="kobo.432.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">Layer 3 Switch</span></strong><span class="koboSpan" id="kobo.434.1"> from </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">Edge Router</span></strong><span class="koboSpan" id="kobo.436.1"> using one of the available two </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">output adapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.438.1">The H2 output adapter</span></h3>
<p><span class="koboSpan" id="kobo.439.1">Before</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.440.1"> implementing the H2 output</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.441.1"> adapter, we first need to define the database structure of the topology and inventory system. </span><span class="koboSpan" id="kobo.441.2">To determine that structure, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">resources/inventory.sql</span></strong><span class="koboSpan" id="kobo.443.1"> file with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">SQL statements:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.445.1">
CREATE TABLE routers(
    router_id UUID PRIMARY KEY NOT NULL,
    router_type VARCHAR(255)
);
CREATE TABLE switches (
    switch_id UUID PRIMARY KEY NOT NULL,
    router_id UUID,
    switch_type VARCHAR(255),
    switch_ip_protocol VARCHAR(255),
    switch_ip_address VARCHAR(255),
    PRIMARY KEY (switch_id),
    FOREIGN KEY (router_id) REFERENCES routers(router_id)
);
CREATE TABLE networks (
    network_id int NOT NULL PRIMARY KEY AUTO_INCREMENT,
    switch_id UUID,
    network_protocol VARCHAR(255),
    network_address VARCHAR(255),
    network_name VARCHAR(255),
    network_cidr VARCHAR(255),
    PRIMARY KEY (network_id),
    FOREIGN KEY (switch_id) REFERENCES switches(switch_id)
);
INSERT INTO routers(router_id, router_type) VALUES('ca23800e-9b5a-11eb-a8b3-0242ac130003', 'EDGE');
INSERT INTO switches(switch_id, router_id, switch_type, switch_ip_protocol, switch_ip_address)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'ca23800e-9b5a-11eb-a8b3-0242ac130003', 'LAYER3', 'IPV4', '9.0.0.9');
INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '10.0.0.0', 'HR', '8');
INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '20.0.0.0', 'Marketing', '8');
INSERT INTO networks(switch_id, network_protocol, network_address, network_name, network_cidr)
VALUES('922dbcd5-d071-41bd-920b-00f83eb4bb46', 'IPV4', '30.0.0.0', 'Engineering', '8');</span></pre> <p><span class="koboSpan" id="kobo.446.1">Although </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">switches</span></strong><span class="koboSpan" id="kobo.448.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">networks</span></strong><span class="koboSpan" id="kobo.450.1"> have primary keys, we treat switches as entities and </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">networks</span></strong><span class="koboSpan" id="kobo.452.1"> as value objects that are part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Router</span></strong><span class="koboSpan" id="kobo.454.1"> entity in the domain model. </span><span class="koboSpan" id="kobo.454.2">We are imposing our model on the technological arrangement and not the other </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">way around.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">We don’t use these primary keys from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">switches</span></strong><span class="koboSpan" id="kobo.458.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">networks</span></strong><span class="koboSpan" id="kobo.460.1"> tables as references in the domain model. </span><span class="koboSpan" id="kobo.460.2">Instead, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">router_id</span></strong><span class="koboSpan" id="kobo.462.1"> value to correlate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Router</span></strong><span class="koboSpan" id="kobo.464.1"> entity with its </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Switch</span></strong><span class="koboSpan" id="kobo.466.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Network</span></strong><span class="koboSpan" id="kobo.468.1"> value objects and their respective database tables. </span><span class="koboSpan" id="kobo.468.2">This </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.469.1">correlation enables the</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.470.1"> formation of an aggregate where </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Router</span></strong><span class="koboSpan" id="kobo.472.1"> is the aggregate root, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Switch</span></strong><span class="koboSpan" id="kobo.474.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Network</span></strong><span class="koboSpan" id="kobo.476.1"> are the objects used to compose </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the aggregate.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Now, we can proceed to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">RouterNetworkOutputPort</span></strong><span class="koboSpan" id="kobo.480.1"> to create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">RouterNetworkH2Adapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.482.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
public class RouterNetworkH2Adapter implements RouterNet
  workOutputPort {
     private static RouterNetworkH2Adapter instance;
     @PersistenceContext
     private EntityManager em;
     private RouterNetworkH2Adapter(){
          setUpH2Database();
     }
     @Override
     public Router fetchRouterById(RouterId routerId) {
          var routerData = em.
</span><span class="koboSpan" id="kobo.483.2">              getReference(RouterData.class,
              routerId.getUUID());
          return RouterH2Mapper.toDomain(routerData);
     }
     @Override
     public boolean persistRouter(Router router) {
          var routerData = RouterH2Mapper.toH2(router);
          em.persist(routerData);
          return true;
     }
     private void setUpH2Database() {
          var entityManagerFactory = Persistence.
</span><span class="koboSpan" id="kobo.483.3">          createEntityManagerFactory("inventory");
          var em = entityManagerFactory.
</span><span class="koboSpan" id="kobo.483.4">          createEntityManager();
          this.em = em;
     }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.484.1">The first </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.485.1">method we override is </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">fetchRouterById</span></strong><span class="koboSpan" id="kobo.487.1">, where </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.488.1">we receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">routerId</span></strong><span class="koboSpan" id="kobo.490.1"> to fetch a router from the H2 database using our entity manager reference. </span><span class="koboSpan" id="kobo.490.2">We cannot use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Router</span></strong><span class="koboSpan" id="kobo.492.1"> domain entity class to map directly to the database. </span><span class="koboSpan" id="kobo.492.2">Also, we cannot use the database entity as a domain entity. </span><span class="koboSpan" id="kobo.492.3">That’s why we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">toDomain</span></strong><span class="koboSpan" id="kobo.494.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">fetchRouterById</span></strong><span class="koboSpan" id="kobo.496.1"> to map data from the H2 database to </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">the domain.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">We do the same mapping procedure, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">toH2</span></strong><span class="koboSpan" id="kobo.500.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">persistRouter</span></strong><span class="koboSpan" id="kobo.502.1"> to convert it from a domain model entity into an H2 database entity. </span><span class="koboSpan" id="kobo.502.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">setUpH2Database</span></strong><span class="koboSpan" id="kobo.504.1"> method initiates the database when the application starts. </span><span class="koboSpan" id="kobo.504.2">To create only one instance of the H2 adapter, we define a singleton using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">getInstance</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
public static RouterNetworkH2Adapter getInstance() {
    if (instance == null) {
        instance = new RouterNetworkH2Adapter();
    }
    return instance;
}</span></pre> <p><span class="koboSpan" id="kobo.508.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">instance</span></strong><span class="koboSpan" id="kobo.510.1"> field is used to provide a singleton object of the H2 output adapter. </span><span class="koboSpan" id="kobo.510.2">Note </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.511.1">that</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.512.1"> the constructor calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">setUpH2Database</span></strong><span class="koboSpan" id="kobo.514.1"> method to create a database connection using </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">EntityManagerFactory</span></strong><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">To properly configure the entity manager, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">resources/META-INF/persistence.xml</span></strong><span class="koboSpan" id="kobo.518.1"> file with a property to set up the </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">H2 database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!-- code omitted --&gt;
&lt;property
     name="jakarta.persistence.jdbc.url"
          value="jdbc:h2:mem:inventory;
          MODE=MYSQL;
          DB_CLOSE_DELAY=-1;
          DB_CLOSE_ON_EXIT=FALSE;
          IGNORECASE=TRUE;
          INIT=CREATE SCHEMA IF NOT EXISTS inventory\;
          RUNSCRIPT FROM 'classpath:inventory.sql'" /&gt;
&lt;!-- code omitted --&gt;</span></pre> <p><span class="koboSpan" id="kobo.521.1">Remember, our domain model comes first, so we don’t want to couple the system with database technology. </span><span class="koboSpan" id="kobo.521.2">That’s why we need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">RouterData</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.523.1">ORM</span></strong><span class="koboSpan" id="kobo.524.1"> class to map directly to </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.525.1">the </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.526.1">database</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.527.1"> types. </span><span class="koboSpan" id="kobo.527.2">Here, we are using </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">EclipseLink</span></strong><span class="koboSpan" id="kobo.529.1">, but you</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.530.1"> can use </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.531.1">any </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.532.1">JPA-compliant</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "routers")
@SecondaryTable(name = "switches")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass=
  UUIDTypeConverter.class)
public class RouterData implements Serializable {
    @Id
    @Column(name="router_id",
            columnDefinition = "uuid",
            updatable = false )
    @Convert("uuidConverter")
    private UUID routerId;
    @Embedded
    @Enumerated(EnumType.STRING)
    @Column(name="router_type")
    private RouterTypeData routerType;
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(table = "switches",
            name = "router_id",
            referencedColumnName = "router_id")
    private SwitchData networkSwitch;
}</span></pre> <p><span class="koboSpan" id="kobo.535.1">We </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.536.1">use </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">Lombok</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.538.1">@Getter</span></strong><span class="koboSpan" id="kobo.539.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">@NoArgsConstructor</span></strong><span class="koboSpan" id="kobo.541.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">@AllArgsConstructor</span></strong><span class="koboSpan" id="kobo.543.1"> annotations to diminish the verbosity of the class. </span><span class="koboSpan" id="kobo.543.2">We will use the getters and constructor later to convert the data class into a domain </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">model class.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">The usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">@Table</span></strong><span class="koboSpan" id="kobo.547.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">@SecondaryTable</span></strong><span class="koboSpan" id="kobo.549.1"> annotations serves to represent the</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.550.1"> relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">routers</span></strong><span class="koboSpan" id="kobo.552.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">switches</span></strong><span class="koboSpan" id="kobo.554.1"> tables. </span><span class="koboSpan" id="kobo.554.2">This relationship is mapped using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">@OntToOne</span></strong><span class="koboSpan" id="kobo.556.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">@JoinColumn</span></strong><span class="koboSpan" id="kobo.558.1"> annotations, specifying that both tables must be linked through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">router_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">UUID</span></strong><span class="koboSpan" id="kobo.563.1"> as an ID in EclipseLink, we need to create the following </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">converter class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
public class UUIDTypeConverter implements Converter {
     @Override
     public UUID convertObjectValueToDataValue(Object
                    objectValue, Session session) {
          return (UUID) objectValue;
     }
     @Override
     public UUID convertDataValueToObjectValue(Object
                    dataValue, Session session) {
          return (UUID) dataValue;
     }
     @Override
     public boolean isMutable() {
          return true;
     }
     @Override
     public void initialize(
     DatabaseMapping mapping, Session session){
          DatabaseField field = mapping.getField();
          field.setSqlType(Types.OTHER);
          field.setTypeName("java.util.UUID");
          field.setColumnDefinition("UUID");
     }
}</span></pre> <p><span class="koboSpan" id="kobo.566.1">This is the</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.567.1"> class we</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.568.1"> use inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">@Converter</span></strong><span class="koboSpan" id="kobo.570.1"> annotation at the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">RouterData</span></strong><span class="koboSpan" id="kobo.572.1"> class. </span><span class="koboSpan" id="kobo.572.2">Without this converter, there will be an exception stating a problem in mapping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">routerId</span></strong><span class="koboSpan" id="kobo.574.1"> attribute. </span><span class="koboSpan" id="kobo.574.2">Following the declaration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">routerId</span></strong><span class="koboSpan" id="kobo.576.1">, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">RouterTypeData</span></strong><span class="koboSpan" id="kobo.578.1"> attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">routerType</span></strong><span class="koboSpan" id="kobo.580.1">. </span><span class="koboSpan" id="kobo.580.2">For every ORM attribute, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Data</span></strong><span class="koboSpan" id="kobo.582.1"> suffix to the class name. </span><span class="koboSpan" id="kobo.582.2">Aside from </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">RouterData</span></strong><span class="koboSpan" id="kobo.584.1">, we do that with </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">RouterTypeData</span></strong><span class="koboSpan" id="kobo.586.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">SwitchData</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">Remember that in the domain model, the equivalent types are </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Router</span></strong><span class="koboSpan" id="kobo.590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">RouterType</span></strong><span class="koboSpan" id="kobo.592.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">RouterTypeData</span></strong><span class="koboSpan" id="kobo.597.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">enum</span></strong><span class="koboSpan" id="kobo.599.1"> in which we store the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">router type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
@Embeddable
public enum RouterTypeData {
     EDGE,
     CORE;
}</span></pre> <p><span class="koboSpan" id="kobo.602.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">@Embeddable</span></strong><span class="koboSpan" id="kobo.604.1"> annotation allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">enum</span></strong><span class="koboSpan" id="kobo.606.1"> data to be mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">router_type</span></strong><span class="koboSpan" id="kobo.608.1"> field in the database using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Embedded</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1"> annotation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
@Embedded
@Enumerated(EnumType.STRING)
@Column(name="router_type")
private RouterTypeData routerType;</span></pre> <p><span class="koboSpan" id="kobo.613.1">As the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">RouterData</span></strong><span class="koboSpan" id="kobo.615.1"> field, we refer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">SwitchData</span></strong><span class="koboSpan" id="kobo.617.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">networkSwitch</span></strong><span class="koboSpan" id="kobo.619.1"> variable, which </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.620.1">we use to create the relationship between a router and switch. </span><span class="koboSpan" id="kobo.620.2">Let’s see how </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.621.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">SwitchData</span></strong><span class="koboSpan" id="kobo.623.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">is implemented:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "switches")
@SecondaryTable(name = "networks")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass=
  UUIDTypeConverter.class)
public class SwitchData implements Serializable {
    @Id
    @Column(name="switch_id",
            columnDefinition = "uuid",
            updatable = false )
    @Convert("uuidConverter")
    private UUID switchId;
    @Column(name="router_id")
    @Convert("uuidConverter")
    private UUID routerId;
    @Enumerated(EnumType.STRING)
    @Embedded
    @Column(name = "switch_type")
    private SwitchTypeData switchType;
    @OneToMany
    @JoinColumn(table = "networks",
            name = "switch_id",
            referencedColumnName = "switch_id")
    private List&lt;NetworkData&gt; networks;
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(
                    name = "address",
                    column = @Column(
                            name = "switch_ip_address")),
            @AttributeOverride(
                    name = "protocol",
                    column = @Column(
                            name = "switch_ip_protocol")),
    })
    private IPData ip;
}</span></pre> <p><span class="koboSpan" id="kobo.626.1">We apply the same techniques to </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">SwitchData</span></strong><span class="koboSpan" id="kobo.628.1"> that we applied to </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">RouterData</span></strong><span class="koboSpan" id="kobo.630.1">. </span><span class="koboSpan" id="kobo.630.2">There is a subtle </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.631.1">difference though, which is the relationship established between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">switches</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">networks</span></strong><span class="koboSpan" id="kobo.635.1"> tables. </span><span class="koboSpan" id="kobo.635.2">To create this relationship, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">@OneToMany</span></strong><span class="koboSpan" id="kobo.637.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">@JoinColumn</span></strong><span class="koboSpan" id="kobo.639.1"> annotations to create a link between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">SwitchData</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">NetworkData</span></strong><span class="koboSpan" id="kobo.643.1"> types using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">switch_id</span></strong><span class="koboSpan" id="kobo.645.1"> attribute. </span><span class="koboSpan" id="kobo.645.2">A reference to a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">NetworkData</span></strong><span class="koboSpan" id="kobo.647.1"> objects</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.648.1"> is required</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.649.1"> because of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">OneToMany</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">RouterDataType</span></strong><span class="koboSpan" id="kobo.655.1">, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">SwitchDataType</span></strong><span class="koboSpan" id="kobo.657.1">, which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">enum</span></strong><span class="koboSpan" id="kobo.659.1"> equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">SwitchType</span></strong><span class="koboSpan" id="kobo.661.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">domain model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
@Embeddable
public enum SwitchTypeData {
     LAYER2,
     LAYER3;
}</span></pre> <p><span class="koboSpan" id="kobo.664.1">In the topology and inventory system, we attach networks directly to a switch. </span><span class="koboSpan" id="kobo.664.2">To map the domain value object to the H2 database entity, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">NetworkData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
@Getter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "networks")
@MappedSuperclass
@Converter(name="uuidConverter", converterClass=
  UUIDTypeConverter.class)
public class NetworkData implements Serializable {
    @Id
    @Column(name="network_id")
    private int id;
    @Column(name="switch_id")
    @Convert("uuidConverter")
    private UUID switchId;
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(
                    name = "address",
                    column = @Column(
                            name = "network_address")),
            @AttributeOverride(
                    name = "protocol",
                    column = @Column(
                            name = "network_protocol")),
    })
    IPData ip;
    @Column(name="network_name")
    String name;
    @Column(name="network_cidr")
    Integer cidr;
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.668.1">All attributes we have in </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">NetworkData</span></strong><span class="koboSpan" id="kobo.670.1"> are the same ones present in its domain value object counterpart. </span><span class="koboSpan" id="kobo.670.2">The only difference is the annotations we add to turn it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">database entity.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">SwitchData</span></strong><span class="koboSpan" id="kobo.674.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">NetworkData</span></strong><span class="koboSpan" id="kobo.676.1"> classes declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">IPData</span></strong><span class="koboSpan" id="kobo.678.1"> field. </span><span class="koboSpan" id="kobo.678.2">We encounter a</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.679.1"> similar behavior in the domain model, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">Switch</span></strong><span class="koboSpan" id="kobo.681.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Network</span></strong><span class="koboSpan" id="kobo.683.1"> classes</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.684.1"> have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">IP</span></strong><span class="koboSpan" id="kobo.686.1"> attribute. </span><span class="koboSpan" id="kobo.686.2">Here is how we should implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">IPData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.688.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
@Embeddable
@Getter
public class IPData {
    private String address;
    @Enumerated(EnumType.STRING)
    @Embedded
    private ProtocolData protocol;
    private IPData(String address){
        if(address == null)
            throw new IllegalArgumentException("Null IP
                          address");
        this.address = address;
        if(address.length()&lt;=15) {
            this.protocol = ProtocolData.IPV4;
        } else {
            this.protocol = ProtocolData.IPV6;
        }
    }
    public IPData() {}
    public static IPData fromAddress(String address){
        return new IPData(address);
    }
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">ProtocolData</span></strong><span class="koboSpan" id="kobo.691.1"> follows</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.692.1"> the same pattern used</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.693.1"> by other </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">enum</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">-based types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
@Embeddable
public enum ProtocolData {
     IPV4,
     IPV6;
}</span></pre> <p><span class="koboSpan" id="kobo.697.1">We could argue that there is some repetition in creating all those classes to integrate the system with a database. </span><span class="koboSpan" id="kobo.697.2">That’s true. </span><span class="koboSpan" id="kobo.697.3">It’s a trade-off where we give up reusability in favor of changeability, making the application capable of better integration with RDBMSes and other </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">data sources.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Now that we have created all the ORM classes to allow integration with the H2 database, we need to translate database objects into domain model objects and vice versa. </span><span class="koboSpan" id="kobo.699.2">We accomplish this by creating a mapper class with mapper methods. </span><span class="koboSpan" id="kobo.699.3">Let’s start with the methods we use to convert database entities into </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">domain entities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
public static Router toDomain(RouterData routerData){
/** code omitted **/
    return new Router(routerType, routerId, networkSwitch);
}</span></pre> <p><span class="koboSpan" id="kobo.702.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">toDomain</span></strong><span class="koboSpan" id="kobo.704.1"> method receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">RouterData</span></strong><span class="koboSpan" id="kobo.706.1"> type representing the database entity and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Router</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.708.1">domain entity.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">To convert a </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.710.1">list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">NetworkData</span></strong><span class="koboSpan" id="kobo.712.1"> datab</span><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.713.1">ase entity objects into a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">Network</span></strong><span class="koboSpan" id="kobo.715.1"> domain</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.716.1"> value objects, we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">getNetworksFromData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
private static List&lt;Network&gt; getNetworksFromData(List&lt;Net
  workData&gt; networkData){
    return networkData
            .stream()
            .map(network -&gt; new Network(
                      IP.fromAddress(
                      network.getIp().getAddress()),
                      network.getName(),
                      network.getCidr()))
            .collect(Collectors.toList());
}</span></pre> <p><span class="koboSpan" id="kobo.720.1">It receives a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">NetworkData</span></strong><span class="koboSpan" id="kobo.722.1"> database entity objects and returns a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Network</span></strong><span class="koboSpan" id="kobo.724.1"> domain entity objects. </span><span class="koboSpan" id="kobo.724.2">Then, to convert from a domain model entity into an H2 database entity, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">toH2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.726.1">mapper method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
public static RouterData toH2(Router router){
/** code omitted **/
return new RouterData(routerId, routerTypeData,
  switchData);
}</span></pre> <p><span class="koboSpan" id="kobo.728.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">toH2</span></strong><span class="koboSpan" id="kobo.730.1"> method receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Router</span></strong><span class="koboSpan" id="kobo.732.1"> domain entity object as a parameter, to do the proper mapping, and then it returns a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">RouterData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.735.1">Finally, to</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.736.1"> convert a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">Network</span></strong><span class="koboSpan" id="kobo.738.1"> domain value objects into a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">NetworkData</span></strong><span class="koboSpan" id="kobo.740.1"> database entity objects, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">getNetworksFromDomain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.742.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.743.1">
private static List&lt;NetworkData&gt; getNetworksFromDo
  main(List&lt;Network&gt; networks, UUID switchId){
    return  networks
             .stream()
             .map(network -&gt; new NetworkData(
                    switchId,
                    IPData.fromAddress(
                    network.getAddress().getIPAddress()),
                    network.getName(),
                    network.getCidr()))
             .collect(Collectors.toList());
}</span></pre> <p><span class="koboSpan" id="kobo.744.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">getNetworksFromDomain</span></strong><span class="koboSpan" id="kobo.746.1"> method receives a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">Network</span></strong><span class="koboSpan" id="kobo.748.1"> domain value objects </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.749.1">and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">UUID</span></strong><span class="koboSpan" id="kobo.751.1">-type switch ID as parameters. </span><span class="koboSpan" id="kobo.751.2">With that data, this method is able to do the proper mapping, returning a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">NetworkData</span></strong><span class="koboSpan" id="kobo.753.1"> database </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">entity objects.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">toDomain</span></strong><span class="koboSpan" id="kobo.757.1"> static method is used when we need to convert the H2 database object into its domain </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">model counterpart:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
@Override
public Router fetchRouterById(RouterId routerId) {
     var routerData = em.getReference(
     RouterData.class, routerId.getUUID());
     return RouterH2Mapper.toDomain(routerData);
}</span></pre> <p><span class="koboSpan" id="kobo.760.1">When persisting the domain model entity as the H2 database entity, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">toH2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.762.1">static method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
@Override
public boolean persistRouter(Router router) {
     var routerData = RouterH2Mapper.toH2(router);
     em.persist(routerData);
     return true;
}</span></pre> <p><span class="koboSpan" id="kobo.764.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">fetchRouterById</span></strong><span class="koboSpan" id="kobo.766.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">persistRouter</span></strong><span class="koboSpan" id="kobo.768.1"> methods </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.769.1">are called</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.770.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">RouterNetworkInputPort</span></strong><span class="koboSpan" id="kobo.772.1"> object, using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">RouterNetworkOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.774.1">interface reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
private Router fetchRouter(RouterId routerId) {
     return routerNetworkOutputPort.
</span><span class="koboSpan" id="kobo.775.2">     fetchRouterById(routerId);
}
/** code omitted **/
private boolean persistNetwork(Router router) {
     return routerNetworkOutputPort.
</span><span class="koboSpan" id="kobo.775.3">     persistRouter(router);
}</span></pre> <p><span class="koboSpan" id="kobo.776.1">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">RouterNetworkOutputPort</span></strong><span class="koboSpan" id="kobo.778.1"> is resolved at runtime based on the parameter we pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">RouterNetworkInputPort</span></strong><span class="koboSpan" id="kobo.780.1"> constructor. </span><span class="koboSpan" id="kobo.780.2">With this technique, we blind the hexagonal system regarding where it needs to go to get data. </span><span class="koboSpan" id="kobo.780.3">It can be a</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.781.1"> relational database or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">.json</span></strong><span class="koboSpan" id="kobo.783.1"> file, as </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.784.1">we’ll see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.786.1">The file adapter</span></h3>
<p><span class="koboSpan" id="kobo.787.1">To create</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.788.1"> the file adapter, we can apply the same ideas used to</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.789.1"> create the H2 database adapter, with just some minor adjustments to accommodate the file-backed data source. </span><span class="koboSpan" id="kobo.789.2">This data source is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">.json</span></strong><span class="koboSpan" id="kobo.791.1"> file containing the same data used to create the previous database. </span><span class="koboSpan" id="kobo.791.2">So, to start, you can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">.json</span></strong><span class="koboSpan" id="kobo.793.1"> file at </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">resources/inventory.json</span></strong><span class="koboSpan" id="kobo.795.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
[{
    "routerId": "ca23800e-9b5a-11eb-a8b3-0242ac130003",
    "routerType": "EDGE",
    "switch":{
      "switchId": "922dbcd5-d071-41bd-920b-00f83eb4bb46",
      "ip": {
        "protocol": "IPV4", "address": "9.0.0.9"
      },
      "switchType": "LAYER3",
      "networks":[
        {
          "ip": {
            "protocol": "IPV4", "address": "10.0.0.0"
          },
          "networkName": "HR", "networkCidr": "8"
        },
        {
          "ip": {
            "protocol": "IPV4", "address": "20.0.0.0"
          },
          "networkName": "Marketing", "networkCidr": "8"
        },
        {
          "ip": {
            "protocol": "IPV4", "address": "30.0.0.0"
          },
          "networkName": "Engineering", "networkCidr": "8"
        }
      ]
    }
}]</span></pre> <p><span class="koboSpan" id="kobo.798.1">The </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.799.1">purpose of </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.800.1">adding a network to fulfill our use case goals remains the same, so again we will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">RouterNetworkOutputPort</span></strong><span class="koboSpan" id="kobo.802.1"> interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">create </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">RouterNetworkFileAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
public class RouterNetworkFileAdapter implements RouterNet
  workOutputPort {
/** code omitted **/
    @Override
    public Router fetchRouterById(RouterId routerId) {
var router = new Router();
        for(RouterJson: routers){
              if(routerJson.getRouterId().
</span><span class="koboSpan" id="kobo.806.2">              equals(routerId.getUUID())){
                    router =  RouterJsonFileMapper.
</span><span class="koboSpan" id="kobo.806.3">                    toDomain(routerJson);
              break;
           }
        }
        return router;
    }
    @Override
    public boolean persistRouter(Router router) {
        var routerJson = RouterJsonFileMapper.
</span><span class="koboSpan" id="kobo.806.4">                         toJson(router);
        try {
            var localDir = Paths.get("").
</span><span class="koboSpan" id="kobo.806.5">                              toAbsolutePath().toString();
            var file = new File(localDir+
                        "/inventory.json");
            file.delete();
            objectMapper.writeValue(file, routerJson);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }
/** code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.807.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">fetchRouterById</span></strong><span class="koboSpan" id="kobo.809.1"> method returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">Router</span></strong><span class="koboSpan" id="kobo.811.1"> object by parsing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">.json</span></strong><span class="koboSpan" id="kobo.813.1"> file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">RouterId</span></strong><span class="koboSpan" id="kobo.815.1"> parameter. </span><span class="koboSpan" id="kobo.815.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">persistRouter</span></strong><span class="koboSpan" id="kobo.817.1"> method persists changes in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">inventory.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">Instead of using an entity manager and EclipseLink, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">Jackson</span></strong><span class="koboSpan" id="kobo.822.1"> libraries to serialize and deserialize the JSON data. </span><span class="koboSpan" id="kobo.822.2">To load the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">inventory.json</span></strong><span class="koboSpan" id="kobo.824.1"> file into memory, we use </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.825.1">the adapter constructor to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">readJsonFile</span></strong><span class="koboSpan" id="kobo.827.1"> method </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.828.1">to load the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">inventory.json</span></strong><span class="koboSpan" id="kobo.830.1"> file into a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">RouterJson</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
private void readJsonFile(){
    try {
        this.routers = objectMapper.readValue(
             resource,
             new TypeReference&lt;List&lt;RouterJson&gt;&gt;(){});
        } catch (Exception e) {
           e.printStackTrace();
        }
}
private RouterNetworkFileAdapter() {
    this.objectMapper = new ObjectMapper();
    this.resource = getClass().getClassLoader().
</span><span class="koboSpan" id="kobo.833.2">    getResourceAsStream("inventory.json");
    readJsonFile();
}</span></pre> <p><span class="koboSpan" id="kobo.834.1">As in the H2 case, with JSON, we also need to create special classes to map between JSON objects and domain model objects. </span><span class="koboSpan" id="kobo.834.2">The classes’ structure is similar to the H2 ORM classes, with differences mainly in the annotations used to create adequate mapping. </span><span class="koboSpan" id="kobo.834.3">Let’s see how to implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">RouterJson</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.836.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.837.1">
/** Code omitted **/
@JsonInclude(value = JsonInclude.Include.NON_NULL)
public class RouterJson {
     @JsonProperty("routerId")
     private UUID routerId;
     @JsonProperty("routerType")
     private RouterTypeJson routerType;
     @JsonProperty("switch")
     private SwitchJson networkSwitch;
}</span></pre> <p><span class="koboSpan" id="kobo.838.1">We use </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.839.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">@JsonInclude</span></strong><span class="koboSpan" id="kobo.841.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">@JsonProperty</span></strong><span class="koboSpan" id="kobo.843.1"> annotations to map class attributes</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.844.1"> to JSON fields. </span><span class="koboSpan" id="kobo.844.2">These JSON mappings are much more straightforward than H2 mappings because we don’t need to deal with database relationships. </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">RouterTypeJson</span></strong><span class="koboSpan" id="kobo.846.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">SwitchJson</span></strong><span class="koboSpan" id="kobo.848.1">, and all other JSON map classes are similar in that they use the same annotations to convert JSON and domain </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">model objects.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">To convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">RouterJson</span></strong><span class="koboSpan" id="kobo.852.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Router</span></strong><span class="koboSpan" id="kobo.854.1">, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">toDomain</span></strong><span class="koboSpan" id="kobo.856.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">RouterJsonFileMapper</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.858.1">mapper class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.859.1">
RouterJsonFileMapper.toDomain(routerJson);</span></pre> <p><span class="koboSpan" id="kobo.860.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">toJson</span></strong><span class="koboSpan" id="kobo.862.1"> method to convert from </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">Router</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.864.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">RouterJson</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.867.1">
RouterJsonFileMapper.toJson(router);</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">RouterJsonFileMapper</span></strong><span class="koboSpan" id="kobo.869.1"> is similar to its H2 counterpart but simpler because we don’t need</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.870.1"> to deal with </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">one-to-many</span></strong><span class="koboSpan" id="kobo.872.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.873.1">one-to-one</span></strong><span class="koboSpan" id="kobo.874.1"> relationships. </span><span class="koboSpan" id="kobo.874.2">Let’s start</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.875.1"> with the methods used to convert JSON objects into </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">domain objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.877.1">
public static Router toDomain(RouterJson routerJson){
    /** code omitted **/
    return new Router(routerType, routerId, networkSwitch);
}</span></pre> <p><span class="koboSpan" id="kobo.878.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">toDomain</span></strong><span class="koboSpan" id="kobo.880.1"> method here receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">RouterJson</span></strong><span class="koboSpan" id="kobo.882.1"> object as a parameter, performs the proper mapping, and then returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">Router</span></strong><span class="koboSpan" id="kobo.884.1"> object. </span><span class="koboSpan" id="kobo.884.2">A similar procedure occurs when we need to</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.885.1"> convert a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">NetworkJson</span></strong><span class="koboSpan" id="kobo.887.1"> JSON objects into a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">Network</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.889.1">domain objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.890.1">
private static List&lt;Network&gt; getNetworksFromJson(List&lt;Net
  workJson&gt; networkJson){
    return networkJson
            .stream()
            .map(json -&gt;  new Network(
                    IP.fromAddress(
                    json.getIp().getAddress()),
                    json.getNetworkName(),
                    Integer.valueOf(json.getCidr())))
            .collect(Collectors.toList());
}</span></pre> <p><span class="koboSpan" id="kobo.891.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">getNetworksFromJson</span></strong><span class="koboSpan" id="kobo.893.1"> method receives a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">NetworkJson</span></strong><span class="koboSpan" id="kobo.895.1"> objects as parameters </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.896.1">and returns an adequately mapped list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.898.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">Let’s see the methods used to convert domain objects into </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">JSON objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.901.1">
public static RouterJson toJson(Router router){
    /** code omitted **/
    return new RouterJson(
               routerId,
               routerTypeJson,
               switchJson);
}</span></pre> <p><span class="koboSpan" id="kobo.902.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">toJson</span></strong><span class="koboSpan" id="kobo.904.1"> method does the opposite of what </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">toDomain</span></strong><span class="koboSpan" id="kobo.906.1"> does. </span><span class="koboSpan" id="kobo.906.2">Instead of a JSON object as a parameter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">toJson</span></strong><span class="koboSpan" id="kobo.908.1"> method here receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Router</span></strong><span class="koboSpan" id="kobo.910.1"> domain object, performs the proper mapping, and returns a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">RouterJson</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.912.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">Finally, we have a </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.914.1">situation where it’s necessary to convert a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">Network</span></strong><span class="koboSpan" id="kobo.916.1"> domain objects into </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.917.1">a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">NetworkJson</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.919.1">JSON objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
private static List&lt;NetworkJson&gt;  getNetworksFromDo
  main(List&lt;Network&gt; networks){
     return networks
             .stream()
             .map(network -&gt; new NetworkJson(
                    IPJson.fromAddress(
                    network.getAddress().getIPAddress()),
                    network.getName(),
                    String.valueOf(network.getCidr())))
              .collect(Collectors.toList());
}</span></pre> <p><span class="koboSpan" id="kobo.921.1">By receiving a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Network</span></strong><span class="koboSpan" id="kobo.923.1"> objects as parameters, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">getNetworksFromDomain</span></strong><span class="koboSpan" id="kobo.925.1"> method can proceed to map the needed attributes and return a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">NetworkJson</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.927.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">Now that we have completed the file output adapter implementation, let’s play around, calling </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.929.1">both</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.930.1"> the file and H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">output adapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.932.1">Calling the output adapters</span></h3>
<p><span class="koboSpan" id="kobo.933.1">Before </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.934.1">calling the adapter, let’s compile the application. </span><span class="koboSpan" id="kobo.934.2">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">Chapter04</span></strong><span class="koboSpan" id="kobo.936.1"> directory and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.938.1">
mvn clean package</span></pre> <p><span class="koboSpan" id="kobo.939.1">To call the H2 output adapter, we need to use the REST input adapter. </span><span class="koboSpan" id="kobo.939.2">We can do that by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">rest</span></strong><span class="koboSpan" id="kobo.941.1"> parameter when executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.944.1"> file:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.945.1">
$ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar rest
$ curl -vv "http://localhost:8080/network/add?routerId=ca23800e-9b5a-11eb-a8b3-0242ac130003&amp;address=40.0.0.0&amp;name=Finance&amp;cidr=8" | jq</span></pre> <p><span class="koboSpan" id="kobo.946.1">The file output adapter is accessible through the CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">input adapter:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.948.1">
$ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar
Please inform the Router ID:
ca23800e-9b5a-11eb-a8b3-0242ac130003
Please inform the IP address:
40.0.0.0
Please inform the Network Name:
Finance
Please inform the CIDR:
8</span></pre> <p><span class="koboSpan" id="kobo.949.1">The result of calling </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.950.1">both the H2 and file output adapters will be </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">the same:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.952.1">
{
  "routerId": "ca23800e-9b5a-11eb-a8b3-0242ac130003",
  "routerType": "EDGE",
  "switch": {
    "switchId": "922dbcd5-d071-41bd-920b-00f83eb4bb46",
    "ip": {
      "address": "9.0.0.9", "protocol": "IPV4"
    },
    "switchType": "LAYER3",
    "networks": [
      {
        "ip": {
          "address": "10.0.0.0", "protocol": "IPV4"
        },
        "networkName": "HR",
        "networkCidr": "8"
      },
      {
        "ip": {
          "address": "20.0.0.0", "protocol": "IPV4"
        },
        "networkName": "Marketing",
        "networkCidr": "8"
      },
      {
        "ip": {
          "address": "30.0.0.0", "protocol": "IPV4"
        },
        "networkName": "Engineering",
        "networkCidr": "8"
      },
      {
        "ip": {
          "address": "40.0.0.0", "protocol": "IPV4"
        },
        "networkName": "Finance",
        "networkCidr": "8"
      }
    ]
  }
}</span></pre> <p><span class="koboSpan" id="kobo.953.1">Note </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.954.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Finance</span></strong><span class="koboSpan" id="kobo.956.1"> network block at the end of the output, which confirms that the data was </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">correctly persisted.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">By creating these two output adapters, we enabled the hexagonal application to speak with different data sources. </span><span class="koboSpan" id="kobo.958.2">The best part was that we didn’t need to change anything in the Domain or </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">Application hexagons.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">The only requirement for creating an output adapter is implementing an output port interface from the Application hexagon. </span><span class="koboSpan" id="kobo.960.2">These output adapter examples showed how a hexagonal approach protects the business logic from technological concerns. </span><span class="koboSpan" id="kobo.960.3">Of course, there is a trade-off when we decide to follow this path. </span><span class="koboSpan" id="kobo.960.4">However, if we aim to make change-tolerant systems centered in the domain model, the hexagonal architecture provides the </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.961.1">necessary techniques needed </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">for that.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.963.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.964.1">We learned in this chapter that adapters are used to define the technologies that are supported by a hexagonal application. </span><span class="koboSpan" id="kobo.964.2">We created two input adapters to allow driving operations, that is, a REST adapter to receive data from HTTP connections and a CLI adapter to receive data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">STDIN</span></strong><span class="koboSpan" id="kobo.966.1">. </span><span class="koboSpan" id="kobo.966.2">Both input adapters were attached to the same input port, allowing the hexagonal system to use the same logic to process requests coming in </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">distinct formats.</span></span></p>
<p><span class="koboSpan" id="kobo.968.1">Then, we created an H2 database output adapter and a JSON file output adapter to allow the hexagonal application to communicate with different data sources. </span><span class="koboSpan" id="kobo.968.2">These two output adapters were attached to the same output port, enabling the hexagonal system to persist and obtain data from external sources so that the data source technology did not influence the </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">business logic.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">By knowing the purpose of input and output adapters and understanding how to implement them, we can now create systems that can tolerate significant technological changes without substantial refactoring. </span><span class="koboSpan" id="kobo.970.2">This benefit is achieved because all the system components, including the adapters, are developed around the </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.972.1">To fully understand the dynamic between adapters and other hexagonal architecture elements, we’re going to look into the life cycle of driving and driven operations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">next chapter.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.974.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.975.1">When should we create an </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">input adapter?</span></span></li>
<li><span class="koboSpan" id="kobo.977.1">What is the benefit of connecting multiple input adapters to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">input port?</span></span></li>
<li><span class="koboSpan" id="kobo.979.1">What interface must we implement to create </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">output adapters?</span></span></li>
<li><span class="koboSpan" id="kobo.981.1">Which hexagon do the input and output adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">belong to?</span></span></li>
</ol>
<h1 id="_idParaDest-80"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.983.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.984.1">We create an input adapter when we need to expose software features to be accessed by driving actors. </span><span class="koboSpan" id="kobo.984.2">These actors can access the hexagonal application using different technologies or protocols, such as HTTP REST or via the </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">command line.</span></span></li>
<li><span class="koboSpan" id="kobo.986.1">The main benefit is that the same logic, contained in an input port, can be used to treat data that comes from different </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">input adapters.</span></span></li>
<li><span class="koboSpan" id="kobo.988.1">Output adapters must always implement output ports. </span><span class="koboSpan" id="kobo.988.2">By doing that, we are sure that the adapters are in line with the requirements expressed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">domain model.</span></span></li>
<li><span class="koboSpan" id="kobo.990.1">They are both from the </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">Framework hexagon.</span></span></li>
</ol>
<h1 id="_idParaDest-81"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.992.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.993.1">Get Your Hands Dirty on Clean Architecture: A hands-on guide to creating clean web applications with code examples in Java</span></em><span class="koboSpan" id="kobo.994.1">, Tom Hombergs, Packt Publishing </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">Ltd., 2019</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.996.1">Object-Oriented Software Engineering: A Use Case Driven Approach</span></em><span class="koboSpan" id="kobo.997.1">, Ivar Jacobson, Pearson </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">Education, 1992</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.999.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.1000.1">, Eric Evans, Pearson </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">Education, 2003</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1002.1">Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.1003.1">, Vaughn Vernon, Pearson </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">Education, 2013</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1005.1">Hexagonal architecture</span></em><span class="koboSpan" id="kobo.1006.1"> (</span><a href="https://alistair.cockburn.us/hexagonal-architecture/"><span class="koboSpan" id="kobo.1007.1">https://alistair.cockburn.us/hexagonal-architecture/</span></a><span class="koboSpan" id="kobo.1008.1">), </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">Alistair Cockburn</span></span></li>
</ul>
</div>
</body></html>