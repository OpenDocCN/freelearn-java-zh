- en: Chapter 3. Asynchronous Programming and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。异步编程和网络
- en: Several business applications need to react to external stimuli—such as network
    traffic—asynchronously. An example of such software might be a desktop application
    that allows us to track a company's share prices in the stock market.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几个商业应用程序需要异步地对外部刺激——如网络流量——做出反应。这类软件的一个例子可能是允许我们跟踪股市中公司股价的桌面应用程序。
- en: 'We will build this application first using a more traditional approach. In
    doing so, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用更传统的方法来构建这个应用程序。这样做时，我们将：
- en: Be able to identify and understand the drawbacks of the first design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够识别和理解第一种设计的缺点
- en: Learn how to use RxClojure to deal with stateful computations such as rolling
    averages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用RxClojure处理如滚动平均值这样的有状态计算
- en: Rewrite the example in a declarative fashion using observable sequences, thus
    reducing the complexity found in our first approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察序列以声明性方式重写示例，从而减少我们第一种方法中发现的复杂性
- en: Building a stock market monitoring application
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建股票市场监控应用程序
- en: 'Our stock market program will consist of three main components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的股票市场程序将包括三个主要组件：
- en: A function simulating an external service from which we can query the current
    price—this would likely be a network call in a real setting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模拟外部服务的函数，我们可以从中查询当前价格——在现实情况下这很可能是网络调用
- en: A scheduler that polls the preceding function at a predefined interval
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以预定义间隔轮询先前函数的调度器
- en: A display function responsible for updating the screen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责更新屏幕的显示函数
- en: 'We''ll start by creating a new leiningen project, where the source code for
    our application will live. Type the following on the command line and then switch
    into the newly created directory:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的Leiningen项目，我们的应用程序源代码将存储在这里。在命令行中输入以下内容，然后切换到新创建的目录：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we''ll be building a GUI for this application, go ahead and add a dependency
    on Seesaw to the dependencies section of your `project.clj`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为该应用程序构建一个GUI，请在`project.clj`的依赖项部分添加对Seesaw的依赖项：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create a `src/stock_market_monitor/core.clj` file in your favorite editor.
    Let''s create and configure our application''s UI components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您最喜欢的编辑器中创建一个`src/stock_market_monitor/core.clj`文件。让我们创建和配置我们应用程序的UI组件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the UI is fairly simple. It consists of a single label that
    will display a company's share price. We also imported two Java classes, `ScheduledThreadPoolExecutor`
    and `TimeUnit`, which we will use shortly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户界面相当简单。它由一个标签组成，将显示公司的股价。我们还导入了两个Java类，`ScheduledThreadPoolExecutor`和`TimeUnit`，我们将在稍后使用它们。
- en: 'The next thing we need is our polling machinery so that we can invoke the pricing
    service on a given schedule. We''ll implement this via a thread pool so as not
    to block the main thread:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要的是我们的轮询机制，这样我们就可以在给定的时间表上调用定价服务。我们将通过线程池来实现这一点，以避免阻塞主线程：
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: User interface SDKs such as swing have the concept of a main—or UI—thread. This
    is the thread used by the SDK to render the UI components to the screen. As such,
    if we have blocking—or even simply slow running— operations execute in this thread,
    the user experience will be severely affected, hence the use of a thread pool
    to offload expensive function calls.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面SDK，如Swing，有主线程或UI线程的概念。这是SDK用来将UI组件渲染到屏幕上的线程。因此，如果我们在这个线程中执行阻塞操作——甚至只是运行缓慢的操作——用户体验将受到严重影响，这就是为什么使用线程池来卸载昂贵的函数调用。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `init-scheduler` function creates `ScheduledThreadPoolExecutor` with the
    given number of threads. That's the thread pool in which our periodic function
    will run. The `run-every` function schedules a function `f` in the given `pool`
    to run at the interval specified by `millis`. Finally, `shutdown` is a function
    that will be called on program termination and shutdown the thread pool gracefully.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`init-scheduler`函数使用给定的线程数创建`ScheduledThreadPoolExecutor`。这就是我们的周期性函数将运行的线程池。`run-every`函数在给定的`pool`中安排函数`f`以`millis`指定的间隔运行。最后，`shutdown`是一个在程序终止时将被调用的函数，它将优雅地关闭线程池。'
- en: 'The rest of the program puts all these parts together:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分将这些部分组合在一起：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `share-price` function sleeps for 200 milliseconds to simulate network latency
    and returns a random integer between 0 and 1,000 representing the stock's price.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`share-price`函数暂停200毫秒以模拟网络延迟，并返回一个介于0和1,000之间的随机整数，代表股票的价格。'
- en: The first line of our `-main` function adds a shutdown hook to the runtime.
    This allows our program to intercept termination—such as pressing *Ctrl* + *C*
    in a terminal window—and gives us the opportunity to shutdown the thread pool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`-main`函数的第一行向运行时添加了一个关闭钩子。这允许我们的程序拦截终止——例如在终端窗口中按下*Ctrl* + *C*——并给我们机会关闭线程池。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `ScheduledThreadPoolExecutor` pool creates non-daemon threads by default.
    A program cannot terminate if there are any non-daemon threads alive in addition
    to the program's main thread. This is why the shutdown hook is necessary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`池默认创建非守护线程。如果除了程序的主线程外还有任何非守护线程存活，程序就无法终止。这就是为什么关闭钩子是必要的。'
- en: Next, we initialize the scheduler with a single thread and schedule a function
    to be executed every 500 milliseconds. This function asks the `share-price` function
    for XYZ's current price and updates the label.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用单个线程初始化调度器，并安排每500毫秒执行一个函数。这个函数会请求XYZ的当前股价，并更新标签。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Desktop applications require all rendering to be done in the UI thread. However,
    our periodic function runs on a separate thread and needs to update the price
    label. This is why we use `invoke-now`, which is a Seesaw function that schedules
    its body to be executed in the UI thread as soon as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序需要在UI线程中完成所有渲染。然而，我们的周期性函数在单独的线程上运行，并需要更新价格标签。这就是为什么我们使用`invoke-now`，这是一个Seesaw函数，它将主体调度到尽可能快地执行在UI线程中。
- en: 'Let''s run the program by typing the following command in the project''s root
    directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中输入以下命令来运行程序：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Trampolining tells leiningen not to nest our program's JVM within its own, thus
    freeing us to handle uses of *Ctrl* + *C* ourselves through shutdown hooks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Trampolining告诉leiningen不要将我们的程序JVM嵌套在其内部，这样我们就可以通过关闭钩子自己处理*Ctrl* + *C*的使用。
- en: 'A window like the one shown in the following screenshot will be displayed,
    with the values on it being updated as per the schedule implemented earlier:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将会显示一个类似于以下截图的窗口，其上的值将根据之前实现的计划进行更新：
- en: '![Building a stock market monitoring application](img/00010.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![构建股票市场监控应用程序](img/00010.jpeg)'
- en: This is a fine solution. The code is relatively straightforward and satisfies
    our original requirements. However, if we look at the big picture, there is a
    fair bit of noise in our program. Most of its lines of code are dealing with creating
    and managing a thread pool, which, while necessary, isn't central to the problem
    we're solving—it's an implementation detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的解决方案。代码相对简单，并且满足我们的原始要求。然而，如果我们从大局来看，我们的程序中存在相当多的噪声。其中大部分代码行都在处理创建和管理线程池，虽然这是必要的，但并不是我们解决问题的核心——这是一个实现细节。
- en: 'We''ll keep things as they are for the moment and add a new requirement: rolling
    averages.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们将保持现状，并添加一个新要求：滚动平均值。
- en: Rolling averages
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动平均值
- en: Now that we can see the up-to-date stock price for a given company, it makes
    sense to display a rolling average of the past, say, five stock prices. In a real
    scenario, this would provide an objective view of a company's share trend in the
    stock market.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到给定公司的最新股价，显示过去，比如说，五次股价的滚动平均值是有意义的。在现实场景中，这将提供一个公司股票市场趋势的客观视图。
- en: Let's extend our program to accommodate this new requirement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的程序以适应这个新要求。
- en: 'First, we''ll need to modify our namespace definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改我们的命名空间定义：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only change is a new import clause, for Clojure's `PersistentQueue` class.
    We will be using that later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是一个新的导入语句，用于Clojure的`PersistentQueue`类。我们稍后会使用它。
- en: 'We''ll also need a new label to display the current running average:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的标签来显示当前的运行平均值：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we need a function to calculate rolling averages. A rolling—or moving—average
    is a calculation in statistics, where you take the average of a subset of items
    in a dataset. This subset has a fixed size and it shifts forward as data comes
    in. This will become clear with an example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数来计算滚动平均值。滚动平均——或移动平均——是统计学中的一个计算，其中你取数据集中一个子集的平均值。这个子集具有固定的大小，并且随着数据的到来而向前移动。通过一个例子，这会变得清楚。
- en: 'Suppose you have a list with numbers from 1 to 10, inclusive. If we use `3`
    as the subset size, the rolling averages are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含从1到10（包括10）的数字列表。如果我们使用`3`作为子集大小，滚动平均值如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The highlighted parts in the preceding code show the current *window* being
    used to calculate the subset average.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中突出显示的部分显示了当前用于计算子集平均值的*窗口*。
- en: 'Now that we know what rolling averages are, we can move on to implement it
    in our program:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了滚动平均值是什么，我们就可以继续在我们的程序中实现它：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `roll-buffer` function is a utility function that takes a queue, a number,
    and a buffer size as arguments. It adds that number to the queue, popping the
    oldest element if the queue goes over the buffer limit, thus causing its contents
    to *roll* over.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll-buffer`函数是一个实用函数，它接受一个队列、一个数字和一个缓冲区大小作为参数。它将那个数字添加到队列中，如果队列超过缓冲区限制，则弹出最旧的元素，从而使其内容*滚动*。'
- en: Next, we have a function for calculating the average of a collection of numbers.
    We cast the result to float if there's an uneven division.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个用于计算数字集合平均值的函数。如果除法不均匀，我们将结果转换为浮点数。
- en: Finally, the higher-order `make-running-avg` function returns a stateful, single
    argument function that closes over an empty persistent queue. This queue is used
    to keep track of the current subset of data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，高阶`make-running-avg`函数返回一个有状态的、单参数函数，它封装了一个空的持久队列。这个队列用于跟踪当前的数据子集。
- en: We then create an instance of this function by calling it with a buffer size
    of 5 and save it to the `running-avg` var. Each time we call this new function
    with a number, it will add it to the queue using the `roll-buffer` function and
    then finally return the average of the items in the queue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用它并使用缓冲区大小为5来创建这个函数的实例，并将其保存到`running-avg`变量中。每次我们用数字调用这个新函数时，它都会使用`roll-buffer`函数将其添加到队列中，然后最终返回队列中项目的平均值。
- en: 'The code we have written to manage the thread pool will be reused as is so
    all that is left to do is update our periodic function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的用于管理线程池的代码将原样重用，所以我们剩下要做的就是更新我们的周期性函数：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since our function isn't a one-liner anymore, we abstract it away in its own
    function called `worker`. As before, it updates the price label, but we have also
    extended it to use the `running-avg` function created earlier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的函数不再是单行代码，我们将其抽象到它自己的函数`worker`中。就像之前一样，它更新价格标签，但我们还扩展了它以使用之前创建的`running-avg`函数。
- en: 'We''re ready to run the program once more:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好再次运行程序：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a window like the one shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到，就像以下截图所示的一个窗口：
- en: '![Rolling averages](img/00011.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![滚动平均值](img/00011.jpeg)'
- en: You should see that in addition to displaying the current share price for XYZ,
    the program also keeps track and refreshes the running average of the stream of
    prices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到，除了显示XYZ的当前股价之外，程序还跟踪并刷新价格流的运行平均值。
- en: Identifying problems with our current approach
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别我们当前方法的问题
- en: Aside from the lines of code responsible for building the user interface, our
    program is roughly 48 lines long.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了负责构建用户界面的代码行之外，我们的程序大约有48行长。
- en: The core of the program resides in the `share-price` and `avg` functions, which
    are responsible for querying the price service and calculating the average of
    a list of *n* numbers, respectively. They represent only six lines of code. There
    is a lot of *incidental complexity* in this small program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的核心在于`share-price`和`avg`函数，它们分别负责查询价格服务和计算一列*n*个数字的平均值。它们只代表六行代码。在这个小程序中有很多*附加复杂性*。
- en: 'Incidental complexity is complexity caused by code that is not essential to
    the problem at hand. In this example, we have two sources of such complexity—we
    are disregarding UI specific code for this discussion: the thread pool and the
    rolling buffer function. They add a great deal of cognitive load to someone reading
    and maintaining the code.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 附加复杂性是由与当前问题无关的代码引起的复杂性。在这个例子中，我们有两种这样的复杂性的来源——在这个讨论中，我们忽略了特定于UI的代码：线程池和滚动缓冲区函数。它们给阅读和维护代码的人带来了大量的认知负担。
- en: The thread pool is external to our problem. It is only concerned with the semantics
    of how to run tasks asynchronously. The rolling buffer function specifies a detailed
    implementation of a queue and how to use it to represent the concept.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池与我们的问题无关。它只关注如何异步运行任务的语义。滚动缓冲区函数指定了队列的详细实现以及如何使用它来表示该概念。
- en: Ideally, we should be able to abstract over these details and focus on the core
    of our problem; **Compositional Event Systems** (**CES**) allows us to do just
    that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该能够抽象出这些细节，专注于我们问题的核心；**组合事件系统**（**CES**）正允许我们做到这一点。
- en: Removing incidental complexity with RxClojure
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxClojure移除偶然复杂性
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. A Look at Reactive Extensions"),
    *A Look at Reactive Extensions*, we learned about the basic building blocks of
    RxClojure, an open-source CES framework. In this section, we'll use this knowledge
    in order to remove the incidental complexity from our program. This will give
    us a clear, declarative way to display both prices and rolling averages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](part0021_split_000.html#page "第二章. 反应式扩展概述")中，我们学习了RxClojure这个开源CES框架的基本构建块——《反应式扩展概述》。在本节中，我们将利用这些知识来从我们的程序中移除偶然的复杂性。这将使我们能够以清晰、声明性的方式显示价格和滚动平均值。
- en: 'The UI code we''ve written so far remains unchanged, but we need to make sure
    RxClojure is declared in the dependencies section of our `project.clj` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的UI代码保持不变，但我们需要确保在`project.clj`文件的依赖关系部分声明了RxClojure：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, ensure we require the following library:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保我们引入以下库：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The way we approach the problem this time is also different. Let''s take a
    look at the first requirement: it requires we display the current price of a company''s
    share in the stock market.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们解决问题的方法也有所不同。让我们看看第一个要求：它要求我们显示一家公司在股市中的当前股价。
- en: 'Every time we query the price service, we get a—possibly different—price for
    the company in question. As we saw in [Chapter 2](part0021_split_000.html#page
    "Chapter 2. A Look at Reactive Extensions"), *A Look at Reactive Extensions*,
    modeling this as an observable sequence is easy, so we''ll start with that. We''ll
    create a function that gives us back a stock price observable for the given company:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们查询价格服务时，我们都会得到一个——可能是不同的一—关于相关公司的价格。正如我们在[第二章](part0021_split_000.html#page
    "第二章. 反应式扩展概述")中看到的那样，将其建模为可观察序列是很容易的，所以我们将从这里开始。我们将创建一个函数，为我们提供给定公司的股价可观察对象：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is an observable that yields a single value and terminates. It''s equivalent
    to the following marble diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个产生单个值并终止的可观察对象。它等同于以下弹珠图：
- en: '![Removing incidental complexity with RxClojure](img/00012.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用RxClojure移除偶然复杂性](img/00012.jpeg)'
- en: Part of the first requirement is that we query the service on a predefined time
    interval—every 500 milliseconds in this case. This hints at an observable we have
    encountered before, aptly named *interval*. In order to get the polling behavior
    we want, we need to combine the interval and the price observables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分要求之一是我们需要在预定义的时间间隔内查询服务——在这个例子中是每500毫秒一次。这暗示了我们之前遇到的一个名为*interval*的可观察对象。为了获得我们想要的轮询行为，我们需要将interval和价格可观察对象结合起来。
- en: 'As you probably recall, `flatmap` is the tool for the job here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，`flatmap`是完成这项工作的工具：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In fact, we can simply subscribe to this new observable and test it out. Modify
    your main function to the following snippet and run the program:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以简单地订阅这个新的可观察对象并测试它。将你的主函数修改为以下片段并运行程序：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is very cool! We replicated the behavior of our first program with only
    a few lines of code. The best part is that we did not have to worry about thread
    pools or scheduling actions. By thinking about the problem in terms of observable
    sequences, as well as combining existing and new observables, we were able to
    declaratively express what we want the program to do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷！我们只用几行代码就复制了我们第一个程序的行为。最好的部分是，我们不必担心线程池或调度操作。通过将问题视为可观察序列，以及结合现有和新可观察对象，我们能够声明性地表达我们想要程序执行的操作。
- en: 'This already provides great benefits in maintainability and readability. However,
    we are still missing the other half of our program: rolling averages.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经为我们提供了在可维护性和可读性方面的巨大好处。然而，我们仍然缺少程序的一半：滚动平均值。
- en: Observable rolling averages
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察滚动平均值
- en: It might not be immediately obvious how we can model rolling averages as observables.
    What we need to keep in mind is that pretty much anything we can think of as a
    sequence of values, we can probably model as an observable sequence.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可能并不立即明显我们如何将滚动平均值建模为可观察对象。我们需要记住的是，几乎所有我们可以将其视为值序列的东西，我们都可以将其建模为可观察序列。
- en: 'Rolling averages are no different. Let''s forget for a moment that the prices
    are coming from a network call wrapped in an observable. Let''s imagine we have
    all values we care about in a Clojure vector:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动平均值也没有什么不同。让我们暂时忘记价格是从一个封装在可观察对象中的网络调用中来的。让我们想象我们有一个Clojure向量中所有我们关心的值：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What we need is a way to process these values in partitions—or buffers—of size
    5 in such a way that only a single value is dropped at each interaction. In Clojure,
    we can use the `partition` function for this purpose:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来以大小为5的分区（或缓冲区）处理这些值，这样在每次交互中只丢弃一个值。在Clojure中，我们可以使用`partition`函数来完成这个目的：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second argument to the `partition` function is called a *step* and it is
    the offset of how many items should be skipped before starting a new partition.
    Here, we set it to 1 in order to create the sliding window effect we need.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`函数的第二个参数被称为*步长*，它是开始新分区前应跳过的项目偏移量。在这里，我们将它设置为1，以便创建我们需要的滑动窗口效果。'
- en: 'The big question then is: can we somehow leverage `partition` when working
    with observable sequences?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来的大问题是：我们在处理可观察序列时能否以某种方式利用`partition`？
- en: 'It turns out that RxJava has a transformer called `buffer` just for this purpose.
    The previous example can be rewritten as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，RxJava有一个名为`buffer`的转换器，正是为此目的。前面的例子可以重写如下：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As mentioned previously, not all RxJava's API is exposed through RxClojure,
    so here we need to use interop to access the `buffer` method from the observable
    sequence.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并非所有RxJava的API都通过RxClojure暴露，因此在这里我们需要使用互操作来从可观察序列访问`buffer`方法。
- en: 'As before, the second argument to `buffer` is the offset, but it''s called
    `skip` in the RxJava documentation. If you run this at the REPL you''ll see the
    following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`buffer`的第二个参数是偏移量，但在RxJava文档中被称为`skip`。如果你在REPL中运行它，你会看到以下输出：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is exactly what we want. The only difference is that the buffer method
    waits until it has enough elements—five in this case—before proceeding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。唯一的区别是，缓冲方法会等待直到它有足够的元素——在这个例子中是五个——然后才继续。
- en: 'Now, we can go back to our program and incorporate this idea with our main
    function. Here is what it looks like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的程序，并在主函数中融入这个想法。它看起来是这样的：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can, then, independently subscribe to each one in order to update the price
    and rolling average labels. Running the program will display the same screen we''ve
    seen previously:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以独立订阅每个序列，以便更新价格和滚动平均值标签。运行程序将显示我们之前看到的相同屏幕：
- en: '![Observable rolling averages](img/00011.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![可观察滚动平均值](img/00011.jpeg)'
- en: 'You might have noticed two method calls we hadn''t seen before: `publish` and
    `connect`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了两个之前没有见过的方法调用：`publish` 和 `connect`。
- en: The `publish` method returns a connectable observable. This means that the observable
    won't start emitting values until its `connect` method has been called. We do
    this here because we want to make sure that all the subscribers receive all the
    values emitted by the original observable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`方法返回一个可连接的可观察序列。这意味着可观察序列不会开始发出值，直到其`connect`方法被调用。我们在这里这样做是因为我们想确保所有订阅者都能收到原始可观察序列发出的所有值。'
- en: In conclusion, without much additional code, we implemented all requirements
    in a concise, declarative manner that is easy to maintain and follow. We have
    also made the previous roll-buffer function completely unnecessary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们没有添加太多额外的代码，就以一种简洁、声明性的方式实现了所有要求，这使得代码易于维护和跟踪。我们还将之前的roll-buffer函数完全变得不再必要。
- en: 'The full source code for the CES version of the program is given here for reference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序CES版本的完整源代码在此提供供参考：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how in this version of the program, we didn't have to use a shutdown hook.
    This is because RxClojure creates daemon threads, which are automatically terminated
    once the application exits.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个程序版本中，我们不需要使用关闭钩子。这是因为RxClojure创建了守护线程，一旦应用程序退出，这些线程会自动终止。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we simulated a real-world application with our stock market
    program. We've written it in a somewhat traditional way using thread pools and
    a custom queue implementation. We then refactored it to a CES style using RxClojure's
    observable sequences.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用我们的股票市场程序模拟了一个现实世界应用。我们以某种传统的方式编写了它，使用了线程池和自定义队列实现。然后我们将其重构为CES风格，使用了RxClojure的可观察序列。
- en: The resulting program is shorter, simpler, and easier to read once you get familiar
    with the core concepts of RxClojure and RxJava.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦熟悉了RxClojure和RxJava的核心概念，生成的程序将更短、更简单、更容易阅读。
- en: In the next Chapter we will be introduced to core.async in preparation for implementing
    our own basic CES framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍core.async，为实施我们自己的基本CES框架做准备。
