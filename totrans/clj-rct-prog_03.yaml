- en: Chapter 3. Asynchronous Programming and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several business applications need to react to external stimuli—such as network
    traffic—asynchronously. An example of such software might be a desktop application
    that allows us to track a company's share prices in the stock market.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build this application first using a more traditional approach. In
    doing so, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Be able to identify and understand the drawbacks of the first design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use RxClojure to deal with stateful computations such as rolling
    averages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the example in a declarative fashion using observable sequences, thus
    reducing the complexity found in our first approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stock market monitoring application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our stock market program will consist of three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: A function simulating an external service from which we can query the current
    price—this would likely be a network call in a real setting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scheduler that polls the preceding function at a predefined interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A display function responsible for updating the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new leiningen project, where the source code for
    our application will live. Type the following on the command line and then switch
    into the newly created directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ll be building a GUI for this application, go ahead and add a dependency
    on Seesaw to the dependencies section of your `project.clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `src/stock_market_monitor/core.clj` file in your favorite editor.
    Let''s create and configure our application''s UI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the UI is fairly simple. It consists of a single label that
    will display a company's share price. We also imported two Java classes, `ScheduledThreadPoolExecutor`
    and `TimeUnit`, which we will use shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need is our polling machinery so that we can invoke the pricing
    service on a given schedule. We''ll implement this via a thread pool so as not
    to block the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User interface SDKs such as swing have the concept of a main—or UI—thread. This
    is the thread used by the SDK to render the UI components to the screen. As such,
    if we have blocking—or even simply slow running— operations execute in this thread,
    the user experience will be severely affected, hence the use of a thread pool
    to offload expensive function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `init-scheduler` function creates `ScheduledThreadPoolExecutor` with the
    given number of threads. That's the thread pool in which our periodic function
    will run. The `run-every` function schedules a function `f` in the given `pool`
    to run at the interval specified by `millis`. Finally, `shutdown` is a function
    that will be called on program termination and shutdown the thread pool gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the program puts all these parts together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `share-price` function sleeps for 200 milliseconds to simulate network latency
    and returns a random integer between 0 and 1,000 representing the stock's price.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of our `-main` function adds a shutdown hook to the runtime.
    This allows our program to intercept termination—such as pressing *Ctrl* + *C*
    in a terminal window—and gives us the opportunity to shutdown the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ScheduledThreadPoolExecutor` pool creates non-daemon threads by default.
    A program cannot terminate if there are any non-daemon threads alive in addition
    to the program's main thread. This is why the shutdown hook is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize the scheduler with a single thread and schedule a function
    to be executed every 500 milliseconds. This function asks the `share-price` function
    for XYZ's current price and updates the label.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Desktop applications require all rendering to be done in the UI thread. However,
    our periodic function runs on a separate thread and needs to update the price
    label. This is why we use `invoke-now`, which is a Seesaw function that schedules
    its body to be executed in the UI thread as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the program by typing the following command in the project''s root
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trampolining tells leiningen not to nest our program's JVM within its own, thus
    freeing us to handle uses of *Ctrl* + *C* ourselves through shutdown hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A window like the one shown in the following screenshot will be displayed,
    with the values on it being updated as per the schedule implemented earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a stock market monitoring application](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a fine solution. The code is relatively straightforward and satisfies
    our original requirements. However, if we look at the big picture, there is a
    fair bit of noise in our program. Most of its lines of code are dealing with creating
    and managing a thread pool, which, while necessary, isn't central to the problem
    we're solving—it's an implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll keep things as they are for the moment and add a new requirement: rolling
    averages.'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling averages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can see the up-to-date stock price for a given company, it makes
    sense to display a rolling average of the past, say, five stock prices. In a real
    scenario, this would provide an objective view of a company's share trend in the
    stock market.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extend our program to accommodate this new requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to modify our namespace definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only change is a new import clause, for Clojure's `PersistentQueue` class.
    We will be using that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need a new label to display the current running average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need a function to calculate rolling averages. A rolling—or moving—average
    is a calculation in statistics, where you take the average of a subset of items
    in a dataset. This subset has a fixed size and it shifts forward as data comes
    in. This will become clear with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a list with numbers from 1 to 10, inclusive. If we use `3`
    as the subset size, the rolling averages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted parts in the preceding code show the current *window* being
    used to calculate the subset average.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what rolling averages are, we can move on to implement it
    in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `roll-buffer` function is a utility function that takes a queue, a number,
    and a buffer size as arguments. It adds that number to the queue, popping the
    oldest element if the queue goes over the buffer limit, thus causing its contents
    to *roll* over.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a function for calculating the average of a collection of numbers.
    We cast the result to float if there's an uneven division.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the higher-order `make-running-avg` function returns a stateful, single
    argument function that closes over an empty persistent queue. This queue is used
    to keep track of the current subset of data.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of this function by calling it with a buffer size
    of 5 and save it to the `running-avg` var. Each time we call this new function
    with a number, it will add it to the queue using the `roll-buffer` function and
    then finally return the average of the items in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we have written to manage the thread pool will be reused as is so
    all that is left to do is update our periodic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since our function isn't a one-liner anymore, we abstract it away in its own
    function called `worker`. As before, it updates the price label, but we have also
    extended it to use the `running-avg` function created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re ready to run the program once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a window like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rolling averages](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You should see that in addition to displaying the current share price for XYZ,
    the program also keeps track and refreshes the running average of the stream of
    prices.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying problems with our current approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the lines of code responsible for building the user interface, our
    program is roughly 48 lines long.
  prefs: []
  type: TYPE_NORMAL
- en: The core of the program resides in the `share-price` and `avg` functions, which
    are responsible for querying the price service and calculating the average of
    a list of *n* numbers, respectively. They represent only six lines of code. There
    is a lot of *incidental complexity* in this small program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidental complexity is complexity caused by code that is not essential to
    the problem at hand. In this example, we have two sources of such complexity—we
    are disregarding UI specific code for this discussion: the thread pool and the
    rolling buffer function. They add a great deal of cognitive load to someone reading
    and maintaining the code.'
  prefs: []
  type: TYPE_NORMAL
- en: The thread pool is external to our problem. It is only concerned with the semantics
    of how to run tasks asynchronously. The rolling buffer function specifies a detailed
    implementation of a queue and how to use it to represent the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should be able to abstract over these details and focus on the core
    of our problem; **Compositional Event Systems** (**CES**) allows us to do just
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Removing incidental complexity with RxClojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. A Look at Reactive Extensions"),
    *A Look at Reactive Extensions*, we learned about the basic building blocks of
    RxClojure, an open-source CES framework. In this section, we'll use this knowledge
    in order to remove the incidental complexity from our program. This will give
    us a clear, declarative way to display both prices and rolling averages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI code we''ve written so far remains unchanged, but we need to make sure
    RxClojure is declared in the dependencies section of our `project.clj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, ensure we require the following library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The way we approach the problem this time is also different. Let''s take a
    look at the first requirement: it requires we display the current price of a company''s
    share in the stock market.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we query the price service, we get a—possibly different—price for
    the company in question. As we saw in [Chapter 2](part0021_split_000.html#page
    "Chapter 2. A Look at Reactive Extensions"), *A Look at Reactive Extensions*,
    modeling this as an observable sequence is easy, so we''ll start with that. We''ll
    create a function that gives us back a stock price observable for the given company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an observable that yields a single value and terminates. It''s equivalent
    to the following marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing incidental complexity with RxClojure](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Part of the first requirement is that we query the service on a predefined time
    interval—every 500 milliseconds in this case. This hints at an observable we have
    encountered before, aptly named *interval*. In order to get the polling behavior
    we want, we need to combine the interval and the price observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably recall, `flatmap` is the tool for the job here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can simply subscribe to this new observable and test it out. Modify
    your main function to the following snippet and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is very cool! We replicated the behavior of our first program with only
    a few lines of code. The best part is that we did not have to worry about thread
    pools or scheduling actions. By thinking about the problem in terms of observable
    sequences, as well as combining existing and new observables, we were able to
    declaratively express what we want the program to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'This already provides great benefits in maintainability and readability. However,
    we are still missing the other half of our program: rolling averages.'
  prefs: []
  type: TYPE_NORMAL
- en: Observable rolling averages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might not be immediately obvious how we can model rolling averages as observables.
    What we need to keep in mind is that pretty much anything we can think of as a
    sequence of values, we can probably model as an observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rolling averages are no different. Let''s forget for a moment that the prices
    are coming from a network call wrapped in an observable. Let''s imagine we have
    all values we care about in a Clojure vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need is a way to process these values in partitions—or buffers—of size
    5 in such a way that only a single value is dropped at each interaction. In Clojure,
    we can use the `partition` function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The second argument to the `partition` function is called a *step* and it is
    the offset of how many items should be skipped before starting a new partition.
    Here, we set it to 1 in order to create the sliding window effect we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question then is: can we somehow leverage `partition` when working
    with observable sequences?'
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that RxJava has a transformer called `buffer` just for this purpose.
    The previous example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, not all RxJava's API is exposed through RxClojure,
    so here we need to use interop to access the `buffer` method from the observable
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the second argument to `buffer` is the offset, but it''s called
    `skip` in the RxJava documentation. If you run this at the REPL you''ll see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we want. The only difference is that the buffer method
    waits until it has enough elements—five in this case—before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go back to our program and incorporate this idea with our main
    function. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, then, independently subscribe to each one in order to update the price
    and rolling average labels. Running the program will display the same screen we''ve
    seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observable rolling averages](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have noticed two method calls we hadn''t seen before: `publish` and
    `connect`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `publish` method returns a connectable observable. This means that the observable
    won't start emitting values until its `connect` method has been called. We do
    this here because we want to make sure that all the subscribers receive all the
    values emitted by the original observable.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, without much additional code, we implemented all requirements
    in a concise, declarative manner that is easy to maintain and follow. We have
    also made the previous roll-buffer function completely unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full source code for the CES version of the program is given here for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note how in this version of the program, we didn't have to use a shutdown hook.
    This is because RxClojure creates daemon threads, which are automatically terminated
    once the application exits.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we simulated a real-world application with our stock market
    program. We've written it in a somewhat traditional way using thread pools and
    a custom queue implementation. We then refactored it to a CES style using RxClojure's
    observable sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting program is shorter, simpler, and easier to read once you get familiar
    with the core concepts of RxClojure and RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: In the next Chapter we will be introduced to core.async in preparation for implementing
    our own basic CES framework.
  prefs: []
  type: TYPE_NORMAL
