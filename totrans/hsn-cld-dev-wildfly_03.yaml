- en: Right-Sizing Your Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn what Swarm does to create your services with
    only those dependencies that are necessary for them. You will learn in greater
    detail what a fraction is, how Swarm detects what fractions should be used, and
    how you can modify the fraction discovery behavior. Finally, you will learn how
    to further modify the service creation size and behavior using hollow JARs and
    thin JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain all of that, we will introduce the service on which we are
    going to work.
  prefs: []
  type: TYPE_NORMAL
- en: Catalog service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, you learned the basic architecture of the pet store sample
    application and the services that constitute it. In this and the next chapter,
    we will be working with the catalog service. To recall, this is the service responsible
    for providing the information about pets available in the store. We are going
    to introduce that simple functionality now. In the next three chapters, we will
    modify that code in order to show you different features and configuration options
    of WildFly Swarm. Let's look at the initial version.
  prefs: []
  type: TYPE_NORMAL
- en: Draft version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by introducing the first, draft version of the service, which
    we will examine and extend later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter3/catalog-service-jaxrs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the preceding chapter, we have to start with the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have to add the dependency to JAX-RS fraction (1) and configure the WildFly
    Swarm plugin (2). Let's move to the code now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with a simple domain class, `Item`, which contains information
    about the pets available in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, this is a simple class containing `itemId`,
    `name`, description of the pet, and the quantity available in the store. As in
    the `Hello World` example, we have to initialize our JAX-RS application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to write a simple JAX-RS resource that will serve up
    information about available pets from the in-memory `HashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our resource is located at the root path of an application (1). In the first
    version, we have implemented the catalog as a `HashMap` and populated it with
    the first pet—`turtle` (2). The `searchById` method will be invoked when the `GET`
    method is invoked with the `"item"` address and the `itemId` parameter (3).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build and deploy the application as in the first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enter the address of the catalog-service in the web browser, we will
    be able to find our first pet in the catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf2ea670-396d-4fcb-aa12-6caea794a24f.png)'
  prefs: []
  type: TYPE_IMG
- en: Fractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we did the following: we annotated our classes with
    JAX-RS annotations, built the code using Swarm Maven plugin, and obtained a runnable
    Swarm-based JAR. The resulting JAR is much smaller than a full application server.
    The reason for that is that Swarm has wrapped our code in only those parts of
    WildFly that it needs to work. Now, we will look in greater detail at this statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the application created in the preceding chapter again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the beginning of the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed519f6d-79e1-481f-bc43-4b522c3d629b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the lines of the log in the red rectangle. Swarm is informing
    us that it has installed four fractions: JAX-RS, Undertow, Elytron, and Logging.
    However, what does it mean by that and what actually is a fraction?'
  prefs: []
  type: TYPE_NORMAL
- en: The fraction is a part of the functionality needed by an application. To be
    more precise, fraction gathers the code and the configuration necessary for some
    part of the enterprise functionality to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have used JAX-RS in our service, we have added the JAX-RS fraction as
    a Maven dependency. To recall, this was the following dependency in the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a result, Swarm has built a service that contains this fraction. However,
    by looking again at the preceding screenshot, we can see that JAX-RS is not the
    only fraction installed as there are also Undertow, Elytron, and Logging fractions
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the Logging fraction presence is that there are some fractions
    that are necessary for all configurations—logging is one among them. What about
    Undertow fraction? Fractions can depend on other fractions. As you probably know,
    JAX-RS needs to use a web server to serve web pages that it generates, and as
    a result, the JAX-RS fraction requires the dependency on the Undertow plugin.
    Swarm has discovered that we are using JAX-RS, so it included it in the generated
    application, but it also had to analyze dependencies of that fraction. The result
    of this analysis showed that another fraction, namely Undertow, has to be included.
    Similarly, both JAX-RS and Undertow depend on the Elytron fraction, which is responsible
    for implementing the security. As a result, it too was added to the created service.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at what happens if we decide to refactor our catalog
    service and use CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter3/catalog-service-jaxrs-cdi/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move the search functionality from the JAX-RS resource to the CDI service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We created an application-scoped bean (1) and provided the `Search` method
    as the part of its API (2). Also, we have to modify the `CatalogResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We injected the `CatalogService` that we have just created to it (1) and used
    it to look for the pet (2). Finally, we have to modify the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have to add Swarm's CDI fraction (2).
  prefs: []
  type: TYPE_NORMAL
- en: After doing all of the things mentioned previously in this chapter, we can build
    our application and see a result that is similar to the one in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the WildFly-Swarm plugin''s log again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa9cea36-709b-44c0-b99e-3e160ec0af83.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have eight fractions present. Apart from the ones that were introduced
    in the preceding application, CDI, CDI-config, `Bean Validation`, and `Transactions`
    have been added. Again, Swarm has scanned the application and found out that it
    relies on JAX-RS and CDI; it has added those fractions and all their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably noted, the fractions that we see now are tightly related to
    Java EE specification. Can we then think of them as particular Java EE specification
    implementations added to the server core on demand? No. As we already know, Swarm
    is based on the Java EE server and part of its use case is to enable the transition
    from the monolith applications to microservices, there is a large group of fractions
    that map to the implementation of some Java EE functionalities. They are not limited
    to that, though. There is another group of fractions that provide functionality
    outside the Java EE. What is more, you are also able to implement your own fraction
    if you need it in your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Look under WildFly's hood to understand how WildFly plugin works internally
    to create your lean Swarm application. Let's start by explaining how fraction
    detection works and how you can change its behavior by modifying Swarm's configuration
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s return to our latest `CatalogService`. As you recall, it uses JAX-RS
    and CDI. We have provided the dependencies manually by editing the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided dependencies for two fractions: JAX-RS (1) and CDI (2). We
    can run the application and note that it is indeed working.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue our experiment now. What happens if we configure only one fraction?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, only the JAX-RS dependency is configured (1). Note that
    in such a case we have to explicitly define a dependency on CDI-API (2). When
    we run the application, we see the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b10c842f-7c56-4539-b56d-9476eb90df73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see no errors yet, but the first few lines of your log already foretell
    that problems will occur. Although CDI is used, its fractions (and its dependents)
    have not been added. If we get into a browser and enter the address of our service,
    we will see a bad request error. Add a temporary log to service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to note the cause of our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Owing to missing CDI fraction, bean resolution and injection were not performed.
    As a result, the service object was not injected into the `CatalogResource` resource,
    resulting in `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get one step further and remove all the fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have removed all the fractions (1). Please note that in such a case we have
    to provide all of the Java EE APIs manually (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example reference: `chapter3/catalog-service-auto-detect/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we build the project configured this way, we will see something interesting
    in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9374c6d1-9525-46f9-94d7-88c8dba1d692.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, Swarm has performed automatic fraction detection.
    How does it work?
  prefs: []
  type: TYPE_NORMAL
- en: Swarm found out that `org.packt.swarm.petstore.catalog.CatalogResource` is using
    the classes from the `javax.ws.rs` package, which resulted in the inclusion of
    JAX-RS. Similarly, usage of the `javax.inject` package led to the inclusion of
    the CDI fraction. Later, as in manual examples, Swarm has a build service that
    contains the detected fractions, their dependencies, and fractions that are always
    needed. If you run the service now, you will note that it is indeed working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand why Swarm behaved in the described way in the recent
    examples, we must learn about fraction detection mode. Let's do it now.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction detection mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swarm Maven plugin can work in different fraction detection modes. If you do
    not provide fraction dependencies manually, it runs in the when-missing mode.
    We have already seen the behavior of this mode in our previous examples: when
    no direct fraction dependency is provided, the plugin performs auto-detection.
    On the other hand, if we provide at least one fraction dependency manually, the
    auto-detection mode is turned off. This is the reason why our last example wasn''t
    built with the CDI fraction included: adding the JAX-RS fraction manually turned
    auto-detection off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there something we can do about it? Yup, we can use a different detection
    mode: `force`. This mode makes auto-detection work every time. After detecting
    the fractions that are used, it merges the detection result with fractions configured
    by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example reference: `chapter3/catalog-service-force-detect`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reconfigure our example to make it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, only the JAX-RS fraction is configured (1); however, because we have
    configured the Maven plugin with the `force` detection mode (2), Swarm will also
    detect the previously missing CDI fraction. If we run our application again, we
    will see that all necessary fractions were detected and the application works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen two fraction detection modes: when-missing and `force`. Is there
    another? Yes, there is one more: *never*. In this mode, as its name implies, the
    fractions are never detected, and you always have to provide all of them manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Thin and hollow JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, during the standard Maven plugin operation, the resulting
    application contains both the Swarm server and the application that is deployed
    on it. We can change that behavior. Let's suppose that we deploy our application
    in the cloud and later push new changes to its code. Since it is the application
    code that changes in most cases, we would like to create the container with the
    server in the cloud and later push only code to it. How are we able to do it?
    By using hollow JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Using hollow JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are able to configure the Maven plugin to build hollow JARs, which contain
    the swarm server without the actual application deployed on it. Let's return to
    the JAX-RS + CDI example again to show how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example reference: `chapter3/catalog-service-hollow-jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will need to do is configure the Maven plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that we have to do is to enable the hollow configuration parameter
    (1). When we build the application and navigate to our target directory, we will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f141a9c-0e43-4481-9f56-334cdca95fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, one directory ends with the `-hollow-swarm`
    suffix. This is our hollow jar without the deployed application. When running
    it, we must provide the name of the application that we will deploy on the created
    server. We will be able to do it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will start the container and run our application. As a result, it will
    behave in the same way as the original example.
  prefs: []
  type: TYPE_NORMAL
- en: Using thin JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be able to create a thin JAR. A thin JAR does not contain its Maven
    dependencies and loads them during application startup from a local or remote
    Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example reference: `chapter3/catalog-service-thin-jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build the application and look at the target directory, we get the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/793ebc5f-22ea-4c9b-8931-51db0c9871c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that in the preceding scenario, all the JARs are very small with the runnable
    JAR of `744` KB.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the possibility to mix thin JARs with hollow JARs. The runnable
    JAR does not contain the application that has to be deployed on it, so it has
    to be run in the same way as in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both the server and the deployment do not contain bundled dependencies, so they
    have to be loaded from the Maven repository using the application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Swarm creates runnable, right-sized services.
    You learned what a fraction is, how the fraction detection process looks, and
    how you can modify it. Finally, you learned how to create hollow and thin JARs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will show you how to configure your microservices.
  prefs: []
  type: TYPE_NORMAL
