- en: Right-Sizing Your Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当调整服务大小
- en: In this chapter, you will learn what Swarm does to create your services with
    only those dependencies that are necessary for them. You will learn in greater
    detail what a fraction is, how Swarm detects what fractions should be used, and
    how you can modify the fraction discovery behavior. Finally, you will learn how
    to further modify the service creation size and behavior using hollow JARs and
    thin JARs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Swarm如何仅使用对服务必要的依赖项来创建你的服务。你将更详细地了解什么是分数，Swarm如何检测应该使用哪些分数，以及你如何修改分数发现行为。最后，你将了解如何使用空JAR和瘦JAR进一步修改服务创建的大小和行为。
- en: Before we explain all of that, we will introduce the service on which we are
    going to work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释所有这些之前，我们将介绍我们将要工作的服务。
- en: Catalog service
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录服务
- en: In the first chapter, you learned the basic architecture of the pet store sample
    application and the services that constitute it. In this and the next chapter,
    we will be working with the catalog service. To recall, this is the service responsible
    for providing the information about pets available in the store. We are going
    to introduce that simple functionality now. In the next three chapters, we will
    modify that code in order to show you different features and configuration options
    of WildFly Swarm. Let's look at the initial version.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你学习了宠物商店示例应用程序的基本架构以及构成它的服务。在本章和下一章中，我们将使用目录服务。为了回忆，这是负责提供商店中可用宠物信息的那个服务。现在我们将介绍这个简单的功能。在接下来的三个章节中，我们将修改这段代码，以展示WildFly
    Swarm的不同功能和配置选项。让我们看看初始版本。
- en: Draft version
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 草稿版本
- en: We will start by introducing the first, draft version of the service, which
    we will examine and extend later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍服务的第一个草稿版本，我们将在稍后对其进行检查和扩展。
- en: 'Examples reference: `chapter3/catalog-service-jaxrs`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-jaxrs`。
- en: 'As in the preceding chapter, we have to start with the `pom.xml`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一章所述，我们必须从`pom.xml`开始：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to add the dependency to JAX-RS fraction (1) and configure the WildFly
    Swarm plugin (2). Let's move to the code now.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加JAX-RS分数的依赖项（1）并配置WildFly Swarm插件（2）。现在让我们转向代码。
- en: 'We will start with a simple domain class, `Item`, which contains information
    about the pets available in the store:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的域类`Item`开始，它包含关于商店中可用的宠物的信息：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the preceding code, this is a simple class containing `itemId`,
    `name`, description of the pet, and the quantity available in the store. As in
    the `Hello World` example, we have to initialize our JAX-RS application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这是一个简单的类，包含`itemId`、`name`、宠物的描述和商店中可用的数量。正如在`Hello World`示例中一样，我们必须初始化我们的JAX-RS应用程序：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we are ready to write a simple JAX-RS resource that will serve up
    information about available pets from the in-memory `HashMap`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好编写一个简单的JAX-RS资源，该资源将从内存中的`HashMap`提供有关可用宠物的信息：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our resource is located at the root path of an application (1). In the first
    version, we have implemented the catalog as a `HashMap` and populated it with
    the first pet—`turtle` (2). The `searchById` method will be invoked when the `GET`
    method is invoked with the `"item"` address and the `itemId` parameter (3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源位于应用程序的根路径（1）。在第一个版本中，我们将目录实现为一个`HashMap`，并用第一个宠物`turtle`填充它（2）。当使用`"item"`地址和`itemId`参数调用`GET`方法时，将调用`searchById`方法（3）。
- en: 'We can build and deploy the application as in the first chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像第一章中那样构建和部署应用程序：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we enter the address of the catalog-service in the web browser, we will
    be able to find our first pet in the catalog:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网络浏览器中输入目录服务的地址，我们就能在目录中找到我们的第一个宠物：
- en: '![](img/cf2ea670-396d-4fcb-aa12-6caea794a24f.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf2ea670-396d-4fcb-aa12-6caea794a24f.png)'
- en: Fractions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数
- en: 'In the preceding example, we did the following: we annotated our classes with
    JAX-RS annotations, built the code using Swarm Maven plugin, and obtained a runnable
    Swarm-based JAR. The resulting JAR is much smaller than a full application server.
    The reason for that is that Swarm has wrapped our code in only those parts of
    WildFly that it needs to work. Now, we will look in greater detail at this statement.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，我们做了以下操作：我们用JAX-RS注解注解了我们的类，使用Swarm Maven插件构建了代码，并获得了可运行的基于Swarm的JAR。生成的JAR比完整的应用程序服务器小得多。这是因为Swarm只包装了我们需要的WildFly的部分来工作。现在，我们将更详细地研究这个声明。
- en: 'Let''s run the application created in the preceding chapter again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行前一章创建的应用程序：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at the beginning of the console output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看控制台输出的开头：
- en: '![](img/ed519f6d-79e1-481f-bc43-4b522c3d629b.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed519f6d-79e1-481f-bc43-4b522c3d629b.png)'
- en: 'Take a look at the lines of the log in the red rectangle. Swarm is informing
    us that it has installed four fractions: JAX-RS, Undertow, Elytron, and Logging.
    However, what does it mean by that and what actually is a fraction?'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看看红色矩形中的日志行。Swarm在通知我们它已安装了四个分数：JAX-RS、Undertow、Elytron和Logging。然而，这意味着什么，实际上分数是什么？
- en: The fraction is a part of the functionality needed by an application. To be
    more precise, fraction gathers the code and the configuration necessary for some
    part of the enterprise functionality to work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分数是应用程序所需功能的一部分。更准确地说，分数收集了企业功能某部分工作所需的代码和配置。
- en: 'As we have used JAX-RS in our service, we have added the JAX-RS fraction as
    a Maven dependency. To recall, this was the following dependency in the `pom.xml`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在服务中使用了JAX-RS，我们添加了JAX-RS分数作为Maven依赖项。回想一下，这是`pom.xml`中的以下依赖项：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a result, Swarm has built a service that contains this fraction. However,
    by looking again at the preceding screenshot, we can see that JAX-RS is not the
    only fraction installed as there are also Undertow, Elytron, and Logging fractions
    present.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Swarm构建了一个包含此分数的服务。然而，再次查看前面的截图，我们可以看到JAX-RS并不是唯一安装的分数，因为还有Undertow、Elytron和Logging分数存在。
- en: The reason for the Logging fraction presence is that there are some fractions
    that are necessary for all configurations—logging is one among them. What about
    Undertow fraction? Fractions can depend on other fractions. As you probably know,
    JAX-RS needs to use a web server to serve web pages that it generates, and as
    a result, the JAX-RS fraction requires the dependency on the Undertow plugin.
    Swarm has discovered that we are using JAX-RS, so it included it in the generated
    application, but it also had to analyze dependencies of that fraction. The result
    of this analysis showed that another fraction, namely Undertow, has to be included.
    Similarly, both JAX-RS and Undertow depend on the Elytron fraction, which is responsible
    for implementing the security. As a result, it too was added to the created service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 日志分数存在的原因是，有一些分数对于所有配置都是必要的——日志就是其中之一。那么Undertow分数呢？分数可以依赖于其他分数。正如你可能知道的，JAX-RS需要使用一个网络服务器来服务它生成的网页，因此，JAX-RS分数需要依赖于Undertow插件。Swarm发现我们正在使用JAX-RS，因此它将其包含在生成的应用程序中，但它还必须分析该分数的依赖项。分析的结果显示，另一个分数，即Undertow，也必须包含在内。同样，JAX-RS和Undertow都依赖于负责实现安全的Elytron分数，因此它也被添加到了创建的服务中。
- en: Now, let's take a look at what happens if we decide to refactor our catalog
    service and use CDI.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们决定重构我们的目录服务并使用CDI会发生什么：
- en: 'Examples reference: `chapter3/catalog-service-jaxrs-cdi/`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-jaxrs-cdi/`。
- en: 'Let''s move the search functionality from the JAX-RS resource to the CDI service:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将搜索功能从JAX-RS资源移动到CDI服务：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We created an application-scoped bean (1) and provided the `Search` method
    as the part of its API (2). Also, we have to modify the `CatalogResource`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个应用程序范围的bean（1）并将`Search`方法作为其API的一部分（2）。此外，我们还需要修改`CatalogResource`：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We injected the `CatalogService` that we have just created to it (1) and used
    it to look for the pet (2). Finally, we have to modify the `pom.xml`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向其中注入了我们刚刚创建的`CatalogService`（1）并使用它来查找宠物（2）。最后，我们必须修改`pom.xml`：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have to add Swarm's CDI fraction (2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加Swarm的CDI分数（2）。
- en: After doing all of the things mentioned previously in this chapter, we can build
    our application and see a result that is similar to the one in the preceding example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中提到的所有事情都完成后，我们可以构建我们的应用程序并看到与前面示例类似的结果。
- en: 'Let''s look at the WildFly-Swarm plugin''s log again:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看WildFly-Swarm插件的日志：
- en: '![](img/aa9cea36-709b-44c0-b99e-3e160ec0af83.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa9cea36-709b-44c0-b99e-3e160ec0af83.png)'
- en: We now have eight fractions present. Apart from the ones that were introduced
    in the preceding application, CDI, CDI-config, `Bean Validation`, and `Transactions`
    have been added. Again, Swarm has scanned the application and found out that it
    relies on JAX-RS and CDI; it has added those fractions and all their dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有八个分数存在。除了前面应用程序中引入的CDI、CDI-config、`Bean Validation`和`Transactions`之外，CDI、CDI-config、`Bean
    Validation`和`Transactions`也被添加了。再次，Swarm扫描了应用程序并发现它依赖于JAX-RS和CDI；它添加了那些分数及其所有依赖项。
- en: As you probably noted, the fractions that we see now are tightly related to
    Java EE specification. Can we then think of them as particular Java EE specification
    implementations added to the server core on demand? No. As we already know, Swarm
    is based on the Java EE server and part of its use case is to enable the transition
    from the monolith applications to microservices, there is a large group of fractions
    that map to the implementation of some Java EE functionalities. They are not limited
    to that, though. There is another group of fractions that provide functionality
    outside the Java EE. What is more, you are also able to implement your own fraction
    if you need it in your use case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许已经注意到的，我们现在看到的分数与Java EE规范紧密相关。那么，我们可以把它们看作是添加到服务器核心的特定Java EE规范实现吗？不。因为我们已经知道，Swarm基于Java
    EE服务器，其部分用途是使单体应用程序能够过渡到微服务，存在一大组分数映射到某些Java EE功能的实现。尽管如此，它们并不局限于这一点。还有另一组分数提供Java
    EE之外的功能。更重要的是，如果你在用例中需要，你也能够实现自己的分数。
- en: Look under WildFly's hood to understand how WildFly plugin works internally
    to create your lean Swarm application. Let's start by explaining how fraction
    detection works and how you can change its behavior by modifying Swarm's configuration
    parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 查看WildFly的内部结构，了解WildFly插件是如何工作的，以便创建你的精简Swarm应用程序。让我们首先解释分数检测是如何工作的，以及你如何通过修改Swarm的配置参数来改变其行为。
- en: Fraction detection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数检测
- en: 'Let''s return to our latest `CatalogService`. As you recall, it uses JAX-RS
    and CDI. We have provided the dependencies manually by editing the `pom.xml` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们最新的`CatalogService`。正如你所回忆的，它使用了JAX-RS和CDI。我们通过编辑`pom.xml`文件手动提供了依赖项：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have provided dependencies for two fractions: JAX-RS (1) and CDI (2). We
    can run the application and note that it is indeed working.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个分数提供了依赖项：JAX-RS（1）和CDI（2）。我们可以运行应用程序并注意到它确实在运行。
- en: Let's continue our experiment now. What happens if we configure only one fraction?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的实验。如果我们只配置一个分数会发生什么？
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, only the JAX-RS dependency is configured (1). Note that
    in such a case we have to explicitly define a dependency on CDI-API (2). When
    we run the application, we see the following log:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，只配置了JAX-RS依赖项（1）。请注意，在这种情况下，我们必须明确定义对CDI-API的依赖项（2）。当我们运行应用程序时，我们看到以下日志：
- en: '![](img/b10c842f-7c56-4539-b56d-9476eb90df73.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b10c842f-7c56-4539-b56d-9476eb90df73.png)'
- en: 'You will see no errors yet, but the first few lines of your log already foretell
    that problems will occur. Although CDI is used, its fractions (and its dependents)
    have not been added. If we get into a browser and enter the address of our service,
    we will see a bad request error. Add a temporary log to service class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你还没有看到错误，但你的日志的前几行已经预示着问题将会发生。尽管使用了CDI，但其分数（及其依赖项）尚未添加。如果我们打开浏览器并输入我们服务的地址，我们会看到一个错误的请求错误。在服务类中添加一个临时日志：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will be able to note the cause of our problem:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够注意到我们问题的原因：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Owing to missing CDI fraction, bean resolution and injection were not performed.
    As a result, the service object was not injected into the `CatalogResource` resource,
    resulting in `NullPointerException`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺少CDI分数，没有进行豆子解析和注入。因此，服务对象没有被注入到`CatalogResource`资源中，导致`NullPointerException`。
- en: 'Let''s get one step further and remove all the fractions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，移除所有的分数：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have removed all the fractions (1). Please note that in such a case we have
    to provide all of the Java EE APIs manually (2).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了所有的分数（1）。请注意，在这种情况下，我们必须手动提供所有的Java EE API（2）。
- en: 'Example reference: `chapter3/catalog-service-auto-detect/`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-auto-detect/`。
- en: 'When we build the project configured this way, we will see something interesting
    in the log:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式配置项目进行构建时，日志中会出现一些有趣的内容：
- en: '![](img/9374c6d1-9525-46f9-94d7-88c8dba1d692.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9374c6d1-9525-46f9-94d7-88c8dba1d692.png)'
- en: In the preceding example, Swarm has performed automatic fraction detection.
    How does it work?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Swarm已经执行了自动分数检测。它是如何工作的？
- en: Swarm found out that `org.packt.swarm.petstore.catalog.CatalogResource` is using
    the classes from the `javax.ws.rs` package, which resulted in the inclusion of
    JAX-RS. Similarly, usage of the `javax.inject` package led to the inclusion of
    the CDI fraction. Later, as in manual examples, Swarm has a build service that
    contains the detected fractions, their dependencies, and fractions that are always
    needed. If you run the service now, you will note that it is indeed working correctly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 发现 `org.packt.swarm.petstore.catalog.CatalogResource` 正在使用 `javax.ws.rs`
    包中的类，这导致了 JAX-RS 的包含。同样，使用 `javax.inject` 包导致了 CDI 分数的包含。后来，在手动示例中，Swarm 有一个包含检测到的分数、它们的依赖项以及始终需要的分数的构建服务。如果您现在运行该服务，您会注意到它确实正在正确工作。
- en: In order to understand why Swarm behaved in the described way in the recent
    examples, we must learn about fraction detection mode. Let's do it now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Swarm 在最近示例中的行为，我们必须了解分数检测模式。现在让我们来做这件事。
- en: Fraction detection mode
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数检测模式
- en: 'Swarm Maven plugin can work in different fraction detection modes. If you do
    not provide fraction dependencies manually, it runs in the when-missing mode.
    We have already seen the behavior of this mode in our previous examples: when
    no direct fraction dependency is provided, the plugin performs auto-detection.
    On the other hand, if we provide at least one fraction dependency manually, the
    auto-detection mode is turned off. This is the reason why our last example wasn''t
    built with the CDI fraction included: adding the JAX-RS fraction manually turned
    auto-detection off.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm Maven 插件可以在不同的分数检测模式下工作。如果您没有手动提供分数依赖项，它将在当缺失模式下运行。我们已经在之前的示例中看到了这种模式的行为：当没有直接提供分数依赖项时，插件会执行自动检测。另一方面，如果我们至少手动提供了一个分数依赖项，则自动检测模式将关闭。这就是为什么我们的最后一个示例没有包含
    CDI 分数的原因：手动添加 JAX-RS 分数关闭了自动检测。
- en: 'Is there something we can do about it? Yup, we can use a different detection
    mode: `force`. This mode makes auto-detection work every time. After detecting
    the fractions that are used, it merges the detection result with fractions configured
    by the user.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能对此做些什么吗？是的，我们可以使用不同的检测模式：`force`。此模式使自动检测每次都工作。在检测到使用的分数后，它将检测结果与用户配置的分数合并。
- en: 'Example reference: `chapter3/catalog-service-force-detect`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-force-detect`.
- en: 'Let''s reconfigure our example to make it work:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新配置我们的示例以使其工作：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, only the JAX-RS fraction is configured (1); however, because we have
    configured the Maven plugin with the `force` detection mode (2), Swarm will also
    detect the previously missing CDI fraction. If we run our application again, we
    will see that all necessary fractions were detected and the application works
    correctly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，只配置了 JAX-RS 分数（1）；然而，因为我们已经使用 `force` 检测模式配置了 Maven 插件（2），Swarm 也会检测之前缺失的
    CDI 分数。如果我们再次运行我们的应用程序，我们会看到所有必要的分数都被检测到，并且应用程序可以正常工作。
- en: 'We have seen two fraction detection modes: when-missing and `force`. Is there
    another? Yes, there is one more: *never*. In this mode, as its name implies, the
    fractions are never detected, and you always have to provide all of them manually.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种分数检测模式：当缺失和 `force`。还有其他吗？是的，还有一个：*never*。在此模式下，正如其名称所暗示的，分数永远不会被检测到，您必须始终手动提供所有这些。
- en: Thin and hollow JARs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 薄的和空壳 JAR
- en: As we said before, during the standard Maven plugin operation, the resulting
    application contains both the Swarm server and the application that is deployed
    on it. We can change that behavior. Let's suppose that we deploy our application
    in the cloud and later push new changes to its code. Since it is the application
    code that changes in most cases, we would like to create the container with the
    server in the cloud and later push only code to it. How are we able to do it?
    By using hollow JARs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，在标准的 Maven 插件操作期间，生成的应用程序包含 Swarm 服务器和部署在其上的应用程序。我们可以改变这种行为。让我们假设我们将应用程序部署在云中，然后稍后推送新的代码更改。由于大多数情况下是应用程序代码发生变化，我们希望创建一个包含服务器的容器，并将其部署在云中，然后只推送代码到它。我们如何做到这一点？通过使用空壳
    JAR。
- en: Using hollow JARs
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空壳 JAR
- en: You are able to configure the Maven plugin to build hollow JARs, which contain
    the swarm server without the actual application deployed on it. Let's return to
    the JAX-RS + CDI example again to show how it works.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 Maven 插件来构建空壳 JAR，其中包含 swarm 服务器，但上面没有实际部署的应用程序。让我们再次回到 JAX-RS + CDI 示例，以展示它是如何工作的。
- en: 'Example reference: `chapter3/catalog-service-hollow-jar`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-hollow-jar`.
- en: 'The first thing that we will need to do is configure the Maven plugin:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是配置 Maven 插件：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The only thing that we have to do is to enable the hollow configuration parameter
    (1). When we build the application and navigate to our target directory, we will
    see the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要做的就是启用空心配置参数（1）。当我们构建应用程序并导航到目标目录时，我们将看到以下输出：
- en: '![](img/3f141a9c-0e43-4481-9f56-334cdca95fd9.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f141a9c-0e43-4481-9f56-334cdca95fd9.png)'
- en: 'As you can see in the preceding screenshot, one directory ends with the `-hollow-swarm`
    suffix. This is our hollow jar without the deployed application. When running
    it, we must provide the name of the application that we will deploy on the created
    server. We will be able to do it in the following way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，一个目录以 `-hollow-swarm` 后缀结尾。这是我们不带部署应用程序的空心 JAR。在运行它时，我们必须提供将要部署在创建的服务器上的应用程序名称。我们将会以下这种方式做到：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will start the container and run our application. As a result, it will
    behave in the same way as the original example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动容器并运行我们的应用程序。结果，它将以与原始示例相同的方式运行。
- en: Using thin JARs
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用瘦 JAR
- en: You will be able to create a thin JAR. A thin JAR does not contain its Maven
    dependencies and loads them during application startup from a local or remote
    Maven repository.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够创建一个瘦 JAR。瘦 JAR 不包含其 Maven 依赖项，并在应用程序启动期间从本地或远程 Maven 仓库加载它们。
- en: 'Example reference: `chapter3/catalog-service-thin-jar`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter3/catalog-service-thin-jar`。
- en: 'Let''s take a look at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we build the application and look at the target directory, we get the
    following result:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建应用程序并查看目标目录时，我们得到以下结果：
- en: '![](img/793ebc5f-22ea-4c9b-8931-51db0c9871c8.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/793ebc5f-22ea-4c9b-8931-51db0c9871c8.png)'
- en: Note that in the preceding scenario, all the JARs are very small with the runnable
    JAR of `744` KB.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的场景中，所有的 JAR 文件都非常小，可运行的 JAR 文件大小为 `744` KB。
- en: 'You also have the possibility to mix thin JARs with hollow JARs. The runnable
    JAR does not contain the application that has to be deployed on it, so it has
    to be run in the same way as in the preceding example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有可能将瘦 JAR 与空心 JAR 混合。可运行的 JAR 不包含必须部署在其上的应用程序，因此它必须以与前面示例相同的方式运行：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both the server and the deployment do not contain bundled dependencies, so they
    have to be loaded from the Maven repository using the application deployment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和部署都不包含捆绑的依赖项，因此它们必须通过应用程序部署从 Maven 仓库加载。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how Swarm creates runnable, right-sized services.
    You learned what a fraction is, how the fraction detection process looks, and
    how you can modify it. Finally, you learned how to create hollow and thin JARs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了 Swarm 如何创建可运行、大小合适的服务。您学习了什么是分数，分数检测过程是什么样的，以及您如何修改它。最后，您学习了如何创建空心和瘦
    JAR。
- en: In the next chapter, we will show you how to configure your microservices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何配置您的微服务。
