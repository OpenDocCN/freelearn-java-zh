<html><head></head><body>
  <div id="_idContainer136" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-70" class="chapterTitle">Testing Your Backend</h1>
    <p class="normal">This chapter explains how to test your Spring Boot backend. The backend of an application is responsible for handling business logic and data storage. Proper testing of the backend ensures that the application works as intended, is secure, and is easier to maintain. We will create some unit and integration tests in relation to our backend, using the database application that we created earlier as a starting point.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Testing in Spring Boot</li>
      <li class="bulletList">Creating test cases</li>
      <li class="bulletList">Test-driven development</li>
    </ul>
    <h1 id="_idParaDest-71" class="heading-1">Technical requirements</h1>
    <p class="normal">The Spring Boot application that we created in the previous chapters is required.</p>
    <p class="normal">The following GitHub link will also be required: <a href="https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter06"><span class="url">https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter06</span></a>.</p>
    <h1 id="_idParaDest-72" class="heading-1">Testing in Spring Boot</h1>
    <p class="normal">The Spring Boot test starter package<a id="_idIndexMarker263"/> is automatically<a id="_idIndexMarker264"/> added to the <code class="inlineCode">build.gradle</code> file by <strong class="keyWord">Spring Initializr</strong> when we create our project. The test starter dependency can be seen in the following snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">testImplementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span>
</code></pre>
    <p class="normal">The Spring Boot test<a id="_idIndexMarker265"/> starter provides<a id="_idIndexMarker266"/> lots of handy libraries for testing, such as <strong class="keyWord">JUnit</strong>, <strong class="keyWord">Mockito</strong>, and <strong class="keyWord">AssertJ</strong>. Mockito is a mocking framework<a id="_idIndexMarker267"/> that is often<a id="_idIndexMarker268"/> used alongside testing frameworks like JUnit. AssertJ<a id="_idIndexMarker269"/> is a popular library<a id="_idIndexMarker270"/> for writing assertions in Java testing. In this book, we will use <strong class="keyWord">JUnit 5</strong>. The <strong class="keyWord">JUnit Jupiter</strong> module is part of JUnit 5 and provides annotations for more flexible testing.</p>
    <p class="normal">If you take a look at your project structure, you’ll see that it already has its own package created for test classes:</p>
    <figure class="mediaobject">­<img src="../Images/B19818_06_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.1: Test classes</p>
    <p class="normal">By default, Spring Boot uses an in-memory<a id="_idIndexMarker271"/> database for testing. We are using <strong class="keyWord">MariaDB</strong> at this point in the book, but we can use H2 for testing if we add the following dependency to the <code class="inlineCode">build.gradle</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">testRuntimeOnly <span class="hljs-string">'com.h2database:h2'</span>
</code></pre>
    <p class="normal">This specifies that the H2 database will only be used to run tests; otherwise, the application will use the MariaDB<a id="_idIndexMarker272"/> database.</p>
    <div class="packt_tip">
      <p class="normal">Remember to refresh your Gradle project in Eclipse after you have updated the <code class="inlineCode">build.gradle</code> file.</p>
    </div>
    <p class="normal">Now, we can start to create test cases for our application.</p>
    <h1 id="_idParaDest-73" class="heading-1">Creating test cases</h1>
    <p class="normal">There are many different types<a id="_idIndexMarker273"/> of software tests, and each has its own specific objectives. Some of the most important test types are:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Unit tests</strong>: Unit tests focus on the smallest<a id="_idIndexMarker274"/> component of software. This could be, for example, a function, and a unit test will ensure that it works correctly <em class="italic">in isolation</em>. <strong class="keyWord">Mocking</strong> is often used in unit testing<a id="_idIndexMarker275"/> to replace the dependencies of the unit that is being tested.</li>
      <li class="bulletList"><strong class="keyWord">Integration tests</strong>: Integration tests focus on the interaction<a id="_idIndexMarker276"/> between individual components, ensuring that individual components work together as expected.</li>
      <li class="bulletList"><strong class="keyWord">Functional tests</strong>: Functional testing focuses on business<a id="_idIndexMarker277"/> scenarios that are defined in functional specifications. Test cases are designed to verify that software meets the specified requirements.</li>
      <li class="bulletList"><strong class="keyWord">Regression tests</strong>: Regression tests are designed to verify<a id="_idIndexMarker278"/> that new code or code updates do not break existing functionality.</li>
      <li class="bulletList"><strong class="keyWord">Usability tests</strong>: Usability tests verify that software<a id="_idIndexMarker279"/> is user-friendly, intuitive, and easy to use from an end-user perspective. Usability tests focus more on the frontend and user experience.</li>
    </ul>
    <p class="normal">For unit and integration<a id="_idIndexMarker280"/> testing, we are using <strong class="keyWord">JUnit</strong>, a popular Java-based unit testing library. Spring Boot has built-in support for JUnit, making it easy to write tests for your application.</p>
    <p class="normal">The following source code shows an example skeleton for the Spring Boot test class. The <code class="inlineCode">@SpringBootTest</code> annotation specifies that the class is a regular test class that runs Spring Boot-based tests. The <code class="inlineCode">@Test</code> annotation before the method specifies to JUnit that the method can be run as a test case:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-meta-slc">@SpringBootTest</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTestsClass</span> {
    <span class="code-highlight"><strong class="hljs-meta-slc">@Test</strong></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Test case code</span>
    }
}
</code></pre>
    <p class="normal"><strong class="keyWord">Assertions</strong> in unit testing are statements<a id="_idIndexMarker281"/> that can be used to verify whether the actual output of a code unit matches the expected output. In our case, the assertions are implemented using the <strong class="keyWord">AssertJ</strong> library that the <code class="inlineCode">spring-boot-starter-test</code> artifact automatically<a id="_idIndexMarker282"/> includes. The AssertJ library provides an <code class="inlineCode">assertThat()</code> method that you can use to write assertions. You pass an object or a value to the method, allowing you to compare values with the actual assertions. The AssertJ library contains multiple assertions for different data<a id="_idIndexMarker283"/> types. The next sample demonstrates some example assertions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// String assertion</span>
assertThat(<span class="hljs-string">"Learn Spring Boot"</span>).startsWith(<span class="hljs-string">"</span><span class="hljs-string">Learn"</span>);
<span class="hljs-comment">// Object assertion</span>
assertThat(myObject).isNotNull();
<span class="hljs-comment">// Number assertion</span>
assertThat(myNumberVariable).isEqualTo(<span class="hljs-number">3</span>);
<span class="hljs-comment">// Boolean assertion</span>
assertThat(myBooleanVariable).isTrue();
</code></pre>
    <div class="note">
      <p class="normal">You can find all the different assertions<a id="_idIndexMarker284"/> in the AssertJ documentation: <a href="https://assertj.github.io/doc"><span class="url">https://assertj.github.io/doc</span></a>.</p>
    </div>
    <p class="normal">We will now create our initial unit test case, which checks that our controller instance is correctly instantiated and is not <code class="inlineCode">null</code>. Proceed as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open the <code class="inlineCode">CardatabaseApplicationTests</code> test class that has already been made for your application by the Spring Initializr starter project. There is one test method called <code class="inlineCode">contextLoads</code> in here, and this is where we will add the test. Write the following test, which checks that the instance of the controller was created and injected successfully. We use an AssertJ assertion to test that the injected controller instance is not <code class="inlineCode">null</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.assertj.core.api.Assertions.assertThat;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span class="hljs-keyword">import</span> com.packt.cardatabase.web.CarController;
<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CardatabaseApplicationTests</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> CarController controller;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> {
        assertThat(controller).isNotNull();
    }
}
</code></pre>
    <div class="note">
      <p class="normal">We use <strong class="keyWord">field injection</strong> here, which is well-suited <a id="_idIndexMarker285"/>for test classes<a id="_idIndexMarker286"/> because you will never instantiate your test classes directly. You can read more about dependency injection of test fixtures in the Spring documentation: <a href="https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/fixture-di.html"><span class="url">https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/fixture-di.html</span></a>.</p>
    </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">To run tests in Eclipse, activate the test class in the <strong class="screenText">Project Explorer</strong> and right-click. Select <strong class="screenText">Run As | JUnit test</strong> from the menu. You should now see the <strong class="screenText">JUnit</strong> tab in the lower part of the Eclipse workbench. The test results are shown in this tab, and the test case has been passed, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_06_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.2: JUnit test run</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">You can use the <code class="inlineCode">@DisplayName</code> annotation to give a more descriptive name to your test case. The name defined in the <code class="inlineCode">@DisplayName</code> annotation is shown in the JUnit test runner. The code is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="code-highlight"><strong class="hljs-meta-slc">@DisplayName("First example test case")</strong></span>
<span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> {
    assertThat(controller).isNotNull();
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Now, we will create integration<a id="_idIndexMarker287"/> tests for our owner repository to test <strong class="keyWord">create</strong>, <strong class="keyWord">read</strong>, <strong class="keyWord">update</strong>, and <strong class="keyWord">delete</strong> (<strong class="keyWord">CRUD</strong>) operations. This test verifies that our repository interacts correctly with a database. The idea is to simulate database interactions and verify that your repository methods<a id="_idIndexMarker288"/> behave as expected:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new class called <code class="inlineCode">OwnerRepositoryTest</code> in the root test package. Instead of the <code class="inlineCode">@SpringBootTest</code> annotation, the <code class="inlineCode">@DataJpaTest</code> annotation can be used if the test is focused on <strong class="keyWord">Jakarta Persistence API</strong> (<strong class="keyWord">JPA</strong>) components. When using this annotation, the H2 database<a id="_idIndexMarker289"/> and Spring Data are automatically configured for testing. SQL logging is also turned on. The code is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.assertj.core.api.Assertions.assertThat;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
<span class="hljs-keyword">import</span> com.packt.cardatabase.domain.Owner;
<span class="hljs-keyword">import</span> com.packt.cardatabase.domain.OwnerRepository;
<span class="hljs-meta">@DataJpaTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">OwnerRepositoryTest</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OwnerRepository repository;
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">In this example, we use the root package for all test classes and name our classes logically. Alternatively, you can create a similar package structure for your test classes as we did for our application classes.</p>
    </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">We will add our first test case to test the addition of a new owner to the database. Add the following query to your <code class="inlineCode">OwnerRepository.java</code> file. We will use this query in our test case:
        <pre class="programlisting code"><code class="hljs-code">Optional&lt;Owner&gt; <span class="hljs-title">findByFirstname</span><span class="hljs-params">(String firstName)</span>;
</code></pre>
      </li>
      <li class="numberedList">A new <code class="inlineCode">Owner</code> object is created and saved to the database using the <code class="inlineCode">save</code> method. Then, we check that the owner can be found. Add the following test case method code to your <code class="inlineCode">OwnerRepositoryTest</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">saveOwner</span><span class="hljs-params">()</span> {
    repository.save(<span class="hljs-keyword">new</span> <span class="hljs-title">Owner</span>(<span class="hljs-string">"Lucy"</span>, <span class="hljs-string">"Smith"</span>));
    assertThat(
        repository.findByFirstname(<span class="hljs-string">"Lucy"</span>).isPresent()
    ).isTrue();
}
</code></pre>
      </li>
      <li class="numberedList">The second test case<a id="_idIndexMarker290"/> will test the deletion of the owner from the database. A new <code class="inlineCode">Owner</code> object is created and saved to the database. Then, all owners are deleted from the database, and finally, the <code class="inlineCode">count()</code> method should return zero. The following source code shows the test case method. Add the following method code to your <code class="inlineCode">OwnerRepositoryTest</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">deleteOwners</span><span class="hljs-params">()</span> {
    repository.save(<span class="hljs-keyword">new</span> <span class="hljs-title">Owner</span>(<span class="hljs-string">"Lisa"</span>, <span class="hljs-string">"Morrison"</span>));
    repository.deleteAll();
    assertThat(repository.count()).isEqualTo(<span class="hljs-number">0</span>);
}
</code></pre>
      </li>
      <li class="numberedList">Run the test cases and check the Eclipse <strong class="screenText">JUnit</strong> tab to find out whether the tests passed. The following screenshot shows that they have indeed passed:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_06_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.3: Repository test cases</p>
    <p class="normal">Next, we will demonstrate how to test your RESTful web service JWT authentication functionality. We will create an integration test that sends an actual HTTP request to the login endpoint and verifies the response:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new<a id="_idIndexMarker291"/> class called <code class="inlineCode">CarRestTest</code> in the root test package. To test the controllers or any endpoint that is exposed, we can use a <code class="inlineCode">MockMvc</code> object. By using the <code class="inlineCode">MockMvc</code> object, the server is not started, but the tests are performed in the layer where Spring handles HTTP requests, and therefore it mocks the real situation. <code class="inlineCode">MockMvc</code> provides the <code class="inlineCode">perform</code> method to send these requests. To test authentication, we have to add credentials to the request body. We print request and response details to the console using the <code class="inlineCode">andDo()</code> method. Finally, we check that the response status is <code class="inlineCode">Ok</code> using the <code class="inlineCode">andExpect()</code> method. The code is illustrated in the following snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> com.packt.cardatabase;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.
request.MockMvcRequestBuilders.post;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.
servlet.result.MockMvcResultHandlers.print;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span class="hljs-keyword">import</span> org.springframework.http.HttpHeaders;
<span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;
<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@AutoConfigureMockMvc</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CarRestTest</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> MockMvc mockMvc;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAuthentication</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// Testing authentication with correct credentials</span>
        <span class="hljs-built_in">this</span>.mockMvc
            .perform(post(<span class="hljs-string">"/login"</span>)
            .content(<span class="hljs-string">"{\"username\":\"admin\",\"password\""</span>
<span class="hljs-string">                     +":\"</span>admin\<span class="hljs-string">"}"</span>)
            .header(HttpHeaders.CONTENT_TYPE,<span class="hljs-string">"application/json"</span>))
            .andDo(print()).andExpect(status().isOk());
    }
}
</code></pre>
      </li>
      <li class="numberedList">Now, when we run the authentication tests, we will see that the test passes, as the following screenshot confirms:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_06_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.4: Login test</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">You can run all tests<a id="_idIndexMarker292"/> at once by selecting the test package from the Project Explorer and running the JUnit tests (<strong class="screenText">Run As</strong> | <strong class="screenText">JUnit test</strong>). In the image below, you can see the result when all test cases have been passed:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_06_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.5: Running tests</p>
    <h2 id="_idParaDest-74" class="heading-2">Testing with Gradle</h2>
    <p class="normal">All tests run automatically<a id="_idIndexMarker293"/> when you build your project using Gradle. We will go into more detail about building and deployment later in this book. In this section, we will only cover some basics:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">You can run different predefined Gradle tasks using Eclipse. Open the <strong class="screenText">Window | Show View | Other… </strong>Menu. That opens the <strong class="screenText">Show View</strong> window, where you should select <strong class="screenText">Gradle Tasks</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19818_06_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.6: Gradle tasks</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">You should see the list <a id="_idIndexMarker294"/>of Gradle tasks, as shown in the following image. Open the <code class="inlineCode">build</code> folder and double-click the <strong class="screenText">build</strong> task to run it:
    <figure class="mediaobject"><img src="../Images/B19818_06_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.7: Build task</p>
    <p class="normal">The Gradle build task creates a <code class="inlineCode">build</code> folder in your project, where your Spring Boot project is built. The build process runs all the tests from your project. If any of the tests fail, the build process also fails. The build process creates a test summary report (an <code class="inlineCode">index.html</code> file), which you can find in the <code class="inlineCode">build\reports\tests\test</code> folder. If any of your tests fail, you can find the reason from the summary report. In the image below, you can see an example of a test summary<a id="_idIndexMarker295"/> report:</p>
    <figure class="mediaobject"><img src="../Images/B19818_06_08.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 6.8: Test summary</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">The build task creates an executable <code class="inlineCode">jar</code> file in the <code class="inlineCode">\build\libs</code> folder. You can now run your built Spring Boot application using the following command in the <code class="inlineCode">\build\libs</code> folder (you should have the JDK installed):
        <pre class="programlisting con"><code class="hljs-con">java -jar .\cardatabase-0.0.1-SNAPSHOT.jar
</code></pre>
      </li>
    </ol>
    <p class="normal">Now, you can write unit<a id="_idIndexMarker296"/> and integration tests for your Spring Boot application. You have also learned how to run tests using the Eclipse IDE.</p>
    <h1 id="_idParaDest-75" class="heading-1">Test-driven development</h1>
    <p class="normal"><strong class="keyWord">Test-driven development</strong> (<strong class="keyWord">TDD</strong>) is a practice in software development<a id="_idIndexMarker297"/> where you write tests before writing the actual code. The idea is to ensure that your code meets the criteria or requirements that are set. Let’s see one example of how TDD works in practice.</p>
    <p class="normal">Our goal is to implement a service class that manages messages in our application. You can see the common steps of TDD below:</p>
    <div class="note">
      <p class="normal">The following code is not fully functioning. It is just an example for you to get a better idea of the TDD process.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The first functionality to be implemented<a id="_idIndexMarker298"/> is a service that can be used to add new messages. Therefore, in TDD, we will create a test for adding new messages to a list of messages. In the test code, we first create an instance of the message service class. Then, we create a test message that we want to add to the list. We call the <code class="inlineCode">addMsg</code> method of the <code class="inlineCode">messageService</code> instance, passing the <code class="inlineCode">msg</code> as an argument. This method is responsible for adding messages to a list. Finally, the assertion checks if the message added to the list matches the expected message, <code class="inlineCode">"Hello world"</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;
<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageServiceTest</span> {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddMessage</span><span class="hljs-params">()</span> {
        <span class="hljs-type">MessageService</span> <span class="hljs-variable">messageService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new </span><span class="hljs-title">MessageService</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello world"</span>;
        <span class="hljs-type">Message</span> <span class="hljs-variable">newMsg</span> <span class="hljs-operator">=</span> messageService.addMsg(msg);
        assertEquals(msg, newMsg.getMessage());
    }
}
</code></pre>
      </li>
      <li class="numberedList">Now, we can run the test. It should fail because we haven’t implemented our service yet.</li>
      <li class="numberedList">Next, we will implement the <code class="inlineCode">MessageService</code>, which should contain the <code class="inlineCode">addMsg()</code> function that we are testing in our test case:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> {
    <span class="hljs-keyword">private</span> List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">public</span> Message <span class="hljs-title">addMsg</span><span class="hljs-params">(String msg)</span> {
        <span class="hljs-type">Message</span> <span class="hljs-variable">newMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Message</span>(msg);
        messages.add(newMSg);
        <span class="hljs-keyword">return</span> newMsg;
    }
}
</code></pre>
      </li>
      <li class="numberedList">Now, if you run the test again, it should pass if your code works as expected.</li>
      <li class="numberedList">If the test does not pass, you should refactor your code until it does.</li>
      <li class="numberedList">Repeat these steps for each new feature.</li>
    </ol>
    <p class="normal">TDD is an iterative process that helps to ensure that your code works and that new features don’t break<a id="_idIndexMarker299"/> other parts of the software. This is also called <strong class="keyWord">regression testing</strong>. By writing a test before implementing the functionality, we can catch bugs early in the development phase. Developers should understand feature requirements and expected outcomes before actual development.</p>
    <p class="normal">At this point, we have covered<a id="_idIndexMarker300"/> the basics of testing in Spring Boot applications, and you have gained the knowledge you need to implement more test cases for your applications.</p>
    <h1 id="_idParaDest-76" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we focused on testing the Spring Boot backend. We used JUnit for testing and implemented test cases for JPA and RESTful web service authentication. We created one test case for our owner repository to verify that repository methods behave as expected. We also tested the authentication process by using our RESTful API. Remember that testing is an ongoing process throughout the development life cycle. You should update and add tests to cover new features and changes when your application evolves. Test-driven development is one way of doing this.</p>
    <p class="normal">In the next chapter, we will set up the environment and tools related to frontend development.</p>
    <h1 id="_idParaDest-77" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">How can you create unit tests with Spring Boot?</li>
      <li class="numberedList">What is the difference between unit and integration tests?</li>
      <li class="numberedList">How can you run and check the results of unit tests?</li>
      <li class="numberedList">What is TDD?</li>
    </ol>
    <h1 id="_idParaDest-78" class="heading-1">Further reading</h1>
    <p class="normal">There are many other good resources available to learn about Spring Security and testing. A few are listed here:</p>
    <ul>
      <li class="bulletList"><em class="italic">JUnit and Mockito Unit Testing for Java Developers</em>, by Matthew Speake (<a href="https://www.packtpub.com/product/junit-and-mockito-unit-testing-for-java-developers-video/9781801078337"><span class="url">https://www.packtpub.com/product/junit-and-mockito-unit-testing-for-java-developers-video/9781801078337</span></a>)</li>
      <li class="bulletList"><em class="italic">Mastering Software Testing with JUnit 5</em>, by Boni García (<a href="https://www.packtpub.com/product/mastering-software-testing-with-junit-5/9781787285736"><span class="url">https://www.packtpub.com/product/mastering-software-testing-with-junit-5/9781787285736</span></a>)</li>
      <li class="bulletList"><em class="italic">Java Programming MOOC: Introduction to testing</em>, by the University of Helsinki (<a href="https://java-programming.mooc.fi/part-6/3-introduction-to-testing"><span class="url">https://java-programming.mooc.fi/part-6/3-introduction-to-testing</span></a>)</li>
      <li class="bulletList"><em class="italic">Master Java Unit Testing with Spring Boot and Mockito</em>, by In28Minutes Official (<a href="https://www.packtpub.com/product/master-java-unit-testing-with-spring-boot-and-mockito-video/9781789346077"><span class="url">https://www.packtpub.com/product/master-java-unit-testing-with-spring-boot-and-mockito-video/9781789346077</span></a>)</li>
    </ul>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask the author questions, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/FullStackSpringBootReact4e"><span class="url">https://packt.link/FullStackSpringBootReact4e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code10796108009382640.png" alt="" role="presentation"/></p>
  </div>
</body></html>