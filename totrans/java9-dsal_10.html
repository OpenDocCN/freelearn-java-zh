<html><head></head><body>
<div class="book" title="Chapter&#xA0;10.&#xA0;Concepts of Graph" id="1P71O1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Concepts of Graph</h1></div></div></div><p class="calibre8">A graph is a generalization of a tree. In a tree, every node has one parent. In a graph, a node can have multiple parents. The most common way to think about a graph is as a set of vertices and edges. Vertices are like points and edges are like lines that connect the points. In the generic notion of a graph, there is no restriction on which vertices can be connected by edges. This allows graphs to model a versatile category of real-life concepts. The Internet, for example, is a graph where the vertices are the web pages and the edges the hyperlinks between the pages. A social networking site, such as Facebook, has a graph of profiles in which the vertices are the profiles and the edges the friendships between the profiles. Each software has a graph of dependencies, called a dependency graph, in which the vertices are the different software libraries used and the edges the dependencies between the software libraries. There is no end to examples of graphs. In this chapter, we will discuss the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Different types of graphs</li><li class="listitem">The ADT graph </li><li class="listitem">Representation of graphs in memory</li><li class="listitem">Traversal of a graph</li><li class="listitem">Cycle detection</li><li class="listitem">Spanning trees</li><li class="listitem">Minimum spanning trees</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Concepts of Graph" id="1P71O1-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="What is a graph?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec53" class="calibre1"/>What is a graph?</h1></div></div></div><p class="calibre8">A graph is a collection of <a id="id464" class="calibre1"/>vertices and edges that connect the vertices. <span class="strong"><em class="calibre12">Figure 1</em></span> gives a visual representation of an example of a graph. There are a few features to note here, which we will discuss next:</p><div class="mediaobject"><img src="../images/00070.jpeg" alt="What is a graph?" class="calibre9"/><div class="caption"><p class="calibre15">Figure 1: Example of an undirected graph</p></div></div><p class="calibre10"> </p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Undirected graph</strong></span>: An <a id="id465" class="calibre1"/>undirected graph is a graph in which the <a id="id466" class="calibre1"/>edges have no direction, as shown in <span class="strong"><em class="calibre12">Figure 1</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Directed graph</strong></span>: This is a <a id="id467" class="calibre1"/>graph in which the edges <a id="id468" class="calibre1"/>have a direction.</li><li class="listitem"><span class="strong"><strong class="calibre2">Path</strong></span>: A path is a <a id="id469" class="calibre1"/>sequence of edges that connects a set of vertices that are distinct from one another, except the first and the last vertices as they may be the same. For example, in <span class="strong"><em class="calibre12">Figure 1</em></span>, the edges <span class="strong"><strong class="calibre2">AB</strong></span>, <span class="strong"><strong class="calibre2">BD</strong></span>, and <span class="strong"><strong class="calibre2">DE</strong></span> represent a path. It can also be described as the <span class="strong"><strong class="calibre2">ABDE</strong></span> path, which does not repeat its vertices. In the case of a directed graph, the edges must traverse only in the specified direction to form the sequence of edges required to make a path.</li><li class="listitem"><span class="strong"><strong class="calibre2">Cycle</strong></span>: A cycle is a <a id="id470" class="calibre1"/>path with at least two vertices involved; it starts and ends on the same vertex. For example, in <span class="strong"><em class="calibre12">Figure 1</em></span>, the path <span class="strong"><strong class="calibre2">DCED</strong></span> is a cycle.</li><li class="listitem"><span class="strong"><strong class="calibre2">Loop</strong></span>: A loop is an <a id="id471" class="calibre1"/>edge that connects a node to itself. In <span class="strong"><em class="calibre12">Figure 1</em></span>, vertex <span class="strong"><strong class="calibre2">A</strong></span> has a loop.</li><li class="listitem"><span class="strong"><strong class="calibre2">Subgraph</strong></span>: The subgraph of <a id="id472" class="calibre1"/>a graph is another type of graph where all the <a id="id473" class="calibre1"/>edges and vertices are the same as the edges and vertices of the original graph. For example, in <span class="strong"><em class="calibre12">Figure 1</em></span>, the nodes <span class="strong"><strong class="calibre2">A</strong></span>, <span class="strong"><strong class="calibre2">B</strong></span>, and <span class="strong"><strong class="calibre2">C</strong></span> along with the edges <span class="strong"><strong class="calibre2">AB</strong></span> and <span class="strong"><strong class="calibre2">BC</strong></span> represent a subgraph.</li><li class="listitem"><span class="strong"><strong class="calibre2">Connected graph</strong></span>: A <a id="id474" class="calibre1"/>connected graph is a graph in which there <a id="id475" class="calibre1"/>exists a path that starts from any arbitrary vertex and ends in any arbitrary, but different vertex. The graph in <span class="strong"><em class="calibre12">Figure 1</em></span> is not connected. But, the subgraph with vertices <span class="strong"><strong class="calibre2">H</strong></span>, <span class="strong"><strong class="calibre2">I</strong></span>, and <span class="strong"><strong class="calibre2">J</strong></span> and the edges <span class="strong"><strong class="calibre2">HI</strong></span>, <span class="strong"><strong class="calibre2">IJ</strong></span>, and <span class="strong"><strong class="calibre2">JH</strong></span> represent a connected subgraph:<div class="mediaobject"><img src="../images/00071.jpeg" alt="What is a graph?" class="calibre9"/><div class="caption"><p class="calibre15">Figure 2. Example directed graph</p></div></div><p class="calibre26"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Tree</strong></span>: A tree is a <a id="id476" class="calibre1"/>connected but undirected graph with no cycles and loops. <span class="strong"><em class="calibre12">Figure 3</em></span> shows an example of a tree. Note that this is slightly different from the tree we have studied earlier. This tree does not have any particular root. The nodes in this tree do not have any particular parent, and any node can act as a root:<div class="mediaobject"><img src="../images/00072.jpeg" alt="What is a graph?" class="calibre9"/><div class="caption"><p class="calibre15">Figure 3. Example tree</p></div></div><p class="calibre26"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Forest</strong></span>: A forest is an <a id="id477" class="calibre1"/>unconnected, undirected graph with no cycles or loops. You can think of a forest as a collection of trees. A single tree is also a forest. In other words, a forest is a collection of zero or more trees.</li><li class="listitem"><span class="strong"><strong class="calibre2">Complete graph</strong></span>: A <a id="id478" class="calibre1"/>complete graph is an undirected graph that has the maximum number of edges, given a certain number of vertices. It also has constraints as per which there can only be one edge between two given vertices, with no loops. <span class="strong"><em class="calibre12">Figure 4</em></span> shows an example of a complete graph. For a complete graph with the set of vertices <span class="strong"><em class="calibre12">V</em></span> and the set of edges <span class="strong"><em class="calibre12">E</em></span>, <span class="strong"><em class="calibre12">|E| = |V| ( |V| - 1) / 2</em></span>. It is easy to see why this is the case. Each vertex will have an edge between itself and other <span class="strong"><em class="calibre12">|V| - 1</em></span> nodes. That makes a total of <span class="strong"><em class="calibre12">|V| ( |V| - 1)</em></span> edges. However, in this approach, each edge is counted twice, once for each of its two vertices. So, the actual number of edges in a complete graph is <span class="strong"><em class="calibre12">|V| ( |V| - 1) / 2</em></span>:<div class="mediaobject"><img src="../images/00073.jpeg" alt="What is a graph?" class="calibre9"/><div class="caption"><p class="calibre15">Figure 4. A complete graph</p></div></div><p class="calibre26"> </p></li></ul></div></div></div>
<div class="book" title="The graph ADT" id="1Q5IA1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec54" class="calibre1"/>The graph ADT</h1></div></div></div><p class="calibre8">We will now define what <a id="id479" class="calibre1"/>a data structure representing a graph should do. Later, we will discuss the different implementations of this ADT. A graph must support the <a id="id480" class="calibre1"/>following operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Add Vertex</strong></span>: This adds a new vertex</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove Vertex</strong></span>: This removes a vertex</li><li class="listitem"><span class="strong"><strong class="calibre2">Add edge</strong></span>: This adds a new edge; in our graph, we will allow a maximum of one edge between two vertices for simplicity</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove edge</strong></span>: This removes an edge</li><li class="listitem"><span class="strong"><strong class="calibre2">Adjacent</strong></span>: This checks whether the two given vertices are adjacent to each other, that is, whether there is an edge between the given nodes</li><li class="listitem"><span class="strong"><strong class="calibre2">Neighbors</strong></span>: This returns a list of vertices that are adjacent to the given vertex</li><li class="listitem"><span class="strong"><strong class="calibre2">Get Vertex Value</strong></span>: This gets the value stored in a vertex</li><li class="listitem"><span class="strong"><strong class="calibre2">Set Vertex Value</strong></span>: This stores a value in a vertex</li><li class="listitem"><span class="strong"><strong class="calibre2">Get Edge Value</strong></span>: This gets the value stored in an edge</li><li class="listitem"><span class="strong"><strong class="calibre2">Set Edge Value</strong></span>: This sets the value stored in an edge</li><li class="listitem"><span class="strong"><strong class="calibre2">Is undirected</strong></span>: This returns whether the graph is undirected</li><li class="listitem"><span class="strong"><strong class="calibre2">Get all vertices</strong></span>: This returns a self-balancing binary search tree containing all the vertices</li><li class="listitem"><span class="strong"><strong class="calibre2">Max Vertex ID</strong></span>: This returns the highest ID of the vertices</li></ul></div><p class="calibre8">Our algorithms will depend on the above operations being available in a graph data structure. The following Java interface is a realization of this ADT:</p><div class="informalexample"><pre class="programlisting">public interface Graph&lt;V, E&gt; {
    int addVertex();
    void removeVertex(int id);
    void addEdge(int source, int target);
    void removeEdge(int source, int target);
    boolean isAdjacent(int source, int target);
    LinkedList getNeighbors(int source);
    void setVertexValue(int vertex, V value);
    V getVertexValue(int vertex);
    void setEdgeValue(int source, int target, E value);
    E getEdgeValue(int source, int target);
    boolean isUndirected();
    BinarySearchTree&lt;Integer&gt; getAllVertices();
    int maxVertexID();
}</pre></div><p class="calibre8">We identify each vertex by an ID; edges are identified by a source vertex and a target vertex. In the case of an undirected graph, the source and target could be interchanged. But, in the case of a directed graph, they are noninterchangeable.</p><p class="calibre8">Now that we have an ADT, we would like to have an implantation. To implement a graph data structure, we need <a id="id481" class="calibre1"/>to choose a representation in memory.</p></div>

<div class="book" title="Representation of a graph in memory"><div class="book" id="1R42S2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec55" class="calibre1"/>Representation of a graph in memory</h1></div></div></div><p class="calibre8">A graph can be represented <a id="id482" class="calibre1"/>mainly in three different ways: adjacency matrix, adjacency list, and incidence matrix.</p></div>

<div class="book" title="Representation of a graph in memory">
<div class="book" title="Adjacency matrix"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec74" class="calibre1"/>Adjacency matrix</h2></div></div></div><p class="calibre8">An adjacency matrix is a <a id="id483" class="calibre1"/>matrix, a table of values, where each value represents an <a id="id484" class="calibre1"/>edge and both the rows are the columns that represent the vertices. The values in a matrix can be the members of the entry. The values of the edges can be stored in the matrix itself. There could also be a special value for representing the absence of an edge. The following image shows an adjacency matrix for the graph in <span class="strong"><em class="calibre12">Figure 1</em></span>, where the value of the edge represents the number of edges between the corresponding vertices:</p><div class="mediaobject"><img src="../images/00074.jpeg" alt="Adjacency matrix" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The following things can be noted about an adjacency matrix:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Rows are used to represent the sources and columns to represent the targets of the edges</li><li class="listitem">In the case of an <a id="id485" class="calibre1"/>undirected graph, the source and target are indistinguishable, so the adjacency matrix is symmetric</li></ul></div><p class="calibre8">The following code <a id="id486" class="calibre1"/>provides an implementation of the graph ADT with the adjacency matrix. We use a two-dimensional array to store the matrix. The ID of any vertex is directly used as the index of the array. This is true for both the array to store the values stored within the vertices and the values stored in the edges, or even the existence of the edges. When we remove a vertex, we don't free its space; we do this so that the IDs of the newer vertices don't get shifted. This improves lookup performance but is wasteful in terms of resources:</p><div class="informalexample"><pre class="programlisting">public class AdjacencyMatrixGraphWithSparseVertex&lt;V,E&gt; implements Graph&lt;V, E&gt; {

    private static class NullEdgeValue{};</pre></div><p class="calibre8">We create two special objects to signify an edge and a vertex; these objects do not yet hold a value. A null reference refers to the edge or vertex that does not exist:</p><div class="informalexample"><pre class="programlisting">    private NullEdgeValue nullEdge = new NullEdgeValue();
    private NullEdgeValue nullVertex = new NullEdgeValue();

    Object [][] adjacencyMatrix = new Object[0][];
    Object[] vertexValues = new Object[0];</pre></div><p class="calibre8">A flag determines whether the graph is undirected:</p><div class="informalexample"><pre class="programlisting">    boolean undirected;

    public AdjacencyMatrixGraphWithSparseVertex(boolean undirected){
        this.undirected = undirected;
    }</pre></div><p class="calibre8">Adding a vertex involves creating a new matrix and an array of vertex values and copying all the older values into it:</p><div class="informalexample"><pre class="programlisting">    @Override
    public int addVertex() {
        int numVertices = adjacencyMatrix.length;
        Object [][] newAdjacencyMatrix = new Object[numVertices+1][];
        for(int i=0;i&lt;numVertices;i++){
            newAdjacencyMatrix[i] = new Object[numVertices+1];
            System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, numVertices);
        }
        newAdjacencyMatrix[numVertices] = new Object[numVertices+1];
        adjacencyMatrix = newAdjacencyMatrix;
        Object [] vertexValuesNew = new Object[vertexValues.length+1];
        System.arraycopy(vertexValues,0, vertexValuesNew, 0, vertexValues.length);
        vertexValuesNew[vertexValues.length] = nullVertex;
        vertexValues = vertexValuesNew;
        return numVertices;
    }</pre></div><p class="calibre8">Since we don't free any <a id="id487" class="calibre1"/>space, removing a vertex simply involves setting values to null. Note <a id="id488" class="calibre1"/>that removing a vertex has to be accompanied by the removal of all the associated edges, which is done in a loop:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeVertex(int id) {
        vertexValues[id] = null;
        for(int i=0;i&lt;adjacencyMatrix.length;i++){
            adjacencyMatrix[id][i] = null;
            adjacencyMatrix[i][id] = null;
        }
    }</pre></div><p class="calibre8">Adding an edge involves setting a particular position in the adjacency matrix. If the graph is undirected, there will be two updates. This is because the source and target could be interchanged and the adjacency matrix is always symmetric:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void addEdge(int source, int target) {
        if(adjacencyMatrix[source][target] == null){
            adjacencyMatrix[source][target] = nullEdge;
            if(undirected){
                adjacencyMatrix[target][source] = nullEdge;
            }
        }else{
            throw new IllegalArgumentException("Edge already exists");
        }
    }</pre></div><p class="calibre8">The following operation is the simplest of all as it involves setting only one edge to null. In the case of an undirected <a id="id489" class="calibre1"/>graph, there would be a corresponding update that would interchange the source and target:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeEdge(int source, int target) {
        adjacencyMatrix[source][target] = null;
        if(undirected){
            adjacencyMatrix[target][source] = null;
        }
    }</pre></div><p class="calibre8">The following is a trivial <a id="id490" class="calibre1"/>operation of checking the adjacency matrix:</p><div class="informalexample"><pre class="programlisting">    @Override
    public boolean isAdjacent(int source, int target) {
        return adjacencyMatrix[source][target] != null;
    }</pre></div><p class="calibre8">For any given source, find all the edges in the same row of the matrix and add them to a linked list that we can return. Note that in a directed graph, it traverses the edges only in the forward direction:</p><div class="informalexample"><pre class="programlisting">    @Override
    public LinkedList getNeighbors(int source) {
        LinkedList&lt;Integer&gt; neighborList = new LinkedList&lt;&gt;();
        for(int i=0;i&lt;adjacencyMatrix.length;i++){
            if(adjacencyMatrix[source][i]!=null){
                neighborList.appendLast(i);
            }
        }
        return neighborList;
    }</pre></div><p class="calibre8">We store all the values of the vertices in a different array:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void setVertexValue(int vertex, V value) {
        vertexValues[vertex] = value;
    }

    @Override
    public V getVertexValue(int vertex) {
        if(vertexValues[vertex]!=nullVertex)
            return (V)vertexValues[vertex];
        else
            throw new IllegalArgumentException("Vertex "+vertex
                 +" does not exist");
    }</pre></div><p class="calibre8">The values stored in the <a id="id491" class="calibre1"/>edges can be stored in the adjacency <a id="id492" class="calibre1"/>matrix itself:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void setEdgeValue(int source, int target, E value) {
        adjacencyMatrix[source][target] = value;
        if(undirected){
            adjacencyMatrix[target][source] = value;
        }
    }

    @Override
    public E getEdgeValue(int source, int target) {
        if(adjacencyMatrix[source][target] != nullEdge) {
            return (E) adjacencyMatrix[source][target];
        }else {
            return null;
        }
    }

@Override
    public boolean isUndirected() {
        return undirected;
    }

    @Override
    public BinarySearchTree&lt;Integer&gt; getAllVertices() {
        BinarySearchTree&lt;Integer&gt; allVertices = new RedBlackTree&lt;&gt;();
        for(int i=0;i&lt;vertexValues.length;i++){
            if(vertexValues[i]!=null){
                allVertices.insertValue(i);
            }
        }
        return allVertices;
    }

    @Override
    public int maxVertexID() {
        return vertexValues.length-1;
    }
}</pre></div><div class="book" title="Complexity of operations in a sparse adjacency matrix graph"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec21" class="calibre1"/>Complexity of operations in a sparse adjacency matrix graph</h3></div></div></div><p class="calibre8">Now <a id="id493" class="calibre1"/>let's analyze the complexity of the operations we have already discussed:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Add vertex</strong></span>: Adding a vertex requires us to create a new two-dimensional array with length and w the complexities of the idth <span class="strong"><em class="calibre12">|V|</em></span> and then copy the entire old content to the new array. Here, <span class="strong"><em class="calibre12">|V|</em></span> represents the cardinality of the set <span class="strong"><em class="calibre12">V</em></span> of the vertices. What is the size of the adjacency matrix then? It's a square matrix whose length or width equals <span class="strong"><em class="calibre12">|V|</em></span>, so its size is <span class="strong"><em class="calibre12">|V|</em></span><sup class="calibre14">2</sup>. Hence, adding a new edge has this complexity: <span class="strong"><em class="calibre12">θ(|V|</em></span><sup class="calibre14">2</sup><span class="strong"><em class="calibre12">)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove Vertex</strong></span>: Removing a vertex involves removing all the edges that correspond to the given vertex. The maximum number of edges that can be associated with a single vertex is <span class="strong"><em class="calibre12">|V|</em></span>, which is the length of a row or column in the adjacency matrix. We must set all the values in the row and column containing the vertex being deleted, so the number of values that need to be changed is calculated as <span class="strong"><em class="calibre12">2|V| - 1</em></span>. The "minus one" part comes from the fact that the row and column have one edge in common, the edge representing a loop on the node that is being deleted. The common edge is counted twice, both in the row and the column. So one of them must be stopped. Therefore, the complexity of this operation is <span class="strong"><em class="calibre12">θ(2|V|  - 1) = θ(|V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Add edge and Remove edge</strong></span>: Adding an edge is as simple as setting a special value at a single entry in the adjacency matrix. It has this complexity: <span class="strong"><em class="calibre12">θ(1)</em></span>. Removing an edge is just setting null at the same position.</li><li class="listitem"><span class="strong"><strong class="calibre2">Adjacent</strong></span>: This operation involves checking whether an edge exists between the given source and target. It checks one entry in the adjacency matrix, hence this complexity: <span class="strong"><em class="calibre12">θ(1)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Neighbors</strong></span>: This operation requires reading all the values in the row of an adjacency <a id="id494" class="calibre1"/>matrix. So it requires reading <span class="strong"><em class="calibre12">|V|</em></span> values and possibly adding them to a linked list. Therefore, the complexity of this operation is <span class="strong"><em class="calibre12">θ( |V| )</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and getting values at vertices and edges</strong></span>: These operations require reading/setting a single value into/from the adjacency matrix. These operations are all <span class="strong"><em class="calibre12">θ(1)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Get all vertices</strong></span>: This involves scanning through all the vertices and inserting them in a binary search tree. So this operation is <span class="strong"><em class="calibre12">θ( |V|  lg |V|)</em></span>.</li></ul></div></div></div></div>

<div class="book" title="Representation of a graph in memory">
<div class="book" title="More space-efficient adjacency-matrix-based graph"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec75" class="calibre1"/>More space-efficient adjacency-matrix-based graph</h2></div></div></div><p class="calibre8">The trouble with <a id="id495" class="calibre1"/>the above graph implementation is that we are unable to recover any space when vertices are deleted. The problem with recovering space is that it changes the indexes of the vertices that are <a id="id496" class="calibre1"/>added later. To avoid this, we can choose to have an ID of a vertex that is separate from its index position in the arrays. If we do this, we need to be able to search the index of a vertex with the given ID. This mapping can be done with a self-balancing binary search tree, which is what we are going to do here.</p><p class="calibre8">First, we create a separate class that represents a graph vertex. The idea is to allow a comparison to exist on the ID of a vertex. Different graph implementations can then extend this class to accommodate additional data in the graph vertex:</p><div class="informalexample"><pre class="programlisting">public class GraphVertex&lt;V&gt; implements Comparable&lt;GraphVertex&lt;V&gt;&gt;{
    int id;
    V value;

    public GraphVertex(int id, V value) {
        this.id = id;
        this.value = value;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public V getValue() {
        return value;
    }

    public void setValue(V value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        GraphVertex&lt;?&gt; that = (GraphVertex&lt;?&gt;) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return id;
    }


    @Override
    public int compareTo(GraphVertex&lt;V&gt; o) {
        return id - o.id;
    }
}</pre></div><p class="calibre8">With this <a id="id497" class="calibre1"/>class available, we can <a id="id498" class="calibre1"/>implement our adjacency-matrix-based graph implementation with a dense vertex and edge representation:</p><div class="informalexample"><pre class="programlisting">public class AdjacencyMatrixGraphWithDenseVertex&lt;V,E&gt; implements Graph&lt;V, E&gt; {</pre></div><p class="calibre8">First, we extend the <code class="email">GraphVertex</code> class to include an <code class="email">addition</code> field that stores the index of a <a id="id499" class="calibre1"/>vertex in the adjacency matrix as well as in the array meant for storing the values of the vertices:</p><div class="informalexample"><pre class="programlisting">    class Vertex extends GraphVertex&lt;V&gt;{
        int internalIndex;

        public Vertex(int id, V value, int internalIndex) {
            super(id, value);
            this.internalIndex = internalIndex;
        }

        public int getInternalIndex() {
            return internalIndex;
        }

        public void setInternalIndex(int internalIndex) {
            this.internalIndex = internalIndex;
        }
    }</pre></div><p class="calibre8">The <code class="email">nextId</code> variable is used to store the next ID that would be used:</p><div class="informalexample"><pre class="programlisting">    private int nextId;</pre></div><p class="calibre8">Special values to represent empty vertices and edges:</p><div class="informalexample"><pre class="programlisting">    private static class NullValue {};
    private NullValue nullEdge = new NullValue();

    Object [][] adjacencyMatrix = new Object[0][];</pre></div><p class="calibre8">The <a id="id500" class="calibre1"/>following is the binary search tree that stores the vertices with their indexes in the arrays:</p><div class="informalexample"><pre class="programlisting">    RedBlackTree&lt;GraphVertex&lt;V&gt;&gt; vertices = new RedBlackTree&lt;&gt;();
    boolean undirected;

    public AdjacencyMatrixGraphWithDenseVertex(boolean undirected){
        this.undirected = undirected;
    }</pre></div><p class="calibre8">The process of adding involves the same operations as before apart from the extra operation of <a id="id501" class="calibre1"/>generating a new ID and storing an entry in the search tree:</p><div class="informalexample"><pre class="programlisting">    @Override
    public int addVertex() {
        int id = nextId++;
        int numVertices = adjacencyMatrix.length;
        Object [][] newAdjacencyMatrix = new Object[numVertices+1][];
        for(int i=0;i&lt;numVertices;i++){
            newAdjacencyMatrix[i] = new Object[numVertices+1];
            System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, numVertices);
        }
        newAdjacencyMatrix[numVertices] = new Object[numVertices+1];

        vertices.insertValue(new Vertex(id, null, adjacencyMatrix.length));
        adjacencyMatrix = newAdjacencyMatrix;
        return numVertices;
    }</pre></div><p class="calibre8">The removal of a vertex now actually involves creating a smaller adjacency matrix and copying all the <a id="id502" class="calibre1"/>edges, except the ones associated with the vertex that is being deleted:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeVertex(int id) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; node = vertices.searchValue(new GraphVertex&lt;V&gt;(id, null));
        if(node!=null){
            int internalId = ((Vertex)(node.getValue())).getInternalIndex();
            int numVertices = adjacencyMatrix.length;
            Object [][] newAdjacencyMatrix = new Object[numVertices-1][];</pre></div><p class="calibre8">First, copy all the rows before the one for the vertex being deleted:</p><div class="informalexample"><pre class="programlisting">            for(int i=0;i&lt;internalId;i++){
                newAdjacencyMatrix[i] = new Object[numVertices-1];
                System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, internalId);
                System.arraycopy(adjacencyMatrix[i],internalId+1, newAdjacencyMatrix[i], internalId, numVertices-internalId-1);
            }</pre></div><p class="calibre8">Then, copy <a id="id503" class="calibre1"/>all the rows after the one <a id="id504" class="calibre1"/>for the vertex being deleted:</p><div class="informalexample"><pre class="programlisting">            for(int i=internalId+1;i&lt;numVertices;i++){
                newAdjacencyMatrix[i-1] = new Object[numVertices-1];
                System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i-1], 0, internalId);
                System.arraycopy(adjacencyMatrix[i],internalId+1, newAdjacencyMatrix[i-1], internalId, numVertices-internalId-1);
            }
            adjacencyMatrix = newAdjacencyMatrix;</pre></div><p class="calibre8">Now adjust all the indexes of the vertices added after the one that is deleted. We do this by traversing the tree in preorder and updating only when appropriate:</p><div class="informalexample"><pre class="programlisting">            vertices.traverseDepthFirstNonRecursive((gv)-&gt;{
                if(((Vertex)gv).getInternalIndex()&gt;internalId)
                    ((Vertex)gv).setInternalIndex(((Vertex)gv).getInternalIndex()-1);
            }, BinaryTree.DepthFirstTraversalType.PREORDER);
            vertices.deleteValue(new GraphVertex&lt;&gt;(id, null));
        }else{
            throw new IllegalArgumentException("Vertex with id "+id
            +" does not exist");
        }
    }</pre></div><p class="calibre8">Adding an edge involves setting an entry in the adjacency matrix. However, before doing this, we <a id="id505" class="calibre1"/>need to look up the index of the vertex:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void addEdge(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(target, null));
        if(sNode!=null &amp;&amp; tNode!=null) {
            int s = ((Vertex)(sNode.getValue())).getInternalIndex();
            int t = ((Vertex)(tNode.getValue())).getInternalIndex();
            if(adjacencyMatrix[s][t] == null){
                adjacencyMatrix[s][t] = nullEdge;
                if(undirected){
                    adjacencyMatrix[t][s] = nullEdge;
                }
            }else{
                throw new IllegalArgumentException("Edge already exists");
            }
        }else{
            throw new IllegalArgumentException("Non-existent ID");
        }

    }</pre></div><p class="calibre8">This <a id="id506" class="calibre1"/>is the same as adding an edge, other than the fact that we change the corresponding entry in the adjacency matrix to null:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeEdge(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(target, null));
        if(sNode!=null &amp;&amp; tNode!=null) {
            int s = ((Vertex)(sNode.getValue())).getInternalIndex();
            int t = ((Vertex)(tNode.getValue())).getInternalIndex();
            adjacencyMatrix[s][t] = null;
        }else{
            throw new IllegalArgumentException("Non-existent ID");
        }

    }</pre></div><p class="calibre8">Checking <a id="id507" class="calibre1"/>whether two vertices are adjacent involves looking up a value in the adjacency matrix like before. But again, we must first look up the indexes of the vertices:</p><div class="informalexample"><pre class="programlisting">    @Override
    public boolean isAdjacent(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(target, null));
        if(sNode!=null &amp;&amp; tNode!=null) {
            int s = ((Vertex)(sNode.getValue())).getInternalIndex();
            int t = ((Vertex)(tNode.getValue())).getInternalIndex();
            return adjacencyMatrix[s][t] != null;
        }else{
            throw new IllegalArgumentException("Non-existent ID");
        }

    }</pre></div><p class="calibre8">Getting the list of neighbors is a little trickier. We don't have a search mechanism that lets us search by index to look up the ID. So instead of reading a row in the adjacency matrix, we simply <a id="id508" class="calibre1"/>preorder traverse the search tree and check whether there is an edge for the vertex in the adjacency matrix. We add a vertex only when there is an edge between the source vertex and the vertex in question:</p><div class="informalexample"><pre class="programlisting">    @Override
    public LinkedList&lt;Integer&gt; getNeighbors(int source) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; node = vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        if(node!=null){
            LinkedList&lt;Integer&gt; neighborsList = new LinkedList&lt;&gt;();
            int sourceInternalIndex = ((Vertex) node.getValue()).getInternalIndex();
            vertices.traverseDepthFirstNonRecursive((gv)-&gt;{
                int targetInternalIndex = ((Vertex) gv).getInternalIndex();
                if(adjacencyMatrix[sourceInternalIndex][targetInternalIndex]!=null)
                    neighborsList.appendLast(gv.getId());
            }, BinaryTree.DepthFirstTraversalType.INORDER);
            return neighborsList;
        }else{
            throw new IllegalArgumentException("Vertex with id "+source+" does not exist");
        }

    }</pre></div><p class="calibre8">The <a id="id509" class="calibre1"/>process of setting and getting values <a id="id510" class="calibre1"/>into/from the edges and vertices is the same as before, except that we need to look up the index from the ID of the vertex before using it:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void setVertexValue(int vertex, V value) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; node =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(vertex, null));
        if(node!=null){
            node.getValue().setValue(value);
        }else{
            throw new IllegalArgumentException("Vertex with id "+vertex+" does not exist");
        }
    }

    @Override
    public V getVertexValue(int vertex) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; node =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(vertex, null));
        if(node!=null){
            return node.getValue().getValue();
        }else{
            throw new IllegalArgumentException("Vertex with id "+vertex+" does not exist");
        }
    }

    @Override
    public void setEdgeValue(int source, int target, E value) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(target, null));
        if(sNode!=null &amp;&amp; tNode!=null) {
            int s = ((Vertex)(sNode.getValue())).getInternalIndex();
            int t = ((Vertex)(tNode.getValue())).getInternalIndex();
            adjacencyMatrix[s][t] = value;
            if (undirected) {
                adjacencyMatrix[t][s] = value;
            }
        }else{
            throw new IllegalArgumentException("Non-existent ID");
        }
    }

    @Override
    public E getEdgeValue(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode = vertices.searchValue(
                new GraphVertex&lt;V&gt;(target, null));
        if(sNode!=null &amp;&amp; tNode!=null) {
            int s = ((Vertex)(sNode.getValue())).getInternalIndex();
            int t = ((Vertex)(tNode.getValue())).getInternalIndex();
            return (E) adjacencyMatrix[s][t];
        }else{
            throw new IllegalArgumentException("Non-existent ID");
        }
    }

@Override
    public boolean isUndirected() {
        return undirected;
    }

    @Override
    public BinarySearchTree&lt;Integer&gt; getAllVertices() {
        BinarySearchTree&lt;Integer&gt; allVertices = new RedBlackTree&lt;&gt;();
        vertices.traverseDepthFirstNonRecursive(
          (v) -&gt; allVertices.insertValue(v.getId()),
           BinaryTree.DepthFirstTraversalType.PREORDER);
        return allVertices;
    }
    @Override
    public int maxVertexID() {
        return nextId-1;
    }
}</pre></div><div class="book" title="Complexity of operations in a dense adjacency-matrix-based graph"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec22" class="calibre1"/>Complexity of operations in a dense adjacency-matrix-based graph</h3></div></div></div><p class="calibre8">The <a id="id511" class="calibre1"/>following are the complexities of the operations we just discussed in a dense adjacency-matrix-based graph:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Add vertex</strong></span>: Addition still has the same <span class="strong"><em class="calibre12">θ(|V|</em></span><sup class="calibre14">2</sup><span class="strong"><em class="calibre12">)</em></span> operation for creating a new adjacency matrix and copying all the old values. The additional operation of inserting a new vertex in the search tree is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. So the entire operation is still <span class="strong"><em class="calibre12">θ(|V|</em></span><span class="strong"><em class="calibre12">2</em></span><span class="strong"><em class="calibre12">)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove vertex</strong></span>: The removal of a vertex here follows the same operation of recreating an adjacency matrix and copying all the old values, which is <span class="strong"><em class="calibre12">θ(|V|</em></span><sup class="calibre14">2</sup><span class="strong"><em class="calibre12">)</em></span>. The operation of removing a vertex from the search tree is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. So the entire operation is <span class="strong"><em class="calibre12">θ(|V|</em></span><sup class="calibre14">2</sup><span class="strong"><em class="calibre12">)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Add edge and remove edge</strong></span>: The operation of updating an entry in the adjacency matrix is still <span class="strong"><em class="calibre12">θ(1)</em></span>. However, now we need to have two lookups in the search tree to figure out the indexes of the source and target. Both these searches are <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. So the entire operation is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Adjacent</strong></span>: This is also <span class="strong"><em class="calibre12">θ(lg |V|)</em></span> due to the same reason mentioned in the preceding bullet point.</li><li class="listitem"><span class="strong"><strong class="calibre2">Neighbors</strong></span>: Traversing the search tree is <span class="strong"><em class="calibre12">θ(|V|)</em></span>, and for each of the vertices thus traversed, we create a constant number of operations. Looking up the index of the source vertex is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. Hence, the entire operation is still <span class="strong"><em class="calibre12">θ(|V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and getting values at vertices and edges</strong></span>: These operations require a fixed number of lookups (one or two) and then a constant time operation for setting or getting the appropriate value. The lookups are <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>, so the entire operations are also <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Get all </strong></span><a id="id512" class="calibre1"/><span class="strong"><strong class="calibre2">vertices</strong></span>: Just like the previous implementation, this operation is <span class="strong"><em class="calibre12">θ( |V| lg |V|)</em></span>.</li></ul></div></div></div></div>

<div class="book" title="Representation of a graph in memory">
<div class="book" title="Adjacency list"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec76" class="calibre1"/>Adjacency list</h2></div></div></div><p class="calibre8">An adjacency list is <a id="id513" class="calibre1"/>a more space-efficient graph representation of sparse <a id="id514" class="calibre1"/>graphs. A sparse graph is a graph that has a very few edges as compared to the number of edges in a complete graph with the same number of vertices. A complete graph has <span class="strong"><em class="calibre12">|V| ( |V| - 1) / 2 = θ (|V|</em></span>
<span class="strong"><em class="calibre12">2</em></span>
<span class="strong"><em class="calibre12">)</em></span> edges, and the memory space required to store a graph as an adjacency matrix is also <span class="strong"><em class="calibre12">θ (|V|</em></span>
<span class="strong"><em class="calibre12">2</em></span>
<span class="strong"><em class="calibre12">)</em></span>. So, in the case of a dense (almost complete) graph, it makes sense to store it as an adjacency matrix. However, this is not true for a sparse graph.</p><p class="calibre8">In an adjacency list representation, vertices are stored in an array or some other data structure, and edges are stored along with the vertices in some list or some other structure. First, we will consider an adjacency-list-based representation where the vertices are stored in an array indexed by their IDs, as in the case of a sparse adjacency matrix representation. It has the same problem: we cannot reduce the size of the array of vertices when a vertex is deleted. However, in this case, the list of edges are deleted, and this makes it way more space-efficient than what we encountered in an adjacency matrix:</p><div class="informalexample"><pre class="programlisting">public class AdjacencyListGraphWithSparseVertex&lt;V,E&gt; implements Graph&lt;V,E&gt; {
    boolean undirected;

    public AdjacencyListGraphWithSparseVertex(boolean undirected) {
        this.undirected = undirected;
    }</pre></div><p class="calibre8">The <code class="email">Edge</code> class stores the details of the target and the value of an edge originating from a vertex. The vertex stores a collection of the associated edges. We make the edge comparable based of the ID of the target so that we can store them in a binary search tree to easily look it up based on the ID:</p><div class="informalexample"><pre class="programlisting">class Edge implements Comparable&lt;Edge&gt;{
        E value;
        int target;</pre></div><p class="calibre8">To improve the <a id="id515" class="calibre1"/>performance of the <code class="email">getNeighbors</code> operation, we store a list of neighbors in the node. We store a pointer in the node that corresponds to the target <a id="id516" class="calibre1"/>of this node in the <code class="email">targetNode</code> state variable:</p><div class="informalexample"><pre class="programlisting">        DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt; targetNode;

        public Edge(int target) {
            this.target = target;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Edge edge = (Edge) o;

            return target == edge.target;

        }

        @Override
        public int hashCode() {
            return target;
        }

        @Override
        public int compareTo(Edge o) {
            return target - o.target;
        }
    }</pre></div><p class="calibre8">The <code class="email">Vertex</code> class is used to store a vertex along with its associated edges. The edges are stored in a red black tree:</p><div class="informalexample"><pre class="programlisting">    class Vertex extends GraphVertex&lt;V&gt;{
        RedBlackTree&lt;Edge&gt;
                edges = new RedBlackTree&lt;&gt;();
        DoublyLinkedList&lt;Integer&gt; neighbors = new DoublyLinkedList&lt;&gt;();
        public Vertex(int id, V value) {
            super(id, value);
        }
    }</pre></div><p class="calibre8">The vertices are then stored in an array:</p><div class="informalexample"><pre class="programlisting">    Object[] vertices = new Object[0];</pre></div><p class="calibre8">Adding a vertex does <a id="id517" class="calibre1"/>not require us to copy any edges; it just ensures that the vertices are <a id="id518" class="calibre1"/>copied to a newly created array of bigger size:</p><div class="informalexample"><pre class="programlisting">    @Override
    public int addVertex() {
        Object[] newVertices = new Object[vertices.length+1];
        System.arraycopy(vertices, 0, newVertices, 0, vertices.length);
        newVertices[vertices.length] = new Vertex(vertices.length, null);
        vertices=newVertices;
        return newVertices.length-1;
    }</pre></div><p class="calibre8">Removing a vertex requires that you first set the vertex to null at its position. However, you must also remove all the edges from all the other vertices for which the deleted vertex was the target:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeVertex(int id) {
        Vertex sVertex = (Vertex) vertices[id];
        if(sVertex==null){
            throw new IllegalArgumentException("Vertex "+ id +" does not exist");
        }
        LinkedList&lt;Integer&gt; neighbors = getNeighbors(id);
        Edge dummyEdgeForId = new Edge(id);</pre></div><p class="calibre8">We must remove all the edges associated with the vertex being deleted:</p><div class="informalexample"><pre class="programlisting">        for(int t:neighbors){
            Edge e = ((Vertex)vertices[t]).edges.deleteValue(dummyEdgeForId).getValue();
            ((Vertex)vertices[t]).neighbors.removeNode(e.targetNode);
        }
        vertices[id] = null;
    }</pre></div><p class="calibre8">Adding an edge <a id="id519" class="calibre1"/>requires making corresponding entries in the vertices <a id="id520" class="calibre1"/>associated with it:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void addEdge(int source, int target) {
        Vertex sVertex = (Vertex) vertices[source];
        Edge sEdge = sVertex.edges.insertValue(new Edge(target)).getValue();
        sEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt;)
        sVertex.neighbors.appendLast(sEdge.target);
        if(undirected){
            Vertex tVertex = (Vertex) vertices[target];
            Edge tEdge = tVertex.edges.insertValue(new Edge(source)).getValue();
            tEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt;)
            tVertex.neighbors.appendLast(tEdge.target);
        }
    }</pre></div><p class="calibre8">Removing an edge requires removing the corresponding entries in the associated vertices:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeEdge(int source, int target) {
        Vertex sVertex = (Vertex) vertices[source];
        Edge deletedEdge = sVertex.edges.deleteValue(new Edge(target)).getValue();
        sVertex.neighbors.removeNode(deletedEdge.targetNode);
        if(undirected){
            Vertex tVertex = (Vertex) vertices[target];
            deletedEdge = tVertex.edges.deleteValue(new Edge(source)).getValue();
            tVertex.neighbors.removeNode(deletedEdge.targetNode);
        }
    }</pre></div><p class="calibre8">Checking adjacency involves looking up the source vertex first and then looking up an edge for the target in the corresponding red black tree:</p><div class="informalexample"><pre class="programlisting">    @Override
    public boolean isAdjacent(int source, int target) {
        Vertex sVertex = (Vertex) vertices[source];
        return sVertex.edges.searchValue(new Edge(target))!=null;
    }</pre></div><p class="calibre8">We have the list of neighbors <a id="id521" class="calibre1"/>precomputed, so we simply return this list:</p><div class="informalexample"><pre class="programlisting">    @Override
    public LinkedList&lt;Integer&gt; getNeighbors(int source) {s
        Vertex sVertex = (Vertex) vertices[source];
        return sVertex.neighbors;
    }</pre></div><p class="calibre8">The process of setting and <a id="id522" class="calibre1"/>getting the values of a vertex or an edge are self-explanatory:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void setVertexValue(int vertex, V value) {
        Vertex sVertex = (Vertex) vertices[vertex];
        if(sVertex==null){
            throw new IllegalArgumentException("Vertex "+ vertex 
            + "does not exist");
        }else{
            sVertex.setValue(value);
        }
    }

    @Override
    public V getVertexValue(int vertex) {
        Vertex sVertex = (Vertex) vertices[vertex];
        if(sVertex==null){
            throw new IllegalArgumentException("Vertex "+ vertex 
              + "does not exist");
        }else{
            return sVertex.getValue();
        }
    }

    @Override
    public void setEdgeValue(int source, int target, E value) {
        Vertex sVertex = (Vertex) vertices[source];
        Vertex tVertex = (Vertex) vertices[target];
        if(sVertex==null){
            throw new IllegalArgumentException("Vertex "+ source 
              + "does not exist");
        }else if(tVertex==null){
            throw new IllegalArgumentException("Vertex "+ target 
               + "does not exist");
        }else{
            BinaryTree.Node&lt;Edge&gt; node = sVertex.edges.searchValue(new Edge(target));
            if(node==null){
                throw new IllegalArgumentException("Edge between "+ source + "and" + target + "does not exist");

            }else{
                node.getValue().value = value;
            }
        }
    }

    @Override
    public E getEdgeValue(int source, int target) {
        Vertex sVertex = (Vertex) vertices[source];
        Vertex tVertex = (Vertex) vertices[target];
        if(sVertex==null){
            throw new IllegalArgumentException("Vertex "+ source 
                 + "does not exist");
        }else if(tVertex==null){
            throw new IllegalArgumentException("Vertex "+ target 
                  + "does not exist");
        }else{
            BinaryTree.Node&lt;Edge&gt; node =
                    sVertex.edges.searchValue(new Edge(target));
            if(node==null){
                throw new IllegalArgumentException("Edge between "+ source + "and" + target + "does not exist");
            }else{
                return node.getValue().value;
            }
        }
    }

    @Override
    public boolean isUndirected() {
        return undirected;
    }

    @Override
    public BinarySearchTree&lt;Integer&gt; getAllVertices() {
        BinarySearchTree&lt;Integer&gt; allVertices = new RedBlackTree&lt;&gt;();
        for(int i=0;i&lt;vertices.length;i++){
            if(vertices[i]!=null){
                allVertices.insertValue(i);
            }
        }
        return allVertices;
    }

    @Override
    public int maxVertexID() {
        return vertices.length-1;
    }
}</pre></div><div class="book" title="Complexity of operations in an adjacency-list-based graph"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec23" class="calibre1"/>Complexity of operations in an adjacency-list-based graph</h3></div></div></div><p class="calibre8">The following <a id="id523" class="calibre1"/>lists the complexities of the operations we have discussed in an adjacency-list-based graph:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Add vertex</strong></span>: Addition of a vertex requires that you create a new array first and then copy all the vertices to it. So it is <span class="strong"><em class="calibre12">θ(|V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove Vertex</strong></span>: The removal process does not change the array of the vertices. However, this operation involves checking each vertex to remove the edges which has the vertex being deleted as the target. So this operation is <span class="strong"><em class="calibre12">θ(|V|)</em></span> as well.</li><li class="listitem">Add edge and remove edge: The first step of this operation is to look up the source vertex, which is constant time. The second step is to add or remove an edge in a red black tree, so it is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. So the entire operation of adding/deleting an edge is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Adjacent</strong></span>: The first step of this operation is to look up the source vertex, which is constant time. The second step is to look up the edge in a red black tree, so it is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. So the entire operation of adding/deleting an edge is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Neighbors</strong></span>: Since the list of neighbors is precomputed, the complexity is the same as that for looking up a vertex, which is constant time.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and Getting values at vertices</strong></span>: These operations require looking up the vertex first, which is constant time. The second step is setting/getting the value. These operations are <span class="strong"><em class="calibre12">θ(1)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and Getting values at edges</strong></span>: These operations require looking up the source vertex first and then looking up the particular edge. The first is <span class="strong"><em class="calibre12">θ(1)</em></span> and the second is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. At the end, setting or getting the value of an edge is <span class="strong"><em class="calibre12">θ(l)</em></span>. Hence, the total operation is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Get all vertices</strong></span>: This <a id="id524" class="calibre1"/>operation is <span class="strong"><em class="calibre12">θ( |V| lg |V| )</em></span>, just like the previous implementations.</li></ul></div></div></div></div>

<div class="book" title="Representation of a graph in memory">
<div class="book" title="Adjacency-list-based graph with dense storage for vertices"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec77" class="calibre1"/>Adjacency-list-based graph with dense storage for vertices</h2></div></div></div><p class="calibre8">Just as in the case <a id="id525" class="calibre1"/>of an adjacency-matrix-based graph, dense storage of vertices can be done using a search tree instead of an array. This allows us <a id="id526" class="calibre1"/>to recover space when we delete a vertex without affecting the IDs of the other vertices. Everything else remains the same as the array-based storage of the vertices:</p><div class="informalexample"><pre class="programlisting">public class AdjacencyListGraphWithDenseVertex&lt;V,E&gt; implements Graph&lt;V,E&gt; {</pre></div><p class="calibre8">The <code class="email">nextId</code> variable stores the value that would be the ID of the next vertex that is inserted:</p><div class="informalexample"><pre class="programlisting">    int nextId;
    boolean undirected;</pre></div><p class="calibre8">We have the <code class="email">Edge</code> and <code class="email">Vertex</code> class as before:</p><div class="informalexample"><pre class="programlisting">    class Edge implements Comparable&lt;Edge&gt;{
        E value;
        int target;

        DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt; targetNode;
        public Edge(int target) {
            this.target = target;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) 
                 return false;
            Edge edge = (Edge) o;
            return target == edge.target;
        }

        @Override
        public int hashCode() {
            return target;
        }

        @Override
        public int compareTo(Edge o) {
            return target - o.target;
        }
    }
    class Vertex extends GraphVertex&lt;V&gt;{
        RedBlackTree&lt;Edge&gt; edges = new RedBlackTree&lt;Edge&gt;();

        DoublyLinkedList&lt;Integer&gt; neighbors 
                           = new DoublyLinkedList&lt;&gt;();
        public Vertex(int id, V value) {
            super(id, value);
        }
    }

    public AdjacencyListGraphWithDenseVertex(boolean undirected) {
        this.undirected = undirected;
    }</pre></div><p class="calibre8">Now, instead of using an array to store the vertices, use a red black tree:</p><div class="informalexample"><pre class="programlisting">    RedBlackTree&lt;GraphVertex&lt;V&gt;&gt; vertices = new RedBlackTree&lt;&gt;();</pre></div><p class="calibre8">Adding a new <a id="id527" class="calibre1"/>vertex means inserting a new one in the <a id="id528" class="calibre1"/>red black tree:</p><div class="informalexample"><pre class="programlisting">    @Override
    public int addVertex() {
        vertices.insertValue(new Vertex(nextId++, null));
        return nextId;
    }</pre></div><p class="calibre8">The removal process, as before, involves not only removing the vertex but also going through all the other vertices and deleting every edge that has the vertex that is being deleted as the target:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeVertex(int id) {
        vertices.deleteValue(new GraphVertex&lt;V&gt;(id, null));
        vertices.traverseDepthFirstNonRecursive((gv)-&gt;{
                BinaryTree.Node&lt;Edge&gt; edgeNode = ((Vertex) gv).edges.deleteValue(new Edge(id));
                if(edgeNode!=null){
                    Edge edge = edgeNode.getValue();
                    ((Vertex) gv)
                        .neighbors.removeNode(edge.targetNode);
                }
        },
                BinaryTree.DepthFirstTraversalType.INORDER);
    }</pre></div><p class="calibre8">The first step is to find the source and the target node to confirm that they exist. After this, add an edge <a id="id529" class="calibre1"/>to the collection of edges of the source <a id="id530" class="calibre1"/>node. If the graph is undirected, add an edge to the collection of edges in the target node as well:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void addEdge(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
          vertices.searchValue(new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(target, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID "+source+" does not exist");
        }else if(tNode == null){
            throw new IllegalArgumentException("Vertex ID "+target+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            Vertex tVertex = (Vertex) tNode.getValue();
            Edge tEdge = new Edge(target);
            sVertex.edges.insertValue(tEdge);
            tEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt;) sVertex.neighbors
              .appendLast(tVertex.getId());
            if(undirected) {
                Edge sEdge = new Edge(source);
                tVertex.edges.insertValue(sEdge);
                sEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode&lt;Integer&gt;) tVertex.neighbors
                  .appendLast(sVertex.getId());
            }
        }
    }</pre></div><p class="calibre8">The first step is the same as that of the previous one. After this, the edge is removed from the collection of the edges of the source node. If the graph is undirected, the edge is also removed from the <a id="id531" class="calibre1"/>collection of edges in the target <a id="id532" class="calibre1"/>node:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void removeEdge(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(target, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID "+source+" does not exist");
        }else if(tNode == null){
            throw new IllegalArgumentException("Vertex ID "+target+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            Edge deletedEdge = sVertex.edges.deleteValue(new Edge(target)).getValue();
            sVertex.neighbors.removeNode(deletedEdge.targetNode);
            if(undirected) {
                Vertex tVertex = (Vertex) tNode.getValue();
                deletedEdge = tVertex.edges.deleteValue(new Edge(source)).getValue();
              tVertex.neighbors.removeNode(deletedEdge.targetNode);
            }
        }
    }</pre></div><p class="calibre8">The first step is the same as that of the previous one. After this, the edge with the correct target is looked <a id="id533" class="calibre1"/>up. If the edge is found, the vertices are adjacent:</p><div class="informalexample"><pre class="programlisting">    @Override
    public boolean isAdjacent(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(target, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID "
                                   +source+" does not exist");
        }else if(tNode == null){
            throw new IllegalArgumentException("Vertex ID "
                                   +target+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            return sVertex.edges.searchValue(
                                 new Edge(target)) != null;

        }
    }</pre></div><p class="calibre8">We just look <a id="id534" class="calibre1"/>up the vertex and then return our precomputed list of neighbors:</p><div class="informalexample"><pre class="programlisting">    @Override
    public LinkedList&lt;Integer&gt; getNeighbors(int source) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        if(sNode == null){
            throw new IllegalArgumentException(
                    "Vertex ID "+source+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            return  sVertex.neighbors;
        }
    }</pre></div><p class="calibre8">The process of setting and getting values is the same as before, except that we need to look up the vertex/vertices <a id="id535" class="calibre1"/>in the red black tree instead of the array before setting up the values:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void setVertexValue(int vertex, V value) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(vertex, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID "
                               +vertex+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            sVertex.setValue(value);
        }
    }

    @Override
    public V getVertexValue(int vertex) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(vertex, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID "
                               +vertex+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            return sVertex.getValue();
        }
    }

    @Override
    public void setEdgeValue(int source, int target, E value) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(target, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID
                           "+source+" does not exist");
        }else if(tNode == null){
            throw new IllegalArgumentException("Vertex ID
                           "+target+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            BinaryTree.Node&lt;Edge&gt; edgeNode =
                    sVertex.edges.searchValue(new Edge(target));
            if(edgeNode!=null) {
                edgeNode.getValue().value = value;
                if (undirected) {
                    Vertex tVertex = (Vertex) tNode.getValue();
                    edgeNode = tVertex.edges
                            .searchValue(new Edge(source));
                    edgeNode.getValue().value = value;
                }
            }else{
                throw new IllegalArgumentException(
                          "No edge exists between the vertices "
                          + source + " and " + target);
            }
        }
    }

    @Override
    public E getEdgeValue(int source, int target) {
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; sNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(source, null));
        BinaryTree.Node&lt;GraphVertex&lt;V&gt;&gt; tNode =
                vertices.searchValue(
                        new GraphVertex&lt;V&gt;(target, null));
        if(sNode == null){
            throw new IllegalArgumentException("Vertex ID
                               "+source+" does not exist");
        }else if(tNode == null){
            throw new IllegalArgumentException("Vertex ID
                               "+target+" does not exist");
        }else{
            Vertex sVertex = (Vertex) sNode.getValue();
            BinaryTree.Node&lt;Edge&gt; edgeNode =
                    sVertex.edges.searchValue(new Edge(target));
            if(edgeNode!=null) {
                return edgeNode.getValue().value;

            }else{
                throw new IllegalArgumentException(
                           "No edge exists between the vertices "
                           + source + " and " + target);
            }
        }
    }

    @Override
    public boolean isUndirected() {
        return undirected;
    }

    @Override
    public BinarySearchTree&lt;Integer&gt; getAllVertices() {
        BinarySearchTree&lt;Integer&gt; allVertices 
                                = new RedBlackTree&lt;&gt;();
        vertices.traverseDepthFirstNonRecursive(
                  (v) -&gt; allVertices.insertValue(v.getId()),
                BinaryTree.DepthFirstTraversalType.PREORDER);
        return allVertices;
    }

    @Override
    public int maxVertexID() {
        return nextId -1;
    }
}</pre></div><div class="book" title="Complexity of the operations of an adjacency-list-based graph with dense storage for vertices"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec24" class="calibre1"/>Complexity of the operations of an adjacency-list-based graph with dense storage for vertices</h3></div></div></div><p class="calibre8">The <a id="id536" class="calibre1"/>complexity of the operations of an adjacency-list-based graph is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Add vertex</strong></span>: Addition of a vertex requires insertion of one in the red black tree. So this operation is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Remove Vertex</strong></span>: The removal process requires deletion of the vertex from the red black tree, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. However, this operation involves checking each vertex to remove the edges which has the vertex being deleted as the target. So this operation is <span class="strong"><em class="calibre12">θ(|V|)</em></span> as well.</li><li class="listitem"><span class="strong"><strong class="calibre2">Add edge and remove edge</strong></span>: The first step of this operation is to look up the source vertex, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. The second step is to add or remove an edge to/from a red black tree, so this is also <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. Therefore, the entire operation of adding/deleting an edge is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Adjacent</strong></span>: The first step of this operation is to look up the source vertex, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. The second step is to look up the edge in a red black tree, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span> too. Therefore, the entire operation of adding/deleting an edge is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Neighbors</strong></span>: The list of neighbors is precomputed, so the complexity of this operation is the same as that of searching a vertex, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and getting values at vertices</strong></span>: These operations require you to first look up the vertex, which is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. The second step is to set/get the value. These <a id="id537" class="calibre1"/>operations are <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Setting and getting values at edges</strong></span>: These operations require you to first look up the source vertex and then the particular edge. Both of these operations are <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>. At the end, setting or getting the value of an edge is <span class="strong"><em class="calibre12">θ(l)</em></span>. Hence, the total operation is <span class="strong"><em class="calibre12">θ(lg |V|)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Get all vertices</strong></span>: Here too, this operation is <span class="strong"><em class="calibre12">θ( |V| lg |V|)</em></span>.</li></ul></div></div></div></div>

<div class="book" title="Traversal of a graph"><div class="book" id="1S2JE2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec56" class="calibre1"/>Traversal of a graph</h1></div></div></div><p class="calibre8">The traversal of a <a id="id538" class="calibre1"/>graph is the graph's equivalent of the traversal of a tree, as discussed in an earlier chapter. Just as in the case of a tree, we can traverse either breadth-first or depth-first. However, unlike a tree, a graph can reach all the vertices without going through the edges. This makes it necessary to consider the traversal of all the edges and vertices separately. Another thing is that a graph has no designated root, so we can start from any particular vertex. Finally, since a graph may not be connected, we may not be able to traverse all the vertices/edges, starting from one single vertex. This is achieved by performing the traversal repeatedly, starting each time from any vertex that has not been visited yet already. This is a simple extension of the basic breadth-first or depth-first traversal that we are going to discuss here.</p><p class="calibre8">First, let's discuss visiting vertices using both the breadth-first and depth-first search. It involves maintaining two collections of vertices: one that stores all the vertices that are discovered but are yet to be visited/explored and another that stores a Boolean array that checks whether a vertex has already been explored/visited.</p><p class="calibre8">The collection of vertices that are discovered but yet to be explored can be of two types: if it is a stack, we have a depth-first traversal, and if it is a queue, we have a breadth-first traversal.</p><p class="calibre8">To implement both depth-first and breadth-first searches in a single method, we need to create a super interface of our <code class="email">Stack and Queue</code> interfaces. We will need to define three methods in it:</p><div class="informalexample"><pre class="programlisting">public interface OrderedStore&lt;E&gt; {
    void insert(E value);
    E pickFirst();
    E checkFirst();
}</pre></div><p class="calibre8">Now implement these <a id="id539" class="calibre1"/>methods in the <code class="email">Stack</code> and <code class="email">Queue</code> interfaces as default methods to delegate to their appropriate methods:</p><div class="informalexample"><pre class="programlisting">public interface Stack&lt;E&gt; extends OrderedStore&lt;E&gt;{
    void push(E value);
    E pop();
    E peek();
    @Override
    default E checkFirst(){
        return peek();
    }

    @Override
    default void insert(E value){
        push(value);
    }

    @Override
    default E pickFirst(){
        return pop();
    }
}

public interface Queue&lt;E&gt; extends OrderedStore&lt;E&gt;{
    void enqueue(E value);
    E dequeue();
    E peek();

    @Override
    default E checkFirst(){
        return peek();
    }

    @Override
    default void insert(E value){
        enqueue(value);
    }

    @Override
    default E pickFirst(){
        return dequeue();
    }
}</pre></div><p class="calibre8">This allows us to use the <code class="email">OrderedStore</code> interface to hold both a stack and a queue. We also create a new functional interface that represents a lambda that takes two arguments and does not return anything:</p><div class="informalexample"><pre class="programlisting">public interface TwoArgumentStatement&lt;E,F&gt; {
    void doSomething(E e, F f);
}</pre></div><p class="calibre8">We implement this search as a default method in the Graph interface itself.</p><div class="informalexample"><pre class="programlisting">enum TraversalType{
    DFT, BFT
}</pre></div><p class="calibre8">In the beginning, we only insert the starting vertex to the collection of vertices that are not yet explored. Then, we loop until all the vertices that can be discovered in the search are processed and there are <a id="id540" class="calibre1"/>no more elements in the collection of vertices. We avoid processing each vertex from the collection of vertices if it has already been processed. Otherwise, we mark it as "being processed" and invoke the visitor on it. Finally, we expand this vertex by inserting all its neighbors to the collection of elements that have to be processed:</p><div class="informalexample"><pre class="programlisting">default void visitAllConnectedVertices(int startingNode, TwoArgumentStatement&lt;Integer,  V&gt; visitor, TraversalType type) {
        OrderedStore&lt;Integer&gt; toBeProcessed = null;
        boolean doneProcessing[] = new boolean[maxVertexID()+1];
        switch (type){
            case BFT: 
                toBeProcessed = new QueueImplLinkedList&lt;Integer&gt;(); 
                break;
            case DFT: 
                toBeProcessed = new StackImplLinkedList&lt;Integer&gt;(); 
                break;
        }

        toBeProcessed.insert(startingNode);

        while(toBeProcessed.checkFirst()!=null){

            int currentVertex = toBeProcessed.pickFirst();
            if(doneProcessing[currentVertex]){
                continue;
            }

            doneProcessing[currentVertex] = true;
            visitor.doSomething(currentVertex,
                           getVertexValue(currentVertex));  </pre></div><div class="informalexample"><pre class="programlisting">            for(int neighbor:getNeighbors(currentVertex)){
                if(doneProcessing[neighbor]==false){
                    toBeProcessed.insert(neighbor);
                }
            }
        }
    }</pre></div><p class="calibre8">The process of traversal of edges is also very similar; we can follow either the breadth-first or depth-first traversal. In this case, the visitor needs access to both the source and target of the edges, which makes it necessary to store both of them in the stack or queue we use. For this purpose, we create a class named <code class="email">Edge</code>. The class is comparable so that edges can be stored in a binary search tree for easy search ability:</p><div class="informalexample"><pre class="programlisting">class Edge implements Comparable&lt;Edge&gt;{
        int source;
        int target;

        public Edge(int source, int target) {
            this.source = source;
            this.target = target;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass())
                return false;

            Edge edge = (Edge) o;

            if (source != edge.source) return false;
            return target == edge.target;

        }

        @Override
        public int hashCode() {
            int result = source;
            result = 31 * result + target;
            return result;
        }


        @Override
        public int compareTo(Edge o) {
            if(source!=o.source){
                return source - o.source;
            }else {
                return target - o.target;
            }
        }
    }</pre></div><p class="calibre8">Now we can implement the process of traversal of edges using the breadth-first and depth-first traversal:</p><div class="informalexample"><pre class="programlisting">default void visitAllConnectedEdges(int startingNode, ThreeArgumentStatement&lt;Integer, Integer, E&gt; visitor,
                                        TraversalType type){

        OrderedStore&lt;Edge&gt; toBeProcessed = null;
        boolean doneProcessing[] = new boolean[maxVertexID()+1];
        switch (type){
            case BFT: toBeProcessed = new QueueImplLinkedList&lt;Edge&gt;(); break;
            case DFT: toBeProcessed = new StackImplLinkedList&lt;Edge&gt;(); break;
        }
        toBeProcessed.insert(new Edge(-1, startingNode));
        while (toBeProcessed.checkFirst()!=null){
            Edge edge = toBeProcessed.pickFirst();
            LinkedList&lt;Integer&gt; neighbors = getNeighbors(edge.target);
            if(edge.source&gt;=0) {
                visitor.doSomething(edge.source, edge.target,
                  getEdgeValue(edge.source, edge.target));
            }
            if(doneProcessing[edge.target]){
                continue;
            }

            for(int target: neighbors){
                if(isUndirected() &amp;&amp; doneProcessing[target]){
                    continue;
                }
                Edge nextEdge = new Edge(edge.target, target);
                if(nextEdge.target!=edge.source)
                    toBeProcessed.insert(nextEdge);
            }

            doneProcessing[edge.target] = true;
        }
    }</pre></div></div>

<div class="book" title="Traversal of a graph">
<div class="book" title="Complexity of traversals"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec78" class="calibre1"/>Complexity of traversals</h2></div></div></div><p class="calibre8">For each traversal, either <a id="id541" class="calibre1"/>all vertices or edges, all edges must be traversed. This is true even if you just want to visit the vertices. The actual complexity depends on the particular map implementation, so we will use that the complexity of the operation <code class="email">getNeighbors</code> method is <span class="strong"><em class="calibre12">θ(g(|V|))</em></span>.</p><p class="calibre8">If you're visiting either the edges or vertices, ensure that each vertex is expanded only once. This operation is done <span class="strong"><em class="calibre12">|V|</em></span> times, each of which is <span class="strong"><em class="calibre12">θ(g(|V|))</em></span>. So the complexity, due to the expansion of the vertex, to find out the neighbors is <span class="strong"><em class="calibre12">θ(|V|g(|V|))</em></span>. When expanded, they are visited once, and for each edge, we have one neighbor. Some of these neighbors have been visited before; however, we need to perform constant time to verify this. So each vertex is visited once and each neighbor is checked once. This changes the complexity to <span class="strong"><em class="calibre12">θ(|V|g(|V|) + |E| )</em></span>. Since we have seen an implementation of a graph that has the constant time <code class="email">getNeighbors</code> method, we can have a traversal in <span class="strong"><em class="calibre12">θ(|V| + |E| )</em></span>.</p></div></div>

<div class="book" title="Cycle detection" id="1T1401-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec57" class="calibre1"/>Cycle detection</h1></div></div></div><p class="calibre8">One of the uses of a <a id="id542" class="calibre1"/>traversal is cycle detection. A connected undirected graph without any cycle is a tree. A directed graph without any cycle is called a directed acyclic graph (DAG). Cycle detection in graphs can be done in a very similar manner. In the case of an undirected graph, if we do a DFS and the same node is visited twice as the target of an edge, there is a cycle. Since the edge is undirected, we are satisfied if either the source or the target has not been seen before.</p><p class="calibre8">In the case of a directed graph, visiting the same node twice is not enough if you want to know whether there is a cycle; we should also consider the direction of the edges. This means while traversing the edges, we need to know whether we can reach the same node we started with. This requires us to remember the entire path while doing a DFS. This is why we use a recursive helper method to detect a cycle in a directed graph. We create the helper method for the directed cycle first. The <code class="email">checkDirectedCycleFromVertex</code> method takes the path and binary search tree of the vertices. The list of vertices is the one that stores all the vertices, and the ones already visited must be removed so that they are not used as the starting point of cycle detection later. The list of integers is the path from the starting point in a depth-first traversal. If a vertex is repeated in the same path, it means a cycle exists:</p><div class="informalexample"><pre class="programlisting">default void checkDirectedCycleFromVertex(
            com.example.functional.LinkedList&lt;Integer&gt; path, BinarySearchTree&lt;Integer&gt; allVertices){</pre></div><p class="calibre8">The head of the list is the deepest vertex in the path; we need to expand this:</p><div class="informalexample"><pre class="programlisting">        int top = path.head();
        allVertices.deleteValue(top);
        LinkedList&lt;Integer&gt; neighbors = getNeighbors(top);</pre></div><p class="calibre8">Now if any neighbor is already present in the path, a cycle exists, which is what we check. If a cycle is found, we throw an instance of a custom exception:</p><div class="informalexample"><pre class="programlisting">        for(int n:neighbors){
            com.example.functional.LinkedList&lt;Integer&gt; pathPart = path;
            while (!pathPart.isEmpty()){
                int head = pathPart.head();
                if(head == n){
                    throw new CycleDetectedException("Cycle detected");
                }
                pathPart = pathPart.tail();
            }
            checkDirectedCycleFromVertex(path.add(n), allVertices);
        }
    }</pre></div><p class="calibre8">Now we create the method for detection of cycles in either type of graph. Go through all the vertices as there might be unconnected parts of the graph. A directed graph may have connected vertices that cannot be reached from a particular starting vertex due to the directionality of the edges. However, once a vertex is visited in any traversal, it does not need to be visited again. This is taken care of by having all the vertices in a binary search tree and removing the ones that have been visited already:</p><div class="informalexample"><pre class="programlisting">default boolean detectCycle(){</pre></div><p class="calibre8">First, we get a list of all the <a id="id543" class="calibre1"/>vertices. We get it directly by understanding how the vertices are stored inside the graphs:</p><div class="informalexample"><pre class="programlisting">        BinarySearchTree&lt;Integer&gt; allVertices = getAllVertices();
        try {
            if (isUndirected()) {
                while (allVertices.getRoot() != null) {
                    int start = allVertices.getRoot().getValue();
                    RedBlackTree&lt;Integer&gt; metAlready 
                                     = new RedBlackTree&lt;&gt;();
                    metAlready.insertValue(start);
                    allVertices.deleteValue(start);
                    visitAllConnectedEdges(start, (s, t, v) -&gt; {
                            if(metAlready.searchValue(t) == null) {
                                metAlready.insertValue(t);
                                allVertices.deleteValue(t);
                            }else if(metAlready.searchValue(s)== null){
                                metAlready.insertValue(s);
                                allVertices.deleteValue(s);
                            }else{
                                throw new CycleDetectedException(
                                  "found "+t);
                            }
                        }, TraversalType.DFT);
                }
            } else {
                while (allVertices.getRoot() != null) {
                    checkDirectedCycleFromVertex(
                      com.example.functional.LinkedList
                      .&lt;Integer&gt;emptyList().add(allVertices.getRoot().getValue()), allVertices);
                }
            }
        }catch (CycleDetectedException ex){
            return true;
        }
        return false;
    }</pre></div></div>

<div class="book" title="Cycle detection" id="1T1401-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Complexity of the cycle detection algorithm"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec79" class="calibre1"/>Complexity of the cycle detection algorithm</h2></div></div></div><p class="calibre8">First, let's check out the <a id="id544" class="calibre1"/>complexity of cycle detection in an undirected graph. The complexity of <code class="email">getAllVertices</code> is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| lg |V|)</em></span>. Looking up a vertex in the search tree of vertices that have already been visited is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">( lg |V| )</em></span>. We do this twice for every edge. We also have to insert a new vertex in the <code class="email">metAlready</code> search tree and delete a vertex from the <code class="email">allVertices</code> search tree; the complexity of these operations for each edge is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">( lg |V| )</em></span>. So the total complexity is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |V| )</em></span>.</p><p class="calibre8">Now let's consider the complexity of cycle detection in a directed graph. Here, we traverse each edge once. However, for each edge, we have to look through the entire path to know whether the current vertex is seen in the path. The path can potentially be of this length: <span class="strong"><em class="calibre12">|V| - 1</em></span>. So when we check it for each edge, the complexity is <span class="strong"><em class="calibre12">O(|E||V|)</em></span>; this is a lot higher than <span class="strong"><em class="calibre12">O(|E|lg |V|)</em></span>.</p></div></div>

<div class="book" title="Spanning tree and minimum spanning tree"><div class="book" id="1TVKI2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec58" class="calibre1"/>Spanning tree and minimum spanning tree</h1></div></div></div><p class="calibre8">A spanning tree <a id="id545" class="calibre1"/>in a connected graph is a subgraph consisting of all the vertices and some edges. So, a subgraph is a tree; it is a connected graph with no loops or cycles. <span class="strong"><em class="calibre12">Figure 5</em></span> shows an example of a spanning tree in a graph:</p><div class="mediaobject"><img src="../images/00075.jpeg" alt="Spanning tree and minimum spanning tree" class="calibre9"/><div class="caption"><p class="calibre15">Figure 5. A spanning tree of a graph (shown in red)</p></div></div><p class="calibre10"> </p><p class="calibre8">A tree has minimum number of edges required to keep the vertices connected. Removing any edge from a tree will disconnect the graph. This can be useful in a map of roads that connect different places and has a minimal number of roads. With this motivation, we would really be interested in a spanning tree that has a minimum total length of roads. This may be important because constructing roads is a costly affair. Alternatively, we could design a bus route map <a id="id546" class="calibre1"/>for a city and have all the important places connected without creating too many routes; also, shorter routes are better. Such a spanning tree is called a minimum spanning tree. Finding a minimum spanning tree is an important problem. But before we discuss the algorithm, let's see some of the properties of a minimum spanning tree.</p></div>

<div class="book" title="Spanning tree and minimum spanning tree">
<div class="book" title="For any tree with vertices V and edges E, |V| = |E| + 1"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec80" class="calibre1"/>For any tree with vertices V and edges E, |V| = |E| + 1</h2></div></div></div><p class="calibre8">First, let's <a id="id547" class="calibre1"/>consider this proposition: removing any edge from a tree will create two trees with no connection between them. Let's assume the opposite. We have a graph with two vertices A and B and an edge X between them. Let's assume that even if we remove X, the tree still remains connected. This means a path P exists between A and B even if you delete X. This means in the original graph, we can walk from A to B through P and use X to come back to A. This means the original graph has a cycle. But the original graph was assumed to be a tree, so this is impossible. Therefore, my original proposition that removing any edge from the tree will create two trees with no connection between them is true.</p><p class="calibre8">Now let's start with a graph G that has a set of edges E and vertices V. If we remove all the edges, we would of course be left with only V. These set of vertices without edges are actually single vertex trees with no connections between themselves.</p><p class="calibre8">We start with one tree, say G, and remove one edge. Now we have two trees. We can now remove another <a id="id548" class="calibre1"/>edge, and this will split one of these trees into two so we have three trees. This way, after the removal of each edge, we will have one more tree. Therefore, after the removal of all the edges, we will have <span class="strong"><em class="calibre12">|E| + 1</em></span> trees (because there was one tree before any edge was removed). These must be <span class="strong"><em class="calibre12">|V|</em></span> single vertex trees. So, it is either <span class="strong"><em class="calibre12">|V| = |E|+1</em></span> or <span class="strong"><em class="calibre12">|E| = |V| - 1</em></span>.</p></div></div>

<div class="book" title="Spanning tree and minimum spanning tree">
<div class="book" title="Any connected undirected graph has a spanning tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec81" class="calibre1"/>Any connected undirected graph has a spanning tree</h2></div></div></div><p class="calibre8">Let's take an <a id="id549" class="calibre1"/>undirected graph. If there are loops and cycles. First, we simply delete all the loops. Consider A and B as two vertices that are neighbors and part of a cycle. This means if we walk through the edge from A to B, we can use another path: B to A (this is what makes it a cycle). So if we delete the B to A edge, we will still have a connected graph. We do this operation for every cycle. At the end of these operations, we will have a connected graph with no loops or cycles; this is a tree. This tree connects all the vertices, so it is a spanning tree.</p></div></div>

<div class="book" title="Spanning tree and minimum spanning tree">
<div class="book" title="Any undirected connected graph with the property |V| = |E| + 1 is a tree"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec82" class="calibre1"/>Any undirected connected graph with the property |V| = |E| + 1 is a tree</h2></div></div></div><p class="calibre8">Now let's check the <a id="id550" class="calibre1"/>reverse of the preceding theorem. Suppose there is a connected graph where <span class="strong"><em class="calibre12">|V| = |E| + 1</em></span>. We assume it is not a tree. This graph must have a spanning tree, which is a subgraph, with fewer edges. This spanning tree will have the same number of vertices (because we never deleted any vertices) but fewer edges. Therefore, if the spanning tree has the set of edges <span class="strong"><em class="calibre12">E</em></span>
<sup class="calibre14">1</sup>, we have <span class="strong"><em class="calibre12">| E</em></span>
<sup class="calibre14">1</sup><span class="strong"><em class="calibre12">|| &lt; |E| =&gt; | E</em></span>
<sup class="calibre14">1</sup><span class="strong"><em class="calibre12">|| + 1 &lt; |E| + 1 =&gt; | E</em></span>
<sup class="calibre14">1</sup><span class="strong"><em class="calibre12">|| + 1 &lt; |V|</em></span>. But this is not possible because the new graph is a tree. So the original proposition that any undirected connected graph with the property <span class="strong"><em class="calibre12">|V| = |E| +1</em></span> is a tree.</p></div></div>

<div class="book" title="Spanning tree and minimum spanning tree">
<div class="book" title="Cut property"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec83" class="calibre1"/>Cut property</h2></div></div></div><p class="calibre8">Cut refers to a <a id="id551" class="calibre1"/>minimum set of edges that when removed would split a <a id="id552" class="calibre1"/>connected undirected graph into two separate connected graphs with no connections between them. There can be many cuts in a given graph.</p><p class="calibre8">The cut property can be defined as this: if an edge is an element of a cut and has a minimum cost associated with it within the cut, it is part of the minimum spanning tree of the graph. To check this out, first note that for any cut of an undirected connected graph, a spanning tree will always have exactly one member of the cut in it.</p><p class="calibre8">Let's have a cut X that divides the graph G into subgraphs H and J. Let G have a spanning tree called S. Since G is a connected graph and X is a cut, this means H and J are connected with each other. If X is empty, it means G was not connected; this is not possible. Now we have <a id="id553" class="calibre1"/>the Y subset of X where all the members of Y are part <a id="id554" class="calibre1"/>of the spanning tree S. If Y is empty, the vertices of H and J will be disconnected in S, so this is impossible. Now as a contradiction to <span class="strong"><em class="calibre12">|Y| = 1</em></span>, let's assume <span class="strong"><em class="calibre12">|Y| &gt; 1</em></span>. This means there is more than one edge in S, between H and J. Let's pick two of them. Let the first is between vertex A in H and vertex B in J, and the second one between vertex C in H and vertex D in J. Now since the spanning tree S has all the vertices of H and J connected, there is a path from A to C and D to B in S outside of Y. So we have a cycle from A to C and C to D using one of our selected edges and we have D to B and B to A using the other selected edge. This means S has a cycle and hence S is not a tree, which is a contradiction. Therefore, <span class="strong"><em class="calibre12">|Y| = 1</em></span>. Thus, the spanning tree has exactly one member of any cut in an undirected connected graph.</p><p class="calibre8">If S is the minimum spanning tree of G and X is a cut in G dividing G into H and J, S has exactly one member for X, as proved in the preceding section. Let it be any edge other than the one with minimum cost. Since S is a spanning tree, if we remove the edge that is in X, we will have two disconnected subtrees, which are spanning trees of H and J. If we insert any other edge from X now, this new edge will connect these subtrees back to the single spanning tree. This is because all the edges of X are between one vertex in H and another in J. So we can replace the edge in S that is a member of X along with the edge in X with minimum cost, and we can thus create another spanning tree of G. But the edges of the new tree will be the same as in S, except the one that has a lesser cost than the one in S. So the sum of the costs of edges of the new spanning tree must be lesser than that of S, which is a contradiction as S is a minimum spanning tree. Therefore, the minimum spanning tree S must have an edge with the least cost within the cut X.</p></div></div>

<div class="book" title="Spanning tree and minimum spanning tree">
<div class="book" title="Minimum spanning tree is unique for a graph that has all the edges whose costs are different from one another"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec84" class="calibre1"/>Minimum spanning tree is unique for a graph that has all the edges whose costs are different from one another</h2></div></div></div><p class="calibre8">Let's assume that we <a id="id555" class="calibre1"/>have a connected undirected graph G for which there are two different minimum spanning trees, namely S and T. Since S and T are different and have the same number of edges (because for a spanning tree, the calculation is <span class="strong"><em class="calibre12">|V| = |E| + 1</em></span>), there is an edge E in S that is not in T. Let this edge be there between the vertices A and B. Now let's create a partition of the set of vertices in G so that there are two partitions: Y and Z. Create this such that A belongs to Y, B belongs to Z, and Y and Z are disjointed and together contain all the vertices. Let X be the cut that would divide G into two subgraphs with vertices in Y and Z. Since A belongs to Y and B belongs to Z, the edge E between A and B belongs to X. Since X is a cut and S is a spanning tree, there must be exactly one edge in X that is part of S; in this case, it has to be the edge E. Now, since T is also a spanning tree and E is not a member of T, there must be another member of X that is in T; let it be <span class="strong"><strong class="calibre2">f</strong></span>.</p><p class="calibre8">If we remove the edge E from S, we will have two different trees, which would be joined again if we insert f. This is because f is an edge between the vertices in Y and Z, and the two parts are already trees. So now we are left with another spanning tree.</p><p class="calibre8">All the costs are different; the cost of E is different from the cost of f. If the cost of f is lower than that of E, the total cost of the new spanning tree is lower than that of S. Although, this is not possible because S is a minimum spanning tree. So, the cost of f is higher than that of E.</p><p class="calibre8">We can do this for every <a id="id556" class="calibre1"/>edge in S that is not in T; S will transform into T when no more edges are available. In every step of this process, the total cost of edges will increase. This means the total cost of edges in T must be higher than that in S. However, this is impossible because S and T are both minimum spanning trees. So our original assumption that there can be two different minimum spanning trees is wrong. Therefore, each minimum spanning tree is unique in a graph where all the costs of the edges are different.</p></div></div>

<div class="book" title="Finding the minimum spanning tree"><div class="book" id="1UU542-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec59" class="calibre1"/>Finding the minimum spanning tree</h1></div></div></div><p class="calibre8">With the <a id="id557" class="calibre1"/>properties we just discussed, we can now <a id="id558" class="calibre1"/>define an algorithm for finding the minimum spanning tree of a graph. Suppose a set of edges F is already given and they are members of the minimum spanning tree G. Now we are trying to find another edge that is also a member of the minimum spanning tree. First, we choose an edge e whose cost is minimum when compared to the rest of the edges, E and F in this case. Since some of the edges are already given, some of the vertices are already connected. If the chosen edge e is between two vertices that are already connected, we simply reject this edge and find the next edge with minimum cost. We do this until we find an edge f between two vertices that are not already connected. Our claim is that f is a new member of the minimum spanning tree. To confirm this, let's assume that f is between the vertices A and B. From the description of our procedure, A and B are not connected. Let's make two partitions of the vertices: H and J. Let's have all the vertices that are connected to A, including A in H, and all the vertices connected to B, including B in J. The rest of the vertices are assigned to the set H. Since H and J are partitions of the vertices in the original graph G, we have a cut X in the original graph G that splits the graph G in a way that all the vertices in H are placed in one of the subgraphs and all the vertices in J in the other. We know that the member of X that has the minimum cost is a member of the minimum spanning tree G. Now, of course, f is a member of X as it connects A to B. It is also the edge with the minimum cost among all the edges in X. This is because all the edges in X are in the remaining edges (otherwise some vertices in H and some in J would be connected, which cannot be true because of the way we have created the two sets), and f is the minimum cost in all the remaining edges. This means f is a new member of the spanning tree. Therefore, we use the following steps to build the minimum spanning tree:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start with an empty set of edges as the spanning tree.</li><li class="listitem" value="2">If more edges <a id="id559" class="calibre1"/>are remaining and all the vertices are not connected, choose the one with the minimum cost.</li><li class="listitem" value="3">If the edge is between two connected vertices, discard it and go back to step 2.</li><li class="listitem" value="4">Otherwise, add the edge to the set of edges of the minimum spanning tree.</li><li class="listitem" value="5">Repeat from step 1.</li></ol><div class="calibre13"/></div><p class="calibre8">The problem now is how to efficiently know whether the two vertices are connected. The solution is a data structure called a union set forest.</p></div>

<div class="book" title="Finding the minimum spanning tree">
<div class="book" title="Union find"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec85" class="calibre1"/>Union find</h2></div></div></div><p class="calibre8">The purpose of union <a id="id560" class="calibre1"/>find is to be able to tell whether the two given objects are members of the same set. This data structure allows you to first specify all the members of a universal set and then specify which ones are members of the same partition, thus joining the two partitions to make a single partition. It represents a collection of partitions of the universal set, and it lets us query whether the two members of the universal set are members of the same partition.</p><p class="calibre8">A tree is kept in an opposite pointer form, that is, the child knows its parent; however, the parent does not have any pointers to the children. The idea is to have connected values in the same tree. Each tree in a forest has a representative node that is its root. If two nodes have the same representative roots, they are in the same partition; otherwise, they are not.</p><p class="calibre8">This data structure has three important operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Add a new object to the universal set.</li><li class="listitem"><span class="strong"><strong class="calibre2">Union two objects</strong></span>: This will result in the partitions those objects belong to joining together to make a single partition.</li><li class="listitem"><span class="strong"><strong class="calibre2">Find</strong></span>: This will return the representative object of the partition that the object passed belongs to. If the result of the find operations of two different objects is the same, the object would belong to the same partition.</li></ul></div><p class="calibre8">The following is an implementation of a <code class="email">Union</code> find that can hold comparable objects:</p><div class="informalexample"><pre class="programlisting">public class UnionFind&lt;E extends Comparable&lt;E&gt;&gt; {</pre></div><p class="calibre8">Each node holds a reference to its parent. If there is no parent, that is, if the node is the root of its tree, the parent is <a id="id561" class="calibre1"/>null. All nodes also store its rank, which is the height of the tree rooted by itself:</p><div class="informalexample"><pre class="programlisting">    private class Node implements Comparable&lt;Node&gt;{
        Node parent;
        E object;
        int rank;

        public Node(E  object) {
            this.object = object;
            rank = 0;
        }


        @Override
        public int compareTo(Node o) {
            return object.compareTo(o.object);
        }
    }</pre></div><p class="calibre8">All the nodes are stored in a red black tree so they have a logarithmic search:</p><div class="informalexample"><pre class="programlisting">    BinarySearchTree&lt;Node&gt; allNodes = new RedBlackTree&lt;&gt;();</pre></div><p class="calibre8">Additionally, we want to keep a count of the number of partitions available:</p><div class="informalexample"><pre class="programlisting">    int partitionCount;</pre></div><p class="calibre8">The <code class="email">add</code> operation adds a new object to the universal set, which is implemented using a red black tree:</p><div class="informalexample"><pre class="programlisting">    public void add(E object){
        Node n = new Node(object);
        allNodes.insertValue(n);
        partitionCount++;
    }</pre></div><p class="calibre8">This is an internal method that traverses the parents one by one until it finds the root of the tree that the object passed belongs to:</p><div class="informalexample"><pre class="programlisting">    Node findRoot(Node n){
        if(n.parent==null){
            return n;
        }else{
            return findRoot(n.parent);
        }
    }</pre></div><div class="mediaobject"><img src="../images/00076.jpeg" alt="Union find" class="calibre9"/><div class="caption"><p class="calibre15">Figure 6. Union operation in a union find forest. The partitions it represents are shown on the side.</p></div></div><p class="calibre10"> </p><p class="calibre8">The union operation <a id="id562" class="calibre1"/>merges two trees. This is achieved by setting one of the roots of the two trees as the parent of the root of the other tree. When merging two trees of unequal height, the root of the taller tree is set as the parent of the root of the shorter tree; otherwise, any one of the two is chosen as the root. The rank of the root increases only when two equal trees are merged. When unequal trees are merged, the <a id="id563" class="calibre1"/>height of the merged tree is the same as the height of the taller tree. <span class="strong"><em class="calibre12">Figure 6</em></span> shows the union operation:</p><div class="informalexample"><pre class="programlisting">    public void union(E o1, E o2){
        BinaryTree.Node&lt;Node&gt; node1 = allNodes.searchValue(new Node(o1));
        BinaryTree.Node&lt;Node&gt; node2 = allNodes.searchValue(new Node(o2));
        if(node1==null || node2==null){
            throw new IllegalArgumentException("Objects not found");
        }
        Node n1 = node1.getValue();
        Node n2 = node2.getValue();
        Node p1 = findRoot(n1);
        Node p2 = findRoot(n2);
        if(p1==p2){
            return;
        }
        int r1 = n1.rank;
        int r2 = n2.rank;
        if(r1&gt;r2){
            p2.parent = p1;
        }else if(r2&gt;r1){
            p1.parent = p2;
        }else{
            p2.parent = p1;
            p1.rank++;
        }
        partitionCount--;
    }</pre></div><p class="calibre8">The <code class="email">find</code> operation involves looking up the node related to the object first and then finding the root node. The object contained in the root node is returned:</p><div class="informalexample"><pre class="programlisting">    public E find(E object){
        BinaryTree.Node&lt;Node&gt; node1 = allNodes.searchValue(new Node(object));
        if(node1==null){
            throw new IllegalArgumentException("Objects not found");
        }
        Node n = node1.getValue();
        return findRoot(n).object;
    }
}</pre></div></div></div>

<div class="book" title="Finding the minimum spanning tree">
<div class="book" title="Complexity of operations in UnionFind"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec86" class="calibre1"/>Complexity of operations in UnionFind</h2></div></div></div><p class="calibre8">First, let's <a id="id564" class="calibre1"/>consider the complexity of finding the root node of any node; this is an internal operation. The complexity of this operation is <span class="strong"><em class="calibre12">θ(h)</em></span>, where <span class="strong"><em class="calibre12">h</em></span> is the height of the tree. Now what is the upper bound of the height of the tree? Let <span class="strong"><em class="calibre12">f(h)</em></span> be the minimum number of nodes in a tree of height <span class="strong"><em class="calibre12">h</em></span>. Trees are always created by merging two smaller trees. If the trees being merged have unequal heights, the height of the merged tree is the same as the taller of the two initial trees, and now it has more nodes than the original taller tree. This is not the way to create the worst tree, which is the tree with minimum nodes with the same height. The worst tree must be created by merging two equal trees, both of which are worst trees themselves. After you merge them, the height of the merged tree is one more than the height of either of the trees being merged. So, for creating a worst tree of height <span class="strong"><em class="calibre12">h+1</em></span>, we must merge two worst trees of height h. The operation to do this is <span class="strong"><em class="calibre12">f(h+1) = 2 f(h)</em></span>. So, if <span class="strong"><em class="calibre12">f(0) = C</em></span>, where <span class="strong"><em class="calibre12">C</em></span> is some constant, <span class="strong"><em class="calibre12">f(1) = 2C, f(2)=4C, …, f(h) = 2</em></span>
<sup class="calibre14">h</sup><span class="strong"><em class="calibre12"> C</em></span>. Therefore, if the number of nodes is <span class="strong"><em class="calibre12">n</em></span>, then <span class="strong"><em class="calibre12">n ≥ f(h) =  2</em></span>
<sup class="calibre14">h</sup><span class="strong"><em class="calibre12"> C =&gt; lg n  ≥ lg (2</em></span>
<sup class="calibre14">h</sup><span class="strong"><em class="calibre12"> C) = h + lg C =&gt; h ≤ lg n – lg C =&gt; h = O(lg n)</em></span>. This means the complexity of finding the root of a given node is also <span class="strong"><em class="calibre12">O(lg n)</em></span>.</p><div class="book"><ul class="itemizedlist"><li class="listitem">Adding a new object involves inserting a new node in the red black tree, so the complexity is <span class="strong"><em class="calibre12">θ(lg n)</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre2">Find</strong></span>: This operation involves looking up the node that corresponds to the object first. This is a search operation in the red black tree; hence it is <span class="strong"><em class="calibre12">θ(lg n)</em></span>. After this, it involves looking up the root of this node, which is <span class="strong"><em class="calibre12">O(lg n)</em></span>. And at the end, we return the object in the node, which is constant time. Hence, the complexity of the entire find operation is <span class="strong"><em class="calibre12">θ(lg n)</em></span>.</li><li class="listitem">Union involves three operations. The first is to search the nodes for the objects, which is <span class="strong"><em class="calibre12">θ(lg n)</em></span>. The second is to find the roots of each of the trees associated with the nodes, which is also <span class="strong"><em class="calibre12">O(lg n)</em></span>. And finally, it involves the merging of the trees, which is a constant time operation. So the complexity of the entire operation is <span class="strong"><em class="calibre12">θ(lg n)</em></span>.</li></ul></div></div></div>

<div class="book" title="Finding the minimum spanning tree">
<div class="book" title="Implementation of the minimum spanning tree algorithm"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec87" class="calibre1"/>Implementation of the minimum spanning tree algorithm</h2></div></div></div><p class="calibre8">Now we can <a id="id565" class="calibre1"/>implement our minimum spanning tree algorithm. First, we create a class that we will use for the implantation. The <code class="email">CostEdge</code> class represents an edge along with its cost. The <code class="email">compareTo</code> method is overridden to compare the costs instead of IDs:</p><div class="informalexample"><pre class="programlisting">class CostEdge extends Edge{
        Integer cost;

        public CostEdge(int source, int target, int cost) {
            super(source, target);
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return cost - ((CostEdge)o).cost;
        }
    }</pre></div><p class="calibre8">The argument <code class="email">costFinder</code> is a lambda that returns the cost of an edge from the value that is stored in it. <code class="email">edgeQueue</code> is a priority queue that lets us consider the edges in the order of their costs. We can dequeue the edge with the minimum cost every time, as our algorithm requires. The purpose of <code class="email">unionFind</code> is to keep track of which vertices are connected after some edges are already chosen. First, we traverse through all the edges and enqueue them to the priority queue, then we traverse through all the vertices to add them to <code class="email">unionFind</code>. After this, as described in our algorithm, we pick the edges in the order of their costs and add them only when they are not between the vertices that are already connected. The <code class="email">unionFind</code> keeps track of which vertices are connected. The edges of the spanning tree are returned in a linked list:</p><div class="informalexample"><pre class="programlisting">default LinkedList&lt;Edge&gt; minimumSpanningTree(OneArgumentExpression&lt;E,Integer&gt; costFinder){
        if(!isUndirected()){
            throw new IllegalStateException(
              "Spanning tree only applicable to undirected trees");
        }
        LinkedList&lt;Edge&gt; subGraph = new LinkedList&lt;&gt;();

        PriorityQueue&lt;CostEdge&gt; edgeQueue = new LinkedHeap&lt;&gt;((x, y)-&gt;x.compareTo(y));

        UnionFind&lt;Integer&gt; unionFind = new UnionFind&lt;&gt;();

        this.visitAllConnectedEdges(getAllVertices().getRoot().getValue(), (s,t,v)-&gt; edgeQueue.enqueue(
            new CostEdge(s,t,costFinder.compute(v))), TraversalType.DFT);

        this.getAllVertices().traverseDepthFirstNonRecursive(
          (x)-&gt;unionFind.add(x),
                BinaryTree.DepthFirstTraversalType.PREORDER);

        while((unionFind.getPartitionCount()&gt;1 
                               &amp;&amp; edgeQueue.checkMinimum()!=null){
            Edge e = edgeQueue.dequeueMinimum();
            int sGroup = unionFind.find(e.source);
            int tGroup = unionFind.find(e.target);
            if(sGroup!=tGroup){
                subGraph.appendLast(e);
                unionFind.union(e.source, e.target);
            }
        }
        return subGraph;
    }</pre></div></div></div>

<div class="book" title="Finding the minimum spanning tree">
<div class="book" title="Complexity of the minimum spanning tree algorithm"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec88" class="calibre1"/>Complexity of the minimum spanning tree algorithm</h2></div></div></div><p class="calibre8">Visiting all the <a id="id566" class="calibre1"/>edges and adding them to the priority queue can be as low as <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| + |E| + |E| lg |E|)</em></span> because traversing through the edges is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| + |E| )</em></span> and adding all of them to the priority queue is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |E|)</em></span>. Since a connected graph has <span class="strong"><em class="calibre12">|E| ≥|V| -1</em></span>, <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| + |E| + |E| lg |E|) = </em></span>
<span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |E|)</em></span>. Inserting all the vertices to the union find is done through <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| lg |V|)</em></span> because adding each vertex has the complexity <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |V|)</em></span>.</p><p class="calibre8">Now let's consider the core of the algorithm. For each edge, dequeueing the minimum edge is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |E|)</em></span>, finding each of the source and the target in <code class="email">unionFind</code> is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |V|)</em></span>, adding to the linked list is constant time, and doing a union on <code class="email">union find</code> is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |V|)</em></span>. So, for each edge, the complexity is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |V| + lg |E|)</em></span>. This is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |E|)</em></span> for each edge, as <span class="strong"><em class="calibre12">|E| ≥|V| -1</em></span>. Therefore, the complexity of the core part is <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| lg |E|)</em></span> because we stop after <span class="strong"><em class="calibre12">|V| - 1</em></span> number of edges are added and all the vertices are already connected.</p><p class="calibre8">Adding the complexity of all the preceding steps, we get the total complexity of the minimum spanning tree algorithm as <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |E|) + </em></span>
<span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(lg |V|) +</em></span>
<span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| lg |E|) = </em></span>
<span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |E| + |V| lg </em></span>
<span class="strong"><em class="calibre12">|V|) =  </em></span>
<span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|E| lg |E| )</em></span> as <span class="strong"><em class="calibre12">|E| ≥|V| -1</em></span>.</p><p class="calibre8">This algorithm is called Kruskal's algorithm, invented by Joseph Kruskal. Kruskal's algorithm works <a id="id567" class="calibre1"/>with the complexity <span class="strong"><em class="calibre12">Ө</em></span>
<span class="strong"><em class="calibre12">(|V| lg |E| )</em></span> if a sorted list of edges is already available. Since we have checked until all the edges are processed, if a graph is passed that is not connected, it will give a set of minimum spanning trees, one for each connected subgraph.</p></div></div>
<div class="book" title="Summary" id="1VSLM1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec60" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we saw what a graph is and some real-world scenarios where they can be applicable. We saw a few ways of implementing a graph data structure in memory. We then studied ways to traverse a graph, in both BFT and DFT. We used traversals to detect cycles in a graph. Finally, we saw what spanning trees are, what minimum spanning trees are, and how to find them in a graph.</p><p class="calibre8">In the next chapter, we will drift a bit to explore a simple and elegant way of implementing some concurrent programming, called reactive programming.</p></div></body></html>