<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction to Design Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">This chapter will introduce design patterns, looking at reasons to use them, how they differ from enterprise patterns, and how they behave in the real world.</span></p>
<p class="mce-root"><span class="calibre10"><span class="calibre10">Since we assume that you are already familiar with the Java programming language and Java EE, our goal is not to teach Java EE, but to demonstrate its most common design patterns. We will also demonstrate examples of the implementation of design patterns using Java EE 8. Furthermore, we will demonstrate the best way to implement design patterns </span></span><span class="calibre10"><span class="calibre10">and discuss the benefits of using <span class="calibre10"><span class="calibre10">design patterns and enterprise patterns</span></span>. If you do not know about design patterns and enterprise patterns, then this book will be a great tool for learning about the concepts and </span></span>implementations of design patterns and enterprise patterns<span class="calibre10">.</span> <span class="calibre10"><span class="calibre10">If you already know about design patterns and enterprise patterns, then this book will be a great point of reference to address when implementing them. We'll cover the following topics in this chapter:</span></span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Understanding design patterns</span></li>
<li class="calibre16">Understanding the advantages of design patterns</li>
<li class="calibre16">Defining the basic design patterns of the Java world</li>
<li class="calibre16">Explaining enterprise patterns</li>
<li class="calibre16">Explaining the difference between design patterns and enterprise patterns</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining design patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">Design patterns are sets of solutions to common design problems that occur over and over in development. They work as a solution template in which an abstract solution for a common problem is described and the user then applies it, adapting it to their problem. In object-oriented programming, the design pattern provides a way to design reusable classes and objects for a specific problem as well as defining the relationship between objects and classes. </span>In addition, design patterns provide a common idiom among programming languages that allows architects and software developers to communicate about a common and recurring problem <span class="calibre10">regardless of the programming language they are using</span><span class="calibre10">. With this, we are able to identify a problem and its solution by the name of the pattern </span><span class="calibre10">and thinking about a solution by a model point of view in a high abstraction level of language programming details.</span></p>
<p class="mce-root">The design patterns <span class="calibre10">theme</span><span class="calibre10"> </span><span class="calibre10">gained strength in 1994 after the <em class="calibre12">Gang of Four</em> (form</span>ed by Rich Gamma, Richard Helm, Ralph Johnson, and John Vlissides<span class="calibre10">) wrote </span><em class="calibre12">Design Patterns</em>: <em class="calibre12">Elements of Reusable Object‐Oriented Software</em><span class="calibre10">. Here, they described 23 design patterns that were later known as GoF design patterns and are still used today. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the Gang of Four design patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre8">Gang of Four</strong> (<strong class="calibre8">GoF</strong>) design patterns <span class="calibre10"><span class="calibre10">are 23</span></span> patterns that are classified as creational patterns, structural patterns, and behavioral patterns. The creational patterns control the creation and initialization of <span class="calibre10">the</span><span class="calibre10"> </span><span class="calibre10">object and class selection; the structural patterns define the relationship between classes and objects, and the behavioral patterns control the communication and interaction between objects. As well as this, the GoF design patterns have two</span> types of scope which define the focus of solutions<span class="calibre10">. These</span> scopes <span class="calibre10">are</span> <em class="calibre12">object scope,</em><span class="calibre10"> which resolves problems about object relations, and <em class="calibre12">class scope, </em>which </span><span class="calibre10">resolves problems about class relations.</span><span class="calibre10"> </span></p>
<p class="mce-root">The <em class="calibre12">object scope</em> works with composition and the behavior changes are done in a runtime. Thus, the object can have a dynamic behavior. The class scope works with inheritance and its behavior is static-fixed at compile-time way. Then, to change the behavior of a class-scope pattern, we need to change the class and recompile.</p>
<p class="mce-root">Patterns classified as class scope solve problems about the relationship between classes and are static (fixed at compile time and cannot be changed once compiled). However, patterns classified under the object scope solve problems about the relationship between objects and can be changed at runtime.</p>
<p class="mce-root">The following diagram shows us the three classifications, as well as their patterns and scope:</p>
<div class="cdpaligncenter"><img src="Images/8cc41ee8-491b-4867-9682-d8663b902064.png" width="640" height="239" class="calibre24"/></div>
<p class="mce-root"/>
<p class="mce-root">In the preceding diagram, we can see the <strong class="calibre8">Factory Method</strong> pattern on the <strong class="calibre8">Class</strong> <span class="calibre10">section </span>and the <strong class="calibre8">Abstract Factory</strong> pattern on the <strong class="calibre8">Object</strong> section. This occurs because the <strong class="calibre8">Factory Method</strong> works with inheritance and the abstract method pattern works with composition. Then, the Factory Method is static-fixed at compile time and cannot be changed after compilation. However, the <strong class="calibre8">Abstract Factory</strong> is dynamic and can be changed at runtime.</p>
<p class="mce-root">GoF design patterns are generally described using a graphical notation such as a use case diagram, and an example of the implementation's code. The used notation must be able to describe the classes and objects as well as the relationship between these classes and objects. </p>
<p class="mce-root">The pattern's name is an important part of the design patterns. This is because it is what the developer uses to quickly identify the problem related to the pattern and to understand how the pattern will solve it. The name of the pattern must be brief and refer to the problem and its solution.</p>
<p class="mce-root"><span class="calibre10">A design pattern is a great tool for designing software development, but its use needs to be analyzed to determine if the design pattern is really required in order to solve the problem.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The catalog of Gang of Four design patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Names of design patterns need be succinct, making them easy to identify. This is because design patterns create a vocabulary for communicating between developers independent of programming language, permitting developers to identify problems and solutions only by name of a design pattern.</p>
<p class="mce-root">In design patterns, a catalog is a set of pattern names which are designed to permit a better communication between developers.</p>
<p class="mce-root"><span class="calibre10">The catalog of GoF's design patterns has 23 patterns, as shown in</span> <span class="calibre10">the preceding diagram</span>. Here is a description of these patterns: </p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Abstract Factory</strong>: This provides an interface to create objects without specifying their concrete class, making it possible to decouple the business logic and the object creation logic<span class="calibre5">. With this, we can update the object creation logic in an easy way.</span></li>
<li class="calibre16"><strong class="calibre3">Adapter</strong>: This provides an interface that makes it possible for two incompatible interfaces to work together. The adapter pattern works as a bridge between interfaces, adapting these interfaces to work together. Furthermore, the adapter can adopt a class or objects.</li>
<li class="calibre16"><strong class="calibre3">Bridge</strong>: This pattern<strong class="calibre3"> </strong>decouples an abstraction from its implementation, making them vary independently. With this, we can modify the implementations without impacting the abstractions and we can also modify the abstractions without impacting the implementations. The class of abstraction hides implementations and its complexity.</li>
<li class="calibre16"><strong class="calibre3">Builder</strong>: This pattern separates the construction of a complex object from its representation. With this, we can construct the objects of several representations using the same process to that. Thus, we create a standard process of construction of objects that have a complex process to construct. </li>
<li class="calibre16"><strong class="calibre3">Chain of responsibility</strong>: This pattern avoids coupling the sender and receiver of a request creating some objects that have a chance to treat the requests. These objects create a chain of receiver objects for a sender's request. Each object of this chain receives the request and verifies whether or not it will treat this request. </li>
<li class="calibre16"><strong class="calibre3">Command</strong>: This pattern encapsulates a request for an object and creates a wrapper of requests containing their information about the request. With this, we can do a request to some object sending parameters without knowing about this operation. Furthermore, the command permits us to execute an <kbd class="calibre18">undo</kbd> operation.</li>
<li class="calibre16"><strong class="calibre3">Composite</strong>: This pattern composes objects into a tree structure, which represents a part-whole hierarchy. It permits you to treat a group of objects as a single object.</li>
<li class="calibre16"><strong class="calibre3">Decorator</strong>: This pattern permit extends a functionality of a class with flexibility, without use subclass. It allows you to dynamically attach a new responsibility to an object.</li>
<li class="calibre16"><strong class="calibre3">Facade</strong>: This hides the complexity of the system, applying a unified interface to a set of interfaces on a subsystem. This makes the subsystem easy to use.</li>
<li class="calibre16"><strong class="calibre3">Factory Method</strong>: This defines an interface for creating an object, and the subclass states which class to initiate. </li>
<li class="calibre16"><strong class="calibre3">Flyweight</strong>: This uses sharing to efficiently support a large number of fine-grained objects. This pattern reduces the number of objects created.</li>
<li class="calibre16"><strong class="calibre3">Interpreter</strong>: This pattern represents language grammar and uses it to interpret them as sentences of a language.</li>
<li class="calibre16"><strong class="calibre3">Iterator</strong>: This pattern provides a way to <span class="calibre5">sequentially </span>access the elements of a set of objects <span class="calibre5">without</span> knowing its underlying representation.</li>
<li class="calibre16"><strong class="calibre3">Mediator</strong>: This reduces the complexity of communication by creating an object that encapsulates all the communication and interaction between objects.</li>
<li class="calibre16"><strong class="calibre3">Memento</strong>: This pattern captures the object's internal states without hurting encapsulated concepts, with this, the state of the object can be restored by the object. This pattern works as a backup that maintains the current state of an object.</li>
<li class="calibre16"><strong class="calibre3">Observer</strong>: This defines a one-to-many dependency between objects. This means that<span class="calibre5"> if one object is modified,</span> all of its dependents are automatically notified and updated.</li>
<li class="calibre16"><strong class="calibre3">Prototype</strong>: This pattern permits us to create a new object using an object or instance as a prototype. This pattern creates a copy of an object, creating a new object with the <span class="calibre5">same state of the object used as a prototype.</span> </li>
<li class="calibre16"><strong class="calibre3">Proxy</strong>: This pattern creates a surrogate object (proxy object) for another object (original object) in order to control the access to the original object.</li>
<li class="calibre16"><strong class="calibre3">State:</strong> This permits an object to alter its behavior when its internal state changes.</li>
<li class="calibre16"><strong class="calibre3">Singleton</strong>: This ensures that a class has only one instance in the entire project, and the same instance of the object is returned every time the creation process is performed/run.</li>
<li class="calibre16"><strong class="calibre3">Strategy</strong>: This creates a family of algorithms, encapsulating each one and making them interchangeable. This pattern permits you to change the algorithm at runtime.</li>
<li class="calibre16"><strong class="calibre3">Template method</strong>: This defines a skeleton for an algorithm in an operation, and the subclass defines some steps to the algorithm. This pattern algorithm structure and the subclass redefine some steps of this algorithm without modifying its structure.</li>
<li class="calibre16"><strong class="calibre3">Visitor</strong>: This represents an operation to be performed on an object structure. This pattern permits us to add new operations to an element without modifying its class. </li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding the advantages of design patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Creating an object-oriented design is a tough task. This is because we have several important elements to think about with regard to the scenario that we'll work in and the problem we'll solve. This includes defining the appropriate objects <span class="calibre10">that </span>we need to create in order to reach the solution; defining the granularity of objects and looking at what interfaces we need to create. These tasks need to be addressed during the creation process in design. <span class="calibre10">Objects can be created to represent a real-world object or to represent a process with its algorithms and r</span><span class="calibre10">esponsibilities. Furthermore, we even need to consider the number of objects, their size, and the interface we need to access. </span></p>
<p class="mce-root">Design patterns are great tools for helping us to identify classes and objects that don't represent <span class="calibre10">real-world </span>objects and objects that are less-obvious abstractions. Moreover, design patterns help us to apply the finest granularity to objects and they also allow us to analyze a problem and solution as a model. Design patterns make the design flexible, providing a decoupling between classes and objects. They also provide the ability to organize solutions, allowing delegate responsibilities to classes with the best way.</p>
<p class="mce-root"><span class="calibre10">Building software is an expensive process for companies because it requires capable professionals and infrastructure to build and maintain the software. Design patterns, with their flexibility and decoupled design, make maintenance easy and therefore decrease its cost.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding the basic design patterns of the Java world</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">All GoF patterns have a good purpose and solve major problems of object-oriented design, but some patterns are most commonly used in the Java and Java EE ecosystem. In this book, these patterns are treated as basic design patterns because they are most commonly used to implement solutions on Java's APIs, frameworks, and algorithms. Consequently, understanding these patterns will help us to understand these APIs, frameworks, and algorithms, and we'll, in turn, be able to create a better solution using Java. These patterns are Singleton, Abstract Factory, Facade, Iterator, and Proxy.<br class="calibre9"/></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining Singleton</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a software project, in some solutions, <span class="calibre10"><span class="calibre10">we may want to ensure</span></span> that a class has only one instance of an object throughout the project and that this object is accessible at any point in the project. Creating a global instance or static instance will not ensure that this class will not be used at another point in another instance. The best way to solve this is by using the Singleton pattern, which ensures that there is only one instance of a class in the entire project. In the following diagram, we are showing the structure of Singleton and how it is designed:</p>
<div class="cdpaligncenter"><img src="Images/b845e3ba-cca7-4b81-95d9-ef5b8e714936.png" width="151" height="102" class="calibre25"/></div>
<p class="mce-root">Here, we have one class called <strong class="calibre8">Singleton</strong> which has a <kbd class="calibre18">private</kbd> constructor, as well as a reference variable of Singleton and a method for returning its unique instance. A good example of an application is a situation in which we want to create a class responsible for application configurations (paths to some resource, parameters to access filesystems, behaviors of the environment). Often, the application has some configurations and we need a class to represent these application configurations. Thus, this class of application configuration doesn't need various instances, but only one instance. </p>
<p class="mce-root">Another application of Singleton is when we want to create an Abstract Factory that will be explained in the following subsection. Generally, we will have only one Abstract Factory throughout the application. With this, we can use a Singleton to guarantee that we will have only one instance of Abstract Factory.</p>
<p class="mce-root">This pattern is often used in frameworks and APIs, but it is common for this pattern to be found in the code of projects, mainly on Java EE.</p>
<p class="mce-root"><span class="calibre10">The use of the Singleton pattern can be a good practice depending on the scenario, but depending on the scenario the use of Singleton can be a bad practice. The Singleton should not be used when the object is stateful and maintain a state, because with Singleton the same instance of the object is shared by all processes of application and if some process updates a state of this object all processes of application will be impacted by this update. Furthermore, we can have a problem with the concurrent update of the state of a Singleton.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining Abstract Factory</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Sometimes, we need to create a family of objects in a project. Imagine that we have an e-commerce and we have various kinds of products such as cell phones, notebooks, and tablets. <span class="calibre10">These products are objects of the same family. If we create objects throughout a software, we will face problems if we then need to modify the initialization process of this object.</span></p>
<p class="mce-root">Using Abstract Factory will help us to solve problems including a system which should be independent of how its products are created, a system that should use one of the multiple families of products, and a system that should work with objects which are designed to be used together. Using this pattern will be beneficial as it isolates concrete classes. This means that with this pattern, we can control which class of objects that can be initiated on software. Furthermore, it permits the exchange of products easily and provides consistency among products.</p>
<p class="mce-root">The Abstract Factory pattern creates a single point of creation for objects and if we need to change the algorithm of object <span class="calibre10">creation</span><span class="calibre10">, we need only modify the concrete factory. In the following diagram, you can see the structure of Abstract Factory and how it is designed:</span></p>
<div class="cdpaligncenter"><img src="Images/338bd53e-8bd1-4a15-871f-2f2cc94ffd83.png" class="calibre26"/></div>
<p class="mce-root">In our example, the Abstract Factory's structure has three main classes—<kbd class="calibre18">AbstractFactory</kbd>, <kbd class="calibre18">Product</kbd>, and <kbd class="calibre18">Sale</kbd>. The concrete classes of <kbd class="calibre18">AbstractFactory</kbd> are <kbd class="calibre18">CellPhoneFactory</kbd>, <kbd class="calibre18">NotebookFactory</kbd>, and <kbd class="calibre18">TabletFactory</kbd>. <kbd class="calibre18">CellPhoneFactory</kbd> is a concrete class responsible for creating the concrete classes <kbd class="calibre18">CellphoneProduct</kbd> and <kbd class="calibre18">CellphoneSale</kbd>, <kbd class="calibre18">NotebookFactory</kbd> is a concrete class responsible for creating the concrete classes <kbd class="calibre18">NotebookProduct</kbd> and <kbd class="calibre18">NotebookSale</kbd>, and the <kbd class="calibre18">TabletFactory</kbd> is a concrete class responsible for creating the concrete classes <kbd class="calibre18">TabletProduct</kbd> and <kbd class="calibre18">TabletSale</kbd>. A <kbd class="calibre18">Client</kbd> is a class responsible for using <kbd class="calibre18">AbstractFactory</kbd> to create <kbd class="calibre18">AbstractProduct</kbd> and <kbd class="calibre18">AbstractSale</kbd>. The concrete factory is created at runtime and it then creates the concrete product and sale.</p>
<p class="mce-root">The Abstract Factory pattern is sometimes used with another pattern such as Singleton, which we described earlier. Abstract Factory is a single point of creation, and often we need only one instance of it in an entire system. With this, using a Singleton pattern can help us create a design better and more efficiently.</p>
<p class="mce-root">This pattern is often used in frameworks and <span class="calibre10">APIs that have a difficult creation process for an object, such as connections or sessions.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining Facade</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Projects can sometimes turn out to be very complex and big, making them difficult to design and organize. To solve this, a great solution is to break a system into subsystems (<span class="calibre10"><span class="calibre10">divide and conquer)</span></span> and make them less complex and better organized.</p>
<p class="mce-root">The Facade pattern creates a higher-level interface to hide a complexity of a set of interfaces in a subsystem. This pattern reduces the complexity and coupling, minimizing communication and dependencies between subsystems. In the following diagram, you can see the structure of <strong class="calibre8">Facade</strong> and how it is designed:</p>
<div class="cdpaligncenter1"><img src="Images/13464b99-60bf-42ba-8557-25d1193fd008.png" class="calibre27"/></div>
<p class="mce-root">In the preceding diagram, we can see the <strong class="calibre8">Facade</strong> pattern encapsulating all of the calls to subsystems and hiding these calls from the client. The system has one interface, Facade, and the client calls this interface in order to call subsystems. Thus, clients does not call the subsystems directly.<span class="calibre10"> With this solution, the client doesn't need to know about the subsystem and its complexity.</span></p>
<p class="mce-root">This pattern is often used in projects and systems <span class="calibre10">that have high complexity and need to be broken down into subsystems.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining Iterator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Imagine that we want a way to access elements of an aggregate object sequentially without exposing its internal structure. The Iterator pattern does <span class="calibre10">just </span>that.</p>
<p class="mce-root"/>
<p class="mce-root">The Iterator pattern is responsible for <span class="calibre10">sequentially</span><span class="calibre10"> </span>accessing the aggregate object and defining an interface to access the elements <span class="calibre10">without exposing the internal structure. This interface doesn't put a new element on the aggregate object,</span> but simply reads elements to it. <span class="calibre10">In the following diagram, you can see the structure of an <strong class="calibre8">Iterator</strong> and how it is designed:</span></p>
<div class="cdpaligncenter"><img src="Images/d661cc1e-2e1e-4662-8d77-7110231045b4.png" width="705" height="423" class="calibre28"/></div>
<p class="mce-root">In the preceding diagram, we can see the <strong class="calibre8">Aggregate</strong> and <strong class="calibre8">Iterator </strong><span class="calibre10">interfaces </span><span class="calibre10">with their concrete subclasses. The client is the class that uses the <strong class="calibre8">Iterator</strong> to access elements of</span> <strong class="calibre8">Aggregate</strong><span class="calibre10">.</span></p>
<p class="mce-root">This pattern is used on Java collections such as list, deque, and set. Understanding this pattern will help you to understand Java collections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining Proxy</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Sometimes, creating a new object can be a big process and several rules can be involved in creating this object. Imagine that we want to create a list of objects, and these objects represent telecommunication <span class="calibre10">equipment,</span><span class="calibre10"> </span><span class="calibre10">which has a lot of calculus to generate the information of</span> each object<span class="calibre10">.</span> As well as this, these objects will not be accessed at the same time but will be accessed on demand. <span class="calibre10">A good strategy is to create</span> <span class="calibre10">each object when it is accessed, thereby minimizing </span>the cost and time<span class="calibre10"> it takes to create all objects and only access some. The Proxy can help us to solve this.</span></p>
<p class="mce-root">The Proxy pattern is a pattern that surrogates an object instance (original object) to another object instance (Proxy object) that permitting access control to the original object. <span class="calibre10">In the following diagram, you can see the structure of <strong class="calibre8">Proxy</strong> and how it is designed:</span></p>
<div class="cdpaligncenter1"><img src="Images/029d3aca-04db-4bb9-b452-d94796b46a09.png" width="771" height="413" class="calibre29"/></div>
<p class="mce-root">From the preceding diagram, we can see a structure of the <strong class="calibre8">Proxy</strong> pattern. If <strong class="calibre8">Subject</strong> is an interface that clients use to access object operations, then <strong class="calibre8">RealSubject</strong> is the class of the original object and <strong class="calibre8">Proxy</strong> is the class that works as a <strong class="calibre8">Proxy</strong>. Then, when the client accesses the object, they will access the <strong class="calibre8">Proxy</strong> object, and the <strong class="calibre8">Proxy</strong> object will then access the <strong class="calibre8">RealSubject</strong> object and return this object to the client.</p>
<p class="mce-root">This pattern is used in frameworks and APIs that implement JPA specification and <strong class="calibre8">object relational mapping</strong> (<strong class="calibre8">ORM</strong>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining enterprise patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">Over time, technology has evolved and new tools have emerged and helped to change some areas. Seeing the potential of these technologies, organizations increasingly began to use and invest in these tools to automate their processes and optimize their costs. These tools then began to be referred to as enterprise software.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">Enterprise software is a type of software widely used in organizations, companies, or governments that provide a service to make their processes better and optimize the cost and efficiency. Over time, the complexity of this software increased as they began to provide a lot of services. As different services demanded more communication, scalability became increasingly important. With this, some problems surfaced.</span></p>
<p class="mce-root">Enterprise patterns is a set of solutions for common problems that appear in enterprise software as a result of the complexity of enterprise environments. Many enterprise patterns are based on GoF patterns and differ only in the way in which we implement them. On Java EE, enterprise patterns are divided into three groups: presentation patterns, business patterns, and integration patterns. These patterns act on the presentation tier, business tier, and integration patterns, and we'll cover their details in <a href="7db5fa69-8dea-4753-80f4-5ca2e8feab28.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 2</a>, <em class="calibre12">Presentation Patterns</em>, which covers presentation patterns, <a href="2e0b5048-f52a-4868-b5d4-b7e8f7f3c6b3.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 3</a>, <em class="calibre12">Business Patterns</em>, which covers business patterns, and <a href="4d4d0c00-31ce-4d19-8547-b95d92500f8c.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 4</a>,<em class="calibre12"> Integration Patterns</em>, which covers integration patterns.</p>
<p class="mce-root">Enterprise patterns are very important for professionals who create software, because bad practices in the creation of software could inflate the cost and risks involved in the projects. Because of the complexity of the enterprise software, an error could propagate along the time and environment, making the enterprise environment unsustainable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the difference between design patterns and enterprise patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">Comparing design patterns with enterprise patterns is not an easy task, because some behaviors are similar. Design patterns were the first subject that arrived, and this was covered in <em class="calibre12">Design Patterns: Elements of Reusable Object</em>-<em class="calibre12">Oriented Software</em>, written</span> by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides<span class="calibre10">. These design patterns were also the base to other patterns. Enterprise patterns became necessities that design patterns cannot resolve. This is because the</span> <span class="calibre10">design patterns</span> <span class="calibre10">describe solutions for of </span>classes and objects <span class="calibre10">relationships</span>, but the enterprise environments have other necessities such as integrations between systems and software relations. <span class="calibre10">However, enterprise patterns use some design patterns to solve problems.</span></p>
<p class="mce-root"><span class="calibre10">The principal difference between design patterns and enterprise patterns is the aim; design patterns aim to organize and optimize the object-oriented design, and enterprise patterns focus on improving the use of Java EE tools as well as making communications between Java EE components better. Design patterns are focused</span> <span class="calibre10">on object-oriented and </span><span class="calibre10">class and object relations,</span> <span class="calibre10">whereas enterprise patterns are focused on communication between Java EE components.</span></p>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10"> </span></p>
<p class="mce-root">The use of design patterns makes it possible to reuse algorithms and also makes the design flexible; enterprise design patterns promote an abstraction of the complexity of Java EE tools and make it easier for the architecture to make changes.</p>
<p class="mce-root">Because of the complexity of architecture, the minimal use of enterprise patterns tends to be worse than the minimal use of design patterns. This is because, with the lack of use of enterprise patterns, the professional will always work with Java EE's complexity, increasing the probability of error.<br class="calibre9"/>
<br class="calibre9"/>
Some implementations of Java EE patterns are already present in Java EE tools, and this makes them easy to use. In the next chapters, we will describe some of these patterns and their implementation using Java EE tools and see how these patterns will favor the design and architecture of your project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we introduced you to design patterns, explaining the GoF design patterns and their catalog. We covered the basic design patterns of the Java world with a brief introduction to Singleton, Abstract Factory, Facade, Iterator, and Proxy. As well as this, we looked at enterprise patterns and the difference between them and design patterns.</p>
<p class="mce-root">In the next chapter, we will explain presentation patterns, including their concepts and implementation. We will also demonstrate the concepts of presentation patterns and how they help us to write better software. We will then show examples of the implementation of presentation patterns, using real-world problems as an example.</p>


            </article>

            
        </section>
    </div>



  </body></html>