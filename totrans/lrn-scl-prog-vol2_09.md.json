["```java\nAnimal         |      Food \n```", "```java\ndef serveSharedMeal(\n    animalOne: Animal, \n    animalTwo: Animal, \n    meal: Food) = ??? \n//don't care about the implementation \n```", "```java\nData     |            Operations \n```", "```java\nscala> val xs: List = List(\"ABC\") \n<console>:11: error: type List takes type parameters \n       val xs: List = List(\"ABC\") \nList instead of a concrete type:\n```", "```java\nscala> val xs: List[T] = List(\"ABC\") \n<console>:11: error: not found: type T \n       val xs: List[T] = List(\"ABC\") \n```", "```java\nscala> val xs: List[String] = List(\"ABC\") \nxs: List[String] = List(ABC) \n```", "```java\ndef servseMeal[A, B](serveTo: A, serveThis: Option[B]) = ??? \n```", "```java\nserveMeal(Human(Category(\"MALE\")), None) \nserveMeal(Human(Category(\"FEMALE\")), Some(Food())) \nserveMeal(Animal(), None) \nserveMeal(Animal(), Some(\"NONVEG\")) \n\ncase class Human(category: Category) \ncase class Category(name: String) \ncase class Animal() \ncase class Food() \n```", "```java\ndef serveMeal[A, B](serveTo: A, serveThis: Option[B]) = ??? \n```", "```java\nserveMeal(Human(Category(\"MALE\")): Human, None: Option[Food]) \nserveMeal(Human(Category(\"FEMALE\")): Human, Some(Food()): Option[Food]) \nserveMeal(Animal() : Animal, None: Option[Food]) \nserveMeal(Animal(): Animal, Some(Food()): Option[Food]) \n```", "```java\nsealed abstract class List[+A] extends AbstractSeq[A] \n  with LinearSeq[A] \n  with Product \n  with GenericTraversableTemplate[A, List] \n  with LinearSeqOptimized[A, List[A]] \n  with Serializable \n```", "```java\n//With type parameter name A \n\nsealed abstract class List[+A] extends AbstractSeq[A]  \n\n//With type parameter name T \n\nsealed abstract class List[+T] extends AbstractSeq[T] \n```", "```java\nsealed abstract class Option[+A] extends Product  \n   with Serializable \n```", "```java\nsealed abstract class Either[+A, +B] extends Product with Serializable \n```", "```java\nobject TypeErasure extends App { \n  val strings: List[String] = List(\"First\", \"Second\", \"Third\") \n  val noStringsAttached: List[Int] = List(1, 2, 3) \n\n  def listOf[A](value: List[A]) = value match { \n    case listOfString: List[String] => println(\"Strings Attached!\") \n    case listOfNumbers: List[Int] => println(\"No Strings Attached!\") \n  } \n\n  listOf(strings) \n  listOf(noStringsAttached) \n} \n```", "```java\nStrings Attached! \nStrings Attached! \n```", "```java\ntrait Tfoo[T]{ \n  val member: T \n} \n```", "```java\ntrait Tfoo { \n  val member: Object   //Cause scala files gets converted to *.class files. \n} \ntype parameter,Â it's not alien code to us. But, then you ask, what's with the + sign in List[+T]? Yes, this shows variance under an inheritance relationship and this + is called variance annotation. Let's go through it.\n```", "```java\nabstract class Animal() \n\nclass Cat(name: String) extends Animal()               // Inheritance relationship between Cat and Animal \n\ndef doSomethingForAnimals(animals: List[Animal]) = ??? //definitely do something for animals. \n\nIs it possible to pass an argument that's a list of Cats? \nval cats = List(new Cat(\"Mischief\"), new Cat(\"Birdie\")) \ndoSomethingForAnimals(cats) \n```", "```java\nclass AircraftSeat[-T] \n```", "```java\nabstract class Passengers \nclass CorporatePassengers extends Passengers \nclass RegularPassengers extends Passengers \n```", "```java\ndef reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = ??? //Seat booking logic! \n```", "```java\nobject ContraVariance extends App { \n\n  class AircraftSeat[-T] \n\n  def reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = { \n    //Performs some logic regarding the seat reservation! \n    println(s\" Seats Confirmed!\") \n  } \n\n  abstract class Passengers \n  class CorporatePassengers extends Passengers \n  class RegularPassengers extends Passengers \n\n  reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers]) \n\n  reserveSeatForCorporatePassengers(new AircraftSeat[Passengers]) \n\n} \n```", "```java\nSeats Confirmed! \nSeats Confirmed! \n```", "```java\ntrait Function1[-T1, +R] extends AnyRef {self => \n  /** Apply the body of this function to the argument. \n    * \n    * @return the result of function application. \n    */ \n  def apply(v1: T1): R \n\n} \n```", "```java\nscala> val func = (i: Int) => i.toString \nfunc: Int => String \n```", "```java\nnew Function1[Int, String]{ \n  override def apply(v1: Int): String = v1.toString \n} \n```", "```java\ntrait ThinkingInTermsOfT { \n      type T \n} \n```", "```java\nval instance = new ThinkingInTermsOfT { \n  type T = Int \n\n  def behaviourX(t: T): T = ??? \n} \n```", "```java\ntype T = Int \n```", "```java\nobject AbstractTypes extends App { \n\n  trait ColumnParameterized[T] { \n       def column() : T \n  } \n\n  trait ColumnAbstract { \n    type T \n\n    def column(): T \n  } \n\n  val aColumnFromParameterized = new ColumnParameterized[String] { \n    override val column = \"CITY\" \n  } \n\n  val aColumnFromAbstract = new ColumnAbstract { \n    type T = String \n\n    override val column = \"HOUSE_NO\" \n  } \n\n  println(s\"Coloumn from Parameterized: ${aColumnFromParameterized.column}   |  and Column from Abstract: ${aColumnFromAbstract.column} \") \n\n} \n```", "```java\nColumn from Parameterized: CITY   |  and Column from Abstract: HOUSE_NO \n```", "```java\ntype T = String \n```", "```java\noverride val column = 23 \n```", "```java\ntrait ActionGenerator[In] { \n  type Out \n\n  def generateAction(): Out \n} \n```", "```java\ntype Out = Int => String \n```", "```java\nobject RatingApp extends App { \n\n  type Rating = Int \n  type NumericString = String //String that can be converted into Int! \n  type AlphaNumeric = String  //Alphanumeric String \n\n  val simpleRatingGenerator = new ActionGenerator[NumericString] { \n    type Out = NumericString => Rating \n\n    /* Times when ratings are simple NumericStrings \n     * Rating as 1, 2, 3, 4, 5 \n     * We don't care about numbers more than 5 \n     */ \n    override def generateAction(): NumericString => Rating = _.toInt \n  } \n\n  val generateNumericRating = simpleRatingGenerator.generateAction() \n\n  println(generateNumericRating(\"1\")) \n} \n```", "```java\n1 \n```", "```java\nval generateNumericRating = simpleRatingGenerator.genrateAction()\nprintln(generateNumericRating(\"1\"))\n```", "```java\nval alphanumericRatingGenerator = new ActionGenerator[AlphaNumeric] { \n  type Out = AlphaNumeric => Rating \n\n /* Times when ratings are Awesome, Super, Good, something else like Neutral \n  * Rating as 1, 2, 3, 4, 5 \n  */ \n  override def generateAction(): AlphaNumeric => Rating = toRating// Some other mechanism to generate the rating \n} \n\nval toRating: AlphaNumeric => Rating = _ match { \n  case \"Awesome\" => 5 \n  case \"Cool\"    => 4 \n  case \"Nice\"    => 3 \n  case \"Worst Ever\" => 1 \n  case _ => 3 // No Comments then average rating. \n} \n\n```", "```java\n\nval generateAlphanumericRating = alphanumericRatingGenerator.generateAction() \n\nprintln(generateAlphanumericRating(\"Awesome\")) \n```", "```java\n5 \n```", "```java\nclass AircraftSeat[-T] \n```", "```java\n  class AircraftSeat[-T <: Passengers] \n```", "```java\nobject Bounds extends App { \n\n   /* \n    * AircraftSeats can be consumed only by Passengers. \n    */ \n  class AircraftSeat[-T <: Passengers] \n\n  def reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = { \n    //Performs some logic regarding the seat reservation! \n    println(s\"Seats Confirmed!\") \n  } \n\n  val corporateSeat = new AircraftSeat[CorporatePassengers]() \n  val passengersSeat = new AircraftSeat[Passengers]() \n\n  reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers]()) \n\n  reserveSeatForCorporatePassengers(new AircraftSeat[Passengers]()) \n\n  abstract class Passengers \n  class CorporatePassengers extends Passengers \n  class RegularPassengers extends Passengers \n\n} \n```", "```java\nclass Person(name: String) \n\nval seat: AircraftSeat[Person] = new AircraftSeat[Person]() \n```", "```java\ntype arguments [chapter10.Bounds.Person] do not conform to class AircraftSeat's type parameter bounds [-T <: chapter10.Bounds.Passengers] \n\n  val seat: AircraftSeat[Person] = new AircraftSeat[Person]() \n```", "```java\nclass ListLikeStructure[T >: AnyRef] \n```", "```java\nnew ListLikeStructure[Any]() \nnew ListLikeStructure[AnyRef]() \n```", "```java\nnew ListLikeStructure[String]() \nError:(30, 7) type arguments [String] do not conform to class ListLikeStructure's type parameter bounds [T >: AnyRef] \n\n  new ListLikeStructure[String]() \n```", "```java\nabstract class Zero \ntrait One extends Zero \ntrait Two extends One \ntrait Three extends Two \ntrait Four extends Three \n```", "```java\nclass ListLikeStructure[T >: Four <: Two] \n```", "```java\nnew ListLikeStructure[Four] \nnew ListLikeStructure[Three] \nnew ListLikeStructure[Two] \n```", "```java\nnew ListLikeStructure[One] \ntype arguments [chapter10.Bounds.One] do not conform to class ListLikeStructure's type parameter bounds [T >: chapter10.Bounds.Four <: chapter10.Bounds.Two] \n  new ListLikeStructure[One] \n```", "```java\ntrait ThinkingInTermsOfT { \n      type T <: Two \n} \n```", "```java\nabstract class Food \nclass Grass extends Food \nclass Meat extends Food \n\nabstract class Animal { \n   type SuitableFood <: Food \n\n   def eatMeal(meal: SuitableFood) \n} \n```", "```java\nclass Cow extends Animal { \n  type SuitableFood <: Grass \n\n  override def eatMeal(meal: SuitableFood): Unit = println(\"Cow's eating grass!\") \n\n} \n```", "```java\nclass Lion extends Animal { \n  type SuitableFood <: Meat \n\n  override def eatMeal(meal: SuitableFood): Unit = println(\"Lion's eating meat!\") \n} \n```", "```java\nobject AbsVsParamTypes extends App { \n\n  abstract class Animal { \n     type SuitableFood <: Food \n\n     def eatMeal(meal: SuitableFood) \n  } \n\n  class Lion extends Animal { \n    type SuitableFood <: Meat \n\n    override def eatMeal(meal: SuitableFood): Unit = println(\"Lion's eating meat!\") \n  } \n\n  class Cow extends Animal { \n    type SuitableFood <: Grass \n\n    override def eatMeal(meal: SuitableFood): Unit = println(\"Cow's eating grass!\") \n  } \n\n  val lion = new Lion(){ \n    type SuitableFood = Meat \n  } \n\n  val cow = new Cow(){ \n    type SuitableFood = Grass \n  } \n\n  cow.eatMeal(new Grass) \n  lion.eatMeal(new Meat) \n\n  abstract class Food \n  class Grass extends Food \n  class Meat extends Food \n} \n```", "```java\nCow's eating grass! \nLion's eating meat! \n```", "```java\ntrait CSVEncoder[T] { \n  def encode(t: T): List[String] \n} \n```"]