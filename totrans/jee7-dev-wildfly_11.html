<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;11.&#xA0;Clustering WildFly Applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Clustering WildFly Applications</h1></div></div></div><p class="calibre8">In the previous chapters, we went through the most interesting aspects of developing Java Enterprise applications. Once you are ready to roll out your applications, it is important that you guarantee your customers a responsive and fault-tolerant environment. This requirement can be achieved through application server clustering.</p><p class="calibre8">WildFly clustering is not the product of a single library or specification, but rather a blend of technologies. In this chapter, we will first introduce some of the basics of clustered programming. Then, we will quickly move on to the cluster configuration and its setup, which will be required to deploy some clustered applications.</p><p class="calibre8">The following list is a preview of the topics that will be covered in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What clustering is and how WildFly implements it</li><li class="listitem">Setting up clusters in the standalone and domain mode</li><li class="listitem">Developing clustered Java EE 7 applications in order to achieve load balancing and high availability</li></ul></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Clustering WildFly Applications">
<div class="book" title="Clustering basics"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec52" class="calibre1"/>Clustering basics</h1></div></div></div><p class="calibre8">A cluster of application servers consists of multiple server instances (cluster nodes) running simultaneously and working together to provide increased scalability and reliability. The nodes <a id="id1161" class="calibre1"/>that make up a cluster can be located either on the same machine or different machines. From the client's point of view, this is irrelevant because the cluster appears as a single server instance.</p><p class="calibre8">Introducing clustering in your<a id="id1162" class="calibre1"/> applications will produce the following benefits:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Horizontal scalability (scaling out)</strong></span>: Adding a new node to a cluster should allow the overall system<a id="id1163" class="calibre1"/> to service a higher client load than that provided by a simple basic configuration. Ideally, it should be possible to service any given load simply by adding the appropriate number of servers or machines.</li><li class="listitem"><span class="strong"><strong class="calibre9">Load balancing</strong></span>: In a clustered environment, the individual nodes that compose the cluster should each process a fair share of the overall client load. This can be achieved<a id="id1164" class="calibre1"/> by distributing client requests across multiple servers, which is also known as load balancing.</li><li class="listitem"><span class="strong"><strong class="calibre9">High availability</strong></span>: Applications running in a cluster can continue to do so when a server instance fails. This is achieved because applications are deployed on <a id="id1165" class="calibre1"/>multiple nodes of the cluster, and so if a server instance fails, another server instance on which that component is deployed can continue with application processing.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="WildFly clustering"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec53" class="calibre1"/>WildFly clustering</h1></div></div></div><p class="calibre8">Clustering is available in <a id="id1166" class="calibre1"/>WildFly out of the box. There is no all-in-one library that deals with clustering, but rather a set of libraries that cover different kinds of aspects.</p><p class="calibre8">The following diagram shows the basic clustering architecture adopted by WildFly:</p><div class="mediaobject"><img src="../images/00089.jpeg" alt="WildFly clustering" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The backbone of JBoss<a id="id1167" class="calibre1"/> clustering is the <span class="strong"><strong class="calibre9">JGroups</strong></span> library, which provides communication between members of the cluster using a multicast transmission.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note62" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Multicast</strong></span> is a<a id="id1168" class="calibre1"/> protocol where data is transmitted simultaneously to a group of hosts that have joined the appropriate multicast group. You can think about multicast as a radio or television streaming where only those tuned to a particular frequency receive the streaming.</p></div><p class="calibre8">The next building block is <span class="strong"><strong class="calibre9">Infinispan</strong></span>, which handles the consistency of your application across the cluster by means<a id="id1169" class="calibre1"/> of a replicated and transactional JSR-107-compatible cache.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note63" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">JSR-107</strong></span> specifies the<a id="id1170" class="calibre1"/> API and semantics for temporary in-memory caching of Java objects, including object creation, shared access, spooling, invalidation, and consistency across JVMs.</p></div><p class="calibre8">Before diving into some<a id="id1171" class="calibre1"/> cluster examples, we will first need to describe how to set up a cluster of WildFly nodes using the two available nodes: <span class="strong"><strong class="calibre9">standalone cluster</strong></span> <a id="id1172" class="calibre1"/>and <a id="id1173" class="calibre1"/>
<span class="strong"><strong class="calibre9">domain cluster</strong></span>. If you don't remember the difference between the <span class="strong"><strong class="calibre9">standalone</strong></span> and <span class="strong"><strong class="calibre9">domain</strong></span> mode or what core <span class="strong"><strong class="calibre9">domain</strong></span> elements are, you can revise the material from <a class="calibre1" title="Chapter 2. Your First Java EE Application on WildFly" href="part0017_split_000.html#page">Chapter 2</a>, <span class="strong"><em class="calibre10">Your First Java EE Application on WildFly</em></span>.</p></div>

<div class="book" title="WildFly clustering">
<div class="book" title="Starting a cluster of standalone nodes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec76" class="calibre1"/>Starting a cluster of standalone nodes</h2></div></div></div><p class="calibre8">A standalone server starts as a single JVM process; therefore, we need to start each server using the <code class="email">standalone.bat/standalone.sh</code> command, passing all the required parameters. In the following example, we are starting a cluster of two server nodes on two different boxes that<a id="id1174" class="calibre1"/> are bound to the IP addresses <code class="email">192.168.1.10</code> and <code class="email">192.168.1.11</code>, respectively:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">./standalone.sh -c standalone-ha.xml -b 192.168.1.10</strong></span>
<span class="strong"><strong class="calibre9">./standalone.sh -c standalone-ha.xml -b 192.168.1.11</strong></span>
</pre></div><p class="calibre8">The <code class="email">-c</code> parameter specifies the server configuration to be used; out of the box, the application server includes two standalone clustering configurations: <code class="email">standalone-ha.xml</code> and <code class="email">standalone-full-ha.xml</code>. The latter one also includes the messaging subsystem and other elements of the Java EE full profile; therefore, it has been named the <span class="strong"><em class="calibre10">full</em></span> configuration.</p><p class="calibre8">The other parameter (<code class="email">-b</code>) should sound familiar to older JBoss users, as it's still used to specify the server-binding address, which needs to be unique in order to avoid port conflicts.</p><p class="calibre8">In this other example, we are starting another cluster of two nodes on the same box using some additional parameters in order to avoid port conflicts:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">./standalone.sh -c standalone-ha.xml -Djboss.node.name=node1  </strong></span>
<span class="strong"><strong class="calibre9">./standalone.sh -c standalone-ha.xml -Djboss.node.name=node2 -Djboss.socket.binding.port-offset=200</strong></span>
</pre></div><p class="calibre8">As you can see, we had to specify two additional parameters: <code class="email">jboss.node.name</code> in order to assign a unique server name to each node and a socket-binding port, which uses an offset of <code class="email">200</code>. So, for example, the second node would respond to the HTTP channel on port <code class="email">8280</code> instead of port <code class="email">8080</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note64" class="calibre1"/>Note</h3><p class="calibre8">Don't be surprised if you<a id="id1175" class="calibre1"/> don't see any message about clustering on your server console. Clustering modules are activated on demand, so first you need to deploy an application that is cluster-aware. In a few minutes, we will show you how.</p></div></div></div>

<div class="book" title="WildFly clustering">
<div class="book" title="Starting a cluster of domain nodes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec77" class="calibre1"/>Starting a cluster of domain nodes</h2></div></div></div><p class="calibre8">In order to configure a<a id="id1176" class="calibre1"/> cluster running on a domain of server nodes, you need to configure the main <code class="email">domain.xml</code> file for your domain <a id="id1177" class="calibre1"/>controller. Then, for every WildFly host that is a part of the cluster, you need to provide a <code class="email">host.xml</code> configuration file, which describes the configuration of a single-server distribution.</p><div class="book" title="The domain controller configuration"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec75" class="calibre1"/>The domain controller configuration</h3></div></div></div><p class="calibre8">The <code class="email">domain.xml</code> file is located at <code class="email">JBOSS_HOME/domain/configuration/</code>. It includes the main domain<a id="id1178" class="calibre1"/> configuration, which is shared by all server instances. In the <code class="email">domain.xml</code> file, we will define the server group configurations specifying a profile that is compatible with clustering. Out of the box, a WildFly domain ships with four different profiles:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">default</code>: This profile<a id="id1179" class="calibre1"/> has the support of Java EE Web Profile and some extensions, such as RESTful web services, or <a id="id1180" class="calibre1"/>support for <span class="strong"><strong class="calibre9">Enterprise JavaBeans</strong></span> (<span class="strong"><strong class="calibre9">EJB</strong></span>) 3 remote invocations</li><li class="listitem"><code class="email">full</code>: This profile<a id="id1181" class="calibre1"/> supports all the default subsystems contained in the default profile and the messaging subsystem</li><li class="listitem"><code class="email">ha</code>: This profile<a id="id1182" class="calibre1"/> corresponds to the <code class="email">default</code> profile extended with clustering capabilities</li><li class="listitem"><code class="email">full-ha</code>: This is the<a id="id1183" class="calibre1"/> <code class="email">full</code> profile with clustering capabilities</li></ul></div><p class="calibre8">So, first specify a cluster-aware profile for your server groups in your <code class="email">domain.xml</code> file. In our example, we have adopted the <code class="email">full-ha</code> profile for both the server groups so that you can run the full Java EE stack on all your domain servers:</p><div class="informalexample"><pre class="programlisting">&lt;server-groups&gt;
<span class="strong"><strong class="calibre9">    &lt;server-group name="main-server-group" profile="full-ha"&gt;</strong></span>
<span class="strong"><strong class="calibre9">        </strong></span>&lt;jvm name="default"&gt;
<span class="strong"><strong class="calibre9">            </strong></span>&lt;heap size="64m" max-size="512m"/&gt;
<span class="strong"><strong class="calibre9">        </strong></span>&lt;/jvm&gt;
<span class="strong"><strong class="calibre9">        </strong></span>&lt;socket-binding-group ref="<span class="strong"><strong class="calibre9">full-ha-sockets</strong></span>"/&gt;
<span class="strong"><strong class="calibre9">    </strong></span>&lt;/server-group&gt;
<span class="strong"><strong class="calibre9">    </strong></span>&lt;server-group name="other-server-group" profile="full-ha"&gt;
<span class="strong"><strong class="calibre9">        </strong></span>&lt;jvm name="default"&gt;
<span class="strong"><strong class="calibre9">            </strong></span>&lt;heap size="64m" max-size="512m"/&gt;
<span class="strong"><strong class="calibre9">        </strong></span>&lt;/jvm&gt;
<span class="strong"><strong class="calibre9">        </strong></span>&lt;socket-binding-group ref="full-sockets"/&gt;
<span class="strong"><strong class="calibre9">    </strong></span>&lt;/server-group&gt;
&lt;/server-groups&gt;</pre></div><p class="calibre8">When using a <code class="email">full-ha</code> profile, you need to configure HornetQ clustering security. You can just disable it, or you need to additionally set a completely random user credential for a JMS cluster. Find the profile settings in <code class="email">domain.xml</code>, and add the following code to the messaging subsystem:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    &lt;hornetq-server&gt;
<span class="strong"><strong class="calibre9">        &lt;cluster-user&gt;randomUser&lt;/cluster-user&gt;</strong></span>
<span class="strong"><strong class="calibre9">        &lt;cluster-password&gt;randomPassword&lt;/cluster-password&gt;</strong></span>
           . . . 
    &lt;/hornetq-server&gt;
&lt;/subsystem&gt;</pre></div><p class="calibre8">In addition to the <code class="email">domain.xml</code> file, you need to check whether your domain controller's <code class="email">host.xml</code> file contains a reference to the local host, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&lt;host name="master" &gt;</strong></span>
    ...
    &lt;domain-controller&gt;
<span class="strong"><strong class="calibre9">       &lt;local/&gt;</strong></span>
    &lt;/domain-controller&gt;
    ...
&lt;/host&gt;</pre></div><p class="calibre8">The <code class="email">local</code> stanza means that this host controller will take the role of a domain controller. For all other hosts controllers, you must specify the remote domain controller host and its port (in this example, we added some variables as placeholders). We will cover them in the next section.</p><p class="calibre8">Finally, you need to create a<a id="id1184" class="calibre1"/>  management user that will be used to establish a connection between the slave nodes and the domain controller. For this purpose, launch the <code class="email">add-user.sh/add-user.cmd</code> script, which is located in the <code class="email">JBOSS_HOME/bin</code> directory of your distribution:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">What type of user do you wish to add?</strong></span>
<span class="strong"><strong class="calibre9"> a) Management User (mgmt-users.properties)</strong></span>
<span class="strong"><strong class="calibre9"> b) Application User (application-users.properties)</strong></span>
<span class="strong"><strong class="calibre9">(a): a</strong></span>

<span class="strong"><strong class="calibre9">Enter the details of the new user to add.</strong></span>
<span class="strong"><strong class="calibre9">Using realm 'ManagementRealm' as discovered from the existing property files.</strong></span>
<span class="strong"><strong class="calibre9">Username : admin1234</strong></span>
<span class="strong"><strong class="calibre9">Password recommendations are listed below. To modify these restrictions edit the add-user.properties configuration file.</strong></span>
<span class="strong"><strong class="calibre9"> - The password should not be one of the following restricted values {root, admin, administrator}</strong></span>
<span class="strong"><strong class="calibre9"> - The password should contain at least 8 characters, 1 alphabetic character(s), 1 digit(s), 1 non-alphanumeric symbol(s)</strong></span>
<span class="strong"><strong class="calibre9"> - The password should be different from the username</strong></span>
<span class="strong"><strong class="calibre9">Password :</strong></span>
<span class="strong"><strong class="calibre9">Re-enter Password :</strong></span>
<span class="strong"><strong class="calibre9">What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[  ]:</strong></span>
<span class="strong"><strong class="calibre9">About to add user 'admin1234' for realm 'ManagementRealm'</strong></span>
<span class="strong"><strong class="calibre9">Is this correct yes/no? yes</strong></span>
<span class="strong"><strong class="calibre9">Added user 'admin1234' to file 'D:\Dev\Servers\wildfly-8.1.0.Final\standalone\configuration\mgmt-users.properties'</strong></span>
<span class="strong"><strong class="calibre9">Added user 'admin1234' to file 'D:\Dev\Servers\wildfly-8.1.0.Final\domain\configuration\mgmt-users.properties'</strong></span>
<span class="strong"><strong class="calibre9">Added user 'admin1234' with groups  to file 'D:\Dev\Servers\wildfly-8.1.0.Final\standalone\configuration\mgmt-groups.properties'</strong></span>
<span class="strong"><strong class="calibre9">Added user 'admin1234' with groups  to file 'D:\Dev\Servers\wildfly-8.1.0.Final\domain\configuration\mgmt-groups.properties'</strong></span>
<span class="strong"><strong class="calibre9">Is this new user going to be used for one AS process to connect to another AS process?</strong></span>
<span class="strong"><strong class="calibre9">e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls.</strong></span>
<span class="strong"><strong class="calibre9">yes/no? yes</strong></span>
<span class="strong"><strong class="calibre9">To represent the user add the following to the server-identities definition &lt;secret value="c2xvZHppYWsxMjM0" /&gt;</strong></span>
<span class="strong"><strong class="calibre9">Press any key to continue . . .</strong></span>
</pre></div><p class="calibre8">As you can see from the preceding listing, you have to create a management user by specifying a username<a id="id1185" class="calibre1"/>  and password for it. You should answer the previous question with either <code class="email">yes</code> or <code class="email">y</code> to indicate that the user will be used to connect to the domain controller from the host controller. The generated secret value is the Base64-encoded password of the newly created user.</p><p class="calibre8">Now we can start the domain controller by specifying the address that will be used for public and management interfaces (in our example, <code class="email">192.168.1.10</code>) with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">domain.sh –host-config=host-master.xml -b 192.168.1.10 -Djboss.bind.address.management=192.168.1.10</strong></span>
</pre></div><p class="calibre8">We have set the bind address of the physical network to the host configuration with the <code class="email">jboss.bind.address.management</code> property. The<a id="id1186" class="calibre1"/>  management interface must be reachable for all the hosts in the domain in order to establish a connection with the domain controller.</p></div><div class="book" title="Host configurations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec76" class="calibre1"/>Host configurations</h3></div></div></div><p class="calibre8">After the domain controller is configured and started, the next step is to set up the other hosts that will connect<a id="id1187" class="calibre1"/> to the domain controller. On each host, we also need an installation of WildFly, where we will configure the <code class="email">host.xml</code> file. (As an alternative, you can name the host file as you like and start the domain with the <code class="email">-host-config</code> parameter, for example, <code class="email">./domain.sh -host-config=host-slave.xml</code>.)</p><p class="calibre8">The first thing is to choose a unique name for each host in our domain in order to avoid name conflicts. Otherwise, the default is the hostname of the server.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&lt;host name="server1" &gt;</strong></span>
    ...
&lt;/host&gt;</pre></div><p class="calibre8">Also, you have to choose a unique name for the other host:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&lt;host name="server2" &gt;</strong></span>
    ...
&lt;/host&gt;</pre></div><p class="calibre8">Next, we need to specify that the host controller will connect to a remote domain controller. We will not specify the actual IP address of the domain controller but leave it as a property named <code class="email">jboss.domain.master.address</code>.</p><p class="calibre8">Additionally, we need to specify the username that will be used to connect to the domain controller. So let's add the user <code class="email">admin1234</code>, which we created on the domain controller machine:</p><div class="informalexample"><pre class="programlisting">&lt;domain-controller&gt;
       &lt;remote host="${jboss.domain.master.address}"      port="${jboss.domain.master.port:9999}"
<span class="strong"><strong class="calibre9">       username="admin1234" </strong></span>
       security-realm="ManagementRealm"/&gt;
&lt;/domain-controller&gt;</pre></div><p class="calibre8">Finally, we need to specify the Base64 password for the server identity that we included in the <code class="email">remote</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;management&gt;
   &lt;security-realms&gt;
      &lt;security-realm name="ManagementRealm"&gt;
         &lt;server-identities&gt;
            &lt;secret value="QWxlc3NhbmRybzIh" /&gt;
         &lt;/server-identities&gt;
         &lt;authentication&gt;
            &lt;properties path="mgmt-users.properties" relative-to="jboss.domain.config.dir" /&gt;
         &lt;/authentication&gt;
      &lt;/security-realm&gt;
      &lt;security-realm name="ApplicationRealm"&gt;
         &lt;authentication&gt;
            &lt;properties path="application-users.properties" relative-to="jboss.domain.config.dir" /&gt;
         &lt;/authentication&gt;
      &lt;/security-realm&gt;
   &lt;/security-realms&gt;
   &lt;management-interfaces&gt;
      &lt;native-interface security-realm="ManagementRealm"&gt;
         &lt;socket interface="management" port="${jboss.management.native.port:9999}" /&gt;
      &lt;/native-interface&gt;
   &lt;/management-interfaces&gt;
&lt;/management&gt;</pre></div><p class="calibre8">The final step is to configure the server nodes inside the <code class="email">host.xml</code> file on both the hosts. So, on the first host, we will configure <code class="email">server-one</code> and <code class="email">server-two</code> to add them to <code class="email">main-server-group</code>:</p><div class="informalexample"><pre class="programlisting">&lt;servers&gt;
        &lt;server name="server-one" group="main-server-group"/&gt;
        &lt;server name="server-two" group="main-server-group" auto-start="false"&gt; 
            &lt;socket-bindings port-offset="150"/&gt;
        &lt;/server&gt;
&lt;/servers&gt;</pre></div><p class="calibre8">On the second host, we will<a id="id1188" class="calibre1"/> configure <code class="email">server-three</code> and <code class="email">server-four</code> to add them to <code class="email">other-server-group</code>:</p><div class="informalexample"><pre class="programlisting">&lt;servers&gt;
     &lt;server name="server-three" group="other-server-group"/&gt;
     &lt;server name="server-four" group="other-server-group"&gt; auto-start="false"&gt;
            &lt;socket-bindings port-offset="150"/&gt;
     &lt;/server&gt;
&lt;/servers&gt;</pre></div><p class="calibre8">Please note that the <code class="email">auto-start</code> flag value indicates that the server instances will not be started automatically if the host controller is started.</p><p class="calibre8">For <code class="email">server-two</code> and <code class="email">server-four</code>, a <code class="email">port-offset</code> value of <code class="email">150</code> is configured to avoid port conflicts. Okay, now we are done with our configuration. Assuming that the first host has an IP address of <code class="email">192.168.1.10</code>, we can start the first host with the following code snippet:</p><div class="informalexample"><pre class="programlisting">domain.sh \
-host-conifg=host.xml
-b 192.168.1.10  \
-Djboss.domain.master.address=192.168.1.1 \
-Djboss.bind.address.management=192.168.1.10</pre></div><p class="calibre8">The second host (<code class="email">192.168.1.11</code>) can be started<a id="id1189" class="calibre1"/> with the following code snippet:</p><div class="informalexample"><pre class="programlisting">domain.sh \
-host-conifg=host.xml
-b 192.168.1.11 \
-Djboss.domain.master.address=192.168.1.1 \
-Djboss.bind.address.management=192.168.1.11 </pre></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Deploying clustered applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec54" class="calibre1"/>Deploying clustered applications</h1></div></div></div><p class="calibre8">If you have tried <a id="id1190" class="calibre1"/>starting your standalone or domain set of cluster nodes, you will be surprised that there is no information at all about clustering in your server logging. Believe me, it is not a bug but a feature! One of the key features of WildFly is that only a minimal set of services is started; therefore, in order to see a cluster's live demonstration, you need to deploy a cluster-aware application. In order to trigger clustering libraries in your application, you can follow two approaches:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If your application uses Enterprise JavaBeans, you don't have to do anything more. This area brings some important changes in WildFly. Now, by default, the data of all stateful session beans is replicated in HA profiles, and all stateless beans are clustered. If your application is deployed on a container started with the <code class="email">standalone-ha.xml</code> configuration, all remote <span class="strong"><strong class="calibre9">Stateless Session Bean</strong></span> (<span class="strong"><strong class="calibre9">SLSB</strong></span>)<a id="id1191" class="calibre1"/> support failover capabilities by default.</li><li class="listitem">If your application includes a web application archive, you can use the portable <code class="email">&lt;distributable /&gt;</code> element in your <code class="email">web.xml</code> file.</li></ul></div><p class="calibre8">Let's have a look at both the approaches, starting from clustering EJBs.</p></div>

<div class="book" title="Deploying clustered applications">
<div class="book" title="Creating HA Stateful Session Beans"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec78" class="calibre1"/>Creating HA Stateful Session Beans</h2></div></div></div><p class="calibre8">Clustered <a id="id1192" class="calibre1"/>
<span class="strong"><strong class="calibre9">Stateful Session Beans</strong></span> (<span class="strong"><strong class="calibre9">SFSB</strong></span>) have built-in failover capabilities. This means that the state of <code class="email">@Stateful</code> EJBs is replicated across the cluster nodes so that if one of the nodes in the cluster<a id="id1193" class="calibre1"/> goes down, some other node will be able to take over the invocations addressed to it. It is<a id="id1194" class="calibre1"/> possible to disable this feature for specific beans using the <code class="email">@Stateful(passivationCapable=false)</code> annotation.</p><p class="calibre8">The following diagram depicts a typical exchange of information between the EJB client application and the remote EJB component:</p><div class="mediaobject"><img src="../images/00090.jpeg" alt="Creating HA Stateful Session Beans" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you can see, after a successful lookup of an <a id="id1195" class="calibre1"/>SFSB via <span class="strong"><strong class="calibre9">Java Naming and Directory Interface</strong></span> (<span class="strong"><strong class="calibre9">JNDI</strong></span>), a proxy is returned to the client for subsequent method invocations.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note65" class="calibre1"/>Note</h3><p class="calibre8">Since the EJB is clustered, it will return a session ID and along with it the <span class="strong"><em class="calibre10">affinity</em></span> of that session, that is, the name of the cluster to which the stateful bean belongs to on the server side. This affinity will later help the EJB client to route the invocations on the proxy appropriately to a specific node in the cluster.</p></div><p class="calibre8">While this session creation request is going on, <span class="strong"><strong class="calibre9">NodeA</strong></span> will also send back an asynchronous message that contains the cluster topology. The <a id="id1196" class="calibre1"/>JBoss <span class="strong"><strong class="calibre9">EJB Client</strong></span> implementation will take note of this topology information and will later use it to create connections to the nodes within the cluster and route invocations to those nodes, whenever necessary.</p><p class="calibre8">Now let's assume that <span class="strong"><strong class="calibre9">NodeA</strong></span> goes down and the client application subsequently invokes on the proxy. At this stage, the <span class="strong"><strong class="calibre9">JBoss EJB Client</strong></span> implementation will be aware of the cluster topology; therefore, it knows that the cluster has two nodes: <span class="strong"><strong class="calibre9">NodeA</strong></span> and <span class="strong"><strong class="calibre9">NodeB</strong></span>. Now when the<a id="id1197" class="calibre1"/> invocation arrives, it detects that <span class="strong"><strong class="calibre9">NodeA</strong></span> is down, so it uses a selector to fetch a suitable node from among the cluster nodes. This exchange is shown in the following diagram:</p><div class="mediaobject"><img src="../images/00091.jpeg" alt="Creating HA Stateful Session Beans" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If a suitable node is found, the <span class="strong"><strong class="calibre9">JBoss EJB Client</strong></span> implementation creates a connection to that node (in our case <span class="strong"><strong class="calibre9">NodeB</strong></span>) and creates an EJB receiver out of it. At the end of this process, the invocation has now been effectively failed over to a different node within the cluster.</p><div class="book" title="Clustering the Ticket example"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec77" class="calibre1"/>Clustering the Ticket example</h3></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, we discussed our ticket system example, which was built<a id="id1198" class="calibre1"/> around the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A stateful EJB to hold the session data</li><li class="listitem">A singleton EJB to store the cache of data</li><li class="listitem">A stateless EJB to perform some business methods</li></ul></div><p class="calibre8">Let's see how to apply the necessary changes to start our application in a cluster context.</p><p class="calibre8">The stateless and stateful beans are ready to be clustered—no additional code is required; however, there's a pitfall. As a matter of fact, the singleton EJB that is used to hold the cache of a seat<a id="id1199" class="calibre1"/> will be instantiated once in each JVM of the cluster. This means that if there's a server failure, the data in the cache will be lost and new data (inconsistent) will be used.</p><p class="calibre8">There are several alternatives to set up a cache in a clustered environment:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use a JBoss proprietary solution that deploys a clustered version of <code class="email">SingletonService</code>, which exposes an HA singleton of <code class="email">org.jboss.msc.service.Service</code> (an example of this approach is contained in the <a id="id1200" class="calibre1"/>WildFly quickstart demo at <a class="calibre1" href="https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton">https://github.com/wildfly/quickstart/tree/master/cluster-ha-singleton</a>)</li><li class="listitem">Move your cache to a persistent storage, which means using JPA to store and read data from the cache (see <a class="calibre1" title="Chapter 5. Combining Persistence with CDI" href="part0030_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre10">Combining Persistence with CDI</em></span>, which includes a JPA-based example of our application)</li><li class="listitem">Use a distributed data cache such as Infinispan to store data, providing a failover and data consistency to your cache</li></ul></div><p class="calibre8">Showing all the possible solution implementations would, however, make this section excessively long; therefore, we will illustrate how to use the last option, which can provide a good architectural pattern with the least amount of effort.</p></div><div class="book" title="Turning your cache into a distributed cache"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec78" class="calibre1"/>Turning your cache into a distributed cache</h3></div></div></div><p class="calibre8">Infinispan is a distributed data grid platform that exposes a JSR-107-compatible cache interface in which<a id="id1201" class="calibre1"/> you can store data and enhance it by providing additional APIs and features (such as transactional cache, data eviction and expiration, asynchronous operations on the cache, and more). Its primary interface is <code class="email">javax.cache.Cache</code>, which is similar to the <code class="email">java.util.ConcurrentMap</code> Java SE, with some modifications for distributed environments. In particular, it adds the ability to register, deregister, and list event listeners. Also, it defines a <code class="email">CacheLoader</code> interface to load/store cached data. Cache instances can be retrieved using an appropriate <code class="email">CacheManager</code> interface, which represents a collection of caches.</p><p class="calibre8">So here's our singleton <code class="email">TheatreBox</code> class rewritten using the Infinispan API:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
@AccessTimeout(value = 5, unit = TimeUnit.MINUTES)
public class TheatreBox {

    private static final Logger logger =
            Logger.getLogger(TheatreBox.class);
<span class="strong"><strong class="calibre9">    </strong></span>private Map&lt;Integer, Seat&gt; seats;

<span class="strong"><strong class="calibre9">    @Resource(lookup = "java:jboss/infinispan/tickets")</strong></span>
<span class="strong"><strong class="calibre9">    private EmbeddedCacheManager container;</strong></span>

    @PostConstruct
    public void setupTheatre() {
        try {
            this.cache = container.getCache();
            logger.info("Got Infinispan cache");

            int id = 0;
            for (int i = 0; i &lt; 5; i++) {
                addSeat(new Seat(++id, "Stalls", 40));
                addSeat(new Seat(++id, "Circle", 20));
                addSeat(new Seat(++id, "Balcony", 10));
            }
            logger.info("Seat Map constructed.");
        } catch (Exception e) {
            logger.info("Error! " + e.getMessage());
        }
    }

    private void addSeat(Seat seat) {
        <span class="strong"><strong class="calibre9">seats.put(seat.getId(), seat);</strong></span>
    }

    @Lock(READ)
    public Collection&lt;Seat&gt; getSeats() {
        return Collections.unmodifiableCollection(<span class="strong"><strong class="calibre9">seats.values()</strong></span>);
    }

    @Lock(READ)
    public int getSeatPrice(int seatId) throws NoSuchSeatException {
        return getSeat(seatId).getPrice();
    }

    @Lock(WRITE)
    public void buyTicket(int seatId) throws SeatBookedException, NoSuchSeatException {
        final Seat seat = getSeat(seatId);
        if (seat.isBooked()) {
            throw new SeatBookedException("Seat " + seatId + " already booked!");
        }
        addSeat(seat.getBookedSeat());
    }

    @Lock(READ)
    private Seat getSeat(int seatId) throws NoSuchSeatException {
        final Seat seat = <span class="strong"><strong class="calibre9">cache.get(seatId);</strong></span>
        if (seat == null) {
            throw new NoSuchSeatException("Seat " + seatId + " does not exist!");
        }
        return seat;
    }
}</pre></div><p class="calibre8">The first thing we want to stress on is the <code class="email">@Resource</code> annotation, which injects an <code class="email">EmbeddedCacheManager</code> instance. When the WildFly deployer encounters this annotation, your application<a id="id1202" class="calibre1"/> will include a dependency on the requested cache container. Consequently, the cache container will automatically start during deployment and stop (including all caches) during undeployment of your application.</p><p class="calibre8">Subsequently, when the EJB is instantiated (see the method <code class="email">start</code>, which is annotated as <code class="email">@PostConstruct</code>), <code class="email">org.infinispan.Cache</code> is created using <code class="email">EmbeddedCacheManager </code>as a factory. This cache will be used to store our highly available set of data.</p><p class="calibre8">The operations performed against the distributed cache are quite intuitive: the <code class="email">put</code> method is used to store instances of the <code class="email">Seat</code> object in the cache and the corresponding <code class="email">get</code> method is used to retrieve elements from it, just what you would do using an ordinary hashmap. The only difference is that in our clustered cache, every entry must be serializable. Be sure to mark <code class="email">Seat</code> as <code class="email">Serializable</code> and create a default constructor for it.</p><p class="calibre8">As far as application deployment is concerned, you need to state a dependency to the Infinispan API explicitly, which is not included as an implicit dependency in WildFly's class-loading policy. This is most easily done by adding the following line to your application's <code class="email">META-INF/MANIFEST.MF</code>:</p><div class="informalexample"><pre class="programlisting">Dependencies: org.infinispan export </pre></div><p class="calibre8">We additionally need to add the new cache container to the appropriate profile in our <code class="email">domain.xml </code>file (in the Infinispan subsystem):</p><div class="informalexample"><pre class="programlisting">&lt;cache-container name="tickets" default-cache="default" jndi-name="java:jboss/infinispan/tickets" module="deployment.ticket-agency-cluster.jar"&gt;
&lt;transport lock-timeout="60000"/&gt;
&lt;replicated-cache name="default" batching="true" mode="SYNC"&gt;
&lt;locking isolation="REPEATABLE_READ"/&gt;
&lt;/replicated-cache&gt;
&lt;/cache-container&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note66" class="calibre1"/>Note</h3><p class="calibre8">In our sample, we<a id="id1203" class="calibre1"/> are using the <code class="email">seats.values()</code> call to get all the elements from our distributed map, which is in fact an instance of <code class="email">org.infinispan.Cache</code>. This operation is normally discouraged in distributed caches (not replicated) and has its own limitations. Check out the Javadoc for this method at <a class="calibre1" href="https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values()">https://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/Cache.html#values()</a> for more information. This is however, no longer the case for the newest version of Infinispan: <a class="calibre1" href="http://infinispan.org/infinispan-7.0/">http://infinispan.org/infinispan-7.0/</a>.</p></div></div><div class="book" title="Coding the cluster-aware remote client"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec79" class="calibre1"/>Coding the cluster-aware remote client</h3></div></div></div><p class="calibre8">The remote EJB client will not <a id="id1204" class="calibre1"/>need any particular change in order to be able to achieve high availability.</p><p class="calibre8">We will only need to prepare a <code class="email">jboss-ejb-client.properties</code> file, which will contain the list of servers that will be<a id="id1205" class="calibre1"/> initially contacted (via remoting) by our client application:</p><div class="informalexample"><pre class="programlisting">remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
remote.connections=node1,node2
remote.connection.node1.host=localhost
remote.connection.node1.port = 8080
remote.connection.node1.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false
remote.connection.node2.host=localhost
remote.connection.node2.port = 8280
remote.connection.node2.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false</pre></div><p class="calibre8">As you can see from this file, we assume that you are running a two-node cluster on the <code class="email">localhost</code> address: the first one running the default port settings and the second one using an offset of <code class="email">200</code> (just as shown in the second paragraph of the <span class="strong"><em class="calibre10">Starting a cluster of standalone nodes</em></span> section).</p><p class="calibre8">Replace the <code class="email">remote.connection.nodeX.host</code> variable's value with the actual IP or host if you are running your server nodes on different machines from your client.</p></div><div class="book" title="Deploying and testing high availability"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec80" class="calibre1"/>Deploying and testing high availability</h3></div></div></div><p class="calibre8">Deploying an application to a cluster can be achieved in several ways; if you prefer automation instead <a id="id1206" class="calibre1"/>of manually copying each archive into the <code class="email">deployments</code> folder, you can reuse the CLI deployment script<a id="id1207" class="calibre1"/> contained in the previous chapter.</p><p class="calibre8">Alternatively, if you are using the WildFly Maven plugin to deploy, you can parameterize its configuration, including the hostname and the port as variables, which will be passed to the command line:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
      &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.0.2.Final&lt;/version&gt;
      &lt;configuration&gt;
          &lt;filename&gt;${project.build.finalName}.jar&lt;/filename&gt;
<span class="strong"><strong class="calibre9">          &lt;hostname&gt;${hostname}&lt;/hostname&gt;</strong></span>
<span class="strong"><strong class="calibre9">          &lt;port&gt;${port}&lt;/port&gt; </strong></span>
      &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p class="calibre8">Therefore, you will use the following shell to compile the package and deploy the application on the first node:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn install wildfly:deploy –Dhostname=localhost –Dport=9999</strong></span>
</pre></div><p class="calibre8">For the second node, you will use the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn install wildfly:deploy –Dhostname=localhost –Dport=10194</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note67" class="calibre1"/>Note</h3><p class="calibre8">Deploying the application in the domain node works the same as mentioned in the preceding example, except that you need to add the <code class="email">domain</code> tag to your configuration and need to specify at least one server group. Visit <a class="calibre1" href="https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html">https://docs.jboss.org/wildfly/plugins/maven/latest/examples/deployment-example.html</a> for more information.</p></div><p class="calibre8">Once you have deployed both the applications on your server node, you should be able to see the cluster view in the server console logs and also see that the Infinispan cache has been started and has discovered other nodes in the cluster. You should see something similar to the following on one of the nodes:</p><div class="mediaobject"><img src="../images/00092.jpeg" alt="Deploying and testing high availability" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Before you launch your application, update Maven's <code class="email">exec</code> plugin information, which should now reference our<a id="id1208" class="calibre1"/> remote EJB client application as shown in the highlighted section of the following code<a id="id1209" class="calibre1"/> snippet:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
   &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
   &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
   &lt;version&gt;${version.exec.plugin}&lt;/version&gt;
   &lt;executions&gt;
     &lt;execution&gt;
         &lt;goals&gt;
            &lt;goal&gt;exec&lt;/goal&gt;
         &lt;/goals&gt;
     &lt;/execution&gt;
   &lt;/executions&gt;
   &lt;configuration&gt;
     &lt;executable&gt;java&lt;/executable&gt;
     &lt;workingDirectory&gt;${project.build.directory}/exec-working-directory&lt;/workingDirectory&gt;
     &lt;arguments&gt;
       &lt;argument&gt;-classpath&lt;/argument&gt;
       &lt;classpath&gt;
       &lt;/classpath&gt;
<span class="strong"><strong class="calibre9">       &lt;argument&gt;com.packtpub.wflydevelopment.chapter11.client.TicketAgencyClient&lt;/argument&gt;</strong></span>
     &lt;/arguments&gt;
   &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p class="calibre8">You can run it using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn exec:exec</strong></span>
</pre></div><p class="calibre8">The first part of the<a id="id1210" class="calibre1"/> client will show the evidence that we have successfully completed the first transaction. On the <a id="id1211" class="calibre1"/>client console, you will see the return value of the booking transaction and the <code class="email">Seat</code> list, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00093.jpeg" alt="Deploying and testing high availability" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The following screenshot shows the server node where our EJB client landed:</p><div class="mediaobject"><img src="../images/00094.jpeg" alt="Deploying and testing high availability" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now shut down the preceding server node (<span class="strong"><em class="calibre10">Ctrl</em></span> + <span class="strong"><em class="calibre10">C</em></span> would suffice if you are starting it as a foreground process) and press <span class="strong"><em class="calibre10">Enter</em></span> (or <span class="strong"><em class="calibre10">Return</em></span> on a Mac) on the client application.</p><p class="calibre8">As you can see from the following screenshot, you should see that the session continues to run on the survivor node and correctly displays the session values (the money left). Your client window should also display the updated cache information.</p><div class="mediaobject"><img src="../images/00095.jpeg" alt="Deploying and testing high availability" class="calibre11"/></div><p class="calibre12"> </p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Web application clustering"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec55" class="calibre1"/>Web application clustering</h1></div></div></div><p class="calibre8">Web application clustering involves two aspects: setting up an HTTP load balancer and telling WildFly to make the application's user sessions as HA. How to do the former depends on what load balancer you would choose (<code class="email">mod_cluster</code> is our suggested choice—it is preconfigured and integrates with WildFly out of the box); the latter could not be simpler—just add<a id="id1212" class="calibre1"/> the <code class="email">&lt;distributable/&gt;</code>tag to your application's <code class="email">web.xml</code> file. Whenever a node fails, the user's HTTP session will be handled by another one. If everything goes well, the end user will not know that there was a failure—everything will be handled behind the scenes.</p><p class="calibre8">Let's see how to action both these steps in concrete terms.</p></div>

<div class="book" title="Web application clustering">
<div class="book" title="Load balancing your web applications"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec79" class="calibre1"/>Load balancing your web applications</h2></div></div></div><p class="calibre8">You have several<a id="id1213" class="calibre1"/> choices available in order to achieve load balancing of your HTTP requests. You can opt for a hardware load balancer that sits in front of your cluster of servers or you can choose from the many available software solutions for <a id="id1214" class="calibre1"/>WildFly, which include the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use Apache Tomcat's <code class="email">mod_jk</code> module to route your requests to your nodes</li><li class="listitem">Use Apache <code class="email">mod_proxy</code> that configures Apache to act as a proxy server and forwards requests to WildFly nodes</li><li class="listitem">Use WildFly's built-in solution <code class="email">mod_cluster</code> to achieve dynamic load balancing of your requests</li></ul></div><p class="calibre8">Here, we will illustrate how to get started with <code class="email">mod_cluster</code>—a module for the Apache HTTP server. The advantage of using <code class="email">mod_cluster</code> against other options can be summarized in the following key points:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Dynamic clustering configuration</li><li class="listitem">Server-side pluggable load metrics</li><li class="listitem">Life cycle notifications of the application status</li></ul></div><p class="calibre8">As a matter of fact, when using a standard load balancer such as <code class="email">mod_jk</code>, you have to provide a static list of nodes that is used to spread the load. This is a very limiting factor, especially if you have to deliver upgrades to your configuration by adding or removing nodes; alternatively, you simply need to upgrade software used by single nodes. Besides this, using a flat cluster <a id="id1215" class="calibre1"/>configuration can be tedious and it is prone to errors, especially if the number of cluster nodes is high.</p><p class="calibre8">When using <a id="id1216" class="calibre1"/>
<code class="email">mod_cluster</code>, you can dynamically add or remove nodes from your cluster because cluster nodes are discovered through an advertising mechanism.</p><p class="calibre8">In practice, the <code class="email">mod_cluster</code> libraries on the HTTP side send UDP messages on a multicast group, which is subscribed by WildFly nodes. This allows WildFly nodes to automatically discover HTTP proxies when application life cycle notifications are sent.</p><p class="calibre8">The next diagram illustrates this concept better:</p><div class="mediaobject"><img src="../images/00096.jpeg" alt="Load balancing your web applications" class="calibre11"/></div><p class="calibre12"> </p><div class="book" title="Installing mod_cluster"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec81" class="calibre1"/>Installing mod_cluster</h3></div></div></div><p class="calibre8">The <code class="email">mod_cluster</code> module is<a id="id1217" class="calibre1"/> implemented as a core WildFly module, which is a part of the distribution. On the HTTP side, it is available as a set of libraries installed on the Apache web server.</p><p class="calibre8">On the WildFly side, you can find the <code class="email">mod_cluster</code> module's subsystem already bundled as part of the clustered configuration file. You can locate it in either the <code class="email">standalone-ha.xml</code> file or the <code class="email">standalone-full-ha.xml</code> (and of course in the <code class="email">domain.xml</code> file) configuration file:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;mod-cluster-config advertise-socket="modcluster" connector="ajp"&gt;
   &lt;dynamic-load-provider&gt;
       &lt;load-metric type="cpu"/&gt;
   &lt;/dynamic-load-provider&gt;
  &lt;/mod-cluster-config&gt;
&lt;/subsystem&gt;</pre></div><p class="calibre8">The subsystem <a id="id1218" class="calibre1"/>contains just a bare-bones configuration that references its socket binding through the <code class="email">advertise-socket</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;socket-binding name="modcluster" port="0" multicast-address="224.0.1.105" multicast-port="23364"/&gt;</pre></div><p class="calibre8">On the Apache web server side, we have to install the core libraries that are used to interact with <code class="email">mod_cluster</code>. This is a very simple procedure; just point the browser to the latest <code class="email">mod_cluster</code> release at <a class="calibre1" href="http://www.jboss.org/mod_cluster/downloads">http://www.jboss.org/mod_cluster/downloads</a>. Be sure to choose a version that suits your operating system and architecture (x86 or x64).</p><p class="calibre8">Once the binaries are downloaded, extract the archive to a folder; then, navigate to the extracted folder. The <code class="email">mod_cluster</code> binaries essentially consist of a bundled Apache web server with all the required libraries installed. To preconfigure your installation, be sure to run the <code class="email">\httpd-2.2\bin\installconf.bat</code> file.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note68" class="calibre1"/>Note</h3><p class="calibre8">It is possible to use your own Apache web server 2.2 installation; just pick up the modules from the <code class="email">mod_cluster</code> bundle and copy them to the <code class="email">modules</code> folder of your Apache web server.</p></div><p class="calibre8">If you choose to use your own Apache web server over the bundled one, you have to load the following libraries into your <code class="email">httpd.conf</code> file (the same set is used in the bundled Apache HTTP):</p><div class="informalexample"><pre class="programlisting">LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_ajp_module modules/mod_proxy_ajp.so
LoadModule proxy_http_module modules/mod_proxy_http.so
LoadModule proxy_cluster_module modules/mod_proxy_cluster.so
LoadModule manager_module modules/mod_manager.so
LoadModule slotmem_module modules/mod_slotmem.so
LoadModule advertise_module modules/mod_advertise.so</pre></div><p class="calibre8">Each of these modules covers an important aspect of load balancing, listed as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">mod_proxy</code>, <code class="email">mod_proxy_http</code>, and <code class="email">mod_proxy_ajp</code>: These are the core modules that forward requests to cluster nodes using either the HTTP/HTTPS or AJP protocol</li><li class="listitem"><code class="email">mod_manager</code>: This module<a id="id1219" class="calibre1"/> reads the information from AS 7 and updates the shared memory information in conjunction with <code class="email">mod_slotmem</code></li><li class="listitem"><code class="email">mod_proxy_cluster</code>: This module contains the balancer for <code class="email">mod_proxy</code></li><li class="listitem"><code class="email">mod_advertise</code>: This is an additional module that allows HTTP to advertise via multicast packets—the IP and port—where the <code class="email">mod_cluster</code> module is listening</li></ul></div><p class="calibre8">The next part of the configuration that we need to add is the core load balancing configuration:</p><div class="informalexample"><pre class="programlisting">Listen 192.168.10.1:8888

&lt;VirtualHost 192.168.10.1:8888&gt;
&lt;Location /&gt;
    Order deny,allow
    Deny from all
    Allow from 192.168.10.
&lt;/Location&gt;
  KeepAliveTimeout 60
  MaxKeepAliveRequests 0
  ManagerBalancerName mycluster
  ServerAdvertise On
&lt;/VirtualHost&gt;</pre></div><p class="calibre8">Basically, you have to replace the <code class="email">192.168.10.1</code> IP address with the one that your Apache web server listens for requests and the port value of <code class="email">8888</code> with the one you want to use to communicate with WildFly.</p><p class="calibre8">As it is, the Apache virtual host allows you to have incoming requests from the subnetwork <code class="email">192.168.10</code>.</p><p class="calibre8">The <code class="email">KeepAliveTimeout</code> directive allows you to reuse the same connection within 60 seconds. The number of requests per connection is unlimited since we are setting <code class="email">MaxKeepAliveRequests</code> to <code class="email">0</code>. The <code class="email">ManagerBalancerName</code> directive provides the balancer name for your cluster (defaults to <code class="email">mycluster</code>).</p><p class="calibre8">What's most important for us is the <code class="email">ServerAdvertise</code> directive that is set to <code class="email">On</code> and uses the advertise mechanism to tell WildFly whom it should send the cluster information to.</p><p class="calibre8">This option is disabled in the bundled server by default. Be sure to uncomment the <code class="email">ServerAdvertise</code> directive in its <code class="email">httpd.conf</code> file.</p><p class="calibre8">Now, restart the Apache <a id="id1220" class="calibre1"/>web server and the single application server nodes. If you have correctly configured the mode cluster on the HTTP side, you will see that each WildFly node will start receiving UDP multicast messages from <code class="email">mod_cluster</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note69" class="calibre1"/>Note</h3><p class="calibre8">If you are running on a Windows machine, be sure to run your web server as an administrator.</p></div><p class="calibre8">If everything goes well, you can visit <code class="email">http://127.0.0.1:6666/mod_cluster_manager</code> to see the status of your load balancer and the interconnected nodes. Be sure to not use Google Chrome for this because it considers the <code class="email">6666</code> port as an unsecure one (it is an IRC port by default). You should see the following information on the simple webpage:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mod_cluster/1.2.6.Final</strong></span>
<span class="strong"><strong class="calibre9">Auto Refresh show DUMP output show INFO output </strong></span>
<span class="strong"><strong class="calibre9">Node michal-pc (ajp://localhost:8009): </strong></span>
<span class="strong"><strong class="calibre9">Enable Contexts Disable ContextsBalancer: mycluster,LBGroup: ,Flushpackets: Off,Flushwait: 10000,Ping: 10000000,Smax: 65,Ttl: 60000000,Status: OK,Elected: 0,Read: 0,Transferred: 0,Connected: 0,Load: 100</strong></span>
</pre></div><p class="calibre8"><span class="strong"><strong class="calibre9">If you don't have a running WildFly instance </strong></span>now, be sure to start it with one of the full-HA configuration files. Refresh Apache's configuration web page after the server is up.</p></div><div class="book" title="Clustering your web applications"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch11lvl3sec82" class="calibre1"/>Clustering your web applications</h3></div></div></div><p class="calibre8">Clustering web applications<a id="id1221" class="calibre1"/> requires the least amount of effort to be put in by the developer. As we have just discussed, all you need to do to switch on clustering in a web application is to add the following directive to the <code class="email">web.xml</code> descriptor:</p><div class="informalexample"><pre class="programlisting">&lt;web-app&gt;
<span class="strong"><strong class="calibre9">  &lt;distributable/&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p class="calibre8">Once your application ships with the distributable stanza in it, the cluster will start, and provided you have correctly designed your session layer, it will be load balanced and fault tolerant as well.</p><p class="calibre8">You could check it out by pointing the browser to your HTTP proxy. For the default setup, it would be <code class="email">http://localhost:6666/your_web_application/</code>.</p><div class="book" title="Programming considerations to achieve HA"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec11" class="calibre1"/>Programming considerations to achieve HA</h4></div></div></div><p class="calibre8">In order to support in-memory replication of HTTP session states, all servlets and JSP session data must be<a id="id1222" class="calibre1"/> serializable.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note70" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Serialization</strong></span> is the<a id="id1223" class="calibre1"/> conversion of an object to a series of bytes so that the object can be easily saved to a persistent storage or streamed across a communication link. The byte stream can then be deserialized, converting the stream into a replica of the original object.</p></div><p class="calibre8">Additionally, in<a id="id1224" class="calibre1"/> an HTTP servlet that implements <code class="email">javax.servlet.http.HttpSession</code>, you need to use the <code class="email">setAttribute</code> method to change the attributes in a session object. If you set the attributes in a session object with <code class="email">setAttribute</code>, by default the object and its attributes are replicated using the Infinispan API. Every time a change is made to an object that is in the session, <code class="email">setAttribute</code> should be called to update that object across the cluster.</p><p class="calibre8">Likewise, you need to use <code class="email">removeAttribute</code> to remove an attribute from a session object.</p></div><div class="book" title="Achieving HA in JSF applications"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch11lvl4sec12" class="calibre1"/>Achieving HA in JSF applications</h4></div></div></div><p class="calibre8">In the applications<a id="id1225" class="calibre1"/> included in this book, we have used JSF and the CDI API to manage the web session. In this case, we<a id="id1226" class="calibre1"/> transparently replicate the other server nodes to the beans, which are marked as <code class="email">@SessionScoped</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note71" class="calibre1"/>Note</h3><p class="calibre8">Clustering JSF-based applications requires special attention if you are dealing with both HTTP and EJB sessions created by SFSB. In the earlier servlet-centric frameworks, the usual approach was to store references of Stateful Session Beans in <code class="email">javax.servlet.http.HttpSession</code>. When dealing with high-level JSF and CDI Beans, it is vital to provide a <code class="email">@SessionScoped</code> controller to your application, which gets injected in the SFSB reference; otherwise, you will end up creating a new Stateful Session Beans upon each request.</p></div><p class="calibre8">The following is an example of how to adapt your Ticket CDI application (described in <a class="calibre1" title="Chapter 4. Learning Context and Dependency Injection" href="part0028_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre10">Learning Context and Dependency Injection</em></span>) to a clustered environment. At first, as we said, we need to include the distributable stanza in your <code class="email">web.xml</code> file to trigger clustering modules:</p><div class="informalexample"><pre class="programlisting">&lt;web-app&gt;
    &lt;distributable/&gt;
&lt;/web-app&gt;</pre></div><p class="calibre8">Next, apply the same changes to the <code class="email">TheatreBox</code> singleton that we described in the <span class="strong"><em class="calibre10">Turning your cache into a distributed cache</em></span> section:</p><div class="informalexample"><pre class="programlisting">@Singleton
@Startup
public class TheatreBox {

<span class="strong"><strong class="calibre9">    @Resource(lookup="java:jboss/infinispan/container/cluster")</strong></span>
<span class="strong"><strong class="calibre9">    private CacheContainer container;</strong></span>

    // Apply the same changes described in
    // "Turning your Cache into a distributed cache section
}</pre></div><p class="calibre8">Since our controller component is bound to a <code class="email">@SessionScoped</code> state, you don't need to apply any changes in order to propagate your session across server nodes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@Named</strong></span>
<span class="strong"><strong class="calibre9">@SessionScoped</strong></span>
public class TheatreBooker implements Serializable {
}</pre></div><p class="calibre8">Finally, remember to<a id="id1227" class="calibre1"/> include the Infinispan dependency in your <code class="email">META-INF/MANIFEST.MF</code>:</p><div class="informalexample"><pre class="programlisting">Dependencies: org.infinispan export</pre></div><p class="calibre8">Once your<a id="id1228" class="calibre1"/> application is deployed on both the nodes of your cluster, you can test it by hitting the Apache web server (<code class="email">http://localhost:6666/ticket-agency-cluster</code> in our example) and start booking tickets:</p><div class="mediaobject"><img src="../images/00097.jpeg" alt="Achieving HA in JSF applications" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Since the <code class="email">mod_cluster</code> subsystem is configured to <a id="id1229" class="calibre1"/>use <span class="strong"><strong class="calibre9">sticky web sessions</strong></span> by default, all subsequent<a id="id1230" class="calibre1"/> requests from<a id="id1231" class="calibre1"/> the same client will be redirected to the same server node. Therefore, by shutting down the sticky server node, you will get evidence that a new cluster view has been created and you can continue shopping on the other server node.</p><div class="mediaobject"><img src="../images/00098.jpeg" alt="Achieving HA in JSF applications" class="calibre11"/></div><p class="calibre12"> </p></div></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec56" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter was all about the world of clustered applications. Here, we took you through the robust clustering features of WildFly and applied them to some of the examples discussed in this book.</p><p class="calibre8">The number of topics related to clustering might be expanded to cover a full book of its own; however, we decided to stress only on some features. In particular, we learned how to cluster EJBs and achieve fault tolerance in case there is a change in the server topology.</p><p class="calibre8">Next, we discussed clustering web applications and the integration with load balancing solutions such as the Apache web server and <code class="email">mod_cluster</code>.</p><p class="calibre8">In the next chapter, we will focus on some new topics added to Java EE 7 related to long-term task execution: batch processing and concurrency utilities' usage.</p></div></body></html>