- en: Accessing Database with Spring ORM and Transactions Implementing Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring ORM 和事务实现模式访问数据库
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, we have learned how to access database
    using JBDC and how Spring can remove boilerplate code from the developer end to
    the framework by using template pattern and callbacks. In this chapter, we will
    learn one advanced step of accessing database using the **Object Relational Mapping**
    (**ORM**) Framework and managing transactions across the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml)，“使用 Spring 和 JDBC 模板模式访问数据库”，我们学习了如何使用
    JBDC 访问数据库以及 Spring 如何通过使用模板模式和回调从开发人员端到框架端移除样板代码。在本章中，我们将学习使用 **对象关系映射**（**ORM**）框架访问数据库并管理应用程序中事务的更高级步骤。
- en: When my son, Arnav, was one and a half years old, he used to play with a dummy
    mobile phone. But as he grew up, his needs too outgrew dummy mobiles to smartphones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的儿子 Arnav 一岁半的时候，他经常玩一个模拟手机。但随着他长大，他的需求也超出了模拟手机，变成了智能手机。
- en: Similarly, when your application has a small set of data for a business tier,
    then JDBC works fine, but as your application grows and becomes more complex,
    it becomes difficult to map tables to the objects in the application. JDBC is
    the dummy small phone of the data access world. But with complex applications,
    we need Object Relational Mapping solutions that are able to map object properties
    to database columns. We also need more sophisticated platforms for our application
    at the data access layer, which create the queries and statements independently
    from the database technologies for us, and which we can define declaratively or
    programmatically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你的应用程序在业务层只有少量数据时，JDBC 工作得很好，但随着应用程序的增长和复杂化，将表映射到应用程序中的对象变得困难。JDBC 是数据访问世界中的小型模拟手机。但是，对于复杂的应用程序，我们需要能够将对象属性映射到数据库列的对象关系映射解决方案。我们还需要在数据访问层为我们的应用程序提供更复杂的平台，这些平台可以独立于数据库技术为我们创建查询和语句，并且我们可以声明式或程序化地定义它们。
- en: Many ORM Frameworks are available to provide services at the data access layer
    of an application. Examples of such services include object relational mapping,
    lazy loading of data, eager loading of data, cascading, and so on. These ORM services
    save you from writing a lot of code for error handling, and managing resources
    in the application. The ORM Frameworks decrease the development time, and help
    to write error-free code, so that you just focus on the business requirements
    only. Spring doesn't implement its own ORM solution, but it provides support for
    many persistence frameworks such as Hibernate, the **Java Persistence API** (**JPA**),
    iBATIS, and **Java Data Objects** (**JDO)**. Spring also provides integration
    points to the ORM Frameworks so that we can easily integrate the ORM Framework
    in our Spring application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 ORM 框架可用于为应用程序的数据访问层提供服务。此类服务的例子包括对象关系映射、数据的延迟加载、数据的预加载、级联等。这些 ORM 服务让您免于编写大量用于错误处理和应用程序资源管理的代码。ORM
    框架减少了开发时间，并有助于编写无错误的代码，这样您就可以只关注业务需求。Spring 不实现自己的 ORM 解决方案，但它为 Hibernate、**Java
    持久化 API**（**JPA**）、iBATIS 和 **Java 数据对象**（**JDO**）等许多持久化框架提供支持。Spring 还提供了与 ORM
    框架的集成点，以便我们可以轻松地将 ORM 框架集成到我们的 Spring 应用程序中。
- en: 'Spring provides support for all these technologies in your application. In
    this chapter, we will explore Spring''s support for ORM solutions, and cover the
    following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 在您的应用程序中为所有这些技术提供支持。在本章中，我们将探讨 Spring 对 ORM 解决方案的支持，并涵盖以下主题：
- en: ORM Framework and used patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 框架和使用的模式
- en: The data access object pattern
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问对象模式
- en: Creating DAOs using the Factory design pattern in Spring
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring 中使用工厂设计模式创建 DAO
- en: The Data Mapper pattern
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据映射模式
- en: The domain model pattern
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型模式
- en: Proxy for the lazy loading pattern
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载模式的代理
- en: The Hibernate template pattern
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 模板模式
- en: Integrating Hibernate with Spring
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Hibernate 与 Spring 集成
- en: Configuring Hibernate's `SessionFactory` in a Spring container
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring 容器中配置 Hibernate 的 `SessionFactory`
- en: Implementing DAOs based on plain Hibernate API
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于纯 Hibernate API 实现 DAO
- en: Transaction management strategies in Spring
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 中的事务管理策略
- en: Declarative transaction implementation and demarcation
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式事务实现和划分
- en: Programmatic transaction implementation and demarcation
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化事务实现和划分
- en: Best practices for Spring ORM and transaction modules in the application
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中 Spring ORM 和事务模块的最佳实践
- en: Before we go on to discuss more about the ORM Frameworks, let's first look at
    some design patterns used in the **data access layer** (**DAL**) of the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论更多关于ORM框架的内容之前，让我们首先看看应用中**数据访问层（DAL**）所使用的一些设计模式。
- en: ORM Framework and the patterns used
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM框架和使用的模式
- en: 'Spring provides support for several ORM Frameworks, such as Hibernate, the
    **Java Persistence API** (**JPA**), iBATIS, and **Java Data Objects** (**JDO**).
    By using any ORM solution in your application, you can easily persist and access
    data in the form of POJO objects from relational databases. The Spring ORM module
    is an extension of the previously discussed Spring JDBC DAO module. Spring provides
    ORM templates, such as JDBC-based templates, to work in the integration tier or
    data access layer. The following are the ORM Frameworks and integration supported
    by the Spring Framework:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持多个ORM框架，例如Hibernate、**Java持久化API（JPA**）、iBATIS和**Java数据对象（JDO**）。通过在应用中使用任何ORM解决方案，您可以轻松地将关系数据库中的数据持久化和以POJO对象的形式访问。Spring
    ORM模块是之前讨论的Spring JDBC DAO模块的扩展。Spring提供了ORM模板，如基于JDBC的模板，以在集成层或数据访问层中工作。以下是Spring框架支持的ORM框架和集成：
- en: Hibernate
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate
- en: Java Persistence API
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java持久化API
- en: Java Data Objects
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java数据对象
- en: iBATIS
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iBATIS
- en: Data access object implementations
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问对象实现
- en: Transaction strategies
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务策略
- en: 'You can use Spring''s dependency injection feature to configure ORM solutions
    in your application. Spring also adds important enhancements to the ORM layer
    in your data access applications. The following are the benefits of using the
    Spring Framework to create your ORM DAOs:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Spring的依赖注入功能来配置应用中的ORM解决方案。Spring还为您数据访问应用中的ORM层添加了重要的增强功能。以下是在创建ORM DAO时使用Spring框架的好处：
- en: '**Easier development and testing**: Spring''s IoC container manages the beans
    for ORM DAOs. You can easily swap the implementation of the DAO interface by using
    Spring''s dependency injection feature. It also makes it easy to test persistence-related
    code in isolation.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易于开发和测试**：Spring的IoC容器管理ORM DAO的bean。您可以通过使用Spring的依赖注入功能轻松地交换DAO接口的实现。它还使得在隔离环境中测试持久化相关代码变得容易。'
- en: '**Common data access exceptions**: Spring provides a consistent data exception
    hierarchy to handle exceptions at the persistence layer. It wraps all the checked
    exceptions from the ORM tool, and converts these exceptions to unchecked general
    exceptions which are not related to any specific ORM solution and are DB-specific.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见数据访问异常**：Spring提供了一致的数据异常层次结构，以处理持久化层的异常。它封装了ORM工具的所有已检查异常，并将这些异常转换为与任何特定ORM解决方案无关的未检查的一般异常，这些异常是数据库特定的。'
- en: '**General resource management**: Resources such as `DataSource`, DB connections,
    Hibernates `SessionFactory`, JPA `EntityManagerFactory`, and others are managed
    by the Spring IoC container. Spring also manages transactions--local or global--using
    JTA.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用资源管理**：如`DataSource`、数据库连接、Hibernate的`SessionFactory`、JPA的`EntityManagerFactory`等资源由Spring
    IoC容器管理。Spring还使用JTA管理本地或全局事务。'
- en: '**Integrated transaction management**: Spring provides declarative and programmatic
    transaction management in your application. For declarative transaction management,
    you can use the `@Transactional` annotation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成事务管理**：Spring在您的应用中提供了声明式和程序式事务管理。对于声明式事务管理，您可以使用`@Transactional`注解。'
- en: The main approach to Spring's integration with the ORM solution is loose coupling
    between the application's layers; that is, the business layer and the data access
    layer. It is clear application layering, and is independent of any specific database
    and transaction technology. Business services in the application are no longer
    dependent on data access and a specific transaction strategy. Because Spring manages
    the resources used in the integration layer, you don't need to look up resources
    for specific data access technologies. Spring provides templates for the ORM solution
    to remove the boilerplate codes, and it provides a consistent approach across
    all ORM solutions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Spring与ORM解决方案的集成主要采用应用层之间的松耦合方式；也就是说，业务层和数据访问层。这是一种清晰的应用分层，且独立于任何特定的数据库和事务技术。应用中的业务服务不再依赖于数据访问和特定的交易策略。因为Spring管理了集成层中使用的资源，所以您不需要为特定的数据访问技术查找资源。Spring为ORM解决方案提供了模板，以移除样板代码，并且为所有ORM解决方案提供了一致的方法。
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, you saw how Spring solves two major problems
    of the integration layer in the application. The first problem was *redundant
    code for managing resources from the application*, and the second problem was
    *handling checked exceptions* in the application at development time. Similarly,
    the Spring ORM module also provides solutions to these two problems, as we'll
    discuss in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml)“使用Spring和JDBC模板模式访问数据库”中，你看到了Spring如何解决应用程序集成层中的两个主要问题。第一个问题是*管理应用程序资源时的冗余代码*，第二个问题是*在开发时处理检查异常*。同样，Spring
    ORM模块也提供了这两个问题的解决方案，我们将在以下章节中讨论。
- en: Resource and transaction management
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和事务管理
- en: In the Spring JDBC module, resources such as connection handling, statements
    handling, and exceptions handling are managed by the Spring's JdbcTemplate. It
    also translates SQL error codes of the database specific to meaningful unchecked
    exception classes. The same is true for the Spring ORM module--Spring manages
    both local and global transactions in the enterprise application by using the
    respective Spring transaction managers. Spring provides transaction managers for
    all supported ORM technologies. For example, Spring offers the Hibernate transaction
    manager for Hibernate, the JPA transaction manager for JPA, and JTA support for
    global or distributed transactions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring JDBC模块中，资源管理，如连接处理、语句处理和异常处理，由Spring的JdbcTemplate管理。它还翻译数据库特定的SQL错误代码为有意义的非检查异常类。对于Spring
    ORM模块也是如此--Spring通过使用相应的Spring事务管理器在企业应用程序中管理本地和全局事务。Spring为所有支持的ORM技术提供事务管理器。例如，Spring为Hibernate提供Hibernate事务管理器，为JPA提供JPA事务管理器，并为全局或分布式事务提供JTA支持。
- en: Consistent exception handling and translation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致的异常处理和转换
- en: 'In the Spring JDBC module, Spring provides `DataAccessException` to handle
    all types of database-specific SQL error code, and generates meaningful exception
    classes. In the Spring ORM module, as we already know, Spring supports integration
    for several ORM solutions, such as Hibernate, JPA, or JDO in a DAO, and these
    persistence technologies provide their own native exception classes as `HibernateException`,
    `PersistenceException`, or `JDOException` depending on the technology. These native
    exceptions of the ORM Frameworks are unchecked exceptions, so we don''t have to
    handle them in the application. The caller of the DAO services cannot do specific
    handling unless the application is strongly ORM based, or does not need any special
    exception treatment. Spring provides a consistent approach throughout the ORM
    Frameworks; you don''t need to implement specific code for any ORM in a Spring
    application. It enables exception translation by using the `@Repository` annotation.
    If any class in the Spring application is annotated with `@Repository` annotation,
    then that class is eligible for Spring `DataAccessException` translation. Take
    for example the following code for the `AccountDaoImpl` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring JDBC模块中，Spring提供了`DataAccessException`来处理所有类型的数据库特定的SQL错误代码，并生成有意义的异常类。在Spring
    ORM模块中，正如我们所知，Spring支持多个ORM解决方案的集成，例如在DAO中使用Hibernate、JPA或JDO，这些持久化技术根据技术提供自己的原生异常类，如`HibernateException`、`PersistenceException`或`JDOException`。这些ORM框架的原生异常是不受检查的异常，因此我们不需要在应用程序中处理它们。除非应用程序是强ORM基础，或者不需要任何特殊的异常处理，否则DAO服务的调用者无法进行特定的处理。Spring在整个ORM框架中提供了一致的方法；在Spring应用程序中，你不需要为任何ORM实现特定的代码。它通过使用`@Repository`注解来实现异常转换。如果Spring应用程序中的任何类被`@Repository`注解标注，那么这个类就有资格进行Spring
    `DataAccessException`的转换。以下是一个针对`AccountDaoImpl`类的示例代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code, the `PersistenceExceptionTranslationPostProcessor`
    class is a bean `post processor`, which automatically searches for all exception
    translators and also advises all the registered beans annotated with the `@Repository`
    annotation in the container. It applies the discovered exception translators to
    those annotated beans, and these translators can intercept and apply the appropriate
    translation on the thrown exceptions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`PersistenceExceptionTranslationPostProcessor`类是一个bean后处理器，它自动搜索所有异常转换器，并在容器中建议所有标注了`@Repository`注解的已注册bean。它将这些发现的异常转换器应用于这些标注的bean，并且这些转换器可以拦截并适当地转换抛出的异常。
- en: Let's see some more design patterns that are implemented in the Spring ORM module
    to provide the best enterprise solution for the integration tier of an enterprise
    application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring ORM模块中实现的一些更多设计模式，以提供企业应用集成层最佳的企业解决方案。
- en: The data access object pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问对象模式
- en: The **data access object** (**DAO**) pattern is a very popular design pattern
    for the persistent layer in a J2EE application. It separates the business logic
    layer and persistence layer. The DAO pattern is based on the encapsulation and
    abstraction object-oriented principles. The context for using the DAO pattern
    is to access and persist data depending on the underlying vendor implementation
    and type of storage, such as object-oriented database, flat files, relational
    databases, and so on. Using the DAO pattern, you can create a DAO interface, and
    implement this DAO interface to abstract and encapsulate all access to the data
    source. This DAO implementation manages the database's resources like connections
    with the data source.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据访问对象**（**DAO**）模式是J2EE应用持久层中一个非常流行的设计模式。它将业务逻辑层和持久层分离。DAO模式基于封装和抽象的面向对象原则。使用DAO模式的环境是根据底层供应商实现和存储类型（如面向对象数据库、平面文件、关系数据库等）来访问和持久化数据。使用DAO模式，你可以创建一个DAO接口，并实现这个DAO接口来抽象和封装对数据源的所有访问。这个DAO实现管理数据库的资源，如与数据源的连接。'
- en: 'The DAO interfaces are very generic to all the underlying data source mechanisms,
    and don''t need to change for any changes in the low-level persistence technologies.
    This pattern allows you to adopt any different data access technologies without
    affecting the business logic in the enterprise application. Let''s see the following
    figure to understand more about the DAO pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DAO接口对所有底层数据源机制都非常通用，并且不需要为任何低级持久技术的变化而改变。这个模式允许你在不影响企业应用中的业务逻辑的情况下采用任何不同的数据访问技术。让我们看看以下图表来了解DAO模式：
- en: '![](img/708d83c8-8fe7-4581-8629-133da0d44194.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/708d83c8-8fe7-4581-8629-133da0d44194.png)'
- en: 'As you can see in the preceding diagram, the following participants work on
    this pattern:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，以下参与者参与了这个模式：
- en: '**BusinessObject**: This object works on the business layer, and is a client
    for the data access layer. It requires data for business modeling, and for preparing
    Java objects for the helper or controllers in the application.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BusinessObject**：这个对象在业务层工作，是数据访问层的客户端。它需要数据来进行业务建模，并为应用中的辅助器或控制器准备Java对象。'
- en: '**DataAccessObject**: This is a primary object of the DAO pattern. This object
    hides all the low-level implementation of the underlying database implementation
    for the **BusinessObject**.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DataAccessObject**：这是DAO模式的主要对象。这个对象隐藏了所有底层数据库实现（针对**BusinessObject**）的低级实现。'
- en: '**DataSource**: This is also an object to contain all the low-level information
    about the underlying database implementation, such as an RDBMS, flat files, or
    XML.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DataSource**：这也是一个对象，用于包含关于底层数据库实现的所有低级信息，如RDBMS、平面文件或XML。'
- en: '**TransferObject**: This is also an object, and it is used as a data carrier.
    This object is used by **DataAccessObject** to return data to the business object.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TransferObject**：这是一个对象，用作数据载体。这个对象被**DataAccessObject**用来将数据返回给业务对象。'
- en: 'Let''s see the following example of the DAO pattern, where `AccountDao` is
    a `DataAccessObject` interface, and `AccountDaoImpl` is the implementation class
    of the `AccountDao` interface:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下DAO模式的示例，其中`AccountDao`是`DataAccessObject`接口，而`AccountDaoImpl`是`AccountDao`接口的实现类：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating DAOs using the Factory design pattern in Spring
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring中使用工厂设计模式创建DAO
- en: As we know, there are a lot of design patterns that play a role in the Spring
    Framework. As discussed in [Chapter 2](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml),
    *Overview of GOF Design Patterns*--Core Design patterns, the Factory pattern is
    a creational design pattern, and it is used to create an object without exposing
    the underlying logic to the client, and to assign a new object to the caller using
    a common interface or abstract class. You can make the DAO pattern highly flexible
    by using the `Factory` method and Abstract Factory design patterns.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，有很多设计模式在Spring框架中发挥作用。如[第2章](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml)“GOF设计模式概述”中讨论的，*核心设计模式*，工厂模式是一种创建型设计模式，它用于在不向客户端暴露底层逻辑的情况下创建对象，并使用公共接口或抽象类将新对象分配给调用者。你可以通过使用`Factory`方法和抽象工厂设计模式使DAO模式更加灵活。
- en: 'Let''s see in our example where do we are implementing this strategy in which
    a factory produces the DAOs for a single database implementation. Please refer
    to the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的例子中，我们是在哪里实现这个策略，即一个工厂为单个数据库实现生成DAO。请参考以下图表：
- en: '![](img/e6b56aff-d1ff-40e2-96a5-ef320074a864.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6b56aff-d1ff-40e2-96a5-ef320074a864.png)'
- en: You can see in the preceding diagram that the **AccountDao** object is produced
    by **AccountDaoFactory**, and **AccountDaoFactory** is a factory for **AccountDao**.
    We can change the underlying database at any time such that we do not need to
    change the business code--the factory takes care of these things, Spring provides
    support to maintain all the DAOs in the bean factory and in the factory for DAOs
    as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的图表中看到，**AccountDao**对象是由**AccountDaoFactory**生成的，而**AccountDaoFactory**是**AccountDao**的工厂。我们可以随时更改底层数据库，这样我们就不需要更改业务代码--工厂负责这些事情，Spring提供了在bean工厂和DAO工厂中维护所有DAO的支持。
- en: The Data Mapper pattern
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据映射模式
- en: '*A layer of Mappers that moves data between objects and a database while keeping
    them independent of each other and the mapper itself*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*一层映射器，它在对象和数据库之间移动数据，同时保持它们彼此以及映射器本身的独立性*。'
- en: '- By **Martin Fowler**: Patterns of Enterprise Application Architecture'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '- 由**马丁·福勒**：《企业应用架构模式》'
- en: 'The ORM Framework provides mapping between the object and relational databases,
    because we know that Objects and tables in the relational databases have different
    ways of storing the data for the application. Also, objects and tables have mechanisms
    for structuring data. In your Spring application, if you use any ORM solution
    such as Hibernate, JPA, or JDO, then you don''t need worry about the mapping mechanism
    between the object and relational databases. Let''s see the following diagram
    to understand more about the Data Mapper pattern:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架提供了对象和关系型数据库之间的映射，因为我们知道，对象和关系型数据库中的表在为应用程序存储数据时有不同的方式。此外，对象和表都有结构化数据的方法。在你的Spring应用程序中，如果你使用任何ORM解决方案，如Hibernate、JPA或JDO，那么你就不需要担心对象和关系型数据库之间的映射机制。让我们通过以下图表来了解数据映射模式：
- en: '![](img/fc8e63e5-0863-4dc2-ac2f-4cd902fc4f45.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc8e63e5-0863-4dc2-ac2f-4cd902fc4f45.png)'
- en: As shown in the preceding diagram, **Account**, an object, is mapped to the
    relational database through **AccountMapper**. It works like a mediator layer
    between the Java object and the underlying database in the application. Let's
    see another pattern used in the data access layer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，对象**Account**通过**AccountMapper**映射到关系型数据库。它就像Java对象和应用程序中底层数据库之间的中介层。让我们看看数据访问层中使用的另一个模式。
- en: The domain model pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型模式
- en: An object model of the domain that incorporates both behaviour and data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 领域对象模型，它结合了行为和数据。
- en: '-by Martin Fowler: Patterns of Enterprise Application Architecture'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '- 由马丁·福勒：《企业应用架构模式》'
- en: 'A domain model is an object that has behavior and data, so, the behavior defines
    the business logic of the enterprise application, and data is information about
    the business''s output. A domain model combines data and process. In an enterprise
    application, data model lies under the business layer to insert the business logic,
    and it returns data from the business behaviors. Let''s see the following diagram
    for more clarity on this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型是一个具有行为和数据的对象，因此，行为定义了企业应用的业务逻辑，而数据是关于业务输出的信息。领域模型结合了数据和过程。在企业应用中，数据模型位于业务层之下，以插入业务逻辑，并从业务行为返回数据。让我们通过以下图表来更清晰地了解这一点：
- en: '![](img/8c41779b-59fc-49c8-be22-75ff9b2b98c7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c41779b-59fc-49c8-be22-75ff9b2b98c7.png)'
- en: As you can see in the preceding diagram, we have defined two domain models in
    our application as per as our business requirements. Business behavior for transferring
    money from one account to another account has been defined in the **TransferService**
    class. The classes **TransferService** and **AccountService** come under the domain
    model pattern in the enterprise application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们根据业务需求在我们的应用程序中定义了两个领域模型。将资金从一个账户转移到另一个账户的业务行为已在 `TransferService` 类中定义。`TransferService`
    和 `AccountService` 类属于企业应用程序中的领域模型模式。
- en: Proxy for the lazy loading pattern
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载模式的代理
- en: Lazy loading is a design pattern, and this design pattern is used by some ORM
    solutions such as Hibernate in the enterprise application to defer initialization
    of an object until it is called by another object at a point where it is needed.
    The purpose of this design pattern is memory optimization in the application.
    The lazy loading design pattern in Hibernate is achieved by using a virtual proxy
    object. In Lazy loading demonstration, we use a proxy, but this is not part of
    the proxy pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是一种设计模式，这种设计模式在企业应用程序中由一些 ORM 解决方案（如 Hibernate）使用，以延迟对象的初始化，直到它被另一个对象在需要时调用。这种设计模式的目的在于优化应用程序的内存。Hibernate
    中的懒加载设计模式是通过使用虚拟代理对象实现的。在懒加载演示中，我们使用了一个代理，但这不是代理模式的一部分。
- en: Spring's Hibernate template pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 的 Hibernate 模板模式
- en: Spring provides a helper class to access data in the DAO layer--this class is
    based on the GoF template method design pattern. Spring provides the `HibernateTemplate`
    class for providing database operations such as `save`, `create`, `delete`, and
    `update`. The `HibernateTemplate` class ensures that only one Hibernate session
    is used per transaction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个辅助类来访问 DAO 层的数据--这个类基于 GoF 模板方法设计模式。Spring 提供了 `HibernateTemplate`
    类，用于提供数据库操作，如 `save`、`create`、`delete` 和 `update`。`HibernateTemplate` 类确保每个事务只使用一个
    Hibernate 会话。
- en: Let's see Spring's support for Hibernate in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看 Spring 对 Hibernate 的支持。
- en: Integrating Hibernate with Spring
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Hibernate 与 Spring 集成
- en: Hibernate is a persistence ORM Framework, it is open source, and it provides
    not only simple object relationship mapping between Java objects and database
    tables, but also provides a lot of sophisticated features for your application
    to improve performance, and helps in better resource utilization such as caching,
    lazy loading, eager fetching, and distributed caching.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 是一个持久化 ORM 框架，它是开源的，不仅提供了 Java 对象和数据库表之间的简单对象关系映射，而且还为您的应用程序提供了许多高级功能，以改进性能，并有助于更好地利用资源，如缓存、懒加载、预加载和分布式缓存。
- en: Spring Framework provides full support to integrate the Hibernate Framework,
    and Spring has some inbuilt libraries for full utilization of the Hibernate Framework.
    We can use Spring's DI pattern and IoC container to configure Hibernate in your
    application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了对 Hibernate 框架的全面支持，Spring 还内置了一些库以充分利用 Hibernate 框架。我们可以使用 Spring
    的 DI 模式和 IoC 容器来配置应用程序中的 Hibernate。
- en: Let's see in the following section how to configure Hibernate in the Spring
    IoC container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看如何在 Spring IoC 容器中配置 Hibernate。
- en: Configuring Hibernate's SessionFactory in a Spring container
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring 容器中配置 Hibernate 的 SessionFactory
- en: 'As the best approach for configuring Hibernate and other persistence technologies
    in any enterprise application, business objects should be separate from the hard-coded
    resource lookups such as a JDBC `DataSource` or Hibernate `SessionFactory`. You
    can define these resources as beans in the Spring container. But business objects
    require the references of these resources, such as `SessionFactory` and JDBC `DataSource`,
    to access them. Let''s see the following DAO class which has `SessionFactory`
    to access data for the application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在任何企业应用程序中配置 Hibernate 和其他持久化技术的最佳方法，业务对象应与硬编码的资源查找（如 JDBC `DataSource` 或
    Hibernate `SessionFactory`）分离。您可以在 Spring 容器中将这些资源定义为 bean。但是，业务对象需要这些资源的引用，如
    `SessionFactory` 和 JDBC `DataSource`，以便访问它们。让我们看看以下具有 `SessionFactory` 以访问应用程序数据的
    DAO 类：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the preceding code, the DAO class, `AccountDaoImpl`, follows
    the dependency injection pattern. It is injected with Hibernate's `SessionFactory`
    object to access the data, and fits nicely into a Spring IoC container. Here,
    Hibernate's `SessionFactory` is singleton object; it produces the main object
    of `org.hibernate.Session` interface of Hibernate. `SessionFactory` manages the
    `Session` object of Hibernate, and is also responsible for opening and closing
    the `Session` object. The `Session` interface has actual data-access functionality
    such as `save`, `update`, `delete`, and `load` objects from the database. In the
    application, `AccountDaoImp` or any other repository uses this Hibernate `Session`
    object to perform all of its persistence needs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，DAO 类 `AccountDaoImpl` 遵循依赖注入模式。它通过注入 Hibernate 的 `SessionFactory`
    对象来访问数据，并且很好地适应了 Spring IoC 容器。在这里，Hibernate 的 `SessionFactory` 是一个单例对象；它生成 Hibernate
    `org.hibernate.Session` 接口的主对象。`SessionFactory` 管理Hibernate的 `Session` 对象，并负责打开和关闭
    `Session` 对象。`Session` 接口具有实际的数据访问功能，如 `save`、`update`、`delete` 和从数据库中加载 `load`
    对象。在应用程序中，`AccountDaoImp` 或任何其他存储库使用这个 Hibernate `Session` 对象来执行其所有持久化需求。
- en: Spring provides inbuilt Hibernate modules, and you could use Spring's Hibernate
    session-factory beans in your application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了内置的 Hibernate 模块，你可以在应用程序中使用 Spring 的 Hibernate 会话工厂 bean。
- en: 'The `org.springframework.orm.hibernate5.LocalSessionFactoryBean` bean is the
    implementation of the `FactoryBean` interface of Spring. `LocalSessionFactoryBean`
    is based on the Abstract Factory pattern, and it produces Hibernate `SessionFactory`
    in the application. You can configure the Hibernate `SessionFactory` as a bean
    in Spring''s context in your application as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.orm.hibernate5.LocalSessionFactoryBean` 这个 bean 是 Spring
    中 `FactoryBean` 接口的实现。`LocalSessionFactoryBean` 基于抽象工厂模式，并在应用程序中生成 Hibernate 的
    `SessionFactory`。你可以在应用程序的 Spring 上下文中将 Hibernate 的 `SessionFactory` 配置为一个 bean，如下所示：'
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have configured `SessionFactory` as a bean by using
    the Spring's `LocalSessionFactoryBean` class. This bean method takes `DataSource`
    as an argument; `DataSource` specifies how and where to find a database connection.
    We also specified a property, `setPackagesToScan`, for `LocalSessionFactoryBean`
    with a package named `"com.packt.patterninspring.chapter8.bankapp.model"` to be
    scanned, and set a property of `SessionFactory` is `hibernateProperties` to find
    what kind of database we will deal with in the application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过使用 Spring 的 `LocalSessionFactoryBean` 类将 `SessionFactory` 配置为一个
    bean。这个 bean 方法接受 `DataSource` 作为参数；`DataSource` 指定了如何以及在哪里找到数据库连接。我们还为 `LocalSessionFactoryBean`
    指定了一个名为 `"com.packt.patterninspring.chapter8.bankapp.model"` 的包，以进行扫描，并将 `SessionFactory`
    的属性设置为 `hibernateProperties` 以确定我们将处理的应用程序中的数据库类型。
- en: Let's see how to implement DAOs for the persistence layer of the application
    after configuring the Hibernate `SessionFactory` bean in the Spring application
    context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 Spring 应用程序上下文中的 Hibernate `SessionFactory` bean 之后，让我们看看如何实现应用程序持久化层的 DAO。
- en: Implementing DAOs based on the plain Hibernate API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于纯 Hibernate API 实现 DAO
- en: 'Let''s create the following DAO implanting class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建以下 DAO 实现类：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding code, `AccountDaoImpl` is a DAO implementation
    class, which is injected with Hibernate's `SessionFactory` bean by using the `@Autowired`
    annotation. The DAO implementations described earlier will throw unchecked Hibernate
    `PersistenceExceptions`--it is not desirable to let these propagate up to the
    service layer or other users of the DAOs. But the Spring AOP module allows translation
    to Spring's rich, vendor-neutral `DataAccessException` hierarchy--it hides the
    access technology used. Spring provides this capability out of the box by annotating
    the DAO implementation class with `@Repository`, and you just need to define a
    Spring-provided `BeanPostProcessor`, that is, `PersistenceExceptionTranslationPostProcessor`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，`AccountDaoImpl` 是一个 DAO 实现类，它通过使用 `@Autowired` 注解注入 Hibernate 的 `SessionFactory`
    bean。前面描述的 DAO 实现将抛出未检查的 Hibernate `PersistenceExceptions`--不希望这些异常传播到服务层或其他 DAO
    的使用者。但是，Spring AOP 模块允许将其转换为 Spring 的丰富、供应商中立的 `DataAccessException` 层次结构--它隐藏了使用的访问技术。Spring
    通过在 DAO 实现类上使用 `@Repository` 注解提供此功能，你只需要定义一个 Spring 提供的 `BeanPostProcessor`，即
    `PersistenceExceptionTranslationPostProcessor`。
- en: 'Let''s add an exception translation to our Hibernate DAO implementation class;
    we can do this by just adding a `PersistenceExceptionTranslationPostProcessor`
    bean to the Spring application context, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的Hibernate DAO实现类中添加一个异常转换；我们可以通过只需将 `PersistenceExceptionTranslationPostProcessor`
    bean添加到Spring应用程序上下文中来完成此操作，如下所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding registered bean `PersistenceExceptionTranslationPostProcessor`
    is responsible for adding an adviser for the beans which are annotated with the
    `@Repository` annotation, and it is re-thrown as a Spring-specific unchecked data
    access exception for any platform-specific exceptions caught in the code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面注册的bean `PersistenceExceptionTranslationPostProcessor` 负责为带有 `@Repository`
    注解的bean添加一个顾问，并且它将任何在代码中捕获的平台特定异常重新抛出为Spring特定的未检查数据访问异常。
- en: Let's see, in the next section, how Spring manages transactions across the business
    and persistence layers of the Spring application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在下一节中，Spring是如何管理Spring应用程序的业务层和持久层的事务的。
- en: Transaction management strategies in Spring
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring的事务管理策略
- en: Spring provides comprehensive support for transaction management in a Spring
    application. This is one the most compelling features of the Spring Framework.
    Mostly, this feature forces software industries to develop enterprise applications
    with the Spring Framework. The Spring Framework provides a consistent way to manage
    transactions across the application using any persistence technology, such as
    Java Transaction API , JDBC, Hibernate, Java Persistence API, and Java Data Objects.
    Spring supports declarative transaction management as well as programmatic transaction
    management.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为Spring应用程序的事务管理提供了全面的支持。这是Spring框架最吸引人的特性之一。大多数情况下，这个特性迫使软件行业使用Spring框架来开发企业应用程序。Spring框架提供了一种一致的方式来管理应用程序中的事务，无论使用哪种持久化技术，如Java事务API、JDBC、Hibernate、Java持久化API和Java数据对象。Spring支持声明式事务管理和程序化事务管理。
- en: 'There are two types of Java transactions, which are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Java事务有两种类型，具体如下：
- en: '**Local transactions - single resource**: Local transactions managed by the
    underlying resource; these are resource-specific. Let''s explain this with the
    help of the following diagram:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地事务 - 单个资源**：由底层资源管理的本地事务；这些是资源特定的。让我们借助以下图表来解释这一点：'
- en: '![](img/ead72de9-5c64-40e8-aa11-4e5f91f63a00.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ead72de9-5c64-40e8-aa11-4e5f91f63a00.png)'
- en: As you can see in the preceding diagram, there is a transaction working between
    the application and the database platforms to ensure that every unit of task follows
    the ACID property of the databases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面图表中看到的，应用程序和数据库平台之间存在一个事务，以确保每个任务单元都遵循数据库的ACID属性。
- en: '**Global (distributed) transactions - multiple**: Global transactions, which
    are managed by separate, dedicated transaction managers, enable you to work with
    multiple transactional resources. Take a look at the following diagram to understand
    more about Global or distributed transactions:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局（分布式）事务 - 多个**：由单独的、专门的交易管理器管理的全局事务，使您能够与多个事务性资源一起工作。请查看以下图表，以了解有关全局或分布式事务的更多信息：'
- en: '![](img/0999f1a4-94f1-447f-a3cb-fed0ca1b793c.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0999f1a4-94f1-447f-a3cb-fed0ca1b793c.png)'
- en: As you can see in the last diagram, a **Transaction Manager** works with multiple
    database technologies in the application. A global transaction is independent
    of platform-specific persistence technologies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在最后一张图表中看到的，**事务管理器**在应用程序中与多种数据库技术一起工作。全局事务独立于特定平台的数据持久化技术。
- en: Spring provides the same API for both types of transactions in Java applications.
    The Spring Framework provides a consistent programming model in any environment
    by either configuring the transactions declaratively, or by configuring the transaction
    programmatically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为Java应用程序中的两种事务类型提供相同的API。Spring框架通过声明式配置事务或程序化配置事务，在任何环境中都提供一致的编程模型。
- en: Let's move on to the following sections to see how to configure transactions
    in Spring applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一节，看看如何在Spring应用程序中配置事务。
- en: Declarative transaction demarcation and implementation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式事务划分和实现
- en: Spring supports declarative transaction management. Spring separates transaction
    demarcation from transaction implementation. Demarcation is expressed declaratively
    via the Spring AOP. We always recommend using Spring's declarative transaction
    demarcation and implementation in your Spring application, because the declarative
    programming model enables you to replace the external transaction demarcation
    API from the code, and you can configure it by using Spring AOP transaction interceptor.
    Transactions are, basically, cross-cutting concerns; this declarative transaction
    model allows you to keep your application's business logic separate from the repetitive
    transaction demarcation code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持声明式事务管理。Spring将事务边界与事务实现分离。边界通过Spring AOP声明性表达。我们始终建议在您的Spring应用程序中使用Spring的声明性事务边界和实现，因为声明性编程模型允许您从代码中替换外部事务边界API，并且您可以通过使用Spring
    AOP事务拦截器来配置它。事务基本上是横切关注点；这种声明性事务模型允许您将应用程序的业务逻辑与重复的事务边界代码分开。
- en: 'As mentioned earlier, Spring provides a consistent model for handling transactions
    in a Spring application, and provides an interface `PlatformTransactionManager`
    to hide the implementation details. There are several implementations available
    for this interface in the Spring Framework, and some of these are listed next:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring为Spring应用程序中的事务处理提供了一个一致的模型，并提供了一个`PlatformTransactionManager`接口来隐藏实现细节。Spring框架中提供了这个接口的几个实现，其中一些将在下面列出：
- en: '`DataSourceTransactionManager`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataSourceTransactionManager`'
- en: '`HibernateTransactionManager`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HibernateTransactionManager`'
- en: '`JpaTransactionManager`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpaTransactionManager`'
- en: '`JtaTransactionManager`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JtaTransactionManager`'
- en: '`WebLogicJtaTransactionManager`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebLogicJtaTransactionManager`'
- en: '`WebSphereUowTransactionManager`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSphereUowTransactionManager`'
- en: 'The following is a key interface:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个关键接口：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the `getTransaction()` method returns a `TransactionStatus`
    object. This object contains the status of transactions; either it is new or it
    returns existing in the current call stack. It depends on the `TransactionDefinition`
    parameter. As in JDBC or ORM modules, Spring also provides a consistent way to
    handle exceptions thrown by any transaction manager. The `getTransaction()` method
    throws a `TransactionException` exception, which is an unchecked exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`getTransaction()`方法返回一个`TransactionStatus`对象。此对象包含事务的状态；要么它是新的，要么它返回当前调用堆栈中的现有状态。这取决于`TransactionDefinition`参数。正如在JDBC或ORM模块中一样，Spring也提供了一种一致的方式来处理任何事务管理器抛出的异常。`getTransaction()`方法抛出一个`TransactionException`异常，这是一个未检查的异常。
- en: Spring uses the same API for global and local transactions in the application.
    Very minor changes are required to move from local transaction to the global transaction
    in the application-that is just change the transaction manager.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在应用程序中使用相同的API处理全局和本地事务。从本地事务切换到应用程序中的全局事务只需要非常小的更改——那就是更改事务管理器。
- en: Deploying the transaction manager
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署事务管理器
- en: There are two steps for deploying a transaction in your Spring application.
    The first step is that you have to implement or configure a pre-implemented Spring
    transaction manager class with your application. The second step is to declare
    transaction demarcation, that is, where you want to place the Spring transaction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Spring应用程序中部署事务有两个步骤。第一步是您必须实现或配置一个预实现的Spring事务管理器类与您的应用程序。第二步是声明事务边界，即您想在何处放置Spring事务。
- en: Step 1 - Implementing the transaction manager
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步 - 实现事务管理器
- en: 'Create the bean for the required implementation just like any other Spring
    bean. You can configure, as appropriate, the transaction manager for any persistence
    technologies such as JDBC, JMS, JTA, Hibernate, JPA, and so on. But in the following
    example, here is the manager for a `DataSource` using JDBC:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他Spring bean一样，为所需的实现创建bean。您可以根据需要配置事务管理器，以支持任何持久化技术，如JDBC、JMS、JTA、Hibernate、JPA等。但在下面的示例中，这里是一个使用JDBC的`DataSource`管理器的管理器：
- en: 'In Java configuration, let''s see how to define the `transactionManager` bean
    in the application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java配置中，让我们看看如何在应用程序中定义`transactionManager` bean：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In XML configuration, the bean can be created like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML配置中，bean可以创建如下：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we use `dataSource` bean; a `dataSource` bean must be
    defined elsewhere. The bean ID, `"transactionManager"`, is the default name. We
    can change it, but then must specify the alternative name everywhere, and that
    is not so easy to do!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - Declaring the transaction demarcation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the best approach, the service layer of the application is the best place
    to demarcate the transactions. Let''s see this in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the preceding code, `TransferServiceImpl` is our service
    class at the service layer of the application. This service is the best place
    to demarcate the transactions for units of work. Spring provides the `@Transactional`
    annotation to demarcate the transactions; this annotation can be used at either
    the class level or the method level of the service classes in the application.
    Let''s look `@Transactional` at the class level:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you declare the `@Transactional` annotation at the class level, all business
    methods in this service will be transactional methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Note--Method visibility should be public if you are using the `@Transactional`
    annotation. If you use this annotation with a non-public method, such as `protected`,
    `private`, or `package-visible`, no error or exception is thrown, but this annotated
    method does not show the transactional behavior.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'But only using this annotation in the Spring application is not enough. We
    have to enable the transaction management feature of the Spring Framework by using
    the `@EnableTransactionManagement` annotation in the Java configuration file of
    Spring, or we can use the namespace `<tx:annotation-driven/>` in the XML configuration
    file. Let''s look the following code, for example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in the preceding code, `InfrastructureConfig` is the Java configuration
    file of the Spring application--here, we define infrastructure-related beans,
    and one of the `transactionManager` beans too has been defined here. This configuration
    class annotated with one more annotation is `@EnableTransactionManagement`--this
    annotation defines a Bean Post-Processor in the application, and it proxies `@Transactional`
    beans. Now, take a look at the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3b63126-1c60-41c5-be2e-a6d0c607274d.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: As you see in the preceding diagram, the `TransferServiceImpl` class is wrapped
    in a Spring proxy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'But to know what happens exactly with the `@Transactional` beans in the application,
    let''s see the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The `target` object is wrapped in a proxy; it uses an Around advice as we have
    discussed in [Chapter 6](64590e34-2cb4-498b-a576-7a328e683632.xhtml), Spring Aspect
    Oriented Programming with Proxy & Decorator Pattern.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Proxy implements the following behavior:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Start transaction before entering the business method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Commit at the end of the business method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Roll back if the business method throws a `RuntimeException`--it is the
    default behavior of a Spring transaction, but you can override it for checked
    and custom exceptions also.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The transaction context is now bound to the current thread in the application.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务上下文现在绑定到应用程序中的当前线程。
- en: All steps controlled by the configuration either in XML, Java or Annotations.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有步骤都由配置控制，无论是XML、Java还是注解。
- en: 'Now take a look at the following diagram of a local JDBC configuration with
    the associated transaction manager:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看以下带有相关事务管理器的本地JDBC配置图：
- en: '![](img/96349dbf-cbec-40c6-8e1b-b60852adfc01.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96349dbf-cbec-40c6-8e1b-b60852adfc01.png)'
- en: In the previous diagram, we have defined a local data source using JDBC and
    a **DataSource Transaction Manager**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们使用JDBC和一个**数据源事务管理器**定义了一个本地数据源。
- en: In the next section, we'll discuss how to implement and demarcate transactions
    programmatically in the application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何在应用程序中程序化地实现和划分事务。
- en: Programmatic transaction demarcation and implementation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化事务划分和实现
- en: Spring allows you to implement and demarcate transactions programmatically in
    the application by using the `TransactionTemplate` and a `PlatformTransactionManager`
    implementation directly. But declarative transaction management is highly recommended,
    because it provides a clean code and a very flexible configuration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring允许您通过使用`TransactionTemplate`和`PlatformTransactionManager`实现直接在应用程序中实现和划分事务。但是，声明式事务管理被高度推荐，因为它提供了干净的代码和非常灵活的配置。
- en: 'Let''s see how to implement the transactions in the application programmatically:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在应用程序中程序化地实现事务：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding application code, we have used `TransactionTemplate` explicitly
    to execute the application logic in a transactional context. The `TransactionTemplate`
    is also based on the template method design pattern, and it has the same approach
    as other templates in the Spring Framework, such as the JdbcTemplate. Similar
    to JdbcTemplate, `TransactionTemplate` also uses a callback approach, and it makes
    application code free from having the boilerplate code for managing transactional
    resources. We constructed an object of the `TransactionTemplate` class in the
    Service class construction, and passed an object of `PlatformTransactionManager`
    as an argument to the constructor of the `TransactionTemplate` class. We also
    wrote a `TransactionCallback` implementation that contains the business logic
    code of your application, which shows tight coupling between the application logic
    and transactional code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的应用程序代码中，我们明确使用了`TransactionTemplate`来在事务上下文中执行应用程序逻辑。`TransactionTemplate`也是基于模板方法设计模式的，并且与Spring框架中的其他模板（如JdbcTemplate）有相同的方法。类似于JdbcTemplate，`TransactionTemplate`也使用回调方法，并且它使应用程序代码免于管理事务资源的样板代码。我们在服务类构造函数中构建了`TransactionTemplate`类的对象，并将`PlatformTransactionManager`对象作为参数传递给`TransactionTemplate`类的构造函数。我们还编写了一个包含应用程序业务逻辑代码的`TransactionCallback`实现，这显示了应用程序逻辑和事务代码之间的紧密耦合。
- en: We have seen in this chapter how efficiently Spring manages transactions in
    an enterprise application. Let's now study some best practices that we have to
    keep in mind whenever we work on the any enterprise application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到Spring如何高效地管理企业应用程序中的事务。现在，让我们研究一些最佳实践，我们在任何企业应用程序工作中都必须牢记。
- en: Best practices for Spring ORM and transaction module in an application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序中Spring ORM和事务模块的最佳实践
- en: 'The following are the practices that we have to follow in the design and development
    of an application:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们设计和开发应用程序时必须遵循的实践：
- en: 'Avoid using Spring''s `HibernateTemplate` helper class in the DAO implementation,
    and use `SessionFactory` and `EntityManager` in your application. Because of the
    contextual session capability of Hibernate, use `SessionFactory` directly in your
    DAOs. Additionally, use `getCurrentSession()` method to access the transactional
    current session in order to perform persistence operations in the application.
    Please refer to the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在DAO实现中使用Spring的`HibernateTemplate`辅助类，并在您的应用程序中使用`SessionFactory`和`EntityManager`。由于Hibernate的上下文会话能力，直接在DAO中使用`SessionFactory`。此外，使用`getCurrentSession()`方法来访问事务当前会话，以便在应用程序中执行持久化操作。请参考以下代码：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In your application, always use the `@Repository` annotation for data access
    objects or repositories; it provides exception translation. Please refer to the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，始终使用`@Repository`注解来表示数据访问对象或存储库；它提供异常转换。请参考以下代码：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The service layer must be separate even though business methods in the services
    only delegate their responsibilities to the corresponding DAO methods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 即使服务中的业务方法只委托其责任到相应的DAO方法，服务层也必须保持独立。
- en: 'Always implement transactions at the service layer of the application and not
    the DAO layer--this is the best place for transactions. Please refer to the following
    code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在应用程序的服务层实现事务，而不是在DAO层--这是事务的最佳位置。请参考以下代码：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declarative transaction management is more powerful and convenient to configure
    in the application, and is a highly recommend approach to use in a Spring application.
    It separates the cross-cutting concerns from business logic.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式事务管理在应用程序中更强大、更方便配置，并且是Spring应用程序中高度推荐使用的方法。它将横切关注点与业务逻辑分离。
- en: Always throw runtime exceptions instead of checked exceptions from the service
    layer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在服务层抛出运行时异常，而不是检查型异常。
- en: Be careful of the readOnly flag for the `@Transactional` annotation. Mark transactions
    as `readOnly=true` when service methods only contain queries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`@Transactional`注解的readOnly标志。当服务方法只包含查询时，将事务标记为`readOnly=true`。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, we saw that Spring provides `JdbcTemplate`
    class based on the GOF template method design pattern. This class handles all
    the required boilerplate codes underlying the tradition JDBC API. But when we
    work with the Spring JDBC module, mapping tables to the objects becomes very tedious.
    In this chapter, we saw the solution to map objects to tables in a relational
    database--we can do much more with a relational database by using ORM in a complex
    application. Spring supports integration with several ORM solutions like Hibernate,
    JPA, and others. These ORM Frameworks enable the declarative programming model
    for the data persistence instead of using the JDBC programming model.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml)《使用Spring和JDBC模板模式访问数据库》中，我们了解到Spring提供了基于GOF模板方法设计模式的`JdbcTemplate`类。这个类处理了传统JDBC
    API下所有必要的样板代码。但是当我们使用Spring JDBC模块时，将表映射到对象变得非常繁琐。在本章中，我们看到了将对象映射到关系数据库中的解决方案--通过在复杂应用程序中使用ORM，我们可以利用关系数据库做更多的事情。Spring支持与多个ORM解决方案集成，如Hibernate、JPA等。这些ORM框架使得数据持久化的声明式编程模型成为可能，而不是使用JDBC编程模型。
- en: We also looked at the several design patterns that are implemented in the data
    access layer or integration tier. These patterns are implemented as a feature
    in the Spring Framework as proxy pattern for lazy loading, Facade pattern for
    integration with business tier, DAO patterns for data accessing, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了在数据访问层或集成层中实现的一些设计模式。这些模式作为Spring框架的一个特性实现，如代理模式用于懒加载，外观模式用于与业务层集成，DAO模式用于数据访问，等等。
- en: In the next chapter, we'll see how we can improve our application's performance
    in production by using Spring's support for cache patterns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过使用Spring对缓存模式的支持来提高我们应用程序在生产环境中的性能。
