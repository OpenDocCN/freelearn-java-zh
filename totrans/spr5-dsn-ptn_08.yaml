- en: Accessing Database with Spring ORM and Transactions Implementing Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, we have learned how to access database
    using JBDC and how Spring can remove boilerplate code from the developer end to
    the framework by using template pattern and callbacks. In this chapter, we will
    learn one advanced step of accessing database using the **Object Relational Mapping**
    (**ORM**) Framework and managing transactions across the application.
  prefs: []
  type: TYPE_NORMAL
- en: When my son, Arnav, was one and a half years old, he used to play with a dummy
    mobile phone. But as he grew up, his needs too outgrew dummy mobiles to smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when your application has a small set of data for a business tier,
    then JDBC works fine, but as your application grows and becomes more complex,
    it becomes difficult to map tables to the objects in the application. JDBC is
    the dummy small phone of the data access world. But with complex applications,
    we need Object Relational Mapping solutions that are able to map object properties
    to database columns. We also need more sophisticated platforms for our application
    at the data access layer, which create the queries and statements independently
    from the database technologies for us, and which we can define declaratively or
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Many ORM Frameworks are available to provide services at the data access layer
    of an application. Examples of such services include object relational mapping,
    lazy loading of data, eager loading of data, cascading, and so on. These ORM services
    save you from writing a lot of code for error handling, and managing resources
    in the application. The ORM Frameworks decrease the development time, and help
    to write error-free code, so that you just focus on the business requirements
    only. Spring doesn't implement its own ORM solution, but it provides support for
    many persistence frameworks such as Hibernate, the **Java Persistence API** (**JPA**),
    iBATIS, and **Java Data Objects** (**JDO)**. Spring also provides integration
    points to the ORM Frameworks so that we can easily integrate the ORM Framework
    in our Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides support for all these technologies in your application. In
    this chapter, we will explore Spring''s support for ORM solutions, and cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ORM Framework and used patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data access object pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating DAOs using the Factory design pattern in Spring
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Data Mapper pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain model pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy for the lazy loading pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hibernate template pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Hibernate with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Hibernate's `SessionFactory` in a Spring container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing DAOs based on plain Hibernate API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management strategies in Spring
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative transaction implementation and demarcation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic transaction implementation and demarcation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for Spring ORM and transaction modules in the application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we go on to discuss more about the ORM Frameworks, let's first look at
    some design patterns used in the **data access layer** (**DAL**) of the application.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Framework and the patterns used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides support for several ORM Frameworks, such as Hibernate, the
    **Java Persistence API** (**JPA**), iBATIS, and **Java Data Objects** (**JDO**).
    By using any ORM solution in your application, you can easily persist and access
    data in the form of POJO objects from relational databases. The Spring ORM module
    is an extension of the previously discussed Spring JDBC DAO module. Spring provides
    ORM templates, such as JDBC-based templates, to work in the integration tier or
    data access layer. The following are the ORM Frameworks and integration supported
    by the Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Persistence API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Data Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iBATIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access object implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use Spring''s dependency injection feature to configure ORM solutions
    in your application. Spring also adds important enhancements to the ORM layer
    in your data access applications. The following are the benefits of using the
    Spring Framework to create your ORM DAOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier development and testing**: Spring''s IoC container manages the beans
    for ORM DAOs. You can easily swap the implementation of the DAO interface by using
    Spring''s dependency injection feature. It also makes it easy to test persistence-related
    code in isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common data access exceptions**: Spring provides a consistent data exception
    hierarchy to handle exceptions at the persistence layer. It wraps all the checked
    exceptions from the ORM tool, and converts these exceptions to unchecked general
    exceptions which are not related to any specific ORM solution and are DB-specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General resource management**: Resources such as `DataSource`, DB connections,
    Hibernates `SessionFactory`, JPA `EntityManagerFactory`, and others are managed
    by the Spring IoC container. Spring also manages transactions--local or global--using
    JTA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated transaction management**: Spring provides declarative and programmatic
    transaction management in your application. For declarative transaction management,
    you can use the `@Transactional` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main approach to Spring's integration with the ORM solution is loose coupling
    between the application's layers; that is, the business layer and the data access
    layer. It is clear application layering, and is independent of any specific database
    and transaction technology. Business services in the application are no longer
    dependent on data access and a specific transaction strategy. Because Spring manages
    the resources used in the integration layer, you don't need to look up resources
    for specific data access technologies. Spring provides templates for the ORM solution
    to remove the boilerplate codes, and it provides a consistent approach across
    all ORM solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, you saw how Spring solves two major problems
    of the integration layer in the application. The first problem was *redundant
    code for managing resources from the application*, and the second problem was
    *handling checked exceptions* in the application at development time. Similarly,
    the Spring ORM module also provides solutions to these two problems, as we'll
    discuss in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Resource and transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring JDBC module, resources such as connection handling, statements
    handling, and exceptions handling are managed by the Spring's JdbcTemplate. It
    also translates SQL error codes of the database specific to meaningful unchecked
    exception classes. The same is true for the Spring ORM module--Spring manages
    both local and global transactions in the enterprise application by using the
    respective Spring transaction managers. Spring provides transaction managers for
    all supported ORM technologies. For example, Spring offers the Hibernate transaction
    manager for Hibernate, the JPA transaction manager for JPA, and JTA support for
    global or distributed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent exception handling and translation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Spring JDBC module, Spring provides `DataAccessException` to handle
    all types of database-specific SQL error code, and generates meaningful exception
    classes. In the Spring ORM module, as we already know, Spring supports integration
    for several ORM solutions, such as Hibernate, JPA, or JDO in a DAO, and these
    persistence technologies provide their own native exception classes as `HibernateException`,
    `PersistenceException`, or `JDOException` depending on the technology. These native
    exceptions of the ORM Frameworks are unchecked exceptions, so we don''t have to
    handle them in the application. The caller of the DAO services cannot do specific
    handling unless the application is strongly ORM based, or does not need any special
    exception treatment. Spring provides a consistent approach throughout the ORM
    Frameworks; you don''t need to implement specific code for any ORM in a Spring
    application. It enables exception translation by using the `@Repository` annotation.
    If any class in the Spring application is annotated with `@Repository` annotation,
    then that class is eligible for Spring `DataAccessException` translation. Take
    for example the following code for the `AccountDaoImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `PersistenceExceptionTranslationPostProcessor`
    class is a bean `post processor`, which automatically searches for all exception
    translators and also advises all the registered beans annotated with the `@Repository`
    annotation in the container. It applies the discovered exception translators to
    those annotated beans, and these translators can intercept and apply the appropriate
    translation on the thrown exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some more design patterns that are implemented in the Spring ORM module
    to provide the best enterprise solution for the integration tier of an enterprise
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The data access object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **data access object** (**DAO**) pattern is a very popular design pattern
    for the persistent layer in a J2EE application. It separates the business logic
    layer and persistence layer. The DAO pattern is based on the encapsulation and
    abstraction object-oriented principles. The context for using the DAO pattern
    is to access and persist data depending on the underlying vendor implementation
    and type of storage, such as object-oriented database, flat files, relational
    databases, and so on. Using the DAO pattern, you can create a DAO interface, and
    implement this DAO interface to abstract and encapsulate all access to the data
    source. This DAO implementation manages the database's resources like connections
    with the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DAO interfaces are very generic to all the underlying data source mechanisms,
    and don''t need to change for any changes in the low-level persistence technologies.
    This pattern allows you to adopt any different data access technologies without
    affecting the business logic in the enterprise application. Let''s see the following
    figure to understand more about the DAO pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/708d83c8-8fe7-4581-8629-133da0d44194.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, the following participants work on
    this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BusinessObject**: This object works on the business layer, and is a client
    for the data access layer. It requires data for business modeling, and for preparing
    Java objects for the helper or controllers in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataAccessObject**: This is a primary object of the DAO pattern. This object
    hides all the low-level implementation of the underlying database implementation
    for the **BusinessObject**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataSource**: This is also an object to contain all the low-level information
    about the underlying database implementation, such as an RDBMS, flat files, or
    XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TransferObject**: This is also an object, and it is used as a data carrier.
    This object is used by **DataAccessObject** to return data to the business object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following example of the DAO pattern, where `AccountDao` is
    a `DataAccessObject` interface, and `AccountDaoImpl` is the implementation class
    of the `AccountDao` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating DAOs using the Factory design pattern in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, there are a lot of design patterns that play a role in the Spring
    Framework. As discussed in [Chapter 2](75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml),
    *Overview of GOF Design Patterns*--Core Design patterns, the Factory pattern is
    a creational design pattern, and it is used to create an object without exposing
    the underlying logic to the client, and to assign a new object to the caller using
    a common interface or abstract class. You can make the DAO pattern highly flexible
    by using the `Factory` method and Abstract Factory design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see in our example where do we are implementing this strategy in which
    a factory produces the DAOs for a single database implementation. Please refer
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6b56aff-d1ff-40e2-96a5-ef320074a864.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding diagram that the **AccountDao** object is produced
    by **AccountDaoFactory**, and **AccountDaoFactory** is a factory for **AccountDao**.
    We can change the underlying database at any time such that we do not need to
    change the business code--the factory takes care of these things, Spring provides
    support to maintain all the DAOs in the bean factory and in the factory for DAOs
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Mapper pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A layer of Mappers that moves data between objects and a database while keeping
    them independent of each other and the mapper itself*.'
  prefs: []
  type: TYPE_NORMAL
- en: '- By **Martin Fowler**: Patterns of Enterprise Application Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM Framework provides mapping between the object and relational databases,
    because we know that Objects and tables in the relational databases have different
    ways of storing the data for the application. Also, objects and tables have mechanisms
    for structuring data. In your Spring application, if you use any ORM solution
    such as Hibernate, JPA, or JDO, then you don''t need worry about the mapping mechanism
    between the object and relational databases. Let''s see the following diagram
    to understand more about the Data Mapper pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc8e63e5-0863-4dc2-ac2f-4cd902fc4f45.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, **Account**, an object, is mapped to the
    relational database through **AccountMapper**. It works like a mediator layer
    between the Java object and the underlying database in the application. Let's
    see another pattern used in the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: The domain model pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object model of the domain that incorporates both behaviour and data.
  prefs: []
  type: TYPE_NORMAL
- en: '-by Martin Fowler: Patterns of Enterprise Application Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain model is an object that has behavior and data, so, the behavior defines
    the business logic of the enterprise application, and data is information about
    the business''s output. A domain model combines data and process. In an enterprise
    application, data model lies under the business layer to insert the business logic,
    and it returns data from the business behaviors. Let''s see the following diagram
    for more clarity on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c41779b-59fc-49c8-be22-75ff9b2b98c7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, we have defined two domain models in
    our application as per as our business requirements. Business behavior for transferring
    money from one account to another account has been defined in the **TransferService**
    class. The classes **TransferService** and **AccountService** come under the domain
    model pattern in the enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy for the lazy loading pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading is a design pattern, and this design pattern is used by some ORM
    solutions such as Hibernate in the enterprise application to defer initialization
    of an object until it is called by another object at a point where it is needed.
    The purpose of this design pattern is memory optimization in the application.
    The lazy loading design pattern in Hibernate is achieved by using a virtual proxy
    object. In Lazy loading demonstration, we use a proxy, but this is not part of
    the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Spring's Hibernate template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a helper class to access data in the DAO layer--this class is
    based on the GoF template method design pattern. Spring provides the `HibernateTemplate`
    class for providing database operations such as `save`, `create`, `delete`, and
    `update`. The `HibernateTemplate` class ensures that only one Hibernate session
    is used per transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see Spring's support for Hibernate in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Hibernate with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hibernate is a persistence ORM Framework, it is open source, and it provides
    not only simple object relationship mapping between Java objects and database
    tables, but also provides a lot of sophisticated features for your application
    to improve performance, and helps in better resource utilization such as caching,
    lazy loading, eager fetching, and distributed caching.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework provides full support to integrate the Hibernate Framework,
    and Spring has some inbuilt libraries for full utilization of the Hibernate Framework.
    We can use Spring's DI pattern and IoC container to configure Hibernate in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see in the following section how to configure Hibernate in the Spring
    IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Hibernate's SessionFactory in a Spring container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the best approach for configuring Hibernate and other persistence technologies
    in any enterprise application, business objects should be separate from the hard-coded
    resource lookups such as a JDBC `DataSource` or Hibernate `SessionFactory`. You
    can define these resources as beans in the Spring container. But business objects
    require the references of these resources, such as `SessionFactory` and JDBC `DataSource`,
    to access them. Let''s see the following DAO class which has `SessionFactory`
    to access data for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the DAO class, `AccountDaoImpl`, follows
    the dependency injection pattern. It is injected with Hibernate's `SessionFactory`
    object to access the data, and fits nicely into a Spring IoC container. Here,
    Hibernate's `SessionFactory` is singleton object; it produces the main object
    of `org.hibernate.Session` interface of Hibernate. `SessionFactory` manages the
    `Session` object of Hibernate, and is also responsible for opening and closing
    the `Session` object. The `Session` interface has actual data-access functionality
    such as `save`, `update`, `delete`, and `load` objects from the database. In the
    application, `AccountDaoImp` or any other repository uses this Hibernate `Session`
    object to perform all of its persistence needs.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides inbuilt Hibernate modules, and you could use Spring's Hibernate
    session-factory beans in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `org.springframework.orm.hibernate5.LocalSessionFactoryBean` bean is the
    implementation of the `FactoryBean` interface of Spring. `LocalSessionFactoryBean`
    is based on the Abstract Factory pattern, and it produces Hibernate `SessionFactory`
    in the application. You can configure the Hibernate `SessionFactory` as a bean
    in Spring''s context in your application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have configured `SessionFactory` as a bean by using
    the Spring's `LocalSessionFactoryBean` class. This bean method takes `DataSource`
    as an argument; `DataSource` specifies how and where to find a database connection.
    We also specified a property, `setPackagesToScan`, for `LocalSessionFactoryBean`
    with a package named `"com.packt.patterninspring.chapter8.bankapp.model"` to be
    scanned, and set a property of `SessionFactory` is `hibernateProperties` to find
    what kind of database we will deal with in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to implement DAOs for the persistence layer of the application
    after configuring the Hibernate `SessionFactory` bean in the Spring application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DAOs based on the plain Hibernate API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the following DAO implanting class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, `AccountDaoImpl` is a DAO implementation
    class, which is injected with Hibernate's `SessionFactory` bean by using the `@Autowired`
    annotation. The DAO implementations described earlier will throw unchecked Hibernate
    `PersistenceExceptions`--it is not desirable to let these propagate up to the
    service layer or other users of the DAOs. But the Spring AOP module allows translation
    to Spring's rich, vendor-neutral `DataAccessException` hierarchy--it hides the
    access technology used. Spring provides this capability out of the box by annotating
    the DAO implementation class with `@Repository`, and you just need to define a
    Spring-provided `BeanPostProcessor`, that is, `PersistenceExceptionTranslationPostProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an exception translation to our Hibernate DAO implementation class;
    we can do this by just adding a `PersistenceExceptionTranslationPostProcessor`
    bean to the Spring application context, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding registered bean `PersistenceExceptionTranslationPostProcessor`
    is responsible for adding an adviser for the beans which are annotated with the
    `@Repository` annotation, and it is re-thrown as a Spring-specific unchecked data
    access exception for any platform-specific exceptions caught in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see, in the next section, how Spring manages transactions across the business
    and persistence layers of the Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction management strategies in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides comprehensive support for transaction management in a Spring
    application. This is one the most compelling features of the Spring Framework.
    Mostly, this feature forces software industries to develop enterprise applications
    with the Spring Framework. The Spring Framework provides a consistent way to manage
    transactions across the application using any persistence technology, such as
    Java Transaction API , JDBC, Hibernate, Java Persistence API, and Java Data Objects.
    Spring supports declarative transaction management as well as programmatic transaction
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of Java transactions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local transactions - single resource**: Local transactions managed by the
    underlying resource; these are resource-specific. Let''s explain this with the
    help of the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ead72de9-5c64-40e8-aa11-4e5f91f63a00.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, there is a transaction working between
    the application and the database platforms to ensure that every unit of task follows
    the ACID property of the databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global (distributed) transactions - multiple**: Global transactions, which
    are managed by separate, dedicated transaction managers, enable you to work with
    multiple transactional resources. Take a look at the following diagram to understand
    more about Global or distributed transactions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0999f1a4-94f1-447f-a3cb-fed0ca1b793c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the last diagram, a **Transaction Manager** works with multiple
    database technologies in the application. A global transaction is independent
    of platform-specific persistence technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides the same API for both types of transactions in Java applications.
    The Spring Framework provides a consistent programming model in any environment
    by either configuring the transactions declaratively, or by configuring the transaction
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the following sections to see how to configure transactions
    in Spring applications.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative transaction demarcation and implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring supports declarative transaction management. Spring separates transaction
    demarcation from transaction implementation. Demarcation is expressed declaratively
    via the Spring AOP. We always recommend using Spring's declarative transaction
    demarcation and implementation in your Spring application, because the declarative
    programming model enables you to replace the external transaction demarcation
    API from the code, and you can configure it by using Spring AOP transaction interceptor.
    Transactions are, basically, cross-cutting concerns; this declarative transaction
    model allows you to keep your application's business logic separate from the repetitive
    transaction demarcation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Spring provides a consistent model for handling transactions
    in a Spring application, and provides an interface `PlatformTransactionManager`
    to hide the implementation details. There are several implementations available
    for this interface in the Spring Framework, and some of these are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataSourceTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HibernateTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpaTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JtaTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebLogicJtaTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebSphereUowTransactionManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a key interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `getTransaction()` method returns a `TransactionStatus`
    object. This object contains the status of transactions; either it is new or it
    returns existing in the current call stack. It depends on the `TransactionDefinition`
    parameter. As in JDBC or ORM modules, Spring also provides a consistent way to
    handle exceptions thrown by any transaction manager. The `getTransaction()` method
    throws a `TransactionException` exception, which is an unchecked exception.
  prefs: []
  type: TYPE_NORMAL
- en: Spring uses the same API for global and local transactions in the application.
    Very minor changes are required to move from local transaction to the global transaction
    in the application-that is just change the transaction manager.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the transaction manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two steps for deploying a transaction in your Spring application.
    The first step is that you have to implement or configure a pre-implemented Spring
    transaction manager class with your application. The second step is to declare
    transaction demarcation, that is, where you want to place the Spring transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - Implementing the transaction manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the bean for the required implementation just like any other Spring
    bean. You can configure, as appropriate, the transaction manager for any persistence
    technologies such as JDBC, JMS, JTA, Hibernate, JPA, and so on. But in the following
    example, here is the manager for a `DataSource` using JDBC:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java configuration, let''s see how to define the `transactionManager` bean
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In XML configuration, the bean can be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use `dataSource` bean; a `dataSource` bean must be
    defined elsewhere. The bean ID, `"transactionManager"`, is the default name. We
    can change it, but then must specify the alternative name everywhere, and that
    is not so easy to do!
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - Declaring the transaction demarcation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the best approach, the service layer of the application is the best place
    to demarcate the transactions. Let''s see this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, `TransferServiceImpl` is our service
    class at the service layer of the application. This service is the best place
    to demarcate the transactions for units of work. Spring provides the `@Transactional`
    annotation to demarcate the transactions; this annotation can be used at either
    the class level or the method level of the service classes in the application.
    Let''s look `@Transactional` at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you declare the `@Transactional` annotation at the class level, all business
    methods in this service will be transactional methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note--Method visibility should be public if you are using the `@Transactional`
    annotation. If you use this annotation with a non-public method, such as `protected`,
    `private`, or `package-visible`, no error or exception is thrown, but this annotated
    method does not show the transactional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'But only using this annotation in the Spring application is not enough. We
    have to enable the transaction management feature of the Spring Framework by using
    the `@EnableTransactionManagement` annotation in the Java configuration file of
    Spring, or we can use the namespace `<tx:annotation-driven/>` in the XML configuration
    file. Let''s look the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, `InfrastructureConfig` is the Java configuration
    file of the Spring application--here, we define infrastructure-related beans,
    and one of the `transactionManager` beans too has been defined here. This configuration
    class annotated with one more annotation is `@EnableTransactionManagement`--this
    annotation defines a Bean Post-Processor in the application, and it proxies `@Transactional`
    beans. Now, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3b63126-1c60-41c5-be2e-a6d0c607274d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see in the preceding diagram, the `TransferServiceImpl` class is wrapped
    in a Spring proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to know what happens exactly with the `@Transactional` beans in the application,
    let''s see the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `target` object is wrapped in a proxy; it uses an Around advice as we have
    discussed in [Chapter 6](64590e34-2cb4-498b-a576-7a328e683632.xhtml), Spring Aspect
    Oriented Programming with Proxy & Decorator Pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Proxy implements the following behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Start transaction before entering the business method.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Commit at the end of the business method.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Roll back if the business method throws a `RuntimeException`--it is the
    default behavior of a Spring transaction, but you can override it for checked
    and custom exceptions also.
  prefs: []
  type: TYPE_NORMAL
- en: The transaction context is now bound to the current thread in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All steps controlled by the configuration either in XML, Java or Annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now take a look at the following diagram of a local JDBC configuration with
    the associated transaction manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96349dbf-cbec-40c6-8e1b-b60852adfc01.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous diagram, we have defined a local data source using JDBC and
    a **DataSource Transaction Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss how to implement and demarcate transactions
    programmatically in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic transaction demarcation and implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring allows you to implement and demarcate transactions programmatically in
    the application by using the `TransactionTemplate` and a `PlatformTransactionManager`
    implementation directly. But declarative transaction management is highly recommended,
    because it provides a clean code and a very flexible configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to implement the transactions in the application programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding application code, we have used `TransactionTemplate` explicitly
    to execute the application logic in a transactional context. The `TransactionTemplate`
    is also based on the template method design pattern, and it has the same approach
    as other templates in the Spring Framework, such as the JdbcTemplate. Similar
    to JdbcTemplate, `TransactionTemplate` also uses a callback approach, and it makes
    application code free from having the boilerplate code for managing transactional
    resources. We constructed an object of the `TransactionTemplate` class in the
    Service class construction, and passed an object of `PlatformTransactionManager`
    as an argument to the constructor of the `TransactionTemplate` class. We also
    wrote a `TransactionCallback` implementation that contains the business logic
    code of your application, which shows tight coupling between the application logic
    and transactional code.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen in this chapter how efficiently Spring manages transactions in
    an enterprise application. Let's now study some best practices that we have to
    keep in mind whenever we work on the any enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for Spring ORM and transaction module in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the practices that we have to follow in the design and development
    of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid using Spring''s `HibernateTemplate` helper class in the DAO implementation,
    and use `SessionFactory` and `EntityManager` in your application. Because of the
    contextual session capability of Hibernate, use `SessionFactory` directly in your
    DAOs. Additionally, use `getCurrentSession()` method to access the transactional
    current session in order to perform persistence operations in the application.
    Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In your application, always use the `@Repository` annotation for data access
    objects or repositories; it provides exception translation. Please refer to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The service layer must be separate even though business methods in the services
    only delegate their responsibilities to the corresponding DAO methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always implement transactions at the service layer of the application and not
    the DAO layer--this is the best place for transactions. Please refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Declarative transaction management is more powerful and convenient to configure
    in the application, and is a highly recommend approach to use in a Spring application.
    It separates the cross-cutting concerns from business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Always throw runtime exceptions instead of checked exceptions from the service
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful of the readOnly flag for the `@Transactional` annotation. Mark transactions
    as `readOnly=true` when service methods only contain queries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](81848842-717f-4e27-9204-ace0a6fdce6f.xhtml), *Accessing Database
    with Spring and JDBC Template Patterns*, we saw that Spring provides `JdbcTemplate`
    class based on the GOF template method design pattern. This class handles all
    the required boilerplate codes underlying the tradition JDBC API. But when we
    work with the Spring JDBC module, mapping tables to the objects becomes very tedious.
    In this chapter, we saw the solution to map objects to tables in a relational
    database--we can do much more with a relational database by using ORM in a complex
    application. Spring supports integration with several ORM solutions like Hibernate,
    JPA, and others. These ORM Frameworks enable the declarative programming model
    for the data persistence instead of using the JDBC programming model.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the several design patterns that are implemented in the data
    access layer or integration tier. These patterns are implemented as a feature
    in the Spring Framework as proxy pattern for lazy loading, Facade pattern for
    integration with business tier, DAO patterns for data accessing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see how we can improve our application's performance
    in production by using Spring's support for cache patterns.
  prefs: []
  type: TYPE_NORMAL
