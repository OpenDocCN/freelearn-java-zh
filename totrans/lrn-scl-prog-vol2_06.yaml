- en: Next Steps in Object-Oriented Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"I was born not knowing and have only had a little time to change that here
    and there."'
  prefs: []
  type: TYPE_NORMAL
- en: – Richard Feynman
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of companion objects gave us the feeling that it''s important to know
    how your programming language treats the constructs you write. Suppose you were
    given a task to generate a `case` class with some sensitive parameters (by sensitive,
    we mean when trying to print that class, those sensitive fields should print some
    dummy values). What you are going to do in order to achieve that entirely depends
    on your knowledge of how Scala treats the `case` classes, and we learned that
    in the previous chapter. So, what now? Now it''s time to do some composition as
    well as use inheritance. Remember, we talked about how we should think of a class
    as a type that we can define? It''s a really useful and fun task to mix these
    types all together and try to make sense out of them and at the same time, add
    functionalities. That''s why we have static typing, isn''t it? Let me tell you,
    it''s fun to learn composition while mixing in those types, creating more than
    one way to access such constructs. And that''s what we''re going to do in this
    chapter. We''ll have fun and learn. So, this is how we are going to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition versus inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default and parameterized constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits as mix-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linearization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and importing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visibility rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move forward I want to clear this up. The terms *composition* and
    *i**nheritance* will be used in this chapter a lot*.* It's better if we differentiate
    these two up front.
  prefs: []
  type: TYPE_NORMAL
- en: Composition and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming terms, to inherit or extend our classes we use the `extends`
    or `with` keywords. These are essential for the relationship between two or more
    classes or similar constructs. This association or relation between two classes
    or similar constructs can be in the form of inheritance (Is-A) or composition
    (Has-A). They are two different notions but they converge to some extent. In simple
    words, **inheritance** is a superclass-subclass relationship where the subclass
    inherits the implementation of the superclass, whereas **composition** is when
    a class depends on another object to provide some or all functionality. With an
    inheritance relationship, you can use the subclass object wherever superclass
    is expected. Think of it as this relationship between a `Dictionary` and a `Book`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can picture the **Book** and **Dictionary** relationship as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, a `Dictionary` class is inheriting from a `Book` class, so it means that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dictionary` is a subclass of `Book`. It can be used as a `Book` type wherever
    required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary has access to all the fields (data) and member functions (behavior)
    of the `Book` class. This means that you're allowed to override the behavior of
    a particular function from the superclass, as well as define your own functions
    in terms of behavior from superclass functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points in a way make it easier to understand the inheritance relationship
    and help you to form a good object-oriented design. However, sometimes you as
    a developer feel duty-bound to change the behavior of the superclass as it's now
    a dependency for other subtypes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composition also may look similar when implemented (in case of traits mix-ins)
    but it''s different in nature. As the name suggests, composition actually makes
    the whole out of parts. It''s easier to understand with the help of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have shown a `Book` class that consists of a set of
    chapters. Each chapter is represented by a `Chapter` class. This is a *Has-a*
    relationship between the `Book` and `Chapter` classes. This relationship is also
    called **aggregation**. And as a special form of aggregation, our topic of interest
    for now is composition. There's a field named `chapters` in the `Book` class that
    is composed of `chapters`. Without the `Chapter` construct, there's no possibility
    of forming a book object that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is composition and it''s directional. The following figure will help us
    to understand the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Composition relationship between a Book and Chapter
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Set` object in `chapters`, we can extend some functionalities that
    can only be performed on `Chapter` objects. I bet you get the idea of composition.
    The reason why we''re discussing this is because we''ll be doing that using mix-ins
    of traits in Scala, and it looks almost like we''re extending them as part of
    inheritance, but that''s not the case. So the idea is clear:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition is not just code reuse but also making a whole out of parts. The
    existence of `Book` is unclear without a `Chapter` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition also adds up functionalities to our already defined class constructs
    (we'll see this when we talk about *traits as mix-ins* later in the chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to know the difference between these two. You may only have a
    vague idea of how to implement inheritance or composition in Scala for now, but
    the terms and their meaning are clear. It's going to make the way clear for us
    to move forward and discuss how we can implement class inheritance in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know that inheritance plays an important role in good object-oriented
    design. We are lucky enough to have constructs such as classes with names, and
    we can increase the possibility of relating those with other classes by using
    inheritance. Inheritance is about forming a meaningful hierarchy of classes to
    solve the purpose of code reuse. And mark my words, I mentioned *meaningful hierarchies.*
    I'll justify my words later. Let's take a look at how we can extend classes to
    make a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `extend` keyword to inherit a class. Let''s see our `Book` example
    to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `Dictionary` inherits from `Book` or `Dictionary` and is a subclass
    of the `Book` superclass. It's important to know that all classes, regardless
    of using the `extends` keyword, explicitly inherit `Any` in Scala. It means that
    our `Book` class inherits `Any`. Now with the establishment of this relationship,
    if you try to create an instance of `Dictionary`, you'll have access to all non-private
    members of the superclass. That's the reason we're able to print the title of
    our dictionary. That's code reuse. If you don't want to allow a particular member
    to be accessible from outside, you may make it `private`, an access modifier.
    We'll learn about access levels later in this chapter. With this inheritance relationship,
    it's possible to use a `Dictionary` instance wherever a `Book` instance is expected.
    The reason for this is that `dictionary` is a subtype of the `Book` type. To make
    things clearer, let's talk about subtyping and subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping versus subclassing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are not types in Scala*.* When we inherit from a class, we form a superclass-subclass
    relationship between the two. And for most cases, the notion of subclassing and
    subtyping are the same. But in cases where *variance (*inheritance behavior under
    parameterized classes*)* plays its part, things become different. Under variance,
    subclassing doesn't guarantee subtyping as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at both cases, positive and negative. Let''s say a dictionary
    inherits from book, and it makes sense to say that a stack of dictionaries is
    a stack of books. This is the positive scenario, where subclassing and subtyping
    are similar in nature. But what about the second scenario? Suppose the `Keyboard`
    class extends from the `Button` class*.* `Button` has a value and also the functionality.
    So, while forming a meaningful keyboard object, we used the `Button` class. But
    do you think a stack of keyboards is the same as a stack of buttons? No! Hence
    here, the subclassing is perfect between `Keyboard` and `Button` classes, but
    we''re not allowed to say that the `Keyboard` is a subtype of `Button`. I think
    you get the idea of subtyping and subclassing and their differences. Still, in
    programming terms, let''s see it this way: if `Dictionary` is a subtype of `Book`,
    then `List`[`Dictionary`] is going to be a subtype of `List`[`Book`]. We call
    this property **covariance**. In the other case, `Keyboard` sub-classes `Button`
    but it''s not a subtype of `Button`. Let''s visualize what we just tried to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sub-classing
  prefs: []
  type: TYPE_NORMAL
- en: This relationship speaks for itself. In the case of keyboard and buttons, it's
    better to choose composition instead of inheritance. But that's a different perspective.
    For now, it has become clear we should differentiate between subtyping and subclassing.
    So now, let's go over one more interesting topic—overriding the behavior of superclasses.
    Yes, it's possible for us to override the functions defined in a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding data and behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that subclasses have access to all non-private members of a superclass,
    hence we can call or invoke functions from a superclass to show some behavior.
    If we want to manipulate the behavior, it's possible in Scala to override any
    function or value from a superclass. Let's see how we can do that. We'll refer
    to our previously mentioned `Book` and `Dictionary` example. Suppose in the `Book`
    class we have a function named `cover` that for demonstration purposes simply
    takes a `String` object as `cover`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We inherit from `Book` and create a `Dictionary` class that wants to override
    the functionality of this function named `cover`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can `override` the definition of the `cover` method by simply adding the
    modifier keyword named `override`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, we''ve overridden the `cover` method*.*
    What if we don''t use this keyword named `override`? In that case, the Scala compiler
    will give us an error stating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cover` method needs the `override` modifier. Method overriding works if
    we''ve kept the signature in the subclass intact. If you try to change the signature,
    the compiler will give you an error stating that the `cover` method overrides
    nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So it's important to keep the method signature as it is in the subclass to override
    it. Scala requires you to provide the `override` keyword whenever you try reusing
    the same method in a subclass. In Java, the `override` keyword is optional. This
    causes problems in real-time scenarios when writing code. Let's suppose you want
    to change the behavior in the `Book` superclass to support the newly introduced
    `Cover` class as a parameter in the `cover` method, and you have overridden this
    `cover` method in a few places, such as the `Dictionary` class. What happens in
    scenarios where the `override` keyword is not mandatory? you may ask. Hence, Scala
    requires you to add it. So at compile time, you're going to get an error that
    the `cover` method in `Dictionary` overrides nothing, and you can change the definition
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more important thing to know: for understanding overriding behaviors thoroughly
    we must understand the scope of them. It''s possible to override a non-parameter
    `def` member with a `val` field. What do we mean by this? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows you that a non-parameter method named `coverType` in `Book`
    can be overridden in the `Dictionary` subclass with a `val` object. It''s perfectly
    legal to perform such overriding operations. If you try to do this the other way
    around, it''s not possible. The Scala compiler will not allow you to perform such
    an operation stating that the `coverType` method needs to be a stable, immutable
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's logical; what you're trying to do here is to make something mutable, a
    definition is mutable. This shouldn't be allowed and the Scala compiler is intelligent
    enough to tell you this. Suppose you want a particular member of your superclass
    to be intact, and not changeable. You want to restrict following subclasses from
    overriding behavior of the superclass, what'll you do in that case? That's what
    we'll learn next.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting inheritance – final keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to restrict subclasses from overriding a particular behavior or
    some data, you may use the `final` keyword to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have declared our `coverType` value as `final`. If you try to override
    this, the Scala compiler will throw an error stating the value cannot override
    the `final` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's useful for when there's some data you want to remain intact and still have
    this superclass-subclass relationship working. With this overriding of behaviors
    in several related classes, there comes confusion when you try to invoke a particular
    method that's in a superclass as well as subclasses. That confusion is solved
    using the concept of dynamic binding. So, let's explain where dynamic binding
    is used before we learn how it works in detail. Dynamic binding is used to resolve
    which member function will get invoked when classes are in an inheritance relationship.
    This is resolved on the basis of objects at runtime. Let's talk in detail about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic binding in function invocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about the dynamic binding of objects to their references and invocation
    of methods. The invocation takes place based on the type of object on which that
    method is called. This is easier to understand with an example. Take a look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a closer look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created three different objects with the same return types, `Book`.
    The first thing to notice is that the class on the left-hand side of the equals
    operator will always be higher in the inheritance hierarchy. Secondly, all three
    are different instances. So, when you try to invoke a member function named `cover`
    from all these instances, you may observe different behavior in all three cases
    and see that the invocation is done based on the runtime type of the class. What
    do we mean by the runtime type of the class? It means that at compile time, all
    three expressions were of the same type, `Book`, but at runtime, things are different.
    Invocation of `Dictionary`, `Encyclopedia`, and `Book` takes place resulting in
    invocation of their respective versions of the cover method. In our case, the
    result that gets printed out shows the expected behavior. This behavior is termed
    **dynamic binding** in object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: By now, I'm sure that you're pretty well-versed in the concept of inheritance,
    and are ready to take this characteristic into account when designing models for
    your next application, right? Well to make it clearer, we'll think of inheritance
    as a concept that solves the issue of code duplication, by code reuse. But it's
    our responsibility to keep in mind that with the relationship that these classes
    form using inheritance, they also transmit some significant semantic information.
    What do we mean by that? We mean that it's important to understand that when we
    inherit from some superclass, it becomes a public interface/construct representing
    our subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when inheriting dictionary from book, if it also keeps semantic information
    about whether the book is going to have a title, pages, cover, author, or other
    information, then its subclass is also expected to have this information available.
    The reason for this is that a `Book` is a public interface for a `dictionary`
    because of the inheritance relationship. And that's where sometimes we find ourselves
    using inheritance in the wrong way. Let's discuss this in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Misusing inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a class named `CustomStack` is inheriting from `ArrayList[String]`. What
    you see here is a semantic code smell. Just because your `CustomStack` class has
    extended from `ArrayList` means that you have access to all of its public members.
    Anyone with a stack object is not only going to have access to `push` or `pop`,
    but a whole set of methods like `get`, `set`, `add`, `remove`, and so on. This
    is wrong; you''re allowed to use an array list object internally to form a stack
    object but the public interface should have nothing to do with it. In our case,
    our code shows that if you have access to `CustomStack`, you have access to all
    those methods. You should avoid using this in the `Stack` construct. The reality
    is that both of these are different concepts altogether so we should avoid using
    such types of modeling where it is semantically wrong. Although it may be a design
    choice, still we should keep in mind a few points when making these decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for Is-A relationship, if it holds true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if rules for encapsulation, such as data hiding, hold true. You should
    never expose internal implementation details to the outer world. In our case,
    `Stack` should've implemented the array list internally instead of inheriting
    from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should check for domains of each construct, the cross domain inheritance
    model is not a good choice, for sure. `Stack` and `ArrayList` are different conceptually.
    One can be composed using the other but should not inherit the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you follow these points, you'll make a better design choice for modeling
    inheritance relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Well, you remember we learned about `case` classes and the way we used to instantiate
    them without the `new` keywords? That makes me wonder, what if we want to have
    more than one way to construct new objects of such a `case` class? If you're also
    thinking the same; good! It's possible to have parameterized constructors in Scala.
    Let's talk about them.
  prefs: []
  type: TYPE_NORMAL
- en: Default and parameterized constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary constructor for any class defined in Scala is the body itself.
    It means that whatever you declare and define inside a class body gets instantiated
    when you make an instance of it. There are other ways to define secondary/auxiliary
    constructors as well. Take a look at the following `case` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see two `case` classes named `Employee` and `StartUp`. You may wonder
    why `Employee` is specific to our `StartUp` class. The `StartUp` case class takes
    a few attributes such as `founder`, `coFounder`, `members`, and `foundingDate`.
    So, for creating instances of these `case` classes, we have to provide values
    for each member. In this case, if someone on the client side wants to use this
    `case` class and does not want to provide `members` or `coFounder` information,
    they still have to give dummy values. Now, the solution to this could be to construct
    auxiliary constructors for our client''s sake. This can be done if we provide
    alternative invocation strategies for the `StartUp` case class. Let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A few points to note here. Firstly, we can define overloaded versions of `this`
    method that work as auxiliary constructors. Secondly, in each definition, we''re
    making a call to the main constructor with some other values. This practice can
    be done on either of these sides. By this we mean that passing optional values
    can be done either at the time of declaring these `case` classes or on the client
    side where we use these. We''ve done it while declaring these classes. Now let''s
    use them in our `StartUpApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It was easy to use these auxiliary constructor versions of the `StartUp` case
    class. We can see that we only passed the needed parameters, and if the version
    was available to us, we were able to create an instance for it. But wait a second,
    we had these case classes and yet still we used the `new` keyword to create an
    instance for the `StartUp` class. What if we try to create an instance without
    using the `new` keyword? Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to do so, the Scala compiler will throw an error stating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because when you declare `case` classes, the compiler generates
    a companion object with the `apply` method for it and the `apply` method takes
    all the parameters of the `case` class definition. When we define auxiliary constructors,
    we don''t really overload the `apply` method defined in companion objects. Hence,
    when we try to use `case` class instantiation without the `new` keyword, the Scala
    compiler is not able to find a corresponding `apply` method version and gives
    an error. If you really want to use it that way, you can define overloaded versions
    of the `apply` method in companion objects. We''ll try to overload an implementation
    with only two parameters, `name` and `founder`*.* Let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to do. Defining an `apply` method that takes only `name` and `founder`
    gives us the option to create an instance of our `StartUp` object without using
    the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These are just a few ways; we can make the client's life easier by providing
    a variety of options to construct new objects. Now that we have seen how we can
    define various options for a class construct and also how inheritance can be effective
    if used properly, we can make our constructs more powerful by using traits in
    Scala. That's what we're going to explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are traits? For those coming from a Java background, it''s tempting to
    see them as interfaces, but in reality they are something different. **Trait**
    constructs may look similar but are of a different nature to interfaces in Java.
    The meaning of the word trait is: a distinguishing quality or characteristic,
    typically one belonging to a person. One of the purposes of traits is the same.
    What if you want to add a particular characteristic to our hierarchy of classes
    or a single class? You can do this by extending or mixing in a trait. It''s easier
    to say that we mix-in traits rather than extend from them. How are these two different?
    We''ll talk about this as we go along but for now, let''s take a look at how we
    define a `trait` in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at it this way. One of the qualities of people who tend to socialize well
    is that they greet you wholeheartedly when they meet you. In programming terms,
    you want to make a class named `Person` social. You can create a `trait` named
    `Socialize`, which for now just defines a method `greet`. This is simple: by defining
    a `trait`, we use the keyword `trait` and give it a name. We''ll talk about this
    as we go along but for now, let''s take a look at how we define a `trait` in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Traits do not take parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits can also form an inheritance hierarchy, a trait can mix-in another trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't have a class and trait with the same name in the same scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which we mix-in traits matters and can affect the behavior of your
    implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define traits by observing the previous points, but it''s also good
    to know how Scala treats traits at compile time. To understand this, we can use
    the `javap` command on our `Socialize` class. It''s going to show the compiled
    form of our trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows that we can have abstract, as well as concrete
    members, as part of our traits. Here we have just declared our `linkToSocialNetwork`
    method without definition and also our previous method, named `greet`, that has
    its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have given its implementation in the `Employee` class, which mixes in this
    trait. With this abstraction, we now can compare traits to abstract classes in
    Scala. What's the distinction between these two? First, you may see that we can't
    pass constructor parameters to our traits. Second, as constructs, traits are heavier
    than abstract classes. So it's a matter of choice for you to decide between these
    two. The recommendation is to select a trait if you're extending any functionality,
    or if only as a class hierarchy, then an abstract class could be a good choice.
    One more aspect of a trait is that it's stackable. This means it's obvious you
    can mix-in more than one and its effect can be used in a stackable manner. Let's
    take a look at how traits can be used to showcase stackable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Traits as mix-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we do trait mix-ins is no different than inheriting any class in Scala;
    the only difference is that you can mix-in more than one trait and for that we
    have this nice keyword called `with`. Why do we call it mix-in? We could have
    called it something else. Well, yes but this explains almost everything you can
    do with traits. It''s easy to modify or add up behaviors to an already existing
    functionality or construct without affecting already existing behavior. We''ll
    see that in a bit. Traits can be used in a variety of use cases such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Composable mix-ins; to make already existing interfaces richer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stackable modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits as composable mix-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By **composable mix-ins** we mean that we can create an instance of a particular
    type, with mix-ins of a trait, that can have certain additive functionalities.
    If you're thinking why would we want to do that, then the answer is maybe you
    want to add some particular behavior that makes sense to your functionality and
    you want it to behave as if it has come from the library itself. As a client of
    such constructs or libraries, we want them to feel as natural as they are. Traits
    help us add certain functions, keeping the real library intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can understand this better with the help of an example. So, suppose you
    have an already existing `CreditCard` functionality. For demonstration purposes,
    we''ll limit our expectations from this `CreditCard` functionality. This class
    has a certain way of generating credit card numbers for each subscriber. This
    is a thing of the past. Now, in the future, let''s say in the next few days, we
    want to introduce certain new `CreditCard` subscriptions with more offers (conditions
    apply). Also, we want to have our own way of generating `CreditCard` numbers,
    without affecting the already existing functionalities or the business. The reality
    might be different, but for learning purposes it''s fine to generate credit card
    numbers ourselves, isn''t it? So, now that you have this picture in mind. Let''s
    see what we already have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see how this `CreditCard` abstract class is defined, and our client
    `CCApp` is accessing that to create a new credit card account with a certain amount.
    Also, if you take a closer look, we didn''t try to define isolated concrete classes
    that extend our abstract class named `CreditCard`, but we directly instantiated
    `CreditCard`, which is only possible because Scala generates and instantiates
    an anonymous class for us and expects us to define the abstract method, in our
    case `creditLimit`. Now, our requirement is that without playing with the already
    available code, we want to have our own version of the `creditCardNumber` generator
    that generates the credit card number for us. Let''s do that then. But think about
    it, how are we going to do that and make it look natural? We want to do it this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we can define a `trait`, let''s say `CreditCardOps`, that''s going
    to define the functionality with which we can refer to the new logic without affecting
    the logic previously implemented. And for the clients it''s going to be natural.
    Let''s take a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage didn''t change too much, and we also achieved what we intended. The
    only new thing we introduced was a `trait` named `CreditCardOps`. This `trait`
    has defined the new logic that we wanted. A few points to note about this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to mix-in this `trait` to our `CreditCard` implementations whenever
    we want this synthetic behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also may want to ensure that this `trait` is specific to `CreditCard` types,
    hence any other traits or classes should not be allowed to mix-in this. We have
    eventually ensured that too. If you try to do something like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala compiler will not allow us to do this; the reason being that the
    syntax we choose to write while defining our trait is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This syntax gives a bit of information to the Scala compiler about upcoming
    statements in the current scope, as well as also limiting the trait's availability
    for certain types. Because of this syntax, we're only allowed to mix-in the `CreditCardOps`
    trait to `CreditCard` types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the following implementation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We are able to refer to `ccType` and `ccNum`, members of the `CreditCard` class,
    only because of this `self` type declaration*.* This declaration gives us access
    to members of the type specified.
  prefs: []
  type: TYPE_NORMAL
- en: We've just modified the logic for `ccNum` and consumed the previous logic to
    create the new one. This was possible because of mix-ins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, one constraint that we faced is that you may have wanted to `override`
    the value, `ccNum`, so that the clients of your `CreditCard` object, when accessing
    `ccNum`, could get the value based on the new logic, something similar to the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But, that's not possible. The compiler will let you do so but at runtime, the
    value will be null. A closer look will tell you that `self` is just a reference
    to the `CreditCard` type, hence you'll be able to refer to members, like we did
    while doing pattern matching, but if you try to `override`, it won't show the
    expected behavior. One reason for that is traits evaluate at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are finally able to get add-on behavior for only `CreditCard`
    types. This is the way we can make already existing constructs more powerful and
    can also modify them to suite our specific needs. We have a term for this process,
    we call it making thin interfaces rich through composable mix-ins. Why rich? Because
    of additive or selective modifications. There's more to traits based on our own
    use-cases. It's natural for an entity to have more than one trait, isn't it? Also,
    its understood if two or more composable behaviors are applied together, they'll
    both have their impact. It's an interesting topic; the way these behaviors are
    implemented. One of the ways these can be implemented is as *stackable modifications.*
  prefs: []
  type: TYPE_NORMAL
- en: Traits as stackable modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we learn about **stackable modifications*,*** we should know why we
    may need them, shouldn''t we? Yes, so the best way to understand that is by using
    an example. Suppose there''s a consumer of a service. He can pay to subscribe
    to a particular service. That service, for example your DTH TV subscription service,
    includes several channel packages. Now, what''s of interest to us here is that
    we may want to implement this service. For implementation, we want to have a list
    of channels or packages the consumer is subscribed to. At the beginning of the
    month, he subscribed to a particular package, let''s say `BasicPackage`. So we
    said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in fact is self-explanatory. We created a `Service` with `BasicPackage`.
    Thinking programmatically, we can assume that we''ve a particular value in our
    `Service` class that has the list of packages/channels listed in a certain package.
    So with this declaration, that attribute must''ve been updated with the value.
    Up till now, everything has been fine. What if the consumer wants to subscribe
    to one more package? And we don''t want to have a mechanism that explicitly modifies
    the list of channels for us, but it should happen by default. This is like a behavior
    that''s getting modified as we keep adding different packages. This kind of situation
    gets you to the concept of stackable modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With each added package, a list of channels/packages is going to update. We''ll
    see in a bit how the implementation implicitly stacks modifications as we add
    more packages. These modifications can be done on some data structure, where we
    can pipeline operations on data, or scenarios like we just mentioned. A sequence
    of operations/modifications in terms of traits can be added. Let''s take another
    example and work on it. For that we''ll take our `CreditCard` abstract class and
    modify it to suit our newly introduced `GoldCreditCard` and `PlatinumCreditCard`.
    These new card subscriptions have a lot to offer to consumers along with an increased
    limit. Subscribers to the gold card will get a credit limit of 10% more than the
    standard/basic credit card. The increased limit amount for a platinum card is
    25% more than a standard card, apart from the other goodies that they bring. A
    consumer who is adventurous enough may want to opt for both subscriptions together.
    So how do you think we can implement this? One hint, we may be using stackable
    modifications, which we just discussed*.* So, let''s take a look what we already
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing different here. We have our old abstract `CreditCard` class. We may
    want to create a standard/basic credit card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t alien code, it''s easy to understand. We created a `BasicCreditCard`
    class extending `CreditCard` and we are overriding the `creditLimit` method. This
    method is simply returning the `Amount` object for the limit amount. Now, let''s
    take a look at the implementation of other subscription types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Two more types named `GoldSubscription` and `PlatinumSubscription` as we discussed
    in terms of traits are added. What''s different here? Syntactical analysis will
    say that this has an `abstract override` modifier, but how? How can you have these
    two together? We declare something `abstract` if we are not willing to provide
    its definition and use `override` to redefine something already in scope. So,
    the thing is, both of these are conflicting. However, Scala, as we already know,
    is intelligent enough to know that this is done in the context of a trait, which
    gets evaluated at runtime, and when you try to create an instance of such a trait
    or mix-in with some already created concrete class, it''s going to override the
    particular definition. See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are going to expect a concrete implementation of `CreditCard` to mix-in
    this trait. Let''s take a look at the implementation `CCApp` to understand better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code is the implementation of the solution we came up with
    for our problem using stackable modifications. A few points to note here are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We didn't try to define some explicit logic implementation but made a *super*
    call to an already defined method with certain *additions*/*limitations*/*modifications*
    in a parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we're allowed to pass the same type of parameter and as it is composed,
    the value we'll get will be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can apply as many `CreditCard` subscriptions as we want and based on the
    logic, we''ll get the expected value for `creditLimit`. That''s why we were able
    to call the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, we mix-in the traits to concrete classes with overridden
    implementations for our abstract method, that's why `abstract override` worked
    here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was interesting, you know. We passed a `creditLimit` value of `15000` for
    all the different instances and we got corresponding values. All of this is due
    to trait's use of stackable modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Linearization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason why multiple inheritances become a burden when we try to implement
    them is due to *the diamond problem*. Take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diamond problem
  prefs: []
  type: TYPE_NORMAL
- en: Here, suppose we have an abstract class named `Language`, that has a method
    named `sayHello`. Two traits, named `British` and `Spanish`, extend the abstract
    `Language` class and define their own implementation of the `sayHello` method.
    Then we create a trait, named `Socializer`, that mixes in the other two traits
    with a `super` call to the `sayHello` method implementation. Now, confusion occurs
    as to which implementation of `sayHello` is getting called when we invoke this
    method. The primary reason for this problem is there's no multiple inheritance
    in Java, but Scala supports a form of multiple inheritance through *trait mix-in*.
    The concept Scala uses to resolve the problem of super calls is linearization.
    Let's first code for the problem and see it's behavior, then we'll understand
    linearization and the rules that justify the behavior we are going to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we code for the problem shown in the preceding image. It''s going to
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you expect this result? We had declared our class `Socializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows that the call made to `super.sayHello` invoked `sayHello`
    from the `Spanish` trait. Well, such behavior is due to linearization. But how
    does it work? The rules for linearization are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the very first extended trait/class and think of the hierarchy.
    We'll consider `AnyRef` and `Any` are also part of the inheritance hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is going to give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's call this a **linearized hierarchy **for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the next trait/class and write a hierarchy down for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Remove the traits/classes from this hierarchy that already exist in the linearized
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we''ll remove `AnyRef -> Any`. Remaining syntax will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Add the remaining traits/classes to the bottom of the already available linearized
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Repeat *step 2* for all traits/classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, place the trait/class at the very first position from the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The direction of super calls is going to be from *left* to *right.* And for
    our implementation, where we extended from `Spanish` with `British`, we now know
    that the `super` call invoked is on the `Spanish` trait due to linearization.
    The result was from the `Spanish` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This understanding can help us a lot to learn the usual behavior of trait mix-ins
    and inheritance. Knowing how linearization works is essential to understanding
    already written code and creating a good design yourself. Now that you know how
    linearization works, why not learn another important concept in object-oriented
    programming?
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and importing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important aspects of object-oriented programs is how we define modular,
    reusable, and hierarchical structures. We're allowed to put all the code that
    we write, constructs like classes, traits, and objects, in some particular package.
    By using *packaging* and *visibility* rules, we can make our code more to reason
    about, means to expose some method to other classes or  and we get structured
    and modular code as an added advantage. There are a couple of ways you're allowed
    to write package statements in Scala; we'll take a look at those.
  prefs: []
  type: TYPE_NORMAL
- en: Package statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write package statements at the beginning of the file. One of the simplest
    examples is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined the package name as `country`. Now, whatever we define in
    the corresponding file is going to stay within the scope of this `country` package.
    This is the reason why, when we wanted to use a function in the `Country` companion
    object*,* we did not need to explicitly put the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The ending `_` underscore symbol, is Scala's ways of doing a wildcard import.
    It means that non-private members are going to be accessible within the current
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple package statements in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala also allows us to put multiple package declarations and nested package
    declarations. First let''s take a look at how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we see how we can define multiple package statements within
    a file. A thing worth noticing is the way we did this. We used curly parentheses
    along with a `package` keyword to tell the Scala compiler that here's our package.
    Whatever we write inside this is going to reside in that package. Here, we defined
    three packages. One is `country`, to define country-specific constructs, another
    one is `state`, to define state specific constructs. The last one is a `customutil`
    package, which, as the name tells us, is to define utility functions for all the
    country/state functionalities. The `averagePopulation` function is not specific
    to country or state but can be used in both cases, hence it is defined in separate
    packages and imported globally at the top. With that import, we've gotten access
    for `customutil` to the scope of the whole compilation unit. One more thing we
    could have done is to declare package `state` as a nested package to `country`,
    because it's obvious multiple `country` constructs and members should be directly
    accessible to `state` constructs as well. Let's see how it's going to look.
  prefs: []
  type: TYPE_NORMAL
- en: Nested package statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know there might be times when we need some `country` package constructs
    directly available to the `state` package. In those scenarios we can define the
    `state` package as a nested package inside `country`. Let''s write that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a package `state` declaration nested inside a `country` package
    declaration. What this does is to avoid making explicit mentions to the full package
    declaration while importing. Also, it makes code easier to understand and more
    structured. It shows that it's OK to expect a country to be a `Region`, and a
    state can also be treated as a region. Thus, nesting of packages is also a good
    way to document your code. It shows an understanding of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining package statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's another way we can put up these package declarations, and that is by
    chaining the declarations of packages. How can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: By keeping the `Region` class in the `country` package, if we declare the `State`
    class with the preceding syntax, things will work out fine, and your class `State`
    is going to reside in package `country.state`. That means `state` is going to
    be a nested package. This way of writing package names is widely used in several
    libraries, you may find this out when you explore some of them.
  prefs: []
  type: TYPE_NORMAL
- en: These are all ways you can declare package names, and now you also know the
    reasoning behind it. Just because of the fact that we have the license to declare
    multiple package names, means it's easier for us to separate constructs based
    on their usage. For example, it's perfectly fine to declare a package for a `TestSuite`
    for your classes in the same file with a different package name. Everyone has
    their ways of writing and structuring package names. With these, declarations,
    we also have more than one way of importing these constructs in other scopes.
    Importing packages in Scala can also be done in some interesting ways; why not
    take a dig at that.
  prefs: []
  type: TYPE_NORMAL
- en: Importing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simpler scenarios, just to bring some objects into scope, we put an `import`
    statement before it. This is how importing can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We use an `import` keyword and give the name of the import. A few points to
    note down while using `import` in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: We are allowed to use imports anywhere in the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In instances where two imports collide, we have the right to hide one over the
    other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also rename some imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, we get flexibility while importing packages. Let''s take a look
    at some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, we declared an `import` statement just before we
    wanted to use it. Also, see the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This allowed us to use `u` in place of the `Util` object*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these depends on the scenario; most often we need to take care of code
    readability. For example, renaming `scala.collection.mutable` to something shorter
    is a good thing to do—developers following the code are going to find it easier
    to understand. Also, if you take a closer look, we renamed the object `Util`,
    so it''s proven that Scala allows us to import as well as rename objects. Moreover,
    Scala is capable enough of renaming the function names, and why not? Those are
    members that we are importing. We did just that in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We renamed the `averagePopulation` function to `ap`*,* and used that in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to keep in mind the same point: we may be renaming whenever it
    makes sense to do so—in our example, it doesn''t. But for demonstration purposes,
    it''s OK to consider that it does. Scala''s extensive ways for packaging and importing
    makes things easier for us. In namespace collision scenarios, we''ve ways to hide
    a definition over the other. That can be done with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You see? The declaration is self-explanatory. We renamed a particular package/member
    to a wildcard. It no longer provides any means to using this particular `Member`
    in the current scope and hides it. This is Scala's way of hiding a particular
    package/member.
  prefs: []
  type: TYPE_NORMAL
- en: These multiple ways of packaging and importing make our code easy to understand,
    but this is not all. We can also provide a few modifiers to control access to
    our members. We can make them `private`, `protected`, or by default `public`.
    Let's discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when we don''t want to let another class or similar construct
    use a few members. Here, we can use Scala''s provided access modifiers. How we
    achieve control over the accessibility of members of our classes/traits/objects
    is through `private`, `public`, or `protected` access modifiers. Take a look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have some trait named `Kitchen`. It has a secret way of cooking a
    really tasty dish, but only for `PrivateRestaurant` types. The secret cannot be
    shared outside the kitchen. In those scenarios, we can keep the secret as it is
    by declaring it with a modifier named `private`. With this, when we try to access
    the secret recipe, we are not able to do that. The Scala compiler gives an error
    stating: *Symbol secret is inaccessible from this place.* With that we were able
    to keep our secret intact. But what if you want to let your private restaurant
    access the secret and no one else. In that case you can make it `protected`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After making our secret protected, we can get access to it only if `PrivateRestaurant`
    extends `Kitchen`. If you remember, this is doing composition and thus we''ll
    have access to the secret by just changing the `private` modifier to `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We should know, for `protected` to work, it''s a must to inherit the member
    class/trait. What we mean by this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have this mix-in. That''s the reason why, after applying
    the `protected` modifier, we got access to the secret recipe. By the way, when
    we don''t specify any access modifiers, Scala treats the members as `public` and
    those members can be accessed if in scope. When it comes to controlling the access
    levels, Scala has more to offer than what we just learnt. We can also specify
    the scope of protection. By scope of protection we mean that the particular member
    is visible up to a certain level. Here, it depends on us what level we define.
    Let''s look at an example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'With a proper look at the code, there are some points that we can consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following declaration, it makes it clear that the secret value is going
    to be privately accessible within this package named `privaterestaurant`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the Scala compiler is not going to complain about the way you used these
    scopes, but at runtime you can expect an exception if your scope is not within
    the package. It means that for our following declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: For it to work properly, we need to be part of this package. That's logically
    correct, otherwise it's not wise to apply privacy to something that's not ours.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `private[X]`, we can also define `protected[Y]` and so on. Defining
    `protected` for some package is going to make it available to classes in the inheritance
    tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's another level of protection, that is, `private[this]`. It's going to
    make a particular member available to an instance of the same class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's really important to control the access level. With it we can have fine-grain
    scope for every construct. This keeps the client away from unnecessary details
    that you might not want them to access. This is all about limiting the scope for
    members. There are a few more construct such as `sealedtraits`, that help us structure
    the code in a good way, but that's just one thing about them. There's much more
    to know about.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One good thing about **sealed traits** is that standard Scala library uses
    these constructs a lot, and you''ve also seen them many times so far. It''s time
    to learn about them. We''ll start with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a sealed trait named `Season`. Then there're a few child season
    case objects extending from the `sealed trait Season`. By the way, case objects
    are like `case` classes with the difference being that these are only instances
    with already available names, unlike the `case` classes. There're a few points
    to note about the preceding implementation of the sealed trait named `Season`.
  prefs: []
  type: TYPE_NORMAL
- en: All children extending the `Season` trait should be defined in the same file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructs such as sealed traits come with a license to perform pattern matching.
    This is good for design constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, when we perform *pattern matching* on sealed traits, we need to take care
    of all the possibilities. Otherwise, as we know, the Scala compiler is intelligent
    enough to come up with a warning about the remaining scenarios whenever it sees
    that the pattern match is on a sealed trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few good and known examples of sealed traits are `Option` type to two children
    named `Some` and `None`. Then, `List` is also defined as a sealed trait. This
    was a short introduction to sealed traits with the license for you to experiment
    with the construct. With sealed traits we have come to the end of the chapter.
    Let's summarize what we have learnt so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was more exciting. We learnt about inheritance in Scala and discussed
    composition and inheritance. It's really going to help us when we take design
    decisions about our implementation. Then we learnt about this amazing construct
    named traits and we tried various ways of using traits. Then we learnt about the
    concept of linearization which it helped us understand how super calls are resolved.
    Then we talked about packaging and importing which was exciting as Scala provides
    different ways to use them. Finally, we learnt about *visibility rules* and *sealed
    traits*. And after going through all these concepts, we can say with confidence
    that we now understand the object-oriented concepts in Scala. So, it's time for
    us to do some real functional programming. In the next few chapters our focus
    will be on using functions in Scala.
  prefs: []
  type: TYPE_NORMAL
