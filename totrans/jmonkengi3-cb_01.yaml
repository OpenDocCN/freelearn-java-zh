- en: Chapter 1. SDK Game Development Hub
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 SDK游戏开发中心
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Setting up a project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Importing a model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模型
- en: Using the Scene Composer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用场景作曲家
- en: Modifying heightmaps with Terrain Editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地形编辑器修改高度图
- en: Adding a sky box and lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加天空盒和照明
- en: Adding water using a filter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器添加水
- en: Adding some ambient audio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些环境音频
- en: Creating bitmap fonts with Font Creator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Font Creator创建位图字体
- en: Retrieving an attachment node
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取附件节点
- en: Using ParticleEmitter—Soaring Birds
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子发射器——飞翔的鸟
- en: An advanced ParticleEmitter class
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级粒子发射器类
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Welcome to the first chapter of this book! In this chapter, we'll go through
    various functions of the SDK. These are the features that make the development
    process accessible to people other than programmers. You can also, in many cases,
    get quick visual results by just tweaking values and without having to launch
    an application. In short, it's a development hub because you will return and use
    these functions from time to time in your project. On the difficulty scale, these
    recipes lean towards the easy side, with little or no programming. The exception
    is the last part of the chapter where modifying the core packages is necessary
    to achieve the results we want.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第一章！在本章中，我们将介绍SDK的各种功能。这些功能使得除了程序员之外的人也能轻松地进行开发。在许多情况下，您只需调整值，无需启动应用程序，就可以快速获得视觉结果。简而言之，它是一个开发中心，因为您将在项目中不时地返回并使用这些功能。在难度等级上，这些食谱倾向于简单，编程很少或没有。例外的是本章的最后部分，需要修改核心包才能达到我们想要的结果。
- en: Setting up a project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: The jMonkeyEngine SDK is based around the NetBeans environment. Users familiar
    with the NetBeans environment will probably have little trouble finding their
    way around the jMonkeyEngine SDK. For those with no previous experience, some
    pointers on how to get started might be in place. In this recipe, we'll create
    a project that can access the jMonkeyEngine test-data library. By doing so, we
    will have some assets available from the start that can be used to try out many
    of the recipes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: jMonkeyEngine SDK基于NetBeans环境。熟悉NetBeans环境的用户在使用jMonkeyEngine SDK时可能不会有太多困难。对于那些没有先前经验的人来说，一些如何开始的指导可能很有帮助。在本食谱中，我们将创建一个可以访问jMonkeyEngine测试数据库的项目。通过这样做，我们从一开始就拥有一些可以用来尝试许多食谱的资产。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before setting up a project, we need to download the SDK. Doing so is as easy
    as going to [http://hub.jmonkeyengine.org/downloads/](http://hub.jmonkeyengine.org/downloads/)
    and selecting a suitable package for your operating system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置项目之前，我们需要下载SDK。这样做就像去[http://hub.jmonkeyengine.org/downloads/](http://hub.jmonkeyengine.org/downloads/)并选择适合您操作系统的合适包一样简单。
- en: After downloading and installing the package, we're ready to go!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装包后，我们就准备就绪了！
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can set up a project by performing the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤设置项目：
- en: First of all, find the **Projects** window.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，找到**项目**窗口。
- en: Right-click somewhere inside it and select **New Project**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中某处右键单击，然后选择**新建项目**。
- en: In the window that appears, select **JME3** from **Categories** and **BasicGame**
    from **Projects**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中，从**类别**中选择**JME3**，从**项目**中选择**BasicGame**。
- en: On the next screen, choose a suitable name for the project and click on **Finish**
    to create it.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，为项目选择一个合适的名称，然后单击**完成**以创建它。
- en: The project should now appear in the **Projects** window. Right-click on it
    and select **Properties** from the menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目现在应该出现在**项目**窗口中。右键单击它，从菜单中选择**属性**。
- en: Select the **Libraries** option, click on the **Add Library…** button, and find
    the `jme3-test-data` library from the list.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**库**选项，单击**添加库…**按钮，并从列表中找到`jme3-test-data`库。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the project is created, it sets up the basic necessities for a jMonkeyEngine
    project. You will get a **Project Assets** folder where any content can be placed
    in its subfolders. It also creates the `Main.java` file based on the `SimpleApplication`
    class. This is the starting point for your application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目创建时，它会为jMonkeyEngine项目设置基本需求。您将获得一个**项目资产**文件夹，您可以将任何内容放置在其子文件夹中。它还会根据`SimpleApplication`类创建`Main.java`文件。这是您应用程序的起点。
- en: Importing a model
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入模型
- en: Let's start off with a pretty basic scenario. We have this model, which we've
    exported from a 3D modeling package, and we would like to use it for our game.
    The first thing we need to do is convert it to the format that jMonkeyEngine 3
    uses internally (`.j3o`). The recommended format to use is `.blend` coming from
    the open source modeling package Blender for which the SDK has extensive support.
    Another common format is `.obj` for static models and Ogre-mesh XML files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常基础的场景开始。我们有一个从3D建模软件导出的模型，我们希望将其用于我们的游戏。我们首先需要做的是将其转换为jMonkeyEngine
    3内部使用的格式（`.j3o`）。推荐的格式是来自开源建模软件Blender的`.blend`格式，该SDK对其提供了广泛的支持。另一种常见的格式是用于静态模型的`.obj`格式和Ogre-mesh
    XML文件。
- en: How to do it…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can import a model by performing the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤导入一个模型：
- en: Go to the **File** menu and select **Import Model**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件**菜单并选择**导入模型**。
- en: Next, we need to choose the project we would like to import.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择我们想要导入的项目。
- en: After selecting the actual model to be imported, we get to preview the model
    and can make sure that all the assets are properly used.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择要导入的实际模型后，我们可以预览模型并确保所有资产都得到正确使用。
- en: Finally, we select where to place it in the **Project Assets** folder structure.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在**项目资产**文件夹结构中选择放置的位置。
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The importer converts the model to the internal `.j3o` format. This is a binary
    format, which means it becomes nonreadable (compare it with a `.obj` file, which
    can be edited in Notepad). The compactness of a binary file is necessary to keep
    memory consumption low. It becomes impossible to edit externally, though, so keeping
    the original files organized is a good idea!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 导入器将模型转换为内部的`.j3o`格式。这是一个二进制格式，这意味着它变得不可读（与可以编辑的`.obj`文件相比）。二进制文件的紧凑性对于保持内存消耗低是必要的。但是，它变得无法外部编辑，因此保持原始文件组织良好是一个好主意！
- en: Using Scene Composer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scene Composer
- en: Here, we'll go through the basics of using Scene Composer in the SDK. Scene
    Composer is a place where we can preview objects, prepare them for in-game usage,
    and combine them to form scenes. Further usage includes viewing a model's skeleton
    and bones setup or playing animations. You can also apply materials, lighting,
    and set some basic geometry data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过SDK中使用Scene Composer的基本操作。Scene Composer是一个我们可以预览对象、为游戏使用准备它们并将它们组合成场景的地方。进一步的使用包括查看模型的骨架和骨骼设置或播放动画。你还可以应用材质、灯光并设置一些基本的几何数据。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Having some models to play around with will be useful if you want to create
    an interesting scene. We will use the Jaime model from the test-data library.
    You can find it in the **Jaime** folder inside **Models** and copy it to your
    project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个有趣的场景，有一些模型可以玩将很有用。我们将使用测试数据库中的Jaime模型。你可以在**Models**文件夹中的**Jaime**文件夹中找到它，并将其复制到你的项目中。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's start by creating a scene we can use to test our recipes later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个场景，稍后我们可以用它来测试我们的食谱。
- en: Right-click on the **Scenes** folder inside **Project Assets**, select **New**,
    and then select **Empty jME3 Scene**. The scene will open automatically in the
    **SceneComposer** window.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**项目资产**中的**场景**文件夹，选择**新建**，然后选择**空jME3场景**。场景将自动在**SceneComposer**窗口中打开。
- en: A scene is just an empty node, and needs to be populated to be useful. To have
    something to look at, let's add the Jaime model to the scene. Find it in the folder
    structure, right-click on **Jaime.j3o**, and select **Link in SceneComposer**.
    The **SceneComposer** window looks as follows:![How to do it…](img/6478OS_01_01.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景只是一个空节点，需要填充才能变得有用。为了有东西可以查看，让我们将Jaime模型添加到场景中。在文件夹结构中找到它，右键单击**Jaime.j3o**，然后选择**在SceneComposer中链接**。**SceneComposer**窗口如下所示：![如何操作…](img/6478OS_01_01.jpg)
- en: Now, most likely, all we can see is a blue, wire-frame box. This is because
    there are no lights in the scene. At the top-left part of the screen, there is
    a button with a light bulb on it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们很可能只能看到一个蓝色的线框盒子。这是因为场景中没有灯光。屏幕左上角有一个带有灯泡按钮的按钮。
- en: By clicking on it, we should get **PointLight** following the camera; it is
    not part of the scene, however.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击它，我们应该得到**PointLight**跟随相机；然而，它不是场景的一部分。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Linking versus adding**'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**链接与添加**'
- en: Adding means you add an instance of the object itself to the scene. This can
    then be modified separately to the original object.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加意味着将对象本身的一个实例添加到场景中。这可以单独修改，而不影响原始对象。
- en: Linking means you add a reference to the object in the scene. Apart from making
    the scene smaller, any modifications to the original object will also affect the
    objects in the scene.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 链接意味着你为场景中的对象添加一个引用。除了使场景更小之外，对原始对象的任何修改也将影响场景中的对象。
- en: Basic camera orientation in the scene includes dragging with the left mouse
    button to rotate the camera. Dragging with the right mouse button pressed moves
    the camera sideways, up, and down. The mouse wheel zooms in and out.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景中的基本相机方向包括用鼠标左键拖动来旋转相机。按住鼠标右键拖动将相机移动到侧面、向上和向下。鼠标滚轮用于缩放。
- en: The second icon in the top bar of the **SceneComposer** window is the Move icon.
    By clicking on it, you will see three different colored planes by Jaime. These
    will be highlighted as you move your mouse over them. If you press the left mouse
    button while they're highlighted, you will move the object in the dimensions of
    that plane.![How to do it…](img/6478OS_01_02.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**场景合成器**窗口顶部栏的第二个图标是移动图标。通过点击它，你会看到Jaime的三个不同颜色的平面。当你将鼠标移过它们时，它们会被突出显示。如果你在它们突出显示时按下鼠标左键，你将在该平面的维度中移动对象。![如何做到这一点…](img/6478OS_01_02.jpg)'
- en: The same rules apply to the next icon, Rotation. Note, though, that scaling
    is uniform across all the axes.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样的规则适用于下一个图标，旋转。注意，尽管如此，缩放在所有轴上是均匀的。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to have total control over your transformations, you can use the
    **Properties** window to set the exact values for translation, rotation, and scale.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要完全控制你的变换，你可以使用**属性**窗口来设置平移、旋转和缩放的精确值。
- en: If you'd like to have an in-depth knowledge of the SDK, have a look at the videos
    on [http://hub.jmonkeyengine.org](http://hub.jmonkeyengine.org).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解SDK，请查看[http://hub.jmonkeyengine.org](http://hub.jmonkeyengine.org)上的视频。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Scene Composer runs an instance of a jME application and what you see is very
    much what you will get when watching the scene in the game (minus the camera light).
    Use it to preview and tweak your assets before bringing them inside your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 场景合成器运行一个jME应用程序的实例，你所看到的就是你在游戏中观看场景时将得到的结果（不包括相机灯光）。使用它来预览和调整你的资产，然后再将它们带入你的应用程序中。
- en: There's more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now that we have a scene, what''s needed to load it into an application? Just
    the following lines of code are needed, really:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了场景，要将它加载到应用程序中需要什么？实际上只需要以下几行代码：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add the preceding code in the `simpleInitApp()` method of `Main.java`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main.java`的`simpleInitApp()`方法中添加前面的代码。
- en: Modifying heightmaps with Terrain Editor
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地形编辑器修改高度图
- en: In Terrain Editor, we find a number of functions that let us modify a heightmap-based
    terrain, something which is used in many games.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在地形编辑器中，我们发现有许多函数可以让我们修改基于高度图的地形，这在许多游戏中都有应用。
- en: A heightmap, in its simplest form, is a 2D array (the dimensions representing
    *x* and *y* coordinates) usually storing floats that represent height values.
    These can be saved as grayscale images where brighter areas correspond to higher
    ground and, reversibly, darker areas correspond to lower ground.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，高度图是一个二维数组（维度代表*x*和*y*坐标），通常存储表示高度值的浮点数。这些可以保存为灰度图像，其中较亮的区域对应较高的地面，反之，较暗的区域对应较低的地面。
- en: The terrain fields of jMonkeyEngine have much more information to help you create
    a visually appealing terrain. Things like vertex normal data and color and texture
    data are available for modification through the API, for daring programmers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: jMonkeyEngine的地形字段提供了更多信息，帮助你创建视觉上吸引人的地形。例如，顶点法线数据、颜色和纹理数据都可以通过API进行修改，这对于勇敢的程序员来说是有用的。
- en: '![Modifying heightmaps with Terrain Editor](img/6478OS_01_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用地形编辑器修改高度图](img/6478OS_01_08.jpg)'
- en: A heightmap
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 高度图
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will begin by creating a terrain for the scene before exploring how to modify
    it. To do this, perform the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为场景创建地形，然后再探讨如何修改它。为此，执行以下步骤：
- en: First, we either create a new scene or load a scene we've worked with previously.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要么创建一个新的场景，要么加载我们之前工作过的场景。
- en: In the **SceneExplorer** window, right-click on the main scene node and select
    **Add Spatial** and then **Terrain..**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景探索器**窗口中，右键单击主场景节点，选择**添加空间**然后**地形**。
- en: To edit the terrain, we have to find the scene j3o file in the **Projects**
    window. It should be present in the **Scenes** folder inside **Project Assets**.
    Right-click on the scene file and select **Edit Terrain**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编辑地形，我们必须在**项目**窗口中找到场景j3o文件。它应该位于**项目资产**中的**场景**文件夹内。右键单击场景文件并选择**编辑地形**。
- en: Now, we have a flat and nice terrain. While it's perfectly functional, let's
    explore the functions in the **TerrainEditor** window. These functions are shown
    in the following screenshot:![How to do it...](img/6478OS_01_07.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有一个平坦且美观的地形。虽然它功能齐全，但让我们探索**地形编辑器**窗口中的功能。这些功能在下面的屏幕截图中有展示：![如何操作...](img/6478OS_01_07.jpg)
- en: Next to the Add Terrain icon, you have the raise/lower terrain icon. This icon
    uses the values of **Radius** and **Height/Weight** sliders to modify the terrain.
    Try it out and see how it can be used to create hills and valleys. The Level terrain
    icon can be used to create flat areas in the terrain. It works by right-clicking
    on an area, the height of which you would like to have as a reference, and then
    holding the left mouse button and flattening out the terrain at the selected height,
    creating plateaus.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加地形图标旁边，你有提升/降低地形图标。此图标使用**半径**和**高度/权重**滑块的值来修改地形。试一试，看看它如何用来创建山丘和山谷。水平地形图标可以用来在地形中创建平坦区域。它的工作原理是在你希望作为参考的高度区域上右键单击，然后按住鼠标左键，在地形所选高度上拉平，从而创建高原。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're going to use this as a test bed for the other chapters, try to keep
    the area just around Jaime at the default height, for now. This is because we
    don't have any logic to keep it at the actual ground level, and we would like
    to see what is going on in the recipes.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打算将其用作其他章节的测试平台，请尝试保持Jaime周围区域的高度为默认值，至少目前是这样。这是因为我们没有逻辑来保持它在实际地面水平，我们想看看食谱中发生了什么。
- en: While the terrain comes with basic texturing, we might want to do something
    more interesting. First of all, we need to add another texture layer. This is
    done with the icon that looks like a plane with a plus sign on top (the Add another
    texture layer icon).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然地形自带基本纹理，但我们可能想要做一些更有趣的事情。首先，我们需要添加另一个纹理层。这是通过一个看起来像带有加号顶部的飞机图标（添加另一个纹理层图标）来完成的。
- en: After clicking on it, there should be another row in the **Painting** window,
    below it. Clicking on the **Texture** field will bring up a selector with all
    the textures available to the project. Select a suitable texture among the available
    ones.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它后，在**绘画**窗口下方应该出现另一行。点击**纹理**字段将弹出一个选择器，显示项目中所有可用的纹理。从可用的纹理中选择一个合适的纹理。
- en: Now, to paint, click on the button with a spray can on it. You can now paint
    by holding the left mouse button over the terrain, and erase by pressing the right
    mouse button. Like most of the other functions in the **TerrainEditor** window,
    it uses the **Radius** and **Height/Weight** values.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要绘画，点击带有喷雾罐按钮的按钮。你现在可以通过在地面上按住鼠标左键来绘画，通过按住鼠标右键来擦除。像**地形编辑器**窗口中的大多数其他功能一样，它使用**半径**和**高度/权重**值。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When painting a terrain by hand, it is a good idea to have a reference image
    of the terrain type at hand. That way we can, for example, see how grass grows
    on slopes, or snow gathers on mountains, and produce more realistic results. Always
    start by painting in broad strokes, gradually painting with smaller and smaller
    brushes.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当手动绘制地形时，手头有一张该类型地形的参考图像是个好主意。这样我们就可以，例如，看到草如何在斜坡上生长，或者雪如何在山上聚集，从而产生更逼真的效果。始终从大笔触开始绘制，逐渐使用越来越小的画笔。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The function of most of the buttons is pretty self-explanatory, but let's look
    at what happens when either of them are applied.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数按钮的功能相当直观，但让我们看看当其中任何一个应用时会发生什么。
- en: A little bit of smoothing is something that might be needed after generating
    a heightmap using an automated tool. In such a case, you most likely won't use
    a brush, though, but rather a filter that will apply it evenly across the whole
    of the heightmap. The brush might instead be used to smooth out an area where
    a game character is supposed to move to make it a better game experience. It might
    also be that the ground of an area is of a type that would most likely be smoother
    than the surroundings, like a beach among rocky cliffs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自动化工具生成高度图之后，可能需要一点平滑处理。在这种情况下，你很可能不会使用画笔，而是使用一个将均匀应用于整个高度图的过滤器。画笔可能被用来平滑游戏角色应该移动的区域，以获得更好的游戏体验。也可能是一个区域的地面类型比周围环境更平滑，比如岩石悬崖中的海滩。
- en: Level terrain has similar uses. If we need sufficient space to place a large
    building for example, it is the best way to ensure that no part of the building
    ends up floating or submerged beneath the ground.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 平坦的地形有类似的使用。如果我们需要足够的空间放置一个大型建筑，例如，这是确保建筑物的任何部分都不会漂浮或沉没在地下的最佳方式。
- en: Adding a sky box and lighting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加天空盒和灯光
- en: Sky boxes or sky domes are small pieces of every day magic in games. They're
    used to create a mood-setting backdrop for scenes and are excellent for making
    areas seem larger than they are.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒或天空穹顶是游戏中常见的魔法元素。它们被用来为场景创造一种氛围背景，非常适合让区域看起来比实际更大。
- en: Sky boxes consist of six textures, rendered on the inside of a cube, much like
    wallpapers. Perceived as enclosing the world, they actually don't need to be very
    big since they are rendered first in the queue. This means everything else will
    be drawn on top of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒由六个纹理组成，渲染在一个立方体的内部，就像壁纸一样。虽然它们被视为包围世界，但实际上它们不需要很大，因为它们是队列中首先渲染的。这意味着其他所有东西都将绘制在它们之上。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The recipe will consist of two sections, where the first section will create
    a sky box from six textures. After this, we will add sun-like light using **Directional
    Light**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配方将包括两个部分，其中第一部分将使用六个纹理创建天空盒。之后，我们将使用**方向光**添加类似太阳的光。
- en: In the **SceneExplorer** window, right-click on your scene and select **Add
    Spatial..** and then **Skybox..**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景探索器**窗口中，右键点击你的场景并选择**添加空间..**然后**天空盒..**。
- en: 'There are two options here: either we can load six independent textures or
    one texture with all the six textures prebaked. This particular recipe uses the
    six `Lagoon` textures from the `test-data/Textures/Sky` folder.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有两种选择：要么我们可以加载六个独立的纹理，要么可以加载一个包含所有六个纹理的预烘焙纹理。这个特定的配方使用了来自`test-data/Textures/Sky`文件夹的六个`Lagoon`纹理。
- en: After this, we should now see a moody, watery scene surrounding the terrain.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们应该现在看到围绕地形的忧郁、水景。
- en: The terrain and skybox don't blend together very well. First and foremost the
    lighting is wrong. The only light in the scene is a white light coming from the
    camera's origin. To get a more natural light in this outdoor scene, we can add
    **Directional Light**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地形和天空盒之间的融合并不很好。首先，灯光是错误的。场景中唯一的灯光是从摄像机原点发出的白色灯光。为了在这个户外场景中获得更自然的光线，我们可以添加**方向光**。
- en: Again, right-click on the scene in the **SceneExplorer** window. Now, select
    **Add Light..** and then select **Directional Light**. Things just got a lot brighter!
    It doesn't look better, however. We need to adjust the light to suit the scene.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在**场景探索器**窗口中右键点击场景。现在，选择**添加光..**然后选择**方向光**。场景变得明亮了许多！然而，它看起来并没有更好。我们需要调整灯光以适应场景。
- en: 'We can see the **DirectionalLight** element in the **SceneExplorer** window.
    Select it and bring up the **Properties** window. There are just two settings:
    `Color` and `Direction`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在**场景探索器**窗口中看到**方向光**元素。选择它并打开**属性**窗口。这里只有两个设置：`颜色`和`方向`。
- en: By clicking on the box next to the color values, we see several options to set
    the color. We can use an image editor and the colorpicker function near the sun
    to get a suitable color. Grab the RGB values and insert them in that tab. This
    way, we know that we get a color that matches the scene's sun.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击颜色值旁边的框，我们可以看到几个设置颜色的选项。我们可以使用图像编辑器和太阳附近的颜色选择器功能来获取合适的颜色。获取RGB值并将它们插入到那个标签中。这样，我们就知道我们得到了与场景中的太阳相匹配的颜色。
- en: Turning off the camera light (the light bulb in the top-left corner) will help
    us see the blue-tinted color from the light we just added.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭相机灯光（左上角的灯泡）将帮助我们看到我们刚刚添加的带有蓝色色调的颜色。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's often a good rule of thumb to have a little less tint than what might first
    seem like a suitable one. It usually feels more natural in the end. Show it to
    someone else and see if they think it's "too much". As a developer, your judgment
    can be "tainted", as you get used to a scene, and it's easy to overdo things like
    lighting.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，比看起来可能合适的颜色稍微浅一点是一个很好的规则。最终通常感觉更自然。拿给别人看，看看他们是否认为它“太多”。作为一个开发者，你的判断可能会“受污染”，因为你习惯了场景，很容易过度处理像光照这样的东西。
- en: There's one more thing to do to make the scene and sky box blend better together.
    The shadows on the terrain are at wrong places in relation to the sun in the scene.
    The default setting for **Directional Light** is to shine in from the southwest
    direction and about 45 degrees downwards. This particular sky box has the main
    source of light coming from the northeast direction. Flipping the minus sign on
    the *x* and *z* values in the **Direction** property seems to make the shadows
    look more natural.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使场景和天空盒更好地融合在一起，还有一件事要做。地形上的阴影与场景中的太阳位置不匹配。**方向光**的默认设置是从西南方向照射，大约45度向下。这个特定的天空盒主要光源来自东北方向。在**方向**属性中将*x*和*z*值的负号翻转似乎可以使阴影看起来更自然。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What you see of a sky box can alter the perception of immersion, greatly. Generally,
    the player should not see anything below the horizon for it to look believable.
    You will notice this if you zoom in and out of the scene. As you're close to the
    ground, it will feel much more natural.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你看到的关于天空盒的内容可以极大地改变沉浸感的感知。一般来说，玩家不应该看到地平线以下的东西，这样才能看起来逼真。如果你在场景中放大和缩小，你会注意到这一点。当你靠近地面时，它会感觉更加自然。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reason sky boxes work is because of how the rendering of the scenegraph
    happens. Objects can be sorted into different lists or buckets, to help the rendered
    in drawing. A sky box is sorted into the `Bucket.Sky` list, which is drawn first
    in every rendering cycle. This is why everything else (normally in the `Bucket.Opaque`
    list) appears to be in front of it. You can achieve the same effect for any object
    by calling `Geometry.setQueueBucket (Bucket.Sky)`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒之所以能工作，是因为场景图的渲染方式。对象可以被分类到不同的列表或桶中，以帮助渲染。天空盒被分类到`Bucket.Sky`列表中，在每次渲染周期中首先绘制。这就是为什么其他所有东西（通常在`Bucket.Opaque`列表中）看起来都位于它前面。你可以通过调用`Geometry.setQueueBucket
    (Bucket.Sky)`为任何对象实现相同的效果。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can achieve the same effect on other objects by changing the `QueueBucket`
    renderers as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式更改`QueueBucket`渲染器，以在其他对象上实现相同的效果：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's more…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you look closely at Jaime (or any other object you added to the scene) with
    the camera light turned off, you will notice that the side not facing the light
    will be completely dark. Unless this is a place devoid of atmosphere, radiance,
    diffusion, and reflection of other surfaces, one should have given all sides some
    basic lighting. This is emulated in games by using ambient lighting. It lights
    all the faces evenly and is added by selecting the scene in the **SceneExplorer**
    window and choosing **Add Light**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察Jaime（或你添加到场景中的任何其他对象），关闭相机灯光，你会注意到背对灯光的那一侧将完全黑暗。除非这是一个没有大气、辐射、散射和反射其他表面的地方，否则应该给所有侧面一些基本的光照。这在游戏中通过使用环境光照来模拟。它均匀地照亮所有面，并且通过在**SceneExplorer**窗口中选择场景并选择**添加灯光**来添加。
- en: You can select the same color as **Directional Light**, but make it much darker
    to get something that will look natural. If you're really serious, and have a
    somewhat uniform ground color, you can try to blend in a little bit of the ground
    color, as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择与**方向光**相同的颜色，但让它变得更暗，以得到看起来自然的东西。如果你真的很认真，并且地面颜色相对均匀，你可以尝试混合一点地面颜色。
- en: Adding water using a filter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器添加水
- en: 'When it comes to bang-for-the-buck visuals in jMonkeyEngine, there is little
    that trumps using a water filter. It is very impressive and yet easy to do. Having
    water in the scene will greatly enhance the mood of our test scene. You can view
    the great looking water with little efforts in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到jMonkeyEngine中的性价比视觉效果时，几乎没有比使用水过滤器更胜一筹的方法。它非常令人印象深刻，而且很容易做到。在场景中有水将极大地增强我们测试场景的氛围。你可以在以下截图中看到通过少量努力就能实现的出色水面效果：
- en: '![Adding water using a filter](img/6478OS_01_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用过滤器添加水](img/6478OS_01_06.jpg)'
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The scene used should have some height differences (or we will end up with all
    water or all ground). If no terrain is available or if it needs adjustments, check
    out the *Modifying heightmaps with Terrain Editor* recipe in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的场景应该有一些高度差异（否则我们可能会得到全部是水或全部是地面的效果）。如果没有地形可用或需要调整，请查看本章中的*使用地形编辑器修改高度图*配方。
- en: If there isn't already an **Effects** folder in your **Projects Assets** folder,
    add it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的**项目资产**文件夹中还没有**效果**文件夹，请添加它。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can add water using a filter by performing the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤使用过滤器添加水：
- en: Right-click on the **Effects** folder under **Project Assets**, select **New**,
    and then select **Empty FilterPostProcessor file**. You might have to select **New**,
    **Other...**, and then click on **Filters** to find it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**项目资产**下的**效果**文件夹，选择**新建**，然后选择**空过滤器后处理文件**。您可能需要选择**新建**，**其他...**，然后点击**过滤器**以找到它。
- en: Name it `Water` and click on **Finish**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Water`并点击**完成**。
- en: Right-click on the newly created **Water.j3f** file and open it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的**Water.j3f**文件并打开它。
- en: We are now moved to the **FilterExplorer** window. From here, we can create,
    add, and modify scene-wide effects, choosing from a number of premade ones. Right-click
    on the **Water** filter and select **Add Filter** and then **Water**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在转到**过滤器资源管理器**窗口。从这里，我们可以创建、添加和修改场景级别的效果，从众多预设中选择。右键单击**水**过滤器，选择**添加过滤器**然后选择**水**。
- en: To see filters in the **SceneComposer** window, we need to click on the Eye
    icon shown in the following screenshot. This should give the scene a whole new
    look. Do it and see the scene transform.![How to do it…](img/6478OS_01_04.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在**场景合成器**窗口中查看过滤器，我们需要点击以下截图所示的眼睛图标。这将使场景焕然一新。试试看，看看场景如何变换。![如何操作…](img/6478OS_01_04.jpg)
- en: A few properties need to be modified in order to make the water appear smoothly.
    The **Properties** window for the **WaterFilter** element can seem a bit overwhelming.
    For now, let's change the **Water Height** parameter. The filter will create foam
    wherever it meets the land and finds a good separation or where the shore height
    is essential. The sweet spot is dependent on the scene but starts out with -2
    units. Changing the following values will affect the appearance along the shoreline:![How
    to do it…](img/6478OS_01_09.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使水面看起来平滑，需要修改一些属性。**水过滤器**元素的**属性**窗口可能会显得有些令人不知所措。现在，让我们更改**水高**参数。过滤器将在遇到陆地并找到良好的分离或岸边高度至关重要的地方创建泡沫。最佳位置取决于场景，但最初为-2单位。更改以下值将影响海岸线的外观：![如何操作…](img/6478OS_01_09.jpg)
- en: There are also **Light Direction** and **Light Color** properties in there.
    Let's copy the values from our **Directional Light** element here to make them
    match. You will find them by moving to the **SceneExplorer** window, selecting
    the **Directional Light** element, and looking in the **Properties** window.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中还有**光方向**和**光颜色**属性。让我们将我们的**方向光**元素的值复制到这里，使它们匹配。您可以通过转到**场景资源管理器**窗口，选择**方向光**元素，并在**属性**窗口中查找它们。
- en: 'Lastly, we need to add the following lines to the `simpleInit` method of our
    test application:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将以下行添加到我们的测试应用的`simpleInit`方法中：
- en: '[PRE2]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Post filters are rendered last as a screen effect in the rendering stage and
    applied to the entire scene. There are many ready-made filter variants made by
    the jME team and community that you can use to change how a scene appears. Filter
    Explorer is a great way to set up and test these before applying them to your
    game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 后置过滤器在渲染阶段作为屏幕效果渲染，并应用于整个场景。jME团队和社区制作了许多现成的过滤器变体，您可以使用它们来改变场景的外观。过滤器资源管理器是设置和测试这些过滤器并在应用到游戏中之前的好方法。
- en: Adding some ambient audio
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些环境音频
- en: Audio is an extremely important moodsetter in games, and any other cross-media
    product, which is often overlooked. Bad audio can just as easily break immersion
    as good audio can improve it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 音频是游戏中以及任何其他跨媒体产品中极其重要的情绪营造者，但常常被忽视。糟糕的音频可以像好的音频一样轻易地破坏沉浸感。
- en: We're going to add some ambient audio to our scene to help set the mood. Since
    the sky box we use is a rather gloomy and watery scene, we're going to add the
    sound of ocean waves crashing against the shore.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向场景添加一些环境音频以帮助营造氛围。由于我们使用的天空盒是一个相当忧郁且多水的场景，我们将添加海浪拍岸的声音。
- en: Ambient sounds can either be sounds you hear throughout a whole scene, such
    as the buzzing of traffic in a city, or local to a specific place, the sound of
    a waterfall, and so on. In this case, we can picture our scene as a small island,
    and thus the waves should be heard wherever you go.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 环境声音可以是你在整个场景中听到的声音，例如城市中交通的嗡嗡声，或者特定地点的声音，如瀑布声等。在这种情况下，我们可以将场景想象成一个小的岛屿，因此波浪声应该在任何地方都能听到。
- en: As it happens, there is a suitable `.ogg` file in the **Environments** folder
    inside `Sound`. If we have added the `jme3-test-data` library to our project,
    we can access it easily.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在`Sound`文件夹内的**环境**文件夹中有一个合适的`.ogg`文件。如果我们已经将`jme3-test-data`库添加到我们的项目中，我们可以轻松访问它。
- en: The SDK can handle both `.ogg` or uncompressed `.wav` files. The `.ogg` format
    is open and free, meaning you won't need any license to use it. This is not necessarily
    the case with other compression types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SDK可以处理`.ogg`或未压缩的`.wav`文件。`.ogg`格式是开放和免费的，这意味着您不需要任何许可证就可以使用它。其他压缩类型的情况可能并非如此。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'If we''ve made the previous recipes, we might already have seen the audio node.
    The following steps will help show us how to add one to the scene:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经制作了前面的食谱，我们可能已经看到了音频节点。以下步骤将帮助我们展示如何将一个添加到场景中：
- en: We can find the audio node by right-clicking on a spatial, in this case the
    main scene node, and selecting **Add Spatial** and then **Audio Node**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在空间上（在这种情况下是主场景节点）右键单击并选择**添加空间**然后**音频节点**来找到音频节点。
- en: Next, select it and look at the **Properties** window.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择它并查看**属性**窗口。
- en: The first important thing to look at is the **Audio Data** parameter. In the
    drop-down menu, the SDK will automatically show the files in the **Sounds** folder
    under **Project Assets**, so we should see **Ocean Waves.ogg** here. Unchecking
    the **Positional** checkbox means there will be no falloff in volume as you move
    around.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要查看的重要事项是**音频数据**参数。在下拉菜单中，SDK将自动显示**项目资源**下**声音**文件夹中的文件，因此我们应该在这里看到**Ocean
    Waves.ogg**。取消选中**位置**复选框意味着在移动时不会有音量衰减。
- en: Also check the **Looping** box to make sure the sound doesn't end when it's
    finished playing one time.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要检查**循环**复选框，以确保声音在播放一次后不会结束。
- en: 'It''s currently not possible to hear the sound in the SDK itself, so we need
    to start an application to do so. Fortunately, only one line of code is needed
    to start the sound in our `simpleInitApp` method. The only catch here is that
    we need to cast the `scene` object in an `AudioNode` instance first. After having
    loaded the scene, add the following lines of code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前在SDK本身中无法听到声音，因此我们需要启动一个应用程序来做到这一点。幸运的是，在`simpleInitApp`方法中启动声音只需要一行代码。这里的唯一问题是，我们需要首先将`scene`对象强制转换为`AudioNode`实例。在加载场景后，添加以下代码行：
- en: '[PRE3]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The sound we added is a very powerful sound and may be a bit overwhelming for
    our scene. Playing with the `Volume` property of the `AudioNode` element can be
    used to tone down the effect a bit.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加的声音非常强大，可能对我们的场景来说有点压倒性。通过调整`AudioNode`元素的`Volume`属性可以稍微降低效果。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `AudioNode` element has a position in the 3D world since it extends `Spatial`
    and can hence be made to be heard only from certain places. It can also easily
    be made to follow objects around. In addition to volume and falloff, audio can
    also be modified during runtime by area effects such as reverb.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioNode`元素在3D世界中有一个位置，因为它扩展了`Spatial`，因此可以使其仅在特定位置被听到。它也可以很容易地使其跟随物体移动。除了音量和衰减外，音频还可以通过如混响等区域效果在运行时进行修改。'
- en: To learn more about how effects can be used to modify audio, check out [Chapter
    9](ch09.html "Chapter 9. Taking Our Game to the Next Level"), *Taking Our Game
    to the Next Level*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何使用效果来修改音频的信息，请查看第9章[《将我们的游戏提升到下一个层次》](ch09.html "第9章。将我们的游戏提升到下一个层次")，*《将我们的游戏提升到下一个层次》*。
- en: Creating bitmap fonts with Font Creator
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Font Creator创建位图字体
- en: The Font Creator plugin is a really nifty tool for any game creator and is easily
    overlooked unless mentioned. By using it, you can create a bitmap font using any
    system font you have available. Refer to the *Downloading the plugins* section
    in [Appendix](apa.html "Appendix A. Information Fragments"), *Information Fragments*,
    to know how to download a plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create bitmap fonts with Font Creator by performing the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Fonts** folder under **Interface** in our **Project Assets**
    folder. Select **New** and then select **Other...**. **Font** is located in the
    GUI folder.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we choose the font we would like to use from the available system fonts.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure Font** part, we can make adjustments before actually creating
    the bitmap. It's recommended to use a power-of-two number for the size.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A higher resolution will make the text more detailed, but it will at the same
    time take up more memory, not only for the bitmap image itself but also for the
    text generated. Consider the application requirements or do some testing. You
    can also try to adjust the size of the font to fit the bitmap.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have our font, there are a couple of ways we can use it. First of all,
    if we want to replace the default font used by the application, we have to name
    the font `Default.fnt` and make sure it's placed inside the **Fonts** folder under
    **Interface**. This is what the application is looking for during startup.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to use the custom font is to load it in the application by using
    the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It can then be used to create text that can be placed anywhere on the screen,
    as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BitmapText` class is spatial, and needs to be attached to a node in order
    to be displayed. The most common node is probably the `guiNode`. Spatials added
    to the `guiNode` will be positioned according to the screen space and projected
    without depth. For this reason, using the `guiNode` is suitable for **HUD** items.
    Setting the `localTranslation` parameter to `(0, 0, 0)` will make the text appear
    in the bottom-left corner of the screen. Instead of using (`screenWidth, 0,` `screenHeight`),
    we will place it in the top-right corner.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving an attachment node
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many games, the characters can be customized to carry different equipment
    or clothes. In these situations, jMonkeyEngine's Attachments node is extremely
    useful. It lets us choose a bone and creates a node for us that will follow that
    particular bone's movement and rotation, without any further work from our side.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need a rigged model with `SkeletonControl`. Fortunately, the Jaime model
    is already rigged and animated. We'll also need something to attach to it. What
    goes well with monkeys if not bananas?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the model in the **SceneComposer** window by right-clicking on it in **Projects**
    and selecting **Edit** in **SceneComposer**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `SkeletonControl` class. Located under `Root` is a Bone called `IKhand.R`,
    as shown in the following screenshot:![How to do it…](img/6478OS_01_10.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **IKhand.R** and select **Get attachment Node**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should now see a node called **IKhand.R_attachnode** created at the top level
    of the hierarchy. Attach the banana to the node by dragging it into the **SceneExplorer**
    window. The banana should now appear in Jaime's hand.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The banana will not fit perfectly in this recipe. To achieve a perfect fit,
    the best way will be to create an actual bone, just for attachments, in the modeling
    program of our choice. Since the attached item is attached using the model's center
    point, we can expect to have to tweak the position of the items as well.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To prove that the banana will actually follow the movement of the model, we
    can play an animation. Select **AnimControl** in the **SceneExplorer** window
    and look at the **Properties** window. Choose an animation from the drop-down
    menu.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we first call `getAttachmentsNode` on a `Bone` object, it will create a
    new node. It will then keep track of it and update its translation, rotation,
    and scale according to the values of the `Bone` object. It works as a regular
    node in most regards, with the difference being that it follows the `IKhand.R`
    bone's movements during animations. It is very handy, isn't it?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this is, of course, possible to do using code as well. Just like in the
    SDK, we use the following `SkeletonControl` class to achieve this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using ParticleEmitter – Soaring Birds
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle Emitters, in general, are good in order to create an atmosphere in
    the games. The most common case is probably for smoke or fire and explosions.
    Particles can, however, be used for many interesting things. In this recipe, we're
    going to explore that by tuning a ParticleEmitter to create birds sailing through
    the sky.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The particles are still sprites, 2D images, so they will work best either far
    up in the sky, or below us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe will be divided into two parts. The first one contains setting up
    the `ParticleEmitter` class in the SDK and writing the `ParticleInfluencer` interface.
    The second part includes changing the way the `ParticleEmitter` class behaves
    and extending our `ParticleInfluencer` interface to take advantage of this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ParticleEmitter – Soaring Birds](img/6478OS_01_05.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need a suitable bird texture. There's one supplied with the
    project in the **Birds** folder inside **Textures**, which will be fine if the
    birds are supposed to be far away. Up close, it will not suffice though.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first section will describe how to set up a material we can use. This consists
    of the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We're going to start by creating a material to supply to the `ParticleEmitter`
    class. Create a new material in the **Materials** folder by right-clicking and
    selecting **New…** and then **Empty Material File**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to something suitable, for example, `Birds.j3m`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can open it and are automatically moved to the **Material Editor** window.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we set the **Material Definition** value to `Common/Matdefs/Misc/Unshaded.j3md`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only thing we need to change is the **ColorMap** value, which should be
    pointed to our birds texture.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we come to the configuration of the `ParticleEmitter` class. This section
    consists of the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating a new scene and opening it in the **SceneExplorer**
    window. Right-click and select **Add Spatial..** and then **Particle Emitter**.
    A default smoke puffing the `ParticleEmitter` object is created.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can bring up the **Properties** window and start tweaking it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all, we set the material to our newly created material for the birds.
    Don't worry if it looks terrible!
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking at the `Images X` property, we can see that it's set to **15** by default.
    This is the amount of horizontal "frames" in the texture. If we look at the birds
    texture, we can see that it's only four frames, so let's change that value. The
    particles are already looking better.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`High Life` and `Low Life` define the maximum or minimum lifespan of a particle.
    We can assume that the birds should soar across the sky for a while, so let''s
    change it to **30** and **25** respectively.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are an awful lot of birds now. Setting `Num Particles` to **50** will
    make more sense.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Start Size` and `End Size` affect the size of the particles over time. These
    should be set to **1** for our birds. They shouldn''t inflate.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, let's increase the radius of the emitter to get a better view. It's
    a sphere by default and the last value is the radius. Set it to **30**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we take a look at the birds now, they still just float in space. This is
    very unbird-like.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's scroll down a bit to the `ParticleInfluencer` class. The `ParticleInfluencer`
    class has an opportunity to alter a particle's velocity when it's created, decreasing
    uniformity. The `DefaultParticleInfluencer` class can set an initial velocity,
    and a variation, from 0 to 1.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `InitialVelocity` parameter to `3.0, 0.0, 0.0` and the `VelocityVariation`
    to `1.0` to give the particles some individuality.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the birds look in the direction they're flying, check the **Facing Velocity**
    box.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New settings won't take effect immediately, but only when a new particle is
    generated. If you want to speed up the process, click on the "**Emit All**" button
    to emit all the new particles with the new settings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A ParticleEmitter can be described as a cheap way to draw many identical or
    near-identical bitmaps. Particle Emitters have a single mesh that stores all its
    particles. As opposed to drawing each particle individually, it renders them all
    at once. This is considerably cheaper. The drawback is, of course, that they all
    look the same.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another thing we can do to improve the appearance of the generated
    birds. Since we are expecting to look at them from either above or below, it makes
    sense to flatten the shape of the emitter to be more of a plane. Let''s revisit
    the `Emitter Shape` property and make a box instead of a sphere, as shown in the
    following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The numbers define the extremes of a box, that is, *X* ^(*min*), *Y* ^(*min*),
    *Z* ^(*min*) and *X* ^(*max*), *Y* ^(*max*), and *Z* ^(*max*). In other words,
    we have created a box that is 60 units wide and long and only 2 units high.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: An advanced ParticleEmitter class
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Soaring birds are nice but it's easy to feel that the result of the previous
    recipe could have been much better if the birds were better animated. If you've
    worked with the `ParticleEmitter` class before or have been observant of the birds,
    you will know that particles can actually be animated although they only cycle
    through every frame once per lifetime. This is much too slow for the birds.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to look at what's needed to make the birds flap
    their wings. It's not as simple as it sounds and requires modifying the `ParticleEmitter`
    code and writing our own `ParticleInfluencer` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: If we have a look at the `ParticleEmitter` class to see what we need to do,
    we can see that there is an `updateParticle` method that seems like a good place
    to start. This is called for every particle in each update cycle. One thing that
    is less obvious at first is that since we have the same `ParticleInfluencer` instance
    affecting all particles, it also needs to be updated separately for each frame.
    To achieve the latter, we can use a control.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to modify the `ParticleEmitter` class, we need the source. This means
    we have to check it out from the repository. If you're not comfortable with this,
    you can still do the first part and learn more about the `ParticleInfluencer`
    instance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: After having checked out the source code for jMonkeyEngine from the repository,
    it should be opened as a project in the SDK.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Build it and then change the reference in the properties for this project to
    use the `.jar` files from the source code project instead of the supplied `jMonkeyEngine.jar`
    files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first section, we''ll create a new `ParticleInfluencer` instance. This
    consists of the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is create a new class called `BirdParticleInfluencer`
    and have it extend the `DefaultParticleInfluencer` class. Since the flat particles
    point in the direction they''re flying, it sometimes looks weird when they have
    a Y-velocity. We''re going to fix that by not allowing the particles to have any
    velocity in the *y* axis. We override the `influenceParticle` method and set the
    Y-velocity to `0`. After this we need to normalize the velocity, as shown in the
    following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can now replace the `ParticleInfluencer` interface in the `ParticleEmitter`
    element's **Property** window with our own.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That was the easy part, and that''s how far we get without modifying the engine.
    In the next section, we will extend the current `ParticleEmitter` instance to
    animate particles continuously. This will consist of the following steps:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by making our `ParticleInfluencer` interface ready to update the
    particles in every frame. Let''s start by making our `ParticleInfluencer` interface
    ready to update the particles in every frame. We''re going to add two methods
    to it. The first one is for updating the particle, and the second one is for updating
    the influencer itself, as shown in the following code:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our `BirdParticleInfluencer` class, we''re going to need some new fields.
    The `maxImages` property keeps track of how many images there are in a cycle.
    The `animationFps` property defines how fast the animation should run. These two
    properties should be added to the class''s read/write/clone methods as well to
    ensure that they''re saved properly. The `time` and `increaseFrames` are runtime
    properties only:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s go to our `update` method. This is the method that runs once every
    frame. We add functionality to check whether it''s time to change the frame in
    the particle or not. The logic goes like this: when the current passed time is
    larger than the time between frames, increase the frame index by one. Using a
    `while` loop rather than an `if` statement allows us to compensate for low frame
    rate, by skipping several frames, if necessary, to keep up with the frames per
    second:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `influenceRealtime`, which is the method that is run once per particle and
    frame, all we do is tell it to increase the `imageIndex` value if needed, making
    sure not to exceed the maximum images in the cycle:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s the influencer part. Let''s make sure `influenceRealtime` is called
    from the `ParticleEmitter` class. At the end of the `updateParticle` method, add
    the following code:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, we also need to comment out the following line:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the last section of the recipe, we will create a control that will update
    the `ParticleInfluencer` class. This consists of the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new class called `BirdParticleEmitterControl` and make it extend
    `AbstractControl`. The important bit here is the `controlUpdate` method where
    we in turn call the `update` method of the `ParticleEmitter` instance:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Apart from that, we also need to add the following code for it to work properly:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To affect the birds by our changes, we need to do a few more things. First,
    we need to open the birds scene in the **SceneComposer** window.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting the **Emitter** element, we need to choose **Add Control..** and then
    select **Custom Control**. Our newly created control should be available in the
    list.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to load the scene inside an application. We just load the scene
    and move it up into the sky by using the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Particle emitters are normally limited in what control you have over the particles.
    The `ParticleInfluencer` class gives us some basic control during particle creation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子发射器通常在控制粒子方面有限。`ParticleInfluencer` 类在粒子创建过程中提供了基本控制。
- en: Since the birds are flat planes, they look best when viewed straight on. This
    creates a problem when we have said that they should always point in the direction
    they're flying if they're moving along the *y* axis.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于鸟儿是平面，当从正面观看时看起来最好。这在我们说它们如果沿着 *y* 轴移动时应该始终指向它们飞行的方向时，造成了一个问题。
- en: The `influenceParticle` method is a method implemented from the `ParticleInfluencer`
    interface and it is called upon the creation of every new particle. Since the
    `DefaultParticleInfluencer` instance is already applying a velocity with variation,
    we just needed to remove any Y-velocity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`influenceParticle` 方法是从 `ParticleInfluencer` 接口实现的方法，并且在新粒子创建时被调用。由于 `DefaultParticleInfluencer`
    实例已经应用了带有变化的速率，我们只需要移除任何 Y-速率。'
- en: In the `ParticleEmitter` class, we commented out a line in the `update` method.
    That's the current animation logic that will override our changes every time.
    A workaround would be to let the `ParticleInfluencer` class keep track of the
    current frame, but that would make all the birds have the same frame. Another
    alternative would be to move it to one of the other `ParticleInfluencer` classes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ParticleEmitter` 类中，我们在 `update` 方法中注释掉了一行。这是当前的动画逻辑，每次都会覆盖我们的更改。一种解决方案是让
    `ParticleInfluencer` 类跟踪当前帧，但这会使所有鸟儿都有相同的帧。另一种选择是将它移动到其他 `ParticleInfluencer`
    类之一。
- en: By using the control pattern to update the `ParticleInfluencer` class, we can
    offset some code and keep minimum changes in the `ParticleEmitter` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用控制模式来更新 `ParticleInfluencer` 类，我们可以偏移一些代码，并在 `ParticleEmitter` 类中保持最小的更改。
- en: Unfortunately, the changes we made to the `ParticleEmitter` class won't be picked
    up by Scene Composer, as it uses its own compiled classes. So to see it, we had
    to start an application and load the scene there.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们对 `ParticleEmitter` 类所做的更改不会被场景作曲家识别，因为它使用自己的编译类。因此，为了看到它，我们必须启动应用程序并在那里加载场景。
- en: There's more…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The birds now continuously flap their wings like many small birds do when flying.
    Larger birds tend to glide more, with only an occasional flap. They also fly in
    straight lines.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的鸟儿会像许多小鸟在飞行时那样连续拍打翅膀。较大的鸟儿倾向于滑翔更多，偶尔才拍打翅膀。它们也沿直线飞行。
- en: The `influenceRealtime` method we created opens up new possibilities to create
    better looking particles.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `influenceRealtime` 方法为创建外观更好的粒子开辟了新的可能性。
- en: An additional touch would be to implement logic to have the birds both soar
    and flap interchangeably, and circle around a point or change their direction.
    Are you up for it?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个额外的点是将逻辑实现为鸟儿可以交替进行翱翔和拍打翅膀，并围绕一个点盘旋或改变方向。你准备好了吗？
