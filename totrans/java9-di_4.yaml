- en: Dependency Injection with Google Guice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our journey began, we have learned the concepts of the DI pattern to understand
    IoC, got an idea about the modular framework of Java 9 and its DI mechanism, and
    in the last chapter, we acquired knowledge of the most widely used Spring Framework
    to understand DI using various examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see the rudiments of the **Google Guice** framework and
    its DI mechanism, and we will also learn various injection types and binding techniques
    while defining DI in Guice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to the Google Guice framework
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the benefits of DI in software engineering, but choosing a framework
    wisely is also important when implementing DI because each framework has its own
    advantages and disadvantages. There are various Java-based dependency injection
    frameworks available in the open source community, such as Dagger, Google Guice,
    Spring DI, JAVA EE 8 DI, and PicoContainer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will learn in detail about Google Guice (pronounced *juice*), a lightweight
    DI framework that helps developers to modularize applications. Guice encapsulates
    annotation and generics features introduced by Java 5 to make code type-safe.
    It enables objects to wire together and tests with fewer efforts. Annotations
    help you to write error-prone and reusable code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In Guice, the `new` keyword is replaced with `@inject` for injecting dependency.
    It allows constructors, fields, and methods (any method with multiple numbers
    of arguments) level injections. Using Guice, we can define custom scopes and circular dependency, and
    it has features to integrate with Spring and AOP interception.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Guice also implements **Java Specification Request** (**JSR**) **330**,
    and uses the standard annotation provided by JSR-330\. The first version of Guice
    was introduced by Google in 2007 and the latest version is Guice 4.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Guice setup
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our coding simple, throughout this chapter, we are going to use a Maven
    project to understand Guice DI.  Let’s create a simple Maven project using the
    following parameters: `groupid:`,` com.packt.guice.id`, `artifactId : chapter4`,
    and `version : 0.0.1-SNAPSHOT`. By adding `Guice 4.1.0` dependency on the `pom.xml`
    file, our final `pom.xml` will look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this chapter, we have used JDK 9, but not as a module project because the
    Guice library is not available as a Java 9 modular jar.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and JSR-330
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into Guice injection, let's look at the DI pattern again, along
    with JSR-330, in brief.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A dependency injection mechanism enables an object to pass dependencies to another
    object. In Java, using DI, we can move dependency resolution from compile time
    to runtime. DI removes hard dependency between two Java classes; this allows us
    to reuse class as much as and also classes are  independently testable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Specification Request-330**: There is a different way to define dependency
    in Java classes, but `@Inject` and `@Named` are the most common annotations used
    to describe dependencies in Java classes from JSR-330. According to JSR-330, objects
    can be injected into the class constructor, the parameter of the method, and a
    field level. As per best practices, static field and method-level injection should
    be avoided for the following reasons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 规范请求-330**：在Java类中定义依赖关系有不同的方式，但`@Inject`和`@Named`是JSR-330中最常用的注解，用于描述Java类中的依赖关系。根据JSR-330，对象可以被注入到类的构造函数、方法的参数和字段级别。根据最佳实践，应避免静态字段和方法级别注入，以下是一些原因：'
- en: Static field only injected when the first-time class object was created via
    DI, which makes static field inaccessible for the constructor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在通过DI第一次创建类对象时，才会注入静态字段，这使得静态字段对构造函数不可访问
- en: At runtime, the compiler complains if a static field is marked as final
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，如果静态字段被标记为final，编译器会报错
- en: When the first instance of the class is created, only static methods are called
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类的第一个实例被创建时，只会调用静态方法
- en: 'As per JSR-330, the injection can be performed in this order: first, constructor
    injection; then field injection; and the last is method level injection. But,
    you can''t expect the methods or fields to be called in the sequence of their
    assertion in the class.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JSR-330，注入可以按以下顺序执行：首先，构造函数注入；然后是字段注入；最后是方法级别注入。但是，你不能期望方法或字段按照它们在类中的声明顺序被调用。
- en: A constructor can't use injected member variables, because field and method
    parameter injection takes place only after calling a constructor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不能使用注入的成员变量，因为字段和方法参数的注入仅在调用构造函数之后发生。
- en: Example of simple DI
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单DI的示例
- en: '`NotifictionService` represents a common service interface for sending data
    to a different system:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationService`代表一个通用的服务接口，用于向不同的系统发送数据：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous interface defines a method signature for `sendNotification()`
    by passing the message and recipient details and returning the type as Boolean. `SMSService.java` is
    a concrete implementation of this interface for sending SMS notifications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的接口通过传递消息和接收者详细信息并返回布尔类型来定义`sendNotification()`方法的签名。`SMSService.java`是这个接口的实体实现，用于发送短信通知：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous class implemented code for sending SMS by accepting the message
    and recipient details. Now, we create a client application, `NotificationClient.java`,
    which will use `NotificationService` to initialize the actual SMSService. The
    same object can be used to send notifications to different systems, including
    email or custom notifications:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节课实现了通过接受消息和接收者详细信息来发送短信的代码。现在，我们创建一个客户端应用程序，`NotificationClient.java`，它将使用`NotificationService`来初始化实际的SMSService。同一个对象可以用来向不同的系统发送通知，包括电子邮件或自定义通知：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous example, even though implementation and interface are loosely
    coupled, we need to create a manual instance of the real implementation of the
    class in the client application. In this scenario, at compilation time, the client
    application knows which execution classes related to interfaces will be bound.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，尽管实现和接口是松散耦合的，但我们需要在客户端应用程序中手动创建类的真实实现的一个实例。在这种情况下，在编译时，客户端应用程序知道与接口相关的执行类将如何绑定。
- en: That is the thing that Google Guice does; it takes instances as services from
    the client application code and the dependency between the clients, and their
    service is consequently injected through a simple configuration mechanism.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Google Guice 所做的；它从客户端应用程序代码中获取实例作为服务，并注入客户端之间的依赖关系，然后通过简单的配置机制注入服务。
- en: Let's see an example of dependency injection in Guice by using different API
    in the next topic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在下一个主题中使用不同的API来查看Guice中依赖注入的一个示例。
- en: Basic injection in Guice
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guice 中的基本注入
- en: 'We have seen a basic DI implementation, now it is time to understand how injection
    works in Guice. Let''s rewrite the example of a notification system using Guice,
    and along with that, we will see several indispensable interfaces and classes
    in Guice.  We have a base interface called `NotificationService`, which is expecting
    a message and recipient details as arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个基本的DI实现，现在是时候了解Guice中的注入是如何工作的了。让我们重写一个使用Guice的示例通知系统，同时我们还将看到Guice中的一些不可或缺的接口和类。我们有一个名为`NotificationService`的基本接口，它期望以消息和接收者详细信息作为参数：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `SMSService` concrete class is an implementation of the `NotificationService` interface.
    Here, we will apply the `@Singleton` annotation to the implementation class. When
    you consider that service objects will be made through injector classes, this
    annotation is furnished to allow them to understand that the service class ought
    to be a singleton object. Because of JSR-330 support in Guice, annotation, either
    from `javax.inject` or the `com.google.inject` package, can be used:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`SMSService`具体类是`NotificationService`接口的实现。在这里，我们将`@Singleton`注解应用到实现类上。当你考虑到服务对象将通过注入器类创建时，这个注解被提供以允许它们理解服务类应该是一个单例对象。由于Guice支持JSR-330，可以使用`javax.inject`或`com.google.inject`包中的注解：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the same way, we can also implement another service, such as sending notifications
    to a social media platform, by implementing the `NotificationService` interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以通过实现`NotificationService`接口来实施另一个服务，例如向社交媒体平台发送通知。
- en: 'It''s time to define the consumer class, where we can initialize the service
    class for the application. In Guice, the `@Inject` annotation will be used to
    define `setter-based` as well as `constructor-based` dependency injection. An
    instance of this class is utilized to send notifications by means of the accessible
    correspondence services. Our `AppConsumer` class defines `setter-based` injection
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是定义消费者类的时候了，在这里我们可以初始化应用程序的服务类。在Guice中，`@Inject`注解将用于定义基于`setter`以及基于`constructor`的依赖注入。这个类的实例被用来通过可访问的通信服务发送通知。我们的`AppConsumer`类定义了如下基于`setter`的注入：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Guice needs to recognize which service implementation to apply, so we should
    configure it with the aid of extending the `AbstractModule` class, and offer an implementation
    for the `configure()` method. Here is an example of an injector configuration:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Guice需要识别要应用哪个服务实现，因此我们应该通过扩展`AbstractModule`类来配置它，并为`configure()`方法提供一个实现。以下是一个注入器配置的示例：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous class, the module implementation determines that an instance of
    `SMSService` is to be injected any place a `NotificationService` variable is determined.
    In the same way, we just need to define a binding for the new service implementation,
    if required. Binding in Guice is similar to wiring in Spring:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，模块实现确定在确定`NotificationService`变量的地方注入`SMSService`的一个实例。同样，如果需要，我们只需要为新服务实现定义一个绑定。在Guice中的绑定类似于Spring中的连接：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the previous program, the  `Injector` object is created using the `Guice`
    class''s `createInjector()` method, by passing the `ApplicationModule` class''s
    implementation object. By using the injector''s `getInstance()` method, we can initialize the
    `AppConsumer` class. At the same time as creating the AppConsumer''s objects,
    Guice injects the needy service class implementation (`SMSService`, in our case).
    The following is the yield of running the previous code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`Injector`对象是通过`Guice`类的`createInjector()`方法创建的，通过传递`ApplicationModule`类的实现对象。通过使用注入器的`getInstance()`方法，我们可以初始化`AppConsumer`类。在创建`AppConsumer`对象的同时，Guice注入了所需的服务类实现（在我们的例子中是`SMSService`）。以下是运行前面代码的结果：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, this is how Guice dependency injection works compared to other DI. Guice
    has embraced a code-first technique for dependency injection, and management of numerous XML
    is not required.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是与其它DI相比Guice依赖注入的工作方式。Guice采用了代码优先的依赖注入技术，并且不需要管理多个XML文件。
- en: 'Let''s test our client application by writing a **JUnit** test case. We can
    simply mock the service implementation of `SMSService`, so there is no need to
    implement the actual service. The `MockSMSService` class looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个**JUnit**测试用例来测试我们的客户端应用程序。我们可以简单地模拟`SMSService`的服务实现，因此不需要实现实际的服务。`MockSMSService`类看起来是这样的：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the JUnit 4 test case for the client application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对客户端应用程序的JUnit 4测试用例：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take note that we are binding the `MockSMSService` class to `NotificationService` by
    having an anonymous class implementation of `AbstractModule`. This is done in the `setUp()` method,
    which runs for some time before the test methods run.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过`AbstractModule`的匿名类实现将`MockSMSService`类绑定到`NotificationService`。这是在`setUp()`方法中完成的，该方法在测试方法运行之前运行一段时间。
- en: Guice API and Phases
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guice API 和阶段
- en: 'We have seen DI examples using various Guice APIs, including interfaces and
    classes. So, it is time to understand the principal API and architecture. Guice
    architecture is divided into two phases: Start-up and runtime.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Start up phase
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the start-up phase, APIs such as `Module`, `AbstractModule`, `Binder`,  `Injector`,
    `Guice`, and `Provider` play a significant role in Guice dependency injection.
    Let us learn about each API in detail, starting with **module interface**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Module interface
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special interface that you use to tell Guice which implementations
    go with which interfaces. Modules are objects that preserve a set of **bindings**.
    It is viable to have multiple modules in a piece of software. Injectors interact
    with modules to get the feasible bindings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The module is represented by using an interface with a method referred to as `Module.configure()`,
    which ought to be overridden with the aid of the application to populate the bindings.
    If we rewrite our `ApplicationModule` by implementing the `Module` interface,
    then it would look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The AbstractModule class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve things, there is an abstract class called `AbstractModule`, which
    straightforwardly extends the module interface, so applications can rely upon
    `AbstractModule` as opposed to module.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: It's strongly suggested that modules should be extended to the usage of `AbstractModule`.
    It gives a more readable configuration, and additionally steers us away from the
    excessive invoking of methods on the binder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In our example `ApplicationModule`, to configure Guice instead of implementing
    the module interface, we have used `AbstractModule`, where Guice passes our module
    to the binder interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In the event that an application has a predetermined number of configurations,
    they could be consolidated in a solitary module. For such applications, a single
    module per package or a single module per application could be a suitable system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Binder
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This interface mainly includes information associated with **bindings**. A binding
    normally consists of a mapping between an interface and a concrete implementation.
    For example, if we consider an implementation of the module interface for creating
    custom module, then the reference to the interface `NotificationService` is bound
    to the `SMSService` implementation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When coding, notice that the objects for both the interface and implementation
    classes are passed to the `bind()` and then `to()` methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second way is to tie an interface directly to its instance by writing the
    following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Injector
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Injector` interface creates and maintains object graphs, tracks dependencies
    of each type, and uses bindings to inject them. Injectors keep a set of **default
    bindings**, from which they take configuration details for making and maintaining
    relationships between objects. Consider the following code, which will return
    an implementation of the `AppConsumer` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also get all the associated bindings with the injector by calling the `Injector.getBindings()` method,
    which returns a map containing binding objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过调用`Injector.getBindings()`方法来获取与注入器关联的所有绑定，该方法返回一个包含绑定对象的映射：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From this, we can say that each binding has a matching `key` object, which is
    internally made and kept by the Google Guice class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以得出结论，每个绑定都有一个匹配的`key`对象，该对象由Google Guice类内部创建并保留。
- en: Guice
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guice
- en: '`Guice` is a final class, an entry point to the Guice framework. It''s used
    to create injectors by providing a set of modules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guice`是一个最终类，是Guice框架的入口点。它通过提供一组模块来创建注入器：'
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Provider
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者
- en: 'By default, whenever an application requires an instance of an object, Guice
    instantiates and returns it; but, in some cases, if the object creation process
    needs customization, then Guice providers do that. A provider interface takes
    after the conventional factory design in making objects.  For instance, consider
    our `ApplicationModule` class binding process:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每当应用程序需要一个对象的实例时，Guice都会实例化并返回它；但在某些情况下，如果对象创建过程需要定制，那么Guice提供者会进行定制。提供者接口在创建对象方面遵循传统的工厂设计模式。例如，考虑我们的`ApplicationModule`类绑定过程：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By writing above line of code, `SMSProvider` class gives factory methods that
    will return objects of type `NotificationService`. Let''s say we want to customize
    the object-making and maintenance process for the `ServiceConnection` class, which
    is shown as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写上述代码行，`SMSProvider`类提供了将返回`NotificationService`类型对象的工厂方法。假设我们想要定制`ServiceConnection`类的对象创建和维护过程，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s compose a straightforward `Provider` interface that acclimates to
    Guice `Provider` that makes and returns `ServiceConnection` objects. The following
    is the code for this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个简单的`Provider`接口，它符合Guice的`Provider`，用于创建和返回`ServiceConnection`对象。以下是这个接口的代码：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Every custom provider class should implement `Provider` interface, and must
    override the `get()` method to get back the objects made in a custom mold. Presently,
    the module should be aware about the custom provider class so that Guice asks `SMSProvider` to
    create instances, instead of making them on its own. The following is a module
    snippet that contains the test client code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个自定义提供者类都应该实现`Provider`接口，并且必须重写`get()`方法以返回以自定义方式创建的对象。目前，模块应该知道自定义提供者类，这样Guice就会请求`SMSProvider`创建实例，而不是自己创建。以下是一个包含测试客户端代码的模块片段：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have seen the use of major API individually, which has a notable role in
    Guice''s start-up phase. The following is the sequence diagram of our application,
    which illustrates the complete flow of Guice dependency management:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经单独看到了主要API的使用，它在Guice的启动阶段起着重要的作用。以下是我们应用程序的序列图，它说明了Guice依赖管理的完整流程：
- en: '![](img/00029.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Runtime phase
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时阶段
- en: 'We will now be able to utilize the injector we made during the start-up phase
    to inject objects and examine our bindings. Guice''s runtime phase consists of an
    injector which contains a few bindings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够利用启动阶段创建的注入器来注入对象并检查我们的绑定。Guice的运行时阶段由一个包含一些绑定的注入器组成：
- en: '![](img/00030.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: The preceding diagram defines the components of each binding. Each **key** uniquely
    recognizes each binding. The key consists of a type, which the client depends
    on, and an annotation, which is optional. An **annotation** could be used to distinguish
    a couple of bindings of the same type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图定义了每个绑定的组件。每个**键**唯一识别每个绑定。键由一个类型和一个可选的注解组成，客户端依赖于该类型。注解可以用来区分相同类型的几个绑定。
- en: Every single binding has a provider, which gives an instance of the mandatory
    type. We may offer a class, and Guice will make instances of it for us. We might
    give Guice an instance of the type for binding the class. Guice can inject dependencies if
    we provide our own **provider**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定都有一个提供者，它提供了一个必需类型的实例。我们可以提供一个类，Guice将为我们创建其实例。我们也可以给Guice一个实例来绑定该类。如果我们提供自己的**提供者**，Guice可以注入依赖。
- en: By default, no bindings have a scope; but it's optionally available, and for
    each injection, Guice creates a new instance, which is similar to Spring **Prototype.** Guice
    also provides a facility to define a custom scope to govern whether or not Guice
    makes a new instance. In this case, we can make one instance per `HttpSession`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，没有绑定有作用域；但它是可选的，并且对于每次注入，Guice都会创建一个新的实例，这与Spring的**Prototype**类似。Guice还提供了一个定义自定义作用域的设施，以控制Guice是否创建新的实例。在这种情况下，我们可以为每个`HttpSession`创建一个实例。
- en: Guice annotations
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guice comes with a little set of valuable annotations that are utilized to include metadata
    values in an application. Now, let's study the annotations that are going to get secured in
    this segment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Inject
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice provides the `@Inject` annotation to indicate that a consumer is dependent
    on a particular dependency. The injector takes care of initializing this dependency
    using the object graph. Guice gets a hint from the annotation that it needs to
    participate in the class construction phase. The `@Inject` annotation can be utilized in
    a constructor for a class, for a method, or for a field. Consider the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ProvidedBy
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ImplementedBy
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This annotation focuses on a class object that gives an implementation to the
    interface. For example, in case the `NotificationService` interface has numerous usages, and in
    case we wish to have `SMSService` as the default implementation, at that point we
    can  code as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '@Named'
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making unused annotation types for each concrete usage doesn’t provide much
    value, as the sole reason for having such an annotation is to check the implementation
    class instance required by clients. To support such things, we have a built-in
    binding annotation called `@Named`, which takes a string. There''s the method
    `Names.named()`, which returns `@Named` annotation when passing names as arguments:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We suggest utilizing `@Named` sparingly, because the compiler cannot check the
    string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`@Singleton` is another useful annotation which we will discuss in detail in
    [Chapter 5](part0131.html#3STPM0-255b24dd0eb24162a557b7d0d84b0b16), *Scopes*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Binding in Guice
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we became acquainted with the binding process and its
    importance in Guice DI. Each binding call to the `bind()` method is type-checked,
    so the compiler can report mistakes in case you utilize off-base types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Guice provides different types of binding techniques which can be used in modules.
    The types of binding available are: linked bindings, instance bindings; untargeted
    bindings. Constructor bindings, built-in bindings, Just-in-time bindings. and
    provider bindings.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Linked bindings
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Linked ****binding** helps to map a type to its implementation. Examples
    of linked bindings include an interface to its implementation class, and a superclass
    to a subclass.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `NotificationService` is bound to the `SMSService` instance in the `ApplicationModule`
    class. This binding affirmation binds an interface to its implementation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we call `injector.getInstance(ApplicationModule.class)`, it will utilize `SMSService`. If binding
    to a distinctive implementation of `NotificationService`, as an `EmailService`
    is required, then we only need to essentially alter the binding:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can even define the link from a type to any of its subtypes, such as an executing class or
    an extending class. You can indeed link the concrete `SMSService` course to a
    subclass:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A basic thing to be understood is that linked binding could indeed be chained.
    For example, if we need `SMSService` to be wired to a specific class which extends
    the `SMSService`, at that point we would do something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本需要理解的是，链接绑定确实可以被链式调用。例如，如果我们需要`SMSService`与一个扩展`SMSService`的特定类进行连接，那么我们就会做类似这样的事情：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, if asked for `NotificationService`, then the injector will return the `SMSDataBase`
    instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果请求`NotificationService`，那么注入器将返回`SMSDataBase`实例。
- en: Instance bindings
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例绑定
- en: '**Instance bindings** help to bind a type to a particular instance of that type. This
    is normally helpful only for objects that don''t have dependencies in their possession; for
    example, value objects:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例绑定**有助于将一个类型绑定到该类型的特定实例。这通常只对没有依赖关系的对象有帮助；例如，值对象：'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Avoid utilizing `.toInstance` with objects that are complicated to make, since
    it can slow down application start-up. You can utilize the `@Provides` technique.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`.toInstance`与制作复杂的对象，因为它可能会减慢应用程序的启动速度。你可以使用`@Provides`技术。
- en: Untargeted bindings
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未指定目标的绑定
- en: 'Binding that can be created without target is known as an untargeted bindings. These
    are really signs to the injector around a type, so that the dependencies are arranged eagerly.
    In **untargeted binding**, we do not require the `to` clause:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以不指定目标创建的绑定称为未指定绑定。这些实际上是向注入器发出关于类型的信号，以便依赖关系被急切地安排。在**未指定绑定**中，我们不需要`to`子句：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this statement, the injector would prepare an instance of the String class
    eagerly with a value of  `./alerts/`. When dependency injection requires it to
    inject the instance of String, it will inject this specific instance. This binding
    is useful when defining concrete classes and types annotated by `@ImplementedBy`
    or `@ProvidedBy`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，注入器会急切地准备一个String类的实例，其值为`./alerts/`。当依赖注入需要注入String类的实例时，它将注入这个特定的实例。这种绑定在定义具体类和由`@ImplementedBy`或`@ProvidedBy`注解的类型时非常有用。
- en: Constructor bindings
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数绑定
- en: 'This kind of binding binds a type to a constructor. This specific case arises
    when the `@Inject` annotation can''t be implemented to the target constructor.
    Possible reasons for this could be:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的绑定将一个类型绑定到一个构造函数。这个特定的情况发生在`@Inject`注解不能应用于目标构造函数时。可能的原因包括：
- en: If we are using a third-party class
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用第三方类
- en: A couple of constructors taking part in dependency injection
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个参与依赖注入的构造函数
- en: 'To address such a problem, we have the `toConstructor()` binding in our module.
    Here, if the constructor cannot be found, module reflectively select our target
    constructor and handle the exception:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们在模块中有了`toConstructor()`绑定。在这里，如果找不到构造函数，模块将反射选择我们的目标构造函数并处理异常：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, `SMSService` should have a constructor that takes a single
    `SMSDatabaseConnection` parameter. Guice will conjure that constructor to fulfill
    the binding, so the constructor does not require an `@Inject` annotation. If we
    select reflective constructor then we require to handle checked exceptions thrown
    by the `getConstructor()` API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SMSService`应该有一个接受单个`SMSDatabaseConnection`参数的构造函数。Guice将构造这个构造函数来满足绑定，因此构造函数不需要`@Inject`注解。如果我们选择反射构造函数，那么我们需要处理`getConstructor()`
    API抛出的受检异常。
- en: The scope of each constructor binding is autonomous. In the event that we make
    different singleton bindings that target the same constructor, every binding yields
    its possess instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数绑定的范围是独立的。如果我们为同一个构造函数创建不同的单例绑定，每个绑定都会产生其自己的实例。
- en: Built-in bindings
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置绑定
- en: As the name suggests, these are bindings that are automatically covered in the
    injector. Let the injector make these bindings, as trying to bind them yourself is
    an error. **Loggers** is one example of this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这些是在注入器中自动覆盖的绑定。让注入器来创建这些绑定，因为自己尝试绑定它们将是一个错误。**日志记录器**就是这样一个例子。
- en: '**Loggers**: `java.util.logging.Logger` has a built-in binding in Guice. The binding naturally sets
    the logger''s title to the title of the class into which the logger is being injected:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录器**：`java.util.logging.Logger`在Guice中有一个内置绑定。这个绑定自然地将日志记录器的标题设置为注入日志记录器的类的标题：'
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just-in-time Bindings
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时绑定
- en: These are bindings that might be made by Guice automatically. When there is
    not a clear binding, the injector will endeavor to make a binding, which is a
    **Just-in-time **(**JIT**) binding or implicit binding.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能是Guice自动创建的绑定。当没有明确的绑定时，注入器将努力创建一个绑定，这是一个**即时**(**JIT**)绑定或隐式绑定。
- en: '**Default constructors**:By default, no argument constructors are invoked to
    get instances ready for injection. Occasionally, in our illustrations there is
    no express binding as a way to make an instance of `Client`. In any case, the
    injector invoked a default constructor to return the instance of the client.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认构造函数**：默认情况下，不会调用无参数构造函数来获取准备注入的实例。偶尔，在我们的示例中，没有明确的绑定作为创建 `Client` 实例的方式。在任何情况下，注入器都会调用默认构造函数来返回客户端的实例。'
- en: '**Constructors with** `@Inject`: If  constructors have the `@Inject` annotation, then
    that moreover qualified for implicit bindings. It also includes no arguments and
    a public constructor:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有 @Inject 的构造函数**：如果构造函数有 `@Inject` 注解，那么它也适用于隐式绑定。它还包括无参数和公共构造函数：'
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Binding annotations
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定注解
- en: 'Sometimes we want to use numerous bindings for the same type. In our earlier
    example, `NotificationService` is bound to `SMSService`, which is essentially
    futile since the interface is bound to just one execution. If we need the client
    to have the adaptability to utilize any of the implementations, at that point
    we need to write a couple of bind statements in the `configure()` method, and
    to make that possible, we can write code as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要为同一类型使用多个绑定。在我们之前的例子中，`NotificationService` 绑定到 `SMSService`，这实际上是无用的，因为接口只绑定到一个执行。如果我们需要客户端能够利用任何实现，那么我们需要在
    `configure()` 方法中编写几个绑定语句，为了使这成为可能，我们可以编写如下代码：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From the previous statement, Guice knows when to bind the `NotificationService`
    interface to `SMSService` and when to bind it to `EmailService`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的语句中，Guice 知道何时将 `NotificationService` 接口绑定到 `SMSService`，何时绑定到 `EmailService`。
- en: 'The client-side code to call the `SMSService` implementation will look like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `SMSService` 实现的客户端代码将如下所示：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And to call `EmailService` implementation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 并且调用 `EmailService` 实现如下：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To support such a case, binding supports non-mandatory *binding annotations*.
    A **key** is a pair of unique combinations of Annotation and Type. The following
    is the basic code to define binding annotations for SMS annotation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种情况，绑定支持非强制性的 *绑定注解*。一个 **键** 是注解和类型唯一组合的对。以下是为 SMS 注解定义绑定注解的基本代码：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From the previous two lines, let''s look at the meta-annotations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从前两行来看，让我们看看元注解：
- en: '`@BindingAnnotation` is utilized to tell Guice that this is a binding''s explanation.
    If we ever define a different binding for the same member, then Guice may produce
    an error.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BindingAnnotation` 用于告知 Guice 这是一个绑定的说明。如果我们为同一成员定义不同的绑定，那么 Guice 可能会生成错误。'
- en: '`@Target` and `@Retention` are typical annotations used to create custom annotations
    in Java. `@Target`, helps to locate field, parameter, and method, and `@Ratention(RUNTIME)` available
    in runtime respectively.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Target` 和 `@Retention` 是在 Java 中创建自定义注解时常用的注解。`@Target` 帮助定位字段、参数和方法，`@Retention(RUNTIME)`
    分别在运行时可用。'
- en: Guice injection
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guice 注入
- en: As we know what dependency injection is, let us explore how Google Guice provides
    injection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了依赖注入是什么，让我们来看看 Google Guice 如何提供注入。
- en: We have seen that the injector helps to resolve dependencies by reading configurations
    from modules, which are called *bindings*. *Injector* is preparing charts for
    the requested objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到注入器通过从模块中读取配置来帮助解决依赖关系，这些模块被称为 *绑定*。*注入器* 正在为请求的对象准备图表。
- en: 'Dependency injection is managed by injectors using various types of injection:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入由注入器通过各种类型的注入来管理：
- en: Constructor injection
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Method injection
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入
- en: Field injection
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段注入
- en: Optional injection
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选注入
- en: Static injection
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态注入
- en: Constructor Injection
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: '**Constructor injection** can be achieved  by using the `@Inject` annotation
    at the constructor level. This constructor ought to acknowledge class dependencies
    as arguments. Multiple constructors will, at that point, assign the arguments
    to their final fields:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数注入**可以通过在构造函数级别使用 `@Inject` 注解来实现。这个构造函数应该将类依赖项作为参数来识别。此时，多个构造函数将把参数分配给它们的最终字段：'
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If our class does not have a constructor with `@Inject`, then it will be considered
    a default constructor with no arguments. When we have a single constructor and
    the class accepts its dependency, at that time the constructor injection works
    perfectly and is helpful for unit testing. It is also easy because Java is maintaining
    the constructor invocation, so you don't have to stress about objects arriving
    in an uninitialized state.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice allows us to define injection at the method level by annotating methods
    with the `@Inject` annotation. This is similar to the setter injection available
    in Spring. In this approach, dependencies are passed as parameters, and are resolved
    by the injector before invocation of the method. The name of the method and the
    number of parameters does not affect the method injection:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This could be valuable when we don't want to control instantiation of classes.
    We can, moreover, utilize it in case you have a super class that needs a few dependencies.
    (This is difficult to achieve in a constructor injection.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Field injection
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fields can be injected by the `@Inject` annotation in Guice. This is a simple
    and short injection, but makes the field untestable if used with the `private` access
    modifier. It is advisable to avoid the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Optional injection
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice provides a way to declare an injection as optional. The method and field
    might be optional, which causes Guice to quietly overlook them when the dependencies
    aren''t accessible. **Optional injection** can be used by mentioning the `@Inject(optional=true)`
    annotation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Static injection
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static injection** is helpful when we have to migrate a static factory implementation
    into Guice. It makes it feasible for objects to mostly take part in dependency
    injection by picking up access to injected types without being injected themselves.
    In a module, to indicate classes to be injected on injector creation, use `requestStaticInjection()`.
    For example,  `NotificationUtil` is a utility class that provides a static method, `timeZoneFormat`,
    to  a string in a given format, and returns the date and timezone. The `TimeZoneFormat`
    string is hardcoded in `NotificationUtil`, and we will attempt to inject this
    utility class statically.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Consider that we have one private static string variable, `timeZonFmt`, with
    setter and getter methods. We will use `@Inject` for the setter injection, using
    the `@Named` parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`NotificationUtil` will look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, `SMSUtilModule` should look like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This API is not suggested for common utilization, since it faces many of the
    same issues as static factories. It is also difficult to test and it makes dependencies uncertain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, that's it for Google Guice. To sum up our chapter, we began with basic dependency
    injection. After that, we learned how basic Dependency Injection works in Guice,
    with examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Then, we investigated the phases of Guice, and the role of the API in each phase. We
    got the idea that, unlike Spring, in Guice there is no requirement to maintain
    isolated XML files, as all the setup-related data is nicely typified by means
    of the module component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the chapter, we explored the major annotations and distinct types
    of binding available in Guice, and at the end, we learned the different types
    of injections.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will become competent in the different scopes offered
    by Spring and the Google Guice framework.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
