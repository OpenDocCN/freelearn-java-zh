- en: Dependency Injection with Google Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our journey began, we have learned the concepts of the DI pattern to understand
    IoC, got an idea about the modular framework of Java 9 and its DI mechanism, and
    in the last chapter, we acquired knowledge of the most widely used Spring Framework
    to understand DI using various examples.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see the rudiments of the **Google Guice** framework and
    its DI mechanism, and we will also learn various injection types and binding techniques
    while defining DI in Guice.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to the Google Guice framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the benefits of DI in software engineering, but choosing a framework
    wisely is also important when implementing DI because each framework has its own
    advantages and disadvantages. There are various Java-based dependency injection
    frameworks available in the open source community, such as Dagger, Google Guice,
    Spring DI, JAVA EE 8 DI, and PicoContainer.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will learn in detail about Google Guice (pronounced *juice*), a lightweight
    DI framework that helps developers to modularize applications. Guice encapsulates
    annotation and generics features introduced by Java 5 to make code type-safe.
    It enables objects to wire together and tests with fewer efforts. Annotations
    help you to write error-prone and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: In Guice, the `new` keyword is replaced with `@inject` for injecting dependency.
    It allows constructors, fields, and methods (any method with multiple numbers
    of arguments) level injections. Using Guice, we can define custom scopes and circular dependency, and
    it has features to integrate with Spring and AOP interception.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Guice also implements **Java Specification Request** (**JSR**) **330**,
    and uses the standard annotation provided by JSR-330\. The first version of Guice
    was introduced by Google in 2007 and the latest version is Guice 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: Guice setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our coding simple, throughout this chapter, we are going to use a Maven
    project to understand Guice DI.  Let’s create a simple Maven project using the
    following parameters: `groupid:`,` com.packt.guice.id`, `artifactId : chapter4`,
    and `version : 0.0.1-SNAPSHOT`. By adding `Guice 4.1.0` dependency on the `pom.xml`
    file, our final `pom.xml` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For this chapter, we have used JDK 9, but not as a module project because the
    Guice library is not available as a Java 9 modular jar.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and JSR-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into Guice injection, let's look at the DI pattern again, along
    with JSR-330, in brief.
  prefs: []
  type: TYPE_NORMAL
- en: A dependency injection mechanism enables an object to pass dependencies to another
    object. In Java, using DI, we can move dependency resolution from compile time
    to runtime. DI removes hard dependency between two Java classes; this allows us
    to reuse class as much as and also classes are  independently testable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Specification Request-330**: There is a different way to define dependency
    in Java classes, but `@Inject` and `@Named` are the most common annotations used
    to describe dependencies in Java classes from JSR-330. According to JSR-330, objects
    can be injected into the class constructor, the parameter of the method, and a
    field level. As per best practices, static field and method-level injection should
    be avoided for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Static field only injected when the first-time class object was created via
    DI, which makes static field inaccessible for the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, the compiler complains if a static field is marked as final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the first instance of the class is created, only static methods are called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As per JSR-330, the injection can be performed in this order: first, constructor
    injection; then field injection; and the last is method level injection. But,
    you can''t expect the methods or fields to be called in the sequence of their
    assertion in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor can't use injected member variables, because field and method
    parameter injection takes place only after calling a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Example of simple DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NotifictionService` represents a common service interface for sending data
    to a different system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous interface defines a method signature for `sendNotification()`
    by passing the message and recipient details and returning the type as Boolean. `SMSService.java` is
    a concrete implementation of this interface for sending SMS notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous class implemented code for sending SMS by accepting the message
    and recipient details. Now, we create a client application, `NotificationClient.java`,
    which will use `NotificationService` to initialize the actual SMSService. The
    same object can be used to send notifications to different systems, including
    email or custom notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, even though implementation and interface are loosely
    coupled, we need to create a manual instance of the real implementation of the
    class in the client application. In this scenario, at compilation time, the client
    application knows which execution classes related to interfaces will be bound.
  prefs: []
  type: TYPE_NORMAL
- en: That is the thing that Google Guice does; it takes instances as services from
    the client application code and the dependency between the clients, and their
    service is consequently injected through a simple configuration mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of dependency injection in Guice by using different API
    in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Basic injection in Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen a basic DI implementation, now it is time to understand how injection
    works in Guice. Let''s rewrite the example of a notification system using Guice,
    and along with that, we will see several indispensable interfaces and classes
    in Guice.  We have a base interface called `NotificationService`, which is expecting
    a message and recipient details as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SMSService` concrete class is an implementation of the `NotificationService` interface.
    Here, we will apply the `@Singleton` annotation to the implementation class. When
    you consider that service objects will be made through injector classes, this
    annotation is furnished to allow them to understand that the service class ought
    to be a singleton object. Because of JSR-330 support in Guice, annotation, either
    from `javax.inject` or the `com.google.inject` package, can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, we can also implement another service, such as sending notifications
    to a social media platform, by implementing the `NotificationService` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to define the consumer class, where we can initialize the service
    class for the application. In Guice, the `@Inject` annotation will be used to
    define `setter-based` as well as `constructor-based` dependency injection. An
    instance of this class is utilized to send notifications by means of the accessible
    correspondence services. Our `AppConsumer` class defines `setter-based` injection
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Guice needs to recognize which service implementation to apply, so we should
    configure it with the aid of extending the `AbstractModule` class, and offer an implementation
    for the `configure()` method. Here is an example of an injector configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous class, the module implementation determines that an instance of
    `SMSService` is to be injected any place a `NotificationService` variable is determined.
    In the same way, we just need to define a binding for the new service implementation,
    if required. Binding in Guice is similar to wiring in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous program, the  `Injector` object is created using the `Guice`
    class''s `createInjector()` method, by passing the `ApplicationModule` class''s
    implementation object. By using the injector''s `getInstance()` method, we can initialize the
    `AppConsumer` class. At the same time as creating the AppConsumer''s objects,
    Guice injects the needy service class implementation (`SMSService`, in our case).
    The following is the yield of running the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, this is how Guice dependency injection works compared to other DI. Guice
    has embraced a code-first technique for dependency injection, and management of numerous XML
    is not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test our client application by writing a **JUnit** test case. We can
    simply mock the service implementation of `SMSService`, so there is no need to
    implement the actual service. The `MockSMSService` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the JUnit 4 test case for the client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take note that we are binding the `MockSMSService` class to `NotificationService` by
    having an anonymous class implementation of `AbstractModule`. This is done in the `setUp()` method,
    which runs for some time before the test methods run.
  prefs: []
  type: TYPE_NORMAL
- en: Guice API and Phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen DI examples using various Guice APIs, including interfaces and
    classes. So, it is time to understand the principal API and architecture. Guice
    architecture is divided into two phases: Start-up and runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Start up phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the start-up phase, APIs such as `Module`, `AbstractModule`, `Binder`,  `Injector`,
    `Guice`, and `Provider` play a significant role in Guice dependency injection.
    Let us learn about each API in detail, starting with **module interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Module interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special interface that you use to tell Guice which implementations
    go with which interfaces. Modules are objects that preserve a set of **bindings**.
    It is viable to have multiple modules in a piece of software. Injectors interact
    with modules to get the feasible bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module is represented by using an interface with a method referred to as `Module.configure()`,
    which ought to be overridden with the aid of the application to populate the bindings.
    If we rewrite our `ApplicationModule` by implementing the `Module` interface,
    then it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The AbstractModule class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve things, there is an abstract class called `AbstractModule`, which
    straightforwardly extends the module interface, so applications can rely upon
    `AbstractModule` as opposed to module.
  prefs: []
  type: TYPE_NORMAL
- en: It's strongly suggested that modules should be extended to the usage of `AbstractModule`.
    It gives a more readable configuration, and additionally steers us away from the
    excessive invoking of methods on the binder.
  prefs: []
  type: TYPE_NORMAL
- en: In our example `ApplicationModule`, to configure Guice instead of implementing
    the module interface, we have used `AbstractModule`, where Guice passes our module
    to the binder interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that an application has a predetermined number of configurations,
    they could be consolidated in a solitary module. For such applications, a single
    module per package or a single module per application could be a suitable system.
  prefs: []
  type: TYPE_NORMAL
- en: Binder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This interface mainly includes information associated with **bindings**. A binding
    normally consists of a mapping between an interface and a concrete implementation.
    For example, if we consider an implementation of the module interface for creating
    custom module, then the reference to the interface `NotificationService` is bound
    to the `SMSService` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When coding, notice that the objects for both the interface and implementation
    classes are passed to the `bind()` and then `to()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to tie an interface directly to its instance by writing the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Injector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Injector` interface creates and maintains object graphs, tracks dependencies
    of each type, and uses bindings to inject them. Injectors keep a set of **default
    bindings**, from which they take configuration details for making and maintaining
    relationships between objects. Consider the following code, which will return
    an implementation of the `AppConsumer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get all the associated bindings with the injector by calling the `Injector.getBindings()` method,
    which returns a map containing binding objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can say that each binding has a matching `key` object, which is
    internally made and kept by the Google Guice class.
  prefs: []
  type: TYPE_NORMAL
- en: Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Guice` is a final class, an entry point to the Guice framework. It''s used
    to create injectors by providing a set of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, whenever an application requires an instance of an object, Guice
    instantiates and returns it; but, in some cases, if the object creation process
    needs customization, then Guice providers do that. A provider interface takes
    after the conventional factory design in making objects.  For instance, consider
    our `ApplicationModule` class binding process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By writing above line of code, `SMSProvider` class gives factory methods that
    will return objects of type `NotificationService`. Let''s say we want to customize
    the object-making and maintenance process for the `ServiceConnection` class, which
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s compose a straightforward `Provider` interface that acclimates to
    Guice `Provider` that makes and returns `ServiceConnection` objects. The following
    is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Every custom provider class should implement `Provider` interface, and must
    override the `get()` method to get back the objects made in a custom mold. Presently,
    the module should be aware about the custom provider class so that Guice asks `SMSProvider` to
    create instances, instead of making them on its own. The following is a module
    snippet that contains the test client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen the use of major API individually, which has a notable role in
    Guice''s start-up phase. The following is the sequence diagram of our application,
    which illustrates the complete flow of Guice dependency management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Runtime phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now be able to utilize the injector we made during the start-up phase
    to inject objects and examine our bindings. Guice''s runtime phase consists of an
    injector which contains a few bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram defines the components of each binding. Each **key** uniquely
    recognizes each binding. The key consists of a type, which the client depends
    on, and an annotation, which is optional. An **annotation** could be used to distinguish
    a couple of bindings of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Every single binding has a provider, which gives an instance of the mandatory
    type. We may offer a class, and Guice will make instances of it for us. We might
    give Guice an instance of the type for binding the class. Guice can inject dependencies if
    we provide our own **provider**.
  prefs: []
  type: TYPE_NORMAL
- en: By default, no bindings have a scope; but it's optionally available, and for
    each injection, Guice creates a new instance, which is similar to Spring **Prototype.** Guice
    also provides a facility to define a custom scope to govern whether or not Guice
    makes a new instance. In this case, we can make one instance per `HttpSession`.
  prefs: []
  type: TYPE_NORMAL
- en: Guice annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guice comes with a little set of valuable annotations that are utilized to include metadata
    values in an application. Now, let's study the annotations that are going to get secured in
    this segment.
  prefs: []
  type: TYPE_NORMAL
- en: Inject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice provides the `@Inject` annotation to indicate that a consumer is dependent
    on a particular dependency. The injector takes care of initializing this dependency
    using the object graph. Guice gets a hint from the annotation that it needs to
    participate in the class construction phase. The `@Inject` annotation can be utilized in
    a constructor for a class, for a method, or for a field. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: ProvidedBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ImplementedBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This annotation focuses on a class object that gives an implementation to the
    interface. For example, in case the `NotificationService` interface has numerous usages, and in
    case we wish to have `SMSService` as the default implementation, at that point we
    can  code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '@Named'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making unused annotation types for each concrete usage doesn’t provide much
    value, as the sole reason for having such an annotation is to check the implementation
    class instance required by clients. To support such things, we have a built-in
    binding annotation called `@Named`, which takes a string. There''s the method
    `Names.named()`, which returns `@Named` annotation when passing names as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We suggest utilizing `@Named` sparingly, because the compiler cannot check the
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Singleton` is another useful annotation which we will discuss in detail in
    [Chapter 5](part0131.html#3STPM0-255b24dd0eb24162a557b7d0d84b0b16), *Scopes*.'
  prefs: []
  type: TYPE_NORMAL
- en: Binding in Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we became acquainted with the binding process and its
    importance in Guice DI. Each binding call to the `bind()` method is type-checked,
    so the compiler can report mistakes in case you utilize off-base types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guice provides different types of binding techniques which can be used in modules.
    The types of binding available are: linked bindings, instance bindings; untargeted
    bindings. Constructor bindings, built-in bindings, Just-in-time bindings. and
    provider bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: Linked bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Linked ****binding** helps to map a type to its implementation. Examples
    of linked bindings include an interface to its implementation class, and a superclass
    to a subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `NotificationService` is bound to the `SMSService` instance in the `ApplicationModule`
    class. This binding affirmation binds an interface to its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `injector.getInstance(ApplicationModule.class)`, it will utilize `SMSService`. If binding
    to a distinctive implementation of `NotificationService`, as an `EmailService`
    is required, then we only need to essentially alter the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even define the link from a type to any of its subtypes, such as an executing class or
    an extending class. You can indeed link the concrete `SMSService` course to a
    subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic thing to be understood is that linked binding could indeed be chained.
    For example, if we need `SMSService` to be wired to a specific class which extends
    the `SMSService`, at that point we would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, if asked for `NotificationService`, then the injector will return the `SMSDataBase`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Instance bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Instance bindings** help to bind a type to a particular instance of that type. This
    is normally helpful only for objects that don''t have dependencies in their possession; for
    example, value objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Avoid utilizing `.toInstance` with objects that are complicated to make, since
    it can slow down application start-up. You can utilize the `@Provides` technique.
  prefs: []
  type: TYPE_NORMAL
- en: Untargeted bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binding that can be created without target is known as an untargeted bindings. These
    are really signs to the injector around a type, so that the dependencies are arranged eagerly.
    In **untargeted binding**, we do not require the `to` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this statement, the injector would prepare an instance of the String class
    eagerly with a value of  `./alerts/`. When dependency injection requires it to
    inject the instance of String, it will inject this specific instance. This binding
    is useful when defining concrete classes and types annotated by `@ImplementedBy`
    or `@ProvidedBy`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This kind of binding binds a type to a constructor. This specific case arises
    when the `@Inject` annotation can''t be implemented to the target constructor.
    Possible reasons for this could be:'
  prefs: []
  type: TYPE_NORMAL
- en: If we are using a third-party class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of constructors taking part in dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address such a problem, we have the `toConstructor()` binding in our module.
    Here, if the constructor cannot be found, module reflectively select our target
    constructor and handle the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `SMSService` should have a constructor that takes a single
    `SMSDatabaseConnection` parameter. Guice will conjure that constructor to fulfill
    the binding, so the constructor does not require an `@Inject` annotation. If we
    select reflective constructor then we require to handle checked exceptions thrown
    by the `getConstructor()` API.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of each constructor binding is autonomous. In the event that we make
    different singleton bindings that target the same constructor, every binding yields
    its possess instance.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, these are bindings that are automatically covered in the
    injector. Let the injector make these bindings, as trying to bind them yourself is
    an error. **Loggers** is one example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loggers**: `java.util.logging.Logger` has a built-in binding in Guice. The binding naturally sets
    the logger''s title to the title of the class into which the logger is being injected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Just-in-time Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are bindings that might be made by Guice automatically. When there is
    not a clear binding, the injector will endeavor to make a binding, which is a
    **Just-in-time **(**JIT**) binding or implicit binding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default constructors**:By default, no argument constructors are invoked to
    get instances ready for injection. Occasionally, in our illustrations there is
    no express binding as a way to make an instance of `Client`. In any case, the
    injector invoked a default constructor to return the instance of the client.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructors with** `@Inject`: If  constructors have the `@Inject` annotation, then
    that moreover qualified for implicit bindings. It also includes no arguments and
    a public constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Binding annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we want to use numerous bindings for the same type. In our earlier
    example, `NotificationService` is bound to `SMSService`, which is essentially
    futile since the interface is bound to just one execution. If we need the client
    to have the adaptability to utilize any of the implementations, at that point
    we need to write a couple of bind statements in the `configure()` method, and
    to make that possible, we can write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From the previous statement, Guice knows when to bind the `NotificationService`
    interface to `SMSService` and when to bind it to `EmailService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client-side code to call the `SMSService` implementation will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And to call `EmailService` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To support such a case, binding supports non-mandatory *binding annotations*.
    A **key** is a pair of unique combinations of Annotation and Type. The following
    is the basic code to define binding annotations for SMS annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous two lines, let''s look at the meta-annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@BindingAnnotation` is utilized to tell Guice that this is a binding''s explanation.
    If we ever define a different binding for the same member, then Guice may produce
    an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Target` and `@Retention` are typical annotations used to create custom annotations
    in Java. `@Target`, helps to locate field, parameter, and method, and `@Ratention(RUNTIME)` available
    in runtime respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guice injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know what dependency injection is, let us explore how Google Guice provides
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that the injector helps to resolve dependencies by reading configurations
    from modules, which are called *bindings*. *Injector* is preparing charts for
    the requested objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection is managed by injectors using various types of injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Constructor injection** can be achieved  by using the `@Inject` annotation
    at the constructor level. This constructor ought to acknowledge class dependencies
    as arguments. Multiple constructors will, at that point, assign the arguments
    to their final fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If our class does not have a constructor with `@Inject`, then it will be considered
    a default constructor with no arguments. When we have a single constructor and
    the class accepts its dependency, at that time the constructor injection works
    perfectly and is helpful for unit testing. It is also easy because Java is maintaining
    the constructor invocation, so you don't have to stress about objects arriving
    in an uninitialized state.
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice allows us to define injection at the method level by annotating methods
    with the `@Inject` annotation. This is similar to the setter injection available
    in Spring. In this approach, dependencies are passed as parameters, and are resolved
    by the injector before invocation of the method. The name of the method and the
    number of parameters does not affect the method injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This could be valuable when we don't want to control instantiation of classes.
    We can, moreover, utilize it in case you have a super class that needs a few dependencies.
    (This is difficult to achieve in a constructor injection.)
  prefs: []
  type: TYPE_NORMAL
- en: Field injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fields can be injected by the `@Inject` annotation in Guice. This is a simple
    and short injection, but makes the field untestable if used with the `private` access
    modifier. It is advisable to avoid the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Optional injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice provides a way to declare an injection as optional. The method and field
    might be optional, which causes Guice to quietly overlook them when the dependencies
    aren''t accessible. **Optional injection** can be used by mentioning the `@Inject(optional=true)`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Static injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static injection** is helpful when we have to migrate a static factory implementation
    into Guice. It makes it feasible for objects to mostly take part in dependency
    injection by picking up access to injected types without being injected themselves.
    In a module, to indicate classes to be injected on injector creation, use `requestStaticInjection()`.
    For example,  `NotificationUtil` is a utility class that provides a static method, `timeZoneFormat`,
    to  a string in a given format, and returns the date and timezone. The `TimeZoneFormat`
    string is hardcoded in `NotificationUtil`, and we will attempt to inject this
    utility class statically.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider that we have one private static string variable, `timeZonFmt`, with
    setter and getter methods. We will use `@Inject` for the setter injection, using
    the `@Named` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`NotificationUtil` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `SMSUtilModule` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This API is not suggested for common utilization, since it faces many of the
    same issues as static factories. It is also difficult to test and it makes dependencies uncertain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, that's it for Google Guice. To sum up our chapter, we began with basic dependency
    injection. After that, we learned how basic Dependency Injection works in Guice,
    with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we investigated the phases of Guice, and the role of the API in each phase. We
    got the idea that, unlike Spring, in Guice there is no requirement to maintain
    isolated XML files, as all the setup-related data is nicely typified by means
    of the module component.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the chapter, we explored the major annotations and distinct types
    of binding available in Guice, and at the end, we learned the different types
    of injections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will become competent in the different scopes offered
    by Spring and the Google Guice framework.
  prefs: []
  type: TYPE_NORMAL
