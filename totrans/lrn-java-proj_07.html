<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor148"/>7</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Methods</h1>
			<p>In <a href="B19793_06.xhtml#_idTextAnchor118"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we learned about arrays in Java. We learned that arrays are data structures that are fixed in size. They are stored in contiguous memory locations where each location is of the same type. We also saw how to declare, initialize, and process arrays. Both the traditional and enhanced <strong class="source-inline">for</strong> loops are ideal for <span class="No-Break">processing arrays.</span></p>
			<p>In addition, we discussed multi-dimensional arrays, including how they are organized and how to process them. Lastly, as arrays are very common, we discussed the <strong class="source-inline">Arrays</strong> class, which has several useful methods for <span class="No-Break">processing arrays.</span></p>
			<p>In this chapter, we will cover methods. Methods enable us to create a named block of code that can be executed from elsewhere in the code. Firstly, we will explain why methods are so commonplace. You will learn the difference between the method definition and the method invocation. We will explore what a method signature is and how method overloading enables methods to have the same name, without conflict. We will also explain variable arguments (<strong class="source-inline">varargs</strong>), which enable a method to be executed with 0 or more arguments. Lastly, Javas’ principle of call-by-value for passing arguments (and returning values) will be outlined. By the end of this chapter, you will be well able to code and execute methods. In addition, you will understand method overloading, <strong class="source-inline">varargs</strong>, and Javas’ <span class="No-Break">call-by-value mechanism.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Explaining why methods <span class="No-Break">are important</span></li>
				<li>Understanding the difference between method definition and <span class="No-Break">method execution</span></li>
				<li>Exploring <span class="No-Break">method overloading</span></li>
				<li><span class="No-Break">Explaining </span><span class="No-Break"><strong class="source-inline">varargs</strong></span></li>
				<li>Mastering call <span class="No-Break">by value</span></li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch7</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor151"/>Explaining why methods are important</h1>
			<p>Methods <a id="_idIndexMarker442"/>are code blocks that are given a name for ease of reference. They can accept inputs and return an output. Both the inputs and output are optional. A method should do one task and do it well. It is considered good practice to keep your methods short (less than 20 lines). The longer the method, the more likely it is that the method is doing too much. The maxim of “keep it simple” <span class="No-Break">applies here.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor152"/>Flow of control</h2>
			<p>Simply put, when a method is called (executed), the normal flow of control of execution is changed. <a id="_idIndexMarker443"/>Let us discuss a simple example that will help demonstrate this. This is an important point to appreciate, especially for inexperienced developers. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B19793_07_1.jpg" alt="Figure 7.1 – A very simple method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A very simple method</p>
			<p>In this example, we have two methods: the <strong class="source-inline">main()</strong> method (lines 4 to 8) and the <strong class="source-inline">simpleExample()</strong> method (lines 9 to 11). Both exist inside the <strong class="source-inline">Methods</strong> class (lines 3 <span class="No-Break">to 12).</span></p>
			<p>In Java, every program starts with the <strong class="source-inline">main()</strong> method. The JVM calls it on our behalf; we do not have to call (or execute) it ourselves. Therefore, in this example, the first line in <strong class="source-inline">main()</strong>, line 5, is the first line <span class="No-Break">to execute.</span></p>
			<p>Line 6 is<a id="_idIndexMarker444"/> important – it is what we refer to as a method call. There is a direct correlation between the <strong class="source-inline">simpleExample()</strong> method definition on line 9 and the method call on line 6. We will discuss this relationship shortly. For the moment, just understand that the method call changes the order of execution of the program. Normally, Java executes lines of code from top to bottom and this is true. However, <em class="italic">method calls alter that</em>. In this example, when line 6 executes, the next line to execute is line 10 (inside the <span class="No-Break"><strong class="source-inline">simpleExample()</strong></span><span class="No-Break"> method).</span></p>
			<p>So, the <strong class="source-inline">main()</strong> method has now handed over control to the <strong class="source-inline">simpleExample()</strong> method, and control will not return to <strong class="source-inline">main()</strong> until <strong class="source-inline">simpleExample()</strong> exits. This can occur when execution hits the closing <strong class="source-inline">}</strong> at the end of the <strong class="source-inline">simpleExample() </strong>method (line 11). This is what happens in this example. Alternatively, a method can exit by using the <span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break"> keyword.</span></p>
			<p>So, line 6 calls the <strong class="source-inline">simpleExample()</strong> method, causing its code to execute. Line 10 outputs some text to the screen. The closing <strong class="source-inline">}</strong> on line 11 causes <strong class="source-inline">simpleExample()</strong> to exit and control now returns to <strong class="source-inline">main()</strong>, where execution resumes at <span class="No-Break">line 7.</span></p>
			<p>In summary, the order of execution in this program is illustrated by <span class="No-Break">the output:</span></p>
			<pre class="console">
main: before call to simpleExample()    Executing simpleExample() method...
main: after call to simpleExample()</pre>
			<p>Here, you can see that <strong class="source-inline">println()</strong>, inside the <strong class="source-inline">simpleExample()</strong> method, is sandwiched between the two <strong class="source-inline">println()</strong> statements from <strong class="source-inline">main()</strong>. This demonstrates that the flow of control was altered by the method call on <span class="No-Break">line 6.</span></p>
			<h3>The stack</h3>
			<p>So, how can a <a id="_idIndexMarker445"/>caller method, such as <strong class="source-inline">main()</strong>, simply <em class="italic">resume</em> where it left off after the <strong class="source-inline">simpleExample()</strong> method returns? What about the local variables <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break">?</span></p>
			<p>The ability of a method to resume exactly where it left off, after the method it called returns, requires <a id="_idIndexMarker446"/>the use of a memory structure called the <em class="italic">stack</em>. We will discuss the stack later in <span class="No-Break">this chapter.</span></p>
			<p>Returning to our <em class="italic">why methods are important’ discussion</em>, two major advantages of methods are that they provide abstraction and avoid code duplication. Let’s examine these <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor153"/>Abstraction</h2>
			<p>Abstraction is a <a id="_idIndexMarker447"/>principle in software engineering where clients of a service, are abstracted from the service implementation. This decouples clients, who use the service, from knowing how the service is implemented. Thus, if the service implementation is changed, the clients are <span class="No-Break">not impacted.</span></p>
			<p>Take, for example, a McDonald’s drive-thru where you drive up and place your order. In this situation, you are the client of the McDonald’s service. You do not care how McDonald’s process your order; you simply want to place an order and receive the food/drinks. If McDonald’s changes its internal implementation, you are shielded (abstracted) from those changes. This is known <span class="No-Break">as abstraction.</span></p>
			<p>For our purposes, the method itself is the McDonald’s service. The method call is the McDonald’s customer. The method call is abstracted from internal changes to the <span class="No-Break">method code.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Code duplication</h2>
			<p>Methods can help us <a id="_idIndexMarker448"/>avoid code replication. This has the added benefit of easing debugging. Let’s look at a simple example of this. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> demonstrates <span class="No-Break">duplicated code:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B19793_07_2.jpg" alt="Figure 7.2 – Duplicated code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Duplicated code</p>
			<p>In the preceding <a id="_idIndexMarker449"/>figure, lines 8 to 12 are repeated on lines 14 to 18 and lines 20 to 24. Each of these sections prompts the user for a number, stores the user input in a variable named <strong class="source-inline">number</strong>, and checks to see if the number is in range. If the number is out of range, then an error is flagged. While a loop would be an obvious improvement, bear in mind that these lines of code could well be in separate parts of the program. In addition, for this simple example, we are only interested in highlighting code duplication. We simply prompt for a number, accept the user’s input, and validate it. The result is five lines of code repeated <span class="No-Break">three times.</span></p>
			<p>Now, let’s assume that we want to adjust the upper valid range from 10 to 100. We have to change the prompts on lines 8, 14, and 20. In addition, the <strong class="source-inline">if</strong> statements on lines 10, 16, and 22 need to change. Thus, a simple range adjustment has resulted in quite a few code changes and we could easily forget to make one or more of the changes required. Let’s refactor the code into a method. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em> shows the <span class="No-Break">refactored code:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19793_07_3.jpg" alt="Figure 7.3 – The code from Figure 7.2 refactored to use a method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The code from Figure 7.2 refactored to use a method</p>
			<p>In the <a id="_idIndexMarker450"/>preceding figure, the method itself is coded from lines 9 to 17 and will be explained in detail in the next section. The five lines of repeated code from <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> are coded only once, on lines 11 to 15. The execution calls of the method are on lines 5, 6, and 7; one execution call per line. If we want to change the upper valid range from 10 to 100, we just need to change the method – that is, lines 11 and 13. These two changes are <em class="italic">automatically</em> reflected throughout the code. In effect, the three method calls on lines 5, 6, and 7 automatically reflect the changes made in <span class="No-Break">the method.</span></p>
			<p>As you can imagine, this situation scales very well. For example, if, in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em>, we had duplicated the code 10 times, we would have to make changes in 10 areas of the code. However, with the method implementation, there is still <em class="italic">only one</em> location to make the change and that is in the <span class="No-Break">method itself.</span></p>
			<p>Now that we have justified why methods exist, let’s examine the difference between the method itself and the <span class="No-Break">method call.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor155"/>Understanding the difference between method definition and method execution</h1>
			<p>For those new<a id="_idIndexMarker451"/> to programming, it may surprise you to know that there are two parts to having a method <em class="italic">do</em> something. Firstly, we must code the method (the method definition). This is similar to a bank machine on the street – it just sits there, doing nothing, waiting to be used. Secondly, we must execute the method (the method execution). This is similar to a customer “using” the bank machine. Remember that the <strong class="source-inline">main</strong> method is the only method that is automatically executed by the JVM. Any other method calls have to be <span class="No-Break">explicitly coded.</span></p>
			<p>Now, let’s examine the method definition and method execution <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor156"/>Method definition</h2>
			<p>The <a id="_idIndexMarker452"/>method definition (declaration) is the method code itself - this is the block of code that is executed when the method is called. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.4</em> presents <span class="No-Break">the syntax:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19793_07_4.jpg" alt="Figure 7.4 – The syntax of the method definition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The syntax of the method definition</p>
			<p>In the preceding figure, as in other figures, square brackets signify optional elements. The <strong class="source-inline">access-modifier</strong> and <strong class="source-inline">static</strong> elements will be discussed in <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. The <strong class="source-inline">throws</strong> <strong class="source-inline">someException</strong> element will be covered in <a href="B19793_11.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. In this chapter, we will focus on the elements in bold; namely, <strong class="source-inline">return-type</strong> (mandatory), <strong class="source-inline">methodName</strong> (mandatory), and <span class="No-Break"><strong class="source-inline">parameters </strong></span><span class="No-Break">(optional).</span></p>
			<p>The return type of the method can be a primitive type, a reference type, or <strong class="source-inline">void</strong>. The <strong class="source-inline">void</strong> keyword means that the method is not returning anything. If that is the case, you <em class="italic">cannot</em> simply leave out the return type; you must specify <strong class="source-inline">void</strong>. In addition, when you’re not returning anything from a method, you can specify <strong class="source-inline">return;</strong> or simply leave out the <strong class="source-inline">return</strong> keyword altogether (which is what we have done for all the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> methods).</span></p>
			<p>Let’s examine a method that accepts input and returns a result. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em> presents such <span class="No-Break">an example:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B19793_07_5.jpg" alt="Figure 7.5 – Sample method definition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Sample method definition</p>
			<p>In the preceding figure, we <a id="_idIndexMarker453"/>have a method that takes in two integers and a mathematical operation to be performed using the two integers as operands. For example, if <strong class="source-inline">"+"</strong> is passed in, the two numbers are added and the result is returned. Let’s review how the method <span class="No-Break">does this.</span></p>
			<p>Line 15 is very important. For the moment, as stated earlier, <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> will explain both <strong class="source-inline">public</strong> (access-modifier) and <strong class="source-inline">static</strong>. The <strong class="source-inline">return-type</strong> is an <strong class="source-inline">int</strong> – meaning, this method returns whole numbers. The name of the method is <strong class="source-inline">performCalc</strong>. Method names often begin with verbs and follow camel <span class="No-Break">casing style.</span></p>
			<p>Note that round brackets follow the method name. The round brackets are delimiters for the optional input parameters to the method. For each parameter, you must specify the data type of the parameter (as Java is a strongly typed language) and the parameter’s identifier name. If you have two or more parameters, comma-separate them. These parameters are how the method accepts input. In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em>, we have two integers namely <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, followed by a <strong class="source-inline">String</strong> called <strong class="source-inline">operation</strong>. The scope of any method parameters, in this case, <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">operation</strong>, is the whole of <span class="No-Break">the method.</span></p>
			<p>Lines 16-26 encapsulate a <strong class="source-inline">switch</strong> expression. In effect, depending on the mathematical <strong class="source-inline">operation</strong> passed in, that operation is performed on the two inputs, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. The local <strong class="source-inline">int</strong> variable, <strong class="source-inline">result</strong>, is initialized accordingly. The <strong class="source-inline">result</strong> variable is returned on line 27. As the return type declared on line 15 is an <strong class="source-inline">int</strong>, returning <strong class="source-inline">result</strong>, which is also an <strong class="source-inline">int</strong>, <span class="No-Break">is fine.</span></p>
			<p>A method definition in<a id="_idIndexMarker454"/> and of itself does not do anything. It just defines a block of code. As stated previously, this is similar to a bank machine on the street – it just sits there, doing nothing, waiting to be used. For the bank machine to be useful, you must “use” it. Similarly, we must “use” the method – this is what we call executing <span class="No-Break">the method.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/>Method execution</h2>
			<p>Executing the<a id="_idIndexMarker455"/> method is also known as calling or invoking the method. The method that calls the method is known as the “calling” (or caller) method. So, you have the calling method and the called method. When you call a method, you pass down the required arguments, if there are any. The called method will execute at this point. When the called method finishes, control returns to the caller method. The called method’s result, if there is one, is also returned. This enables the called method to return data to the caller method, where it can be output to the screen, stored in a variable, or <span class="No-Break">simply ignored.</span></p>
			<p class="callout-heading">Method parameters versus method arguments</p>
			<p class="callout">The method definition<a id="_idIndexMarker456"/> defines parameters, whereas the method call passes down arguments. These terms are often <span class="No-Break">used interchangeably.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.6</em> presents a code example to help explain <span class="No-Break">this further:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B19793_07_6.jpg" alt="Figure 7.6 – Sample code demonstrating method calls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Sample code demonstrating method calls</p>
			<p class="callout-heading">IntelliJ IDEA inlay hints</p>
			<p class="callout">Note that the IntelliJ editor inserts inlay hints when you are coding. In the previous figure, the <strong class="source-inline">performCalc</strong> method signature (line 13) specifies that the parameters are namely <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">operation</strong>. That is why on each method call, the inlay hint uses these parameter names. For example, on line 5, we typed in 10 as the first argument; however, IntelliJ, upon inspecting the method signature, realized that 10 was mapping to ‘x’ and that is why you see “<strong class="bold">x:</strong>” before the 10. We did not type in “x:” at all! It is not part of the Java language to do that (IntelliJ is just trying to help us). In actual fact, for line 5, we typed in <strong class="source-inline">performCalc(10, 2, "+")</strong> and IntelliJ converted that to <strong class="source-inline">performCalc(x: 10, y: 2, </strong><span class="No-Break"><strong class="source-inline">operation: "+").</strong></span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.6</em><em class="italic"><a id="_idIndexMarker457"/></em>, the <strong class="source-inline">performCalc</strong> method (lines 13-26) is unchanged from <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em>. However, we can now see the various method calls (lines 5 <span class="No-Break">and 7-11).</span></p>
			<p>Let’s start with line 5. On the right-hand side of the assignment, we have the <strong class="source-inline">performCalc(10, 2, "+")</strong> method call. This method call has higher precedence than the assignment, so it is executed first. The IntelliJ IDE does a very nice job of highlighting that <strong class="source-inline">10</strong> will be passed into the method as <strong class="source-inline">x</strong>, <strong class="source-inline">2</strong> will be passed into the method as <strong class="source-inline">y</strong>, and <strong class="source-inline">"+"</strong> will be passed in as <strong class="source-inline">operation</strong>. It is very important to realize that once we get to the method call on line 5, the next line of code that’s executed is line 14 – so, from line 5, we jump into the <strong class="source-inline">performCalc</strong> method and start executing the <strong class="source-inline">switch</strong> expression on <span class="No-Break">line 14.</span></p>
			<p>Since <strong class="source-inline">operation</strong> is <strong class="source-inline">"+"</strong> for this method invocation, line 15 assigns 10 + 2 (12) to <strong class="source-inline">result</strong>. Line 25 returns <strong class="source-inline">result</strong> back to the calling method (line 5), where the value 12 is assigned into <strong class="source-inline">result</strong>. Line 6 outputs the return value from the <strong class="source-inline">performCalc</strong> invocation on line 5, which <span class="No-Break">is 12.</span></p>
			<p class="callout-heading">Different scopes</p>
			<p class="callout">Note that the two <strong class="source-inline">result</strong> variables (lines 5 and 14) are completely different as they are in two separate scopes – one is in the <strong class="source-inline">main()</strong> method and the other is in the <strong class="source-inline">performCalc</strong> method. As a result, there is no conflict or <span class="No-Break">ambiguity whatsoever.</span></p>
			<p>Line 7 executes <strong class="source-inline">System.out.println()</strong> with a method call inside the <strong class="source-inline">()</strong> of <strong class="source-inline">println</strong>. In <a id="_idIndexMarker458"/>this scenario, Java will execute the method call inside the <strong class="source-inline">()</strong> of <strong class="source-inline">println</strong>, and whatever the method returns will then be output to the screen. So, for line 7, the arguments passed to <strong class="source-inline">performCalc</strong> are <strong class="source-inline">10</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">"-"</strong>. Therefore, in <strong class="source-inline">performCalc</strong>, <strong class="source-inline">x</strong> is 10, <strong class="source-inline">y</strong> is 2, and <strong class="source-inline">operation</strong> is <strong class="source-inline">"-"</strong>. The <strong class="source-inline">switch</strong> expression now executes line 16, resulting in <strong class="source-inline">result</strong> becoming 8 (10 -2). This <strong class="source-inline">result</strong> is returned (line 25) back to the calling method (line 7), where <strong class="source-inline">8</strong> is output to <span class="No-Break">the screen.</span></p>
			<p>Lines 8 and 9 operate similarly to line 7 except that the lines of code executed in the <strong class="source-inline">switch</strong> expression are different. The method call on line 8 executes line 17 in the <strong class="source-inline">switch</strong> expression, resulting in <strong class="source-inline">result</strong> being initialized to 20. This value is returned to the calling method (line 8), where <strong class="source-inline">20</strong> is output to the screen. The method call on line 9 executes line 18 in the <strong class="source-inline">switch</strong> expression, resulting in <strong class="source-inline">result</strong> being initialized to 5, and thus <strong class="source-inline">5</strong> is output to <span class="No-Break">the screen.</span></p>
			<p>Line 10 causes line 19 in the <strong class="source-inline">switch</strong> expression to be executed, initializing <strong class="source-inline">result</strong> to <strong class="source-inline">0</strong> (10 % 2). This <strong class="source-inline">result</strong> is returned back to the calling method, where, because it is not stored in a variable, it is <span class="No-Break">simply lost/ignored.</span></p>
			<p>The <strong class="source-inline">performCalc</strong> call on line 11 passes in <strong class="source-inline">"&amp;"</strong>, which executes the <strong class="source-inline">default</strong> branch of the <strong class="source-inline">switch</strong> expression. This results in the error message “Unrecognized operation: &amp;” being displayed on the screen and -1 being returned. The -1 is then output on <span class="No-Break">the screen.</span></p>
			<p>Now that we know how to define and execute methods, we will move on to discussing method overloading, where distinct methods can have the same <span class="No-Break">identifier name.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor158"/>Exploring method overloading</h1>
			<p>Consider a <a id="_idIndexMarker459"/>scenario where you have an algorithm, implemented by a method, that operates similarly on various input types – for example, <strong class="source-inline">String</strong> and <strong class="source-inline">int</strong>. It would be a shame to have two separately contrived method names, one for each input type, such as <strong class="source-inline">doStuffForString(String)</strong> and <strong class="source-inline">doStuffForInt(int)</strong>. It would be much better if both methods had the same name – that is, <strong class="source-inline">doStuff</strong> – differentiated by their input types, which are <strong class="source-inline">doStuff(String)</strong> and <strong class="source-inline">doStuff(int)</strong>. Thus, there will be no contrived method names. This is what method overloading provides. To discuss method overloading properly, we must first define the <span class="No-Break">method signature.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor159"/>Method signature</h2>
			<p>The method signature<a id="_idIndexMarker460"/> consists of the method’s name and the optional parameters. It does <em class="italic">not</em> consist of the return type. Let’s look at an example to explain <span class="No-Break">this further:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B19793_07_7.jpg" alt="Figure 7.7 – Method signature"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Method signature</p>
			<p>In the preceding figure, the method signature is highlighted in a dashed rectangle. It consists of the name of the method, followed by both the type and the order of the parameters. What this means is that the signature for the method in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.7</em> is <strong class="source-inline">performCalc</strong>, which takes in two integers and a <strong class="source-inline">String</strong>, <em class="italic">in that order</em>. Note that the parameter names do not matter. So, in effect, from the perspective of the compiler, the method signature is <strong class="source-inline">performCalc(int, </strong><span class="No-Break"><strong class="source-inline">int, String)</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor160"/>Overloading a method</h2>
			<p>A method is overloaded when two or more methods share the same name but the parameters are different in type and/or order. This makes sense if you consider this from the viewpoint of the compiler. If you call a method that has two or more definitions, how will the compiler know which one you are referring to? To locate the correct method definition, the compiler compares and matches the method call with the overloaded <a id="_idIndexMarker461"/>method signatures. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.8</em> presents an overloaded method with <span class="No-Break">various signatures:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B19793_07_08.jpg" alt="Figure 7.8 – The method signature’s impact on overloading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – The method signature’s impact on overloading</p>
			<p>In this figure, the <strong class="source-inline">someMethod</strong> method is overloaded several times. The method signatures on lines 6 to 10 are <strong class="source-inline">someMethod()</strong>, <strong class="source-inline">someMethod(int)</strong>, <strong class="source-inline">someMethod(double)</strong>, <strong class="source-inline">someMethod(String)</strong>, and <strong class="source-inline">someMethod(double, </strong><span class="No-Break"><strong class="source-inline">int)</strong></span><span class="No-Break">, respectively.</span></p>
			<p>The interesting cases are the compiler errors on lines 11-13. The error on line 11 is a misleading error from the compiler. In other words, if we comment out lines 12 and 13, the compiler error on line 11 disappears. There is nothing wrong with line 11 as this is the first time the compiler has seen this particular method signature – that is, <strong class="source-inline">someMethod(int, double)</strong>. The problem is that lines 12 to 13 have the same signatures and the compiler is flagging all lines with <span class="No-Break">that signature.</span></p>
			<p>Line 12 reinforces the point that the parameter names do not matter as they are not part of the method signature. Therefore, the fact that they are named <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> on line 11 and <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> on line 12 makes no <span class="No-Break">difference whatsoever.</span></p>
			<p>Similarly, line 13 demonstrates that the return type is not part of the method signature. Line 13 is a compiler error because its signature, <strong class="source-inline">someMethod(int, double)</strong>, is the same as on lines 11 and 12, even though the two methods have different return types (<strong class="source-inline">int</strong> and <span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break">, respectively).</span></p>
			<p>In summary, the return type and parameter names are <em class="italic">not</em> part of the method signature. Now that we understand what is (and what is not) part of the method signature, let’s look at a simple example of method overloading. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.9</em> presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B19793_07_9.jpg" alt="Figure 7.9 – Method overloading example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Method overloading example</p>
			<p>In this figure, we <a id="_idIndexMarker462"/>have an overloaded <strong class="source-inline">add</strong> method. The first version (lines 10 to 13) takes in two <strong class="source-inline">int</strong> parameters; the second version (lines 14-17) takes in two <strong class="source-inline">double</strong> parameters. Their respective signatures are captured on lines 10 and 14, respectively. Thus, when we call <strong class="source-inline">add</strong> on line 5 and pass down two integers, the compiler matches the call with the version of <strong class="source-inline">add</strong> on line 10 because that version of <strong class="source-inline">add</strong> takes two integers. Similarly, the call to <strong class="source-inline">add</strong> on line 7 matches <strong class="source-inline">add</strong> on line 14 because both the call and method signature match (two <strong class="source-inline">double</strong> types <span class="No-Break">in both).</span></p>
			<p>Now that we understand how method parameter types and their order affect method overloading, let’s examine how Java enables us to execute methods where the number of arguments <span class="No-Break">is variable.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor161"/>Explaining varargs</h1>
			<p>Consider <a id="_idIndexMarker463"/>the following situation: you want to call a method, <strong class="source-inline">m1</strong>, but the number of arguments may vary. Do you overload the method with each version of the method taking in one extra parameter? For example, assuming the argument types are of the <strong class="source-inline">String</strong> type, do you overload <strong class="source-inline">m1</strong> when each new version takes in an extra <strong class="source-inline">String</strong> parameter? In this case, you would have to code <strong class="source-inline">m1(String)</strong>, <strong class="source-inline">m1(String, String)</strong>, <strong class="source-inline">m1(String, String, String)</strong>, and so forth. This is <span class="No-Break">not scalable.</span></p>
			<p>This is where <strong class="source-inline">varargs</strong> comes in. <strong class="source-inline">varargs</strong> is a very flexible language feature in Java, specifically provided for this use case. The syntax is that the type name is followed by an ellipsis (three dots). <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.10</em> shows <strong class="source-inline">varargs</strong> <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B19793_07_10.jpg" alt="Figure 7.10 – varargs example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – varargs example</p>
			<p>In this figure, on line 10, <strong class="source-inline">m1(int… )</strong> defines a method signature for the <strong class="source-inline">m1</strong> method, defining 0 or more <strong class="source-inline">int</strong> parameters. This is quite different from <strong class="source-inline">String[]</strong> defined on line 4 for <strong class="source-inline">main</strong>. In effect, you don’t have to pass in any argument to <strong class="source-inline">m1</strong> at all; or you can pass in 1, 2, 3, or more integers. This is shown by the method calls (lines 5-8). Internally, in the <strong class="source-inline">m1</strong> method, <strong class="source-inline">varargs</strong> is treated as an array. The <strong class="source-inline">for</strong> loop (lines 12-14) <span class="No-Break">demonstrate that.</span></p>
			<p>The output from <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.10</em> is <span class="No-Break">as follows:</span></p>
			<pre class="console">
01
3
6</pre>
			<p>Line 5 generates no output at all. Line 6 generates <strong class="source-inline">1</strong>; line 7 generates <strong class="source-inline">3</strong>; and line 8 <span class="No-Break">generates </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></p>
			<p>Let’s examine some edge cases with <strong class="source-inline">varargs</strong>. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.11</em> <span class="No-Break">will help:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B19793_07_11.jpg" alt="Figure 7.11 – varargs compiler errors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – varargs compiler errors</p>
			<p>In the preceding<a id="_idIndexMarker464"/> figure, we can see that <strong class="source-inline">varargs</strong> must be the last parameter in the method definition. Line 10 is fine as it defines the <strong class="source-inline">varargs</strong> parameter as the last parameter. However, line 11 is a compiler error because it attempts to define a parameter <em class="italic">after</em> the varargs parameter. This makes sense as all other parameters are mandatory; so, if <strong class="source-inline">varargs</strong> can define 0 or more arguments, it must be the <span class="No-Break">last parameter.</span></p>
			<p>Given that <strong class="source-inline">varargs</strong> is treated as an array, this begs the question, can we use an array instead of <strong class="source-inline">varargs</strong>? The answer is no. The compiler errors (lines 5-8) all relate to the fact that, despite the presence of <strong class="source-inline">m1(int[])</strong> on line 12, the compiler cannot find the method definition that matches any of these <span class="No-Break">method calls.</span></p>
			<p>The last major topic for methods is an important one: call by value. We will discuss <span class="No-Break">that now.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor162"/>Mastering call by value</h1>
			<p>Java uses<a id="_idIndexMarker465"/> call by value when passing arguments to methods and returning results from methods. Concisely, this means that Java <em class="italic">makes a copy of something</em>. Effectively, when you are passing an argument to a method, a copy is made of that argument and when you are returning a result from a method, a copy is made of that result. Why do we care? Well, depending on what you are copying – a primitive or a reference has <strong class="bold">major</strong> implications. An example of a primitive type is <strong class="source-inline">int</strong> and an example of a reference type is <span class="No-Break">an array.</span></p>
			<p>In a method, there <a id="_idIndexMarker466"/>is a clear difference between the effect of changes when the parameter is a primitive type versus when the parameter is a reference type. We will demonstrate this shortly with a code example but first, to appreciate the differences, we need to understand what is happening <span class="No-Break">in memory.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>Primitives versus references in memory</h2>
			<p>An<a id="_idIndexMarker467"/> array is an object, whereas a <a id="_idIndexMarker468"/>primitive is not. We will discuss objects in detail in <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, but for now, let’s examine the code in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B19793_07_12.jpg" alt="Figure 7.12 – Sample code containing a primitive and an array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Sample code containing a primitive and an array</p>
			<p>To understand what the code in the preceding figure looks like in memory, we need to discuss the stack, the heap, <span class="No-Break">and references.</span></p>
			<h3>Stack</h3>
			<p>The<a id="_idIndexMarker469"/> stack is a special area of memory used by methods. Each time a new method <strong class="source-inline">A</strong>, is called, a new frame is <em class="italic">pushed</em> (created) onto the stack. The frame contains, among other things, <strong class="source-inline">A</strong>’s local variables and their values. Each frame is stacked one on top of the other, like plates. If <strong class="source-inline">A</strong> calls another method, <strong class="source-inline">B</strong>, the existing frame for <strong class="source-inline">A</strong> is saved and a new frame for <strong class="source-inline">B</strong> is pushed onto the stack, creating a new context. When <strong class="source-inline">B</strong> finishes, its stack frame is <em class="italic">popped</em> (removed) from the stack, and the frame for <strong class="source-inline">A</strong> is restored (with all its local variables and their values as they were, prior to the call to <strong class="source-inline">B</strong>). This is why a<a id="_idIndexMarker470"/> stack is called a <strong class="bold">Last-In, First Out</strong> (<strong class="bold">LIFO</strong>) structure. For further detail on the stack and Java Memory Management in general, please see our previous <span class="No-Break">book: </span><a href="https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&amp;keywords=java+memory+management+maaike&amp;qid=1699112145&amp;sprefix=java+memory+management+maaike%2Caps%2C148&amp;sr=8-1&#13;"><span class="No-Break">https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/</span> <span class="No-Break">1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&amp;keywords=java+memory+management+maaike&amp;qid=1699112145&amp;sprefix=java+memory+management+</span> <span class="No-Break">maaike%2Caps%2C148&amp;sr=8-1</span></a></p>
			<p>For our discussion here, what we need to be aware of is that local variables (primitives and/or references) are <a id="_idIndexMarker471"/>stored on the stack. Objects are <em class="italic">not</em> stored on the stack; objects are stored on <span class="No-Break">the heap.</span></p>
			<h3>Heap</h3>
			<p>The heap<a id="_idIndexMarker472"/> is an area of memory reserved for objects and arrays are objects. This means that arrays are stored on the heap. To access an object, we use <span class="No-Break">a reference.</span></p>
			<h3>References</h3>
			<p>The <a id="_idIndexMarker473"/>named identifier used to access an object is known as a reference. A reference is similar to a pointer. Consider a TV that has no buttons on it to change the channel but does have a remote control. The reference is the remote control and the TV is <span class="No-Break">the object.</span></p>
			<p>With these definitions in mind, let’s review the code in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.12</em>. Line 5 declares a primitive <strong class="source-inline">int</strong> type called <strong class="source-inline">x</strong> and initializes it to 19. Line 6 declares an <strong class="source-inline">int</strong> array, namely <strong class="source-inline">arr</strong>, and initializes <strong class="source-inline">arr[0]</strong> to <strong class="source-inline">1</strong> and <strong class="source-inline">arr[1]</strong> to <strong class="source-inline">2</strong>. The array reference is <strong class="source-inline">arr</strong>. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.13</em> shows the in-memory representation of <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.12</em> as we reach <span class="No-Break">line 7:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B19793_07_13.jpg" alt="Figure 7.13 – In-memory representation of the code from Figure 7.12"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – In-memory representation of the code from Figure 7.12</p>
			<p>In the preceding figure, we can see that there is a stack frame for the <strong class="source-inline">main</strong> method containing the local variables, <strong class="source-inline">x</strong> and <strong class="source-inline">arr</strong>. Note that, for simplicity, the <strong class="source-inline">String[] args</strong> parameter in <strong class="source-inline">main</strong> is omitted. Immediately, you can see the difference between the way primitives, namely <strong class="source-inline">x</strong>, and references, namely <strong class="source-inline">arr</strong>, are stored – <strong class="source-inline">x</strong> and its value are stored on the stack; whereas the value of <strong class="source-inline">arr</strong> refers to the object on <span class="No-Break">the heap.</span></p>
			<p>With this in mind, we <a id="_idIndexMarker474"/>are now in a position to examine a proper code example demonstrating the real impact of call by value when passing primitives versus passing references. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.14</em> represents the code example we will <span class="No-Break">be using:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B19793_07_14.jpg" alt="Figure 7.14 – Call by value passing primitives and references"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Call by value passing primitives and references</p>
			<p>In this figure, the <strong class="source-inline">callByValue</strong> method is defined on lines 13-17: the method accepts an <strong class="source-inline">int</strong> type and an <strong class="source-inline">int</strong> array in that order and returns an <strong class="source-inline">int</strong>. Line 14 changes the value of the <strong class="source-inline">int</strong> parameter to -1 and line 15 changes index 0 of the array to -1. Lastly, the method returns the value of <strong class="source-inline">x</strong> on <span class="No-Break">line 16.</span></p>
			<p>Let us examine the first call to <strong class="source-inline">callByValue</strong>, passing down the <strong class="source-inline">x</strong> and <strong class="source-inline">arr</strong> arguments. It is important to note that the <strong class="source-inline">x</strong> and <strong class="source-inline">arr</strong> variables declared in <strong class="source-inline">main</strong> are completely separate variables from the <strong class="source-inline">x</strong> and <strong class="source-inline">arr</strong> parameters declared in the method <strong class="source-inline">callByValue</strong>. This is because they are in two separate scopes (methods). As Java uses call by value, copies of the primitive, <strong class="source-inline">x</strong>, and the reference, <strong class="source-inline">arr</strong>, are made and it is the <em class="italic">copies</em> that are passed into the <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">callByValue</strong></span><span class="No-Break">.</span></p>
			<p>Making a copy of a <a id="_idIndexMarker475"/>primitive is like photocopying a blank sheet of paper - if you pass the photocopy to someone and they write on it, your original blank sheet is still blank. Making a copy of a reference is like copying a remote control – if you give the second remote control (the copied one) to someone else, they can change the channel on the TV. Crucially, there is only one TV in all of this – the copy is made of the remote control, <em class="italic">not</em> <span class="No-Break">the TV.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This saves memory as copying a reference has a much smaller memory footprint that copying a potentially <span class="No-Break">large object.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.15</em> represents the in-memory representation of the code as we are about to <strong class="source-inline">return</strong> from the <em class="italic">first</em> invocation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">callByValue</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B19793_07_15.jpg" alt="Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call to callByValue (line 7)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 - In-memory view of Figure 7.14 (line 16) based on first call to callByValue (line 7)</p>
			<p>As can be seen from the <a id="_idIndexMarker476"/>stack in the preceding figure, when we call <strong class="source-inline">callByValue(x, arr)</strong> from <strong class="source-inline">main</strong>, the existing frame for <strong class="source-inline">main</strong> is saved and a frame for <strong class="source-inline">callByValue</strong> is pushed onto the stack (on top of the frame for <strong class="source-inline">main</strong>). Then the code for <strong class="source-inline">callByValue</strong> <span class="No-Break">is executed:</span></p>
			<pre class="source-code">
x = -1:arr[0] = -1;
return x;</pre>
			<p>Firstly, <strong class="source-inline">x</strong> in changed in the <strong class="source-inline">callByValue</strong> frame. This is the copy of <strong class="source-inline">x</strong> from <strong class="source-inline">main</strong>. Note that the value of <strong class="source-inline">x</strong> in (the frame for) <strong class="source-inline">main</strong> remains untouched (still 19). Consequently, 19 is output for <strong class="source-inline">x</strong> in <strong class="source-inline">main</strong> (line 8). Thus, a called method cannot (directly) change the caller method’s primitive values. We will revisit this <span class="No-Break">point shortly.</span></p>
			<p>However, the line <strong class="source-inline">arr[0] = 1;</strong> in <strong class="source-inline">callByValue</strong> does have a material impact on <strong class="source-inline">main</strong>. When <strong class="source-inline">callByValue</strong> uses its <strong class="source-inline">arr</strong> reference, which is a copy of the <strong class="source-inline">arr</strong> reference from <strong class="source-inline">main</strong>, it changes the one object that <a id="_idIndexMarker477"/>both methods share. In effect, the array object that <strong class="source-inline">main</strong> is looking at is changed. This is demonstrated in <strong class="source-inline">main</strong> after the <strong class="source-inline">callByValue</strong> <span class="No-Break">method returns:</span></p>
			<pre class="source-code">
System.out.println(arr[0] + ", " + arr[1]); // -1, 2</pre>			<p>Crucially, <strong class="source-inline">-1</strong> is output for the value at <strong class="source-inline">arr[0]</strong>. Therefore, be aware that when passing a reference to a method, the method can change the object that you are <span class="No-Break">looking at.</span></p>
			<p>Let’s revisit the primitive situation. What if we wanted the called method to change the primitive value that’s passed down? This is why <strong class="source-inline">callByValue</strong> is returning <strong class="source-inline">x</strong>. The first method call to <strong class="source-inline">callByValue</strong> completely ignores the <span class="No-Break">return value:</span></p>
			<pre class="source-code">
callByValue(x, arr);</pre>			<p>However, the second call <span class="No-Break">does not:</span></p>
			<pre class="source-code">
x = callByValue(x, arr);</pre>			<p>The -1 that’s returned from <strong class="source-inline">callByValue</strong> is used to overwrite the value of <strong class="source-inline">x</strong> in <strong class="source-inline">main</strong>. As a result, -1 is output for <strong class="source-inline">x</strong> in <strong class="source-inline">main</strong> (<span class="No-Break">line 11).</span></p>
			<p>That completes our discussion on methods. Now, let’s put that knowledge into practice to reinforce <span class="No-Break">these concepts.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>Exercises</h1>
			<p>Maintaining a dinosaur park takes a lot more than just raw passion. It involves regular health check-ups for our dinosaurs, ensuring our guests are comfortable, and that the park is well-staffed. All these tasks involve methodical processes. Luckily, we now know <span class="No-Break">about methods!</span></p>
			<p>You can add these methods to the <span class="No-Break">same class:</span></p>
			<ol>
				<li>The stage of life a dinosaur is in can significantly impact its behavior and needs. Write a method that takes a dinosaur’s age and returns whether it’s a hatchling, juvenile, <span class="No-Break">or adult.</span></li>
				<li>It’s important to remember that our dinosaurs aren’t actually pets – they’re large, often hefty creatures with large appetites. Write a method that accepts a dinosaur’s weight and calculates how much food it <span class="No-Break">needs daily.</span></li>
				<li>Being on top of our dinosaurs’ average age helps us plan for the future. Design a method that accepts an array of dinosaur ages and calculates the <span class="No-Break">average age.</span></li>
				<li>The park isn’t open 24/7 to day visitors. We need some time to clean up the popcorn and repair any minor damages to the enclosures. Write a method that checks if the park is open or closed based on the current time. (Hint: this method doesn’t require <span class="No-Break">any input.)</span></li>
				<li>Personalization is key to making our guests feel special. Create a method that uses a dinosaur’s name and a visitor’s name to craft a personal <span class="No-Break">greeting message.</span></li>
				<li>As you’re well aware, safety is our top priority. We need a method to return whether we can let in another group of guests (a certain number of people) to the park based on the current number of visitors and the maximum number of <span class="No-Break">visitors allowed.</span></li>
			</ol>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Project – Mesozoic Eden assistant</h1>
			<p>This is going to be our biggest project so far. So, <span class="No-Break">buckle up!</span></p>
			<p>Let’s start with a high-level description. The <a id="_idIndexMarker478"/>Mesozoic Eden assistant is an interactive console application that assists in managing a dinosaur park. The assistant should have features to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Add or <span class="No-Break">remove dinosaurs</span></li>
				<li>Check the park’s <span class="No-Break">opening hours</span></li>
				<li>Greet guests and provide <span class="No-Break">park information</span></li>
				<li>Track visitor counts to ensure the park <span class="No-Break">isn’t overcrowded</span></li>
				<li>Manage park <span class="No-Break">staff details</span></li>
			</ul>
			<p>Since we won’t let you drown, if you need it, here is a step-by-step guide. A starting project will follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li><strong class="bold">Create a data structure</strong>: Create the necessary classes for <strong class="source-inline">Dinosaur</strong>, <strong class="source-inline">Guest</strong>, and <strong class="source-inline">Employee</strong>. Include appropriate properties <span class="No-Break">and methods.</span></li>
				<li><strong class="bold">Initialize the data</strong>: You can choose to hardcode initial data or provide a mechanism to input data using the <span class="No-Break"><strong class="source-inline">Scanner</strong></span><span class="No-Break"> class.</span></li>
				<li><strong class="bold">Implement interaction</strong>: Implement a simple console-based interaction with the user using the <span class="No-Break"><strong class="source-inline">Scanner</strong></span><span class="No-Break"> class.</span></li>
				<li><strong class="bold">Create a menu</strong>: Create a menu that allows the user to interact with the park <span class="No-Break">management system.</span></li>
				<li><strong class="bold">Handle actions</strong>: Each menu item should trigger a certain action, such as adding a dinosaur, checking park hours, or greeting <span class="No-Break">a guest.</span></li>
				<li><strong class="bold">Exit the program</strong>: Provide an option for the user to exit <span class="No-Break">the program.</span></li>
			</ol>
			<p>Here is a <a id="_idIndexMarker479"/>code snippet to get <span class="No-Break">you started:</span></p>
			<pre class="source-code">
import java.util.Scanner;public class Main {
    // Use Scanner for reading input from the user
    Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        Main main = new Main();
        main.start();
    }
    public void start() {
        // This is the main loop of the application. It
          will keep running until the user decides to exit.
        while (true) {
            displayMenu();
            int choice = scanner.nextInt();
            handleMenuChoice(choice);
        }
    }
    public void displayMenu() {
        System.out.println("Welcome to Mesozoic Eden
          Assistant!");
        System.out.println("1. Add Dinosaur");
        System.out.println("2. Check Park Hours");
        System.out.println("3. Greet Guest");
        System.out.println("4. Check Visitors Count");
        System.out.println("5. Manage Staff");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }
    public void handleMenuChoice(int choice) {
        switch (choice) {
            case 1:
                // addDinosaur();
                break;
            case 2:
                // checkParkHours();
                break;
            case 3:
                // greetGuest();
                break;
            case 4:
                // checkVisitorsCount();
                break;
            case 5:
                // manageStaff();
                break;
            case 6:
                System.out.println("Exiting...");
                System.exit(0);
        }
    }
}</pre>
			<p>So, this<a id="_idIndexMarker480"/> is a great starting point! But it’s not done. In the preceding code snippet, <strong class="source-inline">addDinosaur()</strong>, <strong class="source-inline">checkParkHours()</strong>, <strong class="source-inline">greetGuest()</strong>, <strong class="source-inline">checkVisitorsCount()</strong>, and <strong class="source-inline">manageStaff()</strong> are placeholders for methods you need to implement according to your data structures and functionality. The <strong class="source-inline">Scanner</strong> class is used to read the user’s menu choice from <span class="No-Break">the console.</span></p>
			<p>You can make the project as sophisticated as you like by adding additional features <span class="No-Break">and enhancements.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor166"/>Summary</h1>
			<p>In this chapter, we started our discussion on methods by stating that methods are simply code blocks that are given a name for ease of reference. Methods are important because they enable us to abstract away the implementation, while at the same time helping us to avoid unnecessary <span class="No-Break">code duplication.</span></p>
			<p>There are two parts to a method: the method definition (or declaration) and the method call (or invocation). The method definition declares (among other things) the method name, the input parameters, and the return type. The method name and the parameter types (including their order) constitute the method signature. The method call passes down the arguments (if any) to be used as inputs in the method. The return value from a method (if there is one) can be captured by assigning the method call to <span class="No-Break">a variable.</span></p>
			<p>Method overloading is where the same method name is used across several different methods. What distinguishes the various methods is that they have different signatures – the parameter types and/or their order will be different. The parameter names and return types do <span class="No-Break">not matter.</span></p>
			<p>A <strong class="source-inline">varargs</strong> (variable arguments) parameter is specified in a method declaration using an ellipsis (three dots). This means that when calling this method, the arguments corresponding to that parameter are variable – you can pass down <strong class="source-inline">0</strong> or more arguments for that parameter. Internally, in the method, the <strong class="source-inline">varargs</strong> parameter is treated as <span class="No-Break">an array.</span></p>
			<p>When passing arguments to a method, Java uses call by value. This means that a copy of the argument is made. Depending on whether you are passing down a primitive or a reference has major implications regarding the effect of the changes that are made by the called method on the calling method. If it’s a primitive, the called method cannot change the primitive that the caller method has (unless the caller method deliberately overwrites the variable with the return value). If it’s a reference, the called method can change the object that the caller method is <span class="No-Break">looking at.</span></p>
			<p>Now that we have finished looking at methods, let’s move on to our first strictly <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) chapter, where we will look at classes, objects, <span class="No-Break">and enums.</span></p>
		</div>
	

		<div id="_idContainer098" class="Content">
			<h1 id="_idParaDest-167" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor167"/>Part 2: Object-Oriented Programming</h1>
			<p>In this part, we will take a deep dive into <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>). We will start by looking at classes and their relationship with objects. We will discuss the first core pillar of OOP, namely Encapsulation. Enums and records, both of which are closely related to classes, will also be covered. We will then move on to the remaining two major pillars in OOP, namely Inheritance and Polymorphism. Next up are <strong class="source-inline">abstract</strong> classes and the hugely important <strong class="source-inline">interface </strong>construct. Following that, we will examine Java’s exception framework. Lastly, we will explore selected classes from the Java Core API, such as <strong class="source-inline">String</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">StringBuilder</strong></span><span class="No-Break">.</span></p>
			<p>This section has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19793_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Classes, Objects, and Enums</em></li>
				<li><a href="B19793_09.xhtml#_idTextAnchor205"><em class="italic">Chapter 9</em></a>, <em class="italic">Inheritance and Polymorphism</em></li>
				<li><a href="B19793_10.xhtml#_idTextAnchor249"><em class="italic">Chapter 10</em></a>, <em class="italic">Interfaces and Abstract Classes</em></li>
				<li><a href="B19793_11.xhtml#_idTextAnchor266"><em class="italic">Chapter 11</em></a>, <em class="italic">Dealing with Exceptions</em></li>
				<li><a href="B19793_12.xhtml#_idTextAnchor293"><em class="italic">Chapter 12</em></a>, <em class="italic">Java Core API</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer099">
			</div>
		</div>
	</body></html>