<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Object Relational Mapping with JPA"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Object Relational Mapping with JPA</h1></div></div></div><p>Any non-trivial Java EE application will persist data to a relational database. In this chapter, we will <a id="id243" class="indexterm"/>cover how to connect to a database and perform <span class="strong"><strong>CRUD</strong></span> operations (<span class="strong"><strong>Create</strong></span>, <span class="strong"><strong>Read</strong></span>, <span class="strong"><strong>Update</strong></span>, <span class="strong"><strong>Delete</strong></span>).</p><p>The <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>) is<a id="id244" class="indexterm"/> the standard Java EE <span class="strong"><strong>Object Relational Mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>) tool.<a id="id245" class="indexterm"/> We will discuss this API in detail in this chapter.</p><p>Some of the topics covered in this chapter include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Retrieving data from a database through JPA</li><li class="listitem" style="list-style-type: disc">Inserting data into a database through JPA</li><li class="listitem" style="list-style-type: disc">Updating data in a database through JPA</li><li class="listitem" style="list-style-type: disc">Deleting data in a database through JPA</li><li class="listitem" style="list-style-type: disc">Building queries programmatically through the JPA Criteria API</li><li class="listitem" style="list-style-type: disc">Automating data validation through JPA 2.0's Bean Validation support</li></ul></div><div class="section" title="The CustomerDB database"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>The CustomerDB database</h1></div></div></div><p>Examples in this chapter will use a database called <code class="literal">CUSTOMERDB</code>. This database<a id="id246" class="indexterm"/> contains tables to track customer and order information for a fictitious store. The database uses JavaDB for its <span class="strong"><strong>Relational Database Management System</strong></span> (<span class="strong"><strong>RDBMS</strong></span>)<a id="id247" class="indexterm"/> since it comes bundled with GlassFish.</p><p>A script is included with this book's code download to create this database and prepopulate some of its tables. Instructions on how to execute the script and add a connection pool and datasource to <a id="id248" class="indexterm"/>access it are included in the download as well. The schema for the <code class="literal">CUSTOMERDB</code> database is depicted in the following diagram:</p><div class="mediaobject"><img src="graphics/6886EN_03_01.jpg" alt="The CustomerDB database"/></div><p>As can be seen in the preceding diagram, the database contains tables to store customer information such as name, address, and e-mail address. It also contains tables to store order and item information.</p><p>The <code class="literal">ADDRESS_TYPES</code> table <a id="id249" class="indexterm"/>will store <a id="id250" class="indexterm"/>values such as "Home", "Mailing", and "Shipping" to distinguish the type of address in the <code class="literal">ADDRESSES</code> table; similarly, the<a id="id251" class="indexterm"/> <code class="literal">TELEPHONE_TYPES</code> table<a id="id252" class="indexterm"/> stores the values "Cell", "Home", and "Work". These two tables are prepopulated when creating the database as well as the <a id="id253" class="indexterm"/>
<code class="literal">US_STATES</code> table.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>For simplicity, our database only deals with US addresses.</p></div></div></div></div>
<div class="section" title="Introducing the Java Persistence API"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Introducing the Java Persistence API</h1></div></div></div><p>JPA<a id="id254" class="indexterm"/> was introduced to Java EE in Version 5 of the specification. As its name implies, it is used to persist data to an RDBMS. JPA is a replacement for Entity Beans that were used in J2EE. JPA Entities are regular Java classes; the Java EE container recognizes these classes as JPA entities. Let's look at an Entity mapping to the <code class="literal">CUSTOMER</code> table in the <code class="literal">CUSTOMERDB</code> database, shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jpaintro.entity;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable
{
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;

  @Column(name = "FIRST_NAME")
  private String firstName;

  @Column(name = "LAST_NAME")
  private String lastName;

  private String email;

  public Long getCustomerId()
  {
    return customerId;
  }
  public void setCustomerId(Long customerId)
  {
    this.customerId = customerId;
  }
  public String getEmail()
  {
    return email;
  }
  public void setEmail(String email)
  {
    this.email = email;
  }
  public String getFirstName()
  {
    return firstName;
  }
  public void setFirstName(String firstName)
  {
    this.firstName = firstName;
  }
  public String getLastName()
  {
    return lastName;
  }
  public void setLastName(String lastName)
  {
    this.lastName = lastName;
  }
}</pre></div><p>In the preceding code, the <code class="literal">@Entity</code> annotation lets GlassFish (or, for that matter, any other application server <a id="id255" class="indexterm"/>that is compliant with Java EE) know that this class is an entity.</p><p>The <code class="literal">@Table(name = "CUSTOMERS")</code> annotation<a id="id256" class="indexterm"/> lets the application server know what table to map the entity to. The value of the <code class="literal">name</code> element contains the name of the database table that the entity maps to. This annotation is optional; if the name of the class is the same as the name of the database table, then it isn't necessary to specify what table the entity maps to.</p><p>The <code class="literal">@Id</code> annotation<a id="id257" class="indexterm"/> indicates that the <code class="literal">customerId</code> field is the primary key (unique identifier) for our Entity.</p><p>The <code class="literal">@Column</code> annotation<a id="id258" class="indexterm"/> maps each field to a column in the table. If the name of the field matches the name of the database column, then this annotation is not needed. This is the reason why the <code class="literal">email</code> field is not annotated.</p><p>The <code class="literal">EntityManager</code> class (<code class="literal">EntityManager</code> is actually an interface; each Java EE compliant application server provides its own implementation) is used to persist Entities to a database.<a id="id259" class="indexterm"/> The following example illustrates its usage:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jpaintro.namedbean;

import javax.annotation.Resource;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.HeuristicMixedException;
import javax.transaction.HeuristicRollbackException;
import javax.transaction.NotSupportedException;
import javax.transaction.RollbackException;
import javax.transaction.SystemException;
import javax.transaction.UserTransaction;
import net.ensode.glassfishbook.jpaintro.entity.Customer;

@Named
@RequestScoped
public class JpaDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    public String updateDatabase() {

        String retVal = "confirmation";

        Customer customer = new Customer();
        Customer customer2 = new Customer();
        Customer customer3;

        customer.setCustomerId(3L);
        customer.setFirstName("James");
        customer.setLastName("McKenzie");
        customer.setEmail("jamesm@notreal.com");

        customer2.setCustomerId(4L);
        customer2.setFirstName("Charles");
        customer2.setLastName("Jonson");
        customer2.setEmail("cjohnson@phony.org");

        try {
            userTransaction.begin();
            entityManager.persist(customer);
            entityManager.persist(customer2);
            customer3 = entityManager.find(Customer.class, 4L);
            customer3.setLastName("Johnson");
            entityManager.persist(customer3);
            entityManager.remove(customer);

            userTransaction.commit();
        } catch (HeuristicMixedException |
                HeuristicRollbackException |
                IllegalStateException |
                NotSupportedException |
                RollbackException |
                SecurityException |
                SystemException e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }
}</pre></div><p>The CDI named bean<a id="id260" class="indexterm"/> in the preceding code obtains an instance of a class implementing the <code class="literal">javax.persistence.EntityManager</code> interface via dependency injection. This is done by decorating the <code class="literal">EntityManager</code> variable with the <code class="literal">@PersistenceContext</code> annotation.</p><p>An instance of a class implementing the <code class="literal">javax.transaction.UserTransaction</code> interface is then injected via the <code class="literal">@Resource</code> annotation. This object is necessary since without it, invoking calls to persist Entities to the database would result in the code throwing a <code class="literal">javax.persistence.TransactionRequiredException</code>.</p><p>The <code class="literal">EntityManager</code> class performs many database-related tasks such as finding entities in the database, updating them, and deleting them.</p><p>Since JPA Entities are <span class="strong"><strong>Plain Old Java Objects</strong></span> (<span class="strong"><strong>POJOs</strong></span>),<a id="id261" class="indexterm"/> they can be instantiated via the <code class="literal">new</code> operator.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>POJOs are Java objects that do not need to extend any specific parent class or implement any specific interface</p><p>The call to the <code class="literal">setCustomerId()</code> method<a id="id262" class="indexterm"/> takes advantage of autoboxing, a feature added to the Java language in JDK 1.5. Note that the method takes an instance of <code class="literal">java.lang.Long</code> as its parameter, but we are using long primitives. The code compiles and executes properly thanks to this feature..</p></div></div><p>Calls to the <code class="literal">persist()</code> method on <code class="literal">EntityManager</code> must be in a transaction; therefore, it is necessary to start one by calling the <code class="literal">begin()</code> method on <code class="literal">UserTransaction</code>.</p><p>We then insert two <a id="id263" class="indexterm"/>new rows to the <code class="literal">CUSTOMERS</code> table by calling the <code class="literal">persist()</code> method on <code class="literal">entityManager</code> for the two instances of the <code class="literal">Customer</code> class we populated earlier in the code.</p><p>After persisting the data contained in the <code class="literal">customer</code> and <code class="literal">customer2</code> objects, we search the database for a row in the <code class="literal">CUSTOMERS</code> table with a primary key of <code class="literal">4</code>. We do this by invoking the <code class="literal">find()</code> method on <code class="literal">entityManager</code>. This method takes the class of the Entity we are searching for as its first parameter and the primary key of the row corresponding to the object we want to obtain. This method is roughly equivalent to the <code class="literal">findByPrimaryKey()</code> method<a id="id264" class="indexterm"/> on an Entity Bean's home interface.</p><p>The primary key we set for the <code class="literal">customer2</code> object was <code class="literal">4</code>; therefore, what we have now is a copy of this object. The last name for this customer was misspelled when we originally inserted his data into the database; we now correct Mr. Johnson's last name by invoking the <code class="literal">setLastName()</code> method on <code class="literal">customer3</code> and then update the information in the database by invoking <code class="literal">entityManager.persist()</code>.</p><p>We then delete the information for the <code class="literal">customer</code> object by invoking <code class="literal">entityManager.remove()</code> and passing the <code class="literal">customer</code> object as a parameter.</p><p>Finally, we commit the changes to the database by invoking the <code class="literal">commit()</code> method on <code class="literal">userTransaction</code>.</p><p>In order for our code to work as expected, an XML configuration file named <code class="literal">persistence.xml</code> must be deployed in the WAR file containing <code class="literal">JPADemoBean</code>. This file must be placed in the <code class="literal">WEB-INF/classes/META-INF/</code> directory inside the WAR file. The contents of this file corresponding to our code are shown next:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1"


xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"&gt;
  &lt;persistence-unit name="customerPersistenceUnit"&gt;
    &lt;jta-data-source&gt;jdbc/__CustomerDBPool&lt;/jta-data-source&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p>The <code class="literal">persistence.xml</code> file must contain at least one <code class="literal">&lt;persistence-unit&gt;</code> element. Each <code class="literal">&lt;persistence-unit&gt;</code> element must provide a value for its <code class="literal">name</code> attribute and must contain a <code class="literal">&lt;jta-data-source&gt;</code> child element whose value is the JNDI name of the datasource to be used for the persistence unit.</p><p>More than one <code class="literal">&lt;persistence-unit&gt;</code> element is allowed because an application may access more than one database. A <code class="literal">&lt;persistence-unit&gt;</code> element is required for each database the application will <a id="id265" class="indexterm"/>access. If the application defines more than one <code class="literal">&lt;persistence-unit&gt;</code> element, then the <code class="literal">@PersistenceContext</code> annotation used to inject <code class="literal">EntityManager</code> must provide a value for its <code class="literal">unitName</code> element. The value for this element must match the <code class="literal">name</code> attribute of the corresponding <code class="literal">&lt;persistence-unit&gt;</code> element in <code class="literal">persistence.xml</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>Cannot persist the detached object exception</strong></span>
</p><p>An application will frequently retrieve a JPA entity via the <code class="literal">EntityManager.find()</code> method and then pass this entity to a business or user interface layer, where it will potentially be modified. Later, the database data corresponding to the entity will be updated. In cases like this, invoking <code class="literal">EntityManager.persist()</code> will result in an exception. In order to update JPA entities this way, we need to invoke <code class="literal">EntityManager.merge()</code>. This method takes an instance of the JPA entity as its single argument and updates the corresponding row in the database with the data stored in it.</p></div></div><div class="section" title="Entity relationships"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Entity relationships</h2></div></div></div><p>In the previous section, we saw how to retrieve, insert, update, and delete single entities from the database. Entities<a id="id266" class="indexterm"/> are rarely isolated; in the vast majority of cases, they are related to other entities.</p><p>Entities can have<a id="id267" class="indexterm"/> one-to-one, one-to-many, many-to-one, and many-to-many relationships.</p><p>In the <code class="literal">CustomerDB</code> database, for example, there is a one-to-one relationship between the <code class="literal">LOGIN_INFO</code> table and the <code class="literal">CUSTOMERS</code> tables. This means that each customer has exactly one corresponding row in the <code class="literal">LOGIN_INFO</code> table. There is also a one-to-many relationship between the <code class="literal">CUSTOMERS</code> table and the <code class="literal">ORDERS</code> table. This is because a customer can place many orders, but each order belongs only to a single customer. Additionally, there is a many-to-many relationship between the <code class="literal">ORDERS</code> table and the <code class="literal">ITEMS</code> table. This is because an order can contain many items and an item can be in many orders.</p><p>In the next few sections, we discuss how to establish relationships between JPA entities.</p><div class="section" title="One-to-one relationships"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>One-to-one relationships</h3></div></div></div><p>One-to-one relationships occur when an instance of an entity can have zero or one corresponding instance of another entity.</p><p>One-to-one entity<a id="id268" class="indexterm"/> relationships can be bidirectional (each entity is aware of the relationship) or unidirectional (only one of the entities is aware of the relationship). In the <code class="literal">CustomerDB</code> example database, the one-to-one mapping<a id="id269" class="indexterm"/> between the <code class="literal">LOGIN_INFO</code> and the <code class="literal">CUSTOMERS</code> tables is unidirectional. This is because the <code class="literal">LOGIN_INFO</code> table has a foreign key to the <code class="literal">CUSTOMERS</code> table, but not the other way around. As we will soon see, this fact does not stop us from creating a bidirectional one-to-one relationship between the <code class="literal">Customer</code> entity and the <code class="literal">LoginInfo</code> entity.</p><p>The source code for the <code class="literal">LoginInfo</code> entity, which maps to the <code class="literal">LOGIN_INFO</code> table, can be seen next:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.Table;

@Entity
@Table(name = "LOGIN_INFO")
public class LoginInfo
{
  @Id
  @Column(name = "LOGIN_INFO_ID")
  private Long loginInfoId;

  @Column(name = "LOGIN_NAME")
  private String loginName;

  private String password;

<span class="strong"><strong>  @OneToOne</strong></span>
<span class="strong"><strong>  @JoinColumn(name="CUSTOMER_ID")</strong></span>
<span class="strong"><strong>  private Customer customer;</strong></span>

  public Long getLoginInfoId()
  {
    return loginInfoId;
  }

  public void setLoginInfoId(Long loginInfoId)
  {
    this.loginInfoId = loginInfoId;
  }

  public String getPassword()
  {
    return password;
  }

  public void setPassword(String password)
  {
    this.password = password;
  }

  public String getLoginName()
  {
    return loginName;
  }

  public void setLoginName(String userName)
  {
    this.loginName = userName;
  }

  public Customer getCustomer()
  {
    return customer;
  }

  public void setCustomer(Customer customer)
  {
    this.customer = customer;
  }

}</pre></div><p>The code for this entity is very similar to the code for the <code class="literal">Customer</code> entity; it defines fields that map to database<a id="id270" class="indexterm"/> columns. Each field whose<a id="id271" class="indexterm"/> name does not match the database column name is decorated with the <code class="literal">@Column</code> annotation; in addition to that, the primary key is decorated with the <code class="literal">@Id</code> annotation.</p><p>This code gets interesting in the declaration of the <code class="literal">customer</code> field. As can be seen in the code, the <code class="literal">customer</code> field is decorated with the <code class="literal">@OneToOne</code> annotation<a id="id272" class="indexterm"/>. This lets the application server (GlassFish) know that there is a one-to-one relationship between this entity and the <code class="literal">Customer</code> entity. The <code class="literal">customer</code> field is also decorated with the <code class="literal">@JoinColumn</code> annotation. This annotation lets the container know what column in the <code class="literal">LOGIN_INFO</code> table is the foreign key corresponding to the primary key on the <code class="literal">CUSTOMER</code> table. Since <code class="literal">LOGIN_INFO</code>, the table that the <code class="literal">LoginInfo</code> entity maps to, has a foreign key to the <code class="literal">CUSTOMER</code> table, the <code class="literal">LoginInfo</code> entity owns the relationship. If the relationship was unidirectional, we wouldn't have to make any changes to the <code class="literal">Customer</code> entity. However, since we<a id="id273" class="indexterm"/> would like to have a bidirectional relationship between these two entities, we need to add a <code class="literal">LoginInfo</code> field<a id="id274" class="indexterm"/> to the <code class="literal">Customer</code> entity, along with the corresponding getter and setter methods, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable
{
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;

  @Column(name = "FIRST_NAME")
  private String firstName;

  @Column(name = "LAST_NAME")
  private String lastName;

  private String email;

<span class="strong"><strong>  @OneToOne(mappedBy = "customer")</strong></span>
<span class="strong"><strong>  private LoginInfo loginInfo;</strong></span>

  public Long getCustomerId()
  {
    return customerId;
  }

  public void setCustomerId(Long customerId)
  {
    this.customerId = customerId;
  }

  public String getEmail()
  {
    return email;
  }

  public void setEmail(String email)
  {
    this.email = email;
  }

  public String getFirstName()
  {
    return firstName;
  }

  public void setFirstName(String firstName)
  {
    this.firstName = firstName;
  }

  public String getLastName()
  {
    return lastName;
  }

  public void setLastName(String lastName)
  {
    this.lastName = lastName;
  }

<span class="strong"><strong>  public LoginInfo getLoginInfo()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return loginInfo;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public void setLoginInfo(LoginInfo loginInfo)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    this.loginInfo = loginInfo;</strong></span>
<span class="strong"><strong>  }</strong></span>
</pre></div><p>The only change we need to make to the <code class="literal">Customer</code> entity to make the one-to-one relationship bidirectional is to add a <code class="literal">LoginInfo</code> field to it, along with the corresponding setter and getter methods. The <code class="literal">LoginInfo</code> field<a id="id275" class="indexterm"/> is decorated with the <code class="literal">@OneToOne</code> annotation. Since the <code class="literal">Customer</code> entity does not own the relationship (the table it maps to does not have a foreign key to the corresponding table), the <code class="literal">mappedBy</code> element of the <code class="literal">@OneToOne</code> annotation needs to be added. This element specifies what field in the corresponding entity has the other end <a id="id276" class="indexterm"/>of the relationship. In this particular case, the <code class="literal">customer</code> field in the <code class="literal">LoginInfo</code> entity corresponds to the other end of this one-to-one relationship.</p><p>The following Java <a id="id277" class="indexterm"/>class illustrates the use of the preceding entity:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.namedbean;

import javax.annotation.Resource;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.HeuristicMixedException;
import javax.transaction.HeuristicRollbackException;
import javax.transaction.NotSupportedException;
import javax.transaction.RollbackException;
import javax.transaction.SystemException;
import javax.transaction.UserTransaction;
import net.ensode.glassfishbook.entityrelationship.entity.Customer;
import net.ensode.glassfishbook.entityrelationship.entity.LoginInfo;

@Named
@RequestScoped
public class OneToOneRelationshipDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    public String updateDatabase() {
        String retVal = "confirmation";
        Customer customer;
        LoginInfo loginInfo = new LoginInfo();

        loginInfo.setLoginInfoId(1L);
        loginInfo.setLoginName("charlesj");
        loginInfo.setPassword("iwonttellyou");

        try {
            userTransaction.begin();

            customer = entityManager.find(Customer.class, 4L);
            loginInfo.setCustomer(customer);

            entityManager.persist(loginInfo);

            userTransaction.commit();

        } catch (NotSupportedException |
                SystemException |
                SecurityException |
                IllegalStateException |
                RollbackException |
                HeuristicMixedException |
                HeuristicRollbackException e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }
}</pre></div><p>In this example, we first create an instance of the <code class="literal">LoginInfo</code> entity and populate it with some data. We then obtain an instance of the <code class="literal">Customer</code> entity from the database by invoking the <code class="literal">find()</code> method of <code class="literal">EntityManager</code> (the data for this entity was inserted into the <code class="literal">CUSTOMERS</code> table<a id="id278" class="indexterm"/> in one of the previous examples). We then invoke the <code class="literal">setCustomer()</code> method on the <code class="literal">LoginInfo</code> entity, passing the customer <a id="id279" class="indexterm"/>object as a parameter. Finally, we invoke the <code class="literal">EntityManager.persist()</code> method to save the data in the database.</p><p>Behind the scenes, the <code class="literal">CUSTOMER_ID</code> column of the <code class="literal">LOGIN_INFO</code> table gets populated with the primary key of the corresponding row in the <code class="literal">CUSTOMERS</code> table. This can be easily verified by <a id="id280" class="indexterm"/>querying the <code class="literal">CUSTOMERDB</code> database.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Notice how the call to <code class="literal">EntityManager.find()</code> to obtain the customer entity is inside the same transaction where we call <code class="literal">EntityManager.persist()</code>. This must be the case; otherwise the database will not be updated successfully.</p></div></div></div><div class="section" title="One-to-many relationships"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec12"/>One-to-many relationships</h3></div></div></div><p>JPA one-to-many entity relationships<a id="id281" class="indexterm"/> can be bidirectional (one entity contains a many-to-one relationship and the corresponding entity contains an inverse one-to-many relationship).</p><p>With SQL, one-to-many relationships are defined by foreign keys in one of the tables. The "many" part of the<a id="id282" class="indexterm"/> relationship is the one containing a foreign key to the "one" part of the relationship. One-to-many relationships defined in an RDBMS are typically unidirectional, since making them bidirectional usually results in denormalized data.</p><p>Just as when defining a unidirectional one-to-many relationship in an RDBMS, in JPA, the "many" part of the relationship is the one that has a reference to the "one" part of the relationship; therefore, the annotation used to decorate the appropriate setter method is <code class="literal">@ManyToOne</code>.</p><p>In the <code class="literal">CUSTOMERDB</code> database, there is a unidirectional one-to-many relationship between customers and orders. We define this relationship in the <code class="literal">Order</code> entity, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "ORDERS")
public class Order
{
  @Id
  @Column(name = "ORDER_ID")
  private Long orderId;

  @Column(name = "ORDER_NUMBER")
  private String orderNumber;

  @Column(name = "ORDER_DESCRIPTION")
  private String orderDescription;

<span class="strong"><strong>  @ManyToOne</strong></span>
<span class="strong"><strong>  @JoinColumn(name = "CUSTOMER_ID")</strong></span>
<span class="strong"><strong>  private Customer customer;</strong></span>

  public Customer getCustomer()
  {
    return customer;
  }

  public void setCustomer(Customer customer)
  {
    this.customer = customer;
  }

  public String getOrderDescription()
  {
    return orderDescription;
  }

  public void setOrderDescription(String orderDescription)
  {
    this.orderDescription = orderDescription;
  }

  public Long getOrderId()
  {
    return orderId;
  }

  public void setOrderId(Long orderId)
  {
    this.orderId = orderId;
  }

  public String getOrderNumber()
  {
    return orderNumber;
  }

  public void setOrderNumber(String orderNumber)
  {
    this.orderNumber = orderNumber;
  }
}</pre></div><p>If we were to define a unidirectional many-to-one relationship between the <code class="literal">Orders</code> entity and the <code class="literal">Customer</code> entity, we wouldn't need to make any changes to the <code class="literal">Customer</code> entity. To define a bidirectional <a id="id283" class="indexterm"/>one-to-many<a id="id284" class="indexterm"/> relationship between the two entities, a new field decorated with the <code class="literal">@OneToMany</code> annotation needs to be added to the <code class="literal">Customer</code> entity, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable
{
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;

  @Column(name = "FIRST_NAME")
  private String firstName;

  @Column(name = "LAST_NAME")
  private String lastName;

  private String email;

  @OneToOne(mappedBy = "customer")
  private LoginInfo loginInfo;

<span class="strong"><strong>  @OneToMany(mappedBy="customer")</strong></span>
<span class="strong"><strong>  private Set&lt;Order&gt; orders;</strong></span>

  public Long getCustomerId()
  {
    return customerId;
  }

  public void setCustomerId(Long customerId)
  {
    this.customerId = customerId;
  }

  public String getEmail()
  {
    return email;
  }

  public void setEmail(String email)
  {
    this.email = email;
  }

  public String getFirstName()
  {
    return firstName;
  }

  public void setFirstName(String firstName)
  {
    this.firstName = firstName;
  }

  public String getLastName()
  {
    return lastName;
  }

  public void setLastName(String lastName)
  {
    this.lastName = lastName;
  }

  public LoginInfo getLoginInfo()
  {
    return loginInfo;
  }

  public void setLoginInfo(LoginInfo loginInfo)
  {
    this.loginInfo = loginInfo;
  }

<span class="strong"><strong>  public Set&lt;Order&gt; getOrders()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return orders;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public void setOrders(Set&lt;Order&gt; orders)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    this.orders = orders;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The only difference between this version of the <code class="literal">Customer</code> entity and the previous one is the addition of the <code class="literal">orders</code> field and related getter and setter methods. Of special interest is the <code class="literal">@OneToMany</code> annotation<a id="id285" class="indexterm"/> decorating this field. The <code class="literal">mappedBy</code> attribute must match the name of the corresponding<a id="id286" class="indexterm"/> field in the entity corresponding to the "many" part of the relationship. In simple terms, the value of the <code class="literal">mappedBy</code> attribute must match the name of the field decorated with the <code class="literal">@ManyToOne</code> annotation in<a id="id287" class="indexterm"/> the bean at the other side of the relationship.</p><p>The following example code illustrates how to persist one-to-many relationships to the database:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.namedbean;

import javax.annotation.Resource;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.HeuristicMixedException;
import javax.transaction.HeuristicRollbackException;
import javax.transaction.NotSupportedException;
import javax.transaction.RollbackException;
import javax.transaction.SystemException;
import javax.transaction.UserTransaction;
import net.ensode.glassfishbook.entityrelationship.entity.Customer;
import net.ensode.glassfishbook.entityrelationship.entity.Order;

@Named
@RequestScoped
public class OneToManyRelationshipDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    public String updateDatabase() {
        String retVal = "confirmation";

        Customer customer;
        Order order1;
        Order order2;

        order1 = new Order();
        order1.setOrderId(1L);
        order1.setOrderNumber("SFX12345");
        order1.setOrderDescription("Dummy order.");

        order2 = new Order();
        order2.setOrderId(2L);
        order2.setOrderNumber("SFX23456");
        order2.setOrderDescription("Another dummy order.");

        try {
            userTransaction.begin();

            customer = entityManager.find(Customer.class, 4L);

            order1.setCustomer(customer);
            order2.setCustomer(customer);

            entityManager.persist(order1);
            entityManager.persist(order2);

            userTransaction.commit();

        } catch (NotSupportedException |
                SystemException |
                SecurityException |
                IllegalStateException |
                RollbackException |
                HeuristicMixedException |
                HeuristicRollbackException e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }
}</pre></div><p>The preceding code is pretty similar to the previous example. It instantiates two instances of the <code class="literal">Order</code> entity, <a id="id288" class="indexterm"/>populates them with some data; then, an instance of the <code class="literal">Customer</code> entity is located in a transaction and used as the parameter of the <code class="literal">setCustomer()</code> method<a id="id289" class="indexterm"/> of both instances of the <code class="literal">Order</code> entity. We then persist both <code class="literal">Order</code> entities by invoking <code class="literal">EntityManager.persist()</code> for each one of them.</p><p>Just as when dealing<a id="id290" class="indexterm"/> with one-to-one relationships, behind the scenes, the <code class="literal">CUSTOMER_ID</code> column of the <code class="literal">ORDERS</code> table in the <code class="literal">CUSTOMERDB</code> database is populated with the primary key corresponding to the related row in the <code class="literal">CUSTOMERS</code> table.</p><p>Since the relationship is bidirectional, we can obtain all orders related to a customer by invoking the <code class="literal">getOrders()</code> method<a id="id291" class="indexterm"/> on the <code class="literal">Customer</code> entity.</p></div><div class="section" title="Many-to-many relationships"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec13"/>Many-to-many relationships</h3></div></div></div><p>In the <code class="literal">CUSTOMERDB</code> database, there is a many-to-many relationship between the <code class="literal">ORDERS</code> table and the <code class="literal">ITEMS</code> table. We can map<a id="id292" class="indexterm"/> this relationship by adding a new <code class="literal">Collection&lt;Item&gt;</code> field to the <code class="literal">Order</code> entity and decorating it with<a id="id293" class="indexterm"/> the <code class="literal">@ManyToMany</code> annotation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import java.util.Collection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "ORDERS")
public class Order
{
  @Id
  @Column(name = "ORDER_ID")
  private Long orderId;

  @Column(name = "ORDER_NUMBER")
  private String orderNumber;

  @Column(name = "ORDER_DESCRIPTION")
  private String orderDescription;

  @ManyToOne
  @JoinColumn(name = "CUSTOMER_ID")
  private Customer customer;

<span class="strong"><strong>  @ManyToMany</strong></span>
<span class="strong"><strong>  @JoinTable(name = "ORDER_ITEMS", </strong></span>
<span class="strong"><strong>      joinColumns = @JoinColumn(name = "ORDER_ID", </strong></span>
<span class="strong"><strong>          referencedColumnName = "ORDER_ID"), </strong></span>
<span class="strong"><strong>          inverseJoinColumns = @JoinColumn(name = "ITEM_ID", </strong></span>
<span class="strong"><strong>              referencedColumnName = "ITEM_ID"))</strong></span>
<span class="strong"><strong>  private Collection&lt;Item&gt; items;</strong></span>

  public Customer getCustomer()
  {
    return customer;
  }

  public void setCustomer(Customer customer)
  {
    this.customer = customer;
  }

  public String getOrderDescription()
  {
    return orderDescription;
  }

  public void setOrderDescription(String orderDescription)
  {
    this.orderDescription = orderDescription;
  }

  public Long getOrderId()
  {
    return orderId;
  }

  public void setOrderId(Long orderId)
  {
    this.orderId = orderId;
  }

  public String getOrderNumber()
  {
    return orderNumber;
  }

  public void setOrderNumber(String orderNumber)
  {
    this.orderNumber = orderNumber;
  }

<span class="strong"><strong>  public Collection&lt;Item&gt; getItems()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return items;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public void setItems(Collection&lt;Item&gt; items)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    this.items = items;</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>As we can see in the preceding code, in addition to being decorated with the <code class="literal">@ManyToMany</code> annotation, the <code class="literal">items</code> field is also decorated with the <code class="literal">@JoinTable</code> annotation. As its name suggests, this annotation lets the application server know what table is used as a join table to create the many-to-many relationship between the two entities. This annotation <a id="id294" class="indexterm"/>has three relevant elements: the <code class="literal">name</code> element, which defines the name of the join table, and the <code class="literal">joinColumns</code> and <code class="literal">inverseJoinColumns</code> elements, which define the columns that serve as foreign keys in the join table pointing to the entities' primary keys. <a id="id295" class="indexterm"/>Values for the <code class="literal">joinColumns</code> and <code class="literal">inverseJoinColumns</code> elements are yet another annotation, the <code class="literal">@JoinColumn</code> annotation<a id="id296" class="indexterm"/>. This annotation has two relevant elements: the <code class="literal">name</code> element, which defines the name of the column in the join table, and the <code class="literal">referencedColumnName</code> element, which defines the name of the column in the entity table.</p><p>The <code class="literal">Item</code> entity is a simple entity mapping to the <code class="literal">ITEMS</code> table in the <code class="literal">CUSTOMERDB</code> database, as shown in the<a id="id297" class="indexterm"/> following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.entity;

import java.util.Collection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

@Entity
@Table(name = "ITEMS")
public class Item
{
  @Id
  @Column(name = "ITEM_ID")
  private Long itemId;

  @Column(name = "ITEM_NUMBER")
  private String itemNumber;

  @Column(name = "ITEM_SHORT_DESC")
  private String itemShortDesc;

  @Column(name = "ITEM_LONG_DESC")
  private String itemLongDesc;

<span class="strong"><strong>  @ManyToMany(mappedBy="items")</strong></span>
<span class="strong"><strong>  private Collection&lt;Order&gt; orders;</strong></span>

  public Long getItemId()
  {
    return itemId;
  }

  public void setItemId(Long itemId)
  {
    this.itemId = itemId;
  }

  public String getItemLongDesc()
  {
    return itemLongDesc;
  }

  public void setItemLongDesc(String itemLongDesc)
  {
    this.itemLongDesc = itemLongDesc;
  }

  public String getItemNumber()
  {
    return itemNumber;
  }

  public void setItemNumber(String itemNumber)
  {
    this.itemNumber = itemNumber;
  }

  public String getItemShortDesc()
  {
    return itemShortDesc;
  }

  public void setItemShortDesc(String itemShortDesc)
  {
    this.itemShortDesc = itemShortDesc;
  }

<span class="strong"><strong>  public Collection&lt;Order&gt; getOrders()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    return orders;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public void setOrders(Collection&lt;Order&gt; orders)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    this.orders = orders;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>}</strong></span>
</pre></div><p>Just like one-to-one and one-to-many relationships, many-to-many relationships can be unidirectional<a id="id298" class="indexterm"/> or bidirectional. Since we would like the many-to-many relationship between the <code class="literal">Order</code> and <code class="literal">Item</code> entities to be bidirectional, we added a <code class="literal">Collection&lt;Order&gt;</code> field and decorated it with the <code class="literal">@ManyToMany </code>annotation. Since the corresponding field in the <code class="literal">Order</code> entity already has the join table defined, it is not necessary to do it again<a id="id299" class="indexterm"/> here. The entity containing the <code class="literal">@JoinTable </code>annotation is said to own the relationship. In a many-to-many relationship, either entity can own the relationship. In our example, the <code class="literal">Order</code> entity owns it, since its <code class="literal">Collection&lt;Item&gt;</code> field is decorated with the <code class="literal">@JoinTable</code> annotation<a id="id300" class="indexterm"/>.</p><p>Just as with the one-to-one and one-to-many relationships, the<a id="id301" class="indexterm"/> <code class="literal">@ManyToMany</code> annotation in the non-owning side of a bidirectional many-to-many relationship must contain a <code class="literal">mappedBy</code> element indicating what field in the owning entity defines the relationship.</p><p>Now that we have<a id="id302" class="indexterm"/> seen the changes necessary<a id="id303" class="indexterm"/> to establish a bidirectional many-to-many relationship between the <code class="literal">Order</code> and <code class="literal">Item</code> entities, we can see the relationship in action in the following example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.entityrelationship.namedbean;

import java.util.ArrayList;
import java.util.Collection;
import javax.annotation.Resource;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.HeuristicMixedException;
import javax.transaction.HeuristicRollbackException;
import javax.transaction.NotSupportedException;
import javax.transaction.RollbackException;
import javax.transaction.SystemException;
import javax.transaction.UserTransaction;
import net.ensode.glassfishbook.entityrelationship.entity.Item;
import net.ensode.glassfishbook.entityrelationship.entity.Order;

@Named
@RequestScoped
public class ManyToManyRelationshipDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    public String updateDatabase() {
        String retVal = "confirmation";

        Order order;
        Collection&lt;Item&gt; items = new ArrayList&lt;Item&gt;();
        Item item1 = new Item();
        Item item2 = new Item();

        item1.setItemId(1L);
        item1.setItemNumber("BCD1234");
        item1.setItemShortDesc("Notebook Computer");
        item1.setItemLongDesc("64 bit Quad core CPU, 4GB memory");

        item2.setItemId(2L);
        item2.setItemNumber("CDF2345");
        item2.setItemShortDesc("Cordless Mouse");
        item2.setItemLongDesc("Three button, infrared, "
                + "vertical and horizontal scrollwheels");

        items.add(item1);
        items.add(item2);

        try {
            userTransaction.begin();

<span class="strong"><strong>            entityManager.persist(item1);</strong></span>
<span class="strong"><strong>            entityManager.persist(item2);</strong></span>

<span class="strong"><strong>            order = entityManager.find(Order.class, 1L);</strong></span>
<span class="strong"><strong>            order.setItems(items);</strong></span>

<span class="strong"><strong>            entityManager.persist(order);</strong></span>

            userTransaction.commit();

        } catch (NotSupportedException |
                SystemException |
                SecurityException |
                IllegalStateException |
                RollbackException |
                HeuristicMixedException |
                HeuristicRollbackException e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }
}</pre></div><p>The preceding code creates two instances of the <code class="literal">Item</code> entity and populates them with some data. It then adds these two instances to a collection. A transaction is then started. The two <code class="literal">Item</code> instances<a id="id304" class="indexterm"/> are persisted to the database. Then, an instance of the <code class="literal">Order</code> entity is retrieved from the database. The <code class="literal">setItems()</code> method<a id="id305" class="indexterm"/> of the <code class="literal">Order</code> entity instance is then invoked, passing the collection containing the two <code class="literal">Item</code> instances as a parameter. The <code class="literal">Customer</code> instance is then persisted into<a id="id306" class="indexterm"/> the database. At this<a id="id307" class="indexterm"/> point, two rows are created behind the scenes in the <code class="literal">ORDER_ITEMS</code> table, which is the join table between the <code class="literal">ORDERS</code> and <code class="literal">ITEMS</code> tables.</p></div></div><div class="section" title="Composite primary keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Composite primary keys</h2></div></div></div><p>Most tables in the <code class="literal">CUSTOMERDB</code> database have a column that exists for the sole purpose of serving as a primary key (this type of primary key is sometimes referred to as a surrogate primary key or as an artificial primary key). However, some databases are not designed this way; instead, a column<a id="id308" class="indexterm"/> in the database that is known to be unique across rows is used as the primary key. If there is no column whose value is not guaranteed to be unique across rows, then a combination of two or more columns is used as the table's primary key. It is possible to map this kind of primary key to JPA entities using a primary<a id="id309" class="indexterm"/> key class.</p><p>There is one table in the <code class="literal">CUSTOMERDB</code> database that does not have a surrogate primary key; this table is the <code class="literal">ORDER_ITEMS</code> table. This table serves as a join table between the <code class="literal">ORDERS</code> table and the <code class="literal">ITEMS</code> table. In addition to having foreign keys for these two tables, the <code class="literal">ORDER_ITEMS</code> table has an additional column called <code class="literal">ITEM_QTY</code> that stores the quantity of each item in an order. Since this table does not have a surrogate primary key, the JPA entity mapping to it must have a custom primary key class. In this table, the combination of the <code class="literal">ORDER_ID</code> and <code class="literal">ITEM_ID</code> columns must be unique. Therefore, this is a good combination for a composite primary key, as shown in the following code example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.compositeprimarykeys.entity;

import java.io.Serializable;

public class OrderItemPK implements Serializable
{
  public Long orderId;
  public Long itemId;

  public OrderItemPK()
  {

  }

  public OrderItemPK(Long orderId, Long itemId)
  {
    this.orderId = orderId;
    this.itemId = itemId;
  }

  @Override
  public boolean equals(Object obj)
  {
    boolean returnVal = false;

    if (obj == null)
    {
      returnVal = false;
    }
    else if (!obj.getClass().equals(this.getClass()))
    {
      returnVal = false;
    }
    else
    {
      OrderItemPK other = (OrderItemPK) obj;

      if (this == other)
      {
        returnVal = true;
      }
      else if (orderId != null &amp;&amp; other.orderId != null
          &amp;&amp; this.orderId.equals(other.orderId))
      {
        if (itemId != null &amp;&amp; other.itemId != null
            &amp;&amp; itemId.equals(other.itemId))
        {
          returnVal = true;
        }
      }
      else
      {
        returnVal = false;
      }
    }

    return returnVal;
  }

  @Override
  public int hashCode()
  {
    if (orderId == null || itemId == null)
    {
      return 0;
    }
    else
    {
      return orderId.hashCode() ^ itemId.hashCode();
    }
  }
}</pre></div><p>A custom primary key class must satisfy the following requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The class must be <code class="literal">public</code></li><li class="listitem" style="list-style-type: disc">It must implement <code class="literal">java.io.Serializable</code></li><li class="listitem" style="list-style-type: disc">It must have<a id="id310" class="indexterm"/> a <code class="literal">public</code> constructor that takes no arguments</li><li class="listitem" style="list-style-type: disc">Its fields must be <code class="literal">public</code> or <code class="literal">protected</code></li><li class="listitem" style="list-style-type: disc">Its field names and types must match those of the entity</li><li class="listitem" style="list-style-type: disc">It must override the default <code class="literal">hashCode()</code> and <code class="literal">equals()</code> methods defined in the <code class="literal">java.lang.Object</code> class</li></ul></div><p>The <code class="literal">OrderItemPK</code> class<a id="id311" class="indexterm"/> in the preceding code meets all of these requirements. It also has a convenient constructor that takes two <code class="literal">Long</code> objects meant to initialize its <code class="literal">orderId</code> and <code class="literal">itemId</code> fields. This constructor was added for convenience and is not a requirement for the class to be used as a primary key class.</p><p>When an entity uses a custom primary key class, it must be decorated with the <code class="literal">@IdClass</code> annotation. Since the <code class="literal">OrderItem</code> class uses <code class="literal">OrderItemPK</code> as its custom primary key class, it must be decorated with the said annotation, as shown in the following code example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.compositeprimarykeys.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Table;

@Entity
@Table(name = "ORDER_ITEMS")
<span class="strong"><strong>@IdClass(value = OrderItemPK.class)</strong></span>
public class OrderItem
{
<span class="strong"><strong>  @Id</strong></span>
  @Column(name = "ORDER_ID")
  private Long orderId;

<span class="strong"><strong>  @Id</strong></span>
  @Column(name = "ITEM_ID")
  private Long itemId;

  @Column(name = "ITEM_QTY")
  private Long itemQty;

  public Long getItemId()
  {
    return itemId;
  }

  public void setItemId(Long itemId)
  {
    this.itemId = itemId;
  }

  public Long getItemQty()
  {
    return itemQty;
  }

  public void setItemQty(Long itemQty)
  {
    this.itemQty = itemQty;
  }

  public Long getOrderId()
  {
    return orderId;
  }

  public void setOrderId(Long orderId)
  {
    this.orderId = orderId;
  }
}</pre></div><p>There are two differences between this entity and entities we have seen previously. The first difference is that this entity is decorated with the <code class="literal">@IdClass</code> annotation<a id="id312" class="indexterm"/>, indicating the primary key class corresponding to it. The second difference is that this entity has more than one field decorated with the <code class="literal">@Id</code> annotation. Since this entity has a composite primary key, each<a id="id313" class="indexterm"/> field that is part of the primary key must be decorated with this annotation.</p><p>Obtaining a reference of an entity with a composite primary key is not very different from obtaining a reference to an entity with a primary key consisting of a single field. The following example demonstrates how to do this:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.compositeprimarykeys.namedbean;

import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import net.ensode.glassfishbook.compositeprimarykeys.entity.OrderItem;
import net.ensode.glassfishbook.compositeprimarykeys.entity.OrderItemPK;

@Named
@RequestScoped
public class CompositePrimaryKeyDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    private OrderItem orderItem;

    public String findOrderItem() {
        String retVal = "confirmation";

        try {
<span class="strong"><strong>            orderItem = entityManager.find(OrderItem.class, new OrderItemPK(1L, 2L));</strong></span>
        } catch (Exception e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }

    public OrderItem getOrderItem() {
        return orderItem;
    }

    public void setOrderItem(OrderItem orderItem) {
        this.orderItem = orderItem;
    }

}</pre></div><p>As can be<a id="id314" class="indexterm"/> seen in this example, the only difference between locating an entity with a composite primary key and an entity with a primary key consisting of a single field is that an instance of the custom primary key class must be passed as the second argument of the <code class="literal">EntityManager.find()</code> method<a id="id315" class="indexterm"/>; fields for this instance must be populated with the appropriate values for each field that is part of the primary key.</p></div><div class="section" title="Introducing the Java Persistence Query Language"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Introducing the Java Persistence Query Language</h2></div></div></div><p>All of our examples that obtain entities from the database so far have conveniently assumed that the primary key for the<a id="id316" class="indexterm"/> entity is known ahead of time. We all know that, frequently, this is not the case. Whenever we need to search for an entity by a field other than the entity's primary key, we must use the <span class="strong"><strong>Java Persistence Query Language</strong></span> (<span class="strong"><strong>JPQL</strong></span>).</p><p>JPQL is a SQL-like <a id="id317" class="indexterm"/>language used for retrieving, updating, and deleting entities in a database. The following example illustrates how to use JPQL to retrieve a subset of states from the <code class="literal">US_STATES</code> table in the <code class="literal">CUSTOMERDB</code> database:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jpql.namedbean;

import java.util.List;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import net.ensode.glassfishbook.jpql.entity.UsState;

@Named
@RequestScoped
public class SelectQueryDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    private List&lt;UsState&gt; matchingStatesList;

    public String findStates() {
        String retVal = "confirmation";

        try {
<span class="strong"><strong>            Query query = entityManager</strong></span>
<span class="strong"><strong>                    .createQuery(</strong></span>
<span class="strong"><strong>                    "SELECT s FROM UsState s WHERE s.usStateNm "</strong></span>
<span class="strong"><strong>                    + "LIKE :name");</strong></span>
<span class="strong"><strong>            query.setParameter("name", "New%");</strong></span>
<span class="strong"><strong>            matchingStatesList = query.getResultList();</strong></span>
        } catch (Exception e) {
            retVal = "error";
            e.printStackTrace();
        }
        return retVal;
    }

    public List&lt;UsState&gt; getMatchingStatesList() {
        return matchingStatesList;
    }

    public void setMatchingStatesList(List&lt;UsState&gt; matchingStatesList) {
        this.matchingStatesList = matchingStatesList;
    }

}</pre></div><p>The preceding code invokes the <code class="literal">EntityManager.createQuery()</code> method<a id="id318" class="indexterm"/>, passing a string containing a JPQL query as a parameter. This method returns an instance of <code class="literal">javax.persistence.Query</code>. The query retrieves all <code class="literal">UsState</code> entities whose names start with the string <code class="literal">"New"</code>.</p><p>As can be<a id="id319" class="indexterm"/> seen in the preceding code, JPQL is similar to SQL. However there are some differences that may confuse readers with SQL knowledge. The equivalent SQL code for the query in the code will be:</p><div class="informalexample"><pre class="programlisting">SELECT * from US_STATES s where s.US_STATE_NM like 'New%'</pre></div><p>The first difference between JPQL and SQL is that in JPQL, we always use entity names, whereas in SQL table names are used. The <code class="literal">s</code> after the entity name in the JPQL query is an alias for the entity. Table aliases are optional in SQL, but entity aliases are required in JPQL. Keeping these differences in mind, the JPQL query should now be a lot less confusing.</p><p>The <code class="literal">:name</code> parameter<a id="id320" class="indexterm"/> in the query is a named <a id="id321" class="indexterm"/>parameter; named parameters are meant to be substituted with actual values. This is done by invoking the <code class="literal">setParameter()</code> method<a id="id322" class="indexterm"/> in the instance of <code class="literal">javax.persistence.Query</code> returned by the call to <code class="literal">EntityManager.createQuery()</code>. A JPQL query can have multiple named parameters.</p><p>To actually run the query and retrieve the entities from the database, the <code class="literal">getResultList()</code> method<a id="id323" class="indexterm"/> must be invoked in the instance of <code class="literal">javax.persistence.Query</code> obtained from <code class="literal">EntityManager.createQuery()</code>. This method returns an instance of a class implementing the <code class="literal">java.util.List</code> interface. This list contains the entities matching the query criteria. If no entities match the criteria, then an empty list is returned.</p><p>If we are certain that the query will return exactly one entity, then the <code class="literal">getSingleResult()</code> method<a id="id324" class="indexterm"/> may be alternatively called on <code class="literal">Query</code>; this method returns an object that must be cast to the appropriate entity.</p><p>Our example uses the <code class="literal">LIKE</code> operator to find entities whose names start with the string <code class="literal">"New"</code>. This is accomplished by substituting the query's named parameter with the value <code class="literal">"New%"</code>. The percent sign at the end of the parameter value means that any number of characters after the word <code class="literal">"New"</code> will match the expression. The percent sign can be used anywhere in the parameter value; for example, a value of <code class="literal">"%Dakota"</code> would match any entities whose name end in <code class="literal">"Dakota"</code> and a value of <code class="literal">"A%a"</code> would match any states whose name start with an uppercase <code class="literal">"A"</code> and end with a lowercase <code class="literal">"a"</code>. There can be more than one percent sign in a parameter value. The underscore sign (<code class="literal">_</code>) can be used to match a single character; all the rules for the percent sign apply to the underscore as well.</p><p>In addition to the <code class="literal">LIKE</code> operator, there are other operators that can be used to retrieve entities from the <a id="id325" class="indexterm"/>database, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">=</code> operator<a id="id326" class="indexterm"/> will retrieve entities whose field to the left of the operator exactly match the value to the right of the operator</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&gt;</code> operator<a id="id327" class="indexterm"/> will retrieve entities whose field to the left of the operator is greater than the value to the right of the operator</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;</code> operator<a id="id328" class="indexterm"/> will retrieve entities whose field to the left of the operator is less than the value to the right of the operator</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&gt;=</code> operator<a id="id329" class="indexterm"/> will retrieve entities whose field to the left of the operator is greater than, or equal to, the value to the right of the operator</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;=</code> operator<a id="id330" class="indexterm"/> will retrieve entities whose field to the left of the operator is less than, or equal to, the value to the right of the operator</li></ul></div><p>All of the preceding operators work the same way as the equivalent operators in SQL. Just as in SQL, the preceding operators can be combined with the <code class="literal">AND</code> and <code class="literal">OR</code> operators. Conditions combined with the <code class="literal">AND</code> operator match if both conditions are true, and conditions combined with the <code class="literal">OR</code> operator match if at least one of the conditions are true.</p><p>If we intend to use a query<a id="id331" class="indexterm"/> many times, it can be stored in a named query. Named queries can be defined by decorating the relevant entity class with the <code class="literal">@NamedQuery</code> annotation<a id="id332" class="indexterm"/>. This annotation has two elements, a name element used to set the name of the query and a query element that defines the query itself. To execute a named query, the <code class="literal">createNamedQuery()</code> method<a id="id333" class="indexterm"/> must be invoked in an instance of <code class="literal">EntityManager</code>. This method takes a string of type <code class="literal">String</code> containing the query name as its sole parameter and returns an instance of <code class="literal">javax.persistence.Query</code>.</p><p>In addition to retrieving entities, JPQL can be used to modify or delete entities. However, entity modification and deletion can be done programmatically via the <code class="literal">EntityManager</code> interface too; doing so results in code that tends to be more readable than when using JPQL. Because of this, we will not cover entity modification and deletion via JPQL. Readers interested in writing JPQL queries to modify and delete entities, as well as readers wishing to know more about JPQL are encouraged to review the Java Persistence 2.1 specification. This specification can be downloaded from <a class="ulink" href="http://jcp.org/en/jsr/detail?id=338">http://jcp.org/en/jsr/detail?id=338</a>.</p></div><div class="section" title="Introducing the Criteria API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Introducing the Criteria API</h2></div></div></div><p>One of the main additions to JPA in Version 2.0 was the introduction of the Criteria API. The Criteria API is meant as a complement to the JPQL.</p><p>Although<a id="id334" class="indexterm"/> JPQL is very flexible, it has some problems that make working with it more difficult than necessary. For starters, JPQL queries are stored as strings, and the compiler has no way of validating JPQL syntax. Additionally, JPQL is not type safe; we could write a JPQL query in which our <code class="literal">where</code> clause could have a string value for a numeric property and our code would compile and deploy just fine.</p><p>To get around the<a id="id335" class="indexterm"/> JPQL limitations described in the previous paragraph, the Criteria API was introduced in JPA in Version 2.0 of the specification. The Criteria API allows us to write JPA queries programmatically, without having to rely on JPQL.</p><p>The following code example<a id="id336" class="indexterm"/> illustrates how to use the Criteria API in our Java EE applications:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.criteriaapi.namedbean;

import java.util.List;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.EntityType;
import javax.persistence.metamodel.Metamodel;
import javax.persistence.metamodel.SingularAttribute;
import net.ensode.glassfishbook.criteriaapi.entity.UsState;

@Named
@RequestScoped
public class CriteriaApiDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    private List&lt;UsState&gt; matchingStatesList;

    public String findStates() {
        String retVal = "confirmation";
        try {
<span class="strong"><strong>            CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();</strong></span>
<span class="strong"><strong>            CriteriaQuery&lt;UsState&gt; criteriaQuery = criteriaBuilder.</strong></span>
<span class="strong"><strong>                    createQuery(UsState.class);</strong></span>
<span class="strong"><strong>            Root&lt;UsState&gt; root = criteriaQuery.from(UsState.class);</strong></span>

<span class="strong"><strong>            Metamodel metamodel = entityManager.getMetamodel();</strong></span>
<span class="strong"><strong>            EntityType&lt;UsState&gt; usStateEntityType = metamodel.entity(</strong></span>
<span class="strong"><strong>                    UsState.class);</strong></span>
<span class="strong"><strong>            SingularAttribute&lt;UsState, String&gt; usStateAttribute</strong></span>
<span class="strong"><strong>                    =</strong></span>
<span class="strong"><strong>                  usStateEntityType.getDeclaredSingularAttribute(</strong></span>
<span class="strong"><strong>                    "usStateNm",</strong></span>
<span class="strong"><strong>                    String.class);</strong></span>
<span class="strong"><strong>            Path&lt;String&gt; path = root.get(usStateAttribute);</strong></span>
<span class="strong"><strong>            Predicate predicate = criteriaBuilder.like(</strong></span>
<span class="strong"><strong>                    path, "New%");</strong></span>
<span class="strong"><strong>            criteriaQuery = criteriaQuery.where(predicate);</strong></span>

<span class="strong"><strong>            TypedQuery typedQuery = entityManager.createQuery(</strong></span>
<span class="strong"><strong>                    criteriaQuery);</strong></span>

<span class="strong"><strong>            matchingStatesList = typedQuery.getResultList();</strong></span>

        } catch (Exception e) {
            retVal = "error";
            e.printStackTrace();
        }

        return retVal;
    }

    public List&lt;UsState&gt; getMatchingStatesList() {
        return matchingStatesList;
    }

    public void setMatchingStatesList(List&lt;UsState&gt; matchingStatesList) {
        this.matchingStatesList = matchingStatesList;
    }

}</pre></div><p>This example is equivalent to the JPQL example we saw earlier in this chapter. This example, however, takes advantage of the Criteria API instead of relying on JPQL.</p><p>When writing code using the Criteria API, the first thing we need to do is obtain an instance of a class implementing the <code class="literal">javax.persistence.criteria.CriteriaBuilder</code> interface. As we can see in our example, we need to obtain <a id="id337" class="indexterm"/>the said instance by invoking the <code class="literal">getCriteriaBuilder()</code> method<a id="id338" class="indexterm"/> on our <code class="literal">EntityManager</code> instance.</p><p>From our <code class="literal">CriteriaBuilder</code> implementation, we need to obtain an instance of a class implementing the <code class="literal">javax.persistence.criteria.CriteriaQuery</code> interface. We do this by invoking the <code class="literal">createQuery()</code> method in our <code class="literal">CriteriaBuilder</code> implementation. Note that <code class="literal">CriteriaQuery</code> is generically typed. The generic type argument dictates the type of result that our <code class="literal">CriteriaQuery</code> implementation will return upon execution. By taking advantage of generics in this way, the Criteria API allows us to write type-safe code.</p><p>Once we have obtained a <code class="literal">CriteriaQuery</code> implementation, from it we can obtain an instance of a class implementing the <code class="literal">javax.persistence.criteria.Root</code> interface. The <code class="literal">Root</code> implementation dictates what JPA Entity we will be querying from. It is analogous to the <code class="literal">FROM</code> query in JPQL (and SQL).</p><p>The next two lines in our example take advantage of another new addition to the JPA specification, the <span class="strong"><strong>Metamodel API</strong></span>.<a id="id339" class="indexterm"/> In order to take advantage of the Metamodel API, we need to obtain an implementation of the <code class="literal">javax.persistence.metamodel.Metamodel</code> interface by invoking the <code class="literal">getMetamodel()</code> method on our <code class="literal">EntityManager</code> instance.</p><p>From our <code class="literal">Metamodel</code> implementation, we can obtain a generically typed instance of the <code class="literal">javax.persistence.metamodel.EntityType</code> interface. The generic type argument indicates the JPA entity our <code class="literal">EntityType</code> implementation corresponds to. The <code class="literal">EntityType</code> interface implementation allows us to browse the persistent attributes of our JPA entities at runtime,<a id="id340" class="indexterm"/> which is exactly what we do in the next line in our example. In our case, we are getting an instance of <code class="literal">SingularAttribute</code>, which maps to a simple, singular attribute in our JPA entity. The <code class="literal">EntityType</code> interface implementation has methods to obtain attributes that map to collections, sets, lists, and maps. Obtaining these types of attributes is very similar to obtaining <code class="literal">SingularAttribute</code>; therefore, we won't be covering those in depth. Please refer to the Java EE 7 API documentation at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/">http://docs.oracle.com/javaee/7/api/</a> for more information.</p><p>As we can see in our example, <code class="literal">SingularAttribute</code> contains two generic type arguments. The first argument dictates the JPA entity we are working with, and the second one indicates the type of the attribute. We obtain our <code class="literal">SingularAttribute</code> implementation by invoking the <code class="literal">getDeclaredSingularAttribute()</code> method<a id="id341" class="indexterm"/> on our <code class="literal">EntityType</code> interface implementation and passing the attribute name (as declared in our JPA entity) as a string.</p><p>Once we have obtained our <code class="literal">SingularAttribute</code> implementation, we need to obtain a <code class="literal">javax.persistence.criteria.Path</code> implementation by invoking the <code class="literal">get()</code> method in our <code class="literal">Root</code> instance and passing <code class="literal">SingularAttribute</code> as a parameter.</p><p>In our example, we will get a list of all the states in the United States whose names start with the string <code class="literal">"New"</code>. This, of course, is a job for the <code class="literal">like</code> condition. We can do this with the criteria API by invoking the <code class="literal">like()</code> method on our <code class="literal">CriteriaBuilder</code> implementation. The <code class="literal">like()</code> method takes our <code class="literal">Path</code> implementation as its first parameter and the value to search for as its second parameter.</p><p>The <code class="literal">CriteriaBuilder</code> interface implementation has a number of methods that are analogous to SQL and JPQL clauses such as <code class="literal">equals()</code>, <code class="literal">greaterThan()</code>, <code class="literal">lessThan()</code>, <code class="literal">and()</code>, <code class="literal">or()</code>, and so on and so forth (for the complete list, refer to the Java EE 7 documentation at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/">http://docs.oracle.com/javaee/7/api/</a>). These methods can be combined to create complex queries via the Criteria API.</p><p>The <code class="literal">like()</code> method<a id="id342" class="indexterm"/> in <code class="literal">CriteriaBuilder</code> returns an implementation of the <code class="literal">javax.persistence.criteria.Predicate</code> interface, which we need to pass to the <code class="literal">where()</code> method in our <code class="literal">CriteriaQuery</code> implementation. This method returns a new instance of <code class="literal">CriteriaBuilder</code>, which we assign to our <code class="literal">CriteriaBuilder</code> variable.</p><p>At this point, we are ready to build our query. When working with the Criteria API, we deal with the <code class="literal">javax.persistence.TypedQuery</code> interface, which can be thought of as a type-safe version of the <code class="literal">Query</code> interface we use with JPQL. We obtain an instance of <code class="literal">TypedQuery</code> by invoking the <code class="literal">createQuery()</code> method in <code class="literal">EntityManager</code> and passing our <code class="literal">CriteriaQuery</code> implementation as a parameter.</p><p>To obtain our query results<a id="id343" class="indexterm"/> as a list, we simply invoke <code class="literal">getResultList()</code> on our <code class="literal">TypedQuery</code> implementation. It is worth reiterating that the Criteria API is type safe; therefore, attempting to assign the results of <code class="literal">getResultList()</code> to a list of the wrong type would result in a compilation error.</p><div class="section" title="Updating data with the Criteria API"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec14"/>Updating data with the Criteria API</h3></div></div></div><p>When the JPA Criteria API <a id="id344" class="indexterm"/>was initially added to JPA 2.0, it only supported selecting data from the database. Modifying existing data was not supported.</p><p>JPA 2.1, introduced in <a id="id345" class="indexterm"/>Java EE 7, adds support for updating database data via the <code class="literal">CriteriaUpdate</code> interface; the following example illustrates how to use it:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.criteriaupdate.namedbean;

//imports omitted for brevity

@Named
@RequestScoped
public class CriteriaUpdateDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    private int updatedRows;

    public String updateData() {
        String retVal = "confirmation";

        try {

            userTransaction.begin();
            insertTempData();

<span class="strong"><strong>            CriteriaBuilder criteriaBuilder =</strong></span>
<span class="strong"><strong>                entityManager.getCriteriaBuilder();</strong></span>
<span class="strong"><strong>            CriteriaUpdate&lt;Address&gt; criteriaUpdate = criteriaBuilder.createCriteriaUpdate(Address.class);</strong></span>
<span class="strong"><strong>            Root&lt;Address&gt; root = criteriaUpdate.from(Address.class);</strong></span>
<span class="strong"><strong>            criteriaUpdate.set("city", "New York");</strong></span>
<span class="strong"><strong>            criteriaUpdate.where(criteriaBuilder.equal(</strong></span>
<span class="strong"><strong>              root.get("city"), "New Yorc"));</strong></span>

<span class="strong"><strong>            Query query = entityManager.createQuery(criteriaUpdate);</strong></span>

<span class="strong"><strong>            updatedRows = query.executeUpdate();</strong></span>
            userTransaction.commit();
        } catch (Exception e) {
            retVal = "error";
            e.printStackTrace();
        }
        return retVal;
    }

    public int getUpdatedRows() {
        return updatedRows;
    }

    public void setUpdatedRows(int updatedRows) {
        this.updatedRows = updatedRows;
    }

    private void insertTempData() throws NotSupportedException,
            SystemException, RollbackException, HeuristicMixedException,
            HeuristicRollbackException {
      //body omitted since it is not relevant to the discussion at hand
      //full source code available as part of this book's code download
}</pre></div><p>What this example is actually<a id="id346" class="indexterm"/> doing is finding all of the<a id="id347" class="indexterm"/> database rows with a city <code class="literal">"New Yorc"</code> (a typo) and replacing the value with the correct spelling, <code class="literal">"New York"</code>.</p><p>Just as in the previous example, we obtain an instance of a class implementing the <code class="literal">CriteriaBuilder</code> interface by invoking the <code class="literal">getCriteriaBuilder()</code> method<a id="id348" class="indexterm"/> on our <code class="literal">EntityManager</code> instance.</p><p>We then obtain an instance of a class implementing <code class="literal">CriteriaUpdate</code> by invoking <code class="literal">createCriteriaUpdate()</code> on our <code class="literal">CriteriaBuilder</code> instance.</p><p>The next step is to obtain an instance of a class implementing <code class="literal">Root</code> by invoking the <code class="literal">from()</code> method on our <code class="literal">CriteriaUpdate</code> instance.</p><p>We then invoke the <code class="literal">set()</code> method<a id="id349" class="indexterm"/> on <code class="literal">CriteriaUpdate</code> to specify the new values our rows will have after they have been updated. The first parameter of the <code class="literal">set()</code> method must be a string matching the property name in the <code class="literal">Entity</code> class, and the second parameter must be the new value.</p><p>At this point, we <a id="id350" class="indexterm"/>build the <code class="literal">where</code> clause by invoking the <code class="literal">where()</code> method on <code class="literal">CriteriaUpdate</code> and passing the <code class="literal">Predicate</code> returned by the <code class="literal">equal()</code> method invoked in <code class="literal">CriteriaBuilder</code>.</p><p>Then, we<a id="id351" class="indexterm"/> get a <code class="literal">Query</code> implementation by invoking <code class="literal">createQuery()</code> on <code class="literal">EntityManager</code> and passing our <code class="literal">CriteriaUpdate</code> instance as a parameter.</p><p>Finally, we execute our query, as usual, by invoking <code class="literal">executeUpdate()</code> on our <code class="literal">Query</code> implementation.</p></div><div class="section" title="Deleting data with the Criteria API"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Deleting data with the Criteria API</h3></div></div></div><p>In addition to adding <a id="id352" class="indexterm"/>support for data update via the Criteria <a id="id353" class="indexterm"/>API, JPA 2.1 added the ability to bulk-delete database rows with the new <code class="literal">CriteriaDelete</code> interface. The following code snippet illustrates its usage:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.criteriadelete.namedbean;

//imports omitted

@Named
@RequestScoped
public class CriteriaDeleteDemoBean {

    @PersistenceContext
    private EntityManager entityManager;

    @Resource
    private UserTransaction userTransaction;

    private int deletedRows;

    public String deleteData() {
        String retVal = "confirmation";

        try {

            userTransaction.begin();

            CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
<span class="strong"><strong>            CriteriaDelete&lt;Address&gt; criteriaDelete = criteriaBuilder.createCriteriaDelete(Address.class);</strong></span>
<span class="strong"><strong>            Root&lt;Address&gt; root = criteriaDelete.from(Address.class);</strong></span>
<span class="strong"><strong>            criteriaDelete.where(criteriaBuilder.or(criteriaBuilder.equal(</strong></span>
<span class="strong"><strong>                    root.get("city"), "New York"),</strong></span>
<span class="strong"><strong>                    criteriaBuilder.equal(root.get("city"), "New York")));</strong></span>

            Query query = entityManager.createQuery(criteriaDelete);

            deletedRows = query.executeUpdate();
            userTransaction.commit();
        } catch (Exception e) {
            retVal = "error";
            e.printStackTrace();
        }
        return retVal;
    }

    public int getDeletedRows() {
        return deletedRows;
    }

    public void setDeletedRows(int updatedRows) {
        this.deletedRows = updatedRows;
    }
}</pre></div><p>To use<a id="id354" class="indexterm"/> <code class="literal">CriteriaDelete</code>, we first obtain an instance of <code class="literal">CriteriaBuilder</code> as usual, and then invoke the <code class="literal">createCriteriaDelete()</code> method<a id="id355" class="indexterm"/> on our <code class="literal">CriteriaBuilder</code> instance to obtain an<a id="id356" class="indexterm"/> implementation of <code class="literal">CriteriaDelete</code>.</p><p>Once we have an instance of <code class="literal">CriteriaDelete</code>, we build the <code class="literal">where</code> clause as it is usually done with the Criteria API.</p><p>Once we have built our <code class="literal">where</code> clause, we <a id="id357" class="indexterm"/>obtain an implementation of the <code class="literal">Query</code> interface and<a id="id358" class="indexterm"/> invoke <code class="literal">executeUpdate()</code> on it as usual.</p></div></div><div class="section" title="Bean Validation support"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Bean Validation support</h2></div></div></div><p>Another feature introduced in JPA 2.0 is support for JSR 303, Bean Validation. Bean Validation support allows us to annotate our JPA entities with Bean Validation annotations. These<a id="id359" class="indexterm"/> annotations allow us to easily validate user input and perform data sanitation.</p><p>Taking advantage of Bean Validation is very simple. All we need to do is annotate our JPA Entity fields or getter methods with any of the <a id="id360" class="indexterm"/>validation annotations defined in the <code class="literal">javax.validation.constraints</code> package. Once our fields are annotated as needed, the <code class="literal">EntityManager</code> will prevent non-validated data from being persisted.</p><p>The following code example is a modified version of the <code class="literal">Customer</code> JPA entity we saw earlier in this chapter. It has been modified to take advantage of Bean Validation in some of its fields.</p><div class="informalexample"><pre class="programlisting">net.ensode.glassfishbook.beanvalidation.entity;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable
{
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;

  @Column(name = "FIRST_NAME")
<span class="strong"><strong>  @NotNull</strong></span>
<span class="strong"><strong>  @Size(min=2, max=20)</strong></span>
  private String firstName;

  @Column(name = "LAST_NAME")
<span class="strong"><strong>  @NotNull</strong></span>
<span class="strong"><strong>  @Size(min=2, max=20)</strong></span>
  private String lastName;

  private String email;

  public Long getCustomerId()
  {
    return customerId;
  }

  public void setCustomerId(Long customerId)
  {
    this.customerId = customerId;
  }

  public String getEmail()
  {
    return email;
  }

  public void setEmail(String email)
  {
    this.email = email;
  }

  public String getFirstName()
  {
    return firstName;
  }

  public void setFirstName(String firstName)
  {
    this.firstName = firstName;
  }

  public String getLastName()
  {
    return lastName;
  }

  public void setLastName(String lastName)
  {
    this.lastName = lastName;
  }
}</pre></div><p>In this example, we used the <code class="literal">@NotNull</code> annotation<a id="id361" class="indexterm"/> to prevent <code class="literal">firstName</code> and <code class="literal">lastName</code> of our entity from being persisted with <code class="literal">null</code> values. We also used the <code class="literal">@Size</code> annotation to restrict the minimum and maximum length of these fields.</p><p>That is all we need to<a id="id362" class="indexterm"/> do to take advantage of Bean Validation in JPA. If our code attempts to persist or update an instance of our entity that does not pass the declared validation, an exception of type <code class="literal">javax.validation.ConstraintViolationException</code> will be thrown, and the entity will not be persisted.</p><p>As we can see, <a id="id363" class="indexterm"/>Bean Validation pretty much automates data validation, freeing us from having to manually write validation code.</p><p>In addition to the two annotations discussed in the previous example, the <code class="literal">javax.validation.constraints</code> package contains several additional annotations we can use to automate validation on our JPA entities. Please refer to the Java EE 7 API documentation at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/">http://docs.oracle.com/javaee/7/api/</a> for the complete list.</p></div></div>
<div class="section" title="Final notes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Final notes</h1></div></div></div><p>In the examples of this chapter, we showed how a database is accessed directly from CDI named beans serving as controllers. We did this to get the point across without bogging ourselves down with details. In general, accessing the database directly from controllers is not a good practice. <a id="id364" class="indexterm"/>Database access code should be encapsulated in <span class="strong"><strong>Data Access Objects</strong></span> (<span class="strong"><strong>DAOs</strong></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>For more information on the DAO design pattern, see <a class="ulink" href="http://www.oracle.com/technetwork/java/dao-138818.html">http://www.oracle.com/technetwork/java/dao-138818.html</a>.</p></div></div><p>Named beans typically assume the role of controllers and/or models when using the Model-View-Controller (MVC) design pattern: a practice so common that it has become the de facto standard for Java EE applications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>For more information about the MVC design pattern, see <a class="ulink" href="http://www.oracle.com/technetwork/java/mvc-140477.html">http://www.oracle.com/technetwork/java/mvc-140477.html</a>.</p></div></div><p>Additionally, we chose not to show any user interface code in our examples since it is irrelevant to the topic at hand; however, the code downloads for this chapter includes JSF pages that invoke the named beans in this chapter and display a confirmation page once the named bean invocation finishes.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>This chapter covered how to access data in a database via JPA.</p><p>We covered how to mark a Java class as a JPA entity by decorating it with the <code class="literal">@Entity</code> annotation. Additionally, we covered how to map an entity to a database table via the <code class="literal">@Table</code> annotation. We also covered how to map entity fields to database columns via the <code class="literal">@Column</code> annotation, as well as how to declare an entity's primary key via the <code class="literal">@Id</code> annotation.</p><p>Using the <code class="literal">javax.persistence.EntityManager</code> interface to find, persist, and update JPA entities was also covered.</p><p>Defining both unidirectional and bidirectional one-to-one, one-to-many, and many-to-many relationships between JPA entities was covered as well.</p><p>Additionally, we covered how to use JPA composite primary keys by developing custom primary key classes.</p><p>We then went on to cover how to retrieve entities from a database by using the JPQL.</p><p>We discussed additional JPA features, such as the Criteria API, which allows us to build JPA queries programmatically; the Metamodel API, which allows us to take advantage of Java's type safety when working with JPA; and Bean Validation, which allows us to easily validate input by simply annotating our JPA entity fields.</p><p>In the next chapter, we will cover <span class="strong"><strong>Enterprise JavaBeans</strong></span> (<span class="strong"><strong>EJBs</strong></span>).</p></div></body></html>