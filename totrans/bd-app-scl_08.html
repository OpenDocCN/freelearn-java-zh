<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Developing a Chat with Akka" id="aid-2SG6I1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Developing a Chat with Akka</h1></div></div></div><p>In the previous chapters, we persisted data into MySQL using Slick and wrote PDF reports using Jasper reports. Now we will add more features in our app using Akka.</p><p>In this chapter, you will learn how to create Actors using the Akka framework. We will use Actors in combination with the Play framework and WebSockets in order to have a chat capability.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Understanding the Actor model</li><li class="listitem">Actor systems, Actor routing, and dispatchers</li><li class="listitem">Mailboxes, Actor configuration, and persistence</li><li class="listitem">Creating our Chat Application</li><li class="listitem">Testing our Actors</li></ul></div><div class="section" title="Adding the new UI introduction to Akka"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Adding the new UI introduction to Akka</h1></div></div></div><p>Akka (<a class="ulink" href="http://akka.io/">http://akka.io/</a>) is a framework to build concurrent, distributed, and resilient message-driven applications in Scala, Java, and .NET. Building applications with Akka has several advantages, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>High performance</strong></span>: Akka delivers up to 50 million messages per second on a commodity hardware having ~2.5 million Actors per GB of RAM.</li><li class="listitem"><span class="strong"><strong>Resilient by design</strong></span>: Akka systems have self-healing properties for local and remote Actors.</li><li class="listitem"><span class="strong"><strong>Distributed and elastic</strong></span>: Akka has all the mechanisms to scale your application, such as cluster, load balancing, partitioning, and sharding. Akka lets you grow or shrink your Actors on demand.</li></ul></div><p>The Akka framework provides good abstractions for concurrent, asynchronous, and distributed programming, such as Actors, Streams, and Futures. There are plenty of great success cases in production, such as BBC, Amazon, eBay, Cisco, The Guardian, Blizzard, Gilt, HP, HSBC, Netflix, and so many others.</p><p>Akka is a truly reactive framework because everything, in the sense of sending and receiving messages to Actors, is lockless, non-blocking IO, and asynchronous.</p></div></div>
<div class="section" title="Introduction to the Actor model" id="aid-2TEN41"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec90"/>Introduction to the Actor model</h1></div></div></div><p>The key for concurrency programming is to avoid a shared mutable state. A shared state often requires locks and synchronization, which makes your code less concurrent and more complex. Actors share nothing; they have internal state, but they don't share their internal state.</p><p>Actors have location transparency; they can run in a local or remote system and a cluster. It's also possible to mix local and remote actors - this is great for scalability and fits perfectly into a cloud environment. Actors can run anywhere, from your local box, the cloud, bare-metal datacenter, and Linux containers.</p><div class="section" title="What is an Actor?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec101"/>What is an Actor?</h2></div></div></div><p>Actors can be alternatives to threads, callback listeners, singleton services, <span class="strong"><strong>Enterprise Java Beans </strong></span>(<span class="strong"><strong>EJB</strong></span>), routers, load balancer or pool, and a <span class="strong"><strong>finite-state machine</strong></span> (<span class="strong"><strong>FSM</strong></span>). The Actor model concept is not new at all; it was created by Carl Hewitt in 1973. The Actor model is heavily used in the telecom industry in rock-solid technologies such as Erlang. Erlang and the Actor model had immense success with companies such as Ericsson and Facebook.</p><p>Actors have a simple way of working:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Unit of code organization:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Processing</li><li class="listitem">Storage</li><li class="listitem">Communication<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">They manage the internal states</li><li class="listitem">They have a mailbox</li><li class="listitem">They communicate with other actors using messages</li><li class="listitem">They can change the behavior at runtime</li></ul></div><p>
</p></li></ul></div><p>
</p></li></ul></div></div></div>
<div class="section" title="Message exchange and mailboxes" id="aid-2UD7M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec91"/>Message exchange and mailboxes</h1></div></div></div><p>Actors talk with each other via messaging. There are two patterns: one is called ask and the other is called fire and forget. Both methods are asynchronous and non-blocking IO. When an Actor sends a message to another Actor, it does not send the message directly to the other Actor; it actually sends it to the Actor's mailbox.</p><p>Messages are enqueued in the Actor mailbox in a time-ordered fashion. There are different mailboxes implementations in Akka. The default is <span class="strong"><strong>First In First Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) based. This is a good default; however, you might need a different algorithm, which is fine as you can change the mailbox if you need to. More details can be found in the official documentation (<a class="ulink" href="http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala">http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala</a>).
Actors live in an Actor system. You can have multiple Actor systems in a cluster:</p><p>
</p><div class="mediaobject"><img src="../Images/image00313.jpeg" alt="Message exchange and mailboxes"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Akka encapsulates the actor state in mailbox and decouples it from the Actor behavior. The Actor behavior is the code you will have inside your Actor. You will need to see Actors and Akka as a protocol. So, basically, you will need to define how many Actors you will have and what each Actor will do in the sense of code, responsibility, and behavior.
The Actor system has Actors and supervisors. Supervisors are one of the Akka mechanisms to deliver fault tolerance and resiliency. Supervisors take care of the Actor instances, and they can restart, kill, or create more Actors as needed.</p><p>The Actor model is great for concurrency and scalability; however, like every single thing in computer science, there are tradeoffs and cons. For instance, Actors require a new mindset and a different way of thinking.</p><p>There is no silver bullet. Once you have your protocol, it might be hard to reuse your Actors outside your protocol. In general, Actors can be harder to compose, as compared to object-oriented classes or functions in Functional Programming, for instance.</p></div>
<div class="section" title="Coding actors with Akka"><div class="titlepage" id="aid-2VBO82"><div><div><h1 class="title"><a id="ch08lvl1sec92"/>Coding actors with Akka</h1></div></div></div><p>Let's take a look at the following Actor code using the Akka framework and Scala:</p><pre class="programlisting">    import akka.actor._ &#13;
    case object HelloMessage &#13;
    class HelloWorldActor extends Actor { &#13;
      def receive = { &#13;
        case HelloMessage =&gt; sender() ! "Hello World" &#13;
        case a:Any =&gt; sender() ! "I don't know: " + a + " - Sorry!" &#13;
      } &#13;
    } &#13;
    object SimpleActorMainApp extends App{  &#13;
      val system = ActorSystem("SimpleActorSystem") &#13;
      val actor = system.actorOf(Props[HelloWorldActor])  &#13;
      import scala.concurrent.duration._ &#13;
      import akka.util.Timeout &#13;
      import akka.pattern.ask &#13;
      import scala.concurrent.Await &#13;
      implicit val timeout = Timeout(20 seconds)  &#13;
      val future = actor ? HelloMessage &#13;
      val result = Await.result(future, &#13;
      timeout.duration).asInstanceOf[String] &#13;
      println("Actor says: " + result )  &#13;
      val future2 = actor ? "Cobol" &#13;
      val result2 = Await.result(future2, &#13;
      timeout.duration).asInstanceOf[String] &#13;
      println("Actor says: " + result2 )    &#13;
      system.terminate() &#13;
    } &#13;
</pre><p>If you run this Akka code on <code class="literal">sbt</code> in your console, you will see an output similar to this:</p><pre class="programlisting">
<span class="strong"><strong>$ sbt run </strong></span>
</pre><p>
</p><div class="mediaobject"><img src="../Images/image00314.jpeg" alt="Coding actors with Akka"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Let's take a closer look at this Akka code we just wrote, in which we defined a Scala class called <code class="literal">HelloWorldActor</code>. In order for this class be an Actor, we will need to extend Actor. Actors are reactive by default, which means that they are waiting to receive messages to react to the messages. You will need to code your behavior in an event loop. In Akka, this is done by coding the <code class="literal">receive</code> function with a pattern matcher in Scala.</p><p>The pattern matcher will define what the actor can do. You will need to code all the possible kinds of messages you want that actor to handle. As I mentioned earlier, you will need to have a protocol; so your protocol has a message called <code class="literal">HelloMessage</code>. It's a common practice in Akka to use Scala objects as messages. However, you can pass pretty much all types as messages. It's even possible to send case classes with parameters.</p><p>Alright, we have our protocol, which is our Actors, and the messages they can exchange. Now we will need to create an Actor system and start our application. As you can see, we will use the <code class="literal">ActorSystem</code> object to create an Actor system. Actor systems need to have a name, which can be any string you like, as long as it contains any letter [a-z, A-Z, 0-9] and non-leading '-' or '_'.</p><p>After creating the system, you can create Actors. The system has a function called <code class="literal">actorOf</code>, which can be used to create Actors. You will need to use a special object called <code class="literal">Props</code> and pass the <code class="literal">actor</code> class. Why do we need it this way? It's because Akka manages the Actor state. You should not try to manage the Actor instance by yourself. This is dangerous because you can break referential transparency and your code might not work.</p><p>For this code, we are using the ask pattern. We will use this to send messages to the Actor, and we want to know what the Actor will return. Akka does everything in an async and non-blocking way , as mentioned previously. However, sometimes you want to get the answer now and then, unfortunately, you will need to block.</p><p>In order to get the answer now, we will need to define a timeout and use the <code class="literal">Await</code> object. When you send a message to an Actor using <code class="literal">?</code> (the ask pattern), Akka will return a Future for you. Then, you can pass the Future with a timeout to <code class="literal">Await</code>, and if the answer comes back before the timeout, you will have the response from the Actor.</p><p>Again, we are blocking here because we want to get the answer now, and we are outside the Actor system. Keep in mind that when an Actor talks with another Actor inside the Actor system, it should not block ever. So be careful with the usage of <code class="literal">Await</code>.</p><p>Another important thing in this code is that the <code class="literal">sender()</code> method inside of the Actor receives a function. This means that you want to get the reference of the Actor who sends the message to you. As we are performing <code class="literal">sender() !</code> method, we are sending an answer back to the caller. The <code class="literal">sender()</code> function is an Akka abstraction to deal with response messages to other Actors or function callers.</p><p>We also have another case, with <code class="literal">Any</code>, which means all other messages will be handled by that case code.</p><p>The ask pattern is one way to send messages to Actors. There is another pattern called <code class="literal">FireAndForget "!"</code>. Fire and forget will send a message and will not block and wait for the answer. So, there is no answer - in other words, Unit.</p><p>Let's look at some code with the <code class="literal">FireAndForget</code> message exchange:</p><pre class="programlisting">    import akka.actor._  &#13;
    object Message  &#13;
    class PrinterActor extends Actor { &#13;
      def receive = { &#13;
        case a:Any =&gt; &#13;
        println("Print: " + a) &#13;
      } &#13;
    } &#13;
    object FireAndForgetActorMainApp extends App{ &#13;
      val system = ActorSystem("SimpleActorSystem") &#13;
      val actor = system.actorOf(Props[PrinterActor])     &#13;
      val voidReturn = actor ! Message &#13;
      println("Actor says: " + voidReturn ) &#13;
      system.terminate() &#13;
    } &#13;
</pre><p>If you run this code with <code class="literal">$ sbt run</code>, you will see an output as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00315.jpeg" alt="Coding actors with Akka"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Here, we have a <code class="literal">PrinterActor</code> method, which accepts pretty much anything and prints on the console. Then, we will create an Actor system and just send a message to our Actor with the fire and forget pattern, a.k.a "!", and as you can see, we will receive Unit; finally, we will await the shutdown of the Actor system using the <code class="literal">terminate</code> option.</p></div>
<div class="section" title="Actor routing" id="aid-30A8Q1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec93"/>Actor routing</h1></div></div></div><p>Akka provides routing functionality. This is useful from a business point of view because you can route to the right Actor in the sense of business logic and behavior. For architecture, we can use this as load balancing and route messages to more Actors to achieve fault tolerance and scalability.</p><p>Akka has several options for routing, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>RoundRobin</strong></span>: This is a random logic to every different Actor on the pool.</li><li class="listitem"><span class="strong"><strong>SmallestMailbox</strong></span>: This sends the message to the Actor with fewer messages.</li><li class="listitem"><span class="strong"><strong>Consistent Hashing</strong></span>: This partitions the Actors per hash ID.</li><li class="listitem"><span class="strong"><strong>ScatterGather</strong></span>: This sends message to all actors, and the first to reply wins.</li><li class="listitem"><span class="strong"><strong>TailChopping</strong></span>: This sends to a route randomly, and if a reply doesn't come back in a second, it chooses a new route and sends again, and so on.</li></ul></div><p>Let's see the following code in practice:</p><pre class="programlisting">    import akka.actor._ &#13;
    import akka.routing.RoundRobinPool  &#13;
    class ActorUpperCasePrinter extends Actor { &#13;
      def receive = { &#13;
        case s:Any =&gt; &#13;
        println("Msg: " + s.toString().toUpperCase() + " - " + &#13;
        self.path) &#13;
      } &#13;
    } &#13;
    object RoutingActorApp extends App {    &#13;
      val system = ActorSystem("SimpleActorSystem") &#13;
      val actor:ActorRef = system.actorOf(   &#13;
        RoundRobinPool(5).props(Props[ActorUpperCasePrinter]),name = &#13;
      "actor")  &#13;
      try{ &#13;
        actor ! "works 1" &#13;
        actor ! "works 2" &#13;
        actor ! "works 3" &#13;
        actor ! "works 4" &#13;
        actor ! "works 5" &#13;
        actor ! "works 6"  &#13;
      }catch{ &#13;
        case e:RuntimeException =&gt; println(e.getMessage()) &#13;
      }   &#13;
      system.terminate() &#13;
    } &#13;
</pre><p>If you run this code in sbt doing <code class="literal">$ sbt run</code>, you will get an output as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00316.jpeg" alt="Actor routing"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>So, here we have an <code class="literal">ActorUppercasePrinter</code> function that prints whatever it receives and calls the <code class="literal">toString</code> function, and then <code class="literal">toUpperCase</code>. Finally, it also prints the <code class="literal">self.path</code> Actor, which will be the address of the Actor. Actors are structured in a hierarchical structure, similar to a file system.</p><p>There are multiple ways to use Akka - Akka supports code or configuration (<code class="literal">application.conf</code> file). Here, we are creating a round-robin pool actor that has five routes. We are passing the target Actor to the router that will be our printer Actor.</p><p>As you can see, when we send messages using the fire and forget pattern, every message is delivered to a different Actor.</p></div>
<div class="section" title="Persistence"><div class="titlepage" id="aid-318PC2"><div><div><h1 class="title"><a id="ch08lvl1sec94"/>Persistence</h1></div></div></div><p>Akka works on memory. However, it is possible to use persistence. Persistence is still kind of experimental in Akka. However, it is stable. For production, you can use advanced persistence plugins, such as Apache Cassandra. For the sake of development and education, we will use Google leveldb in our file system. Akka has multiple persistence options, such as views and persistent Actors.</p><p>Let's take a look at a persistent actor using the Google leveldb and file system:</p><pre class="programlisting">    import akka.actor._ &#13;
    import akka.persistence._ &#13;
    import scala.concurrent.duration._ &#13;
    class PersistenceActor extends PersistentActor{  &#13;
      override def persistenceId = "sample-id-1" &#13;
      var state:String = "myState" &#13;
      var count = 0    &#13;
      def receiveCommand: Receive = { &#13;
        case payload: String =&gt; &#13;
        println(s"PersistenceActor received ${payload} (nr = &#13;
        ${count})") &#13;
        persist(payload + count) { evt =&gt; &#13;
          count += 1 &#13;
        } &#13;
      }        &#13;
      def receiveRecover: Receive = { &#13;
        case _: String =&gt; &#13;
        println("recover...") &#13;
        count += 1 &#13;
      } &#13;
    }  &#13;
    object PersistentViewsApp extends App { &#13;
      val system = ActorSystem("SimpleActorSystem") &#13;
      val persistentActor = &#13;
      system.actorOf(Props(classOf[PersistenceActor]))     &#13;
      import system.dispatcher &#13;
      system.scheduler.schedule(Duration.Zero, 2.seconds, &#13;
      persistentActor, "scheduled") &#13;
    } &#13;
</pre><p>Executing the <code class="literal">$ sbt run</code> command will give you the following output:</p><p>
</p><div class="mediaobject"><img src="../Images/image00317.jpeg" alt="Persistence"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>If you run this code with <code class="literal">$ sbt run</code>, and stop and run again, you will see the data is being stored and recovered every time you stop and start again.</p><p>As you can see, your Actor needs to extend <code class="literal">PersistentActor</code> in order to have persistence support. You will also need to provide a <code class="literal">persistenceID</code>.</p><p>Here, you will need to implement two receive functions. One is for commands (also known as messages), and the other one is for recovery. The command's receive loop will be activated when this Actor receives messages, while the recover one will be activated when the Actor boots up and will read the persistent data from the database.</p><p>So, this Actor here has a counter to count each message it receives, and prints every message it gets on the console. That's it; as you can see, it is pretty simple. In order to use this functionality, you will also need to configure your <code class="literal">application.conf</code>.</p><p>Your <code class="literal">application.conf</code> file should look something like this:</p><pre class="programlisting">    akka { &#13;
      system = "SimpleActorSystem" &#13;
      remote { &#13;
        log-remote-lifecycle-events = off &#13;
        netty.tcp { &#13;
          hostname = "127.0.0.1" &#13;
          port = 0 &#13;
        } &#13;
      } &#13;
    } &#13;
    akka.cluster.metrics.enabled=off  &#13;
    akka.persistence.journal.plugin = &#13;
    "akka.persistence.journal.leveldb" &#13;
    akka.persistence.snapshot-store.plugin = &#13;
    "akka.persistence.snapshot-store.local"  &#13;
    akka.persistence.journal.leveldb.dir = "target/persistence/journal" &#13;
    akka.persistence.snapshot-store.local.dir = &#13;
    "target/persistence/snapshots"  &#13;
    # DO NOT USE THIS IN PRODUCTION !!! &#13;
    # See also https://github.com/typesafehub/activator/issues/287 &#13;
    akka.persistence.journal.leveldb.native = false &#13;
</pre><p>So, here we are defining a simple Akka system (local mode), and we are configuring the persistence for Google leveldb. As you can see, we will need to provide a path for persistence, and this path must exist on the OS.</p><p>As we are using an additional functionality, we will also need to change <code class="literal">build.sbt</code> in order to import all jars that we will need in the sense of Akka, persistence, and leveldb.</p><p>Your <code class="literal">build.sbt</code> file should look something like this:</p><pre class="programlisting">    // rest of the build.sbt file ...   &#13;
    val akkaVersion = "2.4.9"                &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-actor" % &#13;
    akkaVersion &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-kernel" % &#13;
    akkaVersion &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-remote" % &#13;
    akkaVersion &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-cluster" % &#13;
    akkaVersion &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-contrib" % &#13;
    akkaVersion &#13;
    libraryDependencies += "com.typesafe.akka" %% "akka-persistence" % &#13;
    akkaVersion &#13;
    libraryDependencies += "org.iq80.leveldb" % "leveldb" % "0.7" &#13;
    libraryDependencies += "org.iq80.leveldb" % "leveldb-api" % "0.7" &#13;
    libraryDependencies += "org.fusesource.leveldbjni" % "leveldbjni" % &#13;
    "1.8" &#13;
    libraryDependencies += "org.fusesource.leveldbjni" % "leveldbjni-&#13;
    linux64" % "1.8" &#13;
    libraryDependencies += "org.fusesource" % "sigar" % "1.6.4" &#13;
    libraryDependencies += "org.scalatest" % "scalatest_2.11" % "2.2.6" &#13;
</pre><p>That's it. That's all we need to persist the Actor's state.</p><div class="note" title="Note"><h3 class="title"><a id="note3"/>Note</h3><p>Akka has way more functionalities. For more, check out the default documentation at <a class="ulink" href="http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365">http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365</a>.</p></div></div>
<div class="section" title="Creating our chat application" id="aid-3279U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec95"/>Creating our chat application</h1></div></div></div><p>Now that we know Akka better, we will continue to develop our application. Akka has a great integration with the Play framework. We will use Actors with the Akka and Play framework right now. Let's build a simple chat feature for our app. We will change the code to add a new UI and, using the Akka testkit, we will test out actors.</p><p>The Play framework already includes Akka on the classpath for us, so we don't need to worry about it. However, we will need to add the Akka testkit dependency to the <code class="literal">build.sbt</code> file in order to have the classes in our classpath.</p><p>Your <code class="literal">build.sbt</code> should look something like this:</p><pre class="programlisting">    // rest of the build.stb ...  &#13;
    libraryDependencies ++= Seq( &#13;
      "com.typesafe.akka" %% "akka-testkit" % "2.4.4" % Test, &#13;
    // rest of the deps ... &#13;
    )  &#13;
    // rest of the build.stb ... &#13;
</pre><p>Okay, now you can go to the console and type <code class="literal">$ activator</code>, <code class="literal">$ reload</code>, and then <code class="literal">$ compile</code>. This will force sbt to download the new dependency.</p><p>Now we will need to create a package called Actors. This package needs to be located at <code class="literal">ReactiveWebStore/app/</code>. We will start creating an <code class="literal">ActorHelper</code> utility object in order to have a generic function for the ask pattern that we saw earlier. It is an Actor helper generic ask pattern utility.</p><p>Your <code class="literal">ActorHelper.scala</code> file should look something like this:</p><pre class="programlisting">    package actors  &#13;
    object ActorHelper {  &#13;
      import play.api.libs.concurrent.&#13;
      Execution.Implicits.defaultContext &#13;
      import scala.concurrent.duration._ &#13;
      import akka.pattern.ask &#13;
      import akka.actor.ActorRef &#13;
      import akka.util.Timeout &#13;
      import scala.concurrent.Future &#13;
      import scala.concurrent.Await    &#13;
      def get(msg:Any,actor:ActorRef):String = { &#13;
        implicit val timeout = Timeout(5 seconds) &#13;
        val result = (actor ? msg).mapTo[String].map { result =&gt; &#13;
        result.toString } &#13;
        Await.result(result, 5.seconds) &#13;
      } &#13;
    } &#13;
</pre><p>The <code class="literal">ActorHelper</code> has just one function: <code class="literal">get</code>. This function will get an answer from any Actor given in any message. However, as you can see, we have a timeout of five seconds. If the result does not come back in this time, an exception will be raised.</p><p>In this code, we are also mapping the Actor result to a String calling the <code class="literal">toString</code> function in the result future. This is not a lot of code; however, there are lots of imports, and it makes the code cleaner and we can get answers from Actors with less code and fewer imports.</p></div>
<div class="section" title="The chat protocol"><div class="titlepage" id="aid-335QG2"><div><div><h1 class="title"><a id="ch08lvl1sec96"/>The chat protocol</h1></div></div></div><p>Now we will need to define our protocol. For this functionality, we will need three Actors. The Actors that we create will be as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>ChatRoom</strong></span>: This will have a reference for all users in the chat room</li><li class="listitem"><span class="strong"><strong>ChatUser</strong></span>: This will have one instance per user (active browser)</li><li class="listitem"><span class="strong"><strong>ChatBotAdmin</strong></span>: This simple Bot Admin will provide stats about the chat room</li></ul></div><p>
<code class="literal">ChatUserActor</code> will need to join <code class="literal">JoinChatRoom</code> object in order to start chatting. <code class="literal">ChatUserActor</code> will also need to send messages to <code class="literal">ChatMessage</code> class to the <code class="literal">ChatRoomActor</code> that will broadcast messages to all users. The <code class="literal">ChatBotAdmin</code> will get a report from  <code class="literal">GetStats</code> object from <code class="literal">ChatRoomActor</code>.</p><p>Let's start coding this protocol. First, we will need to define the messages that will be exchanged between these Actors, as shown in the following piece of code:</p><pre class="programlisting">    package actors  &#13;
    case class ChatMessage(name:String,text: String) &#13;
    case class Stats(users:Set[String])  &#13;
    object JoinChatRoom &#13;
    object Tick &#13;
    object GetStats &#13;
</pre><p>As you can see here, we have a <code class="literal">ChatMessage</code> class with a name and a text. This will be the message each user will send on the chat. Then, we will have a stats class, which has a set of users--this will be all the users logged into the chat application.</p><p>Finally, we have some action messages, such as <code class="literal">JoinChatRoom</code>, <code class="literal">Tick</code>, and <code class="literal">GetStats</code>. So, <code class="literal">JoinChatRoom</code> will be sent by <code class="literal">ChatUserActor</code> to <code class="literal">ChatRoomActor</code> in order to join the chat. <code class="literal">Tick</code> will be a scheduled message that will happen from time to time in order to make <code class="literal">ChatBotAdmin</code> send stats about the chat room to all logged users. <code class="literal">GetStats</code> is the message that <code class="literal">ChatBotAdminActor</code> will send to <code class="literal">ChatRoomActor</code> in order to get information about who is in the room.</p><p>Let's code our three actors now.</p><p>The <code class="literal">ChatRoomActor.scala</code> file should look something like this:</p><pre class="programlisting">    package actors  &#13;
    import akka.actor.Props &#13;
    import akka.actor.Terminated &#13;
    import akka.actor.ActorLogging &#13;
    import akka.event.LoggingReceive &#13;
    import akka.actor.Actor &#13;
    import akka.actor.ActorRef &#13;
    import play.libs.Akka &#13;
    import akka.actor.ActorSystem  &#13;
    class ChatRoomActor extends Actor with ActorLogging {  &#13;
      var users = Set[ActorRef]()  &#13;
      def receive = LoggingReceive { &#13;
        case msg: ChatMessage =&gt; &#13;
        users foreach { _ ! msg } &#13;
        case JoinChatRoom =&gt; &#13;
        users += sender &#13;
        context watch sender   &#13;
        case GetStats =&gt; &#13;
        val stats:String = "online users[" + users.size + "] - users[" &#13;
        + users.map( a =&gt;        a.hashCode().mkString("|") + "]" &#13;
        sender ! stats &#13;
        case Terminated(user) =&gt; &#13;
        users -= user &#13;
      } &#13;
    } &#13;
    object ChatRoomActor { &#13;
      var room:ActorRef = null &#13;
      def apply(system:ActorSystem) = { &#13;
        this.synchronized { &#13;
          if (room==null) room = system.actorOf(Props[ChatRoomActor]) &#13;
          room &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>
<code class="literal">ChatRoomActor</code> has a var called <code class="literal">users</code>, which is a set of <code class="literal">ActorRef</code>. <code class="literal">ActorRef</code> is a generic reference to any actor. We have the receive function with three cases: <code class="literal">ChatMessage</code>, <code class="literal">JoinChatRoom</code>, and <code class="literal">GetStats</code>.</p><p>A <code class="literal">JoinChatRoom</code> will be sent by the <code class="literal">ChatUserActor</code> method in order to join the room. As you can see, we are getting the <code class="literal">ActorRef</code> method from the sender Actor using the <code class="literal">sender()</code>function, and we are adding this reference to the set of users. In this way, the set of <code class="literal">ActorRef</code> represents the online logged-in users in the chat room right now.</p><p>The other case is with the <code class="literal">ChatMessage</code> method. Basically, we will broadcast the message to all users in the chat. We do this because we have the reference for all actors in users. Then, we will call the <code class="literal">foreach</code> function in order to iterate all users one by one, and then we will send the message using <code class="literal">FireAndForget "!"</code> to each user Actor represented by the operator underscore <code class="literal">_</code>.</p><p>The <code class="literal">GetStats</code> case creates a string with all chat room stats. For now, the stats are just the number of online users, which is computed by calling the size function on the users object. We are also showing all the hash codes that identify all Actors logged in, just for fun.</p><p>That's our <code class="literal">ChatRoomActor</code> implementation. As you can see, it is hard to talk about one Actor without describing the other, as the protocol will always be kind of coupled. You might also be wondering why we have a companion object for the <code class="literal">ChatRoomActor</code> method.</p><p>This object is to provide an easy way to create Actor instances. We are creating a single room for our design; we don't want to have multiple chat rooms, so that's why we will need to control the creation of the room Actor.</p><p>If the room is null, we will create a new room; otherwise, we will return the cached instance of the room that we already got in the memory. We will need an instance of the Actor system in order to create actors, so that's why we are receiving the system on the <code class="literal">apply</code> function. The <code class="literal">apply</code> function will be called when someone writes a code like <code class="literal">ChatRoomActor(mySystem)</code>.</p><p>Now, let's move to the ChatUserActor implementation.</p><p>The <code class="literal">ChatUserActor.scala</code> file should look something like this:</p><pre class="programlisting">    package actors  &#13;
    import akka.actor.ActorRef &#13;
    import akka.actor.Actor &#13;
    import akka.actor.ActorLogging &#13;
    import akka.event.LoggingReceive &#13;
    import akka.actor.ActorSystem &#13;
    import akka.actor.Props  &#13;
    class ChatUserActor(room:ActorRef, out:ActorRef) extends Actor with &#13;
    ActorLogging { &#13;
      override def preStart() = { &#13;
        room ! JoinChatRoom &#13;
      }  &#13;
      def receive = LoggingReceive { &#13;
        case ChatMessage(name, text) if sender == room =&gt; &#13;
        val result:String = name + ":" + text &#13;
        out ! result &#13;
        case (text:String) =&gt; &#13;
        room ! ChatMessage(text.split(":")(0), text.split(":")(1)) &#13;
        case other =&gt; &#13;
        log.error("issue - not expected: " + other) &#13;
      } &#13;
    }  &#13;
    object ChatUserActor { &#13;
      def props(system:ActorSystem)(out:ActorRef) = Props(new       &#13;
      ChatUserActor(ChatRoomActor(system), out)) &#13;
    } &#13;
</pre><p>This Actor is a little bit easier than the previous one. <code class="literal">ChatUserActor</code> receives, as a parameter, the room actor reference and also an out actor. The room will be an instance of the room that the user will use to communicate with other users. The <code class="literal">ActorRef</code> method called out is the Play framework Actor responsible for sending the answer back to the controllers and UI.</p><p>We pretty much just have two cases: one where we receive a <code class="literal">ChatMessage</code> and the other is the <code class="literal">ChatUserActors</code> method in the chat room. So, we will just need to send back to the UI using the out Actor. That's why there is a fire and forget message for the out Actor with a result. Using a new Actor model can be dangerous, please read more at <a class="ulink" href="http://doc.akka.io/docs/akka/current/scala/actors.html">http://doc.akka.io/docs/akka/current/scala/actors.html</a>.</p><p>There is another case that just receives a string that will be the message from that Actor itself. Remember that each Actor represents a user and a browser full of duplex connections via WebSockets. Don't worry about WebSockets now; we will cover it in more detail later in this chapter.</p><p>For this case function, we are sending the <code class="literal">ChatMessage</code> method to the room. We will split the messages in two parts: the username and the text, which is split by <code class="literal">:</code>.</p><p>Here, we also have a companion object for the sake of good practice. So, you can call <code class="literal">ChatUserActor</code>, passing the Actor system and a curried parameter for the out actor.</p><p>Now, we will move to the last Actor: the Bot Admin Actor, which should look something like this:</p><pre class="programlisting">    package actors  &#13;
    import akka.actor.ActorRef &#13;
    import akka.actor.Actor &#13;
    import akka.actor.ActorLogging &#13;
    import akka.event.LoggingReceive &#13;
    import akka.actor.ActorSystem &#13;
    import akka.actor.Props &#13;
    import scala.concurrent.duration._  &#13;
    class ChatBotAdminActor(system:ActorSystem) extends Actor with &#13;
    ActorLogging { &#13;
      import play.api.libs.concurrent.Execution.&#13;
      Implicits.defaultContext &#13;
      val room:ActorRef = ChatRoomActor(system) &#13;
      val cancellable = system.scheduler.schedule(0 seconds, &#13;
      10 seconds, self , Tick) &#13;
      override def preStart() = { &#13;
        room ! JoinChatRoom &#13;
      }  &#13;
      def receive = LoggingReceive { &#13;
        case ChatMessage(name, text) =&gt; Unit &#13;
        case (text:String) =&gt; room ! ChatMessage(text.split(":")(0), &#13;
        text.split(":")(1)) &#13;
        case Tick =&gt; &#13;
        val response:String = "AdminBot:" + ActorHelper.get&#13;
        (GetStats, room) &#13;
        sender() ! response &#13;
        case other =&gt; &#13;
        log.error("issue - not expected: " + other) &#13;
      } &#13;
    } &#13;
    object ChatBotAdminActor { &#13;
      var bot:ActorRef = null &#13;
      def apply(system:ActorSystem) = { &#13;
        this.synchronized { &#13;
          if (bot==null) bot = system.actorOf(Props&#13;
          (new ChatBotAdminActor(system))) &#13;
          bot &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>As you can see, this Actor receives the reference of the chat room as a parameter. Using the Actor system, it gets the reference of the chat room Actor. This Actor receives an <code class="literal">ActorSystem</code> message by now.</p><p>Using the Actor system variable called system, we will also schedule a <code class="literal">Tick</code> for this Actor for every ten seconds. This time, the window interval will be the time in which the bot will notify the chat room about the current status.</p><p>We will also override the <code class="literal">preStart</code> function. Akka will call this function when the Actor is created on the actor system. This implementation will send a message to the room, which is <code class="literal">JoinChatRoom</code>.</p><p>Like all Actors, there is the receive function implementation. First case with <code class="literal">ChatMessage</code> is returning Unit. If you want to make this bot respond to people, remove Unit and write the proper Scala code as you wish.</p><p>In the second case, we will have the String message that will be sent to the chat room. Finally, after this case, we will have the <code class="literal">Tick</code> method, which will appear every ten seconds. So, we will use the <code class="literal">ActorHelper</code> to get the stats from the room, and then we will send a string message with the information about the room. This will trigger the second case and broadcast the message to the whole room.</p><p>Finally, we have a companion object. We don't want to have two instances of the bot, which is why we will control this object creation by design. We're done with the actors implementations. Next, we will need to work a new controller for the chat actors.</p></div>
<div class="section" title="The chat controller" id="aid-344B21"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec97"/>The chat controller</h1></div></div></div><p>We will need to create a new controller. This controller will be located at <code class="literal">ReactiveWebStore/app/controllers</code>.</p><div class="section" title="Implementing the chat controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Implementing the chat controller</h2></div></div></div><p>
<code class="literal">ChatController.scala</code> should look something like this:</p><pre class="programlisting">    package controllers  &#13;
    import akka.actor.ActorSystem &#13;
    import akka.stream.Materializer &#13;
    import javax.inject._ &#13;
    import play.api._ &#13;
    import play.api.mvc._ &#13;
    import play.api.libs.streams._ &#13;
    import actors.ChatUserActor &#13;
    import actors.ChatBotAdminActor  &#13;
    @Singleton &#13;
    class ChatController @Inject() (implicit val system: ActorSystem,&#13;
    materializer: Materializer) &#13;
    extends Controller {  &#13;
      import play.api.libs.concurrent.Execution.&#13;
      Implicits.defaultContext &#13;
      ChatBotAdminActor(system)  &#13;
      def index_socket = Action { request =&gt; &#13;
        Ok(views.html.chat_index()(Flash(Map()))) &#13;
      } &#13;
      def ws = WebSocket.accept[String, String] { request =&gt; &#13;
        ActorFlow.actorRef(out =&gt; ChatUserActor.props(system)(out)) &#13;
      }&#13;
    } &#13;
</pre><p>The <code class="literal">ChatController</code> method will use Google Guice to get injected instances of Actor System and an Actor materializer instance. A materializer is needed because it will provide the instance of the out Actor for each user in the system.</p><p>As you can see, we will create an instance of the <code class="literal">ChatBotAdmin</code> method passing through the actor system, which Google Guice injected for us. For this controller, we will just have two functions: one function to render the chat UI, and the other one to serve the WebSocket.</p><p>The Play framework already provides built-in integration with Akka and WebSockets. So, we will just need to use the <code class="literal">ActorFlow</code> method using the <code class="literal">actorRef</code> function in order to obtain an out Actor.</p><p>Here, we will call the <code class="literal">ChatUserActor</code> companion object and create a chat user for the websocket passing out the Actor system the controller has. As you can see, this returns <code class="literal">WebSocket.accept</code>, which is a full duplex connection between the web browser and the backend.</p></div></div>
<div class="section" title="Configuring the routes" id="aid-352RK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Configuring the routes</h1></div></div></div><p>Next, we will need to expose our controller functions to the UI. We will need to add more routes to the <code class="literal">ReactiveWebStore/conf/routes</code> file:</p><pre class="programlisting">    routes  
    # 
    # Akka and Websockets  
    # 
    GET /chat/index_socket   controllers.ChatController.index_socket 
    GET /chat/ws                    controllers.ChatController.ws 
</pre><p>The routes are done now.</p></div>
<div class="section" title="Working on the UI"><div class="titlepage" id="aid-361C62"><div><div><h1 class="title"><a id="ch08lvl1sec99"/>Working on the UI</h1></div></div></div><p>Now, it is time to code on the UI on both the HTML layout and the WebSocket code in JavaScript. We will need to create a new file, located at <code class="literal">ReactiveWebStore/app/views</code>.</p><p>Your <code class="literal">chat_index.scala.html</code> file should look something like this:</p><pre class="programlisting">    @()(implicit flash:Flash)  &#13;
    @main("Chat"){  &#13;
    &lt;!DOCTYPE html&gt; &#13;
      &lt;meta charset="utf-8" /&gt; &#13;
      &lt;title&gt;Chat Room&lt;/title&gt; &#13;
      &lt;script type="text/javascript"&gt; &#13;
        var output; &#13;
        var websocket = new WebSocket("ws://localhost:9000/chat/ws");     &#13;
        function init(){ &#13;
          output = document.getElementById("output");     &#13;
          websocket.onmessage = function(evt) { &#13;
            writeToScreen('&lt;span style="color:blue;"&gt;' + evt.data+ &#13;
            '&lt;/span&gt;'); &#13;
          };           &#13;
          websocket.onerror = function(evt) { &#13;
            writeToScreen('&lt;span style="color: red;"&gt;ERROR:&lt;/span&gt; ' + &#13;
            evt.data); &#13;
          }; &#13;
        }     &#13;
        function doSend(message){ &#13;
          websocket.send(message); &#13;
        }     &#13;
        function writeToScreen(message){ &#13;
          var pre = document.createElement("p"); &#13;
          pre.style.wordWrap = "break-word"; &#13;
          pre.innerHTML = message; &#13;
          $('#output').prepend(pre); &#13;
        }     &#13;
        window.addEventListener("load", init, false); &#13;
      &lt;/script&gt;  &#13;
      &lt;h3&gt;Messages&lt;/h3&gt; &#13;
      &lt;div id="output" style="width: 800px; height: 250px; overflow-y: &#13;
      scroll;" &gt; &#13;
      &lt;/div&gt;  &#13;
      &lt;div id="contentMessage"&gt;   &#13;
        &lt;BR&gt; &#13;
        user:      &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &#13;
        &lt;input type="text" name="txtUser" id="txtUser" /&gt; &lt;BR&gt;&lt;BR&gt; &#13;
        message: &lt;input type="text" name="txtMessage" &#13;
        id="txtMessage" /&gt; &#13;
        &lt;BR&gt; &#13;
        &lt;BR&gt;     &#13;
        &lt;a href="#" class="btn btn-success" &#13;
        onclick="doSend( document.getElementById('txtUser').value + ':' &#13;
        + document.getElementById('txtMessage').value );"&gt; &#13;
        &lt;i class="icon-plus icon-white"&gt;&lt;/i&gt;Send Message&lt;/a&gt; &#13;
      &lt;/div&gt; &#13;
    } &#13;
</pre><p>The UI is very simple. There is an input text for you to put your name and there is another one for the text message itself, and a send button. As you can see in the JavaScript code, the first thing that we will do is open a WebSocket connection to the <code class="literal">ws://localhost:9000/chat/ws</code> URL. Then, we will register the <code class="literal">init</code> function to run once the browser is ready.</p><p>The <code class="literal">init</code> function in JavaScript will create two functions for our WebSocket. One function will run when any error occurs and the other function will run for each message emitted by the Akka backend.</p><p>We will have a <code class="literal">doSend</code> function in JavaScript in order to send a message to the WebSocket. This message will be delivered to the controller and then to the Akka actors. You can also see some JQuery and HTML code in order to create new elements on the UI. This is done in order to display the message in the chat room.</p><p>OK, there is one more thing that we will need to do - add a reference to the chat UI on the main page of our application.</p><p>Your <code class="literal">Index.scala.html</code> should look something like this:</p><pre class="programlisting">    @(message: String)(implicit flash:Flash)  &#13;
    @main("Welcome to Reactive Web Store"){ &#13;
    &lt;div class="row-fluid"&gt; &#13;
      &lt;BR&gt; &#13;
      &lt;div class="span12"&gt;           &#13;
        &lt;div class="row-fluid"&gt; &#13;
          &lt;div class="span6"&gt; &#13;
            &lt;a href="/product"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/product.png")"&gt; Manage &#13;
            Products&lt;/a&gt;&lt;BR&gt; &#13;
            &lt;a href="/review"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/review.png")"&gt; Manage &#13;
            Reviews&lt;/a&gt;&lt;BR&gt; &#13;
            &lt;a href="/image"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/image.png")"&gt; Manage &#13;
            Images&lt;/a&gt;&lt;BR&gt; &#13;
          &lt;/div&gt; &#13;
          &lt;div class="span6"&gt; &#13;
            &lt;a href="/reports"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/reports.png")"&gt; Reports &lt;/a&gt;&#13;
            &lt;BR&gt; &#13;
            &lt;a href="/chat/index_socket"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/chat.png")"&gt; Chat Room &lt;/a&gt;&#13;
              &lt;BR&gt; &#13;
            &lt;/div&gt; &#13;
          &lt;/div&gt; &#13;
        &lt;/div&gt;             &#13;
      &lt;/div&gt; &#13;
    } &#13;
</pre><p>We will also use the opportunity to improve a little bit of the UI design using Twitter Bootstrap column design. In the last row, you can see our link to the chat UI. Now, we can run the application and see our chat working. Run <code class="literal">$ activator run</code>:</p><p>
</p><div class="mediaobject"><img src="../Images/image00318.jpeg" alt="Working on the UI"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see, our new chat UI link is there. Now, let's have fun with this new feature. Open four new browsers (simulate four different users), then go to the <code class="literal">http://localhost:9000/chat/index_socket</code> url and let's have a little chat. You should see something similar to this:</p><p>
</p><div class="mediaobject"><img src="../Images/image00319.jpeg" alt="Working on the UI"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Almost done. Our chat feature works; however, we will need to do more than just a functional black box test on the UI. We will need unit tests. Luckily for us, we have the Akka testkit, which allows us to easily test actors.</p></div>
<div class="section" title="Adding Akka tests" id="aid-36VSO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec100"/>Adding Akka tests</h1></div></div></div><p>We will create three more tests: one for each actor that we have. They are located at <code class="literal">ReactiveWebStore/test/</code>.</p><div class="section" title="Scala test for Akka Actor"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Scala test for Akka Actor</h2></div></div></div><p>
<code class="literal">ChatUserActorSpec.scala</code> should look something like this:</p><pre class="programlisting">    class OutActor extends Actor { &#13;
      def receive = { &#13;
        case a:Any =&gt; Unit &#13;
      } &#13;
    }  &#13;
    class ChatUserActorSpec extends PlaySpec {   &#13;
      class Actors extends TestKit(ActorSystem("test"))  &#13;
      "ChatUserActor" should { &#13;
        "joins the chat room and send a message" in new Actors { &#13;
          val probe1 = new TestProbe(system) &#13;
          val actorOutRef = TestActorRef[OutActor](Props[OutActor]) &#13;
          val actorRef = TestActorRef[ChatUserActor]&#13;
          (ChatUserActor.props(system)(actorOutRef)) &#13;
          val userActor = actorRef.underlyingActor &#13;
          assert(userActor.context != null) &#13;
          val msg = "testUser:test msg" &#13;
          probe1.send(actorRef,msg) &#13;
          actorRef.receive(msg) &#13;
          receiveOne(2000 millis) &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>The Akka testkit is very cool as it allows us to test actors with a very easy <span class="strong"><strong>Domain Specific Language</strong></span> (<span class="strong"><strong>DSL</strong></span>). It's possible to check the Actor mailbox, the Actor internal state, and so much more. There is one trick that we will need to do because we need to extend one class; in order to have Play working with the Scala test, we will need to use PlaySpec. However, we will also need to extend one class to make the Akka testkit work, which is <code class="literal">TestKit</code>. We can't extend both at the same time, but no worries, there is always a workaround.</p><p>The workaround here is to create a case class, make that case class extend <code class="literal">TestKit</code>, and then use it in a spec context, that is, in a new <code class="literal">Actor {}</code>.</p><p>Here, we are checking if <code class="literal">ChatUserActor</code> can join the chat room properly. This is done by simply creating the Actor, as the Actor has a <code class="literal">preStart</code> method that will auto-join the room.</p><p>We will need to create a fake implementation of the out Actor here, which is why we have the <code class="literal">OutActor</code> implementation. We will create a probe to test the actor system, and we will also use a special function to test the Actors, called <code class="literal">TestActorRef</code>. This abstraction provides a way to access the Actor's state via <code class="literal">actorRef.underlyingActor</code>, and this is useful because you can check the Actor internal state to validate the code. The rest of the code is normal Akka and Scala test code. Let's move to the next test.</p></div><div class="section" title="Chat room Actor test"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Chat room Actor test</h2></div></div></div><p>The <code class="literal">ChatRoonActorSpec.scala</code> file should look something like this:</p><pre class="programlisting">    class ChatRoomActorSpec extends PlaySpec {    &#13;
      class Actors extends TestKit(ActorSystem("test"))  &#13;
      "ChatRoomActor" should { &#13;
        "accept joins the chat rooms" in new Actors { &#13;
          val probe1 = new TestProbe(system) &#13;
          val probe2 = new TestProbe(system) &#13;
          val actorRef = TestActorRef[ChatRoomActor]&#13;
          (Props[ChatRoomActor]) &#13;
          val roomActor = actorRef.underlyingActor &#13;
          assert(roomActor.users.size == 0) &#13;
          probe1.send(actorRef, JoinChatRoom) &#13;
          probe2.send(actorRef, JoinChatRoom) &#13;
          awaitCond(roomActor.users.size == 2, 100 millis) &#13;
          assert(roomActor.users.contains(probe1.ref)) &#13;
          assert(roomActor.users.contains(probe2.ref)) &#13;
        } &#13;
        "get stats from the chat room" in new Actors { &#13;
          val probe1 = new TestProbe(system) &#13;
          val actorRef = TestActorRef[ChatRoomActor]&#13;
          (Props[ChatRoomActor]) &#13;
          val roomActor = actorRef.underlyingActor &#13;
          assert(roomActor.users.size == 0) &#13;
          probe1.send(actorRef, JoinChatRoom) &#13;
          awaitCond(roomActor.users.size == 1, 100 millis) &#13;
          assert(roomActor.users.contains(probe1.ref)) &#13;
          probe1.send(actorRef, GetStats) &#13;
          receiveOne(2000 millis) &#13;
        } &#13;
        "and broadcast messages" in new Actors { &#13;
          val probe1 = new TestProbe(system) &#13;
          val probe2 = new TestProbe(system) &#13;
          val actorRef = TestActorRef[ChatRoomActor]&#13;
          (Props[ChatRoomActor]) &#13;
          val roomActor = actorRef.underlyingActor &#13;
          probe1.send(actorRef, JoinChatRoom) &#13;
          probe2.send(actorRef, JoinChatRoom) &#13;
          awaitCond(roomActor.users.size == 2, 100 millis) &#13;
          val msg = ChatMessage("sender", "test message") &#13;
          actorRef.receive(msg) &#13;
          probe1.expectMsg(msg) &#13;
          probe2.expectMsg(msg) &#13;
        } &#13;
        "and track users ref and counts" in new Actors { &#13;
          val probe1 = new TestProbe(system) &#13;
          val probe2 = new TestProbe(system)  &#13;
          val actorRef = TestActorRef[ChatRoomActor]&#13;
          (Props[ChatRoomActor]) &#13;
          val roomActor = actorRef.underlyingActor &#13;
          probe1.send(actorRef, JoinChatRoom) &#13;
          probe2.send(actorRef, JoinChatRoom) &#13;
          awaitCond(roomActor.users.size == 2, 100 millis) &#13;
          probe2.ref ! PoisonPill &#13;
          awaitCond(roomActor.users.size == 1, 100 millis) &#13;
        }&#13;
      }&#13;
    } &#13;
</pre><p>So, here we have the same concepts as the other test. However, we have more usage of the Akka testkit DSL. For instance, we are using <code class="literal">expectMsg</code> on the probe to check if an Actor received a specific message. We are also using <code class="literal">awaitCond</code> to check the Actor's internal state in an assertion.</p><p>Now is the time to test the last Actor method.</p></div><div class="section" title="Chat Bot Admin Actor test"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Chat Bot Admin Actor test</h2></div></div></div><p>
<code class="literal">ChatBotAdminActorSpec.scala</code> file should look something like this:</p><pre class="programlisting">    class ChatBotAdminActorSpec extends TestKit(ActorSystem("test")) &#13;
    with ImplicitSender &#13;
    with WordSpecLike with Matchers with BeforeAndAfterAll {  &#13;
      "ChatBotAdminActor" should { &#13;
        "be able to create Bot Admin in the Chat Room and Tick" in { &#13;
          val probe1 = new TestProbe(system) &#13;
          val actorRef = TestActorRef[ChatBotAdminActor](Props(new &#13;
          ChatBotAdminActor(system))) &#13;
          val botActor = actorRef.underlyingActor &#13;
          assert(botActor.context != null) &#13;
          awaitCond(botActor.room != null ) &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>For this test, we will check if the actor context was not null, and also if the room was created and the scheduler was also not null. All good to go.</p><p>Alright, that's it! This is the last actor test. Now we are completely done. You can run this test with <code class="literal">$ activator test</code>, or, if you prefer the activator, then use <code class="literal">"test-only TESTCLASSNAME" -Dsbt.task.forcegc=false</code> to run a specific test case.</p></div></div>
<div class="section" title="Summary" id="aid-37UDA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Summary</h1></div></div></div><p>In this chapter, you learned how to work with Akka actors and created a web chat using Akka, the Play framework, and WebSockets. Akka is a really powerful solution that can be used with or without the Play framework. Additionally, you learned about the Actor model, mailboxes, routing, persistence, Akka configuration, message patterns, and how to write code with actors in Scala and Play.</p><p>In the next chapter, you will learn more about REST, JSON, and how to model a REST API, as well as how to create a Scala client for your REST services.</p></div></body></html>