- en: Reducing the Coding Effort by Relying on Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your application to use a connection pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using messaging services for asynchronous communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a servlet's life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important concepts that you need to know about Java EE is:
    it is a standard. If you go to the **Java Community Process** (**JCP**) website,
    you will find the **Java Specification Request** (**JSR**) for the Java EE platform
    (for Version 8 it is JSR 366).'
  prefs: []
  type: TYPE_NORMAL
- en: A standard... for what? Well, for an application server! For instance, a Java
    EE application server.
  prefs: []
  type: TYPE_NORMAL
- en: It means that you can develop your Java EE application knowing it will run in
    an environment that provides a bunch of resources that you can rely on.
  prefs: []
  type: TYPE_NORMAL
- en: It also means you can easily move from one application server to another, as
    long as you stick to the Java EE patterns instead of some vendor-specific feature
    (considered a bad practice). Your application should have the same behavior no
    matter what Java EE-compatible server you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, yes! Beyond being a standard, Java EE is also a certification. For a Java
    EE server to be considered compatible, it has to pass through a number of tests
    to guarantee it implements every single point of the specification (JSR).
  prefs: []
  type: TYPE_NORMAL
- en: This amazing ecosystem allows for less coding of your application and gives
    you the chance to focus on what really matters to you or to your client. Without
    a standard environment, you would need to implement your own code for request/response
    management, queues, connection pooling, and other stuff.
  prefs: []
  type: TYPE_NORMAL
- en: You can definitely do it if you want, but you don't have to. Actually you can
    even write your own Java EE application server, if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that let's move on with the chapter! In the following recipes, you
    are going to learn how to take advantage of some cool features already implemented
    on your favorite Java EE application server.
  prefs: []
  type: TYPE_NORMAL
- en: Examples will be based on GlassFish 5 but, as I mentioned before, they should
    have the same behavior for any other compatible implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your application to use a connection pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things we should learn in our life, after feeding, is using
    a connection pool. Especially when we are talking about databases. This is the
    case covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because a connection opened with the database is costly in terms of resources
    used for it. Even worse, if we look closer at the process of opening a new connection,
    it uses a lot of CPU resources, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe it won't make much difference if you have two users using a database with
    a couple of registers in a few tables. But it can start causing trouble if you
    have dozens of users, or if the database is large and gives you sleepless nights
    when you have hundreds of users using a huge database.
  prefs: []
  type: TYPE_NORMAL
- en: Actually I, myself, saw in the early days of J2EE 1.3 (the year was 2002), a
    performance issue being solved by a connection pool in an application used by
    20 people. There were a few users, but the database was really big and not so
    well-designed (the same for the application, I have to say).
  prefs: []
  type: TYPE_NORMAL
- en: 'But you may say: why does a connection pool help us with this? Because once
    it is configured, the server will open all the connections you asked for, when
    it is starting up, and will manage them for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing you have to do is to ask: *"Hey, server! Could you lend me a
    database connection, please?"* and kindly give it back when you are done (which
    means as quickly as possible).'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, add the right dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you still haven't downloaded GlassFish 5 to your development environment,
    this is the right time to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin by configuring our connection pool in GlassFish 5\. Once it is
    up and running, go to this URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the go to the Administration Console link or if you prefer, go
    straight to the URL at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:4848/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then follow this path in the left menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources | JDBC | JDBC Connection Pools
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the New button. It will open the New JDBC Connection Pool page. Fill
    in the fields as described here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pool Name: `MysqlPool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource Type: `javax.sql.DataSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database Driver Vendor: `MySql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you can make your own custom choices, but then we will be following
    different paths!
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Next button. It will open the second step for our pool creation
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This new page has three sections: General Settings, Pool Settings, and Transaction
    and Additional Properties. For our recipe, we are only dealing with General Settings and
    Additional Properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the General Settings section make sure that DataSource Classname has this
    value selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`com.mysql.jdbc.jdbc2.optional.MysqlDatasource`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s move to the Additional Properties section. There might be a bunch
    of properties listed, but we will just fill in a few of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DatabaseName: `sys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ServerName: `localhost`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User: `root`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: `mysql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PortNumber: `3306`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the Finish button and voilá! Your connection pool is ready... or almost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can''t access it until you do one more configuration. In the same menu,
    on the left, following this path:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources | JDBC | JDBC Resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the New button and then fill in the fields like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JNDI Name: `jdbc/MysqlPool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pool Name: `MysqlPool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you are good to go! Your connection pool is ready to be used. Let''s build
    a simple application to try it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a class to get a connection from the pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a class that we will use as a representation of the `sys_config` table
    (MySQL''s system table):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create another class, to create a list based on the data returned from
    the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally a servlet that will try them all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To try it just open this URL in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch06-connectionpooling/PoolTestServlet`'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deciding how many connections your pool will hold, as well as all the other
    parameters, is an architecture decision made based on a number of factors such
    as the type of data, database design, application and user behavior, and so on.
    We could write a whole book about it.
  prefs: []
  type: TYPE_NORMAL
- en: But if you are starting from scratch and/or still don't need much information,
    consider a number between 10% to 20% of your concurrent users. In other words,
    if your application has, for instance, 100 concurrent users, you should provide
    10 to 20 connections to your pool.
  prefs: []
  type: TYPE_NORMAL
- en: You will know that your connections aren't enough if some methods are taking
    too much time to get a connection from the pool (it should take no time at all).
    It means that the server has no available connection at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: So, you need to check if there are some methods taking too long to complete,
    or even some part in your code that is not closing the connection (consider what
    gives the connection back to the server). Depending on the issue, it might not
    be a pooling problem but a design one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing for dealing with connection pools is to use the "try-with-resources"
    statement as we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will guarantee that these resources will be properly closed once the method
    is done and also deal with their respective exceptions, also helping you to write
    less code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See this recipe's full source code at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using messaging services for asynchronous communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message service, provided in Java EE by the **Java Message Service** (**JMS**)
    API, is one of the most important and versatile features provided by Java EE environments.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the Producer-Consumer approach, where one peer (the Producer) puts a
    message into a queue and another peer (the Consumer) reads the message from there.
  prefs: []
  type: TYPE_NORMAL
- en: Both the Producer and Consumer can be different applications, even using different
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to build a messaging service using GlassFish 5\.
    Each Java EE server has its own way to set up the service, so if are using some
    other implementations, you should take a look at its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the Java EE code generated here will work on any Java EE
    8-compatible implementation. Standard for the win!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First add the proper dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin by configuring our messaging service in GlassFish 5\. Once the
    server is up and running, go to this URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the go to the Administration Console link or if you prefer, go
    straight to the URL at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:4848/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then follow this path in the left menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources | JMS Resources | Connection Factories
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the New button. When the page is opened, fill the General Settings section
    fields like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JNDI Name: `jms/JmsFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource Type: `javax.jms.ConnectionFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not touch the Pool Settings section here, so just click on the OK button
    to register your new factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now follow this path in the left menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources | JMS Resources | Destination Resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the New button. When the page is opened, fill the section fields like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JNDI Name: `jms/JmsQueue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Physical Destination Name: `JmsQueue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ResourceType: `javax.jms.Queue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on the OK button and you are ready! Now you have a connection factory
    to access your JMS server and a queue. So let''s build an application to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a **message driven bean** (**MDB**) as a listener for any
    message dropped into our queue. This is the Consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the Producer class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And a servlet to access the Producer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a page just to call our servlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now just deploy and run it. Each time you call `QueueSenderServlet` you should
    see something like this on your server log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the standards implemented in the Java EE 8 server, our MDB is 100%
    managed by the container. That''s why we could just refer to the queue without
    looking back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We could have built a Consumer by our own hands, but it would build three times
    as many code lines and would be synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get our container Producer from a session provided by our factory and made
    for our queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then all we have to do is to create and send the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a servlet's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are used to creating web applications using Java EE, you probably will
    have already realized: most of the time it is all about dealing with requests
    and responses and the most popular way to do it is by using the Servlet API.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how the server deals with its life cycles and what
    you should and should not been doing in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, add the proper dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just write this simple servlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once it is deployed to your Java EE server, I suggest you try it using a tool
    such as SoapUI or similar. It will allow you to send requests using `GET`, `POST`,
    `PUT`, and `DELETE`. The browser would only do `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do it, your system log will look just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you undeploy your application it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you pay attention, you will notice that the `init` log will show only after
    your servlet is called for the first time. That's when it is really loaded and
    it is the only time that this method will be called. So if you have some one-shot
    code for this servlet, that's the place to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the `doGet`, `doPost`, `doPut`, and `doDelete` methods, note that
    they were all automatically called by the server based on the request received.
    It's possible thanks to another method implemented by the server called `service`.
  prefs: []
  type: TYPE_NORMAL
- en: You could override the `service` method if you want, but it's a bad practice
    and should be avoided. Do it only if you know exactly what you are doing, otherwise
    you could give the wrong destination to some requests. This chapter is about relying
    on the standards, so why wouldn't you observe them?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `destroy` method being called when your application is
    undeployed. This is like the last breath of your servlet. It is also a bad practice
    to add some code here, as you could prevent some resource from being released,
    and/or run into some process errors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transaction management is one of the trickier subjects in computer science.
    One single wrong line, one unpredicted situation, and your data and/or your user
    will suffer the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: So it would be nice if we could count on the server to do it for us. And most
    of the time we can, so let me show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First add the proper dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a bean that will perform all the transactions we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And a test class to try it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try this test you should see this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we did was mark our bean to hold states and have its transactions
    managed by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens then? If you note, no method that deals with adding or removing
    stuff does any transaction management. But they are still managed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So you have all the transaction intelligence without writing a single line of
    transaction stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will transact even when the bean would releases its resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
