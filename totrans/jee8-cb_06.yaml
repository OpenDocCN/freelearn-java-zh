- en: Reducing the Coding Effort by Relying on Standards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过依赖标准减少编码工作量
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Preparing your application to use a connection pool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备你的应用使用连接池
- en: Using messaging services for asynchronous communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息服务进行异步通信
- en: Understanding a servlet's life cycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解servlet的生命周期
- en: Transaction management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'One of the most important concepts that you need to know about Java EE is:
    it is a standard. If you go to the **Java Community Process** (**JCP**) website,
    you will find the **Java Specification Request** (**JSR**) for the Java EE platform
    (for Version 8 it is JSR 366).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Java EE，你需要了解的最重要概念之一是：它是一个标准。如果你访问**Java社区进程**（**JCP**）网站，你会找到Java EE平台（对于版本8是JSR
    366）的**Java规范请求**（**JSR**）。
- en: A standard... for what? Well, for an application server! For instance, a Java
    EE application server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准...是什么？嗯，对于一个应用服务器！例如，一个Java EE应用服务器。
- en: It means that you can develop your Java EE application knowing it will run in
    an environment that provides a bunch of resources that you can rely on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以开发Java EE应用，知道它将在一个提供了一堆你可以依赖的资源的环境中运行。
- en: It also means you can easily move from one application server to another, as
    long as you stick to the Java EE patterns instead of some vendor-specific feature
    (considered a bad practice). Your application should have the same behavior no
    matter what Java EE-compatible server you are using.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以轻松地从一台应用服务器切换到另一台，只要你坚持使用Java EE模式而不是某些供应商特定的功能（被认为是不良实践）。无论你使用什么Java
    EE兼容服务器，你的应用都应该保持相同的行为。
- en: Oh, yes! Beyond being a standard, Java EE is also a certification. For a Java
    EE server to be considered compatible, it has to pass through a number of tests
    to guarantee it implements every single point of the specification (JSR).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，是的！Java EE不仅是一个标准，还是一个认证。一个Java EE服务器要想被认为兼容，必须通过一系列测试来保证它实现了规范中的每一个点（JSR）。
- en: This amazing ecosystem allows for less coding of your application and gives
    you the chance to focus on what really matters to you or to your client. Without
    a standard environment, you would need to implement your own code for request/response
    management, queues, connection pooling, and other stuff.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令人惊叹的生态系统允许你减少应用的编码量，并给你机会专注于对你或你的客户真正重要的事情。如果没有标准环境，你需要实现自己的代码来管理请求/响应、队列、连接池和其他东西。
- en: You can definitely do it if you want, but you don't have to. Actually you can
    even write your own Java EE application server, if you want to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你当然可以这样做，但你不一定必须这样做。实际上，如果你想的话，甚至可以编写自己的Java EE应用服务器。
- en: Having said that let's move on with the chapter! In the following recipes, you
    are going to learn how to take advantage of some cool features already implemented
    on your favorite Java EE application server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续本章的内容！在接下来的食谱中，你将学习如何利用你最喜欢的Java EE应用服务器上已经实现的一些酷炫功能。
- en: Examples will be based on GlassFish 5 but, as I mentioned before, they should
    have the same behavior for any other compatible implementation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将基于GlassFish 5，但正如我之前提到的，它们应该对任何其他兼容实现都有相同的行为。
- en: Preparing your application to use a connection pool
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的应用使用连接池
- en: One of the first things we should learn in our life, after feeding, is using
    a connection pool. Especially when we are talking about databases. This is the
    case covered here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的一生中，在进食之后，我们应该学习的第一件事就是使用连接池。尤其是在我们谈论数据库时。这正是这里讨论的情况。
- en: Why? Because a connection opened with the database is costly in terms of resources
    used for it. Even worse, if we look closer at the process of opening a new connection,
    it uses a lot of CPU resources, for example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为与数据库打开的连接在资源使用上代价很高。更糟糕的是，如果我们更仔细地看看打开新连接的过程，它会消耗大量的CPU资源，例如。
- en: Maybe it won't make much difference if you have two users using a database with
    a couple of registers in a few tables. But it can start causing trouble if you
    have dozens of users, or if the database is large and gives you sleepless nights
    when you have hundreds of users using a huge database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有两个用户使用包含几个表中的几个记录的数据库，可能不会有太大的区别。但是，如果你有数十个用户，或者数据库很大，当你有数百个用户使用大型数据库时，它可能会开始引起麻烦。
- en: Actually I, myself, saw in the early days of J2EE 1.3 (the year was 2002), a
    performance issue being solved by a connection pool in an application used by
    20 people. There were a few users, but the database was really big and not so
    well-designed (the same for the application, I have to say).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我自己在J2EE 1.3的早期（那一年是2002年），看到有一个由20人使用的应用程序中的连接池解决了性能问题。用户不多，但数据库真的很大，设计得也不是很好（应用程序也是如此，我必须说）。
- en: 'But you may say: why does a connection pool help us with this? Because once
    it is configured, the server will open all the connections you asked for, when
    it is starting up, and will manage them for you.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能想说：为什么连接池能帮助我们解决这个问题？因为一旦配置好，服务器将在启动时打开你请求的所有连接，并为你管理它们。
- en: 'The only thing you have to do is to ask: *"Hey, server! Could you lend me a
    database connection, please?"* and kindly give it back when you are done (which
    means as quickly as possible).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要做的就是问：“嘿，服务器！你能借我一个数据库连接吗？”，用完后（这意味着尽可能快地）友好地归还它。
- en: This recipe will show you how to do it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何操作。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'First, add the right dependency to your project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将正确的依赖项添加到你的项目中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you still haven't downloaded GlassFish 5 to your development environment,
    this is the right time to do it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有将GlassFish 5下载到你的开发环境，现在是做这件事的正确时机。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will begin by configuring our connection pool in GlassFish 5\. Once it is
    up and running, go to this URL:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在GlassFish 5中配置我们的连接池。一旦启动并运行，请访问以下URL：
- en: '`http://localhost:8080`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: 'Now click on the go to the Administration Console link or if you prefer, go
    straight to the URL at:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击“转到管理控制台”链接，或者如果你更喜欢，直接访问以下URL：
- en: '`http://localhost:4848/`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:4848/`'
- en: 'Then follow this path in the left menu:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按照左侧菜单中的以下路径：
- en: Resources | JDBC | JDBC Connection Pools
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 | JDBC | JDBC连接池
- en: 'Click on the New button. It will open the New JDBC Connection Pool page. Fill
    in the fields as described here:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建”按钮。它将打开“新建JDBC连接池”页面。填写字段，如此处所述：
- en: 'Pool Name: `MysqlPool`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池名称：`MysqlPool`
- en: 'Resource Type: `javax.sql.DataSource`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源类型：`javax.sql.DataSource`
- en: 'Database Driver Vendor: `MySql`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库驱动供应商：`MySql`
- en: Of course, you can make your own custom choices, but then we will be following
    different paths!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以根据自己的喜好进行自定义选择，但那时我们将遵循不同的路径！
- en: Click on the Next button. It will open the second step for our pool creation
    process.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮。它将打开我们的池创建过程的第二步。
- en: 'This new page has three sections: General Settings, Pool Settings, and Transaction
    and Additional Properties. For our recipe, we are only dealing with General Settings and
    Additional Properties.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新页面有三个部分：常规设置、池设置和事务及附加属性。对于我们的菜谱，我们只处理常规设置和附加属性。
- en: 'In the General Settings section make sure that DataSource Classname has this
    value selected:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在常规设置部分，确保数据源类名已选择此值：
- en: '`com.mysql.jdbc.jdbc2.optional.MysqlDatasource`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.mysql.jdbc.jdbc2.optional.MysqlDatasource`'
- en: 'Now let''s move to the Additional Properties section. There might be a bunch
    of properties listed, but we will just fill in a few of them:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到附加属性部分。可能会有很多属性列出来，但我们只需填写其中的一些：
- en: 'DatabaseName: `sys`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库名称：`sys`
- en: 'ServerName: `localhost`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器名称：`localhost`
- en: 'User: `root`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户：`root`
- en: 'Password: `mysql`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`mysql`
- en: 'PortNumber: `3306`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口号：`3306`
- en: Click on the Finish button and voilá! Your connection pool is ready... or almost.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“完成”按钮，哇！你的连接池已经准备好了...或者几乎准备好了。
- en: 'You can''t access it until you do one more configuration. In the same menu,
    on the left, following this path:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更多配置之前，你无法访问它。在相同菜单的左侧，按照以下路径：
- en: Resources | JDBC | JDBC Resources
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 | JDBC | JDBC资源
- en: 'Click on the New button and then fill in the fields like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建”按钮，然后填写如下字段：
- en: 'JNDI Name: `jdbc/MysqlPool`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNDI名称：`jdbc/MysqlPool`
- en: 'Pool Name: `MysqlPool`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池名称：`MysqlPool`
- en: 'Now you are good to go! Your connection pool is ready to be used. Let''s build
    a simple application to try it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好了！你的连接池已经准备好使用。让我们构建一个简单的应用程序来测试它：
- en: 'First, we create a class to get a connection from the pool:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个类来从连接池获取连接：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, a class that we will use as a representation of the `sys_config` table
    (MySQL''s system table):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个我们将用作`sys_config`表（MySQL的系统表）表示的类：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we create another class, to create a list based on the data returned from
    the database:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们创建另一个类，根据从数据库返回的数据创建一个列表：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally a servlet that will try them all:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个将尝试所有操作的servlet：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To try it just open this URL in your browser:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试它，只需在浏览器中打开此URL：
- en: '`http://localhost:8080/ch06-connectionpooling/PoolTestServlet`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch06-connectionpooling/PoolTestServlet`'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Deciding how many connections your pool will hold, as well as all the other
    parameters, is an architecture decision made based on a number of factors such
    as the type of data, database design, application and user behavior, and so on.
    We could write a whole book about it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 决定您的连接池将保留多少连接，以及所有其他参数，是基于诸如数据类型、数据库设计、应用程序和用户行为等因素做出的架构决策。我们完全可以写一本书来讨论这个问题。
- en: But if you are starting from scratch and/or still don't need much information,
    consider a number between 10% to 20% of your concurrent users. In other words,
    if your application has, for instance, 100 concurrent users, you should provide
    10 to 20 connections to your pool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您是从零开始，或者仍然不需要太多信息，请考虑一个介于 10% 到 20% 的并发用户数。换句话说，如果您的应用程序有，例如，100 个并发用户，您应该向您的池提供
    10 到 20 个连接。
- en: You will know that your connections aren't enough if some methods are taking
    too much time to get a connection from the pool (it should take no time at all).
    It means that the server has no available connection at that moment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些方法从连接池获取连接所需的时间过长（这应该根本不需要时间），您就会知道您的连接不足。这意味着在那个时刻服务器没有可用的连接。
- en: So, you need to check if there are some methods taking too long to complete,
    or even some part in your code that is not closing the connection (consider what
    gives the connection back to the server). Depending on the issue, it might not
    be a pooling problem but a design one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要检查是否有某些方法执行时间过长，或者您的代码中某些部分没有关闭连接（考虑将连接返回给服务器）。根据问题，这可能不是连接池问题，而是一个设计问题。
- en: 'Another important thing for dealing with connection pools is to use the "try-with-resources"
    statement as we did here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 处理连接池的另一个重要事项是使用我们在这里使用的 "try-with-resources" 语句：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will guarantee that these resources will be properly closed once the method
    is done and also deal with their respective exceptions, also helping you to write
    less code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保证一旦方法执行完毕，这些资源将被正确关闭，并处理它们各自的异常，同时也有助于您编写更少的代码。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See this recipe's full source code at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此处查看此菜谱的完整源代码：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling)
- en: Using messaging services for asynchronous communication
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息服务进行异步通信
- en: The message service, provided in Java EE by the **Java Message Service** (**JMS**)
    API, is one of the most important and versatile features provided by Java EE environments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Java EE 提供的消息服务，通过 **Java 消息服务**（**JMS**）API 实现，是 Java EE 环境提供的重要且多功能特性之一。
- en: It uses the Producer-Consumer approach, where one peer (the Producer) puts a
    message into a queue and another peer (the Consumer) reads the message from there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用生产者-消费者方法，其中一个对等方（生产者）将消息放入队列，另一个对等方（消费者）从那里读取消息。
- en: Both the Producer and Consumer can be different applications, even using different
    technologies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者和消费者可以是不同的应用程序，甚至使用不同的技术。
- en: This recipe will show you how to build a messaging service using GlassFish 5\.
    Each Java EE server has its own way to set up the service, so if are using some
    other implementations, you should take a look at its documentation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何使用 GlassFish 5 构建消息服务。每个 Java EE 服务器都有其设置服务的方式，因此如果您使用其他实现，您应该查看其文档。
- en: On the other hand, the Java EE code generated here will work on any Java EE
    8-compatible implementation. Standard for the win!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这里生成的 Java EE 代码将在任何 Java EE 8 兼容的实现上运行。标准总是胜出！
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First add the proper dependency to your project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向您的项目中添加适当的依赖项：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will begin by configuring our messaging service in GlassFish 5\. Once the
    server is up and running, go to this URL:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在 GlassFish 5 中配置我们的消息服务。一旦服务器启动并运行，请访问以下 URL：
- en: '`http://localhost:8080`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: 'Now click on the go to the Administration Console link or if you prefer, go
    straight to the URL at:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 "转到管理控制台" 链接，或者如果您愿意，可以直接访问以下 URL：
- en: '`http://localhost:4848/`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:4848/`'
- en: 'Then follow this path in the left menu:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后遵循左侧菜单中的此路径：
- en: Resources | JMS Resources | Connection Factories
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 | JMS 资源 | 连接工厂
- en: 'Click on the New button. When the page is opened, fill the General Settings section
    fields like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建”按钮。当页面打开时，填写“常规设置”部分的字段如下：
- en: 'JNDI Name: `jms/JmsFactory`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNDI名称：`jms/JmsFactory`
- en: 'Resource Type: `javax.jms.ConnectionFactory`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源类型：`javax.jms.ConnectionFactory`
- en: We will not touch the Pool Settings section here, so just click on the OK button
    to register your new factory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里触摸“池设置”部分，所以只需点击“确定”按钮来注册你的新工厂。
- en: 'Now follow this path in the left menu:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在左侧菜单中按照以下路径操作：
- en: Resources | JMS Resources | Destination Resources
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 | JMS资源 | 目标资源
- en: 'Click on the New button. When the page is opened, fill the section fields like
    this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建”按钮。当页面打开时，填写如下所示的章节字段：
- en: 'JNDI Name: `jms/JmsQueue`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNDI名称：`jms/JmsQueue`
- en: 'Physical Destination Name: `JmsQueue`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理目标名称：`JmsQueue`
- en: 'ResourceType: `javax.jms.Queue`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源类型：`javax.jms.Queue`
- en: 'Click on the OK button and you are ready! Now you have a connection factory
    to access your JMS server and a queue. So let''s build an application to use it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”按钮，你就准备好了！现在你有一个连接工厂来访问你的JMS服务器和一个队列。所以让我们构建一个应用程序来使用它：
- en: 'First, we create a **message driven bean** (**MDB**) as a listener for any
    message dropped into our queue. This is the Consumer:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个**消息驱动Bean**（**MDB**）作为对我们队列中丢弃的任何消息的监听器。这是消费者：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we define the Producer class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义生产者类：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And a servlet to access the Producer:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及一个用于访问生产者的servlet：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we create a page just to call our servlet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个页面来调用我们的servlet：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now just deploy and run it. Each time you call `QueueSenderServlet` you should
    see something like this on your server log:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需部署并运行它。每次你调用`QueueSenderServlet`时，你应该在你的服务器日志中看到类似以下内容：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Thanks to the standards implemented in the Java EE 8 server, our MDB is 100%
    managed by the container. That''s why we could just refer to the queue without
    looking back:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Java EE 8服务器中实现的标准化，我们的MDB 100%由容器管理。这就是为什么我们只需引用队列而无需回头查看：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could have built a Consumer by our own hands, but it would build three times
    as many code lines and would be synchronous.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自己手动构建一个消费者，但这将需要三倍的代码行数，并且是同步的。
- en: 'We get our container Producer from a session provided by our factory and made
    for our queue:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的工厂提供的会话中获取容器生产者，并为我们的队列创建：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then all we have to do is to create and send the message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需要创建并发送消息：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You could refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在这个配方中查看完整的源代码：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms)
- en: Understanding a servlet's life cycle
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解servlet的生命周期
- en: 'If you are used to creating web applications using Java EE, you probably will
    have already realized: most of the time it is all about dealing with requests
    and responses and the most popular way to do it is by using the Servlet API.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用Java EE创建Web应用程序，你可能已经意识到：大多数时候都是关于处理请求和响应，最流行的方式是通过使用Servlet API。
- en: This recipe will show you how the server deals with its life cycles and what
    you should and should not been doing in your code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示服务器如何处理其生命周期，以及你在代码中应该和不应该做什么。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, add the proper dependency to your project:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将适当的依赖项添加到你的项目中：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Just write this simple servlet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只需编写这个简单的servlet：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once it is deployed to your Java EE server, I suggest you try it using a tool
    such as SoapUI or similar. It will allow you to send requests using `GET`, `POST`,
    `PUT`, and `DELETE`. The browser would only do `GET`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署到你的Java EE服务器上，我建议你使用SoapUI或类似工具尝试它。这将允许你使用`GET`、`POST`、`PUT`和`DELETE`发送请求。浏览器只会做`GET`。
- en: 'If you do it, your system log will look just like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你的系统日志将看起来就像这样：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And if you undeploy your application it will look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你取消部署你的应用程序，它看起来将如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you pay attention, you will notice that the `init` log will show only after
    your servlet is called for the first time. That's when it is really loaded and
    it is the only time that this method will be called. So if you have some one-shot
    code for this servlet, that's the place to do it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意观察，你会注意到`init`日志只有在你的servlet第一次被调用后才会显示。那时它真正被加载，这也是这个方法唯一被调用的时候。所以如果你为这个servlet有一些一次性代码，那就是你该做的。
- en: Talking about the `doGet`, `doPost`, `doPut`, and `doDelete` methods, note that
    they were all automatically called by the server based on the request received.
    It's possible thanks to another method implemented by the server called `service`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`doGet`、`doPost`、`doPut`和`doDelete`方法，请注意，它们都是根据接收到的请求由服务器自动调用的。这是由于服务器实现的一个名为`service`的另一个方法才成为可能的。
- en: You could override the `service` method if you want, but it's a bad practice
    and should be avoided. Do it only if you know exactly what you are doing, otherwise
    you could give the wrong destination to some requests. This chapter is about relying
    on the standards, so why wouldn't you observe them?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以覆盖`service`方法，但这是一种坏习惯，应该避免。只有当你确切知道你在做什么时才这样做，否则你可能会给某些请求错误的地址。这一章是关于依赖标准的，那么为什么你不遵守它们呢？
- en: Finally, we have the `destroy` method being called when your application is
    undeployed. This is like the last breath of your servlet. It is also a bad practice
    to add some code here, as you could prevent some resource from being released,
    and/or run into some process errors.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你的应用程序未部署时，会调用`destroy`方法。这就像是你的servlet的最后一口气。在这里添加一些代码也是一个坏习惯，因为这可能会阻止某些资源被释放，或者遇到一些进程错误。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: You can refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在此处找到此菜谱的完整源代码：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle)
- en: Transaction management
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务管理
- en: Transaction management is one of the trickier subjects in computer science.
    One single wrong line, one unpredicted situation, and your data and/or your user
    will suffer the consequences.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事务管理是计算机科学中比较棘手的话题之一。一行错误，一个不可预测的情况，你的数据和/或你的用户将承受后果。
- en: So it would be nice if we could count on the server to do it for us. And most
    of the time we can, so let me show you how to do it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们可以依赖服务器为我们做这件事，那就太好了。大多数时候我们都可以，所以让我向你展示如何做到这一点。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First add the proper dependency to your project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向你的项目中添加适当的依赖项：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s build a bean that will perform all the transactions we need:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建一个将执行我们所需所有事务的bean：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And a test class to try it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及一个测试类来尝试它：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you try this test you should see this output:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试这个测试，你应该看到以下输出：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we did was mark our bean to hold states and have its transactions
    managed by the server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是标记我们的bean以保持状态，并让服务器管理其事务：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What happens then? If you note, no method that deals with adding or removing
    stuff does any transaction management. But they are still managed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来会发生什么？如果你注意的话，处理添加或删除内容的任何方法都不会进行事务管理。但它们仍然被管理：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So you have all the transaction intelligence without writing a single line of
    transaction stuff.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在不写一行事务代码的情况下拥有所有事务智能。
- en: 'It will transact even when the bean would releases its resources:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使bean会释放其资源，它也会进行事务处理：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to the full source code for this recipe at: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在此处找到此菜谱的完整源代码：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction)
