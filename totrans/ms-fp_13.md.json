["```java\n<a herf=\"link_address\">link_text</a>\n```", "```java\nval target = new URL(\"http://mvnrepository.com/\")\nval res = fetchToDepth(target, 1)\n println(res.take(10).mkString(\"\\n\"))\n println(res.size)\n```", "```java\ndef fetchToDepth(url: URL, depth: Int, visited: Set[URL] = Set()): Set[URL]\n```", "```java\nval links = fetch(url).getOrElse(Set())\n```", "```java\ndef fetch(url: URL): Option[Set[URL]] = Try {\n  Jsoup.connect(url.toString)\n    .get\n    .getElementsByAttribute(\"href\")\n    .asScala.map( h => new URL(url, h.attr(\"href\")) ).toSet\n}.toOption\n```", "```java\nfetch(url).getOrElse(Set())\n```", "```java\ntype A\nval opt: Option[A]\nval default: A\n\nopt match {\n  case Some(x) => x\n  case None => default\n}\n```", "```java\nif (depth > 0) links ++ links\n .filter(!visited(_))\n ./*...*/\n```", "```java\n.toList\n.zipWithIndex\n```", "```java\n.foldLeft(Set[URL]()) { case (accum, (next, id)) =>\n println(s\"Progress for depth $depth: $id of ${links.size}\")\n accum ++ (if (!accum(next)) fetchToDepth(next, depth - 1, accum) else Set())\n }\n```", "```java\n(1 to 10).toList.foldLeft(0) { (total, nextElement) => total + nextElement }\n```", "```java\nelse links\n```", "```java\ndef fetchToDepth(url: URL, depth: Int, visited: Set[URL] = Set()): Set[URL] = {\n    val links = fetch(url).getOrElse(Set())\n\n    if (depth > 0) links ++ links\n      .filter(!visited(_))\n      .toList\n      .zipWithIndex\n      .foldLeft(Set[URL]()) { case (accum, (next, id)) =>\n        println(s\"Progress for depth $depth: $id of ${links.size}\")\n        accum ++ (if (!accum(next)) fetchToDepth(next, depth - 1, accum) else Set())\n      }\n      .toSet\n    else links\n  }\n```", "```java\nval system = ActorSystem(\"PiSystem\")\nval root = system actorOf Worker.workerProps\n\n(root ? Job(new URL(\"http://mvnrepository.com/\"), 1)).onSuccess {\n  case Result(res) =>\n  println(\"Crawling finished successfully\")\n  println(res.take(10).mkString(\"\\n\"))\n  println(res.size)\n\n}\n```", "```java\n(root ? Job(new URL(\"http://mvnrepository.com/\"), 1)).onSuccess {\n```", "```java\ndef receive = awaitingForTasks\n```", "```java\ndef awaitingForTasks: Receive = {\n case Job(url, depth, visited) =>\n replyTo = Some(sender)\n\n val links = fetch(url).getOrElse(Set()).filter(!visited(_))\n buffer = links\n/*...*/\n```", "```java\nif (depth > 0) {\n  println(s\"Processing links of $url, descending now\")\n\n  children = Set()\n  answered = 0\n\n  for { l <- links } dispatch(l, depth - 1, visited ++ buffer)\n  context become processing\n}\n```", "```java\ndef dispatch(lnk: URL, depth: Int, visited: Set[URL]): Unit = {\n  val child = context actorOf Worker.workerProps\n  children += child\n  child ! Job(lnk, depth, visited)\n}\n```", "```java\nelse {\n println(s\"Reached maximal depth on $url - returning its links only\")\n sender ! Result(buffer)\n context stop self\n}\n```", "```java\ndef processing: Receive = {\n  case Result(urls) =>\n    replyTo match {\n      case Some(to) =>\n        answered += 1\n        println(s\"$self: $answered actors responded of ${children.size}\")\n        buffer ++= urls\n        if (answered == children.size) {\n          to ! Result(buffer)\n          context stop self\n        }\n\n      case None => println(\"replyTo actor is None, something went wrong\")\n    }\n}\n```", "```java\nval links = fetch(url).getOrElse(Set()).filter(!visited(_))\n```", "```java\nanswered += 1\n// ...\nif (answered == children.size) {\n  to ! Result(buffer)\n  context stop self\n}\n```", "```java\nif (answered == children.size)\n```"]