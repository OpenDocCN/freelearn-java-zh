<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;A Functional-style REST Service with Finagle and Finch"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. A Functional-style REST Service with Finagle and Finch</h1></div></div></div><p class="calibre7">In this chapter, we're going to show you how you can create a REST service using the Finagle <a id="id62" class="calibre1"/>and Finch library. We'll do this using the following set of examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Your first Finagle and Finch service</strong></span>: In this section, we'll create a minimal REST service, which will simply return a string.</li><li class="listitem"><span class="strong"><strong class="calibre8">HTTP verb and URL matching</strong></span>: An important part of any REST service is how to handle various URL paths and the different HTTP verbs. In this part, we'll show you how Finch supports this through the use of matchers and extractors.</li><li class="listitem"><span class="strong"><strong class="calibre8">Use RequestReaders to process incoming requests</strong></span>: When creating a REST service, you usually need to get information from the incoming HTTP request. Finch uses <code class="email">RequestReader</code> instances to access information from the request, which we'll explain in this part.</li><li class="listitem"><span class="strong"><strong class="calibre8">JSON support</strong></span>: REST services most often use JSON to represent resources. Finch supports a number of different JSON libraries. In this part, we'll explore one of these JSON libraries and how to use it from a Finch service.</li><li class="listitem"><span class="strong"><strong class="calibre8">Request validation and custom responses</strong></span>: The final part of this chapter deals with validating incoming requests and creating custom responses. Finch has a very elegant way, using <code class="email">RequestReader</code> instances and validation rules, to check whether incoming requests are valid and can be processed further.</li></ul></div><p class="calibre7">Before we start looking at the code, let's quickly look at what Finagle and Finch are for libraries.</p></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;A Functional-style REST Service with Finagle and Finch">
<div class="book" title="An introduction to Finagle and Finch"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec15" class="calibre1"/>An introduction to Finagle and Finch</h1></div></div></div><p class="calibre7">Finagle and <a id="id63" class="calibre1"/>Finch are actually two different frameworks. Finagle is an RPC framework, created by Twitter, which you can use to easily create different types<a id="id64" class="calibre1"/> of service. On its website (<a class="calibre1" href="https://github.com/twitter/finagle">https://github.com/twitter/finagle</a>), the team behind Finagle explains it like this:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre24"><span class="strong"><em class="calibre9">"Finagle is an extensible RPC system for the JVM, used to construct high-concurrency servers. Finagle implements uniform client and server APIs for several protocols, and is designed for high performance and concurrency. Most of Finagle's code is protocol agnostic, simplifying the implementation of new protocols."</em></span></p></blockquote></div><p class="calibre7">So, while Finagle provides the plumbing required to create highly scalable services, it doesn't provide direct support for specific protocols. This is where Finch comes in.</p><p class="calibre7">Finch (<a class="calibre1" href="https://github.com/finagle/finch">https://github.com/finagle/finch</a>) provides an HTTP REST layer on top of Finagle. On<a id="id65" class="calibre1"/> their website, you can find a nice quote which summarizes<a id="id66" class="calibre1"/> what Finch aims to do:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre24"><span class="strong"><em class="calibre9">"Finch is a thin layer of purely functional basic blocks atop of <a class="calibre1" href="http://twitter.github.io/finagle">http://twitter.github.io/finagle</a> for building composable REST APIs. Its mission is to provide the developers simple and robust REST API primitives being as close as possible to the bare metal Finagle API."</em></span></p></blockquote></div><p class="calibre7">In this chapter, we'll only be talking about Finch. Note, though, that most of the concepts provided by Finch are based on underlying Finagle ideas. Finch provides a very nice REST-based set of functions to make working with Finagle very easy and intuitive.</p></div></div>
<div class="book" title="Building your first Finagle and Finch REST service"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Building your first Finagle and Finch REST service</h1></div></div></div><p class="calibre7">Let's <a id="id67" class="calibre1"/>start by building a minimal Finch REST service. The <a id="id68" class="calibre1"/>first thing we need to do is make sure we have the correct dependencies. Like we mentioned in the previous chapter, we use SBT to manage our dependencies. All the dependencies for the various chapters can be found in the <code class="email">Dependencies.scala</code> file, which is located in the <code class="email">project</code> directory in the location where you extracted your sources. For the Finch examples, which we will see in this chapter, we use the following dependencies:</p><div class="informalexample"><pre class="programlisting">  lazy val finchVersion = "0.7.0"

  val backendDeps = Seq(
    "com.github.finagle" %% "finch-core" % finchVersion
  )</pre></div><p class="calibre7">This book uses a single SBT file (<code class="email">build.sbt</code> located in the root) for all the chapters and uses a multimodule approach. Diving into the multimodule setup is a bit beyond the scope of this book. If you want to learn more about how we use SBT to manage and define the various modules, look at the <code class="email">build.sbt</code> file.</p><p class="calibre7">Now<a id="id69" class="calibre1"/> that we've got our library dependencies loaded, we can start coding our very first Finch service. The next code fragment (the source can be found at <code class="email">chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala</code>) shows<a id="id70" class="calibre1"/> a minimal Finch service, which just responds with a <code class="email">Hello, Finch!</code> message:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter2.gettingstarted

import io.finch.route._
import com.twitter.finagle.Httpx

object HelloFinch extends App {

  Httpx.serve(":8080", (Get / "hello" /&gt; "Hello, Finch!").toService)

  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar
}</pre></div><p class="calibre7">When this service receives a <code class="email">GET</code> request on the URL path, <code class="email">hello</code>, it will respond with a <code class="email">Hello, Finch!</code> message. Finch does this by creating a service (using the <code class="email">toService</code> function) from a route (more on routes is explained in the next section) and using the <code class="email">Httpx.serve</code> function to host the created service. To run this example, open a terminal window in the directory where you've extracted the sources. In that directory, run the <code class="email">sbt runCH02-HelloFinch</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH02-HelloFinch</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter2.gettingstarted.HelloFinch </strong></span>
<span class="strong"><strong class="calibre8">Jun 26, 2015 9:38:00 AM com.twitter.finagle.Init$$anonfun$1 apply$mcV$sp</strong></span>
<span class="strong"><strong class="calibre8">INFO: Finagle version 6.25.0 (rev=78909170b7cc97044481274e297805d770465110) built at 20150423-135046</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">At this point, we have an HTTP server running on port <code class="email">8080</code>. When we make a call to <code class="email">http://localhost:8080/hello</code>, this server will respond with the <code class="email">Hello, Finch!</code> message. To test this service, we've provided an HTTP request in Postman (see the previous chapter<a id="id71" class="calibre1"/> on how to install Postman and load requests). You <a id="id72" class="calibre1"/>can use the <code class="email">GET Hello Finch</code> request to test the Finch service we just created:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Building your first Finagle and Finch REST service" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="HTTP verb and URL matching"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>HTTP verb and URL matching</h1></div></div></div><p class="calibre7">An <a id="id73" class="calibre1"/>important part of every REST framework is the ability <a id="id74" class="calibre1"/>to easily match HTTP verbs and the various path segments of the URL. In this section, we'll look at the tools Finch provide us with. Let's start with getting the service up and running though. To run this service, you can use the <code class="email">sbt runCH02-runCH02Step1</code> command from the source directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH02-runCH02Step1</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter2.steps.FinchStep1 </strong></span>
<span class="strong"><strong class="calibre8">Jun 26, 2015 10:19:11 AM com.twitter.finagle.Init$$anonfun$1 apply$mcV$sp</strong></span>
<span class="strong"><strong class="calibre8">INFO: Finagle version 6.25.0 (rev=78909170b7cc97044481274e297805d770465110) built at 20150423-135046</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Once the server is started, you can once again use Postman to make requests to this service, using<a id="id75" class="calibre1"/> the requests from the <span class="strong"><strong class="calibre8">Chapter 02</strong></span> collection. This service just returns a simple text message on each request:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="HTTP verb and URL matching" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Now let's <a id="id76" class="calibre1"/>look at some code and see how to do this with Finch (<code class="email">chapter-02/src/main/scala/org/restwithscala/chapter2/steps/FinchStep1.scala</code>):</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter2.steps

import com.twitter.finagle.Httpx
import io.finch.request._
import io.finch.route._
import io.finch.{Endpoint =&gt; _}

object FinchStep1 extends App {

  // handle a single post using a RequestReader
  val taskCreateAPI = Post / "tasks" /&gt; (
    for {
      bodyContent &lt;- body
    } yield s"created task with: $bodyContent")

  // Use matchers and extractors to determine which route to call
  // For more examples, see the source file.
  val taskAPI = Get / "tasks" /&gt;
            "Get a list of all the tasks" | Get / "tasks" / long /&gt;
            ( id =&gt; s"Get a single task with id: $id" ) | Put / "tasks" / long /&gt;
            ( id =&gt; s"Update an existing task with id  $id to " ) | Delete / "tasks" / long /&gt;
            ( id =&gt; s"Delete an existing task with $id" )
     
     
  // a simple server that combines the two routes
  val server = Httpx.serve(":8080", 
            (taskAPI :+: taskCreateAPI).toService )

  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar

  server.close()
}</pre></div><p class="calibre7">In this<a id="id77" class="calibre1"/> code fragment, we create a number of <code class="email">Router</code> instances<a id="id78" class="calibre1"/> that process the requests which we sent from Postman. Let's start by looking at one of the routes of the <code class="email">taskAPI</code> router, <code class="email">Get / "tasks" / long /&gt; (id =&gt; s"Get a single task with id: $id")</code>. The following table explains the various parts of the route:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Part</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Get</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">When<a id="id79" class="indexterm"/> writing routers, usually the first thing you do is determine which HTTP verb you want to match. In this case, this route will only match the <code class="literal">GET</code> verb. Besides the <code class="literal">Get</code> matcher, Finch also provides other matchers such as <code class="literal">Post</code>, <code class="literal">Patch</code>, <code class="literal">Delete</code>, <code class="literal">Head</code>, <code class="literal">Options</code>, <code class="literal">Put</code>, <code class="literal">Connect</code>, and <code class="literal">Trace</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">"tasks"</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The <a id="id80" class="indexterm"/>next part of the route is a matcher that matches a URL path segment. In this case, we match the URL, <code class="literal">http://localhost:8080/tasks</code>. Finch will use an implicit conversion to convert this string object to a finch <code class="literal">Matcher</code> object. Finch also has two wildcard matchers: <code class="literal">*</code> and <code class="literal">**</code>. The <code class="literal">*</code> matcher allows any value for a single path segment, and the <code class="literal">**</code> matcher allows any value for multiple path segments.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">long</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The<a id="id81" class="indexterm"/> next part in the route is called an <span><strong class="calibre25">extractor</strong></span>. With an extractor, you turn part of the URL into a value which you can use to create the response (for example, retrieve an object from the database using the extracted ID). The <code class="literal">long</code> extractor, as the name implies, converts the matching path segment to a long value. Finch also provides an int, string, and boolean extractor.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">long =&gt; B</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The <a id="id82" class="indexterm"/>last part of the route is used to create the response message. Finch provides different ways of creating the response, which we'll show in the other parts of this chapter. In this case, we need to provide Finch with a function that transforms the long value we extracted, and returns a value Finch can convert to a response (you will learn more on this later). In this example, we just return a string.</p>
</td></tr></tbody></table></div><p class="calibre7">If you've looked <a id="id83" class="calibre1"/>closely at the source code, you probably <a id="id84" class="calibre1"/>have noticed that Finch uses custom operators to combine the various parts of a route. Let's look a bit closer at these. With Finch, we get<a id="id85" class="calibre1"/> the following operators (also called <span class="strong"><strong class="calibre8">combinators</strong></span> in Finch terms):</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">/</code> or <code class="email">andThen</code>: With this combinator, you sequentially combine various matchers and extractors. Whenever the first part matches, the next one is called, for instance, <code class="email">Get / "path" / long</code>.</li><li class="listitem"><code class="email">|</code> or <code class="email">orElse</code>: This combinator allows you to combine two routers (or parts thereof) as long as they are of the same type. So, we could do <code class="email">(Get | Post)</code> to create a matcher, which matches the <code class="email">GET</code> and <code class="email">POST</code> HTTP verbs. In the code sample, we've also used this to combine all the routes that returned a simple string to the <code class="email">taskAPI</code> router.</li><li class="listitem"><code class="email">/&gt;</code> or <code class="email">map</code>: With this combinator, we pass the request and any extracted values from the path to a function for further processing. The result of the function that is called is returned as the HTTP response. As you'll see in the rest of the chapter, there are different ways of processing the HTTP request and creating a response.</li><li class="listitem"><code class="email">:+:</code>: The final combinator allows you to combine two routers together of different types. In the example, we have two routers: <code class="email">taskAPI</code>, which returns a simple string, and <code class="email">taskCreateAPI</code>, which uses a <code class="email">RequestReader</code> object (through the <code class="email">body</code> function), to create the response. We can't combine these with <code class="email">|</code> since the result is created using two different approaches, so we use the <code class="email">:+:</code> combinator.</li></ul></div><p class="calibre7">So far, we just return simple strings whenever we get a request. In the next section, we'll look at how you can use a <code class="email">RequestReader</code> instance to convert the incoming HTTP requests to case classes and use those to create an HTTP response.</p></div>
<div class="book" title="Processing incoming requests using RequestReaders"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Processing incoming requests using RequestReaders</h1></div></div></div><p class="calibre7">So far, we <a id="id86" class="calibre1"/>haven't done anything yet with the incoming request. In the previous example, we just returned a string without using any information from the request. Finch provides a very nice model using a <span class="strong"><strong class="calibre8">Reader monad</strong></span>, which<a id="id87" class="calibre1"/> you can use to easily combine information from an incoming request to instantiate new objects.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre7">A Reader monad is a standard functional design pattern, which allows you to define functions that all access the same values. A great explanation of how Reader<a id="id88" class="calibre1"/> monads work can be found at <a class="calibre1" href="http://eed3si9n.com/learning-scalaz/Monad+transformers.html">http://eed3si9n.com/learning-scalaz/Monad+transformers.html</a>.</p></div><p class="calibre7">Let's<a id="id89" class="calibre1"/> look at some code that uses a <code class="email">RequestReader</code> to process incoming requests (the complete source code can be found in the <code class="email">FinchStep2.scala</code> file):</p><div class="informalexample"><pre class="programlisting">object FinchStep2 extends App {

  val matchTask: Matcher = "tasks"
  val matchTaskId = matchTask / long

  // handle a single post using a RequestReader
  val taskCreateAPI =
        Get / matchTask /&gt; GetAllTasks() :+:
       Post / matchTask /&gt; CreateNewTask() :+:
     Delete / matchTaskId /&gt; DeleteTask :+:
        Get / matchTaskId /&gt; GetTask :+:
        Put / matchTaskId /&gt; UpdateTask

  val taskAPI = ...
        

  val server = Httpx.serve(":8080", 
                          (taskAPI :+: taskCreateAPI).toService )

  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar

  server.close()

  sealed trait BaseTask {

    def getRequestToTaskReader(id: Long): RequestReader[Task] = {
      ( RequestReader.value(id) :: 
        param("title") :: 
        body :: 
        RequestReader.value(None:Option[Person]) ::
        RequestReader.value(List.empty[Note]) ::
        RequestReader.value(Status(""))
        ).as[Task]
    }
  }

  case class CreateNewTask() extends Service[Request, String] 
                                                   with BaseTask {

    def apply(req: Request): Future[String] = {
      val p = for {
        task &lt;- getRequestToTaskReader(-1)(req)
        stored &lt;- TaskService.insert(task)
      } yield stored

      p.map(_.toString)
    }
  }

  case class DeleteTask(id: Long) 
                          extends Service[Request, HttpResponse] {

    def apply(req: Request): Future[HttpResponse] = 
      TaskService.delete(id).map {
        case Some(task) =&gt; Ok()
        case None =&gt; NotFound()
      }
  }

  case class GetAllTasks() extends Service[Request, HttpResponse] {

    def apply(req: Request): Future[HttpResponse] = {
      for {
        tasks &lt;- TaskService.all
      } yield Ok(tasks.mkString(":"))
    }
  }

  case class GetTask(taskId: Long) 
                           extends Service[Request, HttpResponse] {
    def apply(req: Request): Future[HttpResponse] = {
      TaskService.select(taskId).map {
        case Some(task) =&gt; Ok(task.toString)
        case None =&gt; NotFound()
      }
    }
  }

  case class UpdateTask(taskId: Long) 
             extends Service[Request, HttpResponse] with BaseTask {
    def apply(req: Request): Future[HttpResponse] =
      for {
        task &lt;- getRequestToTaskReader(taskId)(req)
        stored &lt;- TaskService.update(task)
      } yield stored match {
        case Some(task) =&gt; Ok(task.toString)
        case None =&gt; NotFound()
      }
  }
}</pre></div><p class="calibre7">In<a id="id90" class="calibre1"/> this code, we see a couple of new things. Instead of directly returning a string value, we use a case class that extends from <code class="email">Service</code> to process the HTTP request and create a response. You can also run this service directly from SBT. Running the <code class="email">sbt runCH02-runCH02Step2</code> command will start up the service:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH02-runCH02Step2</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Compiling 1 Scala source to /Users/jos/dev/git/rest-with-scala/chapter-02/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter2.steps.FinchStep2 </strong></span>
<span class="strong"><strong class="calibre8">Jun 27, 2015 10:26:49 AM com.twitter.finagle.Init$$anonfun$1 apply$mcV$sp</strong></span>
<span class="strong"><strong class="calibre8">INFO: Finagle version 6.25.0 (rev=78909170b7cc97044481274e297805d770465110) built at 20150423-135046</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">You can test this service once again using Postman. Let's start by testing whether we can create a new task. To do this, open up Postman and fire off the request <span class="strong"><strong class="calibre8">Step 02 – Create Task</strong></span>:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Processing incoming requests using RequestReaders" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The<a id="id91" class="calibre1"/> response we get back starts to look similar to real data. The text we entered in <code class="email">body</code> as well as the <code class="email">title</code> request parameter is used.</p><p class="calibre7">Let's look at the router we used to create a new task in detail to see how this works:</p><div class="informalexample"><pre class="programlisting">  val matchTask: Matcher = "tasks"
  val taskCreateAPI = Post / matchTask /&gt; CreateNewTask()
      
  ...
    
  sealed trait BaseTask {

    def getRequestToTaskReader(id: Long): RequestReader[Task] = {
      ( RequestReader.value(id) :: 
        param("title") :: 
        body :: 
        RequestReader.value(None:Option[Person]) ::
        RequestReader.value(List.empty[Note]) ::
        RequestReader.value(Status(""))
        ).as[Task]
    }
  }

  case class CreateNewTask() extends Service[Request, String] 
                                                   with BaseTask {

    override def apply(req: Request): Future[String] = {
      val p = for {
        task &lt;- getRequestToTaskReader(-1)(req)
        stored &lt;- TaskService.insert(task)
      } yield stored

      p.map(_.toString)
    }
  }</pre></div><p class="calibre7">At the <a id="id92" class="calibre1"/>top of this code fragment, you can see how we define the router that handles the create task request we just made through Postman. Whenever a <code class="email">POST</code> request is made to the <code class="email">tasks</code> URL, this router matches and maps the request to the function to the right of the <code class="email">/&gt;</code> combinator. This time, however, we don't map to a function that returns a string, but we map to a case class that extends from <code class="email">Service</code>. In our own class, we have to implement the <code class="email">def apply(request: Req): Future[Rep]</code> function from the abstract <code class="email">Service</code> class. In this specific example, we specified the type parameters for this service as <code class="email">Request</code> and <code class="email">String</code>, so the <code class="email">apply</code> function should transform the incoming <code class="email">Request</code> instance to a <code class="email">Future[String]</code> object.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre7">As the first type parameter, you normally specify <code class="email">Request</code> (unless you apply filters before processing the request, as we'll explain in the last part of this chapter), and the second type parameter should be a type, which Finch can automatically convert to an HTTP response. To automatically convert, Finch looks for an implicit <code class="email">EncodeResponse[A]</code> type-class in scope. Out of the box, Finch will transform strings to HTTP responses. It also supports a number of JSON libraries, where case classes are automatically converted to HTTP responses with JSON bodies.</p></div><p class="calibre7">In the service for this route, we take a couple of steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we call the <code class="email">getRequestToTaskReader</code> function defined in the base class, with the ID of the task we want to create. Since we're creating a new one, we just specify <code class="email">-1</code> as the ID and let the backend generate a real ID. The result from this call is a <code class="email">RequestReader[Task]</code> instance, which can convert a request into a <code class="email">Task</code> class.</li><li class="listitem" value="2">We then directly call the <code class="email">apply</code> function on the returned <code class="email">RequestReader[Task]</code> instance with the passed in request. This call returns a <code class="email">Future[Task]</code> object, which we process further in the <code class="email">for</code> comprehension.</li><li class="listitem" value="3">When the future from step 2 resolves, we have access to a task. We store this task using the <code class="email">TaskService.insert</code> method. This call also returns a <code class="email">Future</code>.</li><li class="listitem" value="4">Finally, we yield the stored <code class="email">Task</code> object, as a <code class="email">Future[Task]</code> instance.</li><li class="listitem" value="5">The last step in the service is converting the <code class="email">Future[Task]</code> object to a <code class="email">Future[String]</code> object, which we just do by using a simple <code class="email">map</code> function. The reason we need to do this is because Finch doesn't know how to automatically convert <code class="email">Task</code> objects to an HTTP response.</li></ol><div class="calibre13"/></div><p class="calibre7">Before <a id="id93" class="calibre1"/>we move on to the next section, let's look a bit closer at the <code class="email">RequestReader[Task]</code> instance we used to convert a <code class="email">Request</code> object to a Task object:</p><div class="informalexample"><pre class="programlisting">    def getRequestToTaskReader(id: Long): RequestReader[Task] = {
      ( RequestReader.value(id) :: 
        param("title") :: 
        body :: 
        RequestReader.value(Option.empty[Person]) ::
        RequestReader.value(List.empty[Note]) ::
        RequestReader.value(Status(""))
        ).as[Task]
    }</pre></div><p class="calibre7">In this function, we combine various RequestReader (<code class="email">body</code>, <code class="email">param</code>, and <code class="email">RequestReader.value</code>) using the <code class="email">::</code> combinator (we'll explain more about <code class="email">body</code>, <code class="email">param</code>, and <code class="email">RequestReader.value</code> in the next section). When we pass in a <code class="email">Request</code> to the result of this function, each <code class="email">RequestReader</code> is executed against the request. The result of all these individual steps is combined using the <code class="email">as[A]</code> function (you can also use <code class="email">asTuple</code> to collect the results). Finch standard supports conversion to int, long, float, double, and boolean, and also allows you to convert to a case class. In this last case, you have to make sure the result from the individual <code class="email">RequestReader</code> matches the constructor of your case class. In this example, <code class="email">Task</code> is defined like this:</p><div class="informalexample"><pre class="programlisting">case class Task(id: Long, title: String, content: String, 
                assignedTo: Option[Person], notes: List[Note],
                status: Status)</pre></div><p class="calibre7">And this matches the results of the individual RequestReaders. Should you want to convert to a type that isn't supported, you can very simply write your own, and just make sure it is in scope:</p><div class="informalexample"><pre class="programlisting">implicit val moneyDecoder: DecodeRequest[Money] = 
         DecodeRequest(s =&gt; Try(new Money(s.toDouble)))</pre></div><p class="calibre7">In the example code so far, we've only used a couple of RequestReaders: <code class="email">param</code> and <code class="email">body</code>. Finch provides a number of other readers you can use to access information from the HTTP request:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Reader</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">param(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id94" class="indexterm"/> returns the request parameter as a string and throws a <code class="literal">NotPresent</code> exception when the parameter can't be found.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">paramOption(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the<a id="id95" class="indexterm"/> request parameter as an <code class="literal">Option[String]</code> object. This call will always succeed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">paramsNonEmpty(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a multivalue parameter as a <code class="literal">Seq[String]</code> object. If the parameter can't be found, a <code class="literal">NotPresent</code> exception is thrown.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">params(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a multivalue parameter (for example, <code class="literal">?id=1,2,3&amp;b=1&amp;b=2</code>) as a <code class="literal">Seq[String]</code> object. If the parameter can't be found, an empty list is returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">header(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a request header with the specified name as a string and throws a <code class="literal">NotPresent</code> exception when the header can't be found.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">headerOption(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a request header with the specified name as an <code class="literal">Option[String]</code> object. This call will always succeed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">cookie(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets a <code class="literal">Cookie</code> object from the request. If the specified cookie isn't present, a <code class="literal">NotPresent</code> exception is thrown.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">cookieOption(name)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets a <code class="literal">Cookie</code> object from the request. This call will always succeed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">body</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the request body name as a string and throws a <code class="literal">NotPresent</code> exception when there is no body present.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">bodyOption</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the body as an <code class="literal">Option[String]</code> object. This call will always succeed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">binaryBody</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the request body name as an <code class="literal">Array[Byte]</code> object and throws a <code class="literal">NotPresent</code> exception when there is no body present.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">binaryBodyOption</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the body as an <code class="literal">Option[Array[Byte]]</code> object. This call will always succeed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">fileUpload</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <code class="literal">RequestReader</code> reads an upload (a multipart/form) parameter from the request and throws a <code class="literal">NotPresent</code> exception when the upload can't be found.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">fileUploadOption</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <code class="literal">RequestReader</code> reads an upload (a multipart/form) parameter from the request. This call will always succeed.</p>
</td></tr></tbody></table></div><p class="calibre7">As you can see from this table, a large number of RequestReaders types are already available, and in most cases, this should be enough to handle your requirements. If the <code class="email">RequestReader</code> object does not provide the required functionality, a number of helper functions <a id="id96" class="calibre1"/>are available that you can use to create your own<a id="id97" class="calibre1"/> custom <code class="email">RequestReader</code>:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Function</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">value[A](value: A): </code></p>
<p class="calibre21"><code class="literal">    RequestReader[A]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This function creates a <code class="literal">RequestReader</code> instance that always succeeds and returns the specified value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">exception[A](exc: Throwable): </code></p>
<p class="calibre21"><code class="literal">    RequestReader[A]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This function creates a <code class="literal">RequestReader</code> instance that always fails with the specified exception.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">const[A](value: Future[A]): </code></p>
<p class="calibre21"><code class="literal">    RequestReader[A]  </code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <code class="literal">RequestReader</code> will just return the specified value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">apply[A](f: HttpRequest =&gt; A):</code></p>
<p class="calibre21"><code class="literal">    RequestReader[A]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This function returns a <code class="literal">RequestReader</code> instance that applies the provided function.</p>
</td></tr></tbody></table></div><p class="calibre7">There<a id="id98" class="calibre1"/> is one part of the <code class="email">RequestReader</code> that we haven't discussed yet. What happens when a <code class="email">RequestReader</code> fails? Finch has a very elegant mechanism to handle these validation errors. We'll come back to that in the last part of this chapter.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="JSON support"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>JSON support</h1></div></div></div><p class="calibre7">So far, we've just <a id="id99" class="calibre1"/>worked with plain strings as responses. In this section, we'll expand the previous sample and add JSON support and show you how you can control which HTTP response code should be used when handling a request. Using JSON<a id="id100" class="calibre1"/> with Finch is very straightforward since Finch already supports a number of JSON <a id="id101" class="calibre1"/>libraries<a id="id102" class="calibre1"/> out of the box:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Argonaut (<a class="calibre1" href="http://argonaut.io/">http://argonaut.io/</a>).</li><li class="listitem">Jackson (<a class="calibre1" href="https://github.com/FasterXML/Jackson">https://github.com/FasterXML/Jackson</a>)</li><li class="listitem">Json4s (<a class="calibre1" href="http://json4s.org/">http://json4s.org/</a>)</li></ul></div></div>

<div class="book" title="JSON support">
<div class="book" title="Argonaut"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec18" class="calibre1"/>Argonaut</h2></div></div></div><p class="calibre7">In this<a id="id103" class="calibre1"/> section, we'll look at how to use the Argonaut library to<a id="id104" class="calibre1"/> automatically convert our model (our case classes) to JSON. Should you want to use one of the other libraries, they work in pretty much the same manner.</p><p class="calibre7">We'll start by looking at the request and response message that our service should work with for this scenario. First, start up the server using the <code class="email">sbt runCH02-runCH02Step3</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH02-runCH02Step3</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter2.steps.FinchStep3 </strong></span>
<span class="strong"><strong class="calibre8">Jun 27, 2015 1:58:20 PM com.twitter.finagle.Init$$anonfun$1 apply$mcV$sp</strong></span>
<span class="strong"><strong class="calibre8">INFO: Finagle version 6.25.0 (rev=78909170b7cc97044481274e297805d770465110) built at 20150423-135046</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">When<a id="id105" class="calibre1"/> the server is started, open Postman and select the request <span class="strong"><strong class="calibre8">Step 03 – Create Task</strong></span> from the <span class="strong"><strong class="calibre8">Chapter 02</strong></span> collection. When you send this request, the <a id="id106" class="calibre1"/>server will parse this to a case class, store it, and return the stored task once again as JSON.</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Argonaut" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If you <a id="id107" class="calibre1"/>send the message a couple of times, you'll notice that the ID <a id="id108" class="calibre1"/>of the response increases. The reason is that we generate a new ID for newly created tasks, so ignore the ID from the incoming JSON message.</p><p class="calibre7">Once you've created a number of new tasks, you can also get all the stored tasks by using the <span class="strong"><strong class="calibre8">Step 03 – Get Tasks</strong></span> request:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Argonaut" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">When<a id="id109" class="calibre1"/> you've<a id="id110" class="calibre1"/> stored a number of messages, you can also use the API to delete tasks. Click on <span class="strong"><strong class="calibre8">Step 02 – Delete Task</strong></span>, change the URL to the ID you want to delete (for example, <code class="email">http://localhost:8080/tasks/3</code>):</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Argonaut" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If the<a id="id111" class="calibre1"/> task with the ID you want to delete exists, it will return <span class="strong"><strong class="calibre8">200 Ok</strong></span>, if the ID doesn't exist, you'll see <span class="strong"><strong class="calibre8">404 Not Found</strong></span>.</p><p class="calibre7">To get <a id="id112" class="calibre1"/>this working, the first thing we need to do is get the required Argonaut dependencies. For this, we change the dependencies in our SBT build to this:</p><div class="informalexample"><pre class="programlisting">  lazy val finchVersion = "0.7.0"

  val backendDeps = Seq(
    "com.github.finagle" %% "finch-core" % finchVersion,
    "com.github.finagle" %% "finch-argonaut" % finchVersion
  )</pre></div></div></div>

<div class="book" title="JSON support">
<div class="book" title="Jackson and Json4s"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec19" class="calibre1"/>Jackson and Json4s</h2></div></div></div><p class="calibre7">For <a id="id113" class="calibre1"/>Jackson<a id="id114" class="calibre1"/> and Json4s, you use the <code class="email">finch-jackson</code> and <code class="email">finch-json4s</code> modules instead.</p><p class="calibre7">To <a id="id115" class="calibre1"/>automatically convert our case classes to and from JSON, we<a id="id116" class="calibre1"/> need to tell Argonaut how we can convert to our case classes and vice versa. For our example, we've done this in the <code class="email">chapter2</code> package object (located in the <code class="email">package.scala</code> file):</p><div class="informalexample"><pre class="programlisting">implicit def personDecoding: DecodeJson[Person] = jdecode1L(Person.apply)("name")

implicit def personEncoding: EncodeJson[Person] = jencode1L((u: Person) =&gt; (u.name))("name")

implicit def statusDecoding: DecodeJson[Status] = jdecode1L(Status.apply)("status")

implicit def statusEncoding: EncodeJson[Status] = jencode1L((u: Status) =&gt; (u.status))("status")

implicit def noteDecoding: DecodeJson[Note] = jdecode2L(Note.apply)("id", "content")

implicit def noteEncoding: EncodeJson[Note] = jencode2L((u: Note) =&gt; (u.id, u.content))("id", "content")

implicit def taskDecoding: DecodeJson[Task] = jdecode6L(Task.apply)
    ("id", "title", "content", "assignedTo", "notes", "status") 
implicit def taskEncoding: EncodeJson[Task] = jencode6L( (u: Task) =&gt; (u.id, u.title, u.content,
                u.assignedTo, u.notes, u.status))
  ("id", "title", "content", "assignedTo", "notes", "status" )</pre></div><p class="calibre7">For each <a id="id117" class="calibre1"/>of the <a id="id118" class="calibre1"/>case classes we want to support, we need a set <a id="id119" class="calibre1"/>of implicit values. To convert from<a id="id120" class="calibre1"/> JSON, we need a <code class="email">DecodeJson[A]</code> instance and to convert to JSON, a <code class="email">EncodeJson[A]</code> instance. Argonaut already provides some helper methods you can use to easily create these instances, which we've used in the previous example. For instance, with <code class="email">jdecode2L</code> (the <code class="email">2</code> stands for two arguments), we convert two JSON values to a case class, and with <code class="email">jencode2L</code>, we convert two parameters of a case class to JSON. To<a id="id121" class="calibre1"/> learn more about Argonaut, you can look at its website at <a class="calibre1" href="http://argonaut.io/">http://argonaut.io/</a>; the part that deals with automatic conversion (as explained here) can<a id="id122" class="calibre1"/> be found at <a class="calibre1" href="http://argonaut.io/doc/codec/">http://argonaut.io/doc/codec/</a>.</p><p class="calibre7">Now that we've defined the mapping between JSON and the case classes we're using, we can look at how this changes our implementation. In the following code fragment, we see the code that handles the <span class="strong"><strong class="calibre8">Create Task</strong></span>, <span class="strong"><strong class="calibre8">Delete Task</strong></span>, and <span class="strong"><strong class="calibre8">Get Tasks</strong></span> requests:</p><div class="informalexample"><pre class="programlisting">val matchTask: Matcher = "tasks"
val matchTaskId = matchTask / long

val taskCreateAPI =
        Get / matchTask /&gt; GetAllTasks() :+:
       Post / matchTask /&gt; CreateNewTask() :+:
     Delete / matchTaskId /&gt; DeleteTask 

  ...


  case class CreateNewTask() extends Service[Request, HttpResponse] {

    def apply(req: Request): Future[HttpResponse] = {
      for {
        task &lt;- body.as[Task].apply(req)
        stored &lt;- TaskService.insert(task)
      } yield Ok(stored)
    }
  }

  case class DeleteTask(id: Long) 
           extends Service[Request, HttpResponse] {
    def apply(req: Request): Future[HttpResponse] =
                                       TaskService.delete(id).map {
      case Some(task) =&gt; Ok()
      case None =&gt; NotFound()
    }
  }

  case class GetAllTasks() extends Service[Request, HttpResponse] {
    def apply(req: Request): Future[HttpResponse] = {
      for {
        tasks &lt;- TaskService.all
      } yield Ok(tasks)
    }
  }</pre></div><p class="calibre7">First, we'll <a id="id123" class="calibre1"/>look at the <code class="email">CreateNewTask</code> class. As you can see, the<a id="id124" class="calibre1"/> code has become much simpler since we don't have<a id="id125" class="calibre1"/> to<a id="id126" class="calibre1"/> explicitly define how an incoming request is transformed to a <code class="email">Task</code> anymore. This time, all we need to do in the <code class="email">apply</code> function of the <code class="email">CreateNewTask</code> service is use the body, <code class="email">RequestReader</code>, and use <code class="email">as[Task]</code> to automatically convert the provided request to a <code class="email">Task</code>. This works since we implicitly defined a <code class="email">DecodeJson[Task]</code> instance. Once the <code class="email">Task</code> is created from the <code class="email">Request</code>, we pass it into the <code class="email">TaskService</code> to store it. The <code class="email">TaskService</code> returns a <code class="email">Future[Task]</code>, with the <code class="email">Task</code> that is stored (this will have the correct ID filled in). Finally, we return <code class="email">Ok</code> with the stored <code class="email">Task</code> as a parameter. Finch will convert this <code class="email">Ok</code> object to an <code class="email">HttpResponse</code> with code 200, and it will convert the provided <code class="email">Task</code> to JSON using the implicit <code class="email">EncodeJson[Task]</code> instance. We'll look a bit closer at how to build and customize the HTTP response in the following section. The <code class="email">GetAllTasks()</code> class works in pretty much the same manner. It retrieves a <code class="email">Future[Seq[Task]]</code> object from the <code class="email">TaskService</code> instance and Finch, together with the implicitly defined objects, and knows how to convert this sequence of tasks to the correct JSON message.</p><p class="calibre7">Before <a id="id127" class="calibre1"/>we move on to the next section, let's quickly look at <a id="id128" class="calibre1"/>the <code class="email">DeleteTask</code> class. As you can see in the code, this case <a id="id129" class="calibre1"/>class<a id="id130" class="calibre1"/> takes an additional parameter. This parameter will contain the long value, which was extracted by the <code class="email">long</code> extractor in the router that mapped to this <code class="email">Service</code>. If you have multiple extractors in the router, your case class should have the same amount of parameters.</p></div></div>
<div class="book" title="Request validation and custom responses"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Request validation and custom responses</h1></div></div></div><p class="calibre7">So far, we<a id="id131" class="calibre1"/> haven't looked at what happens when one of our RequestReaders can't <a id="id132" class="calibre1"/>read the required information. A header might be missing, a parameter might be in the incorrect format, or a cookie isn't present. If, for instance, you rename some fields in the JSON for the <span class="strong"><strong class="calibre8">Step 03 – Create Task</strong></span> request, and make the request, it will fail silently:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Request validation and custom responses" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Finch, however, provides an elegant way to handle all the exceptions from the RequestReaders. First, we'll <a id="id133" class="calibre1"/>look at the result we'll be aiming for. First, start<a id="id134" class="calibre1"/> another <code class="email">sbt</code> project like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH02-runCH02Step4</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Compiling 1 Scala source to /Users/jos/dev/git/rest-with-scala/chapter-02/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter2.steps.FinchStep4 </strong></span>
<span class="strong"><strong class="calibre8">Jun 28, 2015 2:10:12 PM com.twitter.finagle.Init$$anonfun$1 apply$mcV$sp</strong></span>
<span class="strong"><strong class="calibre8">INFO: Finagle version 6.25.0 (rev=78909170b7cc97044481274e297805d770465110) built at 20150423-135046</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Open Postman and use <span class="strong"><strong class="calibre8">Step 03 – Create Task</strong></span> to create some tasks in our database. For this example, we've added a search functionality that you can access through the <span class="strong"><strong class="calibre8">Step 04 – Search Tasks</strong></span> request.</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Request validation and custom responses" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To show how validation works, we've added a couple of rules to the request parameters. The <code class="email">status</code> request parameter is required, and when the <code class="email">text</code> parameter is used, its value should be at least five characters. To test how this works, either remove the <code class="email">status</code> parameter <a id="id135" class="calibre1"/>or change the value of the <code class="email">text</code> parameter to something <a id="id136" class="calibre1"/>smaller than five characters. The following screenshot shows the resulting error messages:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Request validation and custom responses" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The following code fragment shows the case class we use to search the database and show changes we have to make to our application to get these validation results:</p><div class="informalexample"><pre class="programlisting">// uses the following route
// Get / matchTask / "search" /&gt; SearchTasks()

case class SearchParams(status: String, text: Option[String])

case class SearchTasks() extends Service[Request, HttpResponse] {

    def getSearchParams: RequestReader[SearchParams] = (
          param("status") ::
          paramOption("text").should(beLongerThan(5))
        ).as[SearchParams]

    def apply(req: Request): Future[HttpResponse] = {
      (for {
        searchParams &lt;- getSearchParams(req)
        tasks &lt;- TaskService.search
                   (searchParams.status, searchParams.text)
      } yield Ok(tasks)).handle({case t: Throwable =&gt; 
                                         BadRequest(errorToJson(t))})
    }

    def errorToJson(t: Throwable):Json = t match {

      case NotPresent(ParamItem(param)) =&gt;
        Json("error" -&gt; Json.jString("param not found"), 
                                     "param" -&gt; Json.jString(param))
      case NotValid(ParamItem(param), rule) =&gt;
        Json("error" -&gt; Json.jString("param not valid"), 
                                     "param" -&gt; Json.jString(param), 
                                     "rule" -&gt; Json.jString(rule))
      case RequestErrors(errors) =&gt;
                          Json.array(errors.map(errorToJson(_)):_*)
      case error:Throwable =&gt; Json("error" -&gt; 
                          Json.jString(error.toString))
    }
  }</pre></div><p class="calibre7">When a<a id="id137" class="calibre1"/> request is passed into this <code class="email">Service</code>, the <code class="email">apply</code> function is<a id="id138" class="calibre1"/> invoked. In this function, we pass the request to a <code class="email">RequestReader[SearchParams]</code> object that looks similar to this:</p><div class="informalexample"><pre class="programlisting">    def getSearchParams: RequestReader[SearchParams] = (
          param("status") ::
          paramOption("text").should(beLongerThan(5))
        ).as[SearchParams]</pre></div><p class="calibre7">When this <code class="email">RequestReader</code> is called with a request, it will first try and get the <code class="email">status</code> parameter. If this parameter can't be found, a <code class="email">NotPresent</code> exception will be thrown. This, however, doesn't stop the processing of the request, and the <code class="email">RequestReader</code> gets the value of the <code class="email">text</code> parameter. If the <code class="email">text</code> parameter is available, it should be longer than five characters (note that we also have a <code class="email">shouldNot</code> function for when you want to check whether a rule doesn't apply). If it isn't, a <code class="email">NotValid</code> exception will be thrown. In the previous examples, if this happened, the processing of the request would have stopped, and the service would not have returned any response. To process these exceptions, we need to call the <code class="email">handle</code> function on the <code class="email">Future[HttpResponse]</code> instance (or the <code class="email">Future</code> returned from the <code class="email">RequestReader()</code> function).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre7">When you start working with Finch yourself, you might notice that it doesn't use the standard <code class="email">scala.concurrent.Future</code> class from Scala, but uses <code class="email">the Future</code> defined in <code class="email">com.twitter.util.Future</code>. The reasons are that Finch (and Finagle, which is used internally by Finch) is a Twitter project, and that the Future from Twitter has a lot of additional functionality. For instance, the <code class="email">handle</code> function, which is discussed in the next section, is a standard function on the Twitter <code class="email">Future</code> object. The <code class="email">TaskService</code> that we use in this book, however, uses standard Scala <code class="email">Future</code> objects. To make sure we can easily interoperate between the Scala <code class="email">Future</code> and Twitter <code class="email">Future</code> objects, we've created some implicit conversions. If you're interested in how they look, you can find these implicit conversions in the <code class="email">src/main/scala/org/restwithscala/chapter2/package.scala</code> file.</p></div><p class="calibre7">The <code class="email">handle</code> function takes a <code class="email">partial</code> function, and in this scenario, it should return an <code class="email">HttpResponse</code> instance. As you can see in the code, we just convert the validation related exceptions as a JSON object and wrap it in a <code class="email">BadRequest</code> class.</p><p class="calibre7">In the example, we showed we used the <code class="email">beLongerThan</code> rule. Finch provides a number of standard rules out of the box that you can use to check whether the result from a specific <code class="email">RequestReader</code> is valid:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Rule</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">beLessThan(n: Int)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id139" class="indexterm"/>checks whether a numeric value is less than the specified integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">beGreaterThan(n: Int</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether a numeric value is greater than the specified integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">beShorterThan(n: Int)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id140" class="indexterm"/>checks whether the length of a string is shorter than the specified integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">beLongerThan(n: Int)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the length of a string is longer than the specified integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">and </code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This combines two rules together. Both rules must be valid.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">or</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This combine two rules together. One of the rules must be valid.</p>
</td></tr></tbody></table></div><p class="calibre7">Creating <a id="id141" class="calibre1"/>a custom validation rule is very simple. For instance, the <a id="id142" class="calibre1"/>following code creates a new rule that checks whether a string contains any uppercase characters:</p><div class="informalexample"><pre class="programlisting">    val shouldBeLowerCase = ValidationRule[String]("be lowercase") {!_.exists((c: Char) =&gt; c.isUpper) }

    def getSearchParams: RequestReader[SearchParams] = (
          param("status") ::
          paramOption("text").should(beLongerThan(5) and shouldBeLowerCase)
        ).as[SearchParams]</pre></div><p class="calibre7">When we now run a query, we also get a message if we use uppercase characters in our <code class="email">text</code> parameter:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Request validation and custom responses" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The last <a id="id143" class="calibre1"/>part that we'll look at a bit closely before we move <a id="id144" class="calibre1"/>on to the next chapter is how to create HTTP responses. We've already seen a little bit of this with the <code class="email">Ok</code>, <code class="email">BadRequest</code>, and <code class="email">NotFound</code> case classes. Finch also provides a number of additional functions to further customize the HTTP<a id="id145" class="calibre1"/> response message. You can use the following functions to create the response:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Function</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withHeaders(headers: (String, String)*)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This adds the provided headers to the response.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withCookies(cookies: Cookie*)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This adds the provided cookies to the response.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withContentType(contentType: Option[String])</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sets the content-type of the response to the specified <code class="literal">Option[String]</code> value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withCharset(charset: Option[String])</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sets the character-set of the response to the provided <code class="literal">Option[String]</code> object.</p>
</td></tr></tbody></table></div><p class="calibre7">For example, if we wanted to create an <code class="email">Ok</code> response with a custom character set, a custom content-type, some custom headers, and a string body, we'd do something like this:</p><div class="informalexample"><pre class="programlisting">  Ok.withCharset(Some("UTF-8"))
    .withContentType(Some("text/plain"))
    .withHeaders(("header1" -&gt; "header1Value"),
                 ("header2" -&gt; "header2Value"))("body")</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we walked through the Finch framework. With the Finch framework, you can create REST services using a functional approach. Handling requests is done by mapping a request to a <code class="email">Service</code>; validating and parsing requests is done using a Reader monad, the <code class="email">RequestReader</code>; and all the parts are composable to create complex routes, RequestReaders, rules, and services from simple parts.</p><p class="calibre7">In the next chapter, we'll dive into a Scala REST framework that uses a different approach. We'll look at Unfiltered, which uses a pattern matching-based approach of defining REST services.</p></div></body></html>