<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functions and Lambdas</h1>
                </header>
            
            <article>
                
<p>The paradigm of functional programming has a lot of common features with the paradigm of declarative programming. One of the defining features of functional languages and declarative programming is the extensive use of functions. This chapter will discuss in more detail what functions are and their meaning in different paradigms. We will have a look at how we can use functions and what their role is in modern programming languages.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Functions as behaviors</li>
<li>Functions in functional programming</li>
<li>Higher-order functions</li>
<li>Lambdas</li>
<li style="color: black">The concept of functions in different programming languages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions as behavior</h1>
                </header>
            
            <article>
                
<p>So what are functions? We can define them as <strong>parameterized</strong>, named chunks of code. This means that they are chunks of code that can be called from any other part of the program by their name. Parameterized means that you can call them with certain arguments. Different calls executed with different parameters usually lead to different results.</p>
<p>What is the motivation behind functions? The answer is the basic principle of engineering – abstract away that which repeats itself. In <a href="485603d0-9f5e-4644-bd73-c46a8a317448.xhtml" target="_blank">Chapter 1</a><span>, The </span><em>Declarative Programming Style</em><span>,</span> we saw something similar in the case of loops. However, loops are built-in control structures. This means they are defined at the language level. When we need to define some logic on the language-user level, and this logic repeats itself across different parts of the project, functions come into play.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can trace functions across paradigms to as early as procedural programming. In procedural programming, functions are one of the units of abstraction. This means that functions encapsulate the logic that repeats. In object-oriented programming, we have an evolution of the understanding of functions. Functions are usually viewed in the context of an object or a class. In this context, they play the role of the behavior of an object.</p>
<p>For example, if you have an object called a soda machine, this object may have certain behaviors associated with it, such as inserting a coin into the machine, or pressing the button to get a can of soda from the machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions in functional programming</h1>
                </header>
            
            <article>
                
<p>In imperative programming, functions are used to represent the behavior of an object. In object-oriented programming, the behavior usually implies side effects. For the purposes of this book, we can understand side effects as follows—a function is side-effecting when it modifies the environment outside its own body. For example, it can have a global variable of its parent object modified, it can write a file into the filesystem, or the function can perform some web API calls over the network.</p>
<p>In functional programming, the understanding of functions is quite different. In functional programming, we prise purity and referential transparency. Purity means the absence of side effects. Referential transparency means that the result value the function has computed can be substituted in place of the function call, while the semantics of the program execution will remain unchanged.</p>
<p>Consider the following example. You have an application that simulates a soda machine. Its behavior is that of the insertion of the coin into the soda machine and getting a soda can back from it. A soda machine consists of the data: the amount of money and soda cans present in the machine. Whenever a coin is inserted, a soda can will be sold.</p>
<p>How do we express this behavior in an imperative style? We can create a separate object called a soda machine and, in that object, a method to dispatch cans. Whenever this method is called, the number of coins present in it is increased by one and the number of soda cans decreases by one. Also, we want to return an object called <kbd>SodaCan</kbd> from the method.</p>
<p class="mce-root"/>
<p>In the spirit of object-oriented programming, we can represent the soda machine as an object with some internal state:</p>
<pre style="padding-left: 30px">public class ImperativeSodaMachine {<br/> private int coins = 0;<br/> private int cans  = 0;<br/> public ImperativeSodaMachine(int initialCans) {<br/>   this.cans = initialCans;<br/> }</pre>
<p>We can also define some behavior on this machine: the behavior of what needs to happen upon inserting a coin and getting a soda can back. If there are soda cans left in the machine, we decrease the number of soda cans by one, increase the number of coins by one, and return a <kbd>soda can</kbd> object to the user. If there are no cans left, we throw an exception:</p>
<pre style="padding-left: 30px"> public SodaCan insertCoin() {<br/>   if (cans &gt; 0) {<br/>     cans--;<br/>     coins++;<br/>     return new SodaCan();<br/>   }<br/>   else throw new RuntimeException("Out of soda cans!");<br/> }<br/>}</pre>
<p>Finally, the <kbd>SodaCan</kbd> object is defined as follows:</p>
<pre style="padding-left: 30px">public class SodaCan {<br/> public void drink() {<br/>   System.out.println("You have drunk a can of soda.");<br/> }<br/>}</pre>
<p>The cans and the amount of money present in the soda machine are the variables of the soda machine. They don't belong to the function's body. This is why the function that changes variables that are outside its own scope constitutes a side-effecting function.</p>
<p class="mce-root"/>
<p>While imperative methods are conceptualized as side-effecting behaviors, functions in the functional style are conceptualized as computations that compute some value. In the functional world, side effects are not welcome. Let's express the preceding program in a purely functional way. We would have a soda machine with no behavior because the behavior is side-effecting. Side effects are generally bad in the functional world, as we will learn in subsequent chapters. Instead of that behavior, you would have a function that computes a new state of the soda machine. That is a new soda machine object from the old soda machine object. Such a soda machine object is an immutable object, which means that it only contains values that cannot be modified. This helps to eliminate side effects, since now, functions defined on the soda machine cannot modify its variables that are outside the scope of the functions. Whenever we want to get a new soda can, we would also need to compute the new state of the soda machine after the can is dispatched, and then return a soda can from this machine:</p>
<pre style="padding-left: 30px">case class SodaMachine(cans: Int, coins: Int = 0)<br/>def insertCoin(sm: SodaMachine): (SodaMachine, SodaCan) =<br/> if (sm.cans &gt; 0) (SodaMachine(sm.cans - 1, sm.coins + 1), new SodaCan)<br/> else throw new RuntimeException("Out of soda cans!")</pre>
<p>Expressed this way, the computation does not affect the environment outside its own scope. We no longer have the modification of some external variables, nor do we interact with the world outside the scope of the function. We just compute the result values based on the inputs to the function. This is the understanding of a function in the world of functional programming. Later on in this book, we will cover how this understanding is more beneficial than the original understanding of a method in terms of the behavior.</p>
<p>The absence of side effects is not the only feature of the functional style. The next feature we are going to look at is higher-order functions—functions that accept other functions as their inputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Higher-order functions</h1>
                </header>
            
            <article>
                
<p>Another important concept that appears in functional programming is that of higher-order functions. A higher-order function is a function that accepts a function as an argument. A very trivial example of where this may be useful is control structures. For example, a <kbd>while</kbd> loop can be expressed in a functional way as a higher-order function that accepts the body of the loop and a predicate as an argument.</p>
<p class="mce-root"/>
<p>The body of the loop can be expressed as a function that does not accept any arguments, but computes some side effects. The way it works is that we have a function accept a <kbd>0-argument</kbd> function and a predicate, and we call the same <kbd>loop</kbd> function recursively while the predicate is true.</p>
<p>We can call the new control structure <kbd>whileDiy</kbd>, and it can be defined as follows:</p>
<pre style="padding-left: 30px">@annotation.tailrec<br/>def whileDiy(predicate: =&gt; Boolean)(body: =&gt; Unit): Unit =<br/>  if (predicate) {<br/>    body<br/>    whileDiy(predicate)(body)<br/>  }<br/>}</pre>
<p>The <kbd>whileDiy</kbd> construct accepts a predicate and a body. The predicate will be evaluated on each function call and, if it is true, we will run the body and recursively invoke the <kbd>whileDiy</kbd> construct again. Notice also that in the <kbd>@annotation.tailrec</kbd> annotation on top of the method, it indicates that the method will be called in a tail-recursive manner, which means there's no chance it will result in a <kbd>StackOverflowError</kbd>, even though it is recursive. This is because it will reuse the frame of its initial call for all subsequent recursive calls.</p>
<p>We can use the new construction as follows:</p>
<pre style="padding-left: 30px">var j = 0<br/>whileDiy (j &lt; 5) {<br/>  println(s"Printing from custom while loop. Iteration: $j")<br/>  j += 1<br/>}</pre>
<p>Compare this to how the built-in <kbd>while</kbd> loop is used:</p>
<pre style="padding-left: 30px">var i = 0<br/>while (i &lt; 5) {<br/>  println(s"Printing from built-in while loop. Iteration: $i")<br/>  i += 1<br/>}</pre>
<p>The usage is almost identical. This illustrates how higher-order functions can be used to define control structures very close to the ones built in to the language.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding lambda functions</h1>
                </header>
            
            <article>
                
<p>Most functional languages have a concept of a lambda function. It is an anonymous function defined inline. It can be assigned to a variable if needed. For example, consider that we need a function that accepts a cookie with user session data, in the context of a web application. Its job is to print a greeting to the user to the standard output. However, before printing, we need to decorate the user's name in a certain way. To complicate matters further, we also have a database of users who hold PhDs and, if they do, we need to refer to them as Dr. Here is how it can be done in Scala:</p>
<ol>
<li>We define the dummy <kbd>Cookie</kbd> class for our example:</li>
</ol>
<pre style="padding-left: 60px">case class Cookie(name: String, gender: String)</pre>
<ol start="2">
<li>We define the <kbd>greeting</kbd> method. The job of the method is to extract the data from the <kbd>cookie</kbd> object, and apply the modifier to the user's name based on their gender.</li>
<li>After that, greet the user. This method does not know how exactly to modify the name. The <kbd>modifier</kbd> logic is abstracted away and we rely on the caller to specify how to do this:</li>
</ol>
<pre style="padding-left: 60px">def greeting(cookie: Cookie)(modifier: (String, String) =&gt; String): Unit = {<br/>     val name         = cookie.name<br/>     val gender       = cookie.gender<br/>     val modifiedName = modifier(name, gender)<br/>     print(s"Hello, $modifiedName")<br/>}</pre>
<ol start="4">
<li>Finally, this is how we can call this method:</li>
</ol>
<pre style="padding-left: 60px">def isPhd(name: String): Boolean = name == "Smith"<br/>val cookie = Cookie("Smith", "male")<br/>greeting(cookie) { (name, gender) =&gt;<br/>  if (isPhd(name)) s"Dr $name"<br/>  else gender match {<br/>    case "male"   =&gt; s"Mr $name"<br/>    case "female" =&gt; s"Mrs $name"<br/>  }<br/>}</pre>
<p>The <kbd>greeting</kbd> function accepts a string and also a function that modifies this string. Notice how, when calling this function, we specify the function that modifies the string inline. We do not define the function prior to passing it to the <kbd>greeting</kbd> function.</p>
<p>This is the idea behind a lambda function. You don't need to define a function before you can use it in some other higher-order function. Instead, you can define functions like that inline, using lambda syntax. Obviously, this kind of approach is especially useful in the context of higher-order functions. It allows you to use higher-order functions without first defining their arguments.</p>
<p>The concept of the lambda function is present in the majority of functional languages, including Scala, Haskell, and Python.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The concept of functions in different programming languages</h1>
                </header>
            
            <article>
                
<p>Functions are present in many programming languages. Some of the languages have better support for purely functional styles, while others favor declarative styles. This is why, for example, using Scala over Java can give you tremendous leverage, because you can declare functions inside other functions, you can declare functions that accept other functions (higher-order functions) more easily, and you can declare anonymous lambda functions (functionality also available in Java, starting from Java 8). This greatly increases your capacity for abstraction, creating control structures, and thereby enabling your application to be expressed in a more <strong>DRY</strong> (<strong>Don't Repeat Yourself</strong>) way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen what functions are and how they have evolved from the early days of programming to today. We have seen how functions were initially treated as abstractions of common logic. After that, in object-oriented programming, they represented the behavior of certain objects. Object-oriented programmers attempted to represent everything as an object. So it is only natural that functions started to be viewed in the context of a world that consists of objects. In this context, functions are best viewed as behaviors of these objects.</p>
<p>In functional programming, functions can be viewed in a different context. Now, the best way to view functions is as mathematical computations. They compute some value out of its inputs, in a pure way, which means without any side effects. The idea is to view them as mathematical functions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Functional programming is close to declarative programming, so its functions are also often tailored to the needs of that style. This way, in functional languages, there is a concept of higher-order functions, anonymous lambda functions, and partial functions. From an engineering perspective, this is useful because it greatly enhances your capability for abstraction.</p>
<p>In programming, data structures are ubiquitous. When adopting functional style, sooner or later you will encounter a problem of working with data structures in a functional way. In the next chapter, we will see how this problem is addressed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How are functions interpreted in the context of object-oriented programming?</li>
<li>How are functions interpreted in the context of pure functional programming?</li>
<li>What are higher-order functions?</li>
<li>Why are higher-order functions useful?</li>
</ol>


            </article>

            
        </section>
    </body></html>