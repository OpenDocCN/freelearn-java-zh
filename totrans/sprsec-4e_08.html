<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor261"/>8</h1>
<h1 id="_idParaDest-179"><a id="_idTextAnchor262"/>Client Certificate Authentication with TLS</h1>
<p>Although username and password authentication are extremely common, as we discussed in <a href="B21757_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Anatomy of an Unsafe Application</em>, and in <a href="B21757_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting Started with Spring Security</em>, forms of authentication exist that allow users to present different types of credentials. Spring Security caters to these requirements as well. In this chapter, we’ll move beyond form-based authentication to explore authentication using trusted <span class="No-Break">client-side certificates.</span></p>
<p>During the course of this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Learning how client certificate authentication is negotiated between the user’s browser and a <span class="No-Break">compliant server</span></li>
<li>Configuring Spring Security to authenticate users with <span class="No-Break">client certificates</span></li>
<li>Understanding the architecture of client certificate authentication in <span class="No-Break">Spring Security</span></li>
<li>Exploring advanced configuration options related to client <span class="No-Break">certificate authentication</span></li>
<li>Reviewing pros, cons, and common troubleshooting steps when dealing with client <span class="No-Break">certificate authentication</span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/XgAQ7"><span class="No-Break">https://packt.link/XgAQ7</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor263"/>How does client certificate authentication work?</h1>
<p>Client certificate authentication<a id="_idIndexMarker523"/> requires a request for information from the server and a response from the browser to negotiate a trusted authentication relationship between the client (that is, a user’s browser) and the server application. This trusted relationship is built through the use of the exchange of trusted and verifiable <a id="_idIndexMarker524"/>credentials, known <span class="No-Break">as </span><span class="No-Break"><strong class="bold">certificates</strong></span><span class="No-Break">.</span></p>
<p>Unlike much of what we have seen up to this point, with client certificate authentication, the Servlet container or application server itself is typically responsible for negotiating the trust relationship between the browser and server by requesting a certificate, evaluating it, and accepting it <span class="No-Break">as valid.</span></p>
<p>Client certificate authentication<a id="_idIndexMarker525"/> is also known as <strong class="bold">mutual authentication</strong> and is <a id="_idIndexMarker526"/>part of the <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) protocol and its<a id="_idIndexMarker527"/> successor, <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>). As mutual <a id="_idIndexMarker528"/>authentication is part of the SSL and TLS protocols, it follows that an HTTPS connection (secured with SSL or TLS) is required in order to make use of client certificate authentication. For more details on SSL/TLS support in Spring Security, please refer to the <em class="italic">Generating a server certificate</em> section in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em>. Setting up SSL/TLS is required to implement client <span class="No-Break">certificate authentication.</span></p>
<p>The following sequence diagram illustrates the interaction between the client browser and the web server when negotiating an SSL connection and validating the trust of a client certificate used for <span class="No-Break">mutual authentication:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 8.1 – Client certificate authentication" height="467" src="image/B21757_08_1.jpg" width="891"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Client certificate authentication</p>
<p>We can see that the exchange of two certificates, the server and client certificates, provides the authentication that both parties are known and can be trusted to continue their conversation securely. In the interest of clarity, we omit some details of the SSL handshake and trust the checking of the certificates themselves; however, you are encouraged to do further reading in the area of the SSL and TLS protocols, and certificates in general, as many good reference guides on these subjects exist. <em class="italic">RFC 8446</em>, <em class="italic">The Transport Layer Security (TLS) Protocol Version 1.3 </em>(<a href="https://datatracker.ietf.org/doc/html/rfc8446">https://datatracker.ietf.org/doc/html/rfc8446</a>), is a good place to begin reading about client certificate presentation, and if you’d like to get into more detail, <em class="italic">SL and TLS: Designing and Building Secure Systems, Eric Rescorla, Addison-Wesley </em>(<a href="https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983">https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983</a>) has an incredibly detailed review of the protocol and <span class="No-Break">its implementation.</span></p>
<p>An alternative name for client <a id="_idIndexMarker529"/>certificate-based <a id="_idIndexMarker530"/>authentication is <strong class="bold">X.509 authentication</strong>. The term X.509 is derived from the X.509 standard, originally published by the <strong class="bold">International Telecommunication Union Telecommunication </strong>(<strong class="bold">ITU-T</strong>) organization for use<a id="_idIndexMarker531"/> in directories based on the X.500 standard (the origins of <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>), as you <a id="_idIndexMarker532"/>may recall from <a href="B21757_06.xhtml#_idTextAnchor180"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">LDAP Directory Services</em>). Later, this standard was adapted for use in securing <span class="No-Break">internet communications.</span></p>
<p>We mention this here because many of the classes in Spring Security related to this subject refer to X.509. Remember that X.509 doesn’t define the mutual authentication protocol itself, but defines the format and structure of the certificates and the encompassing<a id="_idTextAnchor264"/> trusted certificate <span class="No-Break">authorities instead.</span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor265"/>Setting up the client certificate authentication infrastructure</h2>
<p>Unfortunately for you as an individual developer, being able to experiment with client certificate authentication<a id="_idIndexMarker533"/> requires some non-trivial configuration and setup prior to the relatively easy integration with Spring Security. As these<a id="_idIndexMarker534"/> setup steps tend to cause a lot of problems for first-time developers, we feel it is important to walk you <span class="No-Break">through them.</span></p>
<p>We assume that you are using a local, self-signed server certificate, self-signed client certificates, and Apache Tomcat. This is typical of most development environments; however, it’s possible that you may<a id="_idIndexMarker535"/> have access to a valid server certificate, a <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>), or another application server. If this is the case, you may use these setup instructions as guidelines and configure your environment in an analogous manner. Please refer to the SSL setup instructions in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em>, for <a id="_idIndexMarker536"/>assistance in configuring Tomcat and Spring Security to work with SSL in a <span class="No-Break">standalone environment.</span></p>
<h3>Understanding the purpose of a public key infrastructure</h3>
<p>This chapter focuses on setting up a self-contained development environment for the purposes of learning and education. However, in most cases where you are integrating Spring Security into an existing <a id="_idIndexMarker537"/>client certificate-secured environment, there will be a significant amount of infrastructure (usually a combination of hardware and software) in place to provide functionality, such as certificate granting and management, user self-service, and revocation. Environments of this type define a public key infrastructure—a combination of hardware, software, and security policies that result in a highly secure authentication-driven <span class="No-Break">network ecosystem.</span></p>
<p>In addition to being used for web application authentication, certificates or hardware devices in these environments can be used for secure, non-repudiated email (using <strong class="source-inline">S/MIME</strong>), network authentication, and even physical building access (using <strong class="source-inline">PKCS 11</strong>-based <span class="No-Break">hardware devices).</span></p>
<p>While the management overhead of such an environment can be high (and requires both IT and process excellence to implement well), it is arguably one of the most sec<a id="_idTextAnchor266"/>ure operating environments possible for <span class="No-Break">technology professionals.</span></p>
<h3>Creating a client certificate key pair</h3>
<p>The self-signed client certificate is created in the same way as the self-signed server certificate is created—by<a id="_idIndexMarker538"/> generating a key pair using the <strong class="source-inline">keytool</strong> command. A client certificate key pair differs in that it requires the key store to be available to the web browser and requires the client’s public key to be loaded into the server’s trust store (we’ll explain what this is in <span class="No-Break">a moment).</span></p>
<p>If you do not wish to generate your own key right now, you may skip to the next section and use the sample certificates in the <strong class="source-inline">./src/main/resources/keys</strong> folder in the sample chapter. Otherwise, create the client key pair, <span class="No-Break">as follows:</span></p>
<pre class="console">
keytool -genkeypair -alias jbcpclient -keyalg RSA -validity 365 -keystore jbcp_clientauth.p12 -storetype PKCS12</pre> <p class="callout-heading"><a id="_idTextAnchor267"/>Important note</p>
<p class="callout">You can find additional information about <strong class="source-inline">keytool</strong>, along with all of the configuration options, at Oracle’s site, <span class="No-Break">here: </span><a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml"><span class="No-Break">https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml</span></a><span class="No-Break">.</span></p>
<p>Most of the arguments to <strong class="source-inline">keytool</strong> are fairly arbitrary for this use case. However, when prompted to set up the first and last name (the <strong class="bold">Common Name</strong> (<strong class="bold">CN</strong>), the portion of the owner’s <strong class="bold">Distinguished Name</strong> (<strong class="bold">DN</strong>) for the client certificate, ensure that the answer to<a id="_idIndexMarker539"/> the first prompt matches a user that we have set up in our Spring Security JDBC store. For example, <strong class="source-inline">admin1@example.com</strong> is an appropriate value since we have the <strong class="source-inline">admin1@example.com</strong> user setup in Spring Security. An example of the command-line interaction is <span class="No-Break">as follows:</span></p>
<pre class="console">
What is your first and last name? [Unknown]: admin1@example.com
... etc
Is CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US correct?
[no]: yes</pre> <p>We’ll see why this is important when we configure Spring Security to access the information from the certificate-authenticated user. We have one final step befor<a id="_idTextAnchor268"/>e we can set up certificate authentication within Tomcat, which is explained in the <span class="No-Break">next section.</span></p>
<h3>Configuring the Tomcat trust store</h3>
<p>Recall that the definition of a key pair includes both a private and public key. Similar to SSL certificates verifying and securing server communication, the validity of the client certificate needs to be verified by <a id="_idIndexMarker540"/>the certifying authority that <span class="No-Break">created it.</span></p>
<p>As we have created our own self-signed client certificate using the <strong class="source-inline">keytool</strong> command, the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) will not implicitly trust it as having been assigned by a trusted <span class="No-Break">certificate authority.</span></p>
<p>Let’s take a look at the <span class="No-Break">following steps:</span></p>
<ol>
<li>We will need to force Tomcat to recognize the certificate as a trusted certificate. We do this by exporting the public key from the key pair and adding it to the Tomcat <span class="No-Break">trust store.</span><p class="list-inset">Again, if you do not wish to perform this step now, you can use the existing trust store in <strong class="source-inline">.src/main/resources/keys</strong> and skip to where we configure <strong class="source-inline">server.xml</strong> later in <span class="No-Break">this section.</span></p></li>
<li>We’ll export the public key to a standard certificate file named <strong class="source-inline">jbcp_clientauth.cer</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">keytool -exportcert </strong><strong class="bold">-alias jbcpclient -keystore jbcp_clientauth.p12 -storetype PKCS12 -storepass changeit -file jbcp_clientauth.cer</strong></pre></li> <li>Next, we’ll import the certificate into the trust store (this will create the trust store, but in a typical deployment scenario you’d probably already have some other certificates in the <span class="No-Break">trust store):</span><pre class="source-code">
<strong class="bold">keytool -importcert -alias jbcpclient -keystore tomcat.truststore -file jbcp_clientauth.cer</strong></pre><p class="list-inset">The preceding command will create the trust store called <strong class="source-inline">tomcat.truststore</strong> and prompt you for a password (we chose <strong class="source-inline">changeit</strong> as the password). You’ll also see some information about the certificate and will finally be asked to confirm that you do trust the certificate, <span class="No-Break">as follows:</span></p><pre class="source-code"><strong class="bold">Owner: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US</strong>
<strong class="bold">Issuer: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US</strong>
<strong class="bold">Serial number: 464fc10c</strong>
<strong class="bold">Valid from: Fri Jun 23 11:10:19 MDT 2017 until: Thu Feb 12 10:10:19</strong>
<strong class="bold">MST 2043</strong>
<strong class="bold">//Certificate fingerprints:</strong>
<strong class="bold">MD5: 8D:27:CE:F7:8B:C3:BD:BD:64:D6:F5:24:D8:A1:8B:50</strong>
<strong class="bold">SHA1: C1:51:4A:47:EC:9D:01:5A:28:BB:59:F5:FC:10:87:EA:68:24:E3:1F</strong>
<strong class="bold">SHA256: 2C:F6:2F:29:ED:09:48:FD:FE:A5:83:67:E0:A0:B9:DA:C5:3B: FD:CF:4F:95:50:3A:</strong>
<strong class="bold">2C:B8:2B:BD:81:48:BB:EF</strong>
<strong class="bold">Signature algorithm name: SHA256withRSA Version: 3</strong>
<strong class="bold">//Extensions</strong>
<strong class="bold">#1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier [</strong>
<strong class="bold">KeyIdentifier [</strong>
<strong class="bold">0000: 29 F3 A7 A1 8F D2 87 4B</strong>
<strong class="bold">EA 74 AC 8A 4B BC 4B 5D</strong>
<strong class="bold">)</strong>
<strong class="bold">K.t..K.K]</strong>
<strong class="bold">0010: 7C 9B 44 4A</strong>
<strong class="bold">..DJ</strong>
<strong class="bold">]</strong>
<strong class="bold">]</strong>
<strong class="bold">Trust this certificate? [no]</strong>: yes</pre><p class="list-inset">Remember the location of the new <strong class="source-inline">tomcat.truststore</strong> file, as we will need to reference it in our <span class="No-Break">Tomcat </span><span class="No-Break"><a id="_idIndexMarker541"/></span><span class="No-Break">configuration.</span></p></li> </ol>
<p class="callout-heading">What’s the difference between a key store and a trust store?</p>
<p class="callout">The <strong class="bold">Java Secure Socket Extension</strong> (<strong class="bold">JSSE</strong>) documentation<a id="_idIndexMarker542"/> defines a key store as a storage mechanism for private keys and their corresponding public keys. The <a id="_idIndexMarker543"/>key store (containing key pairs) is used to encrypt or decrypt secure messages, and so on. The trust store is intended to store only public keys for trusted communication partners when verifying an identity (similar to how the<a id="_idIndexMarker544"/> trust store is used in certificate authentication). In many common administration scenarios, however, the key store and trust store are combined into a single file (in Tomcat, this would be done through the use of the <strong class="source-inline">keystoreFile</strong> and <strong class="source-inline">truststoreFile</strong> attributes of the connector). The format of the files themselves can be exactly the same. Really, each file can be any JSSE-supported keystore <a id="_idIndexMarker545"/>format, including <strong class="bold">Java KeyStore</strong> (<strong class="bold">JKS</strong><span class="P---Regular-Char">), </span><strong class="source-inline">PKCS 12</strong>, and <span class="No-Break">so on.</span></p>
<ol>
<li value="4">As previously mentioned, we assume you have already configured the SSL Connector, as outlined in the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em>. If you do not see the <strong class="source-inline">keystoreFile</strong> or <strong class="source-inline">keystorePass</strong> attributes in <strong class="source-inline">server.xml</strong>, it means you should visit the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a>, <em class="italic">Additional Reference Material</em>, to get SSL <span class="No-Break">set up.</span></li>
<li>Finally, we’ll need to point Tomcat at the trust store and enable client certificate authentication. This is done by adding three additional attributes to the SSL connector in the Tomcat <strong class="source-inline">server.xml</strong> file, <span class="No-Break">as follows:</span><pre class="source-code">
//sever.xml
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" maxThreads="150"
          scheme="https" secure="true" sslProtocol="TLS" keystoreFile="&lt;KEYSTORE_PATH&gt;/tomcat.keystore"
          keystorePass="changeit" truststoreFile="&lt;CERT_PATH&gt;/tomcat.truststore"
          truststorePass="changeit"  clientAuth="true" /&gt;</pre></li> <li>This should be the remaining configuration required to trigger Tomcat to request a client certificate when an SSL connection is made. Of course, you will want to ensure you replace both <strong class="source-inline">&lt;CERT_PATH&gt;</strong> and <strong class="source-inline">&lt;KEYSTORE_PATH&gt;</strong> with the full paths. For example, on a Unix-based <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>), the path might <a id="_idIndexMarker546"/>look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">/home/packt/chapter8/keys/tomcat.keystore</strong></span><span class="No-Break">.</span></li>
<li>Go ahead and try to start up Tomcat to ensure that the server starts up without any errors in <span class="No-Break">the logs.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">There’s also a way to configure Tomcat to optionally use client certificate authentication—we’ll enable this later in the chapter. For now, we require the use of client certificates to even connect to the Tomcat server in the first place. This makes it easier to diagnose wheth<a id="_idTextAnchor269"/>er or not you have set this <span class="No-Break">up correctly!</span></p>
<h3>Configuring Tomcat in Spring Boot</h3>
<p>We can also configure the embedded Tomcat instance within Spring Boot, which is how we will be working with<a id="_idIndexMarker547"/> Tomcat for the rest of <span class="No-Break">this chapter.</span></p>
<p>Configuring Spring Boot to use our newly created certificates is as straightforward as configuring the properties of the YAML entry, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
## Chapter 8 TLS over HTTP/1.1:
## https://localhost:8443
server:
  port: 8443
  ssl:
    key-store: classpath:keys/jbcp_clientauth.p12
    key-store-password: changeit
    keyStoreType: PKCS12
    keyAlias: jbcpclient
    protocol: TLS
    client-auth: need
    trust-store: classpath:keys/tomcat.truststore
    trust-store-password: changeit</pre> <p>The final step is to import the<a id="_idIndexMarker548"/> certificate into the <span class="No-Break">client browser.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor270"/>Importing the certificate key pair into a browser</h2>
<p>Depending on what browser you are using, the process of importing a certificate may differ. We will provide instructions <a id="_idIndexMarker549"/>for installations of Firefox, Chrome, and Internet Explorer here, but if you are using another browser, please consult its help<a id="_idTextAnchor271"/> section or your favorite search engine <span class="No-Break">for assistance.</span></p>
<h3>Using Mozilla Firefox</h3>
<p>Perform the following steps to<a id="_idIndexMarker550"/> import the key store <a id="_idIndexMarker551"/>containing the client certificate key pair <span class="No-Break">in Firefox:</span></p>
<ol>
<li>Click on <strong class="bold">Edit</strong> | <span class="No-Break"><strong class="bold">Preferences</strong></span><span class="No-Break">.</span></li>
<li>Click on the <span class="No-Break"><strong class="bold">Advanced</strong></span><span class="No-Break"> button.</span></li>
<li>Click on the <span class="No-Break"><strong class="bold">Encryption</strong></span><span class="No-Break"> tab.</span></li>
<li>Click on the <strong class="bold">View Certificates</strong> button. The <strong class="bold">Certificate Manager</strong> window should <span class="No-Break">open up.</span></li>
<li>Click on the <strong class="bold">Your </strong><span class="No-Break"><strong class="bold">Certificates</strong></span><span class="No-Break"> tab.</span></li>
<li>Click on the <span class="No-Break"><strong class="bold">Import...</strong></span><span class="No-Break"> button.</span></li>
<li>Browse to the location where you saved the <strong class="source-inline">jbcp_clientauth.p12</strong> file and select it. You will need to enter the password (that is, <strong class="source-inline">changeit</strong>) that you used<a id="_idTextAnchor272"/> when you <a id="_idIndexMarker552"/>created <span class="No-Break">the file.</span></li>
</ol>
<p>The client certificate<a id="_idIndexMarker553"/> should be imported, and y<a id="_idTextAnchor273"/>ou should see it on <span class="No-Break">the list.</span></p>
<h3>Using Google Chrome</h3>
<p>Perform the following steps to<a id="_idIndexMarker554"/> import the key store containing<a id="_idIndexMarker555"/> the client certificate key pair <span class="No-Break">in Chrome:</span></p>
<ol>
<li>Click on the wrench icon on the <span class="No-Break">browser toolbar.</span></li>
<li><span class="No-Break">Select </span><span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break">.</span></li>
<li>Click on <strong class="bold">Show </strong><span class="No-Break"><strong class="bold">advanced settings...</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">HTTPS/SSL</strong> section, click on the <strong class="bold">Manage </strong><span class="No-Break"><strong class="bold">certificates...</strong></span><span class="No-Break"> button.</span></li>
<li>In the <strong class="bold">Personal</strong> tab click on the <span class="No-Break"><strong class="bold">Import...</strong></span><span class="No-Break"> button.</span></li>
<li>Browse to the location where you saved the <strong class="source-inline">jbcp_clientauth.p12</strong> file and select it (Ensure that you utilize the .p12 extension for <span class="No-Break">the certificate).</span></li>
<li>You will need to enter the password (that is, <strong class="source-inline">changeit</strong>) that you used when you<a id="_idTextAnchor274"/><a id="_idTextAnchor275"/> created <span class="No-Break">the file.</span></li>
<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
</ol>
<h3>Using Microsoft Edge</h3>
<p>Let’s take a look at the steps of <a id="_idIndexMarker556"/>using Microsoft Edge <a id="_idIndexMarker557"/>with <span class="No-Break">Windows OS:</span></p>
<ol>
<li>Double-click on the <strong class="source-inline">jbcp_clientauth.p12</strong> file in Windows Explorer. The<strong class="bold"> Certificate Import Wizard</strong> window should open (Ensure that you utilize the .p12 extension for <span class="No-Break">the certificate).</span></li>
<li>Click on <strong class="bold">Next</strong> and accept the default values until you are prompted for the <span class="No-Break">certificate password.</span></li>
<li>Enter the certificate password (that is, <strong class="source-inline">changeit</strong>) and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
<li>Accept the default <strong class="bold">Automatically select the certificate store</strong> option and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></li>
</ol>
<p>To verify that the certificate was installed correctly, you will need to perform another series <span class="No-Break">of steps:</span></p>
<ol>
<li>Open the <strong class="bold">Settings</strong> menu in <span class="No-Break">Microsoft Edge.</span></li>
<li>Select <strong class="bold">Privacy, search </strong><span class="No-Break"><strong class="bold">and services</strong></span></li>
<li>Scroll down to <span class="No-Break"><strong class="bold">Security</strong></span><span class="No-Break"> and</span></li>
<li>Click <span class="No-Break"><strong class="bold">Manage certificates</strong></span><span class="No-Break">.</span></li>
<li>Click on the <strong class="bold">Personal</strong> tab, if it is not already selected. You should see the certificate <span class="No-Break">listed here.</span></li>
</ol>
<h3>Wrapping up testing</h3>
<p>You should now be able to connect to the <strong class="bold">Jim Bob Circle Pants Online Calendar (JBCP)</strong> calendar site <a id="_idIndexMarker558"/>using the client certificate. Navigate to <strong class="source-inline">https://localhost:8443/</strong>, taking care to use <strong class="bold">HTTPS</strong> and <strong class="bold">8443</strong>. If all is set up correctly, you should be prompted for a certificate when you attempt to access the site—in Chrome, the certificate is displayed <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 8.2 – Client certificate details in Chrome" height="556" src="image/B21757_08_2.jpg" width="1025"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Client certificate details in Chrome</p>
<p>You’ll notice, however, that if you attempt to access a protected section of the site, such as the <strong class="bold">My Events</strong> section, you’ll be<a id="_idIndexMarker559"/> redirected to the login page. This is because we haven’t yet configured Spring Security to recognize the information in the certificate—at this point, the negotiation between the client and server has stopped at the To<a id="_idTextAnchor276"/>mcat <span class="No-Break">server itself.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the code <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter08.00-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor277"/>Troubleshooting client certificate authentication</h2>
<p>Unfortunately, if we said that getting client certificate authentication configured correctly for the first time—without anything going wrong—was easy, we’d be lying to you. The fact is, although this is<a id="_idIndexMarker560"/> a great and very powerful security apparatus, it is poorly documented by both the browser and web server manufacturers, and the error messages, when present, can be confusing at best and misleading <span class="No-Break">at worst.</span></p>
<p>Remember that, at this point, we have not involved Spring Security in the equation at all, so a debugger will most likely not help you (unless you have the Tomcat source code handy). There are some common errors and things <span class="No-Break">to check.</span></p>
<p>You aren’t prompted for a certificate when you access the site. There are many possible causes for this, and this can be the most puzzling problem to try to solve. Here are some things <span class="No-Break">to check:</span></p>
<ol>
<li>Ensure that the certificate has been installed in the browser client you are using. Sometimes, you need to restart the whole browser (close all windows) if you attempted to access the site previously and <span class="No-Break">were rejected.</span></li>
<li>Ensure you are accessing the SSL port for the server (typically <strong class="source-inline">8443</strong> in a development setup), and have selected the HTTPS protocol in your URL. The client certificates are not presented in insecure browser connections. Make sure the browser also trusts the server SSL certificate, even if you have to force it to trust a <span class="No-Break">self-signed certificate.</span></li>
<li>Ensure you have added the <strong class="source-inline">clientAuth</strong> directive to your Tomcat configuration (or the equivalent for whatever application server you <span class="No-Break">are using).</span></li>
<li>If all else fails, use a network analyzer or packet sniffer, such as Wireshark (<a href="http://www.wireshark.org/">http://www.wireshark.org/</a>) or Fiddler2 (<a href="http://www.fiddler2.com/">http://www.fiddler2.com/</a>), to review the traffic and SSL key exchange over the wire (check with your IT department first—many companies do not allow tools of this kind on <span class="No-Break">their networks).</span></li>
<li>If you are using a self-signed client certificate, make sure the public key has been imported into the server’s trust store. If you are using a CA-assigned certificate, make sure the <a id="_idIndexMarker561"/>CA is trusted by the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) or that the CA certificate is imported into the server’s <span class="No-Break">trust store.</span></li>
<li>Internet Explorer, in particular, does not report details of client certificate failures at all (it simply reports a generic <strong class="bold">Page Cannot be Displayed</strong> error). Use Firefox to diagnose whether an issue you are seeing is related to client certificates <span class="No-Break">or not.</span></li>
<li>The following JVM option <a id="_idIndexMarker562"/>will enable SSL handshake level logging: <strong class="source-inline">-Djavax.net.debug=ssl:handshake</strong>. This debugging flag can produce a large amount of output but can be very helpful in diagnosing underlying SSL <span class="No-Break">connectivity issues.</span></li>
</ol>
<h2 id="_idParaDest-184"><a id="_idTextAnchor278"/>Configuring client certificate authentication in Spring Security</h2>
<p>Unlike the authentication<a id="_idIndexMarker563"/> mechanisms that we have utilized thus far, the use of client certificate authentication results in the user’s request being pre-authenticated by the server. As the server (Tomcat) has already <a id="_idIndexMarker564"/>established that the user has provided a valid and trustworthy certificate, Spring Security can simply trust this assertion <span class="No-Break">of validity.</span></p>
<p>An important component of the secure login process is still missing, which is the authorization of the authenticated user. This is where our configuration of Spring Security comes in—we must add a component to Spring Security that will recognize the certificate authentication information from the user’s HTTP session (populated by Tomcat), and then validate the presented credentials against the Spring Security <strong class="source-inline">UserDetailsService</strong> invocation. The invocation of <strong class="source-inline">UserDetailsService</strong> will result in the determination of whether the user declared in the certificate is known to Spring Security at all, and then it will assign <strong class="source-inline">Granted<a id="_idTextAnchor279"/>Authority</strong> as per the usual <span class="No-Break">login rules.</span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor280"/>Configuring client certificate authentication using the security namespace</h2>
<p>With all of the complexity of LDAP <a id="_idIndexMarker565"/>configuration, configuring client certificate authentication is a welcome reprieve. If we are using the security namespace style of configuration, the addition of client certificate authentication is a<a id="_idIndexMarker566"/> simple one-line configuration change, added within the <strong class="source-inline">HttpSecurity</strong> declaration. Go ahead and make the following changes to the provided <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
// SSL / TLS x509 support
http.x509(httpSecurityX509Configurer -&gt; httpSecurityX509Configurer
              .userDetailsServ<a id="_idTextAnchor281"/>ice(userDetailsService));</pre> <p class="callout-heading">Important note</p>
<p class="callout">Observe that the <strong class="source-inline">.x509()</strong> method references our existing <strong class="source-inline">userDetailsService()</strong> configuration. For simplicity, we use the <strong class="source-inline">UserDetailsServiceImpl</strong> implementation covered in <a href="B21757_05.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Authentication with Spring Data</em>. However, we could easily swap this out with any other implementation (that is, the LDAP or JDBC-based implementation covered in <a href="B21757_04.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <span class="No-Break"><em class="italic">JDBC-based Authentication</em></span><span class="No-Break">).</span></p>
<p>After restarting the application, you’ll again be prompted for a client certificate, but this time, you should be able to access areas of the site requiring authorization. You can see from the logs (if you have them <a id="_idIndexMarker567"/>enabled) that <a id="_idIndexMarker568"/>you have been logged in as the <span class="No-Break"><strong class="source-inline">admin1@example.com</strong></span><span class="No-Break"> user.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter08.01-calendar</strong></span><span class="No-Break">.</span></p>
<h3>How does Spring Security use certificate information?</h3>
<p>As previously discussed, Spring Security’s involvement in certificate exchange is to pick up information from the presented<a id="_idIndexMarker569"/> certificate and map the user’s credentials to a user service. What we did not see in the use of the <strong class="source-inline">.x509()</strong> method was the magic that makes this happen. Recall that when we set the client certificate up, a DN similar to an LDAP DN was associated with <span class="No-Break">the certificate:</span></p>
<pre class="source-code">
<strong class="source-inline">Owner: CN=admin@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT, C=US</strong></pre> <p>Spring Security uses the information in this DN to determine the actual username of the principal and it will look for this information in <strong class="source-inline">UserDetailsService</strong>. In particular, it allows for the specification of a regular expression, which is used to match a portion of the DN established with the<a id="_idIndexMarker570"/> certificate, and the utilization of this portion of the DN as the principal name. The implicit, default configuration for the <strong class="source-inline">.x509()</strong> method would be <span class="No-Break">as follows:</span></p>
<pre class="source-code">
http.x509(httpSecurityX509Configurer -&gt; httpSecurityX509Configurer
              .subjectPrincipalRegex("CN=(.*?)(?:,|$)")
              .userDetailsService(userDetailsService));</pre> <p>We can see that this regular expression would match the <strong class="source-inline">admin1@example.com</strong> value as the principal’s name. This regular expression must contain a single matching group, but it can be configured to support the username and DN issuance requirements of your application. For example, if the DNs for your organization’s certificates include the <strong class="source-inline">email</strong> or <strong class="source-inline">userid</strong> fields, the regular expressi<a id="_idTextAnchor282"/>on can be modified to use these <a id="_idTextAnchor283"/>values as the authenticated <span class="No-Break">principal’s name.</span></p>
<h3>How Spring Security certificate authentication works</h3>
<p>Let’s review the various <a id="_idIndexMarker571"/>actors involved in the review and evaluation of the client certificates and translation into a Spring-Security-authenticated session, with the help of the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 8.3 – Spring Security certificate authentication workflow" height="792" src="image/B21757_08_3.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Spring Security certificate authentication workflow</p>
<p>We can see that <strong class="source-inline">o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter</strong> is responsible for examining the request of an unauthenticated user for the presentation of client certificates. If it <a id="_idIndexMarker572"/>sees that the request includes a valid client certificate, it will extract the principal using <strong class="source-inline">o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor</strong>, using a regular expression matching the certificate owner’s DN, as <span class="No-Break">previously described.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Be aware that although the preceding diagram indicates that examination of the certificate occurs for unauthenticated users, a check can also be performed when the presented certificate identifies a different user than the one that was previously authenticated. This would result in a new authentication request using the newly provided credentials. The reason for this should be clear—any time a user presents a new set of credentials, the application must be aware of this and react in a responsible fashion by ensuring that the user is still able to <span class="No-Break">access it.</span></p>
<p>Once the certificate has been <a id="_idIndexMarker573"/>accepted (or rejected/ignored), as with other authentication mechanisms, an <strong class="source-inline">Authentication</strong> token is built and passed along to <strong class="source-inline">AuthenticationManager</strong> for authentication. We can now review the very brief illustration of the <strong class="source-inline">o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider</strong> handling of the <span class="No-Break">authentication token:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow" height="1237" src="image/B21757_08_4.jpg" width="1468"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow</p>
<p>Though we will not go over them in detail, there are a number of other pre-authenticated mechanisms supported by Spring Security. Some examples include Java EE role mapping (<strong class="source-inline">J2eePreAuthenticatedProcessingFilter</strong>), WebSphere integration (<strong class="source-inline">WebSpherePreAuthenticatedProcessingFilter</strong>), and SiteMinder-style authentication (<strong class="source-inline">RequestHeaderAuthenticationFilter</strong>). If you understand the process <a id="_idIndexMarker574"/>flow of client certificate authentication, understanding these other authentication types is <span class="No-Break">significantly easier.</span></p>
<h3>Handling unauthenticated requests with AuthenticationEntryPoint</h3>
<p>Since <strong class="source-inline">X509AuthenticationFilter</strong> will continue processing the request if authentication fails, we’ll need to handle situations where the user does not authenticate successfully<a id="_idIndexMarker575"/> and has requested a protected resource. The way that Spring Security allows developers to customize this is by plugging in a custom <strong class="source-inline">o.s.s.web.AuthenticationEntryPoint</strong> implementation. In a default form login scenario, <strong class="source-inline">LoginUrlAuthenticationEntryPoint</strong> is used to redirect the user to a login page if they have been denied access to a protected resource and are <span class="No-Break">not authenticated.</span></p>
<p>In contrast, in typical client certificate authentication environments, alternative methods of authentication are simply not supported (remember that Tomcat expects the certificate well before the Spring Security form login takes place anyway). As such, it doesn’t make sense to retain the default behavior of redirection to a form login page. Instead, we’ll modify the entry point to simply return an <strong class="source-inline">HTTP 403 Forbidden</strong> message, using <strong class="source-inline">o.s.s.web.authentication.Http403ForbiddenEntryPoint</strong>. Go ahead and make the following updates in your <strong class="source-inline">SecurityConfig.java</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
        PersistentTokenRepository persistentTokenRepository,
        Http403ForbiddenEntryPoint forbiddenEntryPoint) throws Exception {
    http.authorizeRequests( authz -&gt; authz
                .requestMatchers(antMatcher("/webjars/**")).permitAll()
...
          .exceptionHandling(exceptions -&gt; exceptions
                .authenticationEntryPoint(forbiddenEntryPoint)
                .accessDeniedPage("/errors/403"))
...
    return http.build();
}
@Bean
public Http403ForbiddenEntryPoint forbiddenEntryPoint(){
    return new Http403ForbiddenEntryPoint();
}</pre> <p>Now, if a user tries to <a id="_idIndexMarker576"/>access a protected resource and is unable to provide a valid certificate, they will be presented with the following page, instead of being redirected to the <span class="No-Break">login page:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 8.5 – Spring Security forbidden error" height="523" src="image/B21757_08_5.jpg" width="961"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Spring Security forbidden error</p>
<p class="callout-heading">Important note</p>
<p class="callout">We have removed the username of <strong class="source-inline">admin1@example.com</strong>,<span class="P---Regular-Char"> to make sure there is no matching user with the </span><span class="No-Break"><span class="P---Regular-Char">certificate CN.</span></span></p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter08.02-calendar</strong></span><span class="No-Break">.</span></p>
<p>Other configuration<a id="_idIndexMarker577"/> or application flow adjustments that are commonly performed with client certificate authentication are <span class="No-Break">as follows:</span></p>
<ul>
<li>Removal of the form-based login <span class="No-Break">page altogether</span></li>
<li>Removal of the logout link (as there’s no reason to log out because the browser will always present the <span class="No-Break">user’s certificate)</span></li>
<li>Removal of the functionality to rename the user account and change <span class="No-Break">the password</span></li>
<li>Removal of the user registration functionality (unless you are able <a id="_idTextAnchor284"/><a id="_idTextAnchor285"/>to tie it into the issuance of a <span class="No-Break">new certificate)</span></li>
</ul>
<h3>Supporting dual-mode authentication</h3>
<p>It is also possible that some environments may support both certificate-based and form-based authentication. If this is the case in your environment, it is also possible (and trivial) to support it with Spring Security. We can simply leave the default <strong class="source-inline">AuthenticationEntryPoint</strong> interface (redirecting to the form-based login page) intact and allow the user<a id="_idIndexMarker578"/> to log in using the standard login form if they do not supply a <span class="No-Break">client certificate.</span></p>
<p>If you choose to configure your application this way, you’ll need to adjust the Tomcat SSL settings (change as appropriate for your application server). Simply change the <strong class="source-inline">clientAuth</strong> directive to <strong class="source-inline">want</strong>, instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" sslProtocol="TLS"
keystoreFile="conf/tomcat.keystore" keystorePass="password" truststoreFile="conf/tomcat.truststore" truststorePass="password" clientAuth="want"
/&gt;</pre> <p>We’ll also need to remove the <strong class="source-inline">authenticationEntryPoint()</strong> method that we configured in the previous exercise so that the standard form-based authentication workflow takes over if the user isn’t able to supply a valid certificate upon the browser first <span class="No-Break">being queried.</span></p>
<p>Although this is convenient, there are a few things to keep in mind about dual-mode (form-based and certificate-based) authentication, <span class="No-Break">as follows:</span></p>
<ul>
<li>Most browsers will not re-prompt the user for a certificate if they have failed certificate authentication once, so make sure that your users are aware that they may need to reenter the browser to present their <span class="No-Break">certificate again.</span></li>
<li>Recall that a password is not required to authenticate users with certificates; however, if you are still using <strong class="source-inline">UserDetailsService</strong> to support your form-based authenticated users, this may be the same <strong class="source-inline">UserDetailsService</strong> object that you use to give the <strong class="source-inline">PreAuthenticatedAuthenticationProvider</strong> information about your users. This presents a potential security risk, as users who you intend to sign in only with certificates could potentially authenticate using form <span class="No-Break">login credentials.</span></li>
</ul>
<p>There are several ways to <a id="_idIndexMarker579"/>solve this problem, and they are described in the <span class="No-Break">following list:</span></p>
<ul>
<li>Ensure that the users authenticating with certificates have an appropriately strong password in your <span class="No-Break">user store.</span></li>
<li>Consider customizing your user store to clearly identify users who are enabled for form-based login. This can be tracked with an additional field in the table holding user account information, and with minor adjustment<a id="_idTextAnchor286"/>s to the SQL queries used by the <span class="No-Break"><strong class="source-inline">JpaDaoImpl</strong></span><span class="No-Break"> object.</span></li>
<li>Configure a separate user details store altogether for users who are logging in as certificate-authenticated users, to completely segregate them from users that are allowed to use <span class="No-Break">form-based login.</span></li>
<li>Dual-mode authentication can be a powerful addition to your site and can be deployed effectively and securely, provided that you keep in mind the situations under which users will be granted access <span class="No-Break">to it.</span></li>
</ul>
<h1 id="_idParaDest-186"><a id="_idTextAnchor287"/>Configuring client certificate authentication using Spring beans</h1>
<p>Earlier in this chapter, we reviewed<a id="_idIndexMarker580"/> the flow of the classes involved in client certificate authentication. As such, it should be straightforward for <a id="_idIndexMarker581"/>us to configure the JBCP calendar using explicit beans. By using the explicit configuration, we will have additional configuration options at our disposal. Let’s take a look and see how to use <span class="No-Break">explicit configuration:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public X509AuthenticationFilter x509Filter(){
    return new X509AuthenticationFilter(){{
        setAuthenticationManager(authenticationManager);
    }};
}
@Bean
public PreAuthenticatedAuthenticationProvider preAuthAuthenticationProvider(final AuthenticationUserDetailsService authenticationUserDetailsService){
    return new PreAuthenticatedAuthenticationProvider(){{
        setPreAuthenticatedUserDetailsService (authenticationUserDetailsService);
    }};
}
@Bean
public UserDetailsByNameServiceWrapper authenticationUserDetailsService(final UserDetailsService userDetailsService){
    return new UserDetailsByNameServiceWrapper(){{
        setUserDetailsService(userDetailsService);
    }};
}</pre> <p>We’ll also need to remove the <strong class="source-inline">x509()</strong> method, add <strong class="source-inline">x509Filter</strong> to our filter chain, and add <a id="_idIndexMarker582"/>our <strong class="source-inline">AuthenticationProvider</strong> implementation <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">AuthenticationManger</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public AuthenticationManager authManager(HttpSecurity http) throws Exception {
    AuthenticationManagerBuilder authenticationManagerBuilder =
          http.getSharedObject(AuthenticationManagerBuilder.class);
    http.authenticationProvider(preAuthAuthenticationProvider);
    return authenticationManagerBuilder.build();
}</pre> <p>Now, give the application a try. Nothing<a id="_idIndexMarker583"/> much has changed from a user perspective, but as developers, we have opened the door to a number of additional <span class="No-Break">configuration options.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter08.03-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor288"/>Additional capabilities of bean-based configuration</h2>
<p>The use of Spring-bean-based <a id="_idIndexMarker584"/>configuration provides us with additional capabilities through the exposure of bean properties that aren’t exposed via the security namespace style <span class="No-Break">of configuration.</span></p>
<p>Additional properties available on <strong class="source-inline">X509AuthenticationFilter</strong> are <span class="No-Break">as follows:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Property</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Default</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">continueFilterChainOn</strong> <span class="No-Break"><strong class="source-inline">UnsuccessfulAuthentication</strong></span></p>
</td>
<td class="No-Table-Style">
<p>If false, a failed authentication will throw an exception rather than allow the request to continue. This would typically be set in cases where a valid certificate is expected and required to access the secured site. If true, the filter chain will proceed, even if there is a <span class="No-Break">failed authentication.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">checkForPrincipalChanges</strong></span></p>
</td>
<td class="No-Table-Style">
<p>If true, the filter will check to see whether the currently authenticated username differs from the username presented in the client certificate. If so, authentication against the new certificate will be performed and the HTTP session will be invalidated (optionally, see the next attribute). If false, once the user is authenticated, they will remain authenticated <a id="_idIndexMarker585"/>even if they present <span class="No-Break">different credentials.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">false</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">invalidateSessionOn</strong> <span class="No-Break"><strong class="source-inline">PrincipalChange</strong></span></p>
</td>
<td class="No-Table-Style">
<p>If true, and the principal in the request changes, the user’s HTTP session will be invalidated prior to being reauthenticated. If false, the session will remain—note that this may introduce <span class="No-Break">security risks.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – Properties available on X509AuthenticationFilter</p>
<p>The <strong class="source-inline">PreAuthenticatedAuthenticationProvider</strong> implementation has a couple of interesting properties available to us, which are listed in the <span class="No-Break">following table:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Property</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Default</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">preAuthenticated UserDetailsService</strong></span></p>
</td>
<td class="No-Table-Style">
<p>This property is used to build a full <strong class="source-inline">UserDetails</strong> object from the username extracted from <span class="No-Break">the certificate.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">None</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline" lang="en-US" xml:lang="en-US">throwExceptionWhen </strong><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">TokenRejected</strong></span></p>
</td>
<td class="No-Table-Style">
<p>If true, a <strong class="source-inline">BadCredentialsException</strong> exception will be thrown when the token is not constructed properly (does not contain a username or certificate). It is typically set to <strong class="source-inline">true</strong> in environments where certificates are <span class="No-Break">used exclusively.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">None</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – Properties available on PreAuthenticatedAuthenticationProvider</p>
<p>In addition to these properties, there are a number of other opportunities for implementing interfaces or<a id="_idIndexMarker586"/> extending classes involved in certificate authentication to further customize<a id="_idTextAnchor289"/> <span class="No-Break">your implementation.</span><a id="_idTextAnchor290"/></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor291"/>Considerations when implementing client certificate authentication</h2>
<p>Client certificate<a id="_idIndexMarker587"/> authentication, while highly secure, isn’t for everyone and isn’t appropriate for <span class="No-Break">every situation.</span></p>
<p>The pros of client <a id="_idIndexMarker588"/>certificate authentication are listed, <span class="No-Break">as follows:</span></p>
<ul>
<li>Certificates establish a framework of mutual trust and verifiability that both parties (client and server) are who they say <span class="No-Break">they are</span></li>
<li>Certificate-based authentication, if implemented properly, is much more difficult to spoof or tamper with than other forms <span class="No-Break">of authentication</span></li>
<li>If a well-supported browser is used and configured correctly, client certificate authentication can effectively act as a single sign-on solution, enabling transparent login to all <span class="No-Break">certificate-secured applications</span></li>
</ul>
<p>The cons of<a id="_idIndexMarker589"/> client certificate authentication are listed, <span class="No-Break">as follows:</span></p>
<ul>
<li>The use<a id="_idIndexMarker590"/> of certificates typically requires the entire user population to have them. This can lead to both a user training burden and an administrative burden. Most organizations deploying certificate-based authentication on a large scale must have sufficient self-service and helpdesk support for certificate maintenance, expiration <a id="_idIndexMarker591"/>tracking, and <span class="No-Break">user assistance.</span></li>
<li>The use of certificates is generally an all-or-nothing affair, meaning that mixed-mode authentication and offering support for non-certificated users is not provided due to the complexity of web server configuration or poor <span class="No-Break">application support.</span></li>
<li>The use of certificates may not be well supported by all users in your user population, including the ones who use <span class="No-Break">mobile devices.</span></li>
<li>The correct configuration of the infrastructure required to support certificate-based authentication may require advanced <span class="No-Break">IT knowledge.</span></li>
</ul>
<p>As you can see, there are both benefits and drawbacks to client certificate authentication. When implemented correctly, it can be a very convenient mode of access for your users and has extremely attractive security and non-repudiation properties. You will need to determine your particular situation to see whether or not this type of authentication <span class="No-Break">is appropr<a id="_idTextAnchor292"/>iate.</span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor293"/>Summary</h1>
<p>In this chapter, we examined the architecture, flow, and Spring Security support for client certificate-based authentication. We have covered the concepts and overall flow of client certificate (mutual) authentication. We explored the important steps required to configure Apache Tomcat for a self-signed SSL and client <span class="No-Break">certificate scenario.</span></p>
<p>We also learned about configuring Spring Security to understand certificate-based credentials presented by clients. We covered the architecture of Spring Security classes related to certificate authentication. We also know how to configure a Spring bean-style client certificate environment. We also covered the pros and cons of this type <span class="No-Break">of authentication.</span></p>
<p>It’s quite common for developers unfamiliar with client certificates to be confused by many of the complexities of this type of environment. We hope that this chapter has made this complicated subject a bit easier to understand <span class="No-Break">and implement!</span></p>
<p>In the next chapter, we will discuss <strong class="bold">Open Authorization</strong> (<strong class="bold">OAuth 2</strong>) protocol and how you can accomplish single sign-on with <strong class="bold">OpenID </strong><span class="No-Break"><strong class="bold">Connect</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OIDC</strong></span><span class="No-Break">).</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer065">
<h1 id="_idParaDest-190" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor294"/>Part 3: Exploring OAuth 2 and SAML 2</h1>
<p>This part focuses on OAuth 2, which is a widely adopted method for trusted identity management, empowering users to centrally manage their identities through a single trusted provider. Users benefit from the convenience of securely storing their passwords and personal information with the trusted OAuth 2 provider while retaining the option to disclose personal information as needed. Websites implementing OAuth 2 authentication can trust that users presenting OAuth 2 credentials are <span class="No-Break">authenticated individuals.</span></p>
<p>In the exploration of SAML 2 support, we delve into the intricacies of integrating <strong class="bold">Security Assertion Markup Language</strong> (<strong class="bold">SAML 2.0</strong>) into Spring Security applications. SAML 2.0, an XML-based standard, facilitates the exchange of authentication and authorization data between <strong class="bold">Identity Providers</strong> (<strong class="bold">IdP</strong>) and <strong class="bold">Service Providers</strong> (<strong class="bold">SP</strong>), offering seamless integration within Spring <span class="No-Break">Security frameworks.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21757_09.xhtml#_idTextAnchor295"><em class="italic">Chapter 9</em></a>, <em class="italic">Opening </em><em class="italic">up</em><em class="italic"> to OAuth 2</em></li>
<li><a href="B21757_10.xhtml#_idTextAnchor314"><em class="italic">Chapter 10</em></a>, <em class="italic">SAML 2 Support</em></li>
</ul>
</div>
<div>
<div id="_idContainer066">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer067">
</div>
</div>
</div></body></html>