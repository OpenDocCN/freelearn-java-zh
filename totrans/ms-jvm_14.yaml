- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Reflection API is a powerful and versatile tool that enables developers
    to access the inner workings of Java programs. In this chapter, we will explore
    the various capabilities of reflection, such as field access, method invocation,
    and proxy usage. Reflection allows developers to inspect and manipulate classes
    and objects at runtime, providing a dynamic gateway into JVM internals. Throughout
    this chapter, we will delve into the nuances of reflective field interactions,
    the intricacies of dynamically invoking methods, and the strategic deployment
    of proxies to enhance code flexibility. Join us on a journey into the heart of
    Java’s reflective capabilities, where the seemingly unchangeable becomes adaptable,
    and the boundaries of static code are stretched to accommodate the dynamic requirements
    of advanced applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring practical reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter’s GitHub repository, found at [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection, a fundamental feature of the Java programming language, bestows
    upon developers the ability to inspect and manipulate the structure, behavior,
    and metadata of classes and objects at runtime. This dynamic capability might
    open a Pandora’s box of possibilities, allowing programmers to transcend the confines
    of static code and respond to the evolving needs of their applications. Why is
    reflection so crucial to Java development?
  prefs: []
  type: TYPE_NORMAL
- en: Reflection in Java finds practical use in specialized scenarios, such as framework
    and library development, empowering developers to create flexible and extensible
    code. It plays a pivotal role in **dependency injection** (**DI**) containers,
    **object-relational mapping** (**ORM**) frameworks, and testing frameworks, enabling
    dynamic class instantiation and configuration. Reflection is also essential in
    serialization and deserialization libraries, GUI development tools, and Java’s
    core libraries, contributing to the dynamic loading and manipulation of objects
    and classes. While it may not be a daily tool for most developers, reflection
    proves its worth in enhancing code reusability and adaptability in specific domains,
    making it an invaluable asset in the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, reflection plays a pivotal role in achieving introspection, enabling
    programs to examine and adapt to their structure. It becomes particularly valuable
    when dealing with frameworks, libraries, and tools that must operate generically
    and flexibly, accommodating various types and structures dynamically. Reflection
    facilitates the retrieval of class information, method signatures, and field details,
    offering a level of dynamism essential for scenarios where a deep understanding
    of the code base at runtime is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, reflection fuels the development of tools such as IDEs, debuggers,
    and application servers, providing them with the means to analyze and manipulate
    Java code in a manner that transcends the constraints of compile-time knowledge.
    By offering a programmatic interface to class information and facilitating dynamic
    instantiation, reflection lays the groundwork for sophisticated frameworks and
    runtime environments.
  prefs: []
  type: TYPE_NORMAL
- en: While reflection is a distinctive feature of Java, similar concepts exist in
    other programming languages. For example, languages such as Python, C#, and Ruby
    also embrace reflective capabilities to varying extents. In Python, the `inspect`
    module allows for runtime introspection, while C# incorporates reflection for
    dynamic type discovery and invocation. Understanding reflection in the broader
    context of programming languages provides developers with a versatile skill set
    that can be applied across different technological landscapes. As we delve deeper
    into this chapter, we will unravel the intricacies of Java’s Reflection API, exploring
    its nuances and applications that make it a cornerstone of dynamic and adaptable
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the Java Reflection API empowers developers with dynamic capabilities,
    it has a set of trade-offs that should be carefully considered. Understanding
    these trade-offs is crucial for making informed decisions about when to leverage
    reflection and when to seek alternative approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance overhead**: One of the primary trade-offs associated with reflection
    is its performance overhead. Reflective operations, such as accessing fields,
    invoking methods, or creating instances dynamically, are generally slower than
    their non-reflective counterparts. Reflection involves runtime type checking and
    method resolution, which can incur additional computational costs. Consequently,
    in performance-critical applications or situations where rapid execution is paramount,
    relying excessively on reflection may lead to suboptimal performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile-time safety**: Reflection bypasses some of Java’s compile-time checks.
    Since reflection allows for dynamic access to classes, fields, and methods, the
    compiler cannot catch certain errors until runtime. This lack of compile-time
    safety increases the likelihood of runtime exceptions, making the code more error-prone.
    When using reflection, developers must be vigilant in handling potential issues
    such as missing classes, methods, or type mismatches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code readability and maintenance**: Reflective code can be more challenging
    to read and maintain. The absence of explicit type information in reflective operations
    makes the code less self-documenting, and it may be harder for developers to understand
    the program’s structure and behavior. It can increase complexity and reduce maintainability,
    especially in larger code bases where reflection is pervasive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security concerns**: Reflection can introduce security risks, especially
    in environments where security is a top priority, such as web applications. By
    dynamically accessing and manipulating classes and methods, reflective code can
    potentially violate access controls and security constraints. Careful consideration
    and validation are necessary to ensure that reflective operations do not compromise
    the integrity and security of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform dependence**: Reflection might be platform-dependent, and certain
    reflective operations may behave differently on different JVM implementations.
    It can introduce challenges in writing portable and cross-platform code. Developers
    should be cautious when relying on reflection in scenarios where platform independence
    is a critical requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While reflection provides powerful mechanisms for dynamic code manipulation,
    developers should weigh its advantages against these trade-offs. It is essential
    to use review judiciously, considering factors such as performance requirements,
    code maintainability, and security implications to balance flexibility and the
    potential drawbacks associated with reflective programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a framework perspective, reflection is often intertwined with a broader
    set of processes to dynamically understand and interact with the structure of
    Java classes and objects. Let’s break down the reflection process within a framework,
    considering a hypothetical scenario illustrated in this step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Framework initialization and reflection engine loading**: The process begins
    with the initialization of the framework. At this stage, the framework’s core
    components, including the reflection engine, are loaded into the runtime environment
    (Ruime). The reflection engine is how the framework dynamically interacts with
    and manipulates classes and objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code compilation and annotation processing**: Developers write code that
    includes annotations and reflection-related elements. This code undergoes the
    standard Java compilation process. During compilation, the Java compiler reads
    the source code, processes annotations, and generates bytecode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Loading classes into Ruime**: Ruime, the runtime environment, is responsible
    for loading the compiled classes into memory. As part of this process, the reflection
    engine within Ruime gains awareness of the available classes and their structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reflection engine reads annotations**: The reflection engine, now aware of
    the loaded classes, begins to scan for annotations within these classes. Annotations
    are metadata that provides additional information about the code and plays a crucial
    role in reflective frameworks. The reflection engine reads and interprets these
    annotations to dynamically understand how to interact with the annotated elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency tree generation**: The reflection engine generates a dependency
    tree based on information gathered from annotations and other reflective elements.
    This tree outlines the relationships between classes, methods, and fields, providing
    a dynamic blueprint of the program’s structure. The tree serves as a guide for
    the framework to navigate and manipulate the code at runtime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execution of dynamic code**: The framework can now dynamically execute code
    with the dependency tree in place. It could involve creating instances of classes,
    invoking methods, or accessing fields based on runtime information gathered through
    reflection. The framework leverages the reflective capabilities to adapt its behavior
    dynamically, responding to the specific conditions encountered during runtime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As JVM initializes, the reflection engine loads, setting the stage for a code
    compilation ballet. Annotations, the silent choreographers, guide the reflection
    engine through loaded classes. In JVM memory, a dependency tree emerges, a blueprint
    of the runtime structure. This ethereal map becomes the key to dynamic execution,
    where the framework adapts in real time. Arrows trace the fluid path from class
    loading to execution, encapsulating the transformative essence of reflective frameworks.
    Behold the graphic ode to dynamic prowess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The Java perspective using reflection](img/B22030_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The Java perspective using reflection'
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this part, the intricacies of reflection within a framework unfold
    like a well-choreographed performance. The journey from framework initialization
    to dynamic code execution, guided by the reflection engine and annotated insights,
    paints a vivid picture of adaptability and versatility. Now, armed with an understanding
    of reflection’s role in shaping runtime dynamics, we transition seamlessly into
    the next section, where theory transforms into practice. Brace yourself for a
    hands-on exploration of the Reflection API, where we will delve into real-world
    scenarios, demonstrating how to leverage reflection for field access, method invocation,
    and the strategic use of proxies. Through practical examples, we will bridge the
    conceptual foundations laid in this chapter with tangible applications, empowering
    you to wield reflection as a powerful tool in your Java development arsenal. Get
    ready to witness the Reflection API in action, breathing life into the theoretical
    constructs we’ve explored thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring practical reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this hands-on section, we delve into the practical application of Java’s
    Reflection API by creating a versatile `Mapper` interface. We aim to implement
    methods that dynamically convert objects of a given class to and from `Map<String,
    Object>`. The `Mapper` interface serves as a blueprint for a generic solution,
    allowing us to flex the muscles of reflection in a real-world scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with the `Mapper` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `toMap` method is designed to convert an object of type `T` into a map,
    where each key-value pair represents a field name and its corresponding value.
    Conversely, the `toEntity` method reverses this process, reconstructing an object
    of type `T` from a given map.
  prefs: []
  type: TYPE_NORMAL
- en: Now, armed with the theory from the previous part, we’ll put reflection into
    practice to implement these methods. Our journey will involve dynamically inspecting
    class structures, accessing fields, and creating instances at runtime. Through
    hands-on coding exercises, we aim to demystify the power of reflection and showcase
    its practical utility in building flexible and adaptable solutions.
  prefs: []
  type: TYPE_NORMAL
- en: So, buckle up for an engaging session where we bridge the gap between theory
    and application, crafting a dynamic `Mapper` interface that transforms objects
    into maps and back again using the magic of reflection. Let’s dive into the fascinating
    world of practical reflection and witness the code in action!
  prefs: []
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of technology, seamless migration between different
    paradigms often requires bridging conventions. A common challenge arises with
    varying naming conventions, such as Java’s camel case and certain databases’ snake
    case preferences. To tackle this, we introduce the `Column` annotation, allowing
    developers to define custom column names during object-to-map conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the `Column` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This annotation, applicable to fields (`ElementType.FIELD`), carries a `value`
    attribute. If provided, this attribute allows developers to specify a custom column
    name; otherwise, the field name is used by default. This flexibility enables a
    seamless mapping between Java objects and database structures, accommodating diverse
    naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, to mark a class as eligible for parsing, we introduce the `Entity`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Applied to the class level (`ElementType.TYPE`), this annotation signals that
    the class can undergo parsing operations. These annotations, when combined, empower
    developers to annotate their Java classes selectively, tailoring the conversion
    process based on the specific requirements of each class.
  prefs: []
  type: TYPE_NORMAL
- en: We introduce the `Appends` annotation to enhance flexibility and customization
    within our `Mapper` framework. This annotation, along with its companion `Append`
    annotation, provides a means to define default values for entities, enriching
    the object-to-map conversion process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into the definitions of these annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Appends` annotation, applied at the class level (`ElementType.TYPE`), holds
    an array of `Append` annotations. Each `Append` annotation, in turn, allows developers
    to specify a key-value pair, indicating the default values to be appended during
    the object-to-map conversion process.
  prefs: []
  type: TYPE_NORMAL
- en: The `Append` annotation is marked as repeatable (`@Repeatable(Appends.class)`)
    to simplify the specification of multiple append values on a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: In the dynamic landscape of Java development, seamlessly converting objects
    to maps and vice versa is a powerful feature, especially when navigating diverse
    naming conventions or dealing with data migration scenarios. Implementing the
    `toEntity` method within the `ReflectionMapper` class marks a pivotal point in
    our journey through reflection-driven mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method bridges the map representation of an object and its reconstitution
    as a fully realized entity. Through the lens of Java reflection, we embark on
    a step-by-step exploration, unraveling the intricacies of reconstructing an object
    from a map of its properties. The following code shows the implementation of `toEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `toEntity` method reconstructs an entity from a map, dynamically mapping
    fields using reflection. It ensures a non-null map, instantiates the entity using
    the provided class name, and iterates through the fields. Key determination involves
    `@Column` annotations or field names. Values are retrieved from the map and set
    in the object using reflection. The method returns the reconstructed entity, exemplifying
    a concise and dynamic object restoration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map validation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method begins by ensuring that the input `map` instance is not null, throwing
    a `NullPointerException` exception with the specified error message if it is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Entity instantiation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the fully qualified class name stored in the map, the `getEntity` method
    is called to dynamically instantiate an object of type `T` (the entity).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Class-type retrieval**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getClass` method is employed to obtain the runtime class of the entity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Field iteration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method iterates over the declared fields of the class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Column** **key determination**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each field, it determines the key associated with it. If the `Column` annotation
    is present, it uses the specified column name; otherwise, it defaults to the field
    name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Value retrieval** **and assignment**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It retrieves the corresponding value from the map using the determined key.
    If a value is present, it utilizes the `setValue` method to set the value in the
    object using reflection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Reconstructed entity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the reconstructed entity is returned, now populated with values from
    the map based on the reflection process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method demonstrates the dynamic reconstruction of an object using reflection,
    considering the custom annotations (`@Column`) for field-to-key mapping. It showcases
    the flexibility of `ReflectionMapper` in adapting to diverse class structures
    during the object-to-map conversion reversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toMap` method within the `ReflectionMapper` class is critical in exploring
    dynamic mapping using Java reflection. This method takes an object of type `T`
    as input and dynamically converts it into a `Map<String, Object>` instance. Let’s
    unravel the intricacies of this method step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`toMap` method utilizes reflection to dynamically convert Java objects into
    `Map<String, Object>`. It ensures non-null input, explores fields with `@Column`
    annotations, and maps their values. Class-level `@Append` annotations contribute
    default key-value pairs. This concise method exemplifies the efficiency of reflection
    for dynamic object-to-map transformations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method begins by ensuring that the input `entity` instance is not null,
    throwing a `NullPointerException` exception with the specified error message if
    it is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Map initialization**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `HashMap` instance is initialized to store the key-value pairs representing
    the properties of the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Class-type retrieval**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method retrieves the runtime class of the entity and stores its fully qualified
    name in the map using the `ENTITY_ENTRY` key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Field iteration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method iterates over the declared fields of the class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Accessibility setting**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The accessibility of the field is set to `true`, enabling access to private
    fields.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Column** **annotation check**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each field, it checks for the presence of the `Column` annotation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Column** **key determination**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `Column` annotation is present, it determines the key associated with
    the field. It uses the specified column name or defaults to the field name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Value retrieval** **and assignment**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It retrieves the field value using the `getValue` method and adds the key-value
    pair to the map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**@Append** **annotation processing**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It processes `@Append` annotations at the class level, adding default key-value
    pairs to the map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resulting map**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the resulting map, representing the object’s properties, is returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This `toMap` method exemplifies the adaptability of reflection in dynamically
    mapping object properties to a map. It showcases how annotations and field-level
    details are harnessed to create a versatile and extensible mapping mechanism within
    the `ReflectionMapper` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our exploration of reflection-based mapping techniques, we’ll turn our attention
    to practical examples using two distinct entities: `Pet` and `Fruit`. These entities
    are adorned with annotations that provide valuable insights into the dynamic capabilities
    of `ReflectionMapper`. Let’s delve into each entity, examining their structures
    and the annotations that will guide our mapping journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Pet` entity is a simple `@Entity` annotation, signifying its eligibility
    for reflection-based mapping. Each field, such as `name` and `age`, is tagged
    with `@Column`, indicating their inclusion in the mapping process. This straightforward
    structure serves as an excellent starting point for understanding how the `ReflectionMapper`
    class dynamically handles object-to-map conversion and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the `Fruit` entity which has additional settings than the
    previous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Fruit` entity, on the other hand, not only carries the `@Entity` annotation
    but also leverages the `@Append` annotation at the class level. This introduces
    default key-value pairs (`"type": "Fruit"` and `"category": "Natural"`) during
    the mapping process. The class showcases flexibility by including both a deprecated
    and non-deprecated constructor, highlighting how the `ReflectionMapper` class
    adapts to different entity structures.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will execute the `ReflectionMapper` class on instances
    of these entities, unveiling the power of reflection in handling diverse class
    structures and annotations. Through this practical application, we aim to provide
    a comprehensive understanding of how reflection can be harnessed for dynamic object-to-map
    conversion and reconstruction. Let the mapping journey with `Pet` and `Fruit`
    commence!
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the practical application of the `ReflectionMapper` class on our
    diverse entities, we’ve devised a comprehensive `MapperTest` class. This series
    of tests demonstrates the mapper’s ability to seamlessly convert entities to maps
    and reconstruct entities from maps, showcasing the flexibility and adaptability
    of reflection in dynamic mapping scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**shouldConvertToMap**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test ensures that the **ReflectionMapper** class can successfully convert
    a **Pet** entity into a map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It verifies specific keys’ presence and corresponding values in the generated
    map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shouldConvertEntity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this test, a map representing a **Pet** entity is converted back into the
    original entity using **ReflectionMapper**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions validate the correctness of the reconstructed **Pet** object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shouldConvertEntityRepeatable**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test focuses on converting a **Fruit** entity, which includes repeatable
    annotations, into a map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It verifies the presence of default key-value pairs and entity-specific values
    in the resulting map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Through these tests, we aim to illustrate how the `ReflectionMapper` class seamlessly
    handles various entities, annotations, and object-to-map conversions, emphasizing
    the practical utility of reflection in dynamic mapping scenarios. Let the testing
    commence, revealing the prowess of reflection in action!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved deep into the intricate world of reflection, unraveling
    its potential in dynamic object-to-map conversions through the lens of the `ReflectionMapper`
    class. We explored the reflection’s flexibility and adaptability, showcasing its
    prowess in handling diverse entity structures and annotations. As we conclude
    this segment, we stand at the threshold of another fascinating realm—dynamic proxies.
    The upcoming section will usher us into the world of `MapperRepository`, where
    we will harness the power of dynamic proxies to switch between entities and their
    map representations seamlessly. Brace yourself for exploring the dynamic and versatile
    landscape of proxies as we unveil their role in enhancing reflection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic proxies in Java are indispensable tools that enable the creation of
    objects at runtime, implementing one or more interfaces, and intercepting method
    invocations. The `MapperRepository` class introduces us to the profound utility
    of dynamic proxies, where their application becomes paramount in seamlessly switching
    between entities and their corresponding map representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic proxies stand as veritable champions in the arsenal of Java’s runtime
    capabilities, offering a trove of advantages that elevate code’s adaptability,
    flexibility, and conciseness. Their inherent adaptability allows for creating
    proxy instances on the fly, accommodating diverse interfaces at runtime, and facilitating
    seamless integration in scenarios where object structures are only known at runtime.
    The ability to intercept method invocations empowers dynamic proxies to inject
    custom logic seamlessly, enhancing functionalities without compromising the integrity
    of core operations. This interception mechanism enables cleaner `MapperRepository`,
    dynamic proxies emerge as the linchpin, embodying the ethos of adaptability and
    efficiency in the dynamic mapping landscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adaptability and flexibility**: Dynamic proxies offer unparalleled adaptability,
    allowing us to create proxy instances for diverse interfaces at runtime. This
    adaptability becomes crucial when dealing with scenarios where the structure of
    objects or interfaces is not known until runtime. In the context of **MapperRepository**,
    dynamic proxies empower us to handle multiple entity types without a priori knowledge,
    fostering a more flexible and extensible design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interception of method invocations**: One of the key advantages of dynamic
    proxies is their ability to intercept method calls. This interception mechanism
    allows one to perform actions before and after method execution. In the realm
    of mapping entities to maps and vice versa, this interception becomes instrumental.
    It enables us to seamlessly inject conversion logic, enhancing the mapping process
    without altering the core logic of entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced boilerplate code**: Dynamic proxies significantly reduce the need
    for boilerplate code. They allow us to centralize cross-cutting concerns, such
    as logging or validation, by encapsulating these concerns within the proxy. In
    the context of **MapperRepository**, this leads to cleaner, more concise code
    for the conversion between entities and maps, promoting maintainability and readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However powerful, the utilization of dynamic proxies in Java does not come without
    its set of considerations and trade-offs. One of the primary trade-offs lies in
    the performance overhead incurred by the dynamic nature of proxies, as the interception
    of method calls and the runtime creation of proxy instances can introduce a slight
    execution delay compared to direct method calls. Additionally, reliance on interface-based
    proxies restricts their application to scenarios involving interfaces, posing
    limitations in scenarios where class-based proxies may be more fitting. Recognizing
    these trade-offs is paramount, as it allows for informed decision-making when
    implementing dynamic proxies, especially in performance-sensitive contexts. Despite
    these considerations, the benefits offered by dynamic proxies, such as enhanced
    flexibility and reduced boilerplate code, often outweigh these trade-offs, reinforcing
    their indispensable role in dynamic and adaptable Java applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Performance overhead**: While dynamic proxies provide immense flexibility,
    their dynamic nature introduces a performance overhead. The interception of method
    calls and the creation of proxy instances at runtime can lead to slightly slower
    execution compared to direct method calls. Careful consideration is required when
    applying dynamic proxies in performance-critical scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations on class-based proxies**: Dynamic proxies in Java are interface-based,
    limiting their application to scenarios involving interfaces. Class-based proxies
    are not as prevalent, and certain scenarios may require alternative solutions
    or compromises. Understanding these limitations is crucial for making informed
    decisions in design and implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the ever-evolving landscape of Java, `MapperRepository` emerges as a pivotal
    interface, seamlessly intertwining the capabilities of reflection and dynamic
    proxies. This interface serves as a gateway to the dynamic world of object-to-map
    conversions and vice versa, harnessing the intrinsic power of reflection to navigate
    and manipulate entities at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Interface description**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**entity**: This method takes a map representing an object’s properties and
    dynamically reconstructs an object of type **T** at runtime. Leveraging reflection,
    it navigates through the map, creating a dynamic proxy entity that adapts to the
    structure of the provided map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**map**: Conversely, the **map** method accepts an entity of type **T** and
    dynamically generates a map representing its properties. Through reflection and
    dynamic proxies, this method navigates the entity’s structure, creating a map
    that encapsulates the key-value pairs of its properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The true prowess of `MapperRepository` lies in its symbiotic relationship with
    reflection. When reconstructing entities from maps, reflection allows the dynamic
    exploration of the object’s structure, identifying fields, methods, and annotations.
    This exploration and dynamic proxies enable seamless adaptation to varying entity
    types, rendering `MapperRepository` a versatile tool for dynamic mappings.
  prefs: []
  type: TYPE_NORMAL
- en: On the reverse journey, when converting entities to maps, reflection plays a
    pivotal role in introspecting the object’s structure. Information gleaned through
    reflection guides the creation of a map that accurately represents the object’s
    properties. Dynamic proxies enhance this process by intercepting method invocations,
    allowing for custom logic injection, and providing a dynamic approach to object-to-map
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our journey into dynamic proxies and reflection with `MapperRepository`
    unfolds, we step into the implementation arena by introducing the `MapperInvocationHandler`
    class. This implementation, serving as the `InvocationHandler` class for dynamic
    proxies, bridges the abstract realm of dynamic mappings defined in `MapperRepository`
    to the concrete operations facilitated by the underlying `ReflectionMapper` class.
    Let’s delve into the simplicity and power encapsulated within this handler, unlocking
    the potential for robust, customizable dynamic mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MapperInvocationHandler` class, implementing `InvocationHandler`, mediates
    dynamic mappings. It uses a `ReflectionMapper` instance to convert maps to entities
    or entities to maps based on method calls. The handler supports default methods
    and ensures a smooth connection between dynamic proxies and the underlying mapping
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic method routing**: The **invoke** method dynamically routes method
    calls based on their names. For the **entity** method, it extracts the map from
    the provided parameters and delegates the operation to **ReflectionMapper** for
    entity reconstruction. Conversely, the **map** method, it extracts the entity
    and delegates it to **ReflectionMapper** for map creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling default methods**: The handler accounts for default methods in the
    **MapperRepository** interface. If a default method is invoked, it gracefully
    delegates the call using **InvocationHandler.invokeDefault**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception handling**: In cases where an unsupported method is encountered,
    an **UnsupportedOperationException** exception is thrown, providing clear feedback
    on the limitations of the dynamic proxy in handling certain operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the standout features of this implementation lies in its potential for
    customizability. Extending the logic within each method case makes it feasible
    to check annotation parameters, opening the door to many customization possibilities.
    This approach transforms `MapperRepository` into a robust and adaptable tool,
    ready to cater to diverse mapping scenarios through the lens of reflection.
  prefs: []
  type: TYPE_NORMAL
- en: In exploring dynamic proxies and reflection within the realm of `MapperRepository`,
    `MapperInvocationHandler` emerges as a linchpin, seamlessly connecting abstract
    mappings to concrete operations. Its dynamic method routing and the ability to
    handle default methods make it a powerful orchestrator of dynamic mappings. The
    simplicity of the implementation belies its potential for customization, offering
    a pathway to inspect annotation parameters and tailor the mapping process to diverse
    scenarios. As we conclude this chapter, `MapperInvocationHandler` is a testament
    to the symbiotic relationship between dynamic proxies and reflection, showcasing
    their combined might in creating adaptable, customizable, and dynamic mapping
    solutions in Java. The upcoming practical application will illuminate how this
    implementation transforms abstract concepts into a toolset that empowers developers
    to navigate the intricate landscape of dynamic mappings easily.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our exploration of dynamic proxies and reflection, amalgamating these powerful
    Java features as `MapperInvocationHandler` marks a pivotal moment in our journey.
    The ability to dynamically route method calls and the potential for customization
    through annotation parameters underscore the versatility encapsulated within this
    implementation. Yet, this is merely a precursor to the next chapter, where we
    dive into the sophisticated realm of Java annotation processing. Building upon
    the foundation of dynamic mappings, the annotation processor promises to elevate
    our capabilities further, offering a structured and compile-time approach to harnessing
    metadata within our code. Join us in the upcoming chapter as we unveil the intricate
    world of Java annotation processing, where compile-time reflection becomes a cornerstone
    in crafting efficient, robust, and intelligently processed Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the primary purpose of the MapperInvocationHandler class in the context
    of dynamic proxies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling database connections
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing method calls for dynamic mappings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing complex business logic
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing XML configurations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which feature makes dynamic proxies adaptable in scenarios where object structures
    are not known until runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Interface-based implementation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic method routing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Static method invocation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the **MapperInvocationHandler** class demonstrate customizability in
    the dynamic mapping process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses hardcoded values for method calls.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It leverages external libraries for mapping.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It inspects annotation parameters and adapts the mapping logic.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It enforces strict immutability in mapped entities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary purpose of reflection in Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile-time code optimization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic exploration and manipulation of object structures
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure encryption of sensitive data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Asynchronous event handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of the **MapperRepository** interface, how does reflection contribute
    to dynamic mappings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It ensures type safety in method calls.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a secure encryption mechanism.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It dynamically routes method calls.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It enforces strict immutability in mapped entities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: B. Routing method calls for dynamic mappings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. Dynamic method routing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. It inspects annotation parameters and adapts the mapping logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Dynamic exploration and manipulation of object structures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. It dynamically routes method calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
