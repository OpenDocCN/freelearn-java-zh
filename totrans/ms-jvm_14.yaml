- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Reflection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: The Reflection API is a powerful and versatile tool that enables developers
    to access the inner workings of Java programs. In this chapter, we will explore
    the various capabilities of reflection, such as field access, method invocation,
    and proxy usage. Reflection allows developers to inspect and manipulate classes
    and objects at runtime, providing a dynamic gateway into JVM internals. Throughout
    this chapter, we will delve into the nuances of reflective field interactions,
    the intricacies of dynamically invoking methods, and the strategic deployment
    of proxies to enhance code flexibility. Join us on a journey into the heart of
    Java’s reflective capabilities, where the seemingly unchangeable becomes adaptable,
    and the boundaries of static code are stretched to accommodate the dynamic requirements
    of advanced applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 反射API是一个强大且多功能的工具，使开发者能够访问Java程序的内幕。在本章中，我们将探讨反射的各种功能，如字段访问、方法调用和代理使用。反射允许开发者检查和操作运行时的类和对象，为JVM内部提供了动态的入口。在本章中，我们将深入研究反射字段的微妙交互、动态调用方法的复杂性以及代理的战略部署以增强代码的灵活性。让我们一起探索Java反射能力的核心，在这里，看似不可改变的事物变得可适应，静态代码的边界被拉伸以适应高级应用程序的动态需求。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Overview of reflection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射概述
- en: Exploring practical reflection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实用的反射
- en: Proxy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要以下要求：
- en: Java 21
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Git
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: This chapter’s GitHub repository, found at [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于[https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-10)
- en: Overview of reflection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射概述
- en: Reflection, a fundamental feature of the Java programming language, bestows
    upon developers the ability to inspect and manipulate the structure, behavior,
    and metadata of classes and objects at runtime. This dynamic capability might
    open a Pandora’s box of possibilities, allowing programmers to transcend the confines
    of static code and respond to the evolving needs of their applications. Why is
    reflection so crucial to Java development?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 反射，Java编程语言的基本特性，赋予开发者检查和操作类和对象的结构、行为和元数据的能力。这种动态能力可能会打开潘多拉的盒子，让程序员超越静态代码的局限，并响应应用程序不断变化的需求。为什么反射对Java开发如此关键？
- en: Reflection in Java finds practical use in specialized scenarios, such as framework
    and library development, empowering developers to create flexible and extensible
    code. It plays a pivotal role in **dependency injection** (**DI**) containers,
    **object-relational mapping** (**ORM**) frameworks, and testing frameworks, enabling
    dynamic class instantiation and configuration. Reflection is also essential in
    serialization and deserialization libraries, GUI development tools, and Java’s
    core libraries, contributing to the dynamic loading and manipulation of objects
    and classes. While it may not be a daily tool for most developers, reflection
    proves its worth in enhancing code reusability and adaptability in specific domains,
    making it an invaluable asset in the Java ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，反射在实际场景中有着广泛的应用，如框架和库的开发，使开发者能够创建灵活和可扩展的代码。它在**依赖注入**（**DI**）、**对象关系映射**（**ORM**）框架和测试框架中发挥着关键作用，实现了动态类实例化和配置。反射在序列化和反序列化库、GUI开发工具和Java的核心库中也至关重要，有助于动态加载和操作对象和类。虽然它可能不是大多数开发者的日常工具，但反射在特定领域增强了代码的可重用性和适应性，使其成为Java生态系统中的宝贵资产。
- en: At its core, reflection plays a pivotal role in achieving introspection, enabling
    programs to examine and adapt to their structure. It becomes particularly valuable
    when dealing with frameworks, libraries, and tools that must operate generically
    and flexibly, accommodating various types and structures dynamically. Reflection
    facilitates the retrieval of class information, method signatures, and field details,
    offering a level of dynamism essential for scenarios where a deep understanding
    of the code base at runtime is paramount.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，反射在实现内省方面发挥着关键作用，使程序能够检查和适应其结构。当处理必须通用和灵活地操作的框架、库和工具时，它变得特别有价值，这些工具可以动态地适应各种类型和结构。反射促进了类信息、方法签名和字段细节的检索，为那些在运行时对代码库有深入理解至关重要的场景提供了必要的动态性。
- en: Moreover, reflection fuels the development of tools such as IDEs, debuggers,
    and application servers, providing them with the means to analyze and manipulate
    Java code in a manner that transcends the constraints of compile-time knowledge.
    By offering a programmatic interface to class information and facilitating dynamic
    instantiation, reflection lays the groundwork for sophisticated frameworks and
    runtime environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，反射促进了诸如集成开发环境（IDEs）、调试器和应用程序服务器等工具的发展，为它们提供了分析和操作Java代码的手段，这种手段超越了编译时知识的限制。通过提供对类信息的程序化接口并促进动态实例化，反射为复杂的框架和运行时环境奠定了基础。
- en: While reflection is a distinctive feature of Java, similar concepts exist in
    other programming languages. For example, languages such as Python, C#, and Ruby
    also embrace reflective capabilities to varying extents. In Python, the `inspect`
    module allows for runtime introspection, while C# incorporates reflection for
    dynamic type discovery and invocation. Understanding reflection in the broader
    context of programming languages provides developers with a versatile skill set
    that can be applied across different technological landscapes. As we delve deeper
    into this chapter, we will unravel the intricacies of Java’s Reflection API, exploring
    its nuances and applications that make it a cornerstone of dynamic and adaptable
    programming.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然反射是Java的一个独特特性，但其他编程语言中也存在类似的概念。例如，Python、C#和Ruby等语言也在不同程度上采用了反射能力。在Python中，`inspect`模块允许运行时内省，而C#则通过反射实现动态类型发现和调用。在更广泛的编程语言背景下理解反射，为开发者提供了一组灵活的技能集，这些技能可以在不同的技术领域中应用。随着我们深入本章，我们将揭示Java反射API的复杂性，探讨其细微之处和应用，使其成为动态和适应性编程的基石。
- en: 'While the Java Reflection API empowers developers with dynamic capabilities,
    it has a set of trade-offs that should be carefully considered. Understanding
    these trade-offs is crucial for making informed decisions about when to leverage
    reflection and when to seek alternative approaches:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java反射API赋予了开发者动态能力，但它有一系列权衡，应仔细考虑。理解这些权衡对于做出关于何时利用反射以及何时寻求替代方法的明智决策至关重要：
- en: '**Performance overhead**: One of the primary trade-offs associated with reflection
    is its performance overhead. Reflective operations, such as accessing fields,
    invoking methods, or creating instances dynamically, are generally slower than
    their non-reflective counterparts. Reflection involves runtime type checking and
    method resolution, which can incur additional computational costs. Consequently,
    in performance-critical applications or situations where rapid execution is paramount,
    relying excessively on reflection may lead to suboptimal performance.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：与反射相关的主要权衡之一是其性能开销。反射操作，如访问字段、调用方法或动态创建实例，通常比它们的非反射对应物要慢。反射涉及运行时类型检查和方法解析，这可能会产生额外的计算成本。因此，在性能关键的应用或快速执行至关重要的场合，过度依赖反射可能会导致性能不佳。'
- en: '**Compile-time safety**: Reflection bypasses some of Java’s compile-time checks.
    Since reflection allows for dynamic access to classes, fields, and methods, the
    compiler cannot catch certain errors until runtime. This lack of compile-time
    safety increases the likelihood of runtime exceptions, making the code more error-prone.
    When using reflection, developers must be vigilant in handling potential issues
    such as missing classes, methods, or type mismatches.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时安全性**：反射绕过了Java的一些编译时检查。由于反射允许动态访问类、字段和方法，编译器无法在运行时之前捕获某些错误。这种编译时安全性的缺乏增加了运行时异常的可能性，使得代码更容易出错。在使用反射时，开发者必须警惕处理潜在问题，如缺失的类、方法或类型不匹配。'
- en: '**Code readability and maintenance**: Reflective code can be more challenging
    to read and maintain. The absence of explicit type information in reflective operations
    makes the code less self-documenting, and it may be harder for developers to understand
    the program’s structure and behavior. It can increase complexity and reduce maintainability,
    especially in larger code bases where reflection is pervasive.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码可读性和维护性**：反思性代码可能更难以阅读和维护。在反思操作中缺乏显式的类型信息使得代码的自我文档化程度降低，开发者可能更难理解程序的结构和行为。这可能会增加复杂性并降低可维护性，尤其是在反射普遍存在的较大代码库中。'
- en: '**Security concerns**: Reflection can introduce security risks, especially
    in environments where security is a top priority, such as web applications. By
    dynamically accessing and manipulating classes and methods, reflective code can
    potentially violate access controls and security constraints. Careful consideration
    and validation are necessary to ensure that reflective operations do not compromise
    the integrity and security of the application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全担忧**：反射可能会引入安全风险，尤其是在安全至关重要的环境中，如Web应用程序。通过动态访问和操作类和方法，反思性代码可能违反访问控制和安全约束。必须仔细考虑和验证，以确保反思操作不会损害应用程序的完整性和安全性。'
- en: '**Platform dependence**: Reflection might be platform-dependent, and certain
    reflective operations may behave differently on different JVM implementations.
    It can introduce challenges in writing portable and cross-platform code. Developers
    should be cautious when relying on reflection in scenarios where platform independence
    is a critical requirement.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台依赖性**：反射可能具有平台依赖性，某些反思操作可能在不同的JVM实现上表现不同。它可能在编写可移植和跨平台代码时引入挑战。开发者应谨慎在平台独立性是关键要求的场景中依赖反射。'
- en: While reflection provides powerful mechanisms for dynamic code manipulation,
    developers should weigh its advantages against these trade-offs. It is essential
    to use review judiciously, considering factors such as performance requirements,
    code maintainability, and security implications to balance flexibility and the
    potential drawbacks associated with reflective programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然反射提供了强大的动态代码操作机制，但开发者应该权衡其优势与这些权衡。审慎地使用审查，考虑性能要求、代码可维护性和安全影响等因素，以平衡灵活性和与反思编程相关的潜在缺点。
- en: 'From a framework perspective, reflection is often intertwined with a broader
    set of processes to dynamically understand and interact with the structure of
    Java classes and objects. Let’s break down the reflection process within a framework,
    considering a hypothetical scenario illustrated in this step-by-step:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从框架的角度来看，反射通常与更广泛的过程交织在一起，以动态理解和交互Java类和对象的结构。让我们分析框架内的反思过程，考虑以下逐步说明的假设场景：
- en: '**Framework initialization and reflection engine loading**: The process begins
    with the initialization of the framework. At this stage, the framework’s core
    components, including the reflection engine, are loaded into the runtime environment
    (Ruime). The reflection engine is how the framework dynamically interacts with
    and manipulates classes and objects.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**框架初始化和反射引擎加载**：这个过程从框架的初始化开始。在这个阶段，框架的核心组件，包括反射引擎，被加载到运行时环境（Ruime）中。反射引擎是框架如何动态交互和操作类与对象的方式。'
- en: '**Code compilation and annotation processing**: Developers write code that
    includes annotations and reflection-related elements. This code undergoes the
    standard Java compilation process. During compilation, the Java compiler reads
    the source code, processes annotations, and generates bytecode.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码编译和注解处理**：开发者编写的代码包括注解和与反射相关的元素。此代码经过标准的Java编译过程。在编译过程中，Java编译器读取源代码，处理注解，并生成字节码。'
- en: '**Loading classes into Ruime**: Ruime, the runtime environment, is responsible
    for loading the compiled classes into memory. As part of this process, the reflection
    engine within Ruime gains awareness of the available classes and their structure.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将类加载到Ruime中**：Ruime，作为运行时环境，负责将编译后的类加载到内存中。在这个过程中，Ruime内部的反射引擎开始了解可用的类及其结构。'
- en: '**Reflection engine reads annotations**: The reflection engine, now aware of
    the loaded classes, begins to scan for annotations within these classes. Annotations
    are metadata that provides additional information about the code and plays a crucial
    role in reflective frameworks. The reflection engine reads and interprets these
    annotations to dynamically understand how to interact with the annotated elements.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反射引擎读取注解**：现在反射引擎已经了解加载的类，开始在这些类中扫描注解。注解是提供关于代码的额外信息的元数据，在反射框架中扮演着至关重要的角色。反射引擎读取并解释这些注解，以动态理解如何与注解元素交互。'
- en: '**Dependency tree generation**: The reflection engine generates a dependency
    tree based on information gathered from annotations and other reflective elements.
    This tree outlines the relationships between classes, methods, and fields, providing
    a dynamic blueprint of the program’s structure. The tree serves as a guide for
    the framework to navigate and manipulate the code at runtime.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成依赖树**：反射引擎根据从注解和其他反射元素收集的信息生成依赖树。这棵树概述了类、方法和字段之间的关系，提供了程序结构的动态蓝图。这棵树作为框架在运行时导航和操作代码的指南。'
- en: '**Execution of dynamic code**: The framework can now dynamically execute code
    with the dependency tree in place. It could involve creating instances of classes,
    invoking methods, or accessing fields based on runtime information gathered through
    reflection. The framework leverages the reflective capabilities to adapt its behavior
    dynamically, responding to the specific conditions encountered during runtime.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态代码执行**：现在框架可以基于现有的依赖树动态执行代码。这可能包括根据通过反射收集的运行时信息创建类的实例、调用方法或访问字段。框架利用反射能力动态地调整其行为，以响应运行时遇到的具体条件。'
- en: 'As JVM initializes, the reflection engine loads, setting the stage for a code
    compilation ballet. Annotations, the silent choreographers, guide the reflection
    engine through loaded classes. In JVM memory, a dependency tree emerges, a blueprint
    of the runtime structure. This ethereal map becomes the key to dynamic execution,
    where the framework adapts in real time. Arrows trace the fluid path from class
    loading to execution, encapsulating the transformative essence of reflective frameworks.
    Behold the graphic ode to dynamic prowess:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM初始化时，反射引擎加载，为代码编译芭蕾舞设定舞台。注解，无声的编舞者，引导反射引擎穿越加载的类。在JVM内存中，一个依赖树浮现，这是运行时结构的蓝图。这个虚幻的地图成为动态执行的关键，其中框架实时调整。箭头追踪从类加载到执行的流畅路径，封装了反射框架的转化本质。请看这幅对动态能力的图形颂歌：
- en: '![Figure 10.1: The Java perspective using reflection](img/B22030_10_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：使用反射的Java视角](img/B22030_10_01.jpg)'
- en: 'Figure 10.1: The Java perspective using reflection'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：使用反射的Java视角
- en: As we conclude this part, the intricacies of reflection within a framework unfold
    like a well-choreographed performance. The journey from framework initialization
    to dynamic code execution, guided by the reflection engine and annotated insights,
    paints a vivid picture of adaptability and versatility. Now, armed with an understanding
    of reflection’s role in shaping runtime dynamics, we transition seamlessly into
    the next section, where theory transforms into practice. Brace yourself for a
    hands-on exploration of the Reflection API, where we will delve into real-world
    scenarios, demonstrating how to leverage reflection for field access, method invocation,
    and the strategic use of proxies. Through practical examples, we will bridge the
    conceptual foundations laid in this chapter with tangible applications, empowering
    you to wield reflection as a powerful tool in your Java development arsenal. Get
    ready to witness the Reflection API in action, breathing life into the theoretical
    constructs we’ve explored thus far.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分结束时，框架内部的反射复杂性就像一场精心编排的表演一样展开。从框架初始化到由反射引擎和注解洞察引导的动态代码执行，描绘了一幅适应性和灵活性的生动画面。现在，我们理解了反射在塑造运行时动态中的作用，我们将无缝过渡到下一部分，其中理论将转化为实践。准备好进行一次动手探索反射API的旅程，我们将深入现实场景，展示如何利用反射进行字段访问、方法调用和代理的战略使用。通过实际示例，我们将本章中建立的概念基础与实际应用相结合，让您能够将反射作为强大的工具融入Java开发工具箱。准备好见证反射API的实际运行，为迄今为止探索的理论结构注入活力！
- en: Exploring practical reflection
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索实用的反射
- en: In this hands-on section, we delve into the practical application of Java’s
    Reflection API by creating a versatile `Mapper` interface. We aim to implement
    methods that dynamically convert objects of a given class to and from `Map<String,
    Object>`. The `Mapper` interface serves as a blueprint for a generic solution,
    allowing us to flex the muscles of reflection in a real-world scenario.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节动手实践中，我们通过创建一个通用的`Mapper`接口来深入探讨Java反射API的实际应用。我们的目标是实现将给定类对象动态转换为`Map<String,
    Object>`以及反向转换的方法。`Mapper`接口作为一个通用解决方案的蓝图，使我们能够在实际场景中运用反射的力量。
- en: 'Let’s begin with the `Mapper` interface:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Mapper`接口开始：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `toMap` method is designed to convert an object of type `T` into a map,
    where each key-value pair represents a field name and its corresponding value.
    Conversely, the `toEntity` method reverses this process, reconstructing an object
    of type `T` from a given map.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`toMap`方法旨在将类型为`T`的对象转换为映射，其中每个键值对代表一个字段名及其对应的值。相反，`toEntity`方法则逆向这个过程，从给定的映射中重建类型为`T`的对象。'
- en: Now, armed with the theory from the previous part, we’ll put reflection into
    practice to implement these methods. Our journey will involve dynamically inspecting
    class structures, accessing fields, and creating instances at runtime. Through
    hands-on coding exercises, we aim to demystify the power of reflection and showcase
    its practical utility in building flexible and adaptable solutions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，凭借前一部分的理论知识，我们将把反射应用到实践中来实现这些方法。我们的旅程将包括在运行时动态检查类结构、访问字段和创建实例。通过动手编码练习，我们旨在揭示反射的神秘力量，并展示其在构建灵活和适应性解决方案中的实际用途。
- en: So, buckle up for an engaging session where we bridge the gap between theory
    and application, crafting a dynamic `Mapper` interface that transforms objects
    into maps and back again using the magic of reflection. Let’s dive into the fascinating
    world of practical reflection and witness the code in action!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系好安全带，准备参加一场引人入胜的研讨会，我们将理论应用于实践，构建一个动态的`Mapper`接口，利用反射的魔力将对象转换为映射，再从映射转换回对象。让我们深入到实用的反射迷人世界，见证代码的实际运行！
- en: In the ever-evolving landscape of technology, seamless migration between different
    paradigms often requires bridging conventions. A common challenge arises with
    varying naming conventions, such as Java’s camel case and certain databases’ snake
    case preferences. To tackle this, we introduce the `Column` annotation, allowing
    developers to define custom column names during object-to-map conversion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术不断演变的领域中，不同范式之间的无缝迁移通常需要跨越约定。一个常见的挑战是不同的命名约定，例如Java的驼峰命名法和某些数据库的蛇形命名偏好。为了应对这一挑战，我们引入了`Column`注解，允许开发者在对象到映射转换期间定义自定义列名。
- en: 'Let’s take a closer look at the `Column` annotation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`Column`注解：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This annotation, applicable to fields (`ElementType.FIELD`), carries a `value`
    attribute. If provided, this attribute allows developers to specify a custom column
    name; otherwise, the field name is used by default. This flexibility enables a
    seamless mapping between Java objects and database structures, accommodating diverse
    naming conventions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解适用于字段（`ElementType.FIELD`），带有`value`属性。如果提供，此属性允许开发者指定自定义列名；否则，默认使用字段名。这种灵活性使得Java对象和数据库结构之间的映射无缝，适应不同的命名约定。
- en: 'Additionally, to mark a class as eligible for parsing, we introduce the `Entity`
    annotation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了标记一个类可以解析，我们引入了`Entity`注解：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Applied to the class level (`ElementType.TYPE`), this annotation signals that
    the class can undergo parsing operations. These annotations, when combined, empower
    developers to annotate their Java classes selectively, tailoring the conversion
    process based on the specific requirements of each class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到类级别（`ElementType.TYPE`），此注解表示该类可以执行解析操作。这些注解结合使用，使开发者能够有选择性地注解他们的Java类，根据每个类的特定要求定制转换过程。
- en: We introduce the `Appends` annotation to enhance flexibility and customization
    within our `Mapper` framework. This annotation, along with its companion `Append`
    annotation, provides a means to define default values for entities, enriching
    the object-to-map conversion process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入`Appends`注解来增强我们的`Mapper`框架中的灵活性和定制化。此注解及其伴随的`Append`注解提供了一种定义实体默认值的方法，丰富了对象到映射的转换过程。
- en: 'Let’s delve into the definitions of these annotations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些注解的定义：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Appends` annotation, applied at the class level (`ElementType.TYPE`), holds
    an array of `Append` annotations. Each `Append` annotation, in turn, allows developers
    to specify a key-value pair, indicating the default values to be appended during
    the object-to-map conversion process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appends`注解应用于类级别（`ElementType.TYPE`），包含一个`Append`注解数组。每个`Append`注解反过来允许开发者指定一个键值对，指示在对象到映射转换过程中要附加的默认值。'
- en: The `Append` annotation is marked as repeatable (`@Repeatable(Appends.class)`)
    to simplify the specification of multiple append values on a single entity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Append`注解被标记为可重复的（`@Repeatable(Appends.class)`），以简化在单个实体上指定多个附加值。'
- en: In the dynamic landscape of Java development, seamlessly converting objects
    to maps and vice versa is a powerful feature, especially when navigating diverse
    naming conventions or dealing with data migration scenarios. Implementing the
    `toEntity` method within the `ReflectionMapper` class marks a pivotal point in
    our journey through reflection-driven mapping.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java开发的动态环境中，无缝地将对象转换为映射以及反之亦然是一个强大的功能，尤其是在导航不同的命名约定或处理数据迁移场景时。在`ReflectionMapper`类中实现`toEntity`方法标志着我们通过反射驱动的映射之旅中的一个关键点。
- en: 'This method bridges the map representation of an object and its reconstitution
    as a fully realized entity. Through the lens of Java reflection, we embark on
    a step-by-step exploration, unraveling the intricacies of reconstructing an object
    from a map of its properties. The following code shows the implementation of `toEntity`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在对象映射表示和作为完全实现实体重新构成之间架起桥梁。通过Java反射的视角，我们开始逐步探索，揭示从属性映射中重建对象的所有细节。以下代码展示了`toEntity`的实现：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `toEntity` method reconstructs an entity from a map, dynamically mapping
    fields using reflection. It ensures a non-null map, instantiates the entity using
    the provided class name, and iterates through the fields. Key determination involves
    `@Column` annotations or field names. Values are retrieved from the map and set
    in the object using reflection. The method returns the reconstructed entity, exemplifying
    a concise and dynamic object restoration process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEntity`方法从映射中重建实体，动态地使用反射映射字段。它确保映射非空，使用提供的类名实例化实体，并遍历字段。键的确定涉及`@Column`注解或字段名。值从映射中检索，并使用反射设置在对象中。该方法返回重建的实体，展示了简洁且动态的对象恢复过程。'
- en: 'Here’s an explanation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解释：
- en: '**Map validation**:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射验证**：'
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The method begins by ensuring that the input `map` instance is not null, throwing
    a `NullPointerException` exception with the specified error message if it is.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法首先确保输入的`map`实例不为空，如果为空，则抛出带有指定错误信息的`NullPointerException`异常。
- en: '**Entity instantiation**:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体实例化**：'
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the fully qualified class name stored in the map, the `getEntity` method
    is called to dynamically instantiate an object of type `T` (the entity).
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用存储在映射中的完全限定类名，调用`getEntity`方法动态实例化类型为`T`（实体）的对象。
- en: '**Class-type retrieval**:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类类型检索**：'
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `getClass` method is employed to obtain the runtime class of the entity.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`getClass`方法来获取实体的运行时类。
- en: '**Field iteration**:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段迭代**：'
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method iterates over the declared fields of the class.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法遍历类的声明字段。
- en: '**Column** **key determination**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列** **键确定**：'
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For each field, it determines the key associated with it. If the `Column` annotation
    is present, it uses the specified column name; otherwise, it defaults to the field
    name.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个字段，它确定与之关联的键。如果存在`Column`注解，则使用指定的列名；否则，默认为字段名。
- en: '**Value retrieval** **and assignment**:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值检索** **和赋值**：'
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It retrieves the corresponding value from the map using the determined key.
    If a value is present, it utilizes the `setValue` method to set the value in the
    object using reflection.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它使用确定的关键值从映射中检索相应的值。如果存在值，它利用`setValue`方法通过反射在对象中设置该值。
- en: '**Reconstructed entity**:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重建的实体**：'
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, the reconstructed entity is returned, now populated with values from
    the map based on the reflection process.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，重建的实体返回，现在根据反射过程填充了映射中的值。
- en: This method demonstrates the dynamic reconstruction of an object using reflection,
    considering the custom annotations (`@Column`) for field-to-key mapping. It showcases
    the flexibility of `ReflectionMapper` in adapting to diverse class structures
    during the object-to-map conversion reversal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法展示了使用反射动态重建对象的过程，考虑了字段到键映射的自定义注解（`@Column`）。它展示了`ReflectionMapper`在对象到映射转换反转过程中适应不同类结构的灵活性。
- en: 'The `toMap` method within the `ReflectionMapper` class is critical in exploring
    dynamic mapping using Java reflection. This method takes an object of type `T`
    as input and dynamically converts it into a `Map<String, Object>` instance. Let’s
    unravel the intricacies of this method step by step:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReflectionMapper`类中的`toMap`方法对于探索使用Java反射的动态映射至关重要。此方法接受类型为`T`的对象作为输入，并将其动态转换为`Map<String,
    Object>`实例。让我们逐步揭示此方法的复杂性：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`toMap` method utilizes reflection to dynamically convert Java objects into
    `Map<String, Object>`. It ensures non-null input, explores fields with `@Column`
    annotations, and maps their values. Class-level `@Append` annotations contribute
    default key-value pairs. This concise method exemplifies the efficiency of reflection
    for dynamic object-to-map transformations.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toMap`方法利用反射动态将Java对象转换为`Map<String, Object>`。它确保输入非空，探索带有`@Column`注解的字段，并映射它们的值。类级别的`@Append`注解贡献默认键值对。此简洁的方法展示了反射在动态对象到映射转换中的效率。'
- en: '**Input validation**:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：'
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The method begins by ensuring that the input `entity` instance is not null,
    throwing a `NullPointerException` exception with the specified error message if
    it is.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法首先确保输入`entity`实例非空，如果它是空的，则抛出带有指定错误消息的`NullPointerException`异常。
- en: '**Map initialization**:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射初始化**：'
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A `HashMap` instance is initialized to store the key-value pairs representing
    the properties of the object.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化一个`HashMap`实例以存储表示对象属性的键值对。
- en: '**Class-type retrieval**:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类类型检索**：'
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method retrieves the runtime class of the entity and stores its fully qualified
    name in the map using the `ENTITY_ENTRY` key.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法检索实体的运行时类，并使用`ENTITY_ENTRY`键将其完全限定名称存储在映射中。
- en: '**Field iteration**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段迭代**：'
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method iterates over the declared fields of the class.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法遍历类的声明字段。
- en: '**Accessibility setting**:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性设置**：'
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The accessibility of the field is set to `true`, enabling access to private
    fields.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字段的可访问性设置为`true`，允许访问私有字段。
- en: '**Column** **annotation check**:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列** **注解检查**：'
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For each field, it checks for the presence of the `Column` annotation.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个字段，它检查是否存在`Column`注解。
- en: '**Column** **key determination**:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列** **键确定**：'
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the `Column` annotation is present, it determines the key associated with
    the field. It uses the specified column name or defaults to the field name.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果存在`Column`注解，它确定与字段关联的键。它使用指定的列名或默认为字段名。
- en: '**Value retrieval** **and assignment**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值检索** **和赋值**：'
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It retrieves the field value using the `getValue` method and adds the key-value
    pair to the map.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它使用`getValue`方法检索字段值，并将键值对添加到映射中。
- en: '**@Append** **annotation processing**:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Append** **注解处理**：'
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It processes `@Append` annotations at the class level, adding default key-value
    pairs to the map.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它处理类级别的 `@Append` 注解，向映射中添加默认键值对。
- en: '**Resulting map**:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果映射**：'
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, the resulting map, representing the object’s properties, is returned.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，返回的映射表示对象的属性。
- en: This `toMap` method exemplifies the adaptability of reflection in dynamically
    mapping object properties to a map. It showcases how annotations and field-level
    details are harnessed to create a versatile and extensible mapping mechanism within
    the `ReflectionMapper` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `toMap` 方法展示了反射在动态映射对象属性到映射中的适应性。它展示了如何利用注解和字段级细节在 `ReflectionMapper` 类内创建一个灵活和可扩展的映射机制。
- en: 'In our exploration of reflection-based mapping techniques, we’ll turn our attention
    to practical examples using two distinct entities: `Pet` and `Fruit`. These entities
    are adorned with annotations that provide valuable insights into the dynamic capabilities
    of `ReflectionMapper`. Let’s delve into each entity, examining their structures
    and the annotations that will guide our mapping journey:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索基于反射的映射技术时，我们将关注两个不同实体 `Pet` 和 `Fruit` 的实际示例。这些实体带有注解，提供了关于 `ReflectionMapper`
    动态能力的宝贵见解。让我们深入了解每个实体，检查它们的结构和将指导我们映射之旅的注解：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Pet` entity is a simple `@Entity` annotation, signifying its eligibility
    for reflection-based mapping. Each field, such as `name` and `age`, is tagged
    with `@Column`, indicating their inclusion in the mapping process. This straightforward
    structure serves as an excellent starting point for understanding how the `ReflectionMapper`
    class dynamically handles object-to-map conversion and vice versa.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pet` 实体是一个简单的 `@Entity` 注解，表示其符合基于反射的映射资格。每个字段，如 `name` 和 `age`，都带有 `@Column`
    标签，表明它们包含在映射过程中。这种简单的结构是理解 `ReflectionMapper` 类如何动态处理对象到映射的转换及其相反过程的绝佳起点。'
- en: 'The next step is the `Fruit` entity which has additional settings than the
    previous class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是具有比之前类更多设置的 `Fruit` 实体：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Fruit` entity, on the other hand, not only carries the `@Entity` annotation
    but also leverages the `@Append` annotation at the class level. This introduces
    default key-value pairs (`"type": "Fruit"` and `"category": "Natural"`) during
    the mapping process. The class showcases flexibility by including both a deprecated
    and non-deprecated constructor, highlighting how the `ReflectionMapper` class
    adapts to different entity structures.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，`Fruit` 实体不仅带有 `@Entity` 注解，还在类级别上利用了 `@Append` 注解。这会在映射过程中引入默认键值对（`"type":
    "Fruit"` 和 `"category": "Natural"`）。该类通过包含已弃用和非弃用的构造函数展示了其灵活性，突显了 `ReflectionMapper`
    类如何适应不同的实体结构。'
- en: In the upcoming sections, we will execute the `ReflectionMapper` class on instances
    of these entities, unveiling the power of reflection in handling diverse class
    structures and annotations. Through this practical application, we aim to provide
    a comprehensive understanding of how reflection can be harnessed for dynamic object-to-map
    conversion and reconstruction. Let the mapping journey with `Pet` and `Fruit`
    commence!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将对 `ReflectionMapper` 类的这些实体实例进行操作，揭示反射在处理不同类结构和注解方面的强大功能。通过这种实际应用，我们旨在全面了解如何利用反射实现动态对象到映射的转换和重建。让我们开始
    `Pet` 和 `Fruit` 的映射之旅！
- en: 'To validate the practical application of the `ReflectionMapper` class on our
    diverse entities, we’ve devised a comprehensive `MapperTest` class. This series
    of tests demonstrates the mapper’s ability to seamlessly convert entities to maps
    and reconstruct entities from maps, showcasing the flexibility and adaptability
    of reflection in dynamic mapping scenarios:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 `ReflectionMapper` 类在我们多样化的实体上的实际应用，我们设计了一个全面的 `MapperTest` 类。这一系列测试展示了映射器无缝将实体转换为映射以及从映射重建实体的能力，展示了反射在动态映射场景中的灵活性和适应性。
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**shouldConvertToMap**:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shouldConvertToMap**：'
- en: This test ensures that the **ReflectionMapper** class can successfully convert
    a **Pet** entity into a map
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个测试确保 **ReflectionMapper** 类可以成功地将 **Pet** 实体转换为映射。
- en: It verifies specific keys’ presence and corresponding values in the generated
    map
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它验证生成映射中特定键的存在和相应的值。
- en: '**shouldConvertEntity**:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shouldConvertEntity**：'
- en: In this test, a map representing a **Pet** entity is converted back into the
    original entity using **ReflectionMapper**
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个测试中，使用 **ReflectionMapper** 将表示 **Pet** 实体的映射转换回原始实体。
- en: Assertions validate the correctness of the reconstructed **Pet** object
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言验证了重构的**Pet**对象的正确性
- en: '**shouldConvertEntityRepeatable**:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shouldConvertEntityRepeatable**：'
- en: This test focuses on converting a **Fruit** entity, which includes repeatable
    annotations, into a map
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本测试专注于将包含可重复注解的**Fruit**实体转换为映射
- en: It verifies the presence of default key-value pairs and entity-specific values
    in the resulting map
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它验证了结果映射中是否存在默认键值对和实体特定的值
- en: Through these tests, we aim to illustrate how the `ReflectionMapper` class seamlessly
    handles various entities, annotations, and object-to-map conversions, emphasizing
    the practical utility of reflection in dynamic mapping scenarios. Let the testing
    commence, revealing the prowess of reflection in action!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们旨在展示《ReflectionMapper》类如何无缝地处理各种实体、注解和对象到映射的转换，强调反射在动态映射场景中的实际效用。测试开始，揭示反射在实际操作中的能力！
- en: In this section, we delved deep into the intricate world of reflection, unraveling
    its potential in dynamic object-to-map conversions through the lens of the `ReflectionMapper`
    class. We explored the reflection’s flexibility and adaptability, showcasing its
    prowess in handling diverse entity structures and annotations. As we conclude
    this segment, we stand at the threshold of another fascinating realm—dynamic proxies.
    The upcoming section will usher us into the world of `MapperRepository`, where
    we will harness the power of dynamic proxies to switch between entities and their
    map representations seamlessly. Brace yourself for exploring the dynamic and versatile
    landscape of proxies as we unveil their role in enhancing reflection capabilities.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了反射的复杂世界，通过《ReflectionMapper》类展示了其在动态对象到映射转换中的潜力。我们探讨了反射的灵活性和适应性，展示了其在处理各种实体结构和注解方面的能力。随着本段的结束，我们站在另一个迷人领域的门槛上——动态代理。接下来的章节将引领我们进入《MapperRepository》的世界，我们将利用动态代理的强大功能，无缝地在实体及其映射表示之间切换。准备好探索动态和灵活的代理领域，我们将揭示它们在增强反射能力中的作用。
- en: Proxy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Dynamic proxies in Java are indispensable tools that enable the creation of
    objects at runtime, implementing one or more interfaces, and intercepting method
    invocations. The `MapperRepository` class introduces us to the profound utility
    of dynamic proxies, where their application becomes paramount in seamlessly switching
    between entities and their corresponding map representations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的动态代理是不可缺少的工具，它允许在运行时创建对象，实现一个或多个接口，并拦截方法调用。《MapperRepository》类向我们展示了动态代理的强大功能，其应用在无缝切换实体及其对应的映射表示中变得至关重要。
- en: 'Dynamic proxies stand as veritable champions in the arsenal of Java’s runtime
    capabilities, offering a trove of advantages that elevate code’s adaptability,
    flexibility, and conciseness. Their inherent adaptability allows for creating
    proxy instances on the fly, accommodating diverse interfaces at runtime, and facilitating
    seamless integration in scenarios where object structures are only known at runtime.
    The ability to intercept method invocations empowers dynamic proxies to inject
    custom logic seamlessly, enhancing functionalities without compromising the integrity
    of core operations. This interception mechanism enables cleaner `MapperRepository`,
    dynamic proxies emerge as the linchpin, embodying the ethos of adaptability and
    efficiency in the dynamic mapping landscape:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代理在Java的运行时能力中是真正的冠军，提供了许多优势，提高了代码的适应性、灵活性和简洁性。它们固有的适应性允许在运行时动态创建代理实例，适应不同的接口，并在对象结构仅在运行时已知的情况下实现无缝集成。拦截方法调用的能力使动态代理能够无缝地注入自定义逻辑，增强功能而不损害核心操作的完整性。这种拦截机制使得`MapperRepository`更加清晰，动态代理成为关键，体现了动态映射领域的适应性和效率：
- en: '**Adaptability and flexibility**: Dynamic proxies offer unparalleled adaptability,
    allowing us to create proxy instances for diverse interfaces at runtime. This
    adaptability becomes crucial when dealing with scenarios where the structure of
    objects or interfaces is not known until runtime. In the context of **MapperRepository**,
    dynamic proxies empower us to handle multiple entity types without a priori knowledge,
    fostering a more flexible and extensible design.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性和灵活性**：动态代理提供了无与伦比的适应性，允许我们在运行时为各种接口创建代理实例。当处理对象或接口的结构在运行时才知道的场景时，这种适应性变得至关重要。在**MapperRepository**的上下文中，动态代理使我们能够在没有先验知识的情况下处理多种实体类型，从而促进更灵活和可扩展的设计。'
- en: '**Interception of method invocations**: One of the key advantages of dynamic
    proxies is their ability to intercept method calls. This interception mechanism
    allows one to perform actions before and after method execution. In the realm
    of mapping entities to maps and vice versa, this interception becomes instrumental.
    It enables us to seamlessly inject conversion logic, enhancing the mapping process
    without altering the core logic of entities.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用的拦截**：动态代理的一个关键优势是它们能够拦截方法调用。这种拦截机制允许在方法执行前后执行操作。在将实体映射到映射和反之亦然的领域中，这种拦截变得至关重要。它使我们能够无缝地注入转换逻辑，增强映射过程，而不改变实体的核心逻辑。'
- en: '**Reduced boilerplate code**: Dynamic proxies significantly reduce the need
    for boilerplate code. They allow us to centralize cross-cutting concerns, such
    as logging or validation, by encapsulating these concerns within the proxy. In
    the context of **MapperRepository**, this leads to cleaner, more concise code
    for the conversion between entities and maps, promoting maintainability and readability.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少样板代码**：动态代理显著减少了样板代码的需求。它们允许我们将跨切面关注点，如日志记录或验证，集中封装在代理中。在**MapperRepository**的上下文中，这导致实体和映射之间的转换代码更简洁、更易于维护和阅读。'
- en: However powerful, the utilization of dynamic proxies in Java does not come without
    its set of considerations and trade-offs. One of the primary trade-offs lies in
    the performance overhead incurred by the dynamic nature of proxies, as the interception
    of method calls and the runtime creation of proxy instances can introduce a slight
    execution delay compared to direct method calls. Additionally, reliance on interface-based
    proxies restricts their application to scenarios involving interfaces, posing
    limitations in scenarios where class-based proxies may be more fitting. Recognizing
    these trade-offs is paramount, as it allows for informed decision-making when
    implementing dynamic proxies, especially in performance-sensitive contexts. Despite
    these considerations, the benefits offered by dynamic proxies, such as enhanced
    flexibility and reduced boilerplate code, often outweigh these trade-offs, reinforcing
    their indispensable role in dynamic and adaptable Java applications.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，尽管动态代理在Java中的使用非常强大，但它的应用并非没有其考虑和权衡。其中一个主要的权衡在于代理动态性带来的性能开销，因为方法调用拦截和代理实例的运行时创建可能会比直接方法调用引入轻微的执行延迟。此外，基于接口的代理的依赖性限制了它们的应用范围，仅限于涉及接口的场景，而在可能更适合基于类的代理的场景中存在局限性。认识到这些权衡至关重要，因为它允许在实现动态代理时做出明智的决定，尤其是在性能敏感的环境中。尽管有这些考虑，动态代理提供的优势，如增强的灵活性和减少样板代码，通常超过了这些权衡，从而强化了它们在动态和适应性Java应用程序中的不可或缺作用。
- en: '**Performance overhead**: While dynamic proxies provide immense flexibility,
    their dynamic nature introduces a performance overhead. The interception of method
    calls and the creation of proxy instances at runtime can lead to slightly slower
    execution compared to direct method calls. Careful consideration is required when
    applying dynamic proxies in performance-critical scenarios.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：虽然动态代理提供了巨大的灵活性，但它们的动态性引入了性能开销。运行时方法调用拦截和代理实例的创建可能会导致比直接方法调用稍微慢一些的执行。在性能关键场景中应用动态代理时需要仔细考虑。'
- en: '**Limitations on class-based proxies**: Dynamic proxies in Java are interface-based,
    limiting their application to scenarios involving interfaces. Class-based proxies
    are not as prevalent, and certain scenarios may require alternative solutions
    or compromises. Understanding these limitations is crucial for making informed
    decisions in design and implementation.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于类的代理的限制**: Java 中的动态代理基于接口，限制了它们的应用场景仅限于涉及接口的情况。基于类的代理并不常见，某些场景可能需要替代解决方案或妥协。理解这些限制对于在设计实现时做出明智决策至关重要。'
- en: 'In the ever-evolving landscape of Java, `MapperRepository` emerges as a pivotal
    interface, seamlessly intertwining the capabilities of reflection and dynamic
    proxies. This interface serves as a gateway to the dynamic world of object-to-map
    conversions and vice versa, harnessing the intrinsic power of reflection to navigate
    and manipulate entities at runtime:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断演变的 Java 世界中，`MapperRepository` 作为关键接口，无缝地结合了反射和动态代理的能力。该接口作为对象到映射以及反之亦然的动态世界的门户，利用反射的内在力量在运行时导航和操作实体：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Interface description**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口描述**:'
- en: '**entity**: This method takes a map representing an object’s properties and
    dynamically reconstructs an object of type **T** at runtime. Leveraging reflection,
    it navigates through the map, creating a dynamic proxy entity that adapts to the
    structure of the provided map.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**: 此方法接收一个表示对象属性的映射，并在运行时动态地重建一个类型为 **T** 的对象。利用反射，它遍历映射，创建一个动态代理实体，该实体适应提供的映射结构。'
- en: '**map**: Conversely, the **map** method accepts an entity of type **T** and
    dynamically generates a map representing its properties. Through reflection and
    dynamic proxies, this method navigates the entity’s structure, creating a map
    that encapsulates the key-value pairs of its properties.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**: 相反，`map` 方法接受一个类型为 **T** 的实体，并动态生成一个表示其属性的映射。通过反射和动态代理，此方法遍历实体的结构，创建一个封装其属性键值对的映射。'
- en: The true prowess of `MapperRepository` lies in its symbiotic relationship with
    reflection. When reconstructing entities from maps, reflection allows the dynamic
    exploration of the object’s structure, identifying fields, methods, and annotations.
    This exploration and dynamic proxies enable seamless adaptation to varying entity
    types, rendering `MapperRepository` a versatile tool for dynamic mappings.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapperRepository` 的真正实力在于其与反射的共生关系。在从映射中重建实体时，反射允许动态探索对象的结构，识别字段、方法和注解。这种探索和动态代理使得对各种实体类型的无缝适应成为可能，使
    `MapperRepository` 成为动态映射的多功能工具。'
- en: On the reverse journey, when converting entities to maps, reflection plays a
    pivotal role in introspecting the object’s structure. Information gleaned through
    reflection guides the creation of a map that accurately represents the object’s
    properties. Dynamic proxies enhance this process by intercepting method invocations,
    allowing for custom logic injection, and providing a dynamic approach to object-to-map
    conversion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向旅程中，当将实体转换为映射时，反射在检查对象结构方面发挥着关键作用。通过反射获得的信息指导创建一个准确表示对象属性的映射。动态代理通过拦截方法调用，允许注入自定义逻辑，并提供一种动态的对象到映射转换方法。
- en: 'As our journey into dynamic proxies and reflection with `MapperRepository`
    unfolds, we step into the implementation arena by introducing the `MapperInvocationHandler`
    class. This implementation, serving as the `InvocationHandler` class for dynamic
    proxies, bridges the abstract realm of dynamic mappings defined in `MapperRepository`
    to the concrete operations facilitated by the underlying `ReflectionMapper` class.
    Let’s delve into the simplicity and power encapsulated within this handler, unlocking
    the potential for robust, customizable dynamic mappings:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对 `MapperRepository` 中的动态代理和反射的探索之旅展开，我们通过引入 `MapperInvocationHandler` 类进入实现领域。这个实现作为动态代理的
    `InvocationHandler` 类，将 `MapperRepository` 中定义的动态映射的抽象领域与底层 `ReflectionMapper`
    类提供的具体操作联系起来。让我们深入了解这个处理器的简洁和强大，解锁强大、可定制的动态映射的潜力：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `MapperInvocationHandler` class, implementing `InvocationHandler`, mediates
    dynamic mappings. It uses a `ReflectionMapper` instance to convert maps to entities
    or entities to maps based on method calls. The handler supports default methods
    and ensures a smooth connection between dynamic proxies and the underlying mapping
    logic:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `InvocationHandler` 接口的 `MapperInvocationHandler` 类，充当动态映射的中介。它使用一个 `ReflectionMapper`
    实例根据方法调用将映射转换为实体或实体转换为映射。处理程序支持默认方法，并确保动态代理与底层映射逻辑之间的连接顺畅：
- en: '**Dynamic method routing**: The **invoke** method dynamically routes method
    calls based on their names. For the **entity** method, it extracts the map from
    the provided parameters and delegates the operation to **ReflectionMapper** for
    entity reconstruction. Conversely, the **map** method, it extracts the entity
    and delegates it to **ReflectionMapper** for map creation.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态方法路由**：`invoke` 方法根据方法名称动态路由方法调用。对于 `entity` 方法，它从提供的参数中提取映射并将其委托给 `ReflectionMapper`
    进行实体重建。相反，对于 `map` 方法，它提取实体并将其委托给 `ReflectionMapper` 进行映射创建。'
- en: '**Handling default methods**: The handler accounts for default methods in the
    **MapperRepository** interface. If a default method is invoked, it gracefully
    delegates the call using **InvocationHandler.invokeDefault**.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理默认方法**：处理程序考虑了 `MapperRepository` 接口中的默认方法。如果调用默认方法，它将使用 `InvocationHandler.invokeDefault`
    优雅地委派调用。'
- en: '**Exception handling**: In cases where an unsupported method is encountered,
    an **UnsupportedOperationException** exception is thrown, providing clear feedback
    on the limitations of the dynamic proxy in handling certain operations.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理**：在遇到不支持的方法时，会抛出 `UnsupportedOperationException` 异常，提供关于动态代理在处理某些操作限制的明确反馈。'
- en: One of the standout features of this implementation lies in its potential for
    customizability. Extending the logic within each method case makes it feasible
    to check annotation parameters, opening the door to many customization possibilities.
    This approach transforms `MapperRepository` into a robust and adaptable tool,
    ready to cater to diverse mapping scenarios through the lens of reflection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的一个突出特点是它的可定制性潜力。扩展每个方法案例中的逻辑使其可行，以检查注解参数，从而开启许多定制可能性。这种方法将 `MapperRepository`
    转变为一个强大且适应性强的工具，通过反射的视角准备好应对各种映射场景。
- en: In exploring dynamic proxies and reflection within the realm of `MapperRepository`,
    `MapperInvocationHandler` emerges as a linchpin, seamlessly connecting abstract
    mappings to concrete operations. Its dynamic method routing and the ability to
    handle default methods make it a powerful orchestrator of dynamic mappings. The
    simplicity of the implementation belies its potential for customization, offering
    a pathway to inspect annotation parameters and tailor the mapping process to diverse
    scenarios. As we conclude this chapter, `MapperInvocationHandler` is a testament
    to the symbiotic relationship between dynamic proxies and reflection, showcasing
    their combined might in creating adaptable, customizable, and dynamic mapping
    solutions in Java. The upcoming practical application will illuminate how this
    implementation transforms abstract concepts into a toolset that empowers developers
    to navigate the intricate landscape of dynamic mappings easily.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `MapperRepository` 领域内的动态代理和反射时，`MapperInvocationHandler` 成为了一个关键环节，无缝地将抽象映射与具体操作连接起来。其动态方法路由和处理默认方法的能力使其成为动态映射的强大协调者。实现的简单性掩盖了其定制潜力，提供了一种检查注解参数并针对不同场景定制映射过程的方法。随着本章的结束，`MapperInvocationHandler`
    是动态代理和反射之间共生关系的证明，展示了它们在创建适应性强、可定制和动态的 Java 映射解决方案中的联合力量。即将到来的实际应用将阐明这种实现如何将抽象概念转化为一个工具集，使开发者能够轻松地导航动态映射的复杂领域。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: On our exploration of dynamic proxies and reflection, amalgamating these powerful
    Java features as `MapperInvocationHandler` marks a pivotal moment in our journey.
    The ability to dynamically route method calls and the potential for customization
    through annotation parameters underscore the versatility encapsulated within this
    implementation. Yet, this is merely a precursor to the next chapter, where we
    dive into the sophisticated realm of Java annotation processing. Building upon
    the foundation of dynamic mappings, the annotation processor promises to elevate
    our capabilities further, offering a structured and compile-time approach to harnessing
    metadata within our code. Join us in the upcoming chapter as we unveil the intricate
    world of Java annotation processing, where compile-time reflection becomes a cornerstone
    in crafting efficient, robust, and intelligently processed Java applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索动态代理和反射的过程中，将这些强大的Java特性作为`MapperInvocationHandler`整合，标志着我们旅程中的一个关键时刻。动态路由方法调用和通过注解参数进行定制的潜力，凸显了这一实现所包含的灵活性。然而，这仅仅是下一章的序曲，我们将深入探索Java注解处理的复杂领域。在动态映射的基础上，注解处理器承诺将进一步提升我们的能力，提供一种结构化和编译时方法来利用代码中的元数据。加入我们，在下一章中，我们将揭示Java注解处理的微妙世界，其中编译时反射成为构建高效、健壮和智能处理的Java应用程序的基石。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is the primary purpose of the MapperInvocationHandler class in the context
    of dynamic proxies?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动态代理的上下文中，**MapperInvocationHandler** 类的主要目的是什么？
- en: Handling database connections
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理数据库连接
- en: Routing method calls for dynamic mappings
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态映射的路径调用方法
- en: Implementing complex business logic
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现复杂业务逻辑
- en: Parsing XML configurations
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析XML配置
- en: Which feature makes dynamic proxies adaptable in scenarios where object structures
    are not known until runtime?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个特性使得动态代理在运行时才知道对象结构的情况下具有适应性？
- en: Method overloading
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法重载
- en: Interface-based implementation
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于接口的实现
- en: Dynamic method routing
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态方法路由
- en: Static method invocation
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法调用
- en: How does the **MapperInvocationHandler** class demonstrate customizability in
    the dynamic mapping process?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**MapperInvocationHandler** 类如何演示在动态映射过程中的可定制性？'
- en: It uses hardcoded values for method calls.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用硬编码的值进行方法调用。
- en: It leverages external libraries for mapping.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它利用外部库进行映射。
- en: It inspects annotation parameters and adapts the mapping logic.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查注解参数并适应映射逻辑。
- en: It enforces strict immutability in mapped entities.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在映射实体中强制执行严格的不可变性。
- en: What is the primary purpose of reflection in Java?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java中反射的主要目的是什么？
- en: Compile-time code optimization
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时代码优化
- en: Dynamic exploration and manipulation of object structures
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态探索和操作对象结构
- en: Secure encryption of sensitive data
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 敏感数据的加密安全
- en: Asynchronous event handling
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步事件处理
- en: In the context of the **MapperRepository** interface, how does reflection contribute
    to dynamic mappings?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MapperRepository**接口的上下文中，反射如何有助于动态映射？
- en: It ensures type safety in method calls.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确保方法调用中的类型安全。
- en: It provides a secure encryption mechanism.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一种安全的加密机制。
- en: It dynamically routes method calls.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它动态路由方法调用。
- en: It enforces strict immutability in mapped entities.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在映射实体中强制执行严格的不可变性。
- en: Answers
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章问题的答案：
- en: B. Routing method calls for dynamic mappings
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 动态映射的路径调用方法
- en: C. Dynamic method routing
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 动态方法路由
- en: C. It inspects annotation parameters and adapts the mapping logic.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 它检查注解参数并适应映射逻辑。
- en: B. Dynamic exploration and manipulation of object structures
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 动态探索和操作对象结构
- en: C. It dynamically routes method calls.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 它动态路由方法调用。
