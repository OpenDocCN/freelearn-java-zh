- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Improving Resilience Using Resilience4j
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Resilience4j提高弹性
- en: 'In this chapter, we will learn how to use Resilience4j to make our microservices
    more resilient, that is, how to mitigate and recover from errors. As we already
    discussed in *Chapter 1*, *Introduction to Microservices*, in the *Circuit breaker*
    section, and *Chapter 8*, *Introduction to Spring Cloud*, in the *Using Resilience4j
    for improved resilience* section, a circuit breaker can be used to minimize the
    damage that a slow or unresponsive downstream microservice can cause in a large-scale
    system landscape of synchronously communicating microservices. We will see how
    the circuit breaker in Resilience4j can be used together with a time limiter and
    retry mechanism to prevent two of the most common error situations:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Resilience4j使我们的微服务更具弹性，也就是说，如何减轻和从错误中恢复。正如我们在*第一章*，*微服务简介*，*电路断路器*部分，以及*第八章*，*Spring
    Cloud简介*，*使用Resilience4j提高弹性*部分中已经讨论过的，电路断路器可以用来最小化一个慢速或无响应的下游微服务在一个大规模同步通信微服务系统景观中可能造成的损害。我们将看到Resilience4j中的电路断路器如何与时间限制器和重试机制一起使用，以防止两种最常见的错误情况：
- en: Microservices that start to respond slowly or not at all
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始响应缓慢或根本不响应的微服务
- en: Requests that randomly fail from time to time, for example, due to temporary
    network problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时随机失败的请求，例如，由于临时网络问题
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: 'Introducing the three Resilience4j mechanisms: circuit breaker, time limiter,
    and retry'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍三个Resilience4j机制：电路断路器、时间限制器和重试
- en: Adding the mechanisms to the source code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将机制添加到源代码中
- en: Trying out the mechanisms when deployed in the system landscape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统景观中部署时尝试这些机制
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter13`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自`$BOOK_HOME/Chapter13`的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add resilience using Resilience4j, you can compare
    it with the source code for *Chapter 12*, *Centralized Configuration*. You can
    use your favorite `diff` tool and compare the two folders, `$BOOK_HOME/Chapter12`
    and `$BOOK_HOME/Chapter13`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看对本章源代码所做的更改，即查看使用Resilience4j添加弹性的过程，你可以将其与*第12章*，*集中配置*的源代码进行比较。你可以使用你喜欢的`diff`工具比较两个文件夹，`$BOOK_HOME/Chapter12`和`$BOOK_HOME/Chapter13`。
- en: Introducing the Resilience4j resilience mechanisms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Resilience4j弹性机制
- en: 'The circuit breaker, time limiter, and retry mechanisms are potentially useful
    in any synchronous communication between two software components, for example,
    microservices. In this chapter, we will apply these mechanisms in one place, in
    calls from the `product-composite` service to the `product` service. This is illustrated
    in the following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器、时间限制器和重试机制在两个软件组件之间的任何同步通信中都可能很有用，例如，微服务。在本章中，我们将将这些机制应用于一个地方，即在`product-composite`服务对`product`服务的调用中。以下图示说明了这一点：
- en: '![Diagram  Description automatically generated](img/B19825_13_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_13_01.png)'
- en: 'Figure 13.1: Adding resilience capabilities to the system landscape'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：向系统景观添加弹性功能
- en: Note that the synchronous calls to the discovery and config servers from the
    other microservices are not shown in the preceding diagram (to make it easier
    to read).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其他微服务对发现和配置服务器的同步调用在先前的图中没有显示（为了便于阅读）。
- en: With the Spring Cloud Hoxton release in November 2019, the **Spring Cloud Circuit
    Breaker** project was added. It provides an abstraction layer for circuit breakers.
    Resilience4j can be configured to be used under the hood. This project does not
    provide other resilience mechanisms such as retries, time limiters, bulkheads,
    or rate limiters in an integrated way as the Resilience4j project does. For more
    information on the project, see [https://spring.io/projects/spring-cloud-circuitbreaker](https://spring.io/projects/spring-cloud-circuitbreaker).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A number of other alternatives exist as well. For example, the Reactor project
    comes with built-in support for retries and timeouts; see `Mono.retryWhen()` and
    `Mono.timeout()`. Spring also has a retry mechanism (see [https://github.com/spring-projects/spring-retry](https://github.com/spring-projects/spring-retry)),
    but it does not support a reactive programming model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: However, none of the alternatives provide such a cohesive and well-integrated
    approach to providing a set of resilience mechanisms as Resilience4j does, specifically,
    in a Spring Boot environment, where dependencies, annotations, and configuration
    are used in an elegant and consistent way. Finally, it is worth noting that the
    Resilience4j annotations work independently of the programming style used, be
    it reactive or imperative.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the circuit breaker
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s quickly revisit the state diagram for a circuit breaker from *Chapter
    8*, *Introduction to Spring Cloud*, in the *Using Resilience4j for improved resilience*
    section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_13_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Circuit breaker state diagram'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of a circuit breaker are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If a circuit breaker detects too many faults, it will open its circuit, that
    is, not allow new calls.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the circuit is open, a circuit breaker will perform fail-fast logic. This
    means that it doesn’t wait for a new fault, for example, a timeout, to happen
    on subsequent calls. Instead, it directly redirects the call to a **fallback method**.
    The fallback method can apply various business logic to produce a best-effort
    response. For example, a fallback method can return data from a local cache or
    simply return an immediate error message. This will prevent a microservice from
    becoming unresponsive if the services it depends on stop responding normally.
    This is specifically useful under high load.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a while, the circuit breaker will be half-open, allowing new calls to
    see whether the issue that caused the failures is gone. If new failures are detected
    by the circuit breaker, it will open the circuit again and go back to the fail-fast
    logic. Otherwise, it will close the circuit and go back to normal operation. This
    makes a microservice resilient to faults, or self-healing, a capability that is
    indispensable in a system landscape of microservices that communicate synchronously
    with each other.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resilience4j exposes information about circuit breakers at runtime in a number
    of ways:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j 以多种方式在运行时公开有关断路器的信息：
- en: The current state of a circuit breaker can be monitored using the microservice’s
    `actuator` `health` endpoint, `/actuator/health`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用微服务的 `actuator` `health` 端点 `/actuator/health` 监控断路器的当前状态。
- en: The circuit breaker also publishes events on an `actuator` endpoint, for example,
    state transitions and `/actuator/circuitbreakerevents`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器还会在 `actuator` 端点发布事件，例如状态转换和 `/actuator/circuitbreakerevents`。
- en: Finally, circuit breakers are integrated with Spring Boot’s metrics system and
    can use it to publish metrics to monitoring tools such as Prometheus.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，断路器与 Spring Boot 的指标系统集成，并可以使用它将指标发布到监控工具，例如 Prometheus。
- en: We will try out the `health` and `event` endpoints in this chapter. In *Chapter
    20*, *Monitoring Microservices*, we will see Prometheus in action and how it can
    collect metrics that are exposed by Spring Boot, for example, metrics from our
    circuit breaker.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章尝试 `health` 和 `event` 端点。在 *第20章*，*监控微服务* 中，我们将看到 Prometheus 的实际应用以及它如何收集由
    Spring Boot 公开的指标，例如来自我们的断路器的指标。
- en: 'To control the logic in a circuit breaker, Resilience4j can be configured using
    standard Spring Boot configuration files. We will use the following configuration
    parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制断路器中的逻辑，Resilience4j 可以通过标准的 Spring Boot 配置文件进行配置。我们将使用以下配置参数：
- en: '`slidingWindowType`: To determine if a circuit breaker needs to be opened,
    Resilience4j uses a sliding window, counting the most recent events to make the
    decision. The sliding windows can either be based on a fixed number of calls or
    a fixed elapsed time. This parameter is used to configure what type of sliding
    window is used.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slidingWindowType`: 为了确定是否需要打开断路器，Resilience4j 使用滑动窗口，通过计算最近的事件来做出决策。滑动窗口可以是基于固定数量的调用或固定的时间间隔。此参数用于配置使用哪种类型的滑动窗口。'
- en: We will use a count-based sliding window, setting this parameter to `COUNT_BASED`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用基于计数的滑动窗口，将此参数设置为 `COUNT_BASED`。
- en: '`slidingWindowSize`: The number of calls in a closed state, which are used
    to determine whether the circuit should be opened.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slidingWindowSize`: 在关闭状态下，用于确定电路是否应该打开的调用次数。'
- en: We will set this parameter to `5`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将此参数设置为 `5`。
- en: '`failureRateThreshold`: The threshold, in percent, for failed calls that will
    cause the circuit to be opened.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureRateThreshold`: 导致电路打开的失败调用百分比阈值。'
- en: We will set this parameter to `50%`. This setting, together with `slidingWindowSize`
    set to `5`, means that if three or more of the last five calls are faults, then
    the circuit will open.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将此参数设置为 `50%`。此设置，连同 `slidingWindowSize` 设置为 `5`，意味着如果最后五个调用中有三个或更多是故障，则电路将打开。
- en: '`automaticTransitionFromOpenToHalfOpenEnabled`: Determines whether the circuit
    breaker will automatically transition to the half-open state once the waiting
    period is over. Otherwise, it will wait for the first call after the waiting period
    is over until it transitions to the half-open state.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automaticTransitionFromOpenToHalfOpenEnabled`: 确定断路器在等待期结束后是否会自动过渡到半开状态。否则，它将在等待期结束后等待第一个调用，然后过渡到半开状态。'
- en: We will set this parameter to `true`.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将此参数设置为 `true`。
- en: '`waitDurationInOpenState`: Specifies how long the circuit stays in an open
    state, that is, before it transitions to the half-open state.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitDurationInOpenState`: 指定电路保持打开状态的时间长度，即过渡到半开状态之前。'
- en: We will set this parameter to `10000 ms`. This setting, together with enabling
    the automatic transition to the half-open state, set by the previous parameter,
    means that the circuit breaker will keep the circuit open for 10 seconds and then
    transition to the half-open state.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将此参数设置为 `10000 ms`。此设置，连同启用由前一个参数设置的自动过渡到半开状态，意味着断路器将保持电路打开10秒，然后过渡到半开状态。
- en: '`permittedNumberOfCallsInHalfOpenState`: The number of calls in the half-open
    state, which are used to determine whether the circuit will be opened again or
    go back to the normal, closed state.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permittedNumberOfCallsInHalfOpenState`: 在半开状态下，用于确定电路是否会再次打开或返回到正常、关闭状态的调用次数。'
- en: We will set this parameter to `3`, meaning that the circuit breaker will decide
    whether the circuit will be opened or closed based on the first three calls after
    the circuit has transitioned to the half-open state. Since the `failureRateThreshold`
    parameters are set to 50%, the circuit will be open again if two or all three
    calls fail. Otherwise, the circuit will be closed.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ignoreExceptions`: This can be used to specify exceptions that should not
    be counted as faults. Expected business exceptions such as `not found` or `invalid
    input` are typical exceptions that the circuit breaker should ignore; users who
    search for non-existing data or enter invalid input should not cause the circuit
    to open.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will set this parameter to a list containing the exceptions `NotFoundException`
    and `InvalidInputException`.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, to configure Resilience4j to report the state of the circuit breaker
    in the `actuator` `health` endpoint in the correct way, the following parameters
    are set:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`registerHealthIndicator = true` enables Resilience4j to fill in the `health`
    endpoint with information regarding the state of its circuit breakers.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowHealthIndicatorToFail = false` tells Resilience4j not to affect the status
    of the `health` endpoint. This means that the `health` endpoint will still report
    `"UP"` even if one of the component’s circuit breakers is in an open or half-open
    state. It is very important that the health state of the component is not reported
    as `"DOWN"` just because one of its circuit breakers is not in a closed state.
    This means that the component is still considered to be OK, even though one of
    the components it depends on is not.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is actually the core value of a circuit breaker, so setting this value
    to `true` would more or less spoil the value of bringing in a circuit breaker.
    In earlier versions of Resilience4j, this was actually the behavior. In more recent
    versions, this has been corrected, and `false` is actually the default value for
    this parameter. But since I consider it very important to understand the relation
    between the health state of the component and the state of its circuit breakers,
    I have added it to the configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must also configure Spring Boot Actuator to add the circuit breaker
    health information that Resilience4j produces in the response to a request to
    its `health` endpoint:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For a full list of available configuration parameters, see [https://resilience4j.readme.io/docs/circuitbreaker#create-and-configure-a-circuitbreaker](https://resilience4j.readme.io/docs/circuitbreaker#create-and-configure-a-circuitbreaker).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the time limiter
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To help a circuit breaker handle slow or unresponsive services, a timeout mechanism
    can be helpful. Resilience4j’s timeout mechanism, called a **TimeLimiter**, can
    be configured using standard Spring Boot configuration files. We will use the
    following configuration parameter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`timeoutDuration`: Specifies how long a `TimeLimiter` instance waits for a
    call to complete before it throws a timeout exception. We will set it to `2s`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the retry mechanism
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **retry** mechanism is very useful for random and infrequent faults, such
    as temporary network glitches. The retry mechanism can simply retry a failed request
    a number of times with a configurable delay between the attempts. One very important
    restriction on the use of the retry mechanism is that the services that it retries
    must be **idempotent**, that is, calling the service one or many times with the
    same request parameters gives the same result. For example, reading information
    is idempotent, but creating information is typically not. You don’t want a retry
    mechanism to accidentally create two orders just because the response from the
    first order’s creation got lost in the network.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Resilience4j exposes retry information in the same way as it does for circuit
    breakers when it comes to events and metrics but does not provide any health information.
    Retry events are accessible on the `actuator` endpoint, `/actuator/retryevents`.
    To control the retry logic, Resilience4j can be configured using standard Spring
    Boot configuration files. We will use the following configuration parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`maxAttempts`: The number of attempts before giving up, including the first
    call. We will set this parameter to `3`, allowing a maximum of two retry attempts
    after an initial failed call.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitDuration`: The wait time before the next retry attempt. We will set this
    value to `1000` ms, meaning that we will wait 1 second between retries.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryExceptions`: A list of exceptions that will trigger a retry. We will
    only trigger retries on `InternalServerError` exceptions, that is, when HTTP requests
    respond with a `500` status code.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when configuring retry and circuit breaker settings so that, for
    example, the circuit breaker doesn’t open the circuit before the intended number
    of retries has been completed!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of available configuration parameters, see [https://resilience4j.readme.io/docs/retry#create-and-configure-retry](https://resilience4j.readme.io/docs/retry#create-and-configure-retry).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction, we are ready to see how to add these resilience mechanisms
    to the source code in the `product-composite` service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Adding the resilience mechanisms to the source code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add the resilience mechanisms to the source code, we will add code
    that makes it possible to force an error to occur, as a delay and/or as a random
    fault. Next, we will add a circuit breaker together with a time limiter to handle
    slow or unresponsive APIs, as well as a retry mechanism that can handle faults
    that happen randomly. Adding these features from Resilience4j follows the Spring
    Boot way, which we have been using in the previous chapters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Add a starter dependency on Resilience4j in the build file
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add annotations in the source code where the resilience mechanisms will be applied
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将应用弹性机制的源代码位置添加注释
- en: Add a configuration that controls the behavior of the resilience mechanisms
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个控制弹性机制行为的配置
- en: Handling resilience challenges is a responsibility of the integration layer;
    therefore, the resilience mechanisms will be placed in the `ProductCompositeIntegration`
    class. The source code in the business logic, implemented in the `ProductCompositeServiceImpl`
    class, will not be aware of the presence of the resilience mechanisms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 处理弹性挑战是集成层的责任；因此，弹性机制将被放置在`ProductCompositeIntegration`类中。在业务逻辑中实现的源代码，在`ProductCompositeServiceImpl`类中，将不会意识到弹性机制的存在。
- en: Once we have the mechanisms in place, we will finally extend our test script,
    `test-em-all.bash`, with tests that automatically verify that the circuit breaker
    works as expected when deployed in the system landscape.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了机制，我们最终将扩展我们的测试脚本`test-em-all.bash`，添加自动验证电路断路器在系统环境中部署时按预期工作的测试。
- en: Adding programmable delays and random errors
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加可编程延迟和随机错误
- en: To be able to test our resilience mechanisms, we need a way to control when
    errors happen. A simple way to achieve this is by adding optional query parameters
    in the API used to retrieve a product and a composite product.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试我们的弹性机制，我们需要一种控制错误发生时间的方法。实现这一目标的一种简单方法是在用于检索产品和复合产品的API中添加可选查询参数。
- en: The code and API parameters added in this section to force delays and errors
    to occur should only be used during development and tests, not in production.
    When we learn about the concept of a service mesh in *Chapter 18*, *Using a Service
    Mesh to Improve Observability and Management*, we will learn about better methods
    that can be used in production to introduce delays and errors in a controlled
    way. Using a service mesh, we can introduce delays and errors, typically used
    for verifying resilience capabilities, without affecting the source code of the
    microservices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中添加的代码和API参数，用于强制延迟和错误发生，应仅在开发测试期间使用，不应在生产环境中使用。当我们学习到第18章中关于服务网格的概念时，即*使用服务网格提高可观察性和管理*，我们将了解在生产环境中可以使用的更佳方法，以受控的方式引入延迟和错误。使用服务网格，我们可以引入延迟和错误，通常用于验证弹性能力，而不会影响微服务的源代码。
- en: 'The composite product API will simply pass on the parameters to the product
    API. The following query parameters have been added to the two APIs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 复合产品API将直接将参数传递给产品API。以下查询参数已被添加到这两个API中：
- en: '`delay`: Causes the `getProduct` API on the `product` microservice to delay
    its response. The parameter is specified in seconds. For example, if the parameter
    is set to `3`, it will cause a delay of three seconds before the response is returned.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 导致`product`微服务上的`getProduct` API延迟其响应。该参数以秒为单位指定。例如，如果参数设置为`3`，则会在响应返回之前造成三秒的延迟。'
- en: '`faultPercentage`: Causes the `getProduct` API on the `product` microservice
    to throw an exception randomly with the probability specified by the query parameter,
    from 0 to 100%. For example, if the parameter is set to `25`, it will cause every
    fourth call to the API, on average, to fail with an exception. It will return
    an `HTTP error 500 (Internal Server Error)` in these cases.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`faultPercentage`: 导致`product`微服务上的`getProduct` API随机抛出异常，其概率由查询参数指定，范围从0到100%。例如，如果参数设置为`25`，则平均每四次调用API时，会有一次调用失败并抛出异常。在这些情况下，它将返回`HTTP错误500（内部服务器错误）`。'
- en: Changes in the API definitions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API定义的变化
- en: 'The two query parameters that we introduced above, `delay` and `faultPercentage`,
    have been defined in the `api` project in the following two Java interfaces:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面引入的两个查询参数`delay`和`faultPercentage`已在`api`项目的以下两个Java接口中定义：
- en: '`ProductCompositeService`:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductCompositeService`:'
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`ProductService`:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductService`:'
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The query parameters are declared optional with default values that disable
    the use of the error mechanisms. This means that if none of the query parameters
    are used in a request, neither a delay will be applied nor an error will be thrown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数被声明为可选的，并具有默认值，这些默认值禁用了错误机制的使用。这意味着如果请求中没有使用任何查询参数，则不会应用延迟也不会抛出错误。
- en: Changes in the product-composite microservice
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品-复合微服务的变化
- en: 'The `product-composite` microservice simply passes the parameters to the product
    API. The service implementation receives the API request and passes on the parameters
    to the integration component that makes the call to the product API:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The call from the `ProductCompositeServiceImpl` class to the integration component
    looks like this:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call from the `ProductCompositeIntegration` class to the product API looks
    like this:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changes in the product microservice
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `product` microservice implements the actual delay and random error generator
    in the `ProductServiceImpl` class by extending the existing stream used to read
    product information from the MongoDB database. It looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the stream returns a response from the Spring Data repository, it first
    applies the `throwErrorIfBadLuck` method to see whether an exception needs to
    be thrown. Next, it applies a delay using the `delayElement` function in the `Mono`
    class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The random error generator, `throwErrorIfBadLuck()`, creates a random number
    between `1` and `100` and throws an exception if it is higher than, or equal to,
    the specified fault percentage. If no exception is thrown, the product entity
    is passed on in the stream. The source code looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the programmable delays and random error functions in place, we are ready
    to start adding resilience mechanisms to the code. We will start with the circuit
    breaker and the time limiter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Adding a circuit breaker and a time limiter
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, we need to add dependencies, annotations, and configuration.
    We also need to add some code for implementing fallback logic for fail-fast scenarios.
    We will see how to do this in the following sections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to the build file
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add a circuit breaker and a time limiter, we have to add dependencies to
    the appropriate Resilience4j libraries in the build file, `build.gradle`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'From the product documentation ([https://resilience4j.readme.io/docs/getting-started-3#setup](https://resilience4j.readme.io/docs/getting-started-3#setup)),
    we can learn that the following three dependencies need to be added. We will use
    the latest available version (`v2.0.2`, when this chapter was written):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To avoid Spring Cloud overriding the version used with the older version of
    Resilience4j that it bundles, we also import a `resilience4j-bom` (Bill Of Material)
    file, as described in the Spring Boot 3 demo project [https://github.com/resilience4j/resilience4j-spring-boot3-demo](https://github.com/resilience4j/resilience4j-spring-boot3-demo).
    We add this `bom` file to the existing `bom` file for Spring Cloud in the `dependencyManagement`
    section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding annotations in the source code
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The circuit breaker can be applied by annotating the method it is expected
    to protect with `@CircuitBreaker(...)`, which, in this case, is the `getProduct()`
    method in the `ProductCompositeIntegration` class. The circuit breaker is triggered
    by an exception, not by a timeout itself. To be able to trigger the circuit breaker
    after a timeout, we will add a time limiter that can be applied with the annotation
    `@TimeLimiter(...)`. The source code looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过注解要保护的方法来应用熔断器，在本例中是`ProductCompositeIntegration`类中的`getProduct()`方法。熔断器是由异常触发的，而不是由超时本身触发的。为了能够在超时后触发熔断器，我们将添加一个可以注解为`@TimeLimiter(...)`的时间限制器。源代码如下：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `name` of the circuit breaker and the time limiter annotation, `"product"`,
    is used to identify the configuration that will be applied. The `fallbackMethod`
    parameter in the circuit breaker annotation is used to specify what fallback method
    to call (`getProductFallbackValue`, in this case) when the circuit breaker is
    open; see below for information on how it is used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 熔断器和时间限制器注解的`name` `"product"`用于标识将要应用配置。熔断器注解中的`fallbackMethod`参数用于指定当熔断器开启时调用哪个回退方法（在本例中为`getProductFallbackValue`）；下面将介绍其用法。
- en: 'To activate the circuit breaker, the annotated method must be invoked as a
    Spring bean. In our case, it’s the integration class that’s injected by Spring
    into the service implementation class, `ProductCompositeServiceImpl`, and therefore
    used as a Spring bean:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活熔断器，必须以Spring bean的形式调用注解的方法。在我们的案例中，是Spring注入到服务实现类`ProductCompositeServiceImpl`中的集成类，因此用作Spring
    bean：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding fail-fast fallback logic
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加快速失败回退逻辑
- en: 'To be able to apply fallback logic when the circuit breaker is open, that is,
    when a request fails fast, we can specify a fallback method on the `CircuitBreaker`
    annotation, as seen in the previous source code. The method must follow the signature
    of the method the circuit breaker is applied for and also have an extra last argument
    used for passing the exception that triggered the circuit breaker. In our case,
    the method signature for the fallback method looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在熔断器开启时应用回退逻辑，即当请求快速失败时，我们可以在`CircuitBreaker`注解上指定一个回退方法，如前一个源代码所示。该方法必须遵循熔断器应用的方法的签名，并且还有一个额外的最后一个参数，用于传递触发熔断器的异常。在我们的案例中，回退方法的签名如下：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last parameter specifies that we want to be able to handle exceptions of
    type `CallNotPermittedException`. We are only interested in exceptions that are
    thrown when the circuit breaker is in its open state so that we can apply fail-fast
    logic. When the circuit breaker is open, it will not permit calls to the underlying
    method; instead, it will immediately throw a `CallNotPermittedException` exception.
    Therefore, we are only interested in catching `CallNotPermittedException` exceptions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数指定了我们想要能够处理类型为`CallNotPermittedException`的异常。我们只对当熔断器处于开启状态时抛出的异常感兴趣，以便我们可以应用快速失败逻辑。当熔断器开启时，它将不允许调用底层方法；相反，它将立即抛出一个`CallNotPermittedException`异常。因此，我们只对捕获`CallNotPermittedException`异常感兴趣。
- en: The fallback logic can look up information based on the `productId` from alternative
    sources, for example, an internal cache. In our case, we will return hardcoded
    values based on the `productId`, to simulate a hit in a cache. To simulate a miss
    in the cache, we will throw a `not found` exception in the case where the `productId`
    is `13`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 回退逻辑可以根据`productId`从替代源中查找信息，例如，内部缓存。在我们的案例中，我们将根据`productId`返回硬编码的值，以模拟缓存中的命中。为了模拟缓存中的未命中，当`productId`为`13`时，我们将抛出一个`not
    found`异常。
- en: 'The implementation of the fallback method looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回退方法的实现看起来是这样的：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Adding configuration
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Finally, the configuration of the circuit breaker and time limiter is added
    to the `product-composite.yml` file in the config repository, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将熔断器和时间限制器的配置添加到配置存储库中的`product-composite.yml`文件中，如下所示：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The values in the configuration have already been described in the previous
    sections, *Introducing the circuit breaker* and *Introducing the time limiter*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的值已在之前的章节中描述，*介绍熔断器*和*介绍时间限制器*。
- en: Adding a retry mechanism
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加重试机制
- en: In the same way as for the circuit breaker, a retry mechanism is set up by adding
    dependencies, annotations, and configuration. The dependencies were added previously
    in the *Adding dependencies to the build file* section, so we only need to add
    the annotation and set up the configuration.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Adding the retry annotation
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The retry mechanism can be applied to a method by annotating it with `@Retry(name="nnn")`,
    where `nnn` is the name of the configuration entry to be used for this method.
    See the following *Adding configuration* section for details on the configuration.
    The method, in our case, is the same as it is for the circuit breaker and time
    limiter, `getProduct()` in the `ProductCompositeIntegration` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding configuration
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Configuration for the retry mechanism is added in the same way as for the circuit
    breaker and time limiter in the `product-composite.yml` file in the config repository,
    like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The actual values were discussed in the *Introducing the retry mechanism* section
    above.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: While using multiple mechanisms of Resilience4j (in our case, the circuit breaker,
    time limiter, and retry mechanism), understanding the order of how these aspects
    are applied is of importance. For information, see [https://resilience4j.readme.io/docs/getting-started-3#aspect-order](https://resilience4j.readme.io/docs/getting-started-3#aspect-order).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: That is all the dependencies, annotations, source code, and configuration required.
    Let’s wrap up by extending the test script with tests that verify that the circuit
    breaker works as expected in a deployed system landscape.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Adding automated tests
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Automated tests for the circuit breaker have been added to the `test-em-all.bash`
    test script in a separate function, `testCircuitBreaker()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To be able to perform some of the required verifications, we need to have access
    to the `actuator` endpoints of the `product-composite` microservice, which are
    not exposed through the edge server. Therefore, we will access the `actuator`
    endpoints by running a command in the `product-composite` microservice using the
    Docker Compose `exec` command. The base image used by the microservices, `Eclipse
    Temurin`, bundles `curl`, so we can simply run a `curl` command in the `product-composite`
    container to get the information required. The command looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `-T` argument is used to disable the use of a terminal for the `exec` command.
    This is important to make it possible to run the `test-em-all.bash` test script
    in an environment where no terminals exist, for example, in an automated build
    pipeline used for CI/CD.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to extract the information we need for our tests, we can pipe the
    output to the `jq` tool. For example, to extract the actual state of the circuit
    breaker, we can run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It will return either `CLOSED`, `OPEN`, or `HALF_OPEN`, depending on the actual
    state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The test starts by doing exactly this, that is, verifying that the circuit
    breaker is closed before the tests are executed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, the test will force the circuit breaker to open up by running three commands
    in a row, all of which will fail on a timeout caused by a slow response from the
    `product` service (the `delay` parameter is set to `3` seconds):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**A quick reminder of the configuration**: The timeout of the `product` service
    is set to two seconds so that a delay of three seconds will cause a timeout. The
    circuit breaker is configured to evaluate the last five calls when closed. The
    tests in the script that precede the circuit breaker-specific tests have already
    performed a couple of successful calls. The failure threshold is set to 50%; three
    calls with a three-second delay are enough to open the circuit.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'With the circuit open, we expect a fail-fast behavior, that is, we won’t need
    to wait for the timeout before we get a response. We also expect the `fallback`
    method to be called to return a best-effort response. This should also apply to
    a normal call, that is, without requesting a delay. This is verified with the
    following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The product ID `1` is stored in a variable, `$PROD_ID_REVS_RECS`, to make it
    easier to modify the script if required.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also verify that the simulated `not found` error logic works as expected
    in the fallback method, that is, the fallback method returns `404, NOT_FOUND`
    for product ID `13`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The product ID `13` is stored in a variable, `$PROD_ID_NOT_FOUND`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'As configured, the circuit breaker will change its state to half-open after
    `10` seconds. To be able to verify that, the test waits for `10` seconds:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After verifying the expected state (half-open), the test runs three normal
    requests to make the circuit breaker go back to its normal state, which is also
    verified:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The test code also verifies that it got a response with data from the underlying
    database. It does that by comparing the returned product name with the value stored
    in the database. For the product with product ID `1`, the name is `"product name
    C"`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**A quick reminder of the configuration**: The circuit breaker is configured
    to evaluate the first three calls when in the half-open state. Therefore, we need
    to run three requests where more than 50% are successful before the circuit is
    closed.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The test wraps up by using the `/actuator/circuitbreakerevents` actuator API,
    which is exposed by the circuit breaker to reveal internal events. It is used
    to find out what state transitions the circuit breaker has performed. We expect
    the last three state transitions to be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'First state transition: Closed to open'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next state transition: Open to half-open'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last state transition: Half-open to closed'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is verified by the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `jq` expression, `circuitBreakerEvents[-1]`, means the last entry in the
    array of circuit breaker events, `[-2]` is the second to last event, while `[-3]`
    is the third to last event. Together, they are the three latest events, the ones
    we are interested in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We added quite a lot of steps to the test script, but with this, we can automatically
    verify that the expected basic behavior of our circuit breaker is in place. In
    the next section, we will try it out. We will run tests both automatically by
    running the test script and manually by running the commands in the test script
    by hand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the circuit breaker and retry mechanism
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it’s time to try out the circuit breaker and retry mechanism. We will
    start, as usual, by building the Docker images and running the test script, `test-em-all.bash`.
    After that, we will manually run through the tests we described previously to
    ensure that we understand what’s going on! We will perform the following manual
    tests:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Happy days tests of the circuit breaker, to verify that the circuit is closed
    under normal operations
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negative tests of the circuit breaker, to verify that the circuit opens up when
    things start to go wrong
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going back to normal operation, to verify that the circuit goes back to its
    closed state once the problems are resolved
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the retry mechanism with random errors
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running the automated tests
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build and run the automated tests, we need to do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the test script prints out **Start Circuit Breaker tests!**, the tests
    we described previously have been executed!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the circuit is closed under normal operations
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An access token issued by the authorization server is valid for 1 hour. So,
    if you start to get `401 – Unauthorized` errors after a while, it is probably
    time to acquire a new access token.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Try a normal request and verify that it returns the HTTP response code `200`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `-w "%{http_code}\n"` switch is used to print the HTTP return status. As
    long as the command returns `200`, we are not interested in the response body,
    so we suppress it with the switch `-o /dev/null`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the circuit breaker is closed using the `health` API:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the circuit breaker to open when things go wrong
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it’s time to make things go wrong! By that, I mean it’s time to try out
    some negative tests to verify that the circuit opens up when things start to go
    wrong. Call the API three times and direct the `product` service to cause a timeout
    on every call, that is, delay the response by `3` seconds. This should be enough
    to trip the circuit breaker:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We expect a response such as the following each time:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_13_03.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Response after a timeout'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit breaker is now open, so if you make a fourth attempt (within `waitInterval`,
    that is, `10` seconds), you will see fail-fast behavior and the `fallback` method
    in action. You will get a response back immediately instead of an error message
    once the time limiter kicks in after `2` seconds:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_13_04.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Response when the circuit breaker is open'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The response will come from the fallback method. This can be recognized by looking
    at the value in the name field, `Fallback product1`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Fail-fast and fallback methods are key capabilities of a circuit breaker. A
    configuration with a wait time set to only 10 seconds in the open state requires
    you to be rather quick to be able to see fail-fast logic and fallback methods
    in action! Once in a half-open state, you can always submit three new requests
    that cause a timeout, forcing the circuit breaker back to the open state, and
    then quickly try the fourth request. Then, you should get a fail-fast response
    from the fallback method. You can also increase the wait time to a minute or two,
    but it can be rather boring to wait that amount of time before the circuit switches
    to the half-open state.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait 10 seconds for the circuit breaker to transition to half-open, and then
    run the following command to verify that the circuit is now in a half-open state:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Expect it to respond with `HALF_OPEN`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Closing the circuit breaker again
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the circuit breaker is in a half-open state, it waits for three calls to
    see whether it should open the circuit again or go back to normal by closing it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s submit three normal requests to close the circuit breaker:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'They should all respond with `200`. Verify that the circuit is closed again
    by using the `health` API:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by listing the last three state transitions using the following
    command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Expect it to respond with the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_13_05.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Circuit breaker state changes'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'This response tells us that we have taken our circuit breaker through a full
    lap of its state diagram:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: From closed to open when the timeout errors start to prevent requests from succeeding
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From open to half-open to see whether the error is gone
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From half-open to closed when the error is gone, that is, when we are back to
    normal operation
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we are done with testing the circuit breaker; let’s move on and see
    the retry mechanism at play.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Trying out retries caused by random errors
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s simulate that there is a – hopefully temporary – random issue with our
    `product` service or the communication with it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using the `faultPercent` parameter. If we set it to `25`,
    we expect every fourth request on average to fail. We hope that the retry mechanism
    will kick in to help us by automatically retrying failed requests. One way of
    noticing that the retry mechanism has kicked in is to measure the response time
    of the `curl` command. A normal response should take around 100 ms. Since we have
    configured the retry mechanism to wait 1 second (see the `waitDuration` parameter
    in the section on the configuration of the retry mechanism), we expect the response
    time to increase by 1 second per retry attempt. To force a random error to occur,
    run the following command a couple of times:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The command should respond with `200`, indicating that the request succeeded.
    A response time prefixed with `real`, for example, `real 0m0.078s`, means that
    the response time was 0.078 s, or 78 ms. A normal response, that is, without any
    retries, should report a response time of around 100 ms as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B19825_13_06.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Elapsed time for a request without a retry'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'A response after one retry should take a little over 1 second and look as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_13_07.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Elapsed time for a request with one retry'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP status code `200` indicates that the request has succeeded, even though
    it required one retry before succeeding!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have noticed a response time of 1 second, indicating that the request
    required one retry to succeed, run the following command to see the last two retry
    events:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should be able to see the failed request and the next successful attempt.
    The `creationTime` timestamps are expected to differ by 1 second. Expect a response
    such as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Text, chat or text message  Description automatically generated](img/B19825_13_08.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Retry events captured after a request with one retry'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are really unlucky, you will get two faults in a row, and then you will
    get a response time of 2 seconds instead of 1\. If you repeat the preceding command,
    you will be able to see that the `numberOfAttempts` field is counted for each
    retry attempt, which is set to `1` in this case: `"numberOfAttempts": 1`. If calls
    continue to fail, the circuit breaker will kick in and open its circuit, that
    is, subsequent calls will apply fail-fast logic and the fallback method will be
    applied!'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. Feel free to experiment with the parameters in the
    configuration to learn more about the resilience mechanisms.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget to shut down the system landscape:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen Resilience4j and its circuit breaker, time limiter,
    and retry mechanism in action.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A microservice that has synchronous dependencies to other services can become
    unresponsive or even crash if these services stop responding as expected, especially
    under a high load. These types of error scenarios can be avoided by using a circuit
    breaker, which applies fail-fast logic and calls fallback methods when it is open.
    A circuit breaker can also make a microservice resilient by allowing requests
    when it is half-open to see whether the failing service is operating normally
    again and close the circuit if so. To support a circuit breaker in handling unresponsive
    services, a time limiter can be used to maximize the time a circuit breaker waits
    before it kicks in.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: A retry mechanism can retry requests that randomly fail from time to time, for
    example, due to temporary network problems. It is very important to only apply
    retry requests on idempotent services, that is, services that can handle the same
    request being sent two or more times.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Circuit breakers and retry mechanisms are implemented by following Spring Boot
    conventions: declaring dependencies and adding annotations and configuration.
    Resilience4j exposes information about its circuit breakers and retry mechanisms
    at runtime, using `actuator` endpoints. For circuit breakers, information regarding
    health, events, and metrics is available. For retries, information regarding events
    and metrics is available.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the usage of endpoints for both health and events in this chapter,
    but we will have to wait until *Chapter 20*, *Monitoring Microservices*, before
    we use any of the metrics.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the last part of using Spring Cloud, where
    we will learn how to trace call chains through a set of cooperating microservices
    using Spring Cloud Sleuth and Zipkin. Head over to *Chapter 14*, *Understanding
    Distributed Tracing*, to get started!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the states of a circuit breaker and how are they used?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we handle timeout errors in the circuit breaker?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we apply fallback logic when a circuit breaker fails fast?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a retry mechanism and a circuit breaker interfere with each other?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an example of a service that you can’t apply a retry mechanism to.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
