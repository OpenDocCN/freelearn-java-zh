<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating New Vaadin Projects</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This first chapter serves as the foundations for a journey full of interesting technologies, thrilling challenges, and useful code. If you are reading this book, the chances that you have coded a Vaadin application before are high. You probably have a basic understanding of the key players in a Vaadin application: components, layouts, listeners, binders, resources, themes, and widget sets; and you, of course, have had your share of Java coding!</span></p>
<p>Having a solid base when starting a project, not only with Vaadin but with any other technology, plays an important role in successful projects. Understanding what your code does and why it is required helps you make better decisions and become more productive. This chapter will help you understand what is really needed to run a Vaadin application and how you can become more confident about the dependencies and Maven configuration required to start a new Vaadin project.</p>
<p class="p1"><span class="s1">This chapter covers the following topics:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">The main Java dependencies in Vaadin</span></li>
<li class="li2">Servlets and UIs</li>
<li>Maven plugins</li>
<li>Key elements in a Vaadin application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-01">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-01</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/RHavBs">https://goo.gl/RHavBs</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">About the demo applications</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">This book offers value in two ways: the book itself with its explanations, and its companion source code. Instead of developing one single application throughout the book, several small demo applications demonstrate the concepts explained in each chapter. This helps you to jump to any chapter you are interested in, and fully understand the purpose of each part of the code without worrying about the technicalities that we have looked at in other chapters.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the source code</h1>
                </header>
            
            <article>
                
<p class="p2"><span>Before you compile the project, you have to start an H2 database instance. For your convenience, a server is configured in the</span> <kbd>Data-centric-Applications-with-Vaadin-8/chapter-05</kbd> Maven <span>module. You can create a run configuration for the following Maven command or you can run it directly on the command line:</span></p>
<pre><strong>cd Data-centric-Applications-with-Vaadin-8/chapter-05</strong><br/><strong>mvn test exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.H2Server"</strong></pre>
<p>Once the database is up and running, you can build all the demo applications by executing the following:</p>
<pre><strong>cd Data-centric-Applications-with-Vaadin-8</strong><br/><strong>mvn install</strong></pre>
<p class="p2"><span class="s1">All the demo applications are aggregated in a multi-module Maven project, where each module corresponds to one chapter of the book.</span></p>
<div class="p2 packt_infobox"><span class="s1">This book assumes that you are proficient enough with Maven to follow the example applications of each chapter. If you have no previous experience with Maven or multi-module Maven projects, please spend some time going through the tutorials and documentation at:<span> </span><a href="http://maven.apache.org/guides">http://maven.apache.org/guides</a>.</span></div>
<p class="p4"><span class="s1">Each chapter's module may contain multiple sub-modules depending on the concepts being explained in that chapter. We will use the</span> Jetty Maven <span class="s1">plugin to run the examples. </span><span class="s1">Most IDEs today have good support for Maven. The best way to use this book's code is by importing the</span> <kbd><span class="s3">Data-centric-Applications-with-Vaadin-8</span></kbd><span class="s1"> Maven project into your IDE and creating individual <em>running configurations</em> for each demo application.</span> <span class="s1">There are tons of resources online that explain how to do this for the most popular IDEs, such as IntelliJ IDEA, NetBeans, and Eclipse. For example, to run the example application for this chapter in IntelliJ IDEA, create a new running configuration like the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dbe3941e-694b-4a61-b0b4-aadb27684661.png"/></div>
<p>Make sure the working directory corresponds to the correct module in the project. Alternatively, you can run the application by executing the following on the command line:</p>
<pre><strong>cd Data-centric-Applications-with-Vaadin-8/chapter-01</strong><br/><strong>mvn package jetty:run</strong></pre>
<p>This executes the package Maven phase and starts a Jetty server. The application should be available at <kbd>http://localhost:8080</kbd>.</p>
<p>So, <span class="s1">go ahead! Download the source code, import it into your IDE, and run a couple of examples. Feel free to explore the code, modify it, and even use it in your own projects.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the architecture of a Vaadin application</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">What's the best way of starting a new Vaadin project? It’s hard to say. It depends on your previous experience, current development environment setup, and your own preferences. One of the most popular ways of creating a new Vaadin project is by using one of the official <em>Maven archetypes</em>. You have probably used the </span><kbd><span class="s2">vaadin-archetype-application</span></kbd><span class="s1"> Maven archetype, which is good to quickly get started with Vaadin. Maybe you have used the </span><kbd><span class="s2">vaadin-archetype-widgetset</span></kbd><span class="s1"> archetype to create a Vaadin add-on, or maybe you have used the </span><kbd><span class="s2">vaadin-archetype-application-multimodule</span></kbd> <span class="s1">or</span> <kbd><span class="s2">vaadin-archetype-application-example</span></kbd><span class="s1"> archetypes to bootstrap some of your applications. IDEs such as Eclipse provide tools to create a Vaadin project without even thinking about Maven archetypes.</span></p>
<p class="p2"><span class="s1">All of those archetypes and tools are good in the sense that they get you started quickly and show some good practices. However, when you create a project from scratch, you get a better understanding of the whole architecture of the application. Of course, you can use the archetypes if you already feel comfortable enough with every part of the generated</span> <span class="s2"><kbd>pom.xml</kbd> file</span><span class="s1">. However, building the project from scratch is a good way of truly understanding and controlling the configuration of your Vaadin application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new project from scratch</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Usually, you would use the</span><span> </span><kbd><span class="s2">vaadin-archetype-application</span></kbd><span> </span><span class="s1">or</span><span> </span><kbd><span class="s2">vaadin-archetype-application-multimodule</span></kbd><span class="s1"> Maven archetypes to create a new Vaadin application. There's nothing wrong with using these if the generated code suits your needs. However, these archetypes generate more code than you need, partially because they try to show you how to get started with Vaadin and partially because they are general-purpose starters which are well-suited for most projects. But let's gain full control (and understanding) of the web application by creating a Vaadin project in a very different way—a more fine-grained, controlled way.</span></p>
<p class="p2"><span class="s1">A Vaadin application is, at the end of the day, a Java application packaged as a <kbd>WAR</kbd> file. You can think of it as a standard web application in which you drop some JARs that allow you to build a web UI using the Java Programming Language instead of HTML and JavaScript. Is it as simple as dropping some JARs into your Java project? Let's find out!</span></p>
<p class="p2"><span class="s1">Use the</span><span> </span><kbd><span class="s2">maven-archetype-webapp</span></kbd><span> </span><span class="s1">to generate a simple Java web application by executing the following on the command line</span><span class="s1">:</span></p>
<pre class="p3"><strong><span class="s1">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp</span></strong></pre>
<p class="p2"><span class="s1">Use the following properties when prompted:</span></p>
<ul class="ul1">
<li class="li4"><kbd><span class="s1">groupId</span></kbd>: <kbd><span class="s1">packt.vaadin.datacentric.chapter01</span></kbd></li>
<li class="li4"><kbd><span class="s1">artifactId</span></kbd>: <kbd><span class="s1">chapter-01</span></kbd></li>
<li class="li4"><kbd><span class="s1">version</span></kbd>: <kbd><span class="s1">1.0-SNAPSHOT</span></kbd></li>
<li class="li4"><kbd><span class="s1">package</span></kbd>: <kbd><span class="s1">packt.vaadin.datacentric.chapter01</span></kbd></li>
</ul>
<div class="p5 packt_tip"><span class="s1">IDEs such as NetBeans, Eclipse, and IntelliJ IDEA have excellent support for Maven. You should be able to create a new Maven project using the previous archetype in your IDE by providing the corresponding Maven coordinates without using the command line.</span></div>
<p class="p1"><span class="s1">Clean up the</span> <kbd><span class="s2">pom.xml</span></kbd> <span class="s1">file to make it look like the following:</span></p>
<pre class="p5">&lt;project ...&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><br/>    &lt;artifactId&gt;chapter-01&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/>    &lt;packaging&gt;war&lt;/packaging&gt;<br/>&lt;/project&gt;</pre>
<div class="packt_infobox"><span class="s1">Note that in the code provided with this book, you’ll find a<span> </span></span><kbd><span class="s2">&lt;parent&gt;</span></kbd><span class="s1"><span> </span>section in the<span> </span></span><kbd><span class="s2">pom.xml</span></kbd><span class="s1"><span> </span>file of the<span> </span></span><kbd><span class="s2">chapter-01</span></kbd><span class="s1"><span> </span>project. This is because all the demo applications of the book have been aggregated into a single<span> </span><kbd>Data-centric-Applications-with-Vaadin-8</kbd> Maven project for your convenience. You don’t need to add any<span> </span></span><kbd><span class="s2">&lt;parent&gt;</span></kbd><span class="s1"><span> </span>section to your project if you are following the steps in this chapter.</span></div>
<div>
<p class="p1"><span class="s1">Remove the</span> <kbd><span class="s2">src/main/webapp</span></kbd> <span class="s1">and</span> <kbd><span class="s2">src/main/resources</span></kbd> <span class="s1">directories. This deletes the generated</span> <kbd><span class="s2">web.xml</span></kbd> <span class="s1">file which will make Maven complain. To tell it that this was intended, add the following property to your <kbd>pom.xml</kbd> file:</span></p>
<pre class="p2"><span class="s1"><span class="Apple-converted-space">    ...<br/>    &lt;packaging&gt;war&lt;/packaging&gt;<br/>    <br/></span><strong>    &lt;properties&gt;</strong><br/></span><strong><span class="s1"><span class="Apple-converted-space">        </span>&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;/properties&gt;<br/>    ...</span></strong></pre>
<p class="p1"><span class="s1">Also, add the following properties to configure Maven to use Java 8:</span></p>
<pre class="p2"><span class="s1"><span class="Apple-converted-space">        </span>&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;<br/></span><span class="s1"><span class="Apple-converted-space">        </span>&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependencies</h1>
                </header>
            
            <article>
                
<p class="p2">At this point, we have a very simple Java project setup that will be packaged as a <kbd>WAR</kbd> file. The next natural step is to add the required dependencies or libraries. <span class="s1">Vaadin, like many other Java web applications, requires the Servlet API. Add it as follows to the <kbd>pom.xml</kbd> file:</span></p>
<pre class="p2"><span class="s1"><span class="Apple-converted-space">    </span>&lt;dependencies&gt;<br/></span><span class="s1"><span class="Apple-converted-space">        </span>&lt;dependency&gt;<br/></span><span class="s1"><span class="Apple-converted-space">            </span>&lt;groupId&gt;<strong>javax.servlet</strong>&lt;/groupId&gt;<br/></span><span class="s1"><span class="Apple-converted-space">            </span>&lt;artifactId&gt;<strong>javax.servlet-api</strong>&lt;/artifactId&gt;<br/></span><span class="s1"><span class="Apple-converted-space">            </span>&lt;version&gt;<strong>3.1.0</strong>&lt;/version&gt;<br/></span><span class="s1"><span class="Apple-converted-space">            </span>&lt;scope&gt;<strong>provided</strong>&lt;/scope&gt;<br/></span><span class="s1"><span class="Apple-converted-space">        </span>&lt;/dependency&gt;<br/></span><span class="s1"><span class="Apple-converted-space">    </span>&lt;/dependencies&gt;</span></pre>
<p class="p1"><span class="s1">Notice that the scope of this dependency is set as </span><kbd><span class="s2">provided</span></kbd><span class="s1">, which means that a server, or more specifically, a Servlet Container, such as Jetty or Tomcat, will provide the implementation.</span></p>
<p class="p1"><span class="s1">Let’s continue by adding the required Vaadin dependencies. First, add the</span> <kbd><span class="s2">vaadin-bom</span></kbd><span class="s1"> dependency to your</span> <kbd><span class="s2">pom.xml</span></kbd> <span class="s1">file:</span></p>
<pre class="p2"><span class="s1"><span class="Apple-tab-span"> </span>    &lt;dependencyManagement&gt;<br/>        &lt;dependencies&gt;<br/>            &lt;dependency&gt;<br/>                &lt;groupId&gt;<strong>com.vaadin</strong>&lt;/groupId&gt;<br/>                &lt;artifactId&gt;<strong>vaadin-bom</strong>&lt;/artifactId&gt;<br/>                &lt;version&gt;<strong>8.3.2</strong>&lt;/version&gt;<br/>                &lt;type&gt;<strong>pom</strong>&lt;/type&gt;<br/>                &lt;scope&gt;<strong>import</strong>&lt;/scope&gt;<br/>            &lt;/dependency&gt;<br/>        &lt;/dependencies&gt;<br/>    &lt;/dependencyManagement&gt;<br/></span></pre>
<div class="packt_infobox"><span>This book uses Vaadin Framework version 8.3.2, the latest production-ready version of the framework at the time of writing.</span></div>
<p class="p1"><span class="s1">A Maven BOM, or bill of materials, frees you from worrying about versions of related dependencies; in this case, the Vaadin dependencies. Let's drop these dependencies next. Add the following to your <kbd>pom.xml</kbd> file:</span></p>
<pre>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.vaadin&lt;/groupId&gt;<br/>        &lt;artifactId&gt;<strong>vaadin-server</strong>&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.vaadin&lt;/groupId&gt;<br/>        &lt;artifactId&gt;<strong>vaadin-client-compiled</strong>&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.vaadin&lt;/groupId&gt;<br/>        &lt;artifactId&gt;<strong>vaadin-themes</strong>&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;</pre>
<p class="p1"><span class="s1">There's no need to explicitly set the version for these thanks to the</span> <kbd><span class="s2">vaadin-bom</span></kbd> <span class="s1">dependency. We've just added a server-side API (</span><kbd><span class="s2">vaadin-server</span></kbd><span class="s1">), a client-side engine or widget set (</span><kbd><span class="s2">vaadin-client-compiled</span></kbd><span class="s1">), and the Valo theme (</span><kbd><span class="s2">vaadin-themes</span></kbd><span class="s1">).</span></p>
<p class="p1"><span class="s1">At this point, you can compile the project by running the following command inside the</span> <kbd><span class="s2">chapter-01</span></kbd> <span class="s1">directory:</span></p>
<pre class="p4"><strong><span class="s1">mvn clean install</span></strong></pre>
<p class="p1"><span class="s1">This will download the dependencies to your local Maven repository if you haven't used Vaadin 8.3.2 before.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servlets and UIs</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">A Vaadin application in its simplest form is a</span> <kbd><span class="s2">Servlet</span></kbd> <span class="s1">that delegates user interface logic to a</span> <kbd><span class="s2">UI</span></kbd> <span class="s1">implementation. The</span> <kbd><span class="s2">vaadin-server</span></kbd> <span class="s1">dependency includes the</span> <kbd><span class="s2">Servlet</span></kbd> <span class="s1">implementation: the </span> <kbd><span class="s2">VaadinServlet</span></kbd><span class="s1"> class. Let’s configure one.</span></p>
<p class="p2"><span class="s1">Create a new directory with the name </span><kbd><span class="s2">java</span></kbd> <span class="s1">inside the</span> <kbd><span class="s2">src/main</span></kbd> <span class="s1">directory.</span></p>
<div class="p4 packt_tip"><span class="s1">You might have to tell your IDE that this is a source directory. You will most likely find this by right-clicking the directory and selecting the option to mark it as a source directory. Check the documentation for your IDE for detailed instructions.</span></div>
<p class="p2"><span class="s1">Create a new package with the name <kbd>packt.vaadin.datacentric.chapter01</kbd></span><span class="s1">, and add a simple <kbd>UI</kbd> implementation inside this package:</span></p>
<pre class="p5">public class <strong>VaadinUI extends UI</strong> {<br/><br/>    @Override<br/>    protected void init(VaadinRequest vaadinRequest) {<br/>        setContent(new Label("Welcome to Data-Centric Applications with Vaadin 8!"));<br/>    }<br/>}</pre>
<p class="p2"><span class="s1">Add a new</span> <kbd><span class="s2">WebConfig</span></kbd> <span class="s1">class to encapsulate everything related to web configuration, and define the</span> <kbd><span class="s2">VaadinServlet</span></kbd> <span class="s1">as an inner class:</span></p>
<pre class="p5">public class <strong>WebConfig</strong> {<br/><br/>    <strong>@WebServlet("/*")</strong><br/>    @VaadinServletConfiguration(<br/>          ui = <strong>VaadinUI.class</strong>, productionMode = false)<br/>    public static class WebappVaadinServlet extends <strong>VaadinServlet</strong> {<br/>    }<br/>}</pre>
<p class="p2"><span class="s1">The</span> <kbd><span class="s2">WebappVaadinServlet</span></kbd> <span class="s1">class must be</span> <kbd><span class="s2">public static</span></kbd> <span class="s1">to allow its instantiation by the Servlet Container. Notice how we are configuring <kbd>/*</kbd> as the servlet URL mapping using the <kbd>@WebServlet</kbd> annotation. This makes the application available at the root of the deployment path. Notice also how the <kbd>@VaadinServletConfiguration</kbd> annotation connects the <kbd>Servlet</kbd> to the <kbd>UI</kbd> implementation, the <kbd>VaadinUI</kbd> class we implemented in the previous step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven plugins</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">You must have used, or at least seen, the</span> Vaadin Maven plugin. <span class="s1">It allows you to compile the widget set and theme, among other tasks. When creating a new Vaadin application, though, you don’t have any add-ons, custom client-side components, or themes. This means you don’t need the Vaadin Maven plugin just yet. You can use the default widget set provided by the</span> <kbd><span class="s2">vaadin-client-compiled</span></kbd> <span class="s1">dependency.</span></p>
<p>We can benefit from at least one Maven plugin at this point: the Jetty Maven plugin. Although you can configure most IDEs to use a variety of servers in order to deploy your application during development, the Jetty Maven plugin frees you from further specific configurations, making it simple for developers to choose the tools they prefer. To use the plugin, add the following to the <kbd>pom.xml</kbd> file:</p>
<pre><span>&lt;</span><span>build</span><span>&gt;</span><br/>    <span>&lt;</span><span>plugins</span><span>&gt;</span><br/>        <span>&lt;</span><span>plugin</span><span>&gt;</span><br/>            <span>&lt;</span><span>groupId</span><span>&gt;</span><strong>org.eclipse.jetty</strong><span>&lt;/</span><span>groupId</span><span>&gt;</span><br/>            <span>&lt;</span><span>artifactId</span><span>&gt;</span><strong>jetty-maven-plugin</strong><span>&lt;/</span><span>artifactId</span><span>&gt;</span><br/>            <span>&lt;</span><span>version</span><span>&gt;</span><strong>9.3.7.v20160115</strong><span>&lt;/</span><span>version</span><span>&gt;</span><br/>        <span>&lt;/</span><span>plugin</span><span>&gt;</span><br/>    <span>&lt;/</span><span>plugins</span><span>&gt;</span><br/><span>&lt;/</span><span>build</span><span>&gt;</span></pre>
<p>With this in place, you can run the application by creating a new running configuration in your IDE to execute <kbd>mvn jetty:run</kbd>. Point your browser to <kbd>http://localhost:8080</kbd> and you should see the application running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5c26e506-a4de-4096-9539-3cb4e232f71d.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components and layouts</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">To get a full picture of the main parts of a Vaadin application, let's do a quick review of some of the most important classes you should already be familiar with. In a Vaadin application, most of the code deals with components and layouts. In a nutshell, you add components such as</span> <kbd><span class="s2">Label</span></kbd><span class="s1">,</span> <kbd><span class="s2">TextField</span></kbd><span class="s1">,</span> <kbd><span class="s2">CheckBox</span></kbd><span class="s1">,</span> <kbd><span class="s2">ComboBox</span></kbd><span class="s1">, and </span><kbd><span class="s2">Grid</span></kbd><span class="s1"> into layouts such as</span> <kbd><span class="s2">VerticalLayout</span></kbd><span class="s1">,</span> <kbd><span class="s2">FormLayout</span></kbd><span class="s1">,</span> <kbd><span class="s2">GridLayout</span></kbd><span class="s1">,</span> <kbd><span class="s2">HorizontalLayout</span></kbd><span class="s1">, and</span> <kbd><span class="s2">CSSLayout</span></kbd><span class="s1">. You can also add layouts into layouts.</span></p>
<div class="p3 packt_tip CDPAlignLeft CDPAlign"><span class="s1">During design or development, you might want to explore the available components and layouts in the framework so that you can pick the best for a particular scenario. One way to see all the components and layouts included in the framework is by visiting the Vaadin sampler at: <a href="http://demo.vaadin.com/sampler"><span class="s3">http://demo.vaadin.com/sampler</span></a>. You can see code examples by clicking the</span> <span class="packt_screen">Information</span> <span class="s1">icon in the upper right corner of the page:</span></div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-189 image-border" src="assets/c6790880-f9a0-4a6f-a00c-d930a02d27fe.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listeners and binders</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Vaadin applications interact with the server through listeners and binders. Listeners allow you to handle user interaction, while binders allow you to keep values in input components (such as</span> <kbd><span class="s2">TextField</span></kbd><span class="s1">) and domain objects (for example, a custom </span><kbd><span class="s2">User</span></kbd><span class="s1"> class) in sync.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Events and listeners</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s1">In a Vaadin application, the behavior is added through <em>listeners</em>. </span><span class="s1">A listener fires an event when the corresponding action happens, usually caused by the interaction of the user with the UI. Two of the most common listeners in Vaadin are</span> <kbd><span class="s2">ClickListener</span></kbd><span class="s1"> (for buttons) and</span> <kbd><span class="s2">ValueChangeListener</span></kbd><span class="s1"> (for input components). Listeners are usually defined by implementing a <em>functional interface</em>, which allows you to react to an event using a method reference:</span></p>
<pre class="p5">protected void init(VaadinRequest vaadinRequest) { <br/>   Button button = new Button("Click this");<br/>   button.addClickListener(<strong>this::buttonClicked</strong>);<br/>}<br/>...<br/>private void <strong>buttonClicked(Button.ClickEvent event)</strong> {<br/>    Notification.show("Thanks for clicking");<br/>}</pre>
<p class="p4"><span class="s1">You can also use a Lambda expression instead:</span></p>
<pre class="p5">button.addClickListener(<br/>        event -&gt; Notification.show("Thanks for clicking"));</pre>
<p class="p4"><span class="s1">And to make it more readable and testable, extract the listener logic to a new method, passing <span>only what's needed </span>as parameters (in this case, nothing is needed):</span></p>
<pre class="p5">protected void init(VaadinRequest vaadinRequest) { <br/>   ...<br/>   button.addClickListener(<strong><span class="s1">event -&gt; </span><span class="s3">buttonClicked()</span></strong>);<br/>}<br/>...<br/>private void <strong>buttonClicked()</strong> {<br/>    Notification.show("Thanks for clicking");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data binding</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s1">Data binding is typically done through the</span> <kbd><span class="s2">Binder</span></kbd> <span class="s1">class. This class allows you to connect the values in one or more fields to Java properties in a domain class. Suppose you have a</span> <kbd><span class="s2">User</span></kbd> <span class="s1">class (the domain class) with a</span> <kbd><span class="s2">password</span></kbd> <span class="s1">Java</span> <kbd><span class="s2">String</span></kbd> <span class="s1">as one of its properties. You can create a</span> <kbd><span class="s2">TextField</span></kbd> <span class="s1">and bind its value to the</span> <kbd><span class="s2">password</span></kbd> <span class="s1">property as follows:</span></p>
<pre class="p5">TextField <strong>textField</strong> = new TextField(“Email”);<br/>Binder <strong>binder</strong> = new Binder&lt;User&gt;()<br/>    .forField(<strong>textField</strong>)<br/>    .bind(User::<strong>getPassword</strong>, User::<strong>setPassword</strong>);</pre>
<p class="p4"><span class="s1">This is a powerful and type-safe way of implementing data binding. Imagine that you, at some point during development, decide to rename the</span> <kbd><span class="s2">password</span></kbd> <span class="s1">property in the</span> <kbd><span class="s2">User</span></kbd> <span class="s1">class to something like</span> <kbd><span class="s2">pin</span></kbd><span class="s1">. You can use the refactoring tools of your IDE to rename the property, and the IDE will rename the getters, setters, and any code calling these two methods. Of course, you'd have to change the caption</span> <kbd><span class="s2">"Email"</span></kbd> <span class="s1">to</span> <kbd><span class="s2">"PIN"</span></kbd> <span class="s1">yourself, but that would have also been the case with other binding mechanisms.</span></p>
<p class="p4"><span class="s1">Binders are also used to add validators and converters. These can be added using Lambda expressions or method references. For example, the following snippet of code checks that a</span> <kbd><span class="s2">String</span></kbd> <span class="s1">has exactly <kbd>4</kbd> characters and converts it into an integer:</span></p>
<pre class="p5">binder.<strong>withValidator</strong>(s -&gt; s.length() == 4, “Must be 4 characters")<br/>      .<strong>withConverter</strong>(Integer::parseInt, Object::toString);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resources and themes</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s1">The</span> <kbd><span class="s2">Resource</span></kbd> <span class="s1">interface and its implementations are the connections between Java code and resources such as images, downloadable files, or embedded content. You have probably used a</span> <kbd><span class="s2">StreamResource</span></kbd> <span class="s1">to dynamically generate a file that a user can download or a</span> <kbd><span class="s2">ThemeResource</span></kbd> <span class="s1">to display an image in your UI.</span></p>
<p class="p10"><span class="s1">A theme, in turn, is a set of static resources used to configure the appearance of a Vaadin application. By default, Vaadin applications use the Valo theme, a powerful set of styles that can be configured using variables.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Widget sets and add-ons</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s1">So far, you have been introduced to the most common parts of a Vaadin application. Vaadin is mostly about using an API with Java running on the server side. This Java code defines how the application looks and behaves, but a Vaadin application runs on a browser using HTML 5 and JavaScript. You don't have to write a line of HTML or JavaScript in order to implement a Vaadin application. How is this possible? How does a Java class define the HTML rendered in the browser?</span></p>
<p class="p4"><span class="s1">The key to understanding this is the <em>widget set</em>. A widget set is a JavaScript engine running on the client side, which contains all the code required to show components and communicate with the server side. A widget set is generated by compiling a set of Java classes into JavaScript using GWT. These Java classes are provided by the Vaadin Framework and you can add your own if you want to. If you are not using custom client-side components (your own, or those provided by a third-party Vaadin add-on), you can use the already compiled widget set which is included in the</span> <kbd><span class="s2">vaadin-client-compiled</span></kbd> <span class="s1">dependency.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This chapter served as an introduction to the architecture of a Vaadin application and its main players. We explained the most important parts of a Vaadin application and how they are connected. We also learned how to create a minimal Vaadin application from scratch by adding every single configuration required by ourselves.</span></p>
<p class="p1"><span class="s1">In the next chapter, you will learn how to implement main screens and custom application modules that are discovered and registered with a Vaadin application at runtime.</span></p>


            </article>

            
        </section>
    </body></html>