["```java\n  sealed trait Strategy \n  case class PnL(value: BigDecimal) extends AnyVal \n  case class BacktestPerformanceSummary(pnl: PnL) \n  case class Ticker(value: String) extends AnyVal \n\n  def backtest( \n    strategy: Strategy, \n    ticker: Ticker, \n    testInterval: Interval): BacktestPerformanceSummary = ??? \n\n```", "```java\ndef lastMonths(months: Int): Interval = \n    new Interval(new DateTime().minusMonths(months), new DateTime()) \nbacktest(Dave1, Ticker(\"AAPL\"), lastMonths(3)) \nbacktest(Dave1, Ticker(\"GOOG\"), lastMonths(3)) \nbacktest(Dave2, Ticker(\"AAPL\"), lastMonths(3)) \nbacktest(Dave2, Ticker(\"GOOG\"), lastMonths(3)) \n\n```", "```java\nscala> import scala.concurrent.Future \nimport scala.concurrent.Future \n\nscala> import scala.concurrent.ExecutionContext \nimport scala.concurrent.ExecutionContext \n\nscala> val context: ExecutionContext = scala.concurrent.ExecutionContext.global \ncontext: scala.concurrent.ExecutionContext = scala.concurrent.impl.ExecutionContextImpl@3fce8fd9 \n\nscala> def example(){ \n  println(\"Starting the example\") \n  Future{  \n    println(\"Starting the Future\") \n    Thread.sleep(1000)  // simulate computation \n    println(\"Done with the computation\")   \n }(context) \n\nprintln(\"Ending example\") \n} \n\n```", "```java\nscala> example() \nStarting the example \nEnding example \nStarting the future \n// a pause \nDone with the computation \n\n```", "```java\nscala> import scala.concurrent.ExecutionContext.Implicits.global \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nscala> import scala.concurrent.Future \nimport scala.concurrent.Future \n\nscala> Future(1).map(_ + 1).filter(_ % 2 == 0).foreach(println) \n\n2 \n\n```", "```java\ndef map[S](f: T => S)(implicit executor: ExecutionContext): Future[S] \n\n```", "```java\ntrait ExecutionContext { \n  def execute(runnable: Runnable): Unit \n  def reportFailure(cause: Throwable): Unit \n  def prepare(): ExecutionContext = this \n} \n\n```", "```java\ndef fromExecutorService(e: ExecutorService, reporter: Throwable => Unit): ExecutionContextExecutorService \ndef fromExecutorService(e: ExecutorService): ExecutionContextExecutorService \ndef fromExecutor(e: Executor, reporter: Throwable => Unit): ExecutionContextExecutor \ndef fromExecutor(e: Executor): ExecutionContextExecutor \n\n```", "```java\ntrait ExecutionContextExecutor extends ExecutionContext with java.util.concurrent.Executor \ntrait ExecutionContextExecutorService extends ExecutionContextExecutor with java.util.concurrent.ExecutorService \n\n```", "```java\ndef global: ExecutionContextExecutor = Implicits.global \n\n```", "```java\n  Future(1).map(i => { \n    println(Thread.currentThread().getName) \n    i + 1 \n  }).filter(i => { \n    println(Thread.currentThread().getName) \n    i % 2 == 0 \n  }).foreach(println) \n\n```", "```java\nForkJoinPool-1-worker-3 \nForkJoinPool-1-worker-5 \n2 \n\n```", "```java\nimplicit val ec = scala.concurrent.ExecutionContext.Implicits.global \nfor { \n      firstDaveAapl <- Future(backtest(Dave1, Ticker(\"AAPL\"), lastMonths(3))) \n      firstDaveGoog <- Future(backtest(Dave1, Ticker(\"GOOG\"), lastMonths(3))) \n      secondDaveAapl <- Future(backtest(Dave2, Ticker(\"AAPL\"), lastMonths(3))) \n      secondDaveGoog <- Future(backtest(Dave2, Ticker(\"GOOG\"), lastMonths(3))) \n    } yield (firstDaveAapl, firstDaveGoog, secondDaveAapl, secondDaveGoog) \n\n```", "```java\ndef apply[T](body: =>T)(executor: ExecutionContext): Future[T] \n\n```", "```java\n$ cat /proc/cpuinfo  | grep processor | wc -l \n8 \n\n```", "```java\nFuture(1).flatMap(f1 => Future(2).flatMap(f2 => Future(3).map(f3 => (f1, f2, f3)))) \n\n```", "```java\n    val firstDaveAaplF = Future(backtest(Dave1, Ticker(\"AAPL\"), \n      lastMonths(3))) \n    val firstDaveGoogF = Future(backtest(Dave1, Ticker(\"GOOG\"), \n      lastMonths(3))) \n    val secondDaveAaplF = Future(backtest(Dave2, Ticker(\"AAPL\"), \n      lastMonths(3))) \n    val secondDaveGoogF = Future(backtest(Dave2, Ticker(\"GOOG\"), \n      lastMonths(3))) \n    for { \n      firstDaveAapl <- firstDaveAaplF \n      firstDaveGoog <- firstDaveGoogF \n      secondDaveAapl <- secondDaveAaplF \n      secondDaveGoog <- secondDaveGoogF \n    } yield (firstDaveAapl, firstDaveGoog, secondDaveAapl, secondDaveGoog) \n\n```", "```java\nscala> import scala.concurrent.Future \nimport scala.concurrent.Future \n\nscala> import scala.concurrent.ExecutionContext.Implicits.global \nimport scala.concurrent.ExecutionContext.Implicits.global \n\nscala> val f = Future{ println(\"FOO\"); 40 + 2} \nFOO \nf: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@5575e0df \n\nscala> f.value \nres3: Option[scala.util.Try[Int]] = Some(Success(42)) \n\n```", "```java\ndef ready[T](awaitable: Awaitable[T], atMost: Duration): awaitable.type \ndef result[T](awaitable: Awaitable[T], atMost: Duration): T \n\n```", "```java\n    val summariesF = for { \n      firstDaveAapl <- Future(backtest(Dave1, Ticker(\"AAPL\"), lastMonths(3))) \n      firstDaveGoog <- Future(backtest(Dave1, Ticker(\"GOOG\"), lastMonths(3))) \n      secondDaveAapl <- Future(backtest(Dave2, Ticker(\"AAPL\"), lastMonths(3))) \n      secondDaveGoog <- Future(backtest(Dave2, Ticker(\"GOOG\"), lastMonths(3))) \n    } yield (firstDaveAapl, firstDaveGoog, secondDaveAapl, secondDaveGoog) \n\n    Await.result(summariesF, scala.concurrent.duration.Duration(1, java.util.concurrent.TimeUnit.SECONDS)) \n\n```", "```java\nobject SafeAwait { \n  def result[T]( \n    awaitable: Awaitable[T], \n    atMost: Duration): Option[T] =\n\n    Try(Await.result(awaitable, atMost)) match { \n      case Success(t) => Some(t) \n      case Failure(_: TimeoutException) => None \n      case Failure(e) => throw e \n    } \n}\n```", "```java\nFuture(\"not-an-integer\").map(_.toInt).map(i => { \n      println(\"Multiplying\") \n      i * 2 \n    }) \n\n```", "```java\ndef recover[U >: T](pf: PartialFunction[Throwable, U])(implicit executor: ExecutionContext): Future[U] \ndef recoverWith[U >: T](pf: PartialFunction[Throwable, Future[U]])(implicit executor: ExecutionContext): Future[U] \n\n```", "```java\nFuture(\"not-an-integer\").map(_.toInt).recover { \n  case _: NumberFormatException => -2 \n}.map(i => { \n  println(\"Multiplying\") \n  i * 2 \n}) \n\n```", "```java\nMultiplying \nMultiplication result = -4 \n\n```", "```java\n  def submitOrder( \n    ec: ExecutionContext, \n    sendToExchange: ValidatedOrder => Future[OrderSubmitted], \n    updatePositions: OrderSubmitted => Future[AccountPositions], \n    o: RawOrder): Unit = { \n    implicit val iec = ec \n\n    (for { \n      vo <- ValidatedOrder.fromRawOrder(o).fold(\n        Future.failed[ValidatedOrder](new Exception(\n        \"Order failed validation\")))(Future.successful) \n      os <- sendToExchange(vo) \n      ap <- updatePositions(os) \n    } yield (os, ap)).onComplete { \n      case Success((os, ap)) => // Marshal order submission info to caller \n      case Failure(e) =>  // Marshal appropriate error response to caller \n    } \n  } \n\n```", "```java\n   (for { \n      vo <- ValidatedOrder.fromRawOrder(o).fold( \n        Future.failed[ValidatedOrder]( \n        new Exception(\"Order failed validation\")))(Future.successful) \n      os <- { \n        val f = sendToExchange(vo) \n        f.onFailure({ case e => incrementExchangeErrorCount() }) \n        f \n      } \n      ap <- updatePositions(os) \n    } yield (os, ap)) \n\n```", "```java\nscalaz.\\/.right[Throwable, Int](1).map(_ * 2) \n\n```", "```java\n  @Benchmark \n  def manyTransforms(state: TransformFutureState): Int = { \n    import scala.concurrent.ExecutionContext.Implicits._ \n    val init = Future(0) \n    val res = (1 until state.operations).foldLeft(init)\n      ((f, _) => f.map(_ + 1)) \n    Await.result(res, Duration(\"5 minutes\")) \n  } \n\n  @Benchmark \n  def oneTransform(state: TransformFutureState): Int = { \n    import scala.concurrent.ExecutionContext.Implicits._ \n    val res = Future { \n      (1 until state.operations).foldLeft(0)((acc, _) => acc + 1) \n    } \n    Await.result(res, Duration(\"5 minutes\")) \n  } \n\n```", "```java\ndef findBuyOrders( \n client: ClientId, \n ticker: Ticker)(implicit ec: ExecutionContext): Future[List[Order]] = ??? \n\n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits.global \nfindBuyOrders(clientId, tickerFoo)   \n\n```", "```java\nval context = ExecutionContext.fromExecutorService( \n  Executors.newFixedThreadPool(20) \n) \nfindBuyOrders(clientId, tickerFoo)(context)   \n\n```", "```java\ndef findBuyOrders( \n client: ClientId, \n ticker: Ticker)(ec: ExecutionContext): Future[List[Order]] = Future { \n Thread.sleep(100) \n Order.staticList.filter(o => o.clientId == client  \n   && o.ticker == ticker) \n}(ec) \n\n```", "```java\nobject DatabaseAccess { \n\n sealed trait BlockingExecutionContextTag \n\n type BlockingExecutionContext = ExecutionContext @@ BlockingExecutionContextTag \n\n object BlockingExecutionContext { \n   def fromContext(ec: ExecutionContext): BlockingExecutionContext = \n     Tag[ExecutionContext, BlockingExecutionContextTag](ec) \n\n  def withSize(size: Int): BlockingExecutionContext =  \n fromContext(ExecutionContext.fromExecutor(Executors.newFixedThreadPool(size))) \n} \n} \n\nclass DatabaseAccess(ec: BlockingExecutionContext) { \n  // Implementation elided \n} \n\n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits.global \ndef findBuyOrders( \n client: ClientId, \n ticket: Ticker): Future[List[Order]] = Future { \n   scala.concurrent.blocking{ \n     Thread.sleep(100) \n     Order.staticList.filter(o => o.clientId == client && o.ticker == ticker) \n   } \n} \n\n```", "```java\nscala> val p = Promise[Int]  // this promise will provide an Int \np: scala.concurrent.Promise[Int] = scala.concurrent.impl.Promise$DefaultPromise@d343a81 \n\nscala> p.future.value \nres3: Option[scala.util.Try[Int]] = None \n// The future associated to this Promise is not yet completed \n\nscala> p.success(42) \nres4: p.type = scala.concurrent.impl.Promise$DefaultPromise@d343a81 \n\nscala> p.future.value \nres5: Option[scala.util.Try[Int]] = Some(Success(42))  \n\n```", "```java\nobject DatabaseClient { \n  def findQuote(instant: Instant, ticker: Ticker,  \n    f: (Quote) => Unit): Unit = ??? \n\n  def findAllQuotes(from: Instant, to: Instant, ticker: Ticker,\n    f: (List[Quote]) => Unit, h: Exception => Unit): Unit = ??? \n} \n\n```", "```java\nobject DatabaseAdapter { \n\n  def findQuote(instant: Instant, ticker: Ticker): Future[Quote] = { \n    val result = Promise[Quote] \n\n    DatabaseClient.findQuote(instant, ticker, { \n      q: Quote => \n        result.success(q) \n    }) \n\n    result.future \n  } \n\n  def findAllQuotes(from: Instant, to: Instant, ticker: Ticker): \n  Future[List[Quote]] = { \n    Val result = Promise[List[Quote]] \n    DatabaseClient.findQuote(from, to, ticker, {\n      quotes: List[Quote] => result.success(quotes)\n    }, {\n      ex: Exception => result.failure(ex)\n    } \n  } \n\n  result.future \n} \n\n```", "```java\ndef run[A](f: => Future[A], timeout: Duration): Future[A] = { \n  val res = Promise[A] \n\n  Future { \n    Thread.sleep(timeout.getMillis) \n     res.tryFailure(new Exception(\"Timed out\") \n  }  \n\n  f onComplete { \n  case r => res.tryCompleteWith(f) \n  } \n\n  res.future \n} \n\n```", "```java\ndef sum(x: Int, y: Int): Int = x + y \n\n```", "```java\nsum(sum(2, 3), 4)  \n\n```", "```java\nsum(5, 4) \n\n```", "```java\nclass SumService(updateDatabase: () => Unit) { \n  def sum(x: Int, y: Int): Int = { \n    updateDatabase() \n    x + y \n  } \n} \n\n```", "```java\nscala> val t = Task { \n     |   println(\"Starting task\") \n     |   40 + 2 \n     | } \nt: scalaz.concurrent.Task[Int] = scalaz.concurrent.Task@300555a9 \n\n```", "```java\nscala> t.unsafePerformSync \nStarting task \nres0: Int = 42 \n\n```", "```java\nscala> val es = Executors.newFixedThreadPool(4) \nes: java.util.concurrent.ExecutorService = java.util.concurrent.ThreadPoolExecutor@4c50cd8c[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0] \n\nscala> val t = Task { \n println(\"Starting task on thread \" + Thread.currentThread.getName) \n 40 + 2 \n}(es) \nt: scalaz.concurrent.Task[Int] = scalaz.concurrent.Task@497db010 \n\nscala> println(\"Calling run from \" + Thread.currentThread.getName) \nCalling run from run-main-1 \n\nscala> t.unsafePerformSync \nStarting task on thread pool-8-thread-2 \nres2: Int = 42 \n\n```", "```java\nscala> val t = Task { \n     |   println(\"Starting task\") \n     |   40 + 2 \n     | } \nt: scalaz.concurrent.Task[Int] = scalaz.concurrent.Task@300555a9 \n\nscala> t.unsafePerformSync \nStarting task \nres0: Int = 42 \n\nscala> t.unsafePerformSync \nStarting task \nres1: Int = 42 \n\n```", "```java\ndef createAndRunTask(): Unit = { \n val t = Task { \n   println(\"Computing the answer...\") \n   Thread.sleep(2000) \n   40 + 2 \n } \n\n t.unsafePerformAsync { \n   case \\/-(answer) => println(\"The answer is \" + answer) \n   case -\\/(ex) => println(\"Failed to compute the answer: \" + ex) \n } \n\n println(\"Waiting for the answer\") \n} \n\n```", "```java\nscala> TaskExample.createAndRunTask() \nWaiting for the answer \n\nscala> Computing the answer... \nThe answer is 42 \n\n```", "```java\nobject CallbackAPI { \n  def doCoolThings[A](a: => A, f: (Throwable \\/ A) => Unit): Unit = ??? \n} \n\ndef doCoolThingsToTask[A](a: => A): Task[A] = \n Task.async { f => \n   CallbackAPI.doCoolThings[A](a, res => f(res)) \n } \n\n```", "```java\n> val t = doCoolThingsToTask(40+2) \n> t.map(res => res / 2).unsafePerformSync \nres2: Int = 21 \n\n```", "```java\ndef futureToTask[A](future: Future[A])(implicit ec: ExecutionContext): Task[A] = \n Task.async { f => \n   future.onComplete { \n     case Success(res) => f(\\/-(res)) \n     case Failure(ex) => f(-\\/(ex)) \n   } \n } \n\n```", "```java\ndef taskToFuture[A](t: Task[A]): Future[A] = { \n  val p = Promise[A]() \n  t.unsafePerformAsync { \n    case \\/-(a) => p.success(a) \n    case -\\/(ex) => p.failure(ex) \n  } \n  p.future \n}\n```", "```java\nclass Task[+A](val get: Future[Throwable \\/ A]) \n\n```", "```java\n@Benchmark \ndef mapWithFuture(state: TaskFutureState): Int = { \n  implicit val ec = state.context \n  val init = Future(0) \n  val res = (1 until state.operations).foldLeft(init) \n    ((f, _) => f.map(_ + 1)) \n  Await.result(res, Duration(\"5 minutes\")) \n} \n\n@Benchmark \ndef mapWithTask(state: TaskFutureState): Int = { \n  val init = Task(0)(state.es) \n  val res = (1 until state.operations).foldLeft(init)\n    ((t, _) => t.map(_ + 1)) \n  res.unsafePerformSync \n} \n\n```", "```java\n  case class PnL(value: BigDecimal) extends AnyVal \n  object PnL { \n    def merge(x: PnL, y: PnL): PnL = PnL(x.value + y.value) \n    val zero: PnL = PnL(0) \n  } \n  case class BacktestPerformanceSummary(pnl: PnL) \n  case class DecisionDelayMillis(value: Long) extends AnyVal \n\n```", "```java\n  def originalBacktest( \n    testDays: List[MonthDay], \n    decisionDelay: DecisionDelayMillis): BacktestPerformanceSummary = \n    { \n    val pnls = for { \n      d <- testDays \n      _ = Thread.sleep(decisionDelay.value) \n    } yield PnL(10) \n    BacktestPerformanceSummary(pnls.reduceOption(PnL.merge).getOrElse(\n      PnL.zero)) \n  } \n\n```", "```java\n  def backtestWithoutConcurrency( \n    testDays: List[MonthDay], \n    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = \n    { \n    val ts = for (d <- testDays) yield Task.delay { \n      Thread.sleep(decisionDelay.value) \n      PnL(10) \n    } \n    Task.gatherUnordered(ts).map(pnls => BacktestPerformanceSummary( \n      pnls.reduceOption(PnL.merge).getOrElse(PnL.zero))) \n  } \n\n```", "```java\ndef delay[A](a: => A): Task[A] \n\n```", "```java\nList[Task[A]] => Task[List[A]] \n\n```", "```java\ndef gatherUnordered[A](tasks: Seq[Task[A]], exceptionCancels: Boolean = false): Task[List[A]] \n\n```", "```java\n  def backtestWithAllForked( \n    testDays: List[MonthDay], \n    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = \n    { \n    val ts = for (d <- testDays) yield Task.fork { \n      Thread.sleep(decisionDelay.value) \n      Task.now(PnL(10)) \n    } \n    Task.gatherUnordered(ts).map(pnls => BacktestPerformanceSummary( \n      pnls.reduceOption(PnL.merge).getOrElse(PnL.zero))) \n  } \n\n```", "```java\ndef fork[A](a: => Task[A])(implicit pool: ExecutorService = Strategy.DefaultExecutorService): Task[A] \n\n```", "```java\n  def backtestWithBatchedForking( \n    testDays: List[MonthDay], \n    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = \n    { \n    val ts = for (d <- testDays) yield Task.delay { \n      Thread.sleep(decisionDelay.value) \n      PnL(10) \n    } \n    Task.gatherUnordered(ts.sliding(30, 30).toList.map(xs => \n      Task.fork(Task.gatherUnordered(xs)))).map(pnls => \n      BacktestPerformanceSummary( \n        pnls.flatten.reduceOption(PnL.merge).getOrElse(PnL.zero))) \n  } \n\n```", "```java\n  @State(Scope.Benchmark) \n  class BenchmarkState { \n    @Param(Array(\"1\", \"10\")) \n    var decisionDelayMillis: Long = 0 \n    @Param(Array(\"1\", \"12\", \"24\" )) \n    var backtestIntervalMonths: Int = 0 \n\n    var decisionDelay: DecisionDelayMillis = DecisionDelayMillis(-1) \n    var backtestDays: List[MonthDay] = Nil \n\n    @Setup \n    def setup(): Unit = { \n      decisionDelay = DecisionDelayMillis(decisionDelayMillis) \n      backtestDays = daysWithin(trailingMonths(backtestIntervalMonths)) \n    } \n  } \n\n```", "```java\n@Benchmark \ndef withBatchedForking(state: BenchmarkState): BacktestPerformanceSummary = \n  Backtest.backtestWithBatchedForking(state.backtestDays, \n  state.decisionDelay) \n    .unsafePerformSync \n\n```"]