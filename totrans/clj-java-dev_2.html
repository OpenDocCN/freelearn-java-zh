<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Namespaces, Packages, and Tests" id="KVCC1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Namespaces, Packages, and Tests</h1></div></div></div><p class="calibre7">We now have a working installation of Clojure and IntelliJ.</p><p class="calibre7">As a Java developer, you are used to working with classes as the minimal unit of organization. Clojure has a very different sense and gives you different tools to organize your code.</p><p class="calibre7">For starters, you should keep in mind that code and data are separate; you don't have a minimal unit with attributes and functions that work over those attributes. Your functions can work on any data structure that you wish, as long as you follow the rules of how the function works.</p><p class="calibre7">In this chapter, we will start writing some simple functions to illustrate how separation of functions and data works and we will have a look at the tools Clojure gives us to make the separation.</p><p class="calibre7">In this chapter, we will cover the following topic:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How namespaces work compared to the classpath and Java packages</li><li class="listitem">Unit tests</li><li class="listitem">More Clojure examples and syntax</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Namespaces, Packages, and Tests" id="KVCC1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Namespaces in Clojure"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec16" class="calibre1"/>Namespaces in Clojure</h1></div></div></div><p class="calibre7">Clojure <a id="id42" class="calibre1"/>namespaces might be familiar to you, as a Java developer, and for a very good reason, they have a very deep relationship with Java's packages and the classpath.</p><p class="calibre7">First of all, let's review what we already know from Java.</p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Namespaces, Packages, and Tests" id="KVCC1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Namespaces in Clojure">
<div class="book" title="Packages in Clojure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec17" class="calibre1"/>Packages in Clojure</h2></div></div></div><p class="calibre7">The Java<a id="id43" class="calibre1"/> code is organized in packages, a package in Java is a namespace that allows you to group a set of similar classes and interfaces.</p><p class="calibre7">You can think of a package as something very similar to a folder in your computer.</p><p class="calibre7">The following are some common packages that you use a lot when programming in Java:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">java.lang</code>: Everything<a id="id44" class="calibre1"/> that's native to Java, including basic types (integer, long, byte, boolean, character, string, number, short, float, void, and class), the basic threading primitives (runnable, thread), the basic primitives for exceptions (throwable, error, exception), the basic exceptions and errors (<code class="email">NoSuchMethodError</code>, <code class="email">OutOfMemoryError</code>, <code class="email">StackOverflowError</code>, and so on) and runtime access classes like runtime and system.</li><li class="listitem"><code class="email">java.io</code>: This<a id="id45" class="calibre1"/> package includes the primitives for input and output, such as console, file, readers, input streams, and writers.</li><li class="listitem"><code class="email">java.util</code>: This<a id="id46" class="calibre1"/> is one of the most heavily used packages besides <code class="email">java.lang</code>. This includes the classic data structures (map, set, list) along with the most common implementations of such data structures. This package also includes utilities like properties tools, scanner for reading from various input resources, <code class="email">ServiceLoader</code> to load custom services from the <code class="email">classloader</code>, UUID generator, timers, and so on.</li><li class="listitem"><code class="email">java.util.logging</code>: The <a id="id47" class="calibre1"/>logging utilities, you normally use them to give you different levels of alert, from a debug to serious conditions.</li><li class="listitem"><code class="email">java.text</code>: These <a id="id48" class="calibre1"/>are utilities to manage text, dates, and numbers in a language independent way.</li><li class="listitem"><code class="email">javax.servlet</code>: This<a id="id49" class="calibre1"/> includes the primitives to create web apps and deployment in standard web containers.</li></ul></div><p class="calibre7">Each one of these packages groups several related functionalities, the <code class="email">java.lang</code> package is particularly important, since it has every Java core type, such as string, long, and integer. Everything inside the <code class="email">java.lang</code> package is available automatically everywhere.</p><p class="calibre7">The <code class="email">java.lang</code> package provides a bit more than just code organization, it also provides access security. If you remember about Java, there are three security access levels:</p><div class="book"><ul class="itemizedlist"><li class="listitem">private</li><li class="listitem">public</li><li class="listitem">protected</li></ul></div><p class="calibre7">In the case of packages, we are concerned with the protected level of access. The classes in the same package allow every other class in the same package to access its protected attributes and methods.</p><p class="calibre7">There are also ways to analyze a package in runtime but they are involved and allow for very little to be done.</p><p class="calibre7">Packages are implemented at the top of Java's classpath and the classloader.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The classpath and the classloader"><div class="book" id="LTSU2-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>The classpath and the classloader</h1></div></div></div><p class="calibre7">Java was <a id="id50" class="calibre1"/>designed to be modular and for that it needs some way to load your code easily. The answer to this was the classloader, the classloader allows you to read resources from every entry of the classpath; you can look at resources in the classpath as a hierarchical structure similar to the file system.</p><p class="calibre7">The classloader <a id="id51" class="calibre1"/>is just a list of entries; each entry can be a directory in the filesystem or a JAR file. At this point, you should also know that JAR files are just zip files.</p><p class="calibre7">The classloader will treat each entry as a directory (JAR files are just zipped directories) and it will look for files in each directory.</p><p class="calibre7">There are a lot of concepts here to remember, let's try to summarize them:</p><div class="book"><ul class="itemizedlist"><li class="listitem">JAR files are ZIP files; they might contain several classes, properties, files, and so on.</li><li class="listitem">The classpath is a list of entries; each entry is a JAR file or a system directory.</li><li class="listitem">The classloader looks for resources in each entry of the classpath, so you can think of classpath resources as a combination of all the directories in the classpath (repeated resources are not overwritten)</li></ul></div><p class="calibre7">If you are not already familiar with how classloaders look for resources in classpath entries, this is the general process; let's imagine that you want to load a class: <code class="email">test.Test</code>, what happens next?</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">You tell the JVM that you want to load <code class="email">test.Test</code>.</li><li class="listitem" value="2">The JVM knows to look for the <code class="email">test</code>/<code class="email">Test.class</code> file.</li><li class="listitem" value="3">It starts looking for it in each entry of the classpath.</li><li class="listitem" value="4">If the resource is a ZIP file, it "unzips" the directory.</li><li class="listitem" value="5">It looks for the resource in the directory which represents the entry.</li></ol><div class="calibre22"/></div><p class="calibre7">If you were to see the default classpath resources, you will probably see something, such as:</p><div class="informalexample"><pre class="programlisting">java:
    lang:
        String.class
        ….
    io:
        IOException.class
        …
    util:
        List.class</pre></div><p class="calibre7">It is important<a id="id52" class="calibre1"/> to note that each entry in the classpath doesn't just store class files, it can actually store any type of resource, It is a commonplace to store configuration files, such as <code class="email">.properties</code> or <code class="email">.xml</code>.</p><p class="calibre7">Nothing forbids <a id="id53" class="calibre1"/>you from storing anything else in the classpath resources, such as images, mp3 or even code! You can read and access anything from the classpath's resource like you can from the filesystem at runtime. The one thing that you can't do is modify the classpath's resource contents (at least not without some esoteric magic).</p></div>

<div class="book" title="The classpath and the classloader">
<div class="book" title="Back to Clojure namespaces"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec18" class="calibre1"/>Back to Clojure namespaces</h2></div></div></div><p class="calibre7">Now that<a id="id54" class="calibre1"/> we have had our little review of how packages and the classpaths work in Java, it's time to go back to Clojure. You should understand that Clojure attempts to make the hosting platform transparent; this means a couple of very important things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Anything that you can do with the classpath from Java, you can also do with Clojure (you can read configuration files, images, etc).</li><li class="listitem">Namespaces use the classpath just as Java does with packages, which makes them easy to understand. Nevertheless, don't underestimate them, Clojure namespace declarations can be more involved.</li></ul></div><p class="calibre7">Let's get practical and play a little with namespaces.</p><div class="book" title="Playing with namespaces"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec01" class="calibre1"/>Playing with namespaces</h3></div></div></div><p class="calibre7">Lets <a id="id55" class="calibre1"/>create a new Playground, in order to create it use the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre8">lein new app ns-playground</strong></span>
</pre></div><p class="calibre7">You can open this project with IntelliJ, as we did in <a class="calibre1" title="Chapter 1. Getting Started with Clojure" href="part0014_split_000.html#DB7S1-f3eee9b8c89a4c399520b72f8d890ddc">Chapter 1</a>, <span class="strong"><em class="calibre9">Getting Started with Clojure</em></span>.</p><p class="calibre7">Let's look in detail at what was created for us:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Playing with namespaces" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This project structure looks similar to Java projects, we have:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">resources</code>: These are the non-source files that get added to the classpath</li><li class="listitem"><code class="email">src</code>: Our source code</li><li class="listitem"><code class="email">test</code>: Our testing code</li></ul></div><p class="calibre7">The code <a id="id56" class="calibre1"/>inside <code class="email">src</code> and <code class="email">test</code> is already structured into namespaces: by having a quick look, we could say that the name of the namespace is <code class="email">ns_playground</code>. Let's check the source code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core
  (:gen-class))

(defn -main
"I don't do a whole lot ... yet."
  [&amp; args]
  (println "Hello, World!"))
;; Code for src/ns_playground/core.clj</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre7">
<code class="email">:gen-class</code> was added here in order to create a Java class and allow the Java interpreter to start a static main method. It is not needed if you don't intend to create a standalone program.</p></div><p class="calibre7">We can see <a id="id57" class="calibre1"/>that the (<code class="email">ns ns-playground.core</code>) form has been used at the top, as you might have guessed, this is how we declare a namespace in Clojure.</p><p class="calibre7">If you are observant, you will notice something odd; the namespace has a dash instead of an underscore like the folder.</p><p class="calibre7">There are some reasons that lead to this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Clojure like most lisp variable names can have dashes in it (it is actually the preferred style to name the variables, as opposed to camel case in Java).</li><li class="listitem">Every namespace in Clojure is represented as a package containing several Java classes. The namespace is used as a name of the Java package and as you know, the dash is not acceptable in class or package names; so every filename and folder name must have low dashes.</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre7">Due to the nature of Lisp, you can use dashes in variable names (they will get converted to underscores at compile time). In fact, this is the recommended way to name your variables. In Clojure, (and most Lisps) <code class="email">some-variable-name</code> is a more idiomatic style than <code class="email">someVariableName</code>.</p></div></div></div></div>

<div class="book" title="The classpath and the classloader">
<div class="book" title="Creating a new namespace"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec19" class="calibre1"/>Creating a new namespace</h2></div></div></div><p class="calibre7">Let's create<a id="id58" class="calibre1"/> a new namespace; in Cursive Clojure it is easy to do so, just right-click on the <code class="email">ns_playground</code> package and go to <span class="strong"><strong class="calibre8">New</strong></span> | <span class="strong"><strong class="calibre8">Clojure Namespace</strong></span>, it asks for a name and we can call it <code class="email">hello</code>.</p><p class="calibre7">This creates a <code class="email">hello.clj</code> file with the following contents:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello)</pre></div><p class="calibre7">As you can see, namespace creation is quite easy; you can do it by hand with two simple steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new file; it doesn't have to follow the package naming specification, but it helps to maintain your code order and it is a de facto practice.</li><li class="listitem" value="2">Add your namespace declaration.</li></ol><div class="calibre22"/></div><p class="calibre7">That's it! It is true, even though a namespace definition can become quite complex, as it is the place <a id="id59" class="calibre1"/>where you define the Java packages that you wish to import, namespaces or functions from those namespaces that you intend to use. But you will normally just use a subset of those capabilities.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre7">Keep in mind that a namespace in Clojure is normally represented by a single file.</p></div><p class="calibre7">For your initial namespaces, I will advice you to have two of those capabilities in mind:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">:import</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Allows you to import the Java classes from a package that you wish to use</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">:require</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Allows you to bring in whatever Clojure namespace that you wish to use</p>
</td></tr></tbody></table></div><p class="calibre7">The syntax of both <code class="email">require</code> and the <code class="email">import</code> is simple, let's look at a couple of examples before we actually use it.</p><p class="calibre7">Let's start with the <code class="email">import</code> option:</p><div class="informalexample"><pre class="programlisting">(:import java.util.List)</pre></div><p class="calibre7">You'll notice that this is similar to what you can do in Java, we are importing the <code class="email">List</code> interface here.</p><p class="calibre7">The good thing with Clojure is that it allows you to do some more specific things. Let's check how to import two classes at once:</p><div class="informalexample"><pre class="programlisting">(:import [java.util ArrayList HashMap])</pre></div><p class="calibre7">You can extend this to the number of classes you want to use.</p><p class="calibre7">The <code class="email">require</code> option uses a similar syntax and then builds some more on it. Let's check requiring a single function from a namespace:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :refer [a-function another-function]])</pre></div><p class="calibre7">As you can see, it is familiar and the interesting part is when you start importing everything:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :refer [:all]])</pre></div><p class="calibre7">You can also use a custom name for everything inside your package:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :as s])

;; And then use everything in the package like this:

(s/a-function 5)</pre></div><p class="calibre7">Or you could<a id="id60" class="calibre1"/> even combine different keywords:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :as s :refer [a-function]])</pre></div><p class="calibre7">Let's try a bit of what we just learned, using the following code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello
  (:import [java.util Date]))

(def addition +)

(defn current-date []
"Returns the current date"
  (new Date))

(defn &lt;3 [love &amp; loved-ones]
"Creates a sequence of all the {loved-ones} {loved} loves"
  (for [loved-one loved-ones]
    (str love " love " loved-one)))

(defn sum-something [something &amp; nums]
"Adds something to all the remaining parameters"
  (apply addition something nums))

(def sum-one (partial sum-something 1))</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre7">You must have noticed the <code class="email">&amp;</code> operator in the arguments of the <code class="email">&lt;3</code> and <code class="email">sum-something</code> functions; this allows those functions to receive any number of arguments and we can call them, as shown: (<code class="email">sum-something 1 2 3 4 5 6 7 8</code>) or (<code class="email">sum-something</code>) They are called <a id="id61" class="calibre1"/>
<span class="strong"><strong class="calibre8">variadic</strong></span> functions. In Java you will call this feature<a id="id62" class="calibre1"/> <span class="strong"><strong class="calibre8">varargs</strong></span>.</p></div><p class="calibre7">Everything looks great, but we haven't yet seen how to require and use these functions from some other package. Let's write a test to see how this will be done.</p></div></div>

<div class="book" title="The classpath and the classloader">
<div class="book" title="Working with namespaces on the REPL"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec20" class="calibre1"/>Working with namespaces on the REPL</h2></div></div></div><p class="calibre7">A <a id="id63" class="calibre1"/>great way of playing with namespaces is by using the REPL and we'll also get the benefit of getting to know it better.</p><p class="calibre7">Since we are going to play with namespace, we need to know of a few functions that will help us move between namespaces and require other namespaces. The functions are listed as follows:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Function</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Sample usage</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">in-ns</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Sets <code class="literal">*ns*</code> to the namespace named by the symbol, creating it if needed.</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">(<code class="literal">in-ns 'ns-playground.core</code>)</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">require</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Loads <code class="literal">libs</code>, skipping any that are already loaded.</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">(<code class="literal">require '[clojure.java.io :as io]</code>)</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">import</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">For each name in <code class="literal">class-name-symbols</code>, adds a mapping from name to the class named by <code class="literal">package.name</code> to the current namespace.</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">(<code class="literal">import java.util.Date</code>)</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">refer</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">refers to all public <code class="literal">vars</code> of <code class="literal">ns</code>, subject to filters.</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">(<code class="literal">refer 'clojure.string :only '[capitalize trim]</code>)</p>
</td></tr></tbody></table></div><p class="calibre7">Let's go into the <a id="id64" class="calibre1"/>REPL window of our IntelliJ. We can check what namespace we are in with the <code class="email">*ns*</code> instruction. Let's try now:</p><div class="informalexample"><pre class="programlisting">*ns*
=&gt; #&lt;Namespace ns-playground.core&gt;</pre></div><p class="calibre7">Imagine that we need to execute a code and test the code from within the <code class="email">ns-playground.hello</code> namespace, we can do that with the <code class="email">in-ns</code> function:</p><div class="informalexample"><pre class="programlisting">(in-ns 'ns-playground.hello)
=&gt; #&lt;Namespace ns-playground.hello&gt;</pre></div><p class="calibre7">We want to know what <code class="email">str</code> does, it seems to receive three strings:</p><div class="informalexample"><pre class="programlisting">(str "Hello""""world")
=&gt;"Hello world"</pre></div><p class="calibre7">Let's try the <code class="email">for</code> form now:</p><div class="informalexample"><pre class="programlisting">(for [el ["element1""element2""element3"]] el)
=&gt; ("element1""element2""element3")

(for [el ["element1""element2""element3"]]
  (str "Hello " el))
=&gt; ("Hello element1""Hello element2""Hello element3")</pre></div><p class="calibre7">The <code class="email">for</code> macro takes <a id="id65" class="calibre1"/>a collection of items and returns a new lazy sequence applying the body of the <code class="email">for</code> to each element.</p><p class="calibre7">Knowing this, understanding the <code class="email">&lt;3</code> function is easy, let's try it:</p><div class="informalexample"><pre class="programlisting">(&lt;3 "They""tea")
=&gt; ("They love tea")

(clojure.repl/doc &lt;3)
ns-playground.hello/&lt;3
([&amp; loved-ones])
  Creates a sequence of all the {loved-ones} {loved} loves</pre></div><p class="calibre7">We've used the REPL to test some simple functions, but let's now try to test something else like reading a properties file from the classpath.</p><p class="calibre7">We can add a <code class="email">test.properties</code> file to the resources folder with the following contents:</p><div class="informalexample"><pre class="programlisting">user=user
test=password
sample=5</pre></div><p class="calibre7">Remember to restart the REPL, as the changes to the contents that some piece of the classpath points to are not visible to a running REPL.</p><p class="calibre7">Let's try reading our properties file as an input stream, we can use the <code class="email">clojure.java.io</code> namespace to do it, and we can check it as shown:</p><div class="informalexample"><pre class="programlisting">(require '[clojure.java.io :as io])
(io/resource "test.properties")
=&gt; #&lt;URL file:/Users/iamedu/Clojure4Java/ns-playground/resources/test.properties&gt;
(io/input-stream (io/resource "test.properties"))
=&gt; #&lt;BufferedInputStream java.io.BufferedInputStream@2f584e71&gt;
;; Let's now load it into a properties object
(import [java.util Properties])
=&gt; java.util.Properties
(def props (Properties.)) ;; Don't worry about the weird syntax, we will look it soon.
=&gt; #'ns-playground.core/props
(.load props (io/input-stream (io/resource "test.properties")))
props
=&gt; {"user""user", "sample""5", "test""password"}</pre></div><p class="calibre7">We can now define our function for reading properties, we can input this into the REPL:</p><div class="informalexample"><pre class="programlisting">(defn read-properties [path]
  (let [resource (io/resource path)
        is (io/input-stream resource)
        props (Properties.)]
    (.load props is)
    (.close is)
    props))
=&gt; #'ns-playground.core/read-properties
(read-properties "test.properties")
=&gt; {"user""user", "sample""5", "test""password"}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre7">The <code class="email">let</code> form lets us create local 'variables', instead of using the (<code class="email">io/resource path</code>) directly in the code. We can create a reference once and use it through the code. It allows us to use simpler code and to have a single reference to an object.</p></div><p class="calibre7">In the end, we <a id="id66" class="calibre1"/>can redefine the <code class="email">hello</code> namespace to include everything we've checked, such as this:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello
  (:require [clojure.java.io :as io])
  (:import [java.util Date Properties]))

(def addition +)

(defn current-date []
"Returns the current date"
  (new Date))

(defn &lt;3 [love &amp; loved-ones]
"Creates a sequence of all the {loved-ones} {loved} loves"
  (for [loved-one loved-ones]
    (str love " love " loved-one)))

(defn sum-something [something &amp; nums]
"Adds something to all the remaining parameters"
  (apply addition something nums))

(defn read-properties [path]
  (let [resource (io/resource path)
        is (io/input-stream resource)
        props (Properties.)]
    (.load props is)
    props))


(def sum-one (partial sum-something 1))</pre></div><p class="calibre7">Remember to<a id="id67" class="calibre1"/> include the <code class="email">Properties</code> class in the <code class="email">import</code> and to define the <code class="email">:require</code> keyword for <code class="email">clojure.java.io</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing in Clojure"><div class="book" id="MSDG2-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Testing in Clojure</h1></div></div></div><p class="calibre7">Clojure <a id="id68" class="calibre1"/>already<a id="id69" class="calibre1"/> comes with a unit testing support built-in, as a matter of fact Leiningen has already created a test for us; let's take a look at it right now.</p><p class="calibre7">Open the <code class="email">test/ns_playground/core_test.clj</code> file, you should be able to see this code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core-test
  (:require [clojure.test :refer :all]
            [ns-playground.core :refer :all]))
(deftest a-test
  (testing "FIXME, I fail."
(is (= 0 1))))</pre></div><p class="calibre7">Again, as you can see, we are using <code class="email">:require</code> to include functions from the <code class="email">clojure.test</code> and the <code class="email">ns-playground.core</code> packages.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre7">Remember, the <code class="email">:refer :all</code> works similar to how <code class="email">char import static clojure.test.*</code> will work in Java.</p></div></div>

<div class="book" title="Testing in Clojure">
<div class="book" title="Testing from the command line"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec21" class="calibre1"/>Testing from the command line</h2></div></div></div><p class="calibre7">Let's first <a id="id70" class="calibre1"/>learn how to run these tests. From the command line, you can run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre8">lein test</strong></span>
</pre></div><p class="calibre7">You should get the following output:</p><div class="informalexample"><pre class="programlisting">lein test ns-playground.core-test

lein test :only ns-playground.core-test/a-test

FAIL in (a-test) (core_test.clj:7)
FIXME, I fail.
expected: (= 0 1)
  actual: (not (= 0 1))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.</pre></div><p class="calibre7">We see that<a id="id71" class="calibre1"/> there is one test failing, we will go back to this in a bit; for now, let's see how to test in IntelliJ.</p></div></div>

<div class="book" title="Testing in Clojure">
<div class="book" title="Testing in IntelliJ"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec22" class="calibre1"/>Testing in IntelliJ</h2></div></div></div><p class="calibre7">First of all, we <a id="id72" class="calibre1"/>need a new REPL configuration. You can do it as you learned in the previous chapter. You just need to follow the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Right click on the <code class="email">project.clj</code> file and select <span class="strong"><strong class="calibre8">Create REPL for ns-playground,</strong></span> as shown in the following screenshot:<div class="mediaobject"><img src="../images/00006.jpeg" alt="Testing in IntelliJ" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="2">Then click on <span class="strong"><strong class="calibre8">OK</strong></span> in the next dialog.</li><li class="listitem" value="3">After <a id="id73" class="calibre1"/>that, you should run the REPL again by right clicking the <code class="email">project.clj</code> file and selecting <span class="strong"><strong class="calibre8">Run REPL for ns-playground</strong></span>.</li><li class="listitem" value="4">After that you can run any tests, just open your test file and go to <span class="strong"><strong class="calibre8">Tools</strong></span> | <span class="strong"><strong class="calibre8">Run Tests</strong></span> in the current NS in REPL. You should see something similar to the following screenshot:<div class="mediaobject"><img src="../images/00007.jpeg" alt="Testing in IntelliJ" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="5">As you<a id="id74" class="calibre1"/> can see, it signals that your test is currently failing. Let's fix it and run our test again. Change the <code class="email">(is (= 0 1))</code> line to <code class="email">(is (= 1 1))</code>.</li><li class="listitem" value="6">Now, let's try some real tests for our previously defined functions; don't worry if you can't understand all the code for now, you are not supposed to:<div class="informalexample"><pre class="programlisting">(ns ns-playground.hello-test
  (:import [java.util Date])
  (:require [clojure.test :refer :all]
            [ns-playground.hello :as hello :refer [&lt;3]]
            [ns-playground.core :refer :all]))

(defn- lazy-contains? [col element]
  (not (empty? (filter #(= element %) col))))

(deftest a-test
  (testing "DONT FIXME, I don't fail."
    (is (= 42 42))))

(deftest current-date-is-date
  (testing "Test that the current date is a date"
    (is (instance? Date (hello/current-date)))))

(deftest check-loving-collection
  (testing "Check that I love clojure and you"
    (let [loving-seq (&lt;3 "I""Clojure""you""doggies""chocolate")]
      (is (not (lazy-contains? loving-seq "I love Vogons")))
      (is (lazy-contains? loving-seq "I love Clojure"))
      (is (lazy-contains? loving-seq "I love doggies"))
      (is (lazy-contains? loving-seq "I love chocolate"))
      (is (lazy-contains? loving-seq "I love you")))))</pre></div></li></ol><div class="calibre22"/></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre7">We can't use the Clojure contents function here because it has a different function. It looks for keys in a map.</p></div><p class="calibre7">Run the <a id="id75" class="calibre1"/>tests and you'll see that everything passes correctly but there's a lot going on over here, let's go over it little by little:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core-test
  (:import [java.util Date])
  (:require [clojure.test :refer :all]
            [ns-playground.hello :as hello :refer [&lt;3]]
            [ns-playground.core :refer :all]))</pre></div><p class="calibre7">This is the namespace declaration, let's list everything it does:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It declares the <code class="email">ns-playground.core-test</code> package.</li><li class="listitem">It imports the <code class="email">java.util.Date</code> class.</li><li class="listitem">It makes everything in the <code class="email">clojure.test</code> namespace available in the current namespace, if we were in Java we might have used <code class="email">import static clojure.test.*</code> to get a similar effect. We can achieve this with the <code class="email">:refer :all</code> keywords.</li><li class="listitem">It makes everything in the <code class="email">ns-playground.hello</code> namespace available with the hello shortcut but we need to prefix every function or value defined in <code class="email">ns-playground.hello</code> with hello and it also makes the <code class="email">&lt;3</code> function available without a prefix. To generate an alias and make everything available with the <code class="email">hello</code> alias, we use the <code class="email">:as</code> keyword and then pass a vector to <code class="email">:refer</code> to include certain elements.</li><li class="listitem">It makes everything in the <code class="email">ns-playground.core</code> namespace available in the current namespace. We achieve this with the <code class="email">:refer :all</code> keywords.<div class="informalexample"><pre class="programlisting">(defn- lazy-contains? [col element]
  (not (empty? (filter #(= element %) col))))</pre></div></li></ul></div><p class="calibre7">This is the declaration of a function called <code class="email">lazy-contains?</code>, it is a <code class="email">boolean</code> function and it is customary in Clojure to call it a predicate.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre7">The name of the function including the question mark might be something that looks awkward to you. In Clojure and Lisp, you can use question marks in the names of functions and it is common to do it for functions that return Booleans.</p></div><p class="calibre7">It receives two parameters: <code class="email">col</code> and <code class="email">element</code>.</p><p class="calibre7">The actual<a id="id76" class="calibre1"/> body of the function looks a bit complicated but it is actually very simple. Whenever you encounter a function that looks similar to the one mentioned in the preceding section, try to read it from the inside out. The innermost part is, as follows:</p><div class="informalexample"><pre class="programlisting">#(= element %)</pre></div><p class="calibre7">This is a shorter way of writing an anonymous function which has a single parameter. If we want to write another function that compares its argument against the <code class="email">element</code>, without the syntactic sugar, we can do it in the following method:</p><div class="informalexample"><pre class="programlisting">(fn [e1]
  (= element e1))</pre></div><p class="calibre7">This is an anonymous function or in other words it is a function that has no name, but it works as every other function; we will read more about anonymous functions when we get back to functional programming.</p><p class="calibre7">Our anonymous function is a parameter to the following form:</p><div class="informalexample"><pre class="programlisting">(filter #(= element %) col)</pre></div><p class="calibre7">This new form filters the collection <code class="email">col</code> and returns a new collection with only the elements that pass the test. Let's see an example where we have used the predefined Clojure function <code class="email">even?</code>:</p><div class="informalexample"><pre class="programlisting">;; This returns only the even numbers in the collection
(filter even? [1 2 3 4])
;;=&gt; (2 4)</pre></div><p class="calibre7">Our filter function now returns every element in the collection that passes the <code class="email">#(= element %)</code>test. So we get every element that is equal to the element passed to <code class="email">lazy-contains?</code>.</p><p class="calibre7">We then ask if none of the elements equal to <code class="email">element</code> in <code class="email">col</code> with the following form:</p><div class="informalexample"><pre class="programlisting">(empty? (filter #(= element %) col))</pre></div><p class="calibre7">But we want to know if there is some element equal to element, so at last we negate the previous form:</p><div class="informalexample"><pre class="programlisting">(not (empty? (filter #(= element %) col)))</pre></div><p class="calibre7">Imagine that if you had to write this in Java (and I asked to add every element that matches the element to a list), you will have something similar to this:</p><div class="informalexample"><pre class="programlisting">List&lt;T&gt; filteredElements = new ArrayList&lt;T&gt;();
for(T e1 : col) {
    if(e1 == element) {
        filteredElements.add(e1);
    }
}
return !filteredElements.isEmpty();</pre></div><p class="calibre7">There is a big <a id="id77" class="calibre1"/>difference, it is more verbose and to understand it we need to "run" the algorithm in our heads. This is called imperative programming, Clojure allows us to do imperative programming as well as functional programming, which is a type of declarative programming. When you get used to it, you'll see that it's easier to reason about than loops.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre7">Interactive programming means, telling every step of how something should be done to a computer. Declarative programming just asks for a result and doesn't give details of how to achieve it.</p></div><p class="calibre7">The actual tests are simple to understand:</p><div class="informalexample"><pre class="programlisting">(deftest current-date-is-date
  (testing "Test that the current date is a date"
    (is (instance? Date (hello/current-date)))))</pre></div><p class="calibre7">This test checks the current date returns an instance of <code class="email">java.util.Date</code>, the <code class="email">is</code> form works as the Java assert instruction:</p><div class="informalexample"><pre class="programlisting">(deftest check-loving-collection
  (testing "Check that I love clojure and you"
    (let [loving-seq (&lt;3 "I""Clojure""you""doggies""chocolate")]
      (is (not (lazy-contains? loving-seq "I love Vogons")))
      (is (lazy-contains? loving-seq "I love Clojure"))
      (is (lazy-contains? loving-seq "I love doggies"))
      (is (lazy-contains? loving-seq "I love chocolate"))
      (is (lazy-contains? loving-seq "I love you")))))</pre></div><p class="calibre7">This test checks the <code class="email">&lt;3</code> function, it checks that the returned collection contains <code class="email">I love Clojure</code>, <code class="email">I love doggies</code>, <code class="email">I love chocolate</code> and <code class="email">I love you</code> and it should not contain <code class="email">I love Vogons</code>.</p><p class="calibre7">This test is simple to understand. What might be not so simple to understand is the <code class="email">&lt;3</code> function, we'll look into it with the REPL.</p></div></div>
<div class="book" title="Summary" id="NQU21-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we got to know some utilities that we can use for better management of our code and we have some more examples of everyday Clojure code. In particular:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Working of namespace in Clojure and their relation to Java packages</li><li class="listitem">Writing out-of-the-box unit tests and executing them with Leiningen and Cursive Clojure</li><li class="listitem">Delving into the Clojure Interactive development workflow and a bit of the Clojure mindset</li><li class="listitem">Writing very simple functions and testing them</li></ul></div><p class="calibre7">In the next chapter, we will learn about Java interop, so we can start using the familiar classes and libraries we already know in our Clojure code.</p><p class="calibre7">We will also learn how to use Clojure from Java, so you can start using it in your everyday Java projects.</p></div></body></html>