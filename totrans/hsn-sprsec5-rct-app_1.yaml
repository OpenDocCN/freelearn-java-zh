- en: Overview of Spring 5 and Spring Security 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 5 和 Spring Security 5 概述
- en: This book expects readers to be conversant with Spring Framework (any version)
    and Spring Security (any version). This is an ice-breaker chapter that introduces
    the reader to some of the most important concepts; we will expand on them in subsequent
    chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书期望读者熟悉 Spring 框架（任何版本）和 Spring Security（任何版本）。这是一个破冰章节，介绍了读者一些最重要的概念；我们将在随后的章节中对其进行扩展。
- en: The chapter will introduce you to new application requirements and then to reactive
    programming concepts. It touches on application security and how Spring Security
    addresses security concerns in an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍新的应用需求，然后是响应式编程概念。它涉及到应用安全以及 Spring Security 如何解决应用中的安全问题。
- en: We'll continue with Spring Security and then close the chapter by explaining
    how the examples in this chapter are structured. This is quite important as I
    expect readers to be comfortable whenever a new concept is introduced in code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 Spring Security，并在本章结束时解释本章节中的例子是如何构建的。这非常重要，因为我期望读者在代码中引入新概念时感到舒适。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: New-generation application requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新一代应用需求
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Reactive applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式应用
- en: Spring Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架
- en: Reactive landscape in Java
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中的响应式领域
- en: Spring Framework and reactive applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架和响应式应用
- en: Application security
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用安全
- en: Spring Security
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security's core features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 的核心特性
- en: Spring Security 5's new features
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 5 的新特性
- en: The working of Spring Security
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 的工作原理
- en: Core Spring Security modules
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心Spring Security模块
- en: How examples are structured
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子是如何构建的
- en: 'It''s important that you understand how we will be using examples in this book.
    Since the book tries to give lots of detail on Spring Security 5 and its reactive
    aspects, we will not have a single use case throughout the book. Instead, we will
    keep creating small projects to help you understand each of the core concepts
    covered. Here are some of the important aspects of the code base within this book:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们在这本书中将如何使用例子非常重要。由于本书试图详细阐述 Spring Security 5 及其响应式方面，我们将在整本书中不只有一个用例。相反，我们将不断创建小型项目，以帮助您理解涵盖的每个核心概念。以下是本书代码库中一些重要的代码方面：
- en: Most concepts will be covered using a standalone Spring Boot project.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数概念将使用独立的 Spring Boot 项目进行介绍。
- en: At times, we will use the famous Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    to bootstrap our sample Spring Boot application. In other cases, we will start
    with a base project that we already have and introduce more concepts through code.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们将使用著名的 Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    来启动我们的示例 Spring Boot 应用程序。在其他情况下，我们将从一个我们已有的基础项目开始，并通过代码介绍更多概念。
- en: Generally, we will be using Java configuration. At times, we might use XML-based
    configurations.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们将使用 Java 配置。有时，我们可能会使用基于 XML 的配置。
- en: We will keep our examples as simple as possible so that we don't lose focus
    on the core concept being introduced.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尽可能使我们的例子保持简单，这样我们就不至于失去对所介绍的核心概念的专注。
- en: Even though this book is focused on reactive applications, we will not be covering
    this each time it is introduced. At times, we will just be doing plain, old imperative
    programming as it is more important to know reactive programming and use it when
    required. It's not that we have to use reactive code everywhere possible, just
    use it where you see fit.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这本书专注于响应式应用，但我们不会每次介绍时都涵盖这一点。有时，我们可能只是进行普通的、传统的命令式编程，因为了解响应式编程并在需要时使用它更为重要。并不是说我们必须在所有可能的地方使用响应式代码，只是在你认为合适的地方使用它。
- en: We will be using VS Code for all the projects, and we'll be using the extensions
    available in VS Code to the fullest. We will also be using the Spring Initializr
    extension rather than using online Spring Initializr.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在所有项目中使用 VS Code，并且会充分利用 VS Code 中可用的扩展。我们还将使用 Spring Initializr 扩展，而不是使用在线的
    Spring Initializr。
- en: We will be using Maven most of the time in this book. There might be a case
    where we try Gradle.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这本书中，我们大部分时间将使用 Maven。可能会有尝试 Gradle 的情况。
- en: Sometimes, we might use IntelliJ IDE and you'll see some screenshots showing
    this.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们可能会使用 IntelliJ IDE，您将看到一些展示这一点的截图。
- en: We'll be using the latest Spring Boot release version, namely **2.0.0\. RELEASE**.
    This is the latest release version of Spring Boot at the time of writing this
    book.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用最新的Spring Boot发布版本，即**2.0.0.RELEASE**。这是本书撰写时的最新发布版本。
- en: New-generation application requirements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新一代应用需求
- en: 'Here are some of the core new application requirements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些核心的新应用需求：
- en: '**Highly scalable**: The social platform has grown exponentially over the last
    decade and people are more tech-savvy than ever.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可扩展**：社交平台在过去十年中呈指数级增长，人们的科技素养比以往任何时候都要高。'
- en: '**Resilient, fault-tolerant, and highly available**: downtime in your application
    is something which enterprises are not ready to take in modern times; downtime
    of even seconds is now creating huge losses for many big businesses.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性、容错和高度可用**：在现代时代，企业不愿意接受应用的中断；即使是几秒钟的中断现在也在给许多大企业造成巨大的损失。'
- en: '**High performance**: If your site is slow, people have a tendency to leave
    and search for alternatives. People have a short attention span and will not stay
    or come back if your website performs poorly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：如果你的网站运行缓慢，人们倾向于离开并寻找替代品。人们注意力集中时间短，如果你的网站表现不佳，他们不会停留或回来。'
- en: '**Hyper-personalization**: Users need personalized websites rather than generic
    websites, and this puts huge pressure on servers to do many intensive analyses
    in real time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超个性化**：用户需要个性化的网站而不是通用网站，这给服务器带来了巨大的压力，需要在实时进行许多密集的分析。'
- en: With technology in everyone's hands (in some form or another, most people use
    technology), users are quite well-versed in privacy policies and application security.
    They are aware of most of the security requirements, and companies take time to
    educate users about the importance of security and the ways they should look for
    security flaws in applications. You might already know that if a site runs on
    HTTP as opposed to HTTPS (SSL) and Chrome tags, these sites quite clearly show
    the users as Not Secure in the address bar. With more people becoming knowledgeable
    about technology, these aspects are well-known among the majority of users and
    security has become one of the most talked about subjects in the IT landscape.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术无处不在（以某种形式或另一种形式，大多数人都在使用技术），用户对隐私政策和应用安全相当熟悉。他们了解大部分安全要求，公司也会花时间教育用户了解安全的重要性以及他们在应用中寻找安全漏洞的方法。你可能已经知道，如果一个网站运行在HTTP而不是HTTPS（SSL）和Chrome标签下，这些网站在地址栏中会清楚地显示为“不安全”。随着越来越多的人对技术有所了解，这些方面在大多数用户中都是众所周知的，安全已经成为IT领域中最受热议的话题之一。
- en: Another important aspect is data privacy. Some users are not concerned about
    sharing their data but some are quite reticent. Many governments recognize this
    fear and have started making many rules and regulations in this space. One such
    data privacy rule is the well-known **General Data Protection Regulation** (**GDPR**),
    which has been enforced since May 25th, 2018.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的方面是数据隐私。一些用户并不担心分享他们的数据，但一些用户则相当谨慎。许多政府认识到这种恐惧，并开始在这个领域制定许多规则和法规。其中一项数据隐私规则是众所周知的**通用数据保护条例**（**GDPR**），自2018年5月25日起生效。
- en: The **European Union** (**EU**) GDPR replaces the Data Protection Directive
    95/46/EC and was designed to harmonize data privacy laws across Europe, to protect
    and empower all EU citizen's data privacy and to reshape the way organizations
    across the region approach data privacy. For more information, you can check this
    link: [https://gdpr-info.eu/art-99-gdpr/](https://gdpr-info.eu/art-99-gdpr/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧洲联盟**（**EU**）的**GDPR**取代了数据保护指令95/46/EC，旨在统一欧洲的数据隐私法律，保护并赋予所有欧盟公民的数据隐私权，并重塑该地区组织处理数据隐私的方式。更多信息，您可以查看此链接：[https://gdpr-info.eu/art-99-gdpr/](https://gdpr-info.eu/art-99-gdpr/)。'
- en: Modern browsers have also given us enough tools to look at many aspects of a
    web application in a more detailed manner with regards to security. In addition,
    browsers have been enhanced with more and more features (for example, a cookie
    was once one of the options for storing data, but now we have other options, such
    as **localStorage** and i**ndexedDB**), making it more vulnerable to security
    breaches and attacks from an ever-open hacker sitting on the sidelines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器也为我们提供了足够多的工具，以更详细的方式查看Web应用的安全方面的许多方面。此外，浏览器还增加了越来越多的功能（例如，cookie曾经是存储数据的一种选项，但现在我们有其他选项，如**localStorage**和**IndexedDB**），这使得它更容易受到安全漏洞和来自边线黑客的攻击。
- en: To achieve these various application requirements, organizations go to public
    cloud providers instead of their own on-premise datacenters. This puts applications
    in a more vulnerable state and security aspects come to the forefront. The various
    components that constitute the application need to be highly secured and nonhackable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些各种应用需求，组织选择使用公共云服务提供商而不是自己的本地数据中心。这使得应用程序处于更脆弱的状态，安全方面变得尤为突出。构成应用程序的各种组件需要高度安全且不可被黑客攻击。
- en: The technological landscape is constantly growing, with new technologies popping
    up and getting adopted by the developer community. Because of this and the various
    technology improvements it brings in, many organizations have to adopt these technologies
    to be compete within the market. This again puts huge pressure on security, as
    these shiny new technologies may not have concentrated enough effort on making
    security a major requirement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 技术领域正在不断增长，新技术不断涌现并被开发社区所采纳。正因为如此，以及它带来的各种技术改进，许多组织不得不采用这些技术以在市场上竞争。这又给安全带来了巨大的压力，因为这些光鲜的新技术可能没有集中足够的努力来确保安全成为一项主要要求。
- en: All in, having rigid security in an application is a no-brainer requirement
    and organizations, and end users, are well aware of this fact.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在应用程序中拥有严格的安全措施是一个不言而喻的要求，组织和最终用户都清楚这一点。
- en: Reactive programming
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Over the last few years, JavaScript has become one of the most used languages,
    and you have already heard of the term **reactive** in the world of JavaScript,
    both in a backend and a frontend context.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，JavaScript已经成为最常用的语言之一，你已经在JavaScript的世界中听说过**响应式**这个词，无论是在后端还是前端环境中。
- en: So, *What exactly is reactive programming?*—It's a programming paradigm that
    has asynchronous data streams at its core. The data flows through various parts
    of the program in the form of a message. The message is produced by a `Producer` and
    works in a fire-and-forget manner in which the program produces a message and
    forgets it. The `Subscriber` who has subscribed (shown interest) to such messages,
    gets the message, processes it, and passes on the output as a message for other
    parts of the program to consume.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，**响应式编程究竟是什么**？——它是一种以异步数据流为核心的编程范式。数据以消息的形式通过程序的各个部分流动。消息由`生产者`产生，并以一种“发射并遗忘”的方式工作，即程序产生一个消息并忘记它。已经订阅（表示感兴趣）此类消息的`订阅者`会接收到消息，处理它，并将输出作为消息传递给程序的其它部分进行消费。
- en: In the world of databases, NoSQL presented a huge shift from relational databases.
    Similarly, this programming paradigm is a huge shift from the conventional programming
    paradigm (imperative programming). The good thing is that without much knowledge,
    you have already been coding a bit of reactive code in your day-to-day coding
    life. Wherever you see the word **stream**, you are indirectly using a piece of
    reactive code. Such programming has a name of its own and this aspect has become
    more mainstream in the industry. Many languages understand the advantages this
    brings and they have started to natively support this paradigm of programming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库的世界里，NoSQL从关系型数据库中带来了巨大的转变。同样，这种编程范式与传统的编程范式（命令式编程）相比也是一个巨大的转变。好事是，你无需太多知识，在日常编码生活中，你已经在一定程度上编写了一些响应式代码。无论你在哪里看到**流**这个词，你都在间接地使用一段响应式代码。这种编程有自己的名字，并且这一方面在行业中已经变得更加主流。许多语言都理解这种范式带来的优势，并且它们已经开始原生支持这种编程范式。
- en: Reactive applications
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式应用
- en: In the earlier section of this chapter, we covered how application requirements
    have drastically changed over the last decade. To cater to this, there is a concept
    of application development named reactive applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分，我们讨论了应用需求在过去十年中发生了巨大的变化。为了满足这一点，有一个名为响应式应用的应用开发概念。
- en: It is important to understand the difference between reactive programming and
    reactive applications. Employing reactive programming doesn't produce reactive
    applications, but concepts of reactive programming can definitely aid in building
    reactive applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理解响应式编程和响应式应用之间的区别很重要。采用响应式编程不会产生响应式应用，但响应式编程的概念肯定有助于构建响应式应用。
- en: Knowing the Reactive Manifesto will help you understand reactive applications/systems
    because the manifesto clearly dictates each and every aspect of reactive applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解响应式宣言将帮助你理解响应式应用/系统，因为宣言明确规定了响应式应用的每一个方面。
- en: Reactive Manifesto
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: A **manifesto** is a public declaration of intentions, opinions, objectives,
    or motives, as one issued by a government, sovereign, or organization ([http://www.dictionary.com/browse/manifesto](http://www.dictionary.com/browse/manifesto)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**宣言**是一个公开声明意图、观点、目标或动机的文件，如政府、主权国家或组织发布的（[http://www.dictionary.com/browse/manifesto](http://www.dictionary.com/browse/manifesto)）。'
- en: The **Reactive Manifesto** clearly articulates the views of the issuer, following
    which an application can be developed to be reactive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式宣言**清晰地阐述了发布者的观点，据此可以开发出响应式的应用程序。'
- en: According to the Reactive Manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)),
    a reactive system should be responsive, resilient, elastic, and message-driven.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据响应式宣言（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)），一个响应式系统应该是响应的、弹性的、弹性的和消息驱动的。
- en: Let's get into each of these terms in a bit more detail. Most of the text in
    this section is from the online Reactive Manifesto and then slightly modified
    to convey the concepts in more easily digestible terms for the readers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些术语。本节的大部分文本来自在线的响应式宣言，并稍作修改，以便以更易于理解的方式传达给读者。
- en: Responsive
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式
- en: In case of problems, responsive systems can quickly detect them and effectively
    deal with them. These systems also give consistent response times and also establish
    upper bounds, guaranteeing a minimum **Quality of Service** (**QoS**). Because
    of such characteristics, these systems build end user confidence, simplify error
    handling, and encourage more interaction from end users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题时，响应式系统可以快速检测并有效处理它们。这些系统还提供一致的反应时间，并建立上限，保证最低的**服务质量**（**QoS**）。由于这些特性，这些系统增强了终端用户的信心，简化了错误处理，并鼓励终端用户进行更多交互。
- en: Resilient
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: 'In the case of failure, resilient systems stay responsive and interactable.
    **Resilience** in an application can be achieved by:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现故障的情况下，弹性系统保持响应性和可交互性。在应用程序中实现**弹性**可以通过以下方式：
- en: '**Replication**: Running the same component in more than one place, so that
    if one fails, another could handle it and the application can function in a normal
    fashion.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：在多个地方运行相同的组件，以便如果其中一个失败，另一个可以处理它，应用程序可以正常工作。'
- en: '**Containment/isolation**: Issues of a particular component are contained and
    isolated within that component and don''t interfere with other components or other
    similar components spun up as part of replication.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制/隔离**：特定组件的问题被限制和隔离在该组件内部，不会干扰其他组件或其他作为复制一部分启动的类似组件。'
- en: '**Delegation**: In the case of an issue in a component, without much deliberation,
    the control is transferred to another similar component that is running in a completely
    different context.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委派**：在组件出现问题的情形下，无需过多考虑，控制权就会转移到另一个在完全不同环境中运行的类似组件。'
- en: Elastic
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Elastic systems can easily autoscale (increase or decrease resources) as the
    input rate increases or decreases. Such systems don't have any contention points
    and can replicate components at will, distributing the increase in load. The way
    these systems are designed makes sure that when scaling is required, it can be
    done in a very cost-effective manner by adding on more commodity hardware and
    software platforms as opposed to expensive hardware and licensed software platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性系统可以轻松地进行自动扩展（增加或减少资源），随着输入率的增加或减少。这些系统没有任何竞争点，可以随意复制组件，分配负载的增加。这些系统的设计方式确保在需要扩展时，可以通过添加更多的通用硬件和软件平台，而不是昂贵的硬件和授权软件平台，以非常经济的方式完成。
- en: Message-driven
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动
- en: In reactive applications, one of the main aspects is the usage of asynchronous
    messages to pass data from one component to another. This brings loose coupling
    between components and aids in achieving location transparency (as long as the
    component is reachable/discoverable, it can reside in a single node or a cluster
    of nodes anywhere). Create a message, publish, and forget. Registered subscribers
    receive the message, process it, and broadcast the message for the other subscribes
    to do their jobs. This is one of the core aspects of reactive programming and
    it is one of the fundamental aspects needed for a reactive system. This fire-and-forget
    concept brings in a non-blocking way of communication, resulting in highly scalable
    applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式应用程序中，主要方面之一是使用异步消息在组件之间传递数据。这带来了组件之间的松散耦合，并有助于实现位置透明性（只要组件是可到达的/可发现的，它就可以位于单个节点或任何地方的节点集群中）。创建一个消息，发布，然后忘记。已注册的订阅者接收消息，处理它，并将消息广播给其他订阅者以执行他们的任务。这是响应式编程的核心方面之一，也是响应式系统所需的基本方面之一。这种“发射并忘记”的概念以非阻塞的方式引入了通信方式，从而实现了高度可扩展的应用程序。
- en: 'The following diagram (*Figure 1*) clearly shows the Reactive Manifesto in
    a pictorial fashion. It also clearly shows the relationship between the main concepts
    on the Reactive Manifesto:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表（*图 1*）清楚地以图示方式展示了响应式宣言。它还清楚地显示了响应式宣言上主要概念之间的关系：
- en: '![](img/0c837321-50ac-422f-993a-c12aece10ded.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c837321-50ac-422f-993a-c12aece10ded.png)'
- en: 'Figure 1: Reactive Manifesto'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：响应式宣言
- en: Since reactive applications are responsive, resilient, elastic, and message-driven,
    these applications are inherently highly flexible, highly scalable, loosely coupled,
    and fault-tolerant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于响应式应用程序是响应的、弹性的、可伸缩的和消息驱动的，因此这些应用程序本质上具有高度灵活性、高度可扩展性、松散耦合和容错性。
- en: 'Mateusz Gajewski, in one of his presentations shared on `www.slideshare.net`,
    sums up the Reactive Manifesto in a very nice way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mateusz Gajewski 在其分享在 `www.slideshare.net` 的演示文稿中，以一种非常优雅的方式总结了响应式宣言：
- en: '![](img/f2dc861f-ce23-40b4-9240-691ca42cee51.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2dc861f-ce23-40b4-9240-691ca42cee51.png)'
- en: 'Figure 2: Reactive Manifesto as conceived by Mateusz Gajewski'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：Mateusz Gajewski 构想的响应式宣言
- en: Spring Framework
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架
- en: '**Spring Framework** is the de facto standard for building Java applications.
    Over the last decade, it has matured with every major release. Spring Framework
    5 became generally available as 5.0.0\. in September 2017; this is an important
    release (major) for the framework since its previous version, which was released
    in 2013.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring 框架**是构建 Java 应用程序的事实标准。在过去十年中，随着每个主要版本的发布，它已经逐渐成熟。Spring 框架 5 于 2017
    年 9 月成为 5.0.0 版本，这是一个重要的版本（主要）发布，因为其上一个版本是在 2013 年发布的。'
- en: One of the major additions to Spring 5 is the introduction of a functional web
    framework, Spring WebFlux, built on the core reactive foundation. Reactive programming
    is slowly creeping into the framework and many core modules within the framework
    are inherently supporting reactive programming in a big way. Since the framework
    has started supporting reactive programming natively, core aspects of this programming
    are fully implemented and followed by many of the modules. Also, many reactive
    concepts have become common language within the framework.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5 的一个主要新增功能是引入了一个基于核心响应式基础的函数式 Web 框架，即 Spring WebFlux。响应式编程正逐渐渗透到框架中，并且框架中的许多核心模块本质上以很大的方式支持响应式编程。由于框架开始原生支持响应式编程，因此该编程的核心方面得到了全面实现，并被许多模块遵循。此外，许多响应式概念已成为框架中的通用语言。
- en: It's important to note that Spring's reactive concepts have been taken as is
    from Java 8's **Reactor Core library**, which implements the reactive programming
    paradigm. Reactor Core is built on top of *Reactive Streams Specification*, which
    is the industry standard for building reactive applications in the Java world.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Spring 的响应式概念直接借鉴了 Java 8 的 **Reactor Core 库**，该库实现了响应式编程范式。Reactor Core
    是建立在 *Reactive Streams 规范*之上的，这是在 Java 世界中构建响应式应用程序的行业标准。
- en: Another important feature is the inclusion of new way by which such applications
    can be tested. We have a dedicated chapter for Spring WebFlux in ([Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*) where these aspects will be covered in more
    detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是引入了测试此类应用程序的新方法。我们有一个专门的章节介绍 Spring WebFlux（[第 5 章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)，*与
    Spring WebFlux 集成*)，其中将更详细地介绍这些方面。
- en: Being a major release, it has loads of stuff either added or enhanced. But we
    are not going to list all of its features. The full list can be found at this
    link: [https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x)*.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个大版本发布，它增加了许多功能或进行了增强。但我们不会列出所有功能。完整的列表可以在以下链接中找到：[https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x)*.*
- en: Reactive Landscape in Java
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的反应式景观
- en: It's hard to wrap your head around reactive concepts when you're coming from
    a traditional programming model. Some of the subsequent sections are aimed at
    introducing you to reactive concepts and how they evolved into their present state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自传统的编程模型，理解反应式概念可能会很困难。一些后续章节旨在向您介绍反应式概念以及它们是如何发展到当前状态的。
- en: Reactive Streams and Reactive Streams Specifications
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流和反应式流规范
- en: The official document for Reactive Streams ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    says that—*Reactive Streams is an initiative to provide a standard for asynchronous
    stream processing with non-blocking back pressure. This encompasses efforts aimed
    at runtime environments (JVM and JavaScript) as well as network protocols.*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流的官方文档（[http://www.reactive-streams.org/](http://www.reactive-streams.org/））指出——*反应式流是一个旨在提供异步流处理标准，具有非阻塞背压的倡议。这包括针对运行时环境（JVM和JavaScript）以及网络协议的努力。*
- en: It started as an initiative between a group of companies in 2013\. In April
    2015, 1.0 of the specification was released and there were a number of implementations
    (such as Akka Streams and Vert.x) available at the same time. The specification
    was initiated with a target to get it included in the official Java standard library
    and in 2017, with the release of JDK9, it made it's way into it officially. As
    with any specification, the ultimate aim is to have a number of implementations
    conforming to the specification, and over time, the specification evolves. The
    specification consists of some core interfaces, some rules around these, and a
    **Technology Compatibility Kit** (**TCK**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它始于2013年一群公司之间的一个倡议。2015年4月，规范的第1.0版发布，同时有多个实现（如Akka Streams和Vert.x）可用。该规范的目标是将其纳入官方Java标准库，2017年，随着JDK9的发布，它正式成为其中的一部分。与任何规范一样，最终目标是让多个实现符合规范，随着时间的推移，规范会不断发展。规范包括一些核心接口，一些关于这些接口的规则，以及一个**技术兼容性工具包**（**TCK**）。
- en: TCK is a suite of tests that will be executed to check the correctness/compliance
    of a **Java Specification Request** (**JSR**) implementation. In **Java Community
    Process** (**JCP**), TCK is one of the three required components for ratifying
    a JSR. The other two are JSR specification and JSR reference implementation. The
    TCK for the Java platform is called **Java Compatibility Kit** (**JCK**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TCK是一套测试，将用于检查**Java规范请求**（**JSR**）实现的正确性/合规性。在**Java社区进程**（**JCP**）中，TCK是批准JSR所需的三个组件之一。其他两个是JSR规范和JSR参考实现。Java平台的TCK被称为**Java兼容性工具包**（**JCK**）。
- en: 'Being a specification, it enables any implementation respecting the specification
    to cooperate and interoperate with each other. For example, an implementation
    written in Akka can talk to the Vert.x implementation over the Reactive Streams
    protocol without any trouble. Adoption is growing and, as we speak, more implementations
    that conform to the specifications written in different languages are being released:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项规范，它使任何尊重该规范的实现能够相互合作和互操作。例如，用Akka编写的实现可以通过反应式流协议与Vert.x实现进行通信，而不会遇到任何问题。采用率正在增长，并且正如我们所说，更多符合不同语言编写的规范的实施正在发布：
- en: '![](img/889be598-8a2a-46ac-b42d-e926af183090.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/889be598-8a2a-46ac-b42d-e926af183090.png)'
- en: 'Figure 3: Reactive Streams Specification/API'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：反应式流规范/API
- en: 'The preceding figure clearly shows the **Reactive Streams Specification**.
    Some of the important specification rules are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图清楚地显示了**反应式流规范**。一些重要的规范规则如下：
- en: The calls from `Publisher` to `Subscriber` and `Subscriber` to `Publisher` shouldn't
    be concurrent in nature.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Publisher`到`Subscriber`以及从`Subscriber`到`Publisher`的调用在本质上不应该并发。
- en: The `Subscriber` can perform its job synchronously or asynchronously but always
    has to be non-blocking in nature.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber`可以同步或异步地执行其工作，但始终必须是非阻塞的。'
- en: From `Publisher` to `Subscriber` there should be an upper bound defined. After
    that defined bound, buffer overflows occur and could result in errors.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Publisher`到`Subscriber`应该定义一个上限。在此定义的上限之后，缓冲区溢出发生，可能会导致错误。
- en: Apart from **NullPointerException** (**NPE**), no other exception can be raised.
    In the case of NPE, `Publisher` calls the `onError` method and `Subscriber` cancels
    the `Subscription`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了**NullPointerException**（**NPE**）之外，不能引发其他异常。在NPE的情况下，`Publisher`调用`onError`方法，`Subscriber`取消`Subscription`。
- en: In the preceding definition of Reactive Streams, there are some very important
    terms, namely **non-blocking** and **backpressure**, which we'll explore a bit
    more to understand the core concepts of Reactive Streams.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式流的先前定义中，有一些非常重要的术语，即**非阻塞**和**反压**，我们将进一步探讨以了解反应式流的核心概念。
- en: Non-blocking
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞
- en: '**Non-blocking** means threads never block. If the thread needs to block, the
    code is written in such a way that the thread gets notified at the right time
    and the process continues. Reactive programming lets you implement a non-blocking,
    declarative, and event-driven architecture.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**非阻塞**意味着线程永远不会阻塞。如果线程需要阻塞，代码将以这种方式编写，使得线程在正确的时间得到通知，过程继续。反应式编程让您能够实现非阻塞、声明式和事件驱动的架构。'
- en: 'One of the approaches to writing non-blocking applications is by using messages
    as the means of sending data. A thread sends the request and soon after that,
    the thread is being used for something else. When the response is ready, it is
    delivered back using another thread and the requesting party is notified so that
    further processing can continue:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编写非阻塞应用程序的一种方法是通过使用消息作为发送数据的方式。一个线程发送请求，随后该线程就被用于其他任务。当响应准备好时，它将通过另一个线程返回，并通知请求方，以便进一步处理可以继续：
- en: '![](img/1323eef4-40e3-40e8-895a-fe526156fa6e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1323eef4-40e3-40e8-895a-fe526156fa6e.png)'
- en: 'Figure 4: Non-blocking'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：非阻塞
- en: The non-blocking concept is already implemented by well-known frameworks, such
    as Node.js and Akka. The approach that Node.js uses is a single thread that sends
    data in a multiplexing aspect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞概念已经被知名框架如Node.js和Akka实现。Node.js使用的方法是单线程，以复用方式发送数据。
- en: In telecommunications and computer networks, multiplexing (sometimes contracted
    to muxing) is a method by which multiple analog or digital signals are combined
    into one signal over a shared medium. The aim is to share an expensive resource.
    For more information about multiplexing, you can visit the following link: [http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html](http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在电信和计算机网络中，复用（有时简称为muxing）是一种将多个模拟或数字信号组合成一个信号，通过共享介质传输的方法。目的是共享昂贵的资源。有关复用的更多信息，您可以访问以下链接：[http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html](http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html)。
- en: Backpressure
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压
- en: In an ideal scenario, every message produced by the `Producer` is passed to
    the `Subscriber` as and when the message is produced without any delay. There
    is a chance that the `Subscriber` is unable to handle the messages at the same
    rate as they are produced and this can cramp its resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，`Producer`产生的每个消息都应立即传递给`Subscriber`，而无需任何延迟。有可能`Subscriber`无法以与它们产生的相同速率处理消息，这可能会耗尽其资源。
- en: '**Backpressure** is a method by which the `Subscriber` can tell the `Producer`
    to send messages at a slower rate to give the `Subscriber` time to handle these
    messages properly without putting too much pressure on its resources.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**反压**是一种方法，通过这种方法，`Subscriber`可以告诉`Producer`以较慢的速度发送消息，以便给`Subscriber`足够的时间来正确处理这些消息，而不会对其资源造成过多压力。'
- en: Since this is the first chapter, we are just introducing you to these important
    reactive concepts. Code examples will be covered in subsequent chapters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一章，我们只是向您介绍这些重要的反应式概念。代码示例将在后续章节中介绍。
- en: Now that we have a brief idea of Reactive Streams and Reactive Streams Specification,
    we will go into next important reactive concept in Java, namely Reactive Extensions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对反应式流和反应式流规范有了初步的了解，我们将进入Java中下一个重要的反应式概念，即反应式扩展。
- en: Reactive Extensions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: '**Reactive Extensions** (**Rx or ReactiveX**) ([https://msdn.microsoft.com](https://msdn.microsoft.com))
    is a library for composing asynchronous and event-based programs using observable
    sequences and LINQ-style query operators. Data sequences can take many forms,
    such as a stream of data from a file or web service, web services requests, system
    notifications, or a series of events such as user inputs.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式扩展**（**Rx或ReactiveX**）([https://msdn.microsoft.com](https://msdn.microsoft.com))是一个库，用于使用可观察序列和LINQ风格的查询运算符来组合异步和基于事件的程序。数据序列可以采取多种形式，例如来自文件或Web服务的文件数据流、Web服务请求、系统通知或一系列事件，如用户输入。'
- en: 'As stated in the preceding definition, these are APIs that allow stream composition
    using the Observer pattern. It''s my duty to introduce you to the Observer pattern
    before going any further. The following is the definition of this pattern and
    it''s quite intuitive:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述定义，这些是允许使用观察者模式进行流组合的API。在我进一步介绍之前，介绍观察者模式是我的责任。以下是该模式的定义，它相当直观：
- en: The Observer pattern defines a provider (also known as a subject or an observable)
    and zero, one, or more observers (`Subscriber`). Observers register with the provider,
    and whenever a predefined condition, event, or state change occurs, the provider
    automatically notifies all observers by calling one of their methods. For more
    information about the Observer pattern, you can refer to this link: [https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式定义了一个提供者（也称为主题或可观察者）和零个、一个或多个观察者（`Subscriber`）。观察者向提供者注册，每当发生预定义的条件、事件或状态变化时，提供者会自动通过调用它们的方法之一来通知所有观察者。有关观察者模式的更多信息，您可以参考此链接：[https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern)。
- en: Data can flow in a number of forms, such as streams or events. Reactive Extensions
    lets you convert this dataflow into observables and aids you in programming reactive
    code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以多种形式流动，例如流或事件。反应式扩展允许您将这种数据流转换为可观察对象，并帮助您编写反应式代码。
- en: Rx is implemented in a variety of languages, including Java (RxJava). A full
    list of implemented languages and more detail on Rx can be found at [http://reactivex.io/](http://reactivex.io/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Rx是用多种语言实现的，包括Java（RxJava）。实现的完整语言列表和关于Rx的更多详细信息可以在[http://reactivex.io/](http://reactivex.io/)找到。
- en: RxJava
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: '**RxJava** is a Java VM implementation of ReactiveX—a library for composing
    asynchronous and event-based programs by using observable sequences.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJava**是ReactiveX的Java VM实现，是一个用于通过使用可观察序列来组合异步和基于事件的程序的库。'
- en: RxJava was ported from .NET to the world of Java by Netflix. After almost two
    years of development, a stable release of the API was made available in 2014\.
    This stable release targets Java (Version 6 and above), Scala, JRuby, Kotlin,
    and Clojure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是由Netflix从.NET移植到Java世界的。经过近两年的开发，2014年发布了该API的稳定版本。这个稳定版本针对Java（版本6及以上）、Scala、JRuby、Kotlin和Clojure。
- en: RxJava is a single-JAR, lightweight library and focuses on Observable abstraction.
    It facilitates integration with a variety of external libraries, making the library
    align with reactive principles. Some examples are `rxjava-jdbc` (database calls
    using JDBC with RxJava Observables) and Camel RX (Camel support for Reactive Extensions
    using RxJava).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是一个单JAR、轻量级库，专注于可观察抽象。它促进了与各种外部库的集成，使库与反应式原则保持一致。一些例子包括`rxjava-jdbc`（使用RxJava可观察对象进行JDBC数据库调用）和Camel
    RX（使用RxJava对反应式扩展的Camel支持）。
- en: Reactive Streams and RxJava
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流和RxJava
- en: RxJava 2.x is a complete rewrite from its predecessor, RxJava 1.x.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 2.x是从其前身RxJava 1.x完全重写的。
- en: RxJava 1.x was created before Reactive Streams Specification, and because of
    this it doesn't implement it. RxJava 2.x, on the other hand, is written on top
    of Reactive Streams Specification and fully implements it, and also targets Java
    8+. RxJava types in RxJava 1.x have been fully tweaked to comply with the specification
    and suffered heavy changes when the rewrite took place. It's good to note that
    there exists a bridge library ([https://github.com/ReactiveX/RxJavaReactiveStreams](https://github.com/ReactiveX/RxJavaReactiveStreams))
    that bridges between RxJava 1.x types and Reactive Streams, allowing RxJava 1.x
    to pass the Reactive Streams TCK-compliance tests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 1.x是在Reactive Streams规范之前创建的，因此它没有实现该规范。另一方面，RxJava 2.x是基于Reactive Streams规范编写的，并完全实现了它，同时针对Java
    8+。RxJava 1.x中的类型已经完全调整以符合规范，并且在重写时经历了重大变化。值得注意的是，存在一个桥接库（[https://github.com/ReactiveX/RxJavaReactiveStreams](https://github.com/ReactiveX/RxJavaReactiveStreams)），它可以在RxJava
    1.x类型和Reactive Streams之间进行桥接，使得RxJava 1.x能够通过Reactive Streams TCK兼容性测试。
- en: In RxJava 2.x, many concepts remain intact but names have been changed to comply
    with the spec.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava 2.x中，许多概念保持不变，但名称已更改以符合规范。
- en: We will not be going deep into RxJava as it is a big topic and there are plenty
    of books available that dive deep into RxJava.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨RxJava，因为它是一个大主题，而且有大量书籍深入探讨了RxJava。
- en: JDK 9 additions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 9新增功能
- en: As part of concurrency updates to JDK 9 (JEP 266), Reactive Streams was added
    to the Java standard library. Reactive Streams was initiated in 2013 by some of
    the well-known organizations that wanted to standardize the approach by which
    asynchronous data can be exchanged between software components. Soon, the concept
    became adopted by the industry and there evolved a number of implementations that
    all had similar core concepts but lacked standard nomenclature and terminologies,
    especially as regards interfaces and package naming. To avoid multiple nomenclatures
    and to enable interoperability between implementations, JDK 9 included basic interfaces
    as part of the **Flow Concurrency** library. This made applications want to implement
    Reactive Streams to depend on this library but not include specific implementations
    into the code base. Thus it is very easy to swap between implementations without
    any trouble.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JDK 9（JEP 266）并发更新的部分，Reactive Streams被添加到Java标准库中。Reactive Streams是在2013年由一些希望标准化异步数据在软件组件之间交换方法的知名组织发起的。很快，该概念被行业采纳，并出现了一系列具有相似核心概念但缺乏标准命名和术语的实现，特别是在接口和包命名方面。为了避免多个命名，并使实现之间能够互操作，JDK
    9将基本接口作为**Flow Concurrency**库的一部分包含在内。这使得应用程序想要实现Reactive Streams以依赖这个库，但不需要将特定实现包含到代码库中。因此，在无需任何麻烦的情况下，可以轻松地在实现之间进行切换。
- en: These interfaces are coded as static interfaces within the `java.util.concurrent.Flow`
    class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口被编码为`java.util.concurrent.Flow`类中的静态接口。
- en: Important interfaces
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要接口
- en: Reactive Streams specifications in Java 9 revolve around just four interfaces—`Publisher`,
    `Subscriber`, `Subscription`, and `Processor`. The library also includes a `Publisher`
    implementation—`SubmissionPublisher`. All of these are included within the `java.util.concurrent` package
    in the Java standard library. We will touch upon these interfaces in the following
    subsections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的Reactive Streams规范围绕四个接口展开——`Publisher`、`Subscriber`、`Subscription`和`Processor`。该库还包括一个`Publisher`实现——`SubmissionPublisher`。所有这些都被包含在Java标准库中的`java.util.concurrent`包内。我们将在以下小节中讨论这些接口。
- en: The Publisher Interface
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者接口
- en: 'The definition of this interface is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的定义如下：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, `Publisher` allows the `Subscriber` interface to subscribe to
    it so as to receive the message when `Publisher` produces it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Publisher`允许`Subscriber`接口订阅它，以便在`Publisher`产生消息时接收它。
- en: The Subscriber Interface
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者接口
- en: 'The definition of this interface is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的定义如下：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `Subscriber` interface's `onSubscribe` method allows `Subscriber`
    to be notified when `Publisher` accepts the `Subscription`. The `onNext` method
    is invoked when new items get published. As the name suggests, the `onError` method
    is invoked when there's an error and the `onComplete` method gets invoked when
    `Publisher` has completed its function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Subscriber`接口的`onSubscribe`方法允许`Subscriber`在`Publisher`接受`Subscription`时被通知。当有新项目发布时，会调用`onNext`方法。正如其名所示，当出现错误时，会调用`onError`方法，而当`Publisher`完成其功能时，会调用`onComplete`方法。
- en: The Subscription interface
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅接口
- en: 'The definition of this interface is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的定义如下：
- en: '[PRE2]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method request is for accepting requests for items and method cancel is
    for when `Subscription` is cancelled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 方法请求用于接受项目请求，方法取消用于`Subscription`被取消时。
- en: The Processor interface
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器接口
- en: 'The definition of this interface is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的定义如下：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It inherits from both the `Publisher` and `Subscriber` interfaces and therefore
    inherits all the methods of these interfaces. The main aspect is that the `Publisher`
    can produce an item but the `Subscriber` can consume a different item than that
    produced by the `Publisher`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它继承自`Publisher`和`Subscriber`接口，因此继承了这些接口的所有方法。主要方面是`Publisher`可以产生一个项目，但`Subscriber`可以消费与`Publisher`产生的不同项目。
- en: Spring Framework and reactive applications
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Framework和响应式应用
- en: Spring Framework adopted reactive in 2013 (the same time reactive was born and
    became more mainstream) with the release of Version 1.0 of Reactor. This was the
    time when Spring Framework Version 4.0 was released and Spring got itself engaged
    with **Pivotal**. In 2016, Spring's 4.3 Version was released with Reactor's Version
    3.0\. Around this period, the work on Spring's Version 5.0 (major version) was
    actively under construction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework在2013年（与响应式同时诞生并变得更加主流）发布了Reactor 1.0版本时采用了响应式编程。这是Spring Framework
    4.0版本发布，Spring与**Pivotal**建立了联系。2016年，Spring的4.3版本发布，与Reactor的3.0版本一起。在这个时期，Spring
    5.0（主要版本）的工作正在积极进行中。
- en: With new-generation application requirements, many conventional coding practices
    were challenged. One of the main aspects was to get rid of blocking IO and to
    find an alternative to conventional imperative programming.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新一代应用需求的出现，许多传统编码实践受到了挑战。主要方面之一是摆脱阻塞IO，并寻找传统命令式编程的替代方案。
- en: 'Web applications backed by a Servlet container are inherently blocking, and
    Spring 5 did a great deal in web application development by introducing a fresh
    web application framework based on reactive programming: Spring WebFlux.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由Servlet容器支持的Web应用程序本质上是阻塞的，Spring 5通过引入基于响应式编程的新鲜Web应用程序框架——Spring WebFlux，在Web应用程序开发方面做出了大量贡献。
- en: Spring also has embraced Rx and has used it in many ways within Spring 5\. With
    Spring 5, reactive features are baked into it in many aspects, helping developers
    to embrace reactive programming easily in a slow-paced manner.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring也接纳了Rx，并在Spring 5中以多种方式使用它。在Spring 5中，响应式特性被集成到许多方面，帮助开发者以缓慢的速度轻松地拥抱响应式编程。
- en: Pivotal is heavily invested in Reactor but has exposed APIs, allowing developers
    to choose the library of their choice between Reactor and RxJava.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal在Reactor上投入了大量精力，但已公开API，允许开发者在Reactor和RxJava之间选择他们喜欢的库。
- en: 'The following diagram depicts Spring 5''s reactive programming support:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了Spring 5的响应式编程支持：
- en: '![](img/d655fc0b-14d0-4f74-a358-9d23692d570a.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d655fc0b-14d0-4f74-a358-9d23692d570a.png)'
- en: 'Figure 5: Spring Framework + Reactor + Rx'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：Spring Framework + Reactor + Rx
- en: Reactor is Pivotal's (**SpringSource**) answer to implementing Reactive Streams
    Specification. As mentioned earlier, Spring is heavily invested in Reactor and
    this section aims to delve a bit deeper into Reactor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是Pivotal（**SpringSource**）对实现响应式流规范的反应式库的回应。如前所述，Spring在Reactor上投入了大量精力，本节旨在更深入地探讨Reactor。
- en: Reactor is a fourth-generation reactive library for building non-blocking applications
    on the JVM based on the Reactive Streams Specification.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是一个基于响应式流规范的第四代反应式库，用于在JVM上构建非阻塞应用程序。
- en: 'An overview of the history of **Project Reactor** can be pictorially represented
    in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Project Reactor**的历史概述可以通过以下图示表示：'
- en: '![](img/dac8af45-ddb4-4573-bf79-0c71571f4115.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dac8af45-ddb4-4573-bf79-0c71571f4115.png)'
- en: 'Figure 6: Project Reactor history'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Project Reactor历史
- en: The figure above shows the major releases of Project Reactor. The project kick
    started in the year 2013 (1.x version) and the major release of 3.x was released
    in the year 2016\. As of writing this book, the core module of the framework is
    at version 3.1.8.RELEASE.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了Project Reactor的主要版本发布。该项目始于2013年（1.x版本），3.x版本的主要发布在2016年。截至撰写本书时，框架的核心模块版本为3.1.8.RELEASE。
- en: Now that we have a brief understanding of Spring Framework and its connection
    with reactive programming, lets dive a bit deep into Project Reactor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Spring Framework及其与响应式编程的联系有了初步的了解，让我们更深入地探讨一下Project Reactor。
- en: Modules in Reactor
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor的模块
- en: With the latest release of Reactor 3.0 the project has been structured with
    modularity in mind. Reactor 3.0 consists of four major components namely Core,
    IO, Addons, and Reactive Streams Commons.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reactor 3.0 的最新版本中，项目以模块化的方式构建。Reactor 3.0 由四个主要组件组成，即核心、IO、附加组件和反应式流公共组件。
- en: '**Reactor Core** ([https://github.com/reactor/reactor-core](https://github.com/reactor/reactor-core)):
    The main library within Reactor. It provides foundational, non-blocking JVM-compliant
    Reactive Streams Specification implementations. It also contains code for Reactor
    types, such as `Flux` and `Mono`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor 核心库** ([https://github.com/reactor/reactor-core](https://github.com/reactor/reactor-core))：Reactor
    中的主要库。它提供了基础的非阻塞 JVM 兼容的 Reactive Streams 规范实现。它还包含 Reactor 类型（如 `Flux` 和 `Mono`）的代码。'
- en: '**Reactor IO** ([https://github.com/reactor/reactor-ipc](https://github.com/reactor/reactor-ipc)):
    It contains backpressure-ready components that can be used to encode, decode,
    send (unicast, multicast, or request/response), and then serve connections. It
    also contains support for **Kafka** ([https://kafka.apache.org/](https://kafka.apache.org/)),
    **Netty** ([http://netty.io/](http://netty.io/)), and **Aeron** ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron)).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor IO** ([https://github.com/reactor/reactor-ipc](https://github.com/reactor/reactor-ipc))：它包含可用于编码、解码、发送（单播、多播或请求/响应）并随后服务的背压准备就绪的组件。它还包含对
    **Kafka** ([https://kafka.apache.org/](https://kafka.apache.org/))、**Netty** ([http://netty.io/](http://netty.io/))
    和 **Aeron** ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron))
    的支持。'
- en: '**Addons** ([https://github.com/reactor/reactor-addons](https://github.com/reactor/reactor-addons)):
    As the name suggests, these are add-ons that consist of three components:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加组件** ([https://github.com/reactor/reactor-addons](https://github.com/reactor/reactor-addons))：正如其名所示，这些是包含三个组件的附加组件：'
- en: '`reactor-adapter`: Contains a bridge to RxJava 1 or 2 types, such as Observable,
    Completable, Single, Maybe, and Mono/Flux back and forth.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-adapter`：包含一个连接到 RxJava 1 或 2 类型（如 Observable、Completable、Single、Maybe
    和 Mono/Flux）的桥梁，实现双向转换。'
- en: '`reactor-logback`: Supports logback over asynchronous reactor-core processors.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-logback`：支持异步 reactor-core 处理器上的 logback。'
- en: '`reactor-extra`: Contains more operations for `Flux`, which include mathematical
    operations such as sum and average.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-extra`：包含更多针对 `Flux` 的操作，包括数学运算，如求和和平均值。'
- en: '**Reactive Streams Commons **([https://github.com/reactor/reactive-streams-commons](https://github.com/reactor/reactive-streams-commons)):
    A collaboration experiment project between Spring''s Reactor and RxJava. It also
    contains Reactor-Streams-compliant operators that both projects implement. Issues
    fixed on one project are also fixed on the other.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive Streams Commons** ([https://github.com/reactor/reactive-streams-commons](https://github.com/reactor/reactive-streams-commons))：Spring
    的 Reactor 和 RxJava 之间的协作实验项目。它还包含两个项目都实现的符合 Reactor-Streams 规范的算子。在一个项目中修复的问题也会在另一个项目中修复。'
- en: Reactive types in Reactor Core
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 核心中的反应式类型
- en: Reactor provided two reactive types, `Flux` and `Mono`, that implement Rx extensively.
    They can be represented as a timeline in which elements are sequenced according
    to how they arrived. It is important that you get the hang of these two types.
    Let's do that in the following subsections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 反应堆提供了两种反应类型，`Flux` 和 `Mono`，它们广泛实现了 Rx。它们可以表示为一个时间线，其中元素根据它们到达的顺序进行排序。掌握这两种类型非常重要。让我们在以下小节中这样做。
- en: The Flux reative type
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flux` 反应式类型'
- en: 'A Reactive Streams publisher with Rx operators that emits *0* to *N* elements,
    and then completes (successfully or with an error). For more information, you
    can check the following link: [https://projectreactor.io](https://projectreactor.io)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有 Rx 算子的反应式流发布者，它发出从 *0* 到 *N* 个元素，然后完成（成功或出错）。有关更多信息，您可以查看以下链接：[https://projectreactor.io](https://projectreactor.io)
- en: '`Flux<T>` is a `Publisher<T>` with basic flow operations and supports *0.*.*n*
    elements.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux<T>` 是一个具有基本流操作的 `Publisher<T>`，支持 *0.*.*n* 个元素。'
- en: 'The definition of `Flux` is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux` 的定义如下：'
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following figure, as depicted in the `Flux` documentation, explains the
    working of `Flux` in more detail:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图，如图 `Flux` 文档中所示，更详细地解释了 `Flux` 的工作原理：
- en: '![](img/5e2ee3fa-4291-4813-9457-d4404fec9a26.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e2ee3fa-4291-4813-9457-d4404fec9a26.png)'
- en: 'Figure 7: Working of Flux'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：`Flux` 的工作原理
- en: Flux support is in Spring 5 and a variety of other important modules, including
    Spring Security. Operators acting on `Flux` would create new publishers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux` 的支持在 Spring 5 以及其他许多重要模块中，包括 Spring Security。对 `Flux` 执行操作的算子将创建新的发布者。'
- en: 'Please refer to the Reactor Flux documentation for more information: [https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 Reactor Flux 文档以获取更多信息：[https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)。
- en: 'Now, let''s have a look at some code examples where usage of `Flux` is shown:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些展示 `Flux` 用法的代码示例：
- en: 'Creating empty `Flux`:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建空的 `Flux`：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Creating `Flux` with items in it:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含项的 `Flux`：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Creating `Flux` from an existing list:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有列表创建 `Flux`：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Creating `Flux` that emits every `x` milliseconds in an infinite manner:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建以无限方式每隔 `x` 毫秒发出元素的 `Flux`：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating `Flux` that emits an exception:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发出异常的 `Flux`：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Mono reactive type
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Mono` 响应式类型'
- en: A Reactive Streams Publisher with basic Rx operators that completes successfully
    by emitting an element, or with an error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有基本 Rx 操作符的响应式流 `Publisher`，通过发出一个元素或错误成功完成。
- en: – Mono JavaDoc
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: – `Mono` JavaDoc
- en: '`Mono<T>` is a `Publisher<T>` that supports *0*..*1* elements.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono<T>` 是一个支持 *0*..*1* 个元素的 `Publisher<T>`。'
- en: 'The definition of `Mono` is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono` 的定义如下：'
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As detailed in the documentation, the following figure shows the workings of
    `Mono`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中详细说明，以下图展示了 `Mono` 的工作原理：
- en: '![](img/fcab5a6e-6e9e-40b6-a689-b0d0abe4ed0a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcab5a6e-6e9e-40b6-a689-b0d0abe4ed0a.png)'
- en: 'Figure 08: Working of Mono'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 08：Mono 的工作原理
- en: '`Mono<Void>` should be used for a `Publisher` that completes with no value.
    The documentation explains each method and how it works using a marble diagram,
    which is self-explanatory. Again, this type is also supported by Spring 5 and
    Spring Security.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用 `Mono<Void>` 来表示一个完成时没有值的 `Publisher`。文档通过使用图例解释了每个方法及其工作原理，图例是自我解释的。再次强调，这种类型也由
    Spring 5 和 Spring Security 支持。
- en: 'JavaDoc for `Mono` contains more information: [https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono` 的 JavaDoc 包含更多信息：[https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)。'
- en: 'Let''s have a look at some examples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: Creating empty `Mono:`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建空的 `Mono`：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating `Mono` with a value in it:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含值的 `Mono`：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Creating `Mono` that emits an exception:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发出异常的 `Mono`：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data stream types
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流类型
- en: 'Broadly, data streams can be categorized into two types:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，数据流可以分为两种类型：
- en: '**Cold data streams**: There are a number of names by which this is known,
    such as **Cold Source**, **Cold Observable**, and **Cold Publisher**. These emit
    data only when one subscribes to it and because of this, all messages produced
    from start are delivered to the subscriber. If a new `Subscriber` connects to
    it, the messages are replayed in ascending order and this is same for any new
    `Subscriber`. The `Subscriber` also has a provision to dictate the rate at which
    the `Publisher` should emit messages. These data streams are good candidates for
    applying reactive backpressure (`request(n)`), for example, a database cursor
    or file stream (reading a file).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷数据流**：这有几个名称，例如 **冷源**、**冷可观察对象**和**冷 Publisher**。只有当订阅者订阅时，它们才会发出数据，因此从开始产生的所有消息都发送给订阅者。如果新的
    `Subscriber` 连接到它，消息将按顺序重新播放，并且这对任何新的 `Subscriber` 都是相同的。`Subscriber` 还有一个规定 `Publisher`
    应该以多快的速度发出消息的选项。这些数据流是应用响应式背压（`request(n)`）的良好候选者，例如数据库游标或文件流（读取文件）。'
- en: '**Hot data streams**: Again, this has a number of different names, such as
    **Hot Source**, **Hot Observable**, and **Hot Publisher**. These emit data irrespective
    of any subscribers connected. When a new `Subscriber` connects, it just emits
    the messages from that point in time and cannot replay messages from the start.
    These cannot pause message emissions, so an alternate mechanism is required to
    control flow, such as a buffer. Examples of this stream include mouse events and
    stock prices.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热数据流**：同样，这有几个不同的名称，例如 **热源**、**热可观察对象**和**热 Publisher**。这些在不考虑任何连接的订阅者的情况下发出数据。当新的
    `Subscriber` 连接时，它只从那个时间点开始发出消息，并且不能从开始处重新播放消息。这些不能暂停消息的发出，因此需要一个替代机制来控制流，例如缓冲区。这种流的一个例子包括鼠标事件和股票价格。'
- en: It's important to note that operators on a stream can change their property,
    going from cold to hot and vice versa. Also, there are times when a merge between
    hot and cold can happen and their properties change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，流上的算子可以改变它们的属性，从冷到热，反之亦然。有时还会发生热和冷的合并，它们的属性也会改变。
- en: Reactor and RxJava
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 和 RxJava
- en: One of the main aspects between the two is RxJava 2.x which is Java 6+ compatible,
    but Reactor is Java 8+ compatible. If you are going with Spring 5, I urge you
    to use a Reactor. If you are comfortable with RxJava 2.x, there is no need to
    migrate to Reactor. Reactor is an implementation of the Reactive Streams Specification,
    so you can remain agnostic of what the underlying implementation is.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别之一是 RxJava 2.x，它与 Java 6+ 兼容，但 Reactor 与 Java 8+ 兼容。如果您选择使用 Spring
    5，我强烈建议您使用 Reactor。如果您对 RxJava 2.x 感到舒适，就没有必要迁移到 Reactor。Reactor 是响应式流规范的实现，因此您可以保持对底层实现的无知。
- en: Reactive Web Application
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式网络应用程序
- en: Spring 5 has brought reactive concepts into the world of web application development
    with the inclusion of a number of important components. Let's cover them here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5 通过包含一些重要组件，将响应式概念引入了网络应用程序开发的世界。让我们在这里介绍它们。
- en: Spring WebFlux
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring 5 has a reactive stack baked into it, using which, web applications can
    be built on top of Reactive Streams capable of running on new non-blocking servers,
    such as Netty, Undertow, and Servlet containers, running on Servlet specifications
    greater than 3.1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5 内置了响应式堆栈，使用它，可以在支持运行在新的非阻塞服务器（如 Netty、Undertow 和 Servlet 容器）上的响应式流上构建网络应用程序，这些
    Servlet 规范的版本大于 3.1。
- en: Existing web application frameworks, such as Spring MVC, are built for Servlet
    containers from the outset, but Spring 5 brings with it a new web application
    framework, Spring WebFlux, created with reactive in mind. We have a dedicated
    chapter in this book covering Spring WebFlux ([Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*), so I won't be delving deep into this here.
    It's good to know that Spring 5 has serious thoughts on reactive and that it is
    reflected clearly in all these new additions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的网络应用程序框架，如 Spring MVC，从一开始就是为 Servlet 容器构建的，但 Spring 5 带来一个新的网络应用程序框架，Spring
    WebFlux，它是基于响应式设计的。本书中有一章专门介绍 Spring WebFlux（[第 5 章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)，*与
    Spring WebFlux 集成*），因此在这里不会深入探讨。值得知道的是，Spring 5 对响应式有严肃的思考，并且这一点在这些新增功能中得到了清晰的体现。
- en: Spring WebFlux requires Reactor to be included as one of its core dependencies.
    But, as always, it does allow you to switch implementations quite easily, if needs
    be.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 需要将 Reactor 作为其核心依赖之一。但，就像往常一样，它确实允许您在需要时轻松切换实现。
- en: Reactive Spring Web
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式 Spring Web
- en: The **Spring Web Module** ([https://github.com/spring-projects/spring-framework/tree/master/spring-web](https://github.com/spring-projects/spring-framework/tree/master/spring-web))
    has many foundational pieces used to build reactive web applications. It allows
    you to do operations pertaining to the server and the client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Web 模块** ([https://github.com/spring-projects/spring-framework/tree/master/spring-web](https://github.com/spring-projects/spring-framework/tree/master/spring-web))
    包含了许多用于构建响应式网络应用程序的基础组件。它允许您执行与服务器和客户端相关的操作。'
- en: 'The capabilities that it provides on the server are divided into two areas:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它在服务器上提供的功能分为两个领域：
- en: '**HTTP**: Contained within the `org.springframework.http` package in `spring-web`
    and contains various APIs for HTTP request handling for supported servers'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**：包含在 `spring-web` 中的 `org.springframework.http` 包内，包含用于支持的服务器 HTTP
    请求处理的多种 API'
- en: '**Web**: Contained within the `org.springframework.web` package in `spring-web`
    and contains various APIs for request processing'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**：包含在 `spring-web` 中的 `org.springframework.web` 包内，包含用于请求处理的多种 API'
- en: This module also contains message codecs that work on the client and aid in
    encoding and decoding requests and responses. These codecs can also be used on
    the server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块还包含在客户端工作的消息编解码器，有助于编码和解码请求和响应。这些编解码器也可以在服务器上使用。
- en: WebClient
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: The interface `org.springframework.web.reactive.function.client.WebClient` is
    a reactive web client introduced in Spring 5 that can be used to perform web requests.
    Similarly there is `org.springframework.test.web.reactive.server.WebTestClient`
    interface, which is a special `WebClient`—used to write unit tests within your
    application. `WebClient` is the reactive version of `RestTemplate`, which works
    over the HTTP/1.1 protocol. They are packaged as part of the `spring-webflux`
    module.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `org.springframework.web.reactive.function.client.WebClient` 是 Spring 5 中引入的一个响应式网络客户端，可用于执行网络请求。同样，还有一个
    `org.springframework.test.web.reactive.server.WebTestClient` 接口，这是一个特殊的 `WebClient`——用于在您的应用程序中编写单元测试。`WebClient`
    是 `RestTemplate` 的响应式版本，它通过 HTTP/1.1 协议工作。它们被打包为 `spring-webflux` 模块的一部分。
- en: WebSockets
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets
- en: The `spring-webflux` module also has reactive WebSocket implementation. **WebSocket**
    allows us to establish a two-way connection between the client and server, and
    usage of this is becoming more mainstream in new-generation applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-webflux`模块也具有反应式WebSocket实现。**WebSocket**允许我们在客户端和服务器之间建立双向连接，并且在新一代应用程序中使用这种技术的趋势正在变得更加普遍。'
- en: Application security
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全
- en: '**Application security** is composed of various processes put in place to find,
    fix, and prevent security vulnerabilities in an application.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序安全**由各种流程组成，旨在发现、修复和防止应用程序中的安全漏洞。'
- en: We are living in the world of **Development + Operations** (**DevOps**) where
    we bring engineering and operational staff together. DevOps advocates automation
    and monitoring at all levels. With security becoming a very important consideration,
    a new term, **DevSecOps**, is becoming prominent—this is where we bring in security
    as a first-class citizen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个**开发+运维**（**DevOps**）的世界中，我们将工程和运营人员聚集在一起。DevOps倡导在所有层面进行自动化和监控。随着安全变得越来越重要，一个新的术语**DevSecOps**正在变得突出——这就是我们将安全作为一等公民引入的地方。
- en: For an application, security comes under the nonfunctional requirements. Due
    to its importance in an application, most organizations have dedicated teams that
    test applications for potential security flaws. It's a very important aspect to
    be considered, as in this modern world, a security breach can seriously ruin an
    organization's brand.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个应用程序来说，安全属于非功能性需求。由于其在一个应用程序中的重要性，大多数组织都有专门的团队来测试应用程序以发现潜在的安全漏洞。这是一个非常重要的考虑因素，因为在现代世界中，安全漏洞可能会严重破坏一个组织的品牌。
- en: Security is a very broad term and encompasses many aspects. In this book, we
    will look at some of the fundamental security concerns using the Spring Framework
    module—Spring Security. After covering some of the core security concerns, we
    will also look at some of the low-level security problems and how Spring Security
    can help deal with them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个非常广泛的概念，包括许多方面。在这本书中，我们将使用Spring框架模块——Spring Security来探讨一些基本的安全问题。在覆盖了一些核心安全问题之后，我们还将探讨一些低级安全问题以及Spring
    Security如何帮助解决这些问题。
- en: Since we will be focusing on Spring, we will be delving deep into security concerns
    with respect to a Java web application development.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将专注于Spring，我们将深入探讨Java Web应用程序开发中的安全相关问题。
- en: Spring Security
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security is a powerful and highly customizable authentication and access-control
    framework. It is the de facto standard for securing Spring-based applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个强大且高度可定制的身份验证和访问控制框架。它是基于Spring的应用程序安全的事实标准。
- en: – Spring by Pivotal
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: – Spring by Pivotal
- en: Spring Security 5 is the new version of the framework and will be the main focus
    of this book. Spring Security enables you to take care of authentication and authorization
    of your application in all aspects. It also has top-level projects to deal specifically
    with a number of authentication mechanisms, such as **LDAP**, **OAuth**, and **SAML**.
    Spring Security also gives you enough mechanisms to deal with common security
    attacks, such as **Session Fixation**, **Clickjacking**, and **Cross-Site Request
    Forgery**. Moreover, it has very good integration with a number of Spring Framework
    projects, such as Spring MVC, Spring WebFlux, Spring Data, Spring Integration,
    and Spring Boot.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 5是框架的新版本，并将成为本书的主要内容。Spring Security使您能够从各个方面处理应用程序的身份验证和授权。它还拥有顶级项目，专门处理多种身份验证机制，例如**LDAP**、**OAuth**和**SAML**。Spring
    Security还提供了足够的机制来处理常见的安全攻击，如**会话固定**、**点击劫持**和**跨站请求伪造**。此外，它与许多Spring框架项目（如Spring
    MVC、Spring WebFlux、Spring Data、Spring Integration和Spring Boot）有很好的集成。
- en: Spring Security terminologies
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security术语
- en: 'It''s important to understand some of the most important Spring Security terminologies.
    Let''s look at some of them:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一些最重要的Spring Security术语非常重要。让我们来看看其中的一些：
- en: '**Principal**: Any user, device, or system (application) that would like to
    interact with your application.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原则**：任何希望与您的应用程序交互的用户、设备或系统（应用程序）。'
- en: '**Authentication**: A process by which your application makes sure that the
    principal is who they claim to be.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：一个过程，您的应用程序通过这个过程确保主体是其声明的身份。'
- en: '**Credentials**: When a principal tries to interact with your application,
    the authentication process kicks in and challenges the principal to pass on some
    values. One such example is a username/password combination and these values are
    called credentials. The authentication process validates the principal''s passed-in
    credentials against a data store and replies back with the appropriate result.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证**：当主体尝试与您的应用程序交互时，身份验证过程开始并要求主体传递一些值。一个这样的例子是用户名/密码组合，这些值被称为凭证。身份验证过程将主体传递的凭证与数据存储进行验证，并返回相应的结果。'
- en: '**Authorization**: After successful authentication, the principal is checked
    again for actions that it can perform on your application. This process of checking
    rights for a principal and then granting necessary permissions is called authorization.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：在成功身份验证后，主体将再次检查它可以在您的应用程序上执行的操作。这个过程是检查主体的权利，然后授予必要的权限，称为授权。'
- en: '**Secured item/resource**: The item or resource that is marked as secured and
    requires the principal (user) to successfully complete both authentication and
    authorization.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护项/资源**：被标记为受保护并需要主体（用户）成功完成身份验证和授权的项或资源。'
- en: '**GrantedAuthority**: A Spring Security object (`org.springframework.security.core.GrantedAuthority`
    interface) that contains/holds permissions/access-right details of a principal.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GrantedAuthority**：一个包含/持有主体权限/访问权限详细信息的 Spring Security 对象（`org.springframework.security.core.GrantedAuthority`
    接口）。'
- en: '**SecurityContext**: A Spring Security object that holds a principal''s authentication
    details.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecurityContext**：一个包含主体身份验证详细信息的 Spring Security 对象。'
- en: Spring Security's core features
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 的核心功能
- en: Spring Security provides a number of security features for your application.
    The two main features for which Spring Security is well-known are it's **support
    for a variety of authentication** and **authorization methodologies**. In this
    section, we will delve deeply into these core features in more detail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 为您的应用程序提供了一系列安全功能。Spring Security 最著名的两个主要功能是它对各种身份验证**支持**和**授权方法**。在本节中，我们将更深入地探讨这些核心功能。
- en: Authentication
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**身份验证**'
- en: Spring Security provides a number of approaches by which your application can
    authenticate. It also allows you to write a custom authentication mechanism if
    these provided default approaches don't fit your requirements. Because of this
    extensibility, you can even use the legacy application against which authentication
    can be done. The book has a dedicated chapters ([Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication
    Using SAML, LDAP, and OAuth/OIDC* and [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml),
    *Authentication Using CAS and JAAS*) where we will cover various authentications
    mechanisms, such as OAuth, LDAP, and SAML, in more detail.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了多种方法，您的应用程序可以通过这些方法进行身份验证。它还允许您编写自定义的身份验证机制，如果这些提供的默认方法不符合您的需求。由于这种可扩展性，您甚至可以使用可以进行身份验证的旧应用程序。本书有专门的章节（[第
    3 章](69913c59-1186-44b2-8707-dceca721e206.xhtml)，*使用 SAML、LDAP 和 OAuth/OIDC 进行身份验证*和[第
    4 章](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml)，*使用 CAS 和 JAAS 进行身份验证*），我们将更详细地介绍各种身份验证机制，如
    OAuth、LDAP 和 SAML。
- en: Authorization
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'Spring Security allows you, as an application developer, many choices by which
    you can authorize user''s access to various parts of your application. Here are
    some of the approaches:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 允许您作为应用程序开发者，有多种选择来授权用户访问应用程序的各个部分。以下是一些方法：
- en: '**Web URL**: Based on a URL or URL pattern, you can control access'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web URL**：基于 URL 或 URL 模式，您可以控制访问'
- en: '**Method invocation**: Even a method in a Java Bean can be access-controlled
    if needs be'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用**：即使是 Java Bean 中的方法，如果需要，也可以进行访问控制'
- en: '**Domain instance**: One of the very cool features is to control access to
    specific data by having access control of certain needed domain objects within
    your application'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域实例**：一个非常酷的功能是可以通过对应用中某些所需域对象进行访问控制来控制对特定数据的访问'
- en: '**Web service**: Allows you to secure exposed web services in your application'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务**：允许您保护应用程序中公开的 Web 服务'
- en: In the next chapter, we will get into these aspects in a bit more detail with
    more code snippets.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过更多的代码片段对这些方面进行更详细的介绍。
- en: Spring Security 5's new features
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 5 的新功能
- en: 'Spring Security 5 provides a number of new features along with support for
    Spring 5\. Some of the important new features introduced as part of this release
    are:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 5 提供了许多新功能，并支持Spring 5。作为此版本的一部分引入的一些重要新功能包括：
- en: '**Support for OAuth 2.0 and OpenID Connect (OIDC) 1.0**: Allows users to log
    in to your application using their existing OAuth provider (for example, GitHub)
    or OIDC provider (for example, Google). OAuth is implemented using Authorization
    Code Flow. We will delve deep into this in subsequent chapters.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持OAuth 2.0和OpenID Connect (OIDC) 1.0**：允许用户使用他们现有的OAuth提供者（例如，GitHub）或OIDC提供者（例如，Google）登录到您的应用程序。OAuth使用授权码流实现。我们将在后续章节中深入探讨这一点。'
- en: '**Reactive support**: Spring 5 introduced a new reactive web application framework—Spring
    WebFlux. Spring Security made sure that this web application framework is fully
    supported in all aspects (authentication and authorization) using reactive concepts.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式支持**：Spring 5 引入了一个新的响应式Web应用框架——Spring WebFlux。Spring Security 确保这个Web应用框架在所有方面（认证和授权）都完全支持响应式概念。'
- en: '**Improved password encoding**: The introduction of the password-encoding delegation
    allows usage of more than one algorithm for encoding various passwords. The way
    Spring identifies the algorithm is by reading the prefix of the encoded password,
    which contains the algorithm used to encode the password. The format is `{algorithm}encoded_password`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的密码编码**：密码编码委托的引入允许使用多个算法对各种密码进行编码。Spring通过读取编码密码的前缀来识别算法，该前缀包含用于编码密码的算法。格式为
    `{algorithm}encoded_password`。'
- en: Working of Spring Security
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security的工作原理
- en: In this section, we will look at how Spring Security works. We will first explain
    the core concepts and then look at various classes the request goes through to
    perform security.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Spring Security的工作原理。我们首先解释核心概念，然后查看请求在执行安全操作时经过的各种类。
- en: Servlet Filter
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet Filter
- en: It's quite important to understand Servlet Filter so you can understand Spring
    Security internals. The following figure clearly explains a Servlet Filter in
    action. It comes before the request reaches the actual resource and also before
    the response if sent back to the consumer. It's a pluggable component that can
    be introduced at any time with configuration in the web configuration file (`web.xml`).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Servlet Filter非常重要，这样您才能理解Spring Security的内部机制。以下图清晰地解释了Servlet Filter的实际操作。它位于请求到达实际资源之前，以及响应返回给消费者之前。它是一个可插入的组件，可以在任何时间通过在web配置文件（`web.xml`）中进行配置来引入。
- en: '![](img/88799858-7e56-4fe9-92b4-039eb75ddc96.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88799858-7e56-4fe9-92b4-039eb75ddc96.png)'
- en: 'Figure 9: Working of Servlet Filter'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：Servlet Filter的工作原理
- en: Filter Chain
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器链
- en: You can embed any number of Servlet Filters before they reach the actual resource.
    The filters are fired according to the order in which they are declared in `web.xml`.
    This chaining of the Servlet Filter is called **Filter Chain**. Spring Security
    works on a number of Servlet Filters arranged as a Filter Chain, each filter performing
    a single responsibility, then handing it over to the next one, and so on. Most
    of the built-in filters are good enough for most applications. If needs be, you
    can write your own filters and place them wherever you want them to be executed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在实际资源之前嵌入任意数量的Servlet Filter。这些过滤器根据它们在`web.xml`中声明的顺序被触发。这种Servlet Filter的链式调用称为**过滤器链**。Spring
    Security在一系列Servlet Filter上工作，这些Filter被组织成过滤器链，每个Filter执行单一职责，然后将它传递给下一个，依此类推。大多数内置的过滤器对于大多数应用来说已经足够好了。如果需要，您可以编写自己的过滤器并将它们放置在您希望它们执行的位置。
- en: Security Interceptor (DelegatingFilterProxy)
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全拦截器（DelegatingFilterProxy）
- en: 'When any request reaches an application that is secured using Spring Security,
    there is a gate the request goes through. This interceptor does all the magic
    and if things don''t look good, it errors out and goes back to the caller, as
    shown in the following figure:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何请求达到使用Spring Security进行安全保护的程序时，请求会通过一个门。这个拦截器执行所有魔法，如果情况不佳，它会报错并返回给调用者，如下面的图所示：
- en: '![](img/023819ce-1ee5-40a6-9366-716cf9c6dcb9.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/023819ce-1ee5-40a6-9366-716cf9c6dcb9.png)'
- en: 'Figure 10: Working of Security Interceptor'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：安全拦截器的工作原理
- en: 'The Security Interceptor makes sure that, according to various security configurations
    set up for your application, it delegates the work to appropriate parties and
    makes sure that everyone is happy before actually reaching the resource requested
    by the caller. To do the actual job, the Security Interceptor employs a number
    of managers, each entrusted to do a single job. The following figure lists some
    of the important managers the Security Interceptor works with to perform the function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 安全拦截器确保根据为你的应用程序设置的各种安全配置，将工作委托给适当的当事人，并在实际到达调用者请求的资源之前确保每个人都满意。为了完成实际工作，安全拦截器使用多个管理器，每个管理器负责一项单独的工作。以下图列出了安全拦截器在执行功能时与之合作的一些重要管理器：
- en: '![](img/be0f39f5-a970-440b-9014-9cc92ce1a762.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/be0f39f5-a970-440b-9014-9cc92ce1a762.png)'
- en: 'Figure 11: Security Interceptor and associated managers'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：安全拦截器和相关管理器
- en: In Spring Security, the Security Interceptor is accomplished by `DelegatingFilterProxy`.
    For any request that reaches the web application, this proxy makes sure to delegate
    the request to Spring Security, and when things go well, it makes sure that the
    request is taken to the right resource within the web application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中，安全拦截器是通过`DelegatingFilterProxy`实现的。对于任何到达Web应用的请求，这个代理确保将请求委托给Spring
    Security，并且当一切顺利时，确保请求被带到Web应用中的正确资源。
- en: '`DelegatingFilterProxy` is a Servlet Filter that has to be configured in your
    `web.xml` file, which then delegates to a Spring-managed bean (`@Bean`) that implements
    a `ServletFilter` interface.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelegatingFilterProxy`是一个需要在你的`web.xml`文件中配置的Servlet Filter，它随后将委托给一个实现`ServletFilter`接口的Spring管理的bean（`@Bean`）。'
- en: 'The following code snippet shows how to configure `DelegatingProxyFilter` in
    `web.xml`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何在`web.xml`中配置`DelegatingProxyFilter`：
- en: '[PRE14]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, all the requests to the web application (`/* mapping`)
    would go through the `DelegatingProxyFilter` filter. It's important to note that
    the name of this filter should be `springSecurityFilterChain` as Spring Security
    looks for this default filter name to configure itself. The proxy filter just
    passes/delegates the control to a bean named `springSecuirtyFilterChain`. If you
    are using the default Spring Security setup, the request would then be received
    by `FilterChainProxy`. `FilterChainProxy` is responsible for passing the request
    through the various Servlet Filters configured as part of Spring Security. The `springSecuirtyFilterChain` bean
    need not be explicitly declared, instead, it is taken care of by the framework
    which is transparent to the developer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，所有对Web应用的请求（`/* mapping`）都会通过`DelegatingProxyFilter`过滤器。需要注意的是，这个过滤器的名称应该是`springSecurityFilterChain`，因为Spring
    Security会查找这个默认的过滤器名称来自动配置自己。代理过滤器只是将控制权委托给一个名为`springSecuirtyFilterChain`的bean。如果你使用的是默认的Spring
    Security配置，请求就会被`FilterChainProxy`接收。`springSecuirtyFilterChain` bean不需要显式声明，相反，框架会自动处理，对开发者来说是透明的。
- en: 'Now that we''ve looked at all the core concepts of Spring Security, let''s
    come back to the working of Spring Security as pictorially represented in the
    following diagram. It contains two important security aspects –Authentication
    and Authorization:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Spring Security的所有核心概念，让我们回到Spring Security的工作原理，如图所示。它包含两个重要的安全方面——认证和授权：
- en: '![](img/ad01cc0a-91da-4c35-9cf5-dd8cf2722f0a.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/ad01cc0a-91da-4c35-9cf5-dd8cf2722f0a.png)'
- en: 'Figure 12: Working of Spring Security'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：Spring Security的工作原理
- en: The request from the caller reaches `DelegatingFilterProxy`, which delegates
    to `FilterChainProxy` (Spring Bean), which in turn passes the request through
    a number of filters, and after successful execution, grants access to the secured
    resource the caller has asked for.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者的请求达到`DelegatingFilterProxy`，它委托给`FilterChainProxy`（Spring Bean），然后通过一系列过滤器传递请求，在成功执行后，授予调用者请求的受保护资源的访问权限。
- en: 'For the complete list of Servlet Filters and their functions, I urge you to
    go through the Spring Security reference: [https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Servlet Filter及其功能的完整列表，我强烈建议你查阅Spring Security参考文档：[https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html)。
- en: 'With all these details, the following figure sums up how Spring Security takes
    care of Authentication and Authorization for your web application:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些细节的基础上，以下图总结了Spring Security如何处理您的Web应用程序的身份验证和授权：
- en: '![](img/ef2f262d-a6e6-4e88-9131-9f321aa9bf14.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef2f262d-a6e6-4e88-9131-9f321aa9bf14.png)'
- en: 'Figure 13: Authentication and Authorization in Spring Security using a database'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：使用数据库在Spring Security中进行身份验证和授权
- en: When a caller sends a request to a web application protected by Spring Security,
    it first goes through the Security Interceptor managers, such as **Authentication
    Manager** (responsible for authentication) and **Access Decision Manager** (responsible
    for authorization), and after executing these successfully, gives the caller access
    to the secured resource.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用者向受Spring Security保护的Web应用程序发送请求时，它首先通过安全拦截器管理器，如**身份验证管理器**（负责身份验证）和**访问决策管理器**（负责授权），在成功执行这些操作后，给调用者访问受保护资源的权限。
- en: For reactive applications, these concepts are all valid. There are equivalent
    reactive classes and the way we code is the only thing that changes. These are
    easy to understand and implement.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应式应用程序，这些概念都是有效的。存在等效的响应式类，而我们编码的方式是唯一需要改变的地方。这些很容易理解和实现。
- en: In [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep Diving into
    Spring Security*, we will cover Authentication, and in [Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication
    Using SAML, LDAP, and OAuth/OIDC*, we will cover Authorization in detail and delve
    a bit more deeply into its internals.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)，*深入Spring Security*，我们将介绍身份验证，在[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)，*使用SAML、LDAP和OAuth/OIDC进行身份验证*，我们将详细介绍授权并深入探讨其内部机制。
- en: Core Spring Security modules
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心Spring Security模块
- en: 'In Spring Framework, Spring Security is a top-level project. Within the Spring
    Security project ([https://github.com/spring-projects/spring-security](https://github.com/spring-projects/spring-security)),
    there are a number of sub-modules:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，Spring Security是一个顶级项目。在Spring Security项目中([https://github.com/spring-projects/spring-security](https://github.com/spring-projects/spring-security))，存在多个子模块：
- en: '**Core** (`spring-security-core`): Spring security''s core classes and interfaces
    on authentication and access control reside here.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心** (`spring-security-core`): Spring安全的核心类和接口，关于身份验证和访问控制，都位于此处。'
- en: '**Remoting** (`spring-security-remoting`): In case you need Spring Remoting,
    this is the module with the necessary classes.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程** (`spring-security-remoting`): 如果需要Spring Remoting，这是包含必要类的模块。'
- en: '**Aspect** (`spring-security-aspects`): **Aspect-Oriented Programming** (**AOP**)
    support within Spring Security.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方面** (`spring-security-aspects`): 在Spring Security中支持面向切面编程(**AOP**)。'
- en: '**Config** (`spring-security-config`): Provides XML and Java configuration
    support.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置** (`spring-security-config`): 提供XML和Java配置支持。'
- en: '**Crypto** (`spring-security-crypto`): Contains cryptography support.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密** (`spring-security-crypto`): 包含加密支持。'
- en: '**Data** (`spring-security-data`): Integration with Spring Data.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据** (`spring-security-data`): 与Spring Data集成。'
- en: '**Messaging** (`spring-security-messaging`)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递** (`spring-security-messaging`)'
- en: '**OAuth2**: Support for OAuth 2.x support within Spring Security:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth2**: 在Spring Security中支持OAuth 2.x：'
- en: '**Core** (`spring-security-oauth2-core`)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心** (`spring-security-oauth2-core`)'
- en: '**Client** (`spring-security-oauth2-client`)'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端** (`spring-security-oauth2-client`)'
- en: '**JOSE** (`spring-security-oauth2-jose`)'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JOSE** (`spring-security-oauth2-jose`)'
- en: '**OpenID** (`spring-security-openid`): OpenID web-authentication support.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenID** (`spring-security-openid`): 提供OpenID网络身份验证支持。'
- en: '**CAS** (`spring-security-cas`): CAS (Central Authentication Service) client
    integration.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAS** (`spring-security-cas`): CAS（中央身份验证服务）客户端集成。'
- en: '**TagLib** (`spring-security-taglibs`): Various tag libraries regarding Spring
    Security.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TagLib** (`spring-security-taglibs`): 与Spring Security相关的各种标签库。'
- en: '**Test** (`spring-security-test`): Testing support.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试** (`spring-security-test`): 测试支持。'
- en: '**Web** (`spring-security-web`): Contains web security infrastructure code,
    such as various filters and other Servlet API dependencies.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web** (`spring-security-web`): 包含Web安全基础设施代码，如各种过滤器和其他Servlet API依赖项。'
- en: 'These are the top-level projects within Spring Framework that are strongly
    linked to Spring Security:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Spring框架中与Spring Security紧密相关的顶级项目：
- en: '`spring-ldap`: Simplifying **Lightweight Directory Access Protocol** (**LDAP**)
    programming in Java.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ldap`: 简化Java中的轻量级目录访问协议(**LDAP**)编程。'
- en: '`spring-security-oauth`: Easy programming with OAuth 1.x and OAuth 2.x protocols.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-oauth`: 使用 OAuth 1.x 和 OAuth 2.x 协议进行简易编程。'
- en: '`spring-security-saml`: Bringing the SAML 2.0 service provider capabilities
    to Spring applications.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-saml`：将 SAML 2.0 服务提供者功能引入 Spring 应用程序。'
- en: '`spring-security-kerberos`: Bringing easy integration of Spring application
    with Kerberos protocol.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-kerberos`：简化 Spring 应用程序与 Kerberos 协议的集成。'
- en: '**Security Assertion Markup Language** (**SAML**) is an XML-based framework
    for ensuring that transmitted communications are secure. SAML defines mechanisms
    to exchange authentication, authorization, and non-repudiation information, allowing
    single sign-on capabilities for Web services.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全断言标记语言** (**SAML**) 是一个基于 XML 的框架，用于确保传输的通信是安全的。SAML 定义了交换身份验证、授权和非否认信息的机制，允许
    Web 服务实现单点登录功能。'
- en: The **Lightweight Directory Access Protocol** (**LDAP**) is a directory service
    protocol that runs on a layer above the TCP/IP stack. Its based on a client-server
    model and provides a mechanism used to connect to, search, and modify Internet
    directories.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**轻量级目录访问协议** (**LDAP**) 是一种在 TCP/IP 堆栈之上运行的目录服务协议。它基于客户端-服务器模型，提供了一种连接到、搜索和修改互联网目录的机制。'
- en: '**Kerberos** is a network authentication protocol. It is designed to provide
    strong authentication for client/server applications by using secret key cryptography.
    A free implementation of this protocol is available from MIT and it is also available
    in many commercial products.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kerberos** 是一种网络身份验证协议。它通过使用密钥加密技术为客户端/服务器应用程序提供强大的身份验证。该协议的免费实现可以从麻省理工学院获得，并且它也包含在许多商业产品中。'
- en: 'For more information about SAML, LDAP, and Kerberos, you can check the following
    links:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SAML、LDAP 和 Kerberos 的更多信息，您可以查看以下链接：
- en: '[https://www.webopedia.com/TERM/S/SAML.html](https://www.webopedia.com/TERM/S/SAML.html)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.webopedia.com/TERM/S/SAML.html](https://www.webopedia.com/TERM/S/SAML.html)'
- en: '[https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx)'
- en: '[https://web.mit.edu/kerberos/](https://web.mit.edu/kerberos/)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://web.mit.edu/kerberos/](https://web.mit.edu/kerberos/)'
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced you to new application requirements and then
    moved to some of the core reactive concepts. We looked at the Reactive Manifesto
    and reactive programming. We then moved our attention to Spring 5 and Spring Security
    5, and touched on some of the new features in it, especially regarding reactive
    programming. We then looked briefly at Spring's reactive programming efforts by
    introducing you to Project Reactor. After that, we explored Spring Security in
    a bit more detail to refresh your thoughts on this subject. Finally, we closed
    this chapter by giving you an idea of how examples would be structured in this
    book and what coding practices we will be using.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了新的应用程序需求，然后转向了一些核心的响应式概念。我们研究了响应式宣言和响应式编程。然后，我们将注意力转向 Spring 5 和
    Spring Security 5，并简要介绍了其中的一些新功能，特别是关于响应式编程的部分。然后，我们通过向您介绍 Project Reactor 简要地了解了
    Spring 的响应式编程努力。在那之后，我们更详细地探讨了 Spring Security，以刷新您对这个主题的看法。最后，我们通过向您展示本书中示例的结构以及我们将使用的编码实践来结束本章。
- en: You should now have a good grasp on reactive programming, and on Spring Security
    and how it works. You should also have a clear understanding of how to go through
    the rest of the chapters, especially the example code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对响应式编程、Spring Security 以及其工作原理有了很好的理解。您还应该清楚地了解如何阅读本书的其余章节，特别是示例代码。
