- en: Chapter 11. Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 响应式编程
- en: 'This chapter is a little detour to reactive programming. It lets us handle
    the concurrency requirements of an application in some cases. It provides an abstraction
    to handle concurrency. Even though the concepts are old, it has gained interest
    in recent years due to the beginning of large inflow of data. In modern times,
    billions of devices generate data every day. Tapping into this data is essential
    for the growth of business; in some cases, processing the data to statistically
    analyze it or feeding it to some machine learning algorithm may be the entire
    business in itself. This makes it essential to support the processing of this
    large in-flow of data, provide a quick response, and be resilient to failures.
    Of course, one can do these things even using a traditional or imperative programming
    paradigm, just as one can, in theory, build any application using an assembly
    language. However, this makes the application extremely complex to maintain and
    impossible to modify according to business needs. In this chapter, we will discuss
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对响应式编程的一个小插曲。它让我们在某些情况下处理应用程序的并发需求。它提供了一个处理并发的抽象。尽管这些概念很古老，但由于大数据流量的开始，近年来它引起了人们的兴趣。在现代社会，每天都有数十亿设备生成数据。挖掘这些数据对于业务增长至关重要；在某些情况下，对数据进行统计分析或将数据输入到某些机器学习算法中可能是整个业务的全部。这使得支持处理这种大量流入的数据、提供快速响应和具有容错能力变得至关重要。当然，即使使用传统的或命令式编程范式也可以做这些事情，就像理论上可以使用汇编语言构建任何应用程序一样。然而，这使得应用程序的维护变得极其复杂，并且无法根据业务需求进行修改。在本章中，我们将讨论以下主题：
- en: Basic idea of reactive programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程的基本思想
- en: Building an example reactive framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个示例响应式框架
- en: Building example programs using our framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的框架构建示例程序
- en: What is reactive programming?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: Suppose we have a web server that lets us query some data or save it. This web
    server serves multiple requests at the same time, and each request is a short
    task that involves some computation. What is the usual way of achieving this?
    Well, the naive way would be to spawn a new thread for each request. But one can
    easily realize that this leads to an explosion in the number of threads in the
    application. Plus, the creation and deletion of threads are heavyweight activities;
    they slow down the entire application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个允许我们查询或保存数据的Web服务器。这个Web服务器可以同时处理多个请求，每个请求都是一个涉及一些计算的短暂任务。通常如何实现这一点呢？好吧，天真的方式是为每个请求创建一个新的线程。但人们很容易意识到这会导致应用程序中线程数量的激增。此外，线程的创建和删除是重量级活动；它们会减慢整个应用程序的速度。
- en: Next, you can use a thread pool so the same threads can be used over and over
    to avoid the overhead of creation and deletion of threads. However, if you want
    to serve thousands of requests at the same time, this will require a thread pool
    with thousands of threads. Thread scheduling in an operating system is complex
    and involves a lot of logic, including priority and so on. Operating systems do
    not expect threads to just run short bursts of computation; they are not optimized
    that way. Therefore, the solution is to use the same thread for multiple simultaneous
    requests. This can, in general, be done if we stop blocking for IO and use the
    same thread for another task when one task is waiting for I/O. Managing these
    things, however, is extremely complicated. Hence, we would need a framework to
    carry out these activities for us. Such a framework can be called a reactive framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用线程池，这样相同的线程可以反复使用，以避免创建和删除线程的开销。然而，如果你想要同时处理数千个请求，这将需要一个拥有数千个线程的线程池。操作系统的线程调度非常复杂，涉及许多逻辑，包括优先级等。操作系统不期望线程只是运行短时间的计算；它们不是为此优化的。因此，解决方案是使用相同的线程来处理多个同时请求。一般来说，如果我们停止阻塞IO，并在一个任务等待I/O时使用同一线程执行另一个任务，就可以这样做。然而，管理这些事情是非常复杂的。因此，我们需要一个框架来为我们执行这些活动。这样的框架可以被称为响应式框架。
- en: 'Reactive programming takes care of the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程负责以下内容：
- en: '**Scalability**: This property is the capability of the application to cater
    to proportional number of requests as the number of available resources increases.
    If one processor serves 500 requests per second, two processors should do 1,000.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这个属性是指应用程序能够随着可用资源的增加而提供成比例数量的请求的能力。如果一个处理器每秒处理500个请求，那么两个处理器应该处理1,000个。'
- en: '**Responsiveness**: We want the application to be responsive; for example,
    it should show a status when it is computing some result or fetching it from some
    other place.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：我们希望应用程序具有响应性；例如，当它在计算某个结果或从其他地方获取它时，应该显示状态。'
- en: '**Resilience**: Since we use the same thread for multiple tasks, handling errors
    is more complicated than usual. How do we let the user know of an error? So instead
    of propagating the exceptions back down the call stack, we move forward and explicitly
    tackle the error situations.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：由于我们使用相同的线程执行多个任务，错误处理比通常情况下更复杂。我们如何让用户知道错误信息呢？因此，我们不是将异常传播回调用栈，而是向前移动并显式处理错误情况。'
- en: There are different techniques for using reactive programming; it depends on
    the actual problem we are trying to solve. We will not discuss all of them but
    will focus on the commonly used ones.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式编程有不同的技术；这取决于我们试图解决的实际问题。我们不会讨论所有这些技术，但会关注常用的那些。
- en: Producer-consumer model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者-消费者模型
- en: A producer-consumer model is a design that divides processing into small components
    that send messages to other components. One produces a message and the other consumes
    and acts on it. It provides an abstraction to easily implement an application
    optimized to utilize all the resources. A producer-consumer model starts with
    a queue of messages. Producers publish messages in this queue and consumers receive
    them. This queue is different from the queues we have studied so far in a few
    ways. We want this queue to be thread-safe, which is required for the queue to
    work correctly in a multithreaded environment. We do not need to worry about the
    exact order of the messages being dequeued. After all, the order of messages does
    not matter when they are being received by different threads. In these conditions,
    we optimize the delivery of the messages. Before implementing this queue, let's
    discuss a few thread synchronization techniques beyond what we have learned so
    far using the synchronized keyword. These techniques are required for more optimal
    usage of resources while maintaining the correctness of the program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者-消费者模型是一种将处理过程划分为向其他组件发送消息的小组件的设计。一个生产消息，另一个消费并对其采取行动。它提供了一个抽象，可以轻松实现一个优化以利用所有资源的应用程序。生产者-消费者模型从消息队列开始。生产者在队列中发布消息，消费者接收它们。这个队列与我们之前研究过的队列在几个方面不同。我们希望这个队列是线程安全的，这对于队列在多线程环境中的正确工作来说是必需的。我们不需要担心消息出队的确切顺序。毕竟，当它们被不同线程接收时，消息的顺序并不重要。在这些条件下，我们优化了消息的传递。在实现这个队列之前，让我们讨论一些使用synchronized关键字之外的一些线程同步技术。这些技术对于在保持程序正确性的同时更优化地使用资源是必需的。
- en: Semaphore
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量
- en: 'A semaphore is a special variable that lets us limit the number of threads
    that can use a particular resource. The following code shows an example of a semaphore
    that gives us a thread-safe counter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一种特殊的变量，它允许我们限制可以访问特定资源的线程数量。以下代码展示了信号量的一个示例，它提供了一个线程安全的计数器：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the semaphore has been initialized to `1`, which means it will allow only
    one thread to acquire it. No other thread can acquire it until it is released.
    Unlike synchronization, there is no requirement here that the same thread has
    to call the release method that had acquired it, which makes it particularly flexible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，信号量已被初始化为`1`，这意味着它只允许一个线程获取它。其他线程在它释放之前无法获取它。与同步不同，这里没有要求必须由获取它的同一个线程调用释放方法，这使得它特别灵活。
- en: A call to the `acquire` method of a semaphore will be blocked until it successfully
    acquires it. This means that the calling thread will be taken off the thread scheduler
    and put aside in such a way that the operating system's thread scheduler will
    not be able to see it. Once the semaphore is ready to be acquired, this thread
    will be put back in place for the thread scheduler to see it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对信号量的`acquire`方法的调用将被阻塞，直到它成功获取。这意味着调用线程将被从线程调度器中移除并放置在一边，这样操作系统的线程调度器就无法看到它。一旦信号量准备好被获取，这个线程将被放回原位，以便线程调度器可以看到它。
- en: Compare and set
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较并设置
- en: 'Compare and set is an atomic operation that lets you update the value of a
    variable if and only if the existing value matches a specific value. This enables
    us to update a variable based on its previous value. The CAS operation returns
    a Boolean. If the comparison is a match, which means the set operation is successful,
    it returns `true`; otherwise, it returns `false`. The idea is to keep trying until
    this set operation is successful. The following diagram shows the basic strategy:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 比较和设置是一个原子操作，它允许你仅在现有值匹配特定值时更新变量的值。这使我们能够根据变量的先前值更新变量。CAS操作返回一个布尔值。如果比较匹配，这意味着设置操作成功，它返回`true`；否则，它返回`false`。想法是持续尝试，直到设置操作成功。以下图表显示了基本策略：
- en: '![Compare and set](img/00077.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![比较和设置](img/00077.jpeg)'
- en: 'Figure 1: Atomic update using the compare and set operation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：使用比较和设置操作进行原子更新
- en: 'In *Figure 1*, we are trying to increment the value of the shared variable
    **var**. The operation requires us to read the value in a thread-specific temporary
    location, then increment the temporary value and reassign it to the shared variable.
    However, this operation can cause problems if there are multiple threads trying
    to perform the update simultaneously. It can happen that both the threads read
    the value simultaneously in order to get the same temp value. Both these threads
    can update the shared variable with the incremented value. This will increment
    the value only once, but it should have actually caused two increments. To avoid
    this, we check whether the value of **var** is still the same and update only
    when it is so; otherwise, we read the value of **var** again and repeat the process.
    Since this compare and set operation is atomic, it guarantees that no increments
    will be lost. The following is the Java code that does the exact same thing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1*中，我们试图增加共享变量**var**的值。这个操作需要我们在线程特定的临时位置读取值，然后增加临时值并将其重新分配给共享变量。然而，如果有多个线程同时尝试执行更新，这可能会引起问题。可能会发生的情况是，这两个线程同时读取值以获取相同的临时值。这两个线程都可以使用增加的值更新共享变量。这将只增加一次值，但实际上应该增加两次。为了避免这种情况，我们检查**var**的值是否仍然相同，并且只有在它是这样的时候才更新；否则，我们再次读取**var**的值并重复该过程。由于这个比较和设置操作是原子的，它保证了不会丢失任何增加。以下是与之相同的Java代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To use any atomic operation, we need to use classes from the `java.util.concurrent.atomic`
    package. `AtomicInteger` is a class that encapsulates an integer and enables the
    `compareAndSet` operation on it. There are other utility methods as well. In particular,
    it has methods to perform atomic increments and decrements, just like the one
    we have implemented here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用任何原子操作，我们需要使用`java.util.concurrent.atomic`包中的类。`AtomicInteger`是一个封装整数的类，它允许在该整数上执行`compareAndSet`操作。还有其他一些实用方法。特别是，它有执行原子增加和减少的方法，就像我们在这里实现的那样。
- en: Volatile field
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Volatile字段
- en: Suppose we have a field that is being written to and read from multiple threads.
    If all the threads run on the same single CPU, the writes can simply happen on
    the CPU cache; they need not be synced to the main memory often. This would not
    be a problem as the value could also be read from the same cache. However, multiple
    CPUs can have their own caches, and in such a case, a write to a cache from one
    CPU will not be visible from another thread running on a different CPU. Most programs
    accept this and work accordingly. Java, for example, maintains a separate copy
    of a shared variable for each thread, which is occasionally synced. If we, however,
    want to mandate that the writes from one thread should be visible from another
    thread, we need to declare the field volatile. All fields involved in atomic operations
    are declared volatile.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个字段，它被多个线程写入和读取。如果所有线程都在同一个单CPU上运行，写入可以直接在CPU缓存中发生；它们不需要经常同步到主内存。这不会成为问题，因为值也可以从相同的缓存中读取。然而，多个CPU可以有自己的缓存，在这种情况下，一个CPU对缓存的写入对在另一个CPU上运行的线程是不可见的。大多数程序接受这一点并相应地工作。例如，Java为每个线程维护共享变量的单独副本，这些副本偶尔会同步。如果我们想强制一个线程的写入对另一个线程可见，我们需要声明该字段为volatile。所有涉及原子操作的字段都被声明为volatile。
- en: Thread-safe blocking queue
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全的阻塞队列
- en: Now we are ready to implement our thread-safe blocking queue. Thread-safe means
    that multiple threads can share the same queue; blocking means that if a thread
    tries to dequeue an element and the queue is currently empty, the call to dequeue
    will be blocked until some other thread enqueues an element. Similarly, if a thread
    tries to enqueue a new element and the queue is full, the call to the queue will
    be blocked until another thread dequeues an element and frees some space.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实现我们的线程安全的阻塞队列。线程安全意味着多个线程可以共享同一个队列；阻塞意味着如果一个线程尝试出队一个元素而队列当前为空，出队调用将被阻塞，直到其他线程入队一个元素。同样，如果一个线程尝试入队一个新元素而队列已满，对队列的调用将被阻塞，直到另一个线程出队一个元素并释放一些空间。
- en: 'Our queue will store elements in a fixed length array and maintain two counters
    that would store the next index for queuing and dequeuing. Two semaphores block
    threads when the queue is either empty or full. Along with this, each array position
    is provided with two semaphores that ensure that enqueuing and dequeuing operations
    do not overwrite or repeat any elements. It does this by ensuring that once a
    new element is enqueued in a particular position, it is not overwriten before
    it is dequeued. Similarly, once a particular array index is dequeued, it is never
    dequeued again before another enqueue stores another element in it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的队列将在一个固定长度的数组中存储元素，并维护两个计数器，它们将存储入队和出队的下一个索引。两个信号量在队列空或满时阻塞线程。此外，每个数组位置都提供了两个信号量，确保入队和出队操作不会覆盖或重复任何元素。它是通过确保一旦新元素被入队到特定位置，在它被出队之前不会被覆盖来实现的。同样，一旦特定数组索引被出队，它将永远不会在另一个入队操作存储另一个元素之前再次被出队：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `underflowSemaphore` ensures that dequeues are blocked when the queue is
    empty, and `overflowSemaphore` ensures that enqueues are blocked when the queue
    is full:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`underflowSemaphore` 确保当队列空时出队操作被阻塞，而 `overflowSemaphore` 确保当队列满时入队操作被阻塞：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The array store is the space that holds the elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数组存储是持有元素的空间：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both `enqueueLocks` and `dequeueLocks` are individual position-based locks
    that allow only a dequeue after an enqueue and vice versa:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueueLocks` 和 `dequeueLocks` 都是基于位置的独立锁，它们只允许在入队之后进行出队，反之亦然：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `alive` flag can be used by the dequeuing threads to know when they can
    stop running, and no more elements would be expected. This flag needs to be set
    by the enqueuing threads:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`alive` 标志可以被出队线程用来知道何时停止运行，并且不再期望有更多元素。这个标志需要由入队线程设置：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All initializations are pretty much self-evident:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有初始化基本上都是显而易见的：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The enqueue operation first makes sure that the queue is not full by acquiring
    `overflowSemaphore`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作首先确保队列不满，通过获取 `overflowSemaphore`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `nextEnqueueIndex` is then incremented and the previous value is returned,
    which is then used to compute the index in the array where the element would be
    stored. The seemingly complicated expression ensures that the index rolls over
    properly even after the `nextEnqueueIndex` integer rolls over, provided the length
    of the queue is an integer power of 2:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `nextEnqueueIndex` 被增加，并返回其前一个值，这个值随后被用来计算元素将被存储在数组中的索引。这个看似复杂的表达式确保了即使在
    `nextEnqueueIndex` 整数溢出之后，索引也能正确地回滚，前提是队列的长度是2的整数次幂：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the index is selected, we must acquire an enqueue lock on the position,
    store the value, and then release the dequeue lock to mark this position as ready
    for dequeuing. At the end, we release one count on `underflowSemaphore` to mark
    the fact that there is one more element in the queue to be dequeued:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了索引，我们必须在位置上获取一个入队锁，存储值，然后释放出队锁以标记这个位置为准备出队。最后，我们释放 `underflowSemaphore`
    上的一个计数，以标记队列中有一个更多元素待出队：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The dequeue operation is very similar to the enqueue operation, just the role
    of the semaphores are reversed. There is slightly more complicated code before
    the actual operation starts. This is to enable the dequeuing threads to quit when
    no more elements are available:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 出队操作与入队操作非常相似，只是信号量的角色被反转。在实际操作开始之前有一些稍微复杂的代码。这是为了使出队线程在没有更多元素可用时能够退出：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead of directly acquiring `underflowSemaphore`, we use `tryAcquire`, which
    will wake up the thread after 1 second if there are no elements are available
    to be dequeued. This gives us a chance to check the value of the `alive` Boolean
    flag and quit the dequeue operation in case it is no longer alive. If the queue
    is no longer alive, we interrupt the current thread and exit. Otherwise, we compute
    the index and dequeue the element to the enqueue operation in a similar manner:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接获取 `underflowSemaphore`，而是使用 `tryAcquire`，如果没有任何元素可供脱队，它将在 1 秒后唤醒线程。这给了我们检查
    `alive` 布尔标志值的机会，并在它不再活跃的情况下退出脱队操作。如果队列不再活跃，我们中断当前线程并退出。否则，我们计算索引并以类似的方式从入队操作中脱队元素：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a utility method to return the current number of elements in the queue.
    This is useful for knowing when to kill the queue (set the `alive` flag to `false`)
    in a producer-consumer setup:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实用方法，用于返回队列中的当前元素数量。这在知道何时终止队列（将 `alive` 标志设置为 `false`）在生产者-消费者设置中很有用：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Producer-consumer implementation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产者-消费者实现
- en: 'We can now implement a producer-consumer setup using the queue we have created.
    In simple words, the producer-consumer queue is a queue of events that the producers
    produce and the consumers consume. There are three kinds of events. The `INVOCATION`
    type refers to the regular events that propagate processing. The `ERROR` type
    event is raised when an exception needs to be propagated. The `COMPLETION` event
    is produced when it is required that the dequeue threads need to be terminated
    and the queue needs to be closed. The `ProcerConsumer` queue takes `Consumer`
    as input:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们创建的队列实现生产者-消费者设置。简单来说，生产者-消费者队列是生产者生产并由消费者消费的事件队列。有三种类型的事件。`INVOCATION`
    类型指的是传播处理的常规事件。当需要传播异常时，会引发 `ERROR` 类型的事件。当需要终止脱队线程并关闭队列时，会产生 `COMPLETION` 事件。`ProcerConsumer`
    队列接受 `Consumer` 作为输入：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Event` class represents single events. Depending on the type, it can have
    a value or exception:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event` 类表示单个事件。根据类型，它可以有一个值或异常：'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The constructor of `ProducerConsuerQueue` creates consumer threads. It also
    takes consumer code as input. The consumer must implement the `Consumer` interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProducerConsumerQueue` 构造函数创建消费者线程。它还接受消费者代码作为输入。消费者必须实现 `Consumer` 接口：'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The consumer thread runs code that dequeues events and calls the methods on
    `consumerCode` as per the event type in the loop. The loop ends when the termination
    event is received and no more events are there in the queue to be processed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者线程运行代码，脱队事件并按照事件类型在循环中调用 `consumerCode` 的方法。循环在接收到终止事件且队列中没有更多事件需要处理时结束：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Consumer threads are spawned:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消费者线程：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `produce` method is invoked from a producer thread. Notice that the queue
    does not manage producer threads; they need to be managed separately:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`produce` 方法由生产者线程调用。请注意，队列不管理生产者线程；它们需要单独管理：'
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once a producer thread marks the stream of events to be completed, no more
    new events could be generated and the dequeuing threads will be terminated after
    they process all the events:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生产者线程标记事件流已完成，就不会再生成新事件，并且脱队线程在处理完所有事件后将被终止：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is to propagate an exception:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了传播一个异常：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we need to wait for all the dequeuing threads to terminate, we use this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要等待所有脱队线程终止，我们使用这个：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see how to use this producer-consumer queue to actually solve a problem,
    we will consider a dummy problem. We will work on a file—`com-orkut.ungraph.txt`—that
    is open to public and contains all the friendships between users in **Orkut**,
    which was a social networking site in the past. The file can be downloaded from
    [https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz](https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz).
    To protect privacy, all the users are simply referenced by some arbitrary ID and
    the mapping with the actual users is not shared. We will also use another file
    called `ulist` that would contain the list of user IDs we are interested in. Our
    task is to find the number of friends that each user in the second file has. The
    following commands show how the two files look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用这个生产者-消费者队列实际解决问题，我们将考虑一个示例问题。我们将处理一个文件——`com-orkut.ungraph.txt`——它是公开的，包含过去社交网站Orkut中用户之间的所有友谊。该文件可以从[https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz](https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz)下载。为了保护隐私，所有用户都通过一些任意的ID进行引用，并且没有共享与实际用户的映射。我们还将使用另一个名为`ulist`的文件，其中将包含我们感兴趣的ID列表。我们的任务是找出第二个文件中每个用户的朋友数量。以下命令显示了这两个文件的外观：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each line in `com-orkut.ungraph.txt` has two IDs that are separated by a whitespace.
    The meaning is that there is friendship between these two users. It is given that
    each friendship is mentioned only once in the file and is undirected. Note that
    this means each line should increase the friend count for both the IDs. Each line
    in `ulist` has a single ID. All IDs are unique, and we must find the friend count
    of each of these IDs. Note that some of these have no friends and thus are not
    mentioned in `com-orkut.ungraph.txt`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`com-orkut.ungraph.txt`中的每一行都有两个通过空格分隔的ID。这意味着这两个用户之间存在友谊。已知文件中每个友谊只被提及一次，并且是无向的。请注意，这意味着每一行应增加两个ID的朋友数量。`ulist`中的每一行只有一个ID。所有ID都是唯一的，我们必须找到这些ID中每个的朋友数量。请注意，其中一些没有朋友，因此在`com-orkut.ungraph.txt`中没有被提及。'
- en: 'We will first create a utility class that will let us read integer IDs from
    the files. The purpose of this class is to read integer values from any text file
    so that not too many objects are created in the process. This is just to reduce
    garbage collection to some extent. In this case, we used file-channel-based logic
    that uses `ByteBuffer` as a buffer:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个实用程序类，它将使我们能够从文件中读取整数ID。这个类的作用是从任何文本文件中读取整数值，以便在过程中不会创建太多的对象。这只是为了在一定程度上减少垃圾收集。在这种情况下，我们使用了基于文件通道的逻辑，该逻辑使用`ByteBuffer`作为缓冲区：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `readCount` variable keeps track of how many characters are left in the
    buffer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`readCount`变量跟踪缓冲区中剩余的字节数：'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To read an `int`, keep reading the bytes in a loop until you hit a byte that
    is not a digit. In the meantime, keep computing the integer that the string of
    characters represents:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取一个`int`，在一个循环中继续读取字节，直到遇到一个不是数字的字节。在此期间，继续计算字符串表示的整数：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First check whether the buffer is empty; if yes, refill it by reading from
    the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查缓冲区是否为空；如果是，则通过从文件中读取来重新填充它：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If no more bytes are available in the file, don''t care to flip the buffer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中没有更多的字节可用，不必关心翻转缓冲区：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We read a byte and decrement `readCount` because now the buffer has one less
    byte:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取一个字节并减少`readCount`，因为现在缓冲区少了一个字节：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the character is a digit, keep computing the integer; otherwise, break the
    loop and return the calculated integer value:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符是数字，继续计算整数；否则，中断循环并返回计算出的整数值：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the help of this, we will create a program to create a file output, which
    will contain the user IDs provided in `ulist` along with the corresponding friend
    count. The idea is that reading the file is made asynchronous by computing the
    friend count. Since the counting involves a binary search, we want two threads
    doing it instead of one:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此帮助下，我们将创建一个程序来创建一个文件输出，其中将包含`ulist`中提供的用户ID以及相应的朋友数量。想法是通过计算朋友数量来异步读取文件。由于计数涉及二分搜索，我们希望有两个线程来完成这项工作而不是一个：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First, we simply count the number of lines present in `ulist`. This will let
    us create the correct size array:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们简单地计算`ulist`中存在的行数。这将使我们能够创建正确大小的数组：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We create two arrays: one containing the keys and the other containing the
    friend count of each of the keys. The counts are stored in `AtomicInteger` objects
    so that they can be incremented from multiple threads:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个数组：一个包含键，另一个包含每个键的朋友计数。计数存储在`AtomicInteger`对象中，以便可以从多个线程中递增：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We read `userIDs` from `ulist` in an array:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ulist`中读取`userIDs`到一个数组中：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we sort the array of `userID` so that we can perform binary search on it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`userID`数组进行排序，以便我们可以对其执行二分搜索：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The job of our consumers is to search for each user encountered in `com-orkut.ungraph.txt`
    and increment the corresponding count in the array values. Note that creating
    `ProducerConsumerQueue` does not start any processing; only consumer threads are
    created through this. Processing will start only when we produce events, which
    we will do after reading from `com-orkut.ungraph.txt`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们消费者的任务是搜索在`com-orkut.ungraph.txt`中遇到的每个用户，并在数组values中递增相应的计数。请注意，创建`ProducerConsumerQueue`不会启动任何处理；只有通过这种方式创建消费者线程。处理只有在产生事件后才会开始，我们将在读取`com-orkut.ungraph.txt`后进行：
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We use the main thread for producing the events. We use the same `FileReader`
    class for reading each user ID separately. This is because both the users in a
    line in `com-orkut.ungraph.txt` have a friend (which is the other one in the same
    line) for each line in the file. So we simply read the users and post them as
    events so that the consumers can process them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用主线程来产生事件。我们使用相同的`FileReader`类来单独读取每个用户ID。这是因为`com-orkut.ungraph.txt`中每一行的用户都有一个朋友（即同一行中的另一个用户），所以我们可以简单地读取用户并将它们作为事件发布，以便消费者可以处理它们：
- en: '[PRE37]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we are done processing the entire `com-orkut.ungraph.txt` file, we simply
    mark the queue as completed and wait for the consumer threads to be terminated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完整个`com-orkut.ungraph.txt`文件，我们只需将队列标记为完成并等待消费者线程终止：
- en: '[PRE38]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now all the counts must be updated in the values array. So we simply read them
    one by one and output them in the file output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须更新值数组中的所有计数。所以我们逐个读取它们，并将它们输出到文件output中：
- en: '[PRE39]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding example demonstrates how an actual problem can be solved using
    the reactive technique of **producer-consumer**. Now we will discuss another way
    of implementing our event queue; it does not involve blocking on semaphores.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了如何使用**生产者-消费者**的响应式技术解决实际问题。现在我们将讨论实现我们的事件队列的另一种方式；它不涉及在信号量上阻塞。
- en: Spinlock and busy wait
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自旋锁和忙等待
- en: A semaphore normally blocks a thread before the thread acquires it. This blocking
    is achieved by the operating system by removing the thread from the list of threads
    that are ready to be scheduled for processing time on the CPU. The list of threads
    ready to be scheduled are called running threads. Every semaphore has a list of
    threads waiting on it, and these threads are removed from the list of running
    threads. Once the semaphore is released, threads from the list attached to the
    semaphore are removed and put back on the list of the running threads. This operation
    is somewhat heavyweight and requires processing time. Another way to stop a thread
    from accessing a shared resource is to use a spinlock. A spinlock is generally
    implemented using an atomic variable and compare and set operation. A thread in
    a spinlock simply tries to perform compare and set on a variable in a loop; it
    does so until it succeeds. To the operating system, this thread is as good as
    a running thread and is scheduled just like any other thread. The thread itself,
    however, keeps trying a compare and set operation and consumes processor time.
    This is why it is called a busy wait. The thread can proceed to do something meaningful
    once the compare and set operation is successful. Spinlocks are useful when the
    resource would not be available only for a short period of time. It simply does
    not make sense to do all the heavy lifting of removing the thread from the list
    of running thread and blocking on a semaphore if the resource is unavailable for
    a brief period of time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量通常在线程获取它之前阻塞线程。操作系统通过从准备在CPU上分配处理时间的线程列表中移除线程来实现这种阻塞。准备就绪的线程列表被称为运行线程。每个信号量都有一个等待在其上的线程列表，这些线程被从运行线程列表中移除。一旦信号量被释放，附加到信号量的线程列表中的线程将被移除并放回运行线程列表。这个操作相当重量级，需要处理时间。另一种阻止线程访问共享资源的方法是使用自旋锁。自旋锁通常使用原子变量和比较和设置操作实现。自旋锁中的线程简单地尝试在循环中执行变量的比较和设置操作；它一直这样做，直到成功。对于操作系统来说，这个线程就像一个运行线程一样，会被像任何其他线程一样调度。然而，线程本身会不断尝试比较和设置操作，消耗处理器时间。这就是为什么它被称为忙等待。一旦比较和设置操作成功，线程就可以继续做有意义的事情。自旋锁在资源不会长时间不可用时很有用。如果资源只是短暂不可用，就没有必要进行所有重负载操作，比如从运行线程列表中移除线程并在信号量上阻塞。
- en: 'We can implement our thread-safe queue with spinlocks instead of semaphores
    as shown in the following code. Each array location for storing the queue elements
    is protected by two `AtomicBoolean` variables, stored in the `enqueueLocks` and
    `dequeueLocks` arrays. The only thing we want to make sure is that after each
    dequeue, there should only be a single enqueue, and after each enqueue, there
    should only be a single dequeue for a particular array location. Different array
    locations should be independent of one another:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自旋锁而不是信号量来实现我们的线程安全队列，如下面的代码所示。每个用于存储队列元素的数组位置都由两个`AtomicBoolean`变量保护，这些变量存储在`enqueueLocks`和`dequeueLocks`数组中。我们唯一想要确保的是，每次出队后，只有一个入队，每次入队后，特定数组位置只有一个出队。不同的数组位置应该相互独立：
- en: '[PRE40]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When `enqueueLocks[i]` is `false`, it means there is no element being stored
    at the position `i`. When `dequeueLock[i]` is `true`, it means the same thing.
    The reason we need both is for protection when an element is in the process of
    being enqueued or dequeued:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当`enqueueLocks[i]`为`false`时，意味着位置`i`没有存储元素。当`dequeueLock[i]`为`true`时，意味着相同的事情。我们需要两者的原因是在元素正在入队或出队的过程中进行保护：
- en: '[PRE41]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the core of the lock. We simply take the next index to enqueue and
    try to get `enqueueLock`. If it is `false`, which means nothing is already enqueued,
    it is atomically set to `true` and it starts the enqueue process; otherwise, we
    keep doing the same thing in a busy loop until the compare and set operation is
    successful. Once the process is complete, we release `dequeueLock` by simply setting
    it to `false`. A compare and set operation is not necessary here because it is
    guaranteed to be `true`. The number of elements are maintained using another atomic
    variable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是锁的核心。我们简单地取下一个索引进行入队，并尝试获取`enqueueLock`。如果它是`false`，这意味着还没有任何元素入队，它会被原子性地设置为`true`，并开始入队过程；否则，我们会在忙循环中重复做同样的事情，直到比较和设置操作成功。一旦过程完成，我们只需将`dequeueLock`设置为`false`来释放它。比较和设置操作在这里不是必要的，因为它保证是`true`。元素的数量使用另一个原子变量来维护：
- en: '[PRE42]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The dequeue operation is very similar, just that the enqueue and dequeue locks
    have switched places:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The rest of the code is self-evident:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can simply replace the queue in the `ProducerConsumerQueue` class to use
    this spinlock-based queue. In the case of our example problem, the spinlock version
    of the queue performs better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s solve another problem using `ProducerConsumerQueue`. Our problem is
    to find all the perfect numbers between 2 and 500,000\. What is a perfect number?
    A perfect number is a number that is the sum of all its divisors, excluding itself.
    The first perfect number is 6\. 6 has three divisors excluding itself, namely
    1, 2, and 3 and 6=1+2+3\. This is what makes 6 a perfect number. To find all the
    perfect numbers between 2 and 500,000, we will check whether each number in the
    range is a perfect number. We can write the following code to figure out whether
    a given number is a perfect number. For every number *div*, we check whether the
    number *x* is divisible by *div*; if so, we add it to the sum. In such a case,
    if we divide *x* by *div*, we will of course get another divisor of *x* as a result
    stored in the variable quotient. This must also be added to the sum, unless it
    is equal to *div*. We stop this process when we pass through the square root of
    *x*, that is, when *div* is bigger than the quotient we get when *x* is divided
    by *div*. Since we, originally, exclude *1* as a divisor to avoid adding the number
    itself, we add *1* to the sum at the end and check whether it is equal to *x*;
    if so, *x* is a perfect number:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, checking whether a given number is a perfect number is a computationally
    expensive operation, which makes it desirable to use all the CPUs to compute it.
    We will use our producer-consumer framework to do this. The code is self-explanatory.
    Our consumer code simply checks whether a given number is a perfect number and
    then prints the number if it is so. The producer simply generates and queues all
    the numbers. Since the consumer is run in multiple threads and it is the part
    that is computationally intensive, it should work faster than the single-threaded
    version:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since my computer has four CPU cores, I used four threads to do the heavy lifting.
    On my computer, this program takes 1,596 milliseconds as compared to 4,002 milliseconds
    for the single-threaded program, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Functional way of reactive programming
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most reactive programming frameworks provide functional APIs for reactive programming,
    which makes it even easier to work with. In this section, we will build a functional
    reactive API and solve a problem with it. The idea is to use the concept of a
    stream. A stream is a data generator or source that can provide input when requested.
    Functional APIs provide map, filter, and consume operations on the stream. The
    map and the filter operations create a new stream, and the consume operation gives
    a `EventConsumer` instance. The idea is that when `EventConsumer` is asked to
    start processing, it would spawn its own producer threads and consumer threads
    and treat each map, filter, or consume operations as a separately scheduled operation
    in a producer-consumer queue. This is just to highlight what we are really trying
    to achieve.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I will put the code to use the functional API to solve the same
    perfect number problem. We will replace the pseudo-method `someWayCreateAStream`
    with the actual code to create a stream later. The point is to show how an event
    stream can be manipulated using the map, filter, and consume method. The processing
    really starts when the process method is called, and in each step of map, filter,
    and consume are decoupled processing steps and are potentially run in different
    threads:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we create an instance of `EventStream` or `EventConsumer`, no processing
    happens; only metadata is created. It is when the method process is invoked that
    the processing starts. This is done by the process method spawning the producer
    and consumer threads. The producer threads create and enqueue events that contain
    the initial value and the processing code (like map, filter, or consume operations).
    A dequeuer runs the first piece of processing and enqueues another event for the
    next level of processing; it does this for map and filter operations. A consume
    operation is the end of the processing chain, and it does not return any value.
    This is when no more events are scheduled.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This requires that a dequeuer thread must also do some enqueue operations. What
    can be a problem with this? There are two kinds of threads that enqueue. One of
    these threads is responsible for dequeueing too. These threads may get blocked
    while trying to perform enqueue operations when the queue is full. But this would
    mean that they would not be able to do any dequeue operation either; this is because
    if they do this, the queue would never have more space again. This situation is
    a deadlock; all the threads are blocked and are expecting other threads to do
    something to unblock them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why this deadlock happens, let''s imagine a queue with length 4\. Suppose
    there are two dequeuing threads that also perform an enqueue operation once in
    some cases. Let''s have another enqueuer thread too. Since the threads can run
    in any order, it is possible that the enqueuer runs first and enqueues four new
    elements to make the queue full. Now say two dequeuers run, each dequeuing one
    element. Before these threads get a chance to enqueue once more, the enqueuer
    thread is run again, and this time it enqueues two new elements to fill the queue.
    Now the dequeuer threads are run, but they are blocked because the queue is full.
    They cannot even dequeue any element because they are themselves blocked from
    enqueuing more elements. This is a deadlock situation. *Figure 2* shows this situation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional way of reactive programming](img/00078.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'What we really want is threads that will not only perform the enqueue operation,
    but also block the queue before it is completely full. This is so that the dequeueing
    threads can use some space to keep dequeuing and enqueuing until they reach a
    point where they will not have to enqueue anymore (because they have reached the
    last step of the processing chain). Eventually, the queue gets empty and the enqueuer
    threads can be unblocked again. To do this, we need to have two different kinds
    of enqueue operations. One that does not block until the queue is full, and another
    that blocks once the queue is half or more full. We can implement the second type
    using the following code in the `ThreadSafeFixedLengthSpinlockQueue` class. The
    `enqueueProducerOnly` method is just like the `enqueue` method, except it performs
    an atomic check of the `currentElementCount` variable instead of just incrementing
    it. If, while enqueueing, it is seen that the queue is already full, we release
    the enqueue lock and restart. The thread that does only enqueue operations and
    no dequeue operation must use this method instead of the regular `enqueue` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now use this method to implement a corresponding method in the `ProducerConsumerQueue`
    class. This method is exactly the same as the produce method, except that here,
    the call to enqueue has been replaced by a call to the `enqueueProducerOnly` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now let''s see the `EventStream` class. The whole point of the `EventStream`
    class is to create metadata in a functional way. It is an abstract class with
    only one abstract method called `read()`. A call to the `read` method should return
    the next object that needs to be processed. The class maintains a pointer to the
    previous `EventStream` on which this `EventStream` will work. This means that
    the operation represented by `EventStream` will work on the data obtained after
    all the previous `EventStream` have been processed. It is really a linked list
    of `EventStream`. Depending on the kind of operation the current `EventStream`
    represents, it either has a mapper, a filter, or nothing. The `read` method is
    applicable only to the first `EventStream` that generates the data. Both the map
    filter methods return another `EventStream` that represents the corresponding
    processing. After all the map and filter calls, the list linked by `EventStream`
    will store all the operations from the last to the first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The consume method, however, returns an instance of `EventConsumer`. This is
    the terminal processing in any chain that does not compute a new value. The `EventConsumer`
    class, as would be shown a little later, contains all of the logic to actually
    start the processing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Since we need to store the details of the processing inside an `EventConsumer`
    instance, we will first make a few classes to store this information. The first
    one is a `Task` interface that represents any of the map, filter, or consume operation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This interface is implemented by three classes that represent each kind of
    operation. To store the code, we need two additional functional interfaces that
    represent an expression and a statement that would allow you to throw exceptions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following classes implement the `Task` interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Both `MapperTask` and `FilterTask` have a pointer to the next task because
    they are intermediate operations. They also store the piece of code associated
    with the processing. The `ProcessorTask` represents the terminal operation, so
    it does not have a pointer to the next task:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We will now create the `EventConsumer` class that will create a task chain
    and run it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A `StreamEvent` is a processing request that is an element of the producer-consumer
    queue. It stores `value` as `Object` and `task`. The `task` can have more tasks
    pointed to by its next reference:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'An `EventStream` stores its previous operation—that is to say that if we read
    the head of the list, which would be the last operation. Of course, we need to
    arrange the operations in the order of execution and not in reverse order. This
    is what the `eventStreamToTask` method does. A `MapperTask` or `FilterTask` stores
    the next operation, so the head of the list is the first operation to be carried
    out:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The constructor is package-accessible; it is intended to be initialized only
    from inside the `consume` method of an `EventStream`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following is the piece of code responsible for actually carrying out the
    operations. The `ConsumerCodeContainer` class implements `Consumer` and acts as
    the consumer of the producer-consumer queue for processing events:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `onMessage` method is invoked for every event in the producer-consumer
    queue. Based on the actual task, it takes the corresponding action. Notice that
    for `MapperTask` and `FilterTask`, a new event is enqueued with the next operation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `ProcessorTask` is always the end of a processing chain. The operation
    is simply invoked on the value and no new event is queued:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For a `FilterTask`, the event with the next task is enqueued only if the condition
    is satisfied:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For a `MapperTask`, the next task is enqueued with the value computed by the
    current map operation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The process method is responsible for kicking the actual processing of the
    tasks. It uses a `ProducerConsumerQueue` to schedule events that are processed
    by the consumer previously discussed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Only the original `EventStream` on which map and filter were called has the
    `read` method implemented. So we simply get a reference to the original `EventStream`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `startingStream` variable points to the original `EventStream`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The producer code also runs in separate threads. The `Runnable producerRunnable`
    contains the producer code. It simply keeps calling the `read` method of the `EventStream`
    until `null` is returned (which marks the end of the stream) and enqueues a `StreamEvent`
    with the value and the task chain we have created with the help of the `eventStreamToTask`
    method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we spawn the `producer` threads and wait for them to finish with the `join`
    calls:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is a method to register a custom error handler and return a new `EventConsumer`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Going back to our original problem of perfect numbers, all we have to do now
    is to define an `EventStream` with a read method that generates all the numbers
    and then does maps and filters on them as follows. Notice that the `EventStream.read()`
    method may be invoked by multiple threads simultaneously if we use more than one
    producer thread, so it is better for it to be thread-safe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` method simply increments an `AtomicLong` and returns the previous
    value, unless the previous value is greater than `5_00_000L`; in this case, it
    returns `null`, marking the end of the stream. We have already seen the rest of
    the code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This code runs for almost the same time as the previous reactive version without
    a functional API. I will leave it up to you to use the functional API to implement
    the friend count solution, as it is fairly simple as one gets the hang of it.
    All you need to think about is how to implement the `read` method to return the
    integers from the file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to do advanced thread synchronization using
    volatile fields, atomic operations, and semaphores. We used these to create our
    own reactive programming framework and also created a functional API for reactive
    programming. We used our frameworks to solve sample problems and saw how multithreaded
    scalable apps can be written easily with a reactive framework.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用可变字段、原子操作和信号量进行高级线程同步。我们利用这些技术创建了自己的响应式编程框架，并为响应式编程创建了一个功能API。我们使用我们的框架来解决示例问题，并看到了如何使用响应式框架轻松编写多线程可扩展应用程序。
- en: There are many reactive programming frameworks available, such as RxJava, Akka,
    and many more. They are slightly different in their implementation and features.
    They all provide a lot more features than the one we used. This chapter is just
    an introduction to the topic; interested readers can learn more about reactive
    programming from the books dedicated to this subject.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的响应式编程框架有很多，例如RxJava、Akka等。它们在实现和功能上略有不同。它们都提供了比我们使用的更多功能。本章只是对该主题的介绍；感兴趣的读者可以从专门针对该主题的书籍中了解更多关于响应式编程的信息。
- en: In this book, I tried to give you a head start in the world of algorithms, with
    implementations in Java. Algorithms are a vast field of study. Every computation
    problem needs to be solved by an algorithm. A further study would include complexity
    classes of algorithms, equivalence of algorithms, and approximate algorithms for
    highly complex problems. A complex problem is a problem that guarantees that any
    algorithm that solves it must have a certain amount of complexity. This gives
    rise to the concept of the complexity classes of problems. There are also formal/mathematical
    ways of proving the correctness of algorithms. All these areas can be pursued
    by you.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我尝试通过Java实现让您在算法的世界中领先一步。算法是一个广泛的研究领域。每个计算问题都需要通过算法来解决。进一步的研究将包括算法的复杂度类别、算法的等价性和针对高度复杂问题的近似算法。复杂问题是指任何解决它的算法都必须具有一定复杂性的问题。这导致了问题复杂度类别的概念。还有正式/数学的方法来证明算法的正确性。所有这些领域都可以由您追求。
- en: The book also covers functional and reactive programming a little bit. This
    should work as a head start in those areas; you can learn more about them in the
    books dedicated to these topics.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还简要介绍了函数式和响应式编程。这应该可以作为这些领域的入门；您可以在专门针对这些主题的书籍中了解更多关于它们的信息。
