- en: Lazy Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Lazy loading* is a technique for lowering memory consumption and, possibly,
    processing time. This technique delays the loading of data until the moment when
    it''s actually needed in the UI. For example, if you have a `Grid` component with,
    say 10,000 rows, only a bunch of them are visible at a given time. Loading the
    full set of 10,000 rows might be a waste of resources. The idea behind lazy loading
    is the same as the behavior of a lazy person: if you delay doing something until
    the last moment, you will end up saving time if, for some reason, it turns out
    that you don''t have to do the task anymore. It''s the same in a web application.
    For example, if a user leaves certain views without scrolling through the data,
    the application won''t need to load anything other than a few visible items, saving
    it from having to load potentially thousands or millions of items from the data
    source; something that could become a serious problem when many users are on the
    same view at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to implement lazy loading with the `Grid`
    component. However, the same principles apply to any other kind of UI components
    that show data from large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding lazy loading capabilities to backend services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a `DataProvider` with lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinite lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/GLTkjq](https://goo.gl/GLTkjq)'
  prefs: []
  type: TYPE_NORMAL
- en: The example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will develop a simple application to test Vaadin''s capability to show hundreds
    of thousands of rows in a `Grid` component. The users can filter the data in the
    `Grid` by typing a filter text that the application matches against three of the
    columns (Client, Phone Number, and City). The users can also change the position
    of the columns (by dragging them from the header) and order the rows (by clicking
    on the column headers). The following is a screenshot of the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c0c951c-db66-4037-a125-96b6890bf1bf.png)'
  prefs: []
  type: TYPE_IMG
- en: The data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the same data model used in [Chapter 8](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml),
    *Adding Reporting Capabilities*. The data model is based on a simple SQL table,
    `Call`. We'll use JPA to connect to a file-based H2 database. The JPA logic is
    encapsulated in a `CallRepository` class. For more details about the data model,
    please refer to [Chapter 8](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml), *Adding
    Reporting Capabilities*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-09`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Vaadin UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VaadinServlet` is configured in the `WebConfig` class. The `UI` implementation
    is realized in the `VaadinUI` class. For reference, the following is the implementation
    of the `VaadinUI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the UI consists of a `VerticalLayout` that contains only a `CallsBrowser`
    component. We''ll start with the following implementation of the `CallsBrowser`
    custom component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous class can be used as a starting point if you want to implement
    the concepts of this chapter yourself. At this point, the UI doesn't show any
    data in the `Grid` and it has no behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the backend for lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading (and filtering) capabilities should be delegated to the backend
    as much as possible. Although the `Grid` class itself is able to cache some of
    the data and send it to the client only when needed, it cannot prevent you from
    querying the whole database, for example. In order to support lazy loading, backend
    services should provide the means to lazily load the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the UI gets the data from a service or repository class. Let''s
    see an example of how a repository class can provide methods with lazy loading
    capabilities. The `CallRepository` class could define a `findAll` method that
    queries a *slice* of the rows in the `Call` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `limit` is used to *limit* the number of rows (actually,
    instances of `User`) that should be returned. When using SQL, this can be used
    as the `LIMIT` clause in a SQL query. `offset` is used to *skip* a number of rows,
    which is equivalent to the starting row number. For example, if the SQL table
    has 100 rows, and we use `offset=10` and `limit=5`, the method should return only
    the rows 10 to 15\. If we use `offset=98` and `limit=5`, the method should return
    rows 98 to 100 (there are not enough rows left after 98 to complete a set of five
    rows).
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here''s what a JPA implementation of these methods could look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we included a `count` method in the previous snippet of code. This
    is required in some situations, such as when using lazy loading with the `Grid`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading with the Grid component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Grid` component can take advantage of the `offset` and `limit` parameters
    described in the previous section by using the `setDataProvider` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code defines two lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(sortOrders, offset, limit) -> service.find(...)`: This lambda expression
    should return all the items used in *slice* defined by the `offset` and `limit`
    parameters (we will see how to use the `sortOrders` parameters later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`() -> service.count()`: This lambda expression should return the total count
    of items available with no *slices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `setDataProvider` method we used in the previous example receives an instance
    of `FetchItemsCallback`, a functional interface that defines a method to fetch
    the items (or rows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use another version of the `setDataProvider` method that accepts
    an instance of `DataProvider`. There''s a static helper method in the `DataProvider`
    interface that allows you to implement it from lambda expressions similar to the
    ones we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The difference with the previous version is that we get the `offset` and `limit`
    values from a `Query` instance, so we need to use the corresponding getters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filtering should be done with the help of backend services as well. We can
    implement this in the same way as we did in [Chapter 7](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml),
    *Implementing CRUD User Interfaces*. First, the backend service method should
    accept the filter input. In the example application, the filter value is a `String`,
    but in other situations, you may need a custom object containing all the values
    that can be used for filtering. Here is the new `find` method, which accepts a
    filter `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we make the filter case-insensitive by using the `lower` JPQL function
    and converting the filter value to lowercase using the `toLowerCase` method. We
    are also using the `%` operator to allow matches in the middle of the values in
    the database. We have to do something similar with the `count` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the UI side of the implementation, we need to send the filter value to the
    service method. This value comes from the `filter` text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to refresh the `DataProvider` when the Search button is clicked.
    This can be done using a `ClickListener` and the `refreshAll` method of the `DataProvider`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Something similar can be done for the `clear` button, which removes the filter
    introduced by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the `refreshAll` method is invoked, the lambda expressions we previously
    defined are called again and the new data is fetched from the service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s generally a good idea to add database indexes to the columns the application
    uses to filter data. In the example application, we allow filtering on the `client`,
    `phoneNumber`, and `city` columns. You can let JPA create these indexes by using
    the `@Index` annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the example application generates around 500,000 rows in the `Call`
    table. Unfortunately, the `Grid` class cannot handle this amount of rows. See
    the following issues on GitHub for more information about these limitations: [https://github.com/vaadin/framework/issues/6290](https://github.com/vaadin/framework/issues/6290),
    and [https://github.com/vaadin/framework/issues/9751](https://github.com/vaadin/framework/issues/9751).
    One way to overcome these issues is by making the filter show results in the `Grid`
    only when the number of rows the query returns is less than an established threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering rows in Grid components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can guess, ordering (or sorting) is another task that should be delegated
    to the backend services when possible. Moreover, it is most likely required when
    you are implementing pagination (that is, lazy loading using `limit` and `offset`
    parameters) in the backend service as well.
  prefs: []
  type: TYPE_NORMAL
- en: The service method should include a parameter that specifies how to perform
    the ordering. The `Grid` component allows users to click on the column headers
    to activate ordering by that column. These columns that need ordering are passed
    to the `DataProvider` in a `Query` object. You can get these by calling the `Query.getSortOrders()`
    method, which returns a `List` of `QuerySortOrder` objects. You could pass this
    `List` to the service method, but it's always a good idea to avoid coupling the
    backend services with frontend technologies. `QuerySortOrder` is a class included
    in Vaadin Framework, so you would need to include Vaadin dependencies in your
    backend services if they are deployed in a separate artifact, for example. To
    avoid this coupling, we can implement a utility method that converts between `QuerySortOrder`
    objects to framework-independent objects. In the backend services, we can use
    a `Map<String, Boolean>`, where the key is a `String` containing the name of the
    property, and the value is a `Boolean` that tells the method whether to order
    in an ascending mode or not.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the backend services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start, then, by adding a parameter for the ordering configuration to
    the `find` method of the `CallRepository` in the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `order` parameter contains the name of the properties we need to sort by.
    We need to convert this `Map` to an `order by` clause (in a `String` form) in
    JPQL. This is done in the `buildOrderByClause` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks the Client header in the `Grid`, the `buildOrderByClause`
    method will return the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This string would be concatenated to the end of the JPQL query, which in turn
    would be executed in the `find` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Grid` component also supports ordering by multiple columns. To add a column
    to the order configuration, users have to press and hold the *Shift* key down
    while clicking the column header. For example, if the user clicks the Client header
    and presses and holds the *Shift* key down while clicking the City header, the
    `buildOrderByClause` method would return the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enabling ordering in the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have previously discussed, the `DataProvider` interface uses an object
    of type `List<QuerySortOrder>` to provide the ordering configuration. However,
    the backend service requires an object of type `Map<String, Boolean>`. We have
    to implement a helper method that translates between these two types. We can add
    this method to a separate `DataUtils` class and implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `getOrderMap` method iterates over the `QuerySortOrder` objects returned
    by the `query.getSortOrders()` method and maps them to entries in a map of type
    `Map<String, Boolean>`. Notice how we used the `LinkedHasMap` type. This allows
    us to keep the entries in the map in the same order in which they come from the
    `List` provided by the `query` object, something we need if we want to support
    multiple-column ordering in the `Grid` (the `order by` clause should reflect the
    sequence used when the user clicked the headers in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this utility method in the `DataProvider`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273da231-c17c-4128-b7fe-f409ae9d35ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To complete this chapter''s example, we can enable column reordering (the users
    can drag the columns in the browser to reposition them) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: UX and large datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To close this chapter, let me share some thoughts about the convenience (or
    inconvenience) of having a `Grid` with 10,000 (or more) rows in it.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading Grid versus direct search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the screen I'm using to develop the examples of this chapter, I can see around
    15 rows at a time in a `Grid` component. If I want to see the row 5,390, for example,
    I have to scroll down and try to find the rows around 5,390\. That takes me 1
    or 2 seconds if I'm lucky. After this, I have to do some fine-tuned scrolling
    to get to the exact row. Something that can take 1 or 2 seconds again. This scrolling-through
    to search data is possible with this example application because the demo data
    is generated with consecutive numbers for the values in the fields. There are
    no missing numbers. In other situations, this might not be possible at all. Even
    in the cases where this is possible, scrolling through thousands of rows is not
    a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Filters aim to help; clicking on a `TextField` and typing 5,390 is faster than
    scrolling through the data. However, if the user is supposed to type 5,390, we
    could argue that rendering thousands of rows is not even required. The whole UI
    could potentially be redesigned to better fit the use case. When you encounter
    this kind of `Grid` with thousands of rows in it, put yourself in others' shoes;
    in the users' shoes. Consider wizard-like interfaces, infinite lazy loading on
    scroll (like Facebook or Twitter), or any other event, and splitting the view
    into several views, each one for a more specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we have explained lazy loading by using the `Grid` component, we
    can use the same backend service method to implement custom UI components that
    support lazy loading. For example, you can use a `VerticalLayout` to add sets
    of, say, 10 components any time the user clicks a *load more* button at the bottom
    of the layout. In this case, you would need to keep track of the current offset
    and keep incrementing it until the service method returns less than 10 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple UI component that shows how to implement this type
    of infinite lazy loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `loadMore` method keeps adding components to the `content` layout
    until there are no more results to add, at which point the Load more... button
    is hidden from the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows this component in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d7a1acd-a0cd-4ff7-ae4f-29be424ec488.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to implement lazy loading by enhancing the
    backend service methods to support it. We learned how to use a lazy-loaded `Grid`
    component with filtering and ordering capabilities. We implemented a `DataProvider`
    by providing two lambda expressions: one for getting slices of data and one for
    counting the total number of items. We also discussed UX aspects to take into
    consideration when dealing with large datasets and learned how to implement infinite
    lazy loading as an alternative to having a `Grid` with thousands of rows.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter closes the journey through many interesting topics related to modularization,
    API design, UI design, and data management in applications developed with Vaadin.
    There is much more to this subjects that we cannot cover in this book. Hopefully,
    this book inspired you to find good solutions to some of the challenges you may
    encounter when developing data-centric web applications with Vaadin. Happy coding!
  prefs: []
  type: TYPE_NORMAL
