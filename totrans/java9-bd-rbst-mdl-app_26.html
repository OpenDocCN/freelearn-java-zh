<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Photo Management with PhotoBeans</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far, we've written libraries. We've written command-line utilities. We've also written GUIs using JavaFX. In this chapter, we're going to try something completely different. We're going to build a photo management system, which, of course, needs to be a graphical application, but we're going to take a different approach. Rather than using pure JavaFX and building everything from the ground up, we'll use an existing application framework. That framework is the NetBeans <strong class="calibre8">Rich Client Platform</strong> (<strong class="calibre8">RCP</strong>), a mature, stable, and powerful framework, that powers not just the NetBeans IDE we've been using, but countless applications in a myriad of industries from oil and gas to air and space.</p>
<p class="mce-root">In this chapter, we'll cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">How to bootstrap a NetBeans RCP project</li>
<li class="calibre14">How to integrate JavaFX with the NetBeans RCP</li>
<li class="calibre14">The fundamentals of an RCP application such as Nodes, Actions, Lookups, Services, and TopComponents</li>
</ul>
<p class="mce-root">Without further ado then, let's jump right in.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Probably the question at or near the top of your list is, <strong class="calibre8">Why would I want to use NetBeans RCP?</strong>. Before we get into the details of the application, let's address this very fair question, and try to understand why we're building it the way we are.</p>
<p class="mce-root">One of the first things you'll notice when you start looking into the NetBeans platform is the strong notion of modularity. With the Java Module System being such a prominent feature of Java 9, this may seem like a minor detail, but NetBeans exposes this concept to us at the application level, making plugins incredibly simple, as well as allowing us to update the application on a piecemeal basis.</p>
<p class="mce-root">The RCP also provides a robust, well-tested framework for handling windows, menus, actions, nodes, services, and so on. If we were to build this application from scratch, as we've done in the previous chapters using <strong class="calibre8">plain</strong> JavaFX, we would have to manually define areas on the screen, then handle window placement by hand. With the RCP, we have a rich windowing specification already defined, which we can easily use. It offers features such as maximizing/minimizing windows, sliding, detaching, and docking windows, and so on.</p>
<p class="mce-root">The RCP also provides a strong notion of <strong class="calibre8">nodes</strong>, an encapsulation of domain-specific data in a user interface concept, which is most often seen as entries in a tree view on the left side of an application, as well as actions that can be associated with these nodes (or menu items) to act on the data they represent. Again, all of this can be done in JavaFX (or Swing), but you would have to code all of these features yourself. In fact, there are a number of open source frameworks that offer to do just that, such as Canoo's Dolphin Platform (<a href="http://www.dolphin-platform.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://www.dolphin-platform.io</span></a>), though none have had the years of production hardening and testing that the NetBeans RCP has had, so we'll keep our focus here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Bootstrapping the project</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">How you create a NetBeans RCP project will have a very fundamental impact on how the rest of the project will be approached. By default, NetBeans uses Ant as the build system for all RCP apps. Almost all of the online documentation from the NetBeans project, and blog entries from the NetBeans evangelists, often reflect this preference as well. We've been using Maven for every other project, and we're not going to change that here. Fortunately, NetBeans does allow us to create an RCP project with Maven, which is what we'll do.</p>
<div class="mce-root1"><img class="image-border39" src="Images/097ca796-1bf9-49c9-acc6-c68813bf2cb7.png"/></div>
<p class="mce-root">In the <span class="calibre7">New Project</span> window, we select <span class="calibre7">Maven</span>, then <span class="calibre7">NetBeans Application</span>. On the next screen, we configure the project as usual, specifying the project name, photobeans, project location, package, and so on.</p>
<p class="mce-root">When we click on <span class="calibre7">Next</span>, we'll be presented with the <span class="calibre7">Module Options</span> step of the <span class="calibre7">New Project</span> wizard. In this step, we configure some basic aspects of the RCP application. Specifically, we need to specify the version of the NetBeans APIs we'll use, and whether or not we want to use OSGi bundles as dependencies, as seen in the following screenshot:</p>
<div class="mce-root1"><img class="image-border40" src="Images/f789b36a-43db-41d1-8e79-e61d9566e0ca.png"/></div>
<p class="mce-root">At the time of writing, the latest platform version is <span class="calibre7">RELEASE82</span>. By the time Java 9 ships, it is reasonable to expect that NetBeans 9.0, and, therefore <span class="calibre7">RELEASE90</span>, will be available. We want the latest version available, but note that, depending on the release schedule of the NetBeans project, it may very well <em class="calibre20">not</em> be 9.0. For the <span class="calibre7">Allow OSGi bundles as dependencies</span> option we can safely accept the default, though changing it won't cause us any issues, and we can easily change the value later should the need arise.</p>
<p class="mce-root">Once the project is created, we should see three new entries in the projects window: <kbd class="calibre16">PhotoBeans-parent</kbd>, <kbd class="calibre16">PhotoBeans-app</kbd>, and <kbd class="calibre16">PhotoBeans-branding</kbd>. The <kbd class="calibre16">-parent</kbd> project has no real deliverables. Like the <kbd class="calibre16">master</kbd> projects from other chapters, this serves merely to organize related modules, coordinate dependencies, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Branding your application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">-branding</kbd> module is where we can define, as you may have already guessed, the details of the application's branding. You can access these branding properties by right-clicking on the branding module, and selecting <kbd class="calibre16">Branding...</kbd> near the bottom of the content menu. Upon doing so, you will be prompted with a screen like this one:</p>
<div class="mce-root1"><img class="image-border41" src="Images/d735d72c-57cb-4d36-b07b-d5c692d6ede1.png" width="639" height="588"/></div>
<p class="mce-root">In this preceding tab, you can set or change the name of the application, as well as specify the application icon.</p>
<p class="mce-root">In the <span class="calibre7">Splash Screen</span> tab, you can configure, most importantly, the image that is displayed on the splash screen as the application loads. You can also enable or disable the progress bar, and set the colors, font sizes, and positions of the progress bar and startup messages:</p>
<div class="mce-root1"><img class="image-border42" src="Images/67ceebc4-ef35-49f9-b1e0-dfbbcd90ec0e.png"/></div>
<p class="mce-root">The only other tab that is of interest to us at the moment is the <span class="calibre7">Window System</span> tab. In this tab, we can configure a number of features such as window drag and drop, window sliding, closing, and so on:</p>
<div class="mce-root1"><img class="image-border42" src="Images/9b96bcc7-18cf-4162-8c8b-d326e24059a3.png"/></div>
<p class="mce-root">More likely than not, the defaults are acceptable for our purposes here. However, in your own NetBeans RCP application, this screen may be much more important.</p>
<p class="mce-root">Our main interest is the <kbd class="calibre16">-app</kbd> module. This module is the one that will define all of the application's dependencies, and will be its entry point. Unlike the JavaFX applications we've seen in previous chapters, though, we don't need to define a <kbd class="calibre16">public static void main</kbd> method, as NetBeans handles that for us. In fact, the <kbd class="calibre16">-app</kbd> module doesn't have any Java classes in it at all, yet the app can run right out-of-the-box, though it doesn't do much. We'll fix that now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">NetBeans modules</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the strengths of the NetBeans platform is its modularity. If you've ever used the NetBeans IDE itself (before, say, reading this book), you've seen this modularity in action when working with plugins: every NetBeans plugin is made up of one or more modules. In fact, NetBeans itself is composed of numerous modules. That's how RCP applications are designed to work. It promotes decoupling, and makes extending and upgrading the application much simpler.</p>
<p class="mce-root">The generally accepted pattern is to, say, put the API classes in one module and the implementations in another. This makes the API classes reusable by other implementers, can help enforce low coupling by hiding private classes, and so on. To keep things simple as we learn the platform, though, we are going to create just one module that will provide all of the core functionality. To do that, we right-click on the <span class="calibre7">Modules</span> node under the parent project, and select <span class="calibre7">Create New Module...</span>: as shown in the following screenshot:</p>
<div class="mce-root1"><img class="image-border43" src="Images/65839393-7da8-4b95-97a6-e23bed8b59fe.png"/></div>
<p class="mce-root">Once selected, you will be shown the <span class="calibre7">New Project</span> window. Here, you will need to select the <span class="calibre7">Maven</span> category, and the <span class="calibre7">NetBeans Module</span> project type, as follows:</p>
<div class="mce-root1"><img class="image-border17" src="Images/b83bfd3d-7014-4b07-96f8-bfd0347f681a.png"/></div>
<p class="mce-root">Clicking on <span class="calibre7">Next</span> will get you the <span class="calibre7">Name</span> and <span class="calibre7">Location</span> step we've seen several times already in this book. On this pane, we'll name the module <kbd class="calibre16">main</kbd>, set the package to <kbd class="calibre16">com.steeplesoft.photobeans.main</kbd>, and accept the defaults for the other fields. On the next pane, <span class="calibre7">Module Options</span>, we will make sure that the <span class="calibre7">NetBeans Version</span> is the same as was selected earlier, and click on <span class="calibre7">Finish</span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">TopComponent - the class for tabs and windows</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We now have a module that is mostly empty. NetBeans created a few artifacts for us, but we need not concern ourselves with those, as the build will manage those for us. What we do need to do, though, is create our first GUI element, which will be something that NetBeans calls a TopComponent. From the NetBeans Javadoc, found at <a href="http://bits.netbeans.org/8.2/javadoc/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://bits.netbeans.org/8.2/javadoc/</span></a>, we find this definition:</p>
<div class="packt_quote">Embeddable visual component to be displayed in NetBeans. This is the basic unit of display--windows should not be created directly, but rather use this class. A top component may correspond to a single window, but may also be a tab (e.g.) in a window. It may be docked or undocked, have selected nodes, supply actions, etc.</div>
<p class="mce-root">As we'll see, this class is the main component of a NetBeans RCP application. It will hold and control various related user interface elements. It is, to put it another way, at the top of a component hierarchy in the user interface. To create TopComponent, we can use the NetBeans wizard by right-clicking on our now empty package in the <span class="calibre7">Project Explorer</span> tree, and selecting <span class="calibre7">New</span> | <span class="calibre7">Window</span>. If <span class="calibre7">Window</span> is not an option, select <span class="calibre7">Other</span> | <span class="calibre7">Module Development</span> | <span class="calibre7">Window</span>.</p>
<p class="mce-root">You should now see the following <span class="calibre7">Basic Settings</span> window:</p>
<div class="mce-root1"><img class="image-border44" src="Images/727678b4-39df-4316-9037-de24bae2dab2.png" width="666" height="417"/></div>
<p class="mce-root">We have a number of options in the preceding window. What we're creating is a window that will show a list of photos, so some reasonable settings would be to select the following:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Open on Application Start</span></li>
<li class="calibre14"><span class="calibre5">Closing not allowed</span></li>
<li class="calibre14"><span class="calibre5">Maximization not allowed</span></li>
</ul>
<p class="mce-root">These options seem pretty straightforward, but what is <span class="calibre7">Window Position</span>? Another of the benefits of using the NetBeans RCP as opposed to writing everything from scratch is that the platform provides a number of predefined concepts and facilities so that we don't need to worry about them. One such concern is window positioning and placement. The NetBeans user interface specification (which can be found on the NetBeans site at <a href="https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html</span></a>) defines the following areas:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Explorer:</strong> This is used for all windows that provide access to user objects, usually in tree browsers</li>
<li class="calibre14"><strong class="calibre3">Output:</strong> This is used for the Output window and VCS Output window by default</li>
<li class="calibre14"><strong class="calibre3">Debugger:</strong> This is used for all the debugger windows and other supporting windows that require a horizontal layout</li>
<li class="calibre14"><strong class="calibre3">Palette:</strong> This is used for the component palette window</li>
<li class="calibre14"><strong class="calibre3">Inspector:</strong> This is used for the component inspector window</li>
<li class="calibre14"><strong class="calibre3">Properties:</strong> This is used for the properties window</li>
<li class="calibre14"><strong class="calibre3">Documents:</strong> This is used for all the document windows</li>
</ul>
<p class="mce-root">The documentation also provides this helpful illustration:</p>
<div class="mce-root1"><img class="image-border45" src="Images/6f98b02c-9eb7-446b-8faf-6f6a9bc276e0.png" width="600" height="403"/></div>
<p class="mce-root">The specification page has a great deal of additional information, but this should be enough for now to get you going. We would like our photo list to be on the left side of the application window, so we select editor for the window position. Clicking on <span class="calibre7">Next</span>, we configure the name and icon for the component. Strictly speaking, we don't need to specify an icon for TopComponent, so we can just enter <kbd class="calibre16">PhotoList</kbd> for <span class="calibre7">Class Name Prefix:</span>, and click on <span class="calibre7">Finish</span>:</p>
<div class="mce-root1"><img class="image-border46" src="Images/2ff6d649-af7d-49d8-8e51-afe9137ad476.png"/></div>
<p class="mce-root">When you click on <span class="calibre7">Finish</span> here, NetBeans will create a couple of files for you, though only one will show up in the <span class="calibre7">Project Explorer</span> tree, that being <kbd class="calibre16">PhotoListTopComponent.java</kbd>. There is also a file called <kbd class="calibre16">PhotoListTopComponent.form</kbd> that you need to know about, though you will never edit it directly. NetBeans provides a very nice <strong class="calibre8">WYSIWYG</strong> (<span class="calibre7">what you see is what you get</span>) editor for building your user interface. The user interface definition is stored in the <kbd class="calibre16">.form</kbd> file, which is simply an XML file. As you make changes, NetBeans modifies this file for you, and generates the equivalent Java code in a method called <kbd class="calibre16">initComponents()</kbd>. You'll also notice that NetBeans will not allow you to modify the method. You can, of course, use another editor to do so, but any changes you make that way will be lost if you make changes in the GUI editor, so it's best just to leave the method alone. What does the rest of TopComponent look like?</p>
<pre class="calibre21">    @ConvertAsProperties( 
      dtd = "-//com.steeplesoft.photobeans.main//PhotoList//EN", 
      autostore = false 
    ) 
    @TopComponent.Description( 
      preferredID = "PhotoListTopComponent", 
      //iconBase="SET/PATH/TO/ICON/HERE", 
      persistenceType = TopComponent.PERSISTENCE_ALWAYS 
    ) 
    @TopComponent.Registration(mode = "editor",<br class="calibre2"/>     openAtStartup = true) 
    @ActionID(category = "Window", id =  
      "com.steeplesoft.photobeans.main.PhotoListTopComponent") 
    @ActionReference(path = "Menu/Window" /*, position = 333 */) 
    @TopComponent.OpenActionRegistration( 
      displayName = "#CTL_PhotoListAction", 
      preferredID = "PhotoListTopComponent" 
    ) 
    @Messages({ 
      "CTL_PhotoListAction=PhotoList", 
      "CTL_PhotoListTopComponent=PhotoList Window", 
      "HINT_PhotoListTopComponent=This is a PhotoList window" 
    }) 
    public final class PhotoListTopComponent <br class="calibre2"/>     extends TopComponent { </pre>
<p class="mce-root">That's a lot of annotations, but is also a good reminder of how much the NetBeans platform is doing for you. During the build process, these annotations are processed to create the metadata that the platform will use at runtime to configure and wire together your application.</p>
<p class="mce-root">Some of the highlights are as follows:</p>
<pre class="calibre21">    @TopComponent.Registration(mode = "editor",<br class="calibre2"/>      openAtStartup = true) </pre>
<p class="mce-root">This registers our <kbd class="calibre16">TopComponent</kbd>, and reflects our choices of where to put it and when to open it.</p>
<p class="mce-root">We also have some internationalization and localization work being done for us, as shown next:</p>
<pre class="calibre21">    @ActionID(category = "Window", id =  
      "com.steeplesoft.photobeans.main.PhotoListTopComponent") 
    @ActionReference(path = "Menu/Window" /*, position = 333 */) 
    @TopComponent.OpenActionRegistration( 
      displayName = "#CTL_PhotoListAction", 
      preferredID = "PhotoListTopComponent" 
    ) 
    @Messages({ 
      "CTL_PhotoListAction=PhotoList", 
      "CTL_PhotoListTopComponent=PhotoList Window", 
      "HINT_PhotoListTopComponent=This is a PhotoList window" 
    }) </pre>
<p class="mce-root">Without getting too far into the details and risking confusing things, the first three annotations register an open Action, and expose an item in the <kbd class="calibre16">Window</kbd> menu of our application. The last annotation, <kbd class="calibre16">@Messages</kbd>, is used to define the localization keys and strings. When this class is compiled, a class called <kbd class="calibre16">Bundle</kbd> is created in the same package, which defines methods using the specified keys to return the localized string. For example, for <kbd class="calibre16">CTL_PhotoListAction</kbd>, we get the following:</p>
<pre class="calibre21">    static String CTL_PhotoListAction() { 
      return org.openide.util.NbBundle.getMessage(Bundle.class,  
        "CTL_PhotoListAction"); 
    } </pre>
<p class="mce-root">This preceding code looks up the key in the standard Java <kbd class="calibre16">.properties</kbd> file for a localized message. These key/value pairs are merged with any entries found in the <kbd class="calibre16">Bundle.properties</kbd> file that the NetBeans wizard generated for us.</p>
<p class="mce-root">The following constructor of our <kbd class="calibre16">TopComponent</kbd> is also of interest:</p>
<pre class="calibre21">    public PhotoListTopComponent() { 
      initComponents(); 
      setName(Bundle.CTL_PhotoListTopComponent()); 
      setToolTipText(Bundle.HINT_PhotoListTopComponent()); 
      putClientProperty(TopComponent.PROP_CLOSING_DISABLED,  
       Boolean.TRUE); 
      putClientProperty(TopComponent.PROP_MAXIMIZATION_DISABLED,  
       Boolean.TRUE); 
    } </pre>
<p class="mce-root">In the preceding constructor, we can see how the component's name and tool tip are set, as well as where our window-related options are set.</p>
<p class="mce-root">If we run our application now, we won't see any changes. What we need to do, then, is add a dependency on the <kbd class="calibre16">main</kbd> module to the application. We do that by right-clicking on the <span class="calibre7">Dependencies</span> node of the app module, as shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border47" src="Images/11499e06-50f5-42d6-b683-4630c41fd4e7.png" width="525" height="415"/></div>
<p class="mce-root">You should now see the <span class="calibre7">Add Dependency</span> window. Select the <span class="calibre7">Open Projects</span> tab, then select <kbd class="calibre16">main</kbd> as shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border48" src="Images/86ef5273-a784-42a1-bca0-480786969a39.png" width="427" height="385"/></div>
<p class="mce-root">Once we've added the dependency, we need to build both modules, first <kbd class="calibre16">main</kbd> and then <kbd class="calibre16">app</kbd>, and then we'll be ready to run PhotoBeans for the first time:</p>
<div class="mce-root1"><img class="image-border49" src="Images/413c0faa-c309-4627-b2a7-e8a6d378bd0b.png" width="662" height="434"/></div>
<p class="mce-root">Notice the odd date in the window title in the preceding screen? That's the build date of the NetBeans platform, and it's not very pretty in our app, so, let's fix that. We have two options. The first is to use the Branding user interface we looked at earlier. The other is to edit the file directly. To keep things interesting, and to help understand where things are on the disk, we'll use this second approach.</p>
<p class="mce-root">In the branding module, under <span class="calibre7">Other Sources</span> | <span class="calibre7">nbm-branding</span>, you should find the <kbd class="calibre16">modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/ view/ui/Bundle.properties</kbd> file. In this file, you should see these lines:</p>
<pre class="calibre21">    CTL_MainWindow_Title=PhotoBeans {0} 
    CTL_MainWindow_Title_No_Project=PhotoBeans {0} </pre>
<p class="mce-root">All we need to do is remove the <kbd class="calibre16">{0}</kbd> portions, rebuild this module and the app, and our title bar is much prettier. While that looks better, what about our TopComponent? To fix that, we need to learn a few new concepts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Nodes, a NetBeans presentation object</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You've already heard the term Node. I've used it several times to describe what and where to click. Officially, a Node represents one element in a hierarchy of objects (beans). It provides all the methods that are needed for communication between an explorer view and the bean. In the explorer section of our application, we want to represent a list of photos to the user. We'll represent each photo, as well as the year and month in which it was taken, as a Node. To display these Nodes, we'll use a NetBeans class called the <kbd class="calibre16">BeanTreeView</kbd>, which will display this node hierarchy as a tree. There are a few more concepts to learn, but let's start with what we have first.</p>
<p class="mce-root">We'll begin by defining our Nodes, which will serve as a sort of wrapper or bridge between our application's business domain model and the NetBeans APIs. We have not, of course, defined such a model, so we need to settle on that now. Our basic data item is a photograph, a file on disk that holds an image. In the application, we're going to display these photos in a nested tree structure, grouping the photos by year, then month. If you expand a year node, you'll see a list of month Nodes, and if you expand a month Node, you'll see a list of photo Nodes. It's a very basic, somewhat naive data model, but it's both, effective enough to demonstrate the concepts, and simple enough that we don't obscure the concepts.</p>
<p class="mce-root">As with all hierarchies, we need a root node, so we'll start with that:</p>
<pre class="calibre21">    public class RootNode extends AbstractNode </pre>
<p class="mce-root">The base class of all nodes is, technically, Node, but extending that class puts much more of a burden on us, so we use the NetBeans-provided <kbd class="calibre16">AbstractNode</kbd>, which implements a fair amount of the basic behavior of the node for us with reasonable defaults.</p>
<p class="mce-root">Next, we define some constructors as follows:</p>
<pre class="calibre21">    public RootNode() { 
      this(new InstanceContent()); 
    } 
 
    protected RootNode(InstanceContent ic) { 
      super(Children.create(new YearChildFactory(), true), 
       new AbstractLookup(ic)); 
      setDisplayName(Bundle.LBL_RootNode()); 
      setShortDescription(Bundle.HINT_RootNode()); 
 
      instanceContent = ic; 
    } </pre>
<p class="mce-root">Note that we have two constructors, one <kbd class="calibre16">public</kbd> and one <kbd class="calibre16">protected</kbd>. The reason for that is that we want to create and capture an instance of <kbd class="calibre16">InstanceContent</kbd>, which can be used by us, the creators of this class' Lookup, to control what is actually in the lookup. Since we need to pass <kbd class="calibre16">Lookup</kbd> to our class' parent constructor, we have this two-step approach to object instantiation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Lookup, a NetBeans fundamental</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">What's a Lookup? It is a <strong class="calibre8">general registry permitting clients to find instances of services (implementation of a given interface)</strong>. To put it another way, it is a mechanism by which we can publish various artifacts, and other parts of the system can look up these artifacts by a key (either a <kbd class="calibre16">Class</kbd> or a <kbd class="calibre16">Lookup.Template</kbd>, which we'll not discuss here), with no coupling between the modules.</p>
<p class="mce-root">This is often used, as we'll see, to look up the implementations of a service interface. Do you recall earlier when I mentioned that often we see APIs defined in one module and implementations in another? This is where that comes in especially handy. Suppose you're developing an API to retrieve photos from an online service (which would be a great feature for this application!). You plan to deliver an implementation for one service, say Google Photos, but want to enable a third-party developer to provide an implementation for, say, Flickr. If you put the required API interfaces, classes, and so on in one module, and your Google Photos implementation in another, the third-party developer can depend on your API module alone, and avoid the weight of your implementation module. The Flickr module would declare an implementation of the photo service API, and we could load both that and our own Google Photos implementation via a request to the Lookup. In a nutshell, the system allows for decoupling the API definition, implementation, and instance acquisition in a very clean, simple API.</p>
<p class="mce-root">That's Lookup, but what is <kbd class="calibre16">InstanceContent</kbd>? The Lookup API only exposes methods for getting items. There is no mechanism for adding items to the Lookup, which makes sense as the Lookup instance is used by unknown third parties, and we don't want them changing the contents of our Lookup randomly. We, however, may actually want to change those contents, and we do that via <kbd class="calibre16">InstanceContent</kbd>, which exposes the methods we need to add or remove items. We'll see a demonstration of this concept later in the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Writing our own nodes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The preceding section covered those two classes, but what is <kbd class="calibre16">YearChildFactory</kbd>? The class <kbd class="calibre16">RootNode</kbd> defines for the system the root node of what will become our tree. Each node, though, if it has children, is responsible for loading and building those child Nodes, which is done through this <kbd class="calibre16">ChildFactory</kbd> class. Our instance looks like this:</p>
<pre class="calibre21">    public class YearChildFactory extends ChildFactory&lt;String&gt; { 
      private final PhotoManager photoManager; 
      private static final Logger LOGGER =  
        Logger.getLogger(YearChildFactory.class.getName()); 
      public YearChildFactory() { 
        this.photoManager =  
          Lookup.getDefault().lookup(PhotoManager.class); 
        if (photoManager == null) { 
          LOGGER.log(Level.SEVERE,  
          "Cannot get PhotoManager object"); 
          LifecycleManager.getDefault().exit(); 
        } 
      } 
 
      @Override 
      protected boolean createKeys(List&lt;String&gt; list) { 
        list.addAll(photoManager.getYears()); 
        return true; 
      } 
 
      @Override 
      protected Node createNodeForKey(String key) { 
        return new YearNode(Integer.parseInt(key)); 
      } 
    } </pre>
<p class="mce-root">We are creating a <kbd class="calibre16">ChildFactory</kbd> interface that will return nodes that operate on Strings. If you have a more complex data model, one that uses, for example, POJOs, you would specify that class as the parameterized type.</p>
<p class="mce-root">In our constructor, we see an example of finding a service implementation via the Lookup, which is this:</p>
<pre class="calibre21">    this.photoManager=Lookup.getDefault().lookup(<br class="calibre2"/>      PhotoManager.class); </pre>
<p class="mce-root">We'll look at defining services later, but, for now, all you need to understand is that we're asking the global Lookup (which is, unlike the Lookup we created previously, not tied to a particular class) for an instance of the <kbd class="calibre16">PhotoManager</kbd> interface. Perhaps naively, we assume there is only one instance of this interface, but since we're not exporting the interface, we are safe in our assumption. We do, though, check to make sure there is at least one, exiting the application if there is not.</p>
<p class="mce-root">The next two methods are how the factory is used to create the child Nodes. The first method, <kbd class="calibre16">createKeys(List&lt;String&gt; list)</kbd>, is called by the system to generate a list of keys for the child nodes. In our implementation, we ask the <kbd class="calibre16">PhotoManager</kbd> interface for a list of years (which, as we'll see, is a simple query of the database to get a list of the years for which we have photos in the system). The platform then takes these keys, and passes them, one at a time, to <kbd class="calibre16">createNodeForKey(String key)</kbd> to create the actual node. Here, we create an instance of <kbd class="calibre16">YearNode</kbd> to represent the year.</p>
<p class="mce-root"><kbd class="calibre16">YearNode</kbd>, like <kbd class="calibre16">RootNode</kbd>, extends <kbd class="calibre16">AbstractNode</kbd>.</p>
<pre class="calibre21">    public class YearNode extends AbstractNode { 
      public YearNode(int year) { 
        super(Children.create(new MonthNodeFactory(year), true),  
         Lookups.singleton(year)); 
        setName("" + year); 
        setDisplayName("" + year); 
      } 
    } </pre>
<p class="mce-root">The preceding is clearly a simpler node, but the basics are the same--we create <kbd class="calibre16">ChildFactory</kbd> to create our children, and we create a Lookup, which, in this case, holds a single value, the year that the Node represents.</p>
<p class="mce-root"><kbd class="calibre16">MonthNodeFactory</kbd> looks almost exactly like <kbd class="calibre16">YearNodeFactory</kbd> with the exception that it loads months for the given year, so we'll not show the source here. It also creates <kbd class="calibre16">MonthNode</kbd> instances for each month in the list. Like <kbd class="calibre16">YearNode</kbd>, <kbd class="calibre16">MonthNode</kbd> is pretty simple, as you can see in the following code snippet:</p>
<pre class="calibre21">    public class MonthNode extends AbstractNode { 
      public MonthNode(int year, int month) { 
        super(Children.create( 
          new PhotoNodeFactory(year, month), true),  
           Lookups.singleton(month)); 
          String display = month + " - " +  
           Month.values()[month-1].getDisplayName( 
             TextStyle.FULL, Locale.getDefault()); 
          setName(display); 
          setDisplayName(display); 
      } 
    } </pre>
<p class="mce-root">We do a bit more work to give the Node a meaningful name and display name, but it's pretty much the same. Note also that we have yet another <kbd class="calibre16">ChildFactory</kbd> that will generate, as the name implies, the PhotoNodes we'll need as children. The factory itself has nothing new of interest, but <kbd class="calibre16">PhotoNode</kbd> does, so let's take a look at that:</p>
<pre class="calibre21">    public class PhotoNode extends AbstractNode { 
      public PhotoNode(String photo) { 
        this(photo, new InstanceContent()); 
    } 
 
    private PhotoNode(String photo, InstanceContent ic) { 
      super(Children.LEAF, new AbstractLookup(ic)); 
      final String name = new File(photo).getName(); 
      setName(name); 
      setDisplayName(name); 
 
      ic.add((OpenCookie) () -&gt; { 
        TopComponent tc = findTopComponent(photo); 
        if (tc == null) { 
          tc = new PhotoViewerTopComponent(photo); 
          tc.open(); 
        } 
        tc.requestActive(); 
      }); 
    } </pre>
<p class="mce-root">Here we again see the dual constructor approach, though, in this case, we do make use of <kbd class="calibre16">InstanceContent</kbd>. Note that the first parameter to <kbd class="calibre16">super()</kbd> is <kbd class="calibre16">Children.LEAF</kbd>, indicating that this Node does not have any children. We also pass the now familiar <kbd class="calibre16">new AbstractLookup(ic)</kbd>.</p>
<p class="mce-root">After setting the name and display name, we add a lambda to our <kbd class="calibre16">InstanceContent</kbd> object. The non-lambda version of this would look like this:</p>
<pre class="calibre21">    ic.add(new OpenCookie() { 
      @Override 
      public void open() { 
      } 
    }); </pre>
<p class="mce-root">What is <kbd class="calibre16">OpenCookie</kbd>? It's a child of the marker interface <kbd class="calibre16">Node.Cookie</kbd>, and a cookie is <strong class="calibre8">a design pattern used to add behaviors to existing data objects and nodes, or to separate implementation from the main object</strong>. Using this cookie, we can neatly abstract away the signaling that something can be opened as well as how to open it.</p>
<p class="mce-root">In this case, when the system tries to open the photo represented by the node, it will call our definition of <kbd class="calibre16">OpenCookie.open()</kbd>, which will attempt to find an open instance of the photo. Whether it finds an existing one or needs to create a new one, it instructs the system to make it active (or give it focus).</p>
<p class="mce-root">Note that the open photo is represented by another TopComponent. To find it, we have this method:</p>
<pre class="calibre21">    private TopComponent findTopComponent(String photo) { 
      Set&lt;TopComponent&gt; openTopComponents =  
        WindowManager.getDefault().getRegistry().getOpened(); 
      for (TopComponent tc : openTopComponents) { 
        if (photo.equals(tc.getLookup().lookup(String.class))) { 
          return tc; 
        } 
      } 
      return null; 
    } </pre>
<p class="mce-root">We ask the Lookup of <kbd class="calibre16">WindowManager</kbd> for all the opened TopComponents, then iterate through each, comparing <kbd class="calibre16">String photo</kbd>, which is the full path of the image, with any <kbd class="calibre16">String</kbd> stored in the Lookup of TopComponent. If there's a match, we return that TopComponent. This lookup by <kbd class="calibre16">String</kbd> is somewhat naive though, and could, in more complex applications, result in unexpected matches. We're likely safe enough in this application, but you'll need to make sure in your own application that the matching criteria are strict and unique enough to avoid false hits.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Performing Actions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We'll look at <kbd class="calibre16">PhotoViewerTopComponent</kbd> in a moment, but there are a few more items we need to look at before moving on to that.</p>
<p class="mce-root"><kbd class="calibre16">PhotoNode</kbd> overrides two additional methods, which are as follows:</p>
<pre class="calibre21">    @Override 
    public Action[] getActions(boolean context) { 
      return new Action[]{SystemAction.get(OpenAction.class)}; 
    } 
 
    @Override 
    public Action getPreferredAction() { 
      return SystemAction.get(OpenAction.class); 
    } </pre>
<p class="mce-root">Unsurprisingly, the <kbd class="calibre16">getActions()</kbd> method returns an array of Actions for this Node. Actions are an abstraction (from Swing, not NetBeans) that allow us to add items to menus, and provide a means for a user to interact with the system. Each entry you see in the main menu or a context menu is backed by an Action. In our case, we're associating the NetBeans-defined <kbd class="calibre16">OpenAction</kbd> with our node, which will, when clicked, look for an <kbd class="calibre16">OpenCookie</kbd> instance in the Node's lookup and call <kbd class="calibre16">OpenCookie.open()</kbd>, which we defined previously.</p>
<p class="mce-root">We also override <kbd class="calibre16">getPreferredAction()</kbd>, which lets us define the behavior for when a Node is double-clicked. The combination of these two methods makes it possible for the user to right-click a Node and select <kbd class="calibre16">Open</kbd>, or double-click a Node, with the end result being that the TopComponent for that Node is opened.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Services - exposing decoupled functionality</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before looking at the definition of our <kbd class="calibre16">TopComponent</kbd>, let's look at <kbd class="calibre16">PhotoManager</kbd>, and learn a bit about its services. The <kbd class="calibre16">PhotoManager</kbd> interface itself is pretty simple:</p>
<pre class="calibre21">    public interface PhotoManager extends Lookup.Provider { 
      void scanSourceDirs(); 
      List&lt;String&gt; getYears(); 
      List&lt;String&gt; getMonths(int year); 
      List&lt;String&gt; getPhotos(int year, int month); 
    } </pre>
<p class="mce-root">There is little of interest in the preceding code beyond the <kbd class="calibre16">extends Lookup.Provider</kbd> portion. Adding this here, we can force implementations to implement the lone method on that interface, as we'll need that later. The interesting part comes from the implementation, which is as follows:</p>
<pre class="calibre21">    @ServiceProvider(service = PhotoManager.class) 
    public class PhotoManagerImpl implements PhotoManager { </pre>
<p class="mce-root">That is all it takes to register a service with the platform. The annotation specifies the metadata needed, and the build takes care of the rest. Let's take a look at the rest of the implementation:</p>
<pre class="calibre21">    public PhotoManagerImpl() throws ClassNotFoundException { 
      setupDatabase(); 
 
      Preferences prefs =  
        NbPreferences.forModule(PhotoManager.class); 
      setSourceDirs(prefs.get("sourceDirs", "")); 
      prefs.addPreferenceChangeListener(evt -&gt; { 
        if (evt.getKey().equals("sourceDirs")) { 
          setSourceDirs(evt.getNewValue()); 
          scanSourceDirs(); 
        } 
      }); 
 
      instanceContent = new InstanceContent(); 
      lookup = new AbstractLookup(instanceContent); 
      scanSourceDirs(); 
    } </pre>
<p class="mce-root">In this preceding, very simple, implementation, we're going to use SQLite to store information about the photos we find. The service will provide the code to scan the configured source directories, store information about the photos found, and expose methods for retrieving those pieces of that information that vary in specificity.</p>
<p class="mce-root">To start with, we need to make sure that the database is properly set up if this is the first time the application is run. We could include a prebuilt database, but creating it on the user's machine adds a bit of resilience for those situations where the database is accidentally deleted.</p>
<pre class="calibre21">    private void setupDatabase() { 
      try { 
       connection = DriverManager.getConnection(JDBC_URL); 
       if (!doesTableExist()) { 
         createTable(); 
       } 
      } catch (SQLException ex) { 
        Exceptions.printStackTrace(ex); 
      } 
    } 
 
    private boolean doesTableExist() { 
      try (Statement stmt = connection.createStatement()) { 
        ResultSet rs = stmt.executeQuery("select 1 from images"); 
        rs.close(); 
        return true; 
      } catch (SQLException e) { 
        return false; 
      } 
    } 
 
    private void createTable() { 
      try (Statement stmt = connection.createStatement()) { 
        stmt.execute( 
          "CREATE TABLE images (imageSource VARCHAR2(4096), " 
          + " year int, month int, image VARCHAR2(4096));"); 
          stmt.execute( 
            "CREATE UNIQUE INDEX uniq_img ON images(image);"); 
      } catch (SQLException e) { 
        Exceptions.printStackTrace(e); 
      } 
    } </pre>
<p class="mce-root">Next, we ask for a reference to the NetBeans preferences for the module <kbd class="calibre16">PhotoManager</kbd>. We'll look at managing preferences later in the chapter where we'll delve into this API in more detail, but, for now, we'll say only that we are going to ask the system for the <kbd class="calibre16">sourceDirs</kbd> preference, which we'll then use to configure our scanning code.</p>
<p class="mce-root">We also create <kbd class="calibre16">PreferenceChangeListener</kbd> to capture when the user changes the preferences. In this listener, we verify that the preference we care about, <kbd class="calibre16">sourceDirs</kbd>, was changed, and, if it was, we store the new value in our <kbd class="calibre16">PhotoManager</kbd> instance, and initiate a directory scan.</p>
<p class="mce-root">Finally, we create <kbd class="calibre16">InstanceContent</kbd>, create and store a Lookup, and start a directory scan to make sure the application is up-to-date with the state of the photos on disk.</p>
<p class="mce-root">The <kbd class="calibre16">getYears()</kbd>, <kbd class="calibre16">getMonths()</kbd>, and <kbd class="calibre16">getPhotos()</kbd> methods are largely the same, differing only, of course, in the type of data they're working with, so we'll let <kbd class="calibre16">getYears()</kbd> serve as an explanation of all three:</p>
<pre class="calibre21">    @Override 
    public List&lt;String&gt; getYears() { 
      List&lt;String&gt; years = new ArrayList&lt;&gt;(); 
      try (Statement yearStmt = connection.createStatement(); 
      ResultSet rs = yearStmt.executeQuery( 
        "SELECT DISTINCT year FROM images ORDER BY year")) { 
          while (rs.next()) { 
            years.add(rs.getString(1)); 
          } 
        } catch (SQLException ex) { 
          Exceptions.printStackTrace(ex); 
        } 
      return years; 
    } </pre>
<p class="mce-root">If you are familiar with JDBC, this should not be surprising. We use Java 7's <kbd class="calibre16">try-with-resources</kbd> syntax to declare and instantiate both our <kbd class="calibre16">Statement</kbd> and our <kbd class="calibre16">ResultSet</kbd> objects. For those not familiar with this construct, it allows us to declare certain types of resource, and not have to worry about closing them as the system automatically closes them for us once the scope of the <kbd class="calibre16">try</kbd> terminates. The major restriction to be aware of with this, however, is that the class must implement <kbd class="calibre16">AutoCloseable</kbd>; a <kbd class="calibre16">Closeable</kbd> will not work. The other two <kbd class="calibre16">get*</kbd> methods are logically similar, so they are not shown here.</p>
<p class="mce-root">The last major piece of functionality here is the scanning of source directories, which is coordinated by the <kbd class="calibre16">scanSourceDirs()</kbd> method, given as follows:</p>
<pre class="calibre21">    private final ExecutorService executorService =  
      Executors.newFixedThreadPool(5); 
    public final void scanSourceDirs() { 
      RequestProcessor.getDefault().execute(() -&gt; { 
        List&lt;Future&lt;List&lt;Photo&gt;&gt;&gt; futures = new ArrayList&lt;&gt;(); 
        sourceDirs.stream() 
         .map(d -&gt; new SourceDirScanner(d)) 
         .forEach(sds -&gt;  
          futures.add((Future&lt;List&lt;Photo&gt;&gt;)  
          executorService.submit(sds))); 
        futures.forEach(f -&gt; { 
          try { 
            final List&lt;Photo&gt; list = f.get(); 
            processPhotos(list); 
          } catch (InterruptedException|ExecutionException ex) { 
            Exceptions.printStackTrace(ex); 
          } 
        }); 
        instanceContent.add(new ReloadCookie()); 
      }); 
    } </pre>
<p class="mce-root">To speed the process up a bit, we create Future for each configured source directory, which we pass to our <kbd class="calibre16">ExecutorService</kbd>. We have it configured at a maximum of five threads in the pool, which is largely arbitrary. A more sophisticated approach might make this configurable, or perhaps, auto-tuned, but this should be sufficient for our purposes here.</p>
<p class="mce-root">Once the Futures are created, we iterate over the list, requesting each result. If the number of source directories exceeds the size of our thread pool, the excess Futures will wait until a Thread becomes available, at which point the <kbd class="calibre16">ExecutorService</kbd> will pick one to run. Once they're all done, the calls to <kbd class="calibre16">.get()</kbd> will no longer block, and the application can continue. Note that we're not blocking the user interface to allow this to work, as we pass the bulk of this method as a lambda to <kbd class="calibre16">RequestProcessor.getDefault().execute()</kbd> to request that this run off the user interface thread.</p>
<p class="mce-root">When the list of photos has been built and returned, we process those photos with this method:</p>
<pre class="calibre21">    private void processPhotos(List&lt;Photo&gt; photos) { 
      photos.stream() 
       .filter(p -&gt; !isImageRecorded(p)) 
       .forEach(p -&gt; insertImage(p)); 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">isImageRecorded()</kbd> method checks to see if the image path is already in the database, returning true if it is. We <kbd class="calibre16">filter()</kbd> the stream based on the result of this test, so <kbd class="calibre16">forEach()</kbd> only operates on previously unknown images, which are then inserted into the database via <kbd class="calibre16">insertImage()</kbd>. Those two methods look like this:</p>
<pre class="calibre21">    private boolean isImageRecorded(Photo photo) { 
      boolean there = false; 
      try (PreparedStatement imageExistStatement =  
        connection.prepareStatement( 
          "SELECT 1 FROM images WHERE image = ?")) { 
            imageExistStatement.setString(1, photo.getImage()); 
            final ResultSet rs = imageExistStatement.executeQuery(); 
            there = rs.next(); 
            close(rs); 
          } catch (SQLException ex) { 
            Exceptions.printStackTrace(ex); 
          } 
      return there; 
    } 
 
    private void insertImage(Photo photo) { 
      try (PreparedStatement insertStatement =  
       connection.prepareStatement( 
         "INSERT INTO images (imageSource, year, month, image)<br class="calibre2"/>          VALUES (?, ?, ?, ?);")) { 
            insertStatement.setString(1, photo.getSourceDir()); 
            insertStatement.setInt(2, photo.getYear()); 
            insertStatement.setInt(3, photo.getMonth()); 
            insertStatement.setString(4, photo.getImage()); 
            insertStatement.executeUpdate(); 
       } catch (SQLException ex) { 
         Exceptions.printStackTrace(ex); 
       } 
    } </pre>
<p class="mce-root">We are using <kbd class="calibre16">PreparedStatement</kbd>, as it is, generally, unwise to create SQL statements via concatenation, which can, and often does, lead to SQL injection attacks, so we can't use <kbd class="calibre16">try-with-resources</kbd> fully in the first method, requiring us to close the <kbd class="calibre16">ResultSet</kbd> manually.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">PhotoViewerTopComponent</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can now find images, but we still can't tell the system where to look. Before turning our attention to handling preferences with the NetBeans platform, though, we have one more TopComponent to look at--<kbd class="calibre16">PhotoViewerTopComponent</kbd>.</p>
<p class="mce-root">If you think back to our discussion of the areas provided by the NetBeans window system, when we view an image, we want the image to be loaded in the <kbd class="calibre16">Editor</kbd> area. To create a TopComponent for that, we instruct NetBeans to create a new <kbd class="calibre16">Window</kbd> by right-clicking on the desired package, and selecting <span class="calibre7">New</span> | <span class="calibre7">Window</span>:</p>
<div class="mce-root1"><img class="image-border9" src="Images/8c47fa0a-0bea-49e4-9902-cb6e79b0524b.png"/></div>
<p class="mce-root">In the next pane, we specify a class name prefix for our new TopComponent--<kbd class="calibre16">PhotoViewer</kbd> as seen in the following screenshot:</p>
<div class="mce-root1"><img class="image-border50" src="Images/2ec6f7a0-b7f3-49f5-b133-e919072c0608.png" width="723" height="512"/></div>
<p class="mce-root">NetBeans will now create the files <kbd class="calibre16">PhotoViewerTopComponent.java</kbd> and <kbd class="calibre16">PhotoViewerTopComponent.form</kbd> just as was discussed earlier. For this TopComponent, though, we need to make a couple of changes. When we open the <kbd class="calibre16">Window</kbd>, we need to specify an image for it to load, so we need to provide a constructor that takes the path to the image. However, TopComponents must have a no-argument constructor, so we leave it but have it call our new constructor with an empty image path.</p>
<pre class="calibre21">    public PhotoViewerTopComponent() { 
      this(""); 
    } 
 
    public PhotoViewerTopComponent(String photo) { 
      initComponents(); 
      this.photo = photo; 
      File file = new File(photo); 
      setName(file.getName()); 
      setToolTipText(photo); 
      associateLookup(Lookups.singleton(photo)); 
      setLayout(new BorderLayout()); 
      init(); 
    } </pre>
<p class="mce-root">While it may seem like a lot, the steps here are simple: we save the photo path in an instance variable, we create a <kbd class="calibre16">File</kbd> instance from it to get the file name more easily, add the photo path to TopComponent's Lookup (which is how we find the TopComponent for a given photo), change the layout, and then initialize the window.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Integrating JavaFX with the NetBeans RCP</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">init()</kbd> method is interesting, though, in that we're going to do something slightly different; we're going to use JavaFX to view the image. There's no reason we couldn't use Swing like we are in our other TopComponent, but this gives us a good opportunity to demonstrate both how to integrate JavaFX and Swing, as well as JavaFX and the NetBeans platform.</p>
<pre class="calibre21">    private JFXPanel fxPanel; 
    private void init() { 
      fxPanel = new JFXPanel(); 
      add(fxPanel, BorderLayout.CENTER); 
      Platform.setImplicitExit(false); 
      Platform.runLater(this::createScene); 
    } </pre>
<p class="mce-root"><kbd class="calibre16">JFXPanel</kbd> is a Swing component that is used to embed JavaFX into Swing. Our Window's layout is <kbd class="calibre16">BorderLayout</kbd>, so we add our <kbd class="calibre16">JFXPanel</kbd> to it in the <kbd class="calibre16">CENTER</kbd> area, and let it expand to fill the <kbd class="calibre16">Window</kbd>. Any complex layout of the JavaFX components will be handled by yet another container inside our <kbd class="calibre16">JFXPanel</kbd>. Our user interface, though, is fairly simple. As with our earlier JavaFX systems, we define our user interface via FXML as follows:</p>
<pre class="calibre21">    &lt;BorderPane fx:id="borderPane" prefHeight="480.0"  
      prefWidth="600.0"  
        
        
      fx:controller= 
        "com.steeplesoft.photobeans.main.PhotoViewerController"&gt; 
      &lt;center&gt; 
        &lt;ScrollPane fx:id="scrollPane"&gt; 
          &lt;content&gt; 
            &lt;Group&gt; 
              &lt;children&gt; 
                &lt;ImageView fx:id="imageView"  
                  preserveRatio="true" /&gt; 
              &lt;/children&gt; 
            &lt;/Group&gt; 
          &lt;/content&gt; 
        &lt;/ScrollPane&gt; 
      &lt;/center&gt; 
    &lt;/BorderPane&gt; </pre>
<p class="mce-root">Since FXML needs a root element, we specify a <kbd class="calibre16">BorderLayout</kbd>, which, as discussed, gives us a <kbd class="calibre16">BorderLayout</kbd> in a <kbd class="calibre16">JFXPanel</kbd> in a <kbd class="calibre16">BorderLayout</kbd>. That may sound really odd, but that's how embedding JavaFX works. Note also that we still specify a controller. In that controller, our <kbd class="calibre16">initialize()</kbd> method looks like this:</p>
<pre class="calibre21">    @FXML 
    private BorderPane borderPane; 
    @FXML 
    private ScrollPane scrollPane; 
    public void initialize(URL location,<br class="calibre2"/>     ResourceBundle resources) { 
       imageView.fitWidthProperty() 
        .bind(borderPane.widthProperty()); 
       imageView.fitHeightProperty() 
        .bind(borderPane.heightProperty()); 
    } </pre>
<p class="mce-root">In this last method, all we're doing is binding the width and height properties to those of the border pane. We've also set <kbd class="calibre16">preserveRatio</kbd> to <kbd class="calibre16">True</kbd> in the FXML, so the image won't be distorted. This will be important as we rotate the image next.</p>
<p class="mce-root">We haven't seen the code for rotation, so let's look at that now. We'll start by adding a button as follows:</p>
<pre class="calibre21">    &lt;top&gt; 
      &lt;ButtonBar prefHeight="40.0" prefWidth="200.0"  
         BorderPane.alignment="CENTER"&gt; 
         &lt;buttons&gt; 
           &lt;SplitMenuButton mnemonicParsing="false" 
             text="Rotate"&gt; 
              &lt;items&gt; 
                &lt;MenuItem onAction="#rotateLeft"  
                  text="Left 90" /&gt; 
                &lt;MenuItem onAction="#rotateRight"  
                  text="Right 90" /&gt; 
              &lt;/items&gt; 
            &lt;/SplitMenuButton&gt; 
         &lt;/buttons&gt; 
      &lt;/ButtonBar&gt; 
    &lt;/top&gt; </pre>
<p class="mce-root">To the <kbd class="calibre16">top</kbd> section of <kbd class="calibre16">BorderPane</kbd>, we add <kbd class="calibre16">ButtonBar</kbd>, to which we add a single <kbd class="calibre16">SplitMenuButton</kbd>. That gives us a button like the one to the right. In its non-focused state, it looks like a normal button. When the user clicks on the arrow, the menu, as seen here, is presented to the user, offering the ability to rotate the image in the directions listed:</p>
<div class="mce-root1"><img class="image-border51" src="Images/56cf767c-e5e9-404e-ab9d-6dc972baa744.png" width="104" height="114"/></div>
<p class="mce-root">We've tied those MenuItems to the appropriate methods in the controller in our FXML definition:</p>
<pre class="calibre21">    @FXML 
    public void rotateLeft(ActionEvent event) { 
      imageView.setRotate(imageView.getRotate() - 90); 
    } 
    @FXML 
    public void rotateRight(ActionEvent event) { 
      imageView.setRotate(imageView.getRotate() + 90); 
    } </pre>
<p class="mce-root">Using the APIs provided by the JavaFX <kbd class="calibre16">ImageView</kbd>, we set the image rotation.</p>
<p class="mce-root">We can find images, view them, and rotate them, but we still can't tell the system where to look for those images. It's time to fix that.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">NetBeans preferences and the Options panel</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The key to managing preferences is two-fold: <kbd class="calibre16">NbPreferences</kbd> and the <span class="calibre7">Options</span> panel. <kbd class="calibre16">NbPreferences</kbd> is the means by which preferences are stored and loaded, and the options panel is the means by which the user is presented with a user interface for editing those preferences. We'll start by looking at how to add an <span class="calibre7">Options</span> panel, which will lead naturally to the <kbd class="calibre16">NbPreferences</kbd> discussion. Next is the NetBeans Options window:</p>
<div class="mce-root1"><img class="image-border52" src="Images/b108fe68-8693-4927-8069-83f284306812.png"/></div>
<p class="mce-root">In the preceding window, we can see the two types of <span class="calibre7">Options</span> panel--primary and secondary. A primary <span class="calibre7">Options</span> panel is represented by icons across the top: <span class="calibre7">General</span>, <span class="calibre7">Editor</span>, <span class="calibre7">Fonts &amp; Colors</span>, and so on. A secondary <span class="calibre7">Options</span> panel is a tab like we see in the middle section: <span class="calibre7">Diff</span>, <span class="calibre7">Files</span>, <span class="calibre7">Output</span>, and <span class="calibre7">Terminal</span>. When adding an <span class="calibre7">Options</span> panel, you must choose either primary or secondary. We'd like to add a new primary panel, as it will separate our preferences from the rest of the panels visually as well as giving us an opportunity to create both types of panel.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding a primary panel</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To create a primary <span class="calibre7">Options</span> panel, right-click on the desired package or the project node, and click on <span class="calibre7">New</span> | <span class="calibre7">Options Panel</span>. If <span class="calibre7">Options Panel</span> is not visible, select <span class="calibre7">New</span> | <span class="calibre7">Other</span> | <span class="calibre7">Module Development</span> | <span class="calibre7">Options Panel</span>. Next, select <span class="calibre7">Create Primary Panel</span>:</p>
<div class="mce-root1"><img class="image-border53" src="Images/6518b75c-104d-4656-be9a-7e14daa5c644.png"/></div>
<p class="mce-root">We must specify a label, which is the text we'll see under the icon. We must also select an icon. The system will let you select something other than a 32x32 image, but if it's not the right size, it will look strange in the user interface; so, choose carefully. The system will also require you to enter keywords, which will be used if the user applies a filter to the Options window. Finally, select <span class="calibre7">Allow Secondary Panels</span>. The primary panel doesn't have any real content and serves only to display secondary panels, which we'll create shortly.</p>
<p class="mce-root">When you click on <span class="calibre7">Next</span>, you will be asked for the class prefix and package:</p>
<div class="mce-root1"><img class="image-border54" src="Images/749d7480-78b1-447e-b2ee-d47db788dd16.png"/></div>
<p class="mce-root">When you click on <span class="calibre7">Finish</span>, NetBeans will create this single file, <kbd class="calibre16">package-info.java</kbd>:</p>
<pre class="calibre21">    @OptionsPanelController.ContainerRegistration(id = "PhotoBeans", 
      categoryName = "#OptionsCategory_Name_PhotoBeans",  
      iconBase = "com/steeplesoft/photobeans/main/options/<br class="calibre2"/>       camera-icon-32x32.png",  
       keywords = "#OptionsCategory_Keywords_PhotoBeans",  
       keywordsCategory = "PhotoBeans") 
    @NbBundle.Messages(value = { 
      "OptionsCategory_Name_PhotoBeans=PhotoBeans",  
      "OptionsCategory_Keywords_PhotoBeans=photo"}) 
    package com.steeplesoft.photobeans.main.options; 
 
    import org.netbeans.spi.options.OptionsPanelController; 
    import org.openide.util.NbBundle; </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding a secondary panel</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With the primary panel defined, we're ready to create the secondary panel, which will do our work. We right-click on the package again, and select <span class="calibre7">New</span> | <span class="calibre7">Options Panel</span>, this time selecting <span class="calibre7">Create Secondary Panel</span>:</p>
<div class="mce-root1"><img class="image-border53" src="Images/114cafff-12a4-467e-847e-93e147c93cd1.png"/></div>
<p class="mce-root">Since we've defined our own primary panel, we can select that as our parent, and we set the title and keywords as we did before. Click on <span class="calibre7">Next</span>, select and/or verify the class prefix and package, then click on <span class="calibre7">Finish</span>. This will create three artifacts--<kbd class="calibre16">SourceDirectoriesOptionPanelController.java</kbd>, <kbd class="calibre16">SourceDirectoriesPanel.java</kbd>, and <kbd class="calibre16">SourceDirectoriesPanel.form</kbd>, and NetBeans will present you with the GUI editor for your panel.</p>
<p class="mce-root">We want to add four elements to our panel--a label, a list view, and two buttons. We add those by dragging them from the palette on the right, and arranging them in the form as shown next:</p>
<div class="mce-root1"><img class="image-border55" src="Images/cd85e87d-c291-4bb6-99da-9d4e8e943446.png" width="654" height="293"/></div>
<p class="mce-root">To make working with these user interface elements more meaningful, we need to set the variable names. We also need to set the text of the user interface so that each element is meaningful for the user. We can do both by right-clicking on each element, as shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border56" src="Images/7df36ce5-86ec-4fe6-a815-9d54afd9a885.png" width="825" height="301"/></div>
<p class="mce-root">In the preceding screen, we can see the three items of interest--<span class="calibre7">Edit Text</span>, <span class="calibre7">Change Variable Name...</span>, and <span class="calibre7">Events</span> | <span class="calibre7">Action</span> | <span class="calibre7">actionPeformed [buttonAddActionPerformed]</span>. For our buttons, we need to use all three, so we set the text to <kbd class="calibre16">Add</kbd> (or <kbd class="calibre16">Remove</kbd>), change the variable name to <kbd class="calibre16">buttonAdd</kbd>/<kbd class="calibre16">buttonRemove</kbd>, and select <kbd class="calibre16">actionPerformed</kbd>. Back in our Java source, we see a method created for us, which we need to fill out:</p>
<pre class="calibre21">    private void buttonAddActionPerformed(ActionEvent evt) {                                               
      String lastDir = NbPreferences 
       .forModule(PhotoManager.class).get("lastDir", null); 
      JFileChooser chooser = new JFileChooser(); 
      if (lastDir != null) { 
        chooser.setCurrentDirectory( 
          new java.io.File(lastDir)); 
      } 
      chooser.setDialogTitle("Add Source Directory"); 
      chooser.setFileSelectionMode(<br class="calibre2"/>        JFileChooser.DIRECTORIES_ONLY); 
      chooser.setAcceptAllFileFilterUsed(false); 
      if (chooser.showOpenDialog(null) ==  
        JFileChooser.APPROVE_OPTION) { 
          try { 
            String dir = chooser.getSelectedFile() 
            .getCanonicalPath(); 
            ensureModel().addElement(dir); 
            NbPreferences.forModule(PhotoManager.class) 
            .put("lastDir", dir); 
          } catch (IOException ex) { 
              Exceptions.printStackTrace(ex); 
            } 
        } else { 
            System.out.println("No Selection "); 
          } <br class="calibre2"/>    } </pre>
<p class="mce-root">We have quite a bit going on here:</p>
<ol class="calibre18">
<li class="chapter">We start by retrieving the <kbd class="calibre16">lastDir</kbd> preference value. If set, we'll use this as the starting point for selecting the directories to add. Typically, at least in my experience, the directories of interest are, usually, pretty close to one another in the filesystem, so we use this preference to save the user some clicks.</li>
<li class="chapter">Next we create <kbd class="calibre16">JFileChooser</kbd>, which is the Swing class that will allow us to choose the directory.</li>
<li class="chapter">If <kbd class="calibre16">lastDir</kbd> is not null, we pass it to <kbd class="calibre16">setCurrentDirectory()</kbd>.</li>
<li class="chapter">We set the title of the dialog to something meaningful.</li>
<li class="chapter">We specify that the dialog should only let us choose directories.</li>
<li class="chapter">Finally, we disable the <span class="calibre5">Select All file filter</span> option.</li>
<li class="chapter">We call <kbd class="calibre16">chooser.showOpenDialog()</kbd> to present the dialog to the user, and wait for it close.</li>
<li class="chapter">If the return code from the dialog is <kbd class="calibre16">APPROVE_OPTION</kbd>, we need to add the chosen directory to our model.</li>
</ol>
<ol start="9" class="calibre18">
<li class="chapter">We get the canonical path for the selected file.</li>
<li class="chapter">We call <kbd class="calibre16">ensureModel()</kbd>, which we'll look at in a moment, to get the model for our <kbd class="calibre16">ListView</kbd>, then add this new path to it.</li>
<li class="chapter">Finally, we store the chosen path as <kbd class="calibre16">lastDir</kbd> in our preferences to set the starting directory as discussed earlier.</li>
<li class="chapter">The action for the <span class="calibre5">Remove</span> button is much simpler, and is as follows:</li>
</ol>
<pre class="calibre21">        private void buttonRemoveActionPerformed(ActionEvent evt) {                                              
          List&lt;Integer&gt; indexes = IntStream.of( 
            sourceList.getSelectedIndices()) 
            .boxed().collect(Collectors.toList()); 
          Collections.sort(indexes); 
          Collections.reverse(indexes); 
          indexes.forEach(i -&gt; ensureModel().remove(i)); 
        } </pre>
<p class="mce-root">When we are removing items from the model, we remove them by the item index. However, when we remove an item, the index numbers for anything after that change. What we do here, then, is create a List of the selected indices, sort it to make sure it's in the right order (which is possibly excessive here, but it's a relatively inexpensive operation, and makes the next operation safer), then we reverse the order of the List. With our indices now in descending order, we can iterate over the List, removing each index from our model.</p>
<p class="mce-root">We've used <kbd class="calibre16">ensureModel()</kbd> a couple of times now, so let's see what that looks like:</p>
<pre class="calibre21">    private DefaultListModel&lt;String&gt; ensureModel() { 
      if (model == null) { 
        model = new DefaultListModel&lt;&gt;(); 
        sourceList.setModel(model); 
      } 
      return model; 
    } </pre>
<p class="mce-root">It's important that we treat the model as <kbd class="calibre16">DefaultListModel</kbd> rather than the <kbd class="calibre16">ListModel</kbd> type that <kbd class="calibre16">ListView</kbd> expects, as the latter does not expose any methods for mutating the contents of the model, whereas the former does. By dealing with <kbd class="calibre16">DefaultListModel</kbd>, we can add and remove items as needed, as we've done here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Loading and saving preferences</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two more methods we need to look at in this class, the ones that load and store the options represented in the panel. We'll start with <kbd class="calibre16">load()</kbd>, which is as follows:</p>
<pre class="calibre21">    protected void load() { 
      String dirs = NbPreferences 
       .forModule(PhotoManager.class).get("sourceDirs", ""); 
      if (dirs != null &amp;&amp; !dirs.isEmpty()) { 
        ensureModel(); 
        model.clear(); 
        Set&lt;String&gt; set = new HashSet&lt;&gt;( 
          Arrays.asList(dirs.split(";"))); 
        set.forEach(i -&gt; model.addElement(i)); 
      } 
    } </pre>
<p class="mce-root"><kbd class="calibre16">NbPreferences</kbd> does not support storing a list of strings, so, as we'll see below, we store the list of source directories as a semicolon-delimited list of strings. Here, we load the value of <kbd class="calibre16">sourceDirs</kbd>, and, if not null, we split on the semicolon, and add each entry to our <kbd class="calibre16">DefaultListModel</kbd>.</p>
<p class="mce-root">Saving the source directories is also fairly straightforward:</p>
<pre class="calibre21">    protected void store() { 
      Set&lt;String&gt; dirs = new HashSet&lt;&gt;(); 
      ensureModel(); 
      for (int i = 0; i &lt; model.getSize(); i++) { 
        final String dir = model.getElementAt(i); 
        if (dir != null &amp;&amp; !dir.isEmpty()) { 
          dirs.add(dir); 
        } 
      } 
      if (!dirs.isEmpty()) { 
        NbPreferences.forModule(PhotoManager.class) 
        .put("sourceDirs", String.join(";", dirs)); 
      } else { 
        NbPreferences.forModule(PhotoManager.class) 
          .remove("sourceDirs"); 
      } 
    } </pre>
<p class="mce-root">We iterate over <kbd class="calibre16">ListModel</kbd>, adding each directory to a local <kbd class="calibre16">HashSet</kbd> instance, which helps us remove any duplicate directories. If <kbd class="calibre16">Set</kbd> is not empty, we use <kbd class="calibre16">String.join()</kbd> to create our delimited list, and <kbd class="calibre16">put()</kbd> it into our preferences store. If it is empty, we remove the preference entry from the store to clear out any old data that may have been persisted earlier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reacting to changes in preferences</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that we can persist changes, we need to make the application react to the changes. Fortunately, the NetBeans RCP provides a neat, decoupled way to handle that. We need not explicitly call a method from our code here. We can attach a listener at the point in the system where we're interested in the change. We've already seen this code back in <kbd class="calibre16">PhotoManagerImpl</kbd>:</p>
<pre class="calibre21">    prefs.addPreferenceChangeListener(evt -&gt; { 
      if (evt.getKey().equals("sourceDirs")) { 
        setSourceDirs(evt.getNewValue()); 
        scanSourceDirs(); 
      } 
    }); </pre>
<p class="mce-root">When we save any preference for the <kbd class="calibre16">PhotoManager</kbd> module, this listener is called. We simply check to make sure it's for a key that we're interested in, and act accordingly, which, as we've seen, involves restarting the source directory scanning process.</p>
<p class="mce-root">Once new data has been loaded, how do we make the user interface reflect that change? Do we have to update the user interface manually? Again, thanks to the RCP, the answer is no. We've seen the first half at the end of <kbd class="calibre16">scanSourceDirs()</kbd>, which is this:</p>
<pre class="calibre21">    instanceContent.add(new ReloadCookie()); </pre>
<p class="mce-root">NetBeans has a number of cookie classes for indicating that certain actions should take place. While we don't share the class hierarchy (due to the unfortunate dependency on the Nodes API), we do share the same nomenclature with the hope of stealing, so to speak, a bit of the familiarity. So what does <kbd class="calibre16">ReloadCookie</kbd> look like? There's not much to it; it is given like this:</p>
<pre class="calibre21">    public class ReloadCookie { 
    } </pre>
<p class="mce-root">In our case, we just have an empty class. We don't intend for this to be used elsewhere, so we don't need to encode any functionality in the class. We will just be using this as an indicator, as we see in the constructor of <kbd class="calibre16">RootNode</kbd>, which is as follows:</p>
<pre class="calibre21">    reloadResult = photoManager.getLookup().lookup( 
      new Lookup.Template(ReloadCookie.class)); 
    reloadResult.addLookupListener(event -&gt; setChildren( 
      Children.create(new YearChildFactory(), true))); </pre>
<p class="mce-root"><kbd class="calibre16">Lookup.Template</kbd> is used to define the pattern by which the system can filter our <kbd class="calibre16">Lookup</kbd> requests. Using our template, we create a <kbd class="calibre16">Lookup.Result</kbd> object, <kbd class="calibre16">reloadResult</kbd>, and add a listener to it via a lambda. The lambda creates a new set of children using <kbd class="calibre16">Children.create()</kbd> and the <kbd class="calibre16">YearChildFactory</kbd> we looked at earlier, and passes those to <kbd class="calibre16">setChildren()</kbd> to update the user interface.</p>
<p class="mce-root">That may seem like a fair bit of code just to update the user interface when a preference is changed, but the decoupling is certainly worth it. Imagine a more complicated application or a dependent module tree. Using this listener approach, we need not expose methods, or even classes, to the outside world, allowing our internal code to be modified without breaking client code. That is, in short, one of the primary reasons for decoupled code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Once again, we've come to the end of another application. You learned how to bootstrap a Maven-based NetBeans Rich Client Platform application. You learned about RCP modules, and how to include those modules in our application build. You also learned the basics of the NetBeans RCP Node API, how to create our own nodes, and how to nest child nodes. We explained how to use the NetBeans Preferences API, including creating new Options panels for editing preferences, how to load and store them, and how to react to changes in preferences.</p>
<p class="mce-root">One final word on the NetBeans RCP--While we have built a respectable application here, we have in no way pushed the limits of the RCP. I have attempted to cover just enough of the platform to get you going, but you will almost certainly need to learn more if you are to continue using the platform. While the official documentation is helpful, the go-to source for comprehensive coverage is <em class="calibre20">NetBeans Platform for Beginners</em> by Jason Wexbridge and Walter Nyland (<a href="https://leanpub.com/nbp4beginners" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://leanpub.com/nbp4beginners</span></a>). It's a great book, and I highly recommend it.</p>
<p class="mce-root">In the next chapter, we're going to dip our toes into the waters of client/server programming, and implement our own note-taking application. It won't be as robust and full-featured as the competitors already in the market, but we'll make good headway in that direction and, hopefully, learn a lot along the way.</p>


            </article>

            
        </section>
    </div>



  </body></html>