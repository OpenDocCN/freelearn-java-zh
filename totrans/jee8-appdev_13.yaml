- en: Servlet Development and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to develop and deploy Java servlets. Servlets
    allow us, as application developers, to implement server-side logic in Java web
    and enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics covered include:'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of what servlets are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing, configuring, packaging, and deploying our first servlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML form processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forwarding HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting HTTP responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data across HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing servlets via annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet pluggability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring web applications programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 server push support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a servlet?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A servlet is a Java class used to extend the capabilities of servers that host
    server-side web applications. Servlets can respond to requests and generate responses.
    The base class for all servlets is `javax.servlet.GenericServlet`, defines a generic,
    protocol-independent servlet.
  prefs: []
  type: TYPE_NORMAL
- en: By far the most common type of servlet is an HTTP servlet. This type of servlet
    is used for handling HTTP requests and generating HTTP responses. An HTTP servlet
    is a class that extends the `javax.servlet.http.HttpServlet` class, which is a
    subclass of `javax.servlet.GenericServlet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A servlet must implement one or more methods to respond to specific HTTP requests.
    These methods are overridden from the parent `HttpServlet` class. As can be seen
    in the following table, these methods are named in such a way that knowing which
    one to use is intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request** | **HttpServlet method** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `doGet`(`HttpServletRequest` request, `HttpServletResponse` response)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `doPost`(`HttpServletRequest` request, `HttpServletResponse` response)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `doPut`(`HttpServletRequest` request, `HttpServletResponse` response)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `doDelete`(`HttpServletRequest` request, `HttpServletResponse`
    response) |'
  prefs: []
  type: TYPE_TB
- en: Each of these methods takes the same two parameters, namely an instance of a
    class implementing the `javax.servlet.http.HttpServletRequest` interface and an
    instance of a class implementing `javax.servlet.http.HttpServletResponse`. These
    interfaces will be covered in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Application developers never call the preceding methods directly, they are called
    automatically by the application server whenever it receives the corresponding
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Of the four methods listed previously, `doGet()` and `doPost()` are, by far,
    the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP `GET` request is generated whenever a user types the servlet's URL in
    the browser, when a user clicks on a link pointing to the servlet's URL, or when
    a user submits an HTML form using the `GET` method where the form's action points
    to the servlet's URL. In any of these cases, the code inside the servlet's `doGet()`
    method gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP `POST` request is typically generated when a user submits an HTML form
    using the `POST` method and an action pointing to the servlet's URL. In this case,
    the servlet's code inside the `doPost()` method gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first servlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will develop a simple servlet to illustrate how to use
    the servlet API. The code for our servlet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@WebServlet` annotation specifies that our class is a servlet; its `urlPatterns`
    attribute specifies the relative URL of our servlet.
  prefs: []
  type: TYPE_NORMAL
- en: Servlets can also be configured via a `web.xml` deployment descriptor; however,
    since Java EE 6 annotation-based configuration is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Since this servlet is meant to execute when a user enters its URL in the browser
    window, we need to override the `doGet()` method from the parent `HttpServlet`
    class. Like we explained previously, this method takes two parameters, an instance
    of a class implementing the `javax.servlet.http.HttpServletRequest` interface,
    and an instance of a class implementing the `javax.servlet.http.HttpServletResponse`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `HttpServletRequest` and `HttpServletResponse` are interfaces, application
    developers don't typically write classes implementing them. When control goes
    to a servlet from an HTTP request, the application server provides objects implementing
    these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing our `doGet()` method does is to set the content type for the
    `HttpServletResponse` object to `"text/html"`. If we forget to do this, the default
    content type used is `"text/plain"`, which means HTML tags will be displayed on
    the page, as opposed to being interpreted by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Then we obtain an instance of `java.io.PrintWriter` by calling the `HttpServletResponse.getWriter()`
    method. We can then send text output to the browser by calling the `PrintWriter.print()`
    and `PrintWriter.println()` methods (the previous example uses `println()` exclusively).
    Since we set the content type to `"text/html"`, any HTML tags are interpreted
    properly by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify that the servlet has been properly deployed, we need to point our
    browser to our application''s URL, for example, `http://localhost:8080/simpleapp/simpleservlet`.
    After doing so, we should see a page like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d82ab2cd-8846-411f-ab15-65eff3f119a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Processing HTML forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servlets are rarely accessed by typing their URL directly into the browser.
    The most common use for servlets is to process data entered by users in an HTML
    form. In this section, we illustrate this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML file containing the form for our application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value for the form's `action` attribute must match the value of the servlet's
    `urlPatterns` attribute in its `@WebServlet` annotation. Since the value of the
    form's `method` attribute is `"post"`, our servlet's `doPost()` method will be
    executed when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at our servlet''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in this example, we obtain a reference to the value the user
    typed by calling the `request.getParameter()` method. This method takes a single
    `String` object as its sole parameter, and the value of this string must match
    the name of the input field in the HTML file. In this case, the HTML file has
    a text field named `"enteredValue"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore the servlet has a corresponding line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line is used to obtain the text entered by the user and store it in the
    `String` variable named `enteredValue` (the name of the variable does not need
    to match the input field name, but naming it that way is good practice; it makes
    it easy to remember what value the variable is holding).
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging the preceding three files in a WAR file called `formhandling.war`,
    then deploying the WAR file, we can see the rendered HTML file by entering a URL
    similar to the following in the browser (the exact URL will depend on the Java
    EE application server being used): `http://localhost:8080/formhandling` .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/317765a7-0c8a-4aa1-9420-5612c01bfca5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the user enters some text in the text field and submits the form (either
    by hitting "Enter" or clicking on the Submit button), we should see the output
    of the servlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e68644c-775c-4b45-895d-5a4c8cc88f61.png)'
  prefs: []
  type: TYPE_IMG
- en: The `HttpServletRequest.getParameter()` method can be used to obtain the value
    of any HTML input field that can only return one value (text boxes, text areas,
    single selects, radio buttons, hidden fields, and so on). The procedure to obtain
    any of these fields' values is identical; in other words, the servlet doesn't
    care if the user typed in the value in a text field, selected it from a set of
    radio buttons, and so on. As long as the input field's name matches the value
    passed to the `getParameter()` method, the previous code will work.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with radio buttons, all related radio buttons must have the same
    name. Calling the `HttpServletRequest.getParameter()` method and passing the name
    of the radio buttons will return the value of the selected radio button.
  prefs: []
  type: TYPE_NORMAL
- en: Some HTML input fields such as checkboxes and multiple select boxes allow the
    user to select more than one value. For these fields, instead of using the `HttpServletRequest.getParameter()`
    method, the `HttpServletRequest.getParameterValues()` method is used. This method
    also takes a `String` containing the input field's name as its only parameter,
    and returns an array of strings containing all the values that were selected by
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates this case. The relevant sections of our new
    HTML markup are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The new HTML file contains a simple form with three checkboxes and a submit
    button. Notice how every checkbox has the same value for its `name` attribute.
    Like we mentioned before, any checkboxes that are clicked by the user will be
    sent to the servlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the servlet that will handle the preceding HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the `request.getParameterValues()` method and assigns
    its return value to the `selectedOptions` variable. Farther down the `doPost()`
    method, the code traverses the `selectedOptions` array and prints the selected
    values in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: If no checkboxes are clicked, the `request.getParameterValues()` method will
    return `null` , therefore it is a good idea to check for null before attempting
    to traverse through this method's return values.
  prefs: []
  type: TYPE_NORMAL
- en: After packaging our new servlet in a WAR file and deploying it, we can see the
    changes in action by typing its URL in the browser window. For most application
    servers, the URL will be `http://localhost:8080/formhandling/`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66d2e489-2b60-49dd-8859-0b5548f42032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After submitting the form, control goes to our servlet, and the browser window
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74da8611-f55f-4b40-b471-b0620e99469b.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, the actual message seen in the browser window will depend on what
    checkboxes the user clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: Request forwarding and response redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, one servlet processes form data, then transfers control to another
    servlet or JSP to do some more processing or display a confirmation message on
    the screen. There are two ways of doing this, either the request can be forwarded
    or the response can be redirected to another servlet or page.
  prefs: []
  type: TYPE_NORMAL
- en: Request forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice how text displayed in the previous section's example matches the value
    of the `value` attribute of the checkboxes that were clicked and not the labels
    displayed on the previous page. This might confuse the users. Let's modify the
    servlet to change these values so that they match the labels, then forward the
    request to another servlet that will display the confirmation message in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new version of `MultipleValueFieldHandlerServlet` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This version of the servlet iterates through the selected options and adds the
    corresponding label to an `ArrayList` of strings. This string is then attached
    to the `request` object by calling the `request.setAttribute()` method. This method
    is used to attach any object to the request so that any other code we forward
    the request to can have access to it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'After attaching the `ArrayList` to the request, we then forward the request
    to the new servlet in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `String` argument to this method must match the value of the `urlPatterns`
    tag of the servlet's `@WebServlet` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, control goes to our new servlet. The code for this new servlet
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code obtains the `ArrayList` that was attached to the request by the previous
    servlet. This is accomplished by calling the `request.getAttribute()` method;
    the parameter for this method must match the value used to attach the object to
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the preceding servlet obtains the list of option labels, it traverses
    through it and displays them in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b0879f1-5cba-4cd4-a48f-7046ba86c485.png)'
  prefs: []
  type: TYPE_IMG
- en: Forwarding a request as described previously only works for other resources
    (servlets and JSP pages) in the same context as the code doing the forwarding.
    In simple terms, the servlet or JSP we want to forward to must be packaged in
    the same WAR file as the code that is invoking the `request.getRequestDispatcher().forward()`
    method. If we need to direct the user to a page in another context (or even another
    server), we can do it by redirecting the response object.
  prefs: []
  type: TYPE_NORMAL
- en: Response redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One disadvantage of forwarding a request as described in the previous section
    is that requests can only be forwarded to other servlets or JSPs in the same context.
    If we need to direct the user to a page on a different context (deployed in another
    WAR file in the same server or deployed in a different server) we need to use
    the `HttpServletResponse.sendRedirect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate response redirection, let''s develop a simple web application
    that asks the user to select their favorite search engine, then directs the user
    to his/her search engine of choice. The HTML page for this application would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML form in the previous markup code contains three radio buttons, the
    value for each of them is the URL for the search engine corresponding to the user''s
    selection. Notice how the value for the name attribute of each radio button is
    the same, namely `"searchEngine"`. The servlet will obtain the value of the selected
    radio button by calling the `request.getParameter()` method and passing the string
    `"searchEngine"` as a parameter, as is demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By calling `request.getParameter("searchEngine")`, the preceding code assigns
    the URL of the selected search engine to the `url` variable. Then (after checking
    for `null`, in case the user clicked on the submit button without selecting a
    search engine), it directs the user to the selected search engine by calling `response.sendRedirect()`
    and passing the `url` variable as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `web.xml` file for this application should be fairly straightforward and
    is not shown (it is part of this book's code download).
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging the code and deploying it, we can see it in action by typing
    a URL similar to the following in the browser: `http://localhost:8080/responseredirection/`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2cfc300-9367-48ef-81b1-6cf30e6e5337.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking the Submit button, the user is directed to their favorite search
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that redirecting the response as illustrated previously
    creates a new HTTP request to the page we are redirecting to, therefore any request
    parameters and attributes are lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59f9675f-fb6f-475b-b12a-63664079f454.png)'
  prefs: []
  type: TYPE_IMG
- en: Persisting application data across requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how it is possible to store an object in the
    request by invoking the `HttpRequest.setAttribute()` method and how later this
    object can be retrieved by invoking the `HttpRequest.getAttribute()` method. This
    approach only works if the request was forwarded to the servlet invoking the `getAttribute()`
    method. If this is not the case, the `getAttribute()` method will return null.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to persist an object across requests. In addition to attaching
    an object to the request object, an object can also be attached to the session
    object or to the servlet context. The difference between these two is that objects
    attached to the session will not be visible to different users, whereas objects
    attached to the servlet context are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching objects to the session and servlet context is very similar to attaching
    objects to the request. To attach an object to the session, the `HttpServletRequest.getSession()`
    method must be invoked; this method returns an instance of `javax.servlet.http.HttpSession`.
    We then call the `HttpSession.setAttribute()` method to attach the object to the
    session. The following code fragment illustrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then retrieve the object from the session by calling the `HttpSession.getAttribute()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the return value of `session.getAttribute()` needs to be cast to
    the appropriate type. This is necessary since the return value of this method
    is `java.lang.Object` .
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to attach and retrieve objects to and from the servlet context
    is very similar. The servlet needs to call the `getServletContext()` method (defined
    in a class called `GenericServlet`, which is the parent class of `HttpServlet`,
    which in turn is the parent class of our servlets). This method returns an instance
    of `javax.servlet.ServletContext`, which defines a `setAttribute()` and a `getAttribute()`
    method. These methods work the same way as their `HttpServletRequest` and `HttpSessionResponse`
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure to attach an object to the servlet context is illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code attaches the `foo` object to the servlet context; this object
    will be available to any servlet in our application and will be the same across
    sessions. It can be retrieved by calling the `ServletContext.getAttribute()` method,
    as is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code obtains the `foo` object from the request context; again, a cast is
    needed since the `ServletContext.getAttribute()` method, like its counterparts,
    returns an instance of `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects attached to the servlet context are said to have a scope of *application*.
    Similarly, objects attached to the session are said to have a scope of *session*,
    and objects attached to the request are said to have a scope of *request*.
  prefs: []
  type: TYPE_NORMAL
- en: Passing initialization parameters to a servlet via annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is useful to pass some initialization parameters to a servlet;
    that way we can make sure the servlet behaves differently based on the parameters
    that are sent to it. For example, we may want to configure a servlet to behave
    differently in development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the old days, servlet initialization parameters were sent via the `<init-param>`
    parameter in `web.xml`. As of servlet 3.0, initialization parameters can be passed
    to the servlet as the value of the `initParams` attribute of the `@WebServlet`
    annotation. The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the value of the `initParams` attribute of the `@WebServlet`
    annotation is an array of `@WebInitParam` annotations. Each `@WebInitParam` annotation
    has two attributes—`name`, which corresponds to the parameter name, and `value`,
    which corresponds to the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: We can obtain the values of our parameters by invoking the `getInitParameter()`
    method on the `javax.servlet.ServletConfig` class. This method takes a single
    `String` argument as a parameter, corresponding to the parameter name, and returns
    a `String` corresponding to the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: Each servlet has a corresponding instance of `ServletConfig` assigned to it.
    As we can see in this example, we can obtain this instance by invoking `getServletConfig()`,
    which is a method inherited from `javax.servlet.GenericServlet`, the parent class
    of `HttpServlet`, which our servlets extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging our servlet in a WAR file and deploying to our Java EE 8 application
    server of choice, we will see the following page rendered in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed3ce70e-dd48-4b61-865f-e437d4880940.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the rendered values correspond to the values we set in each `@WebInitParam`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters were introduced to the servlet specification in version 2.3\. A filter
    is an object that can dynamically intercept a request and manipulate its data
    before the request is handled by the servlet. Filters can also manipulate a response
    after a servlet's `doGet()` or `doPost()` method finishes, but before the output
    is sent to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to configure a filter in earlier servlet specifications was to
    use the `<filter-mapping>` tag in `web.xml`. Servlet 3.0 introduced the ability
    to configure servlets via the `@WebFilter` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the example, the `@WebFilter` annotation has several attributes
    we can use to configure the filter. Of special importance is the `urlPatterns`
    attribute. This attribute takes an array of `String` objects as its value, and
    each element in the array corresponds to a URL that our filter will intercept.
    In our example, we are intercepting a single URL pattern, which corresponds to
    the servlet we wrote in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Other attributes in the `@WebFilter` annotation include the optional `filterName`
    attribute, which we can use to give our filter a name. If we don't specify a name
    for our filter, then the filter name defaults to the filter's class name.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the previous example, we can send initialization parameters
    to a filter. This is done the same way we send initialization parameters to a
    servlet. The `@WebFilter` annotation has an `initParams` attribute that takes
    an array of `@WebInitParam` annotations as its value. We can obtain the values
    of said parameters by invoking the `getInitParameter()` method on `javax.servlet.FilterConfig`,
    as illustrated in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our filter is fairly simple, it simply sends some output to the server log
    before and after the servlet is invoked. Inspecting the server log after deploying
    our application and pointing the browser to the servlet''s URL should reveal our
    filter''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Servlet filters, of course, have many real uses. They can be used for profiling
    web applications, for applying security, and for compressing data, among many
    other uses.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the lifetime of a typical web application, a number of events take place,
    such as HTTP requests getting created or destroyed, request or session attributes
    getting added, removed or modified, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The servlet API provides a number of listener interfaces we can implement in
    order to react to these events. All of these interfaces are in the `javax.servlet`
    package, and the following table summarizes them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Listener interface** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletContextListener` | Contains methods for handling context initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletContextAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the servlet context (application scope).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletRequestListener` | Contains methods for handling request initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletRequestAttributeListener` | Contains methods for reacting to any
    attributes added, removed, or replaced in the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpSessionListener` | Contains methods for handling HTTP session initialization
    and destruction events. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpSessionAttributeListener` | Contains methods for reacting to any attributes
    added, removed, or replaced in the HTTP session. |'
  prefs: []
  type: TYPE_TB
- en: All we need to do to handle any of the events handled by the interfaces described
    in the preceding table is to implement one of the previous interfaces and annotate
    it with the `@WebListener` interface, or declare it in the `web.xml` deployment
    descriptor via the `<listener>` tag. Unsurprisingly, the ability to use an annotation
    to register a listener was introduced in version 3.0 of the servlet specification.
  prefs: []
  type: TYPE_NORMAL
- en: The API for all of the preceding interfaces is fairly straightforward and intuitive.
    We will show an example for one of the preceding interfaces, and the others will
    be very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaDoc for all of the preceding interfaces can be found at: [https://javaee.github.io/javaee-spec/javadocs/](http://java.sun.com/javaee/6/docs/api/javax/servlet/http/package-summary.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to implement the `ServletRequestListener`
    interface, which can be used to perform an action whenever an HTTP request is
    created or destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all we need to do to activate our listener class is to annotate
    it with the `@WebListener` annotation. Our listener must also implement one of
    the listener interfaces we listed previously. In our example, we chose to implement
    `javax.servlet.ServletRequestListener`; this interface has methods that are automatically
    invoked whenever an HTTP request is initialized or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServletRequestListener` interface has two methods, `requestInitialized()`
    and `requestDestroyed()`. In our previous, simple implementation we simply sent
    some output to the log, but of course we can do anything we need to do in our
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying our previous listener along with the simple servlet we developed
    earlier in the chapter, we can see the following output in the application server
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the other listener interfaces is just as simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the original servlet API was released back in the late 1990s, writing servlets
    was the only way of writing server-side web applications in Java. Since then,
    several standard Java EE and third-party frameworks have been built on top of
    the Servlet API. Examples of such standard frameworks include JSP and JSF, and
    third-party frameworks include Struts, Wicket, Spring Web MVC, and several others.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, very few (if any) Java web applications are built using the Servlet
    API directly; instead, the vast majority of projects utilize one of the several
    available Java web application frameworks. All of these frameworks use the Servlet
    API "under the covers", therefore setting up an application to use one of these
    frameworks has always involved making some configuration in the application's
    `web.xml` deployment descriptor. In some cases, some applications use more than
    one framework, but this tends to make the `web.xml` deployment descriptor fairly
    large and hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet 3.0 introduced the concept of pluggability. Web application framework
    developers now have not one, but two ways to avoid having application developers
    have to modify the `web.xml` deployment descriptor in order to use their framework.
    Framework developers can choose to use annotations instead of a `web.xml` to configure
    their servlets; after doing this, all that is needed to use the framework is to
    include the library JAR file(s) provided by the framework developers in the application's
    WAR file. Alternatively, framework developers may choose to include a `web-fragment.xml`
    as part of the JAR file to be included in web applications that use their framework.
  prefs: []
  type: TYPE_NORMAL
- en: '`web-fragment.xml` is almost identical to `web.xml`, the main difference is
    that the root element of a `web-fragment.xml` is `<web-fragment>` as opposed to
    `<web-app>`. The following example illustrates a sample `web-fragment.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `web-fragment.xml` is almost identical to a typical `web.xml`.
    In this simple example, we only use the `<servlet>` and `<servlet-mapping>` elements,
    but all other usual `web.xml` elements, such as `<filter>`, `<filter-mapping>`,
    and `<listener>`, are available as well.
  prefs: []
  type: TYPE_NORMAL
- en: As specified in our `web-fragment.xml`, our servlet can be invoked via its URL
    pattern, `/WebFragment`, therefore the URL to execute our servlet once deployed
    as part of a web application would be `http://localhost:8080/webfragmentapp/WebFragment`.
    Of course, the host name, port, and context root must be adjusted as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do for any Java EE-compliant application server to pick up the
    settings in `web-fragment.xml` is to place the file in the `META-INF` folder of
    the library where we pack our servlet, filter, and/or listener, then place our
    library's JAR file in the `lib` folder of the WAR file containing our application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring web applications programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to allowing us to configure web applications through annotations
    and through a `web-fragment.xml`, Servlet 3.0 also allows us to configure our
    web applications programmatically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServletContext` class has new methods to configure servlets, filters,
    and listeners programmatically. The following example illustrates how to configure
    a servlet programmatically at runtime, without resorting to the `@WebServlet`
    annotation or to XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we invoke the `createServlet()` method of `ServletContext`
    to create the servlet that we are about to configure. This method takes an instance
    of `java.lang.Class` corresponding to our servlet's class. This method returns
    a class implementing `javax.servlet.Servlet` or any of its child interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create our servlet, we need to invoke `addServlet()` on our `ServletContext`
    instance to register our servlet with the servlet container. This method takes
    two parameters, the first being a `String` corresponding to the servlet name,
    the second being the servlet instance returned by the call to `createServlet()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have registered our servlet, we need to add a URL mapping to it. In
    order to do this, we need to invoke the `getServletRegistration()` method on our
    `ServletContext` instance, passing the servlet name as a parameter. This method
    returns the servlet container's implementation of `javax.servlet.ServletRegistration`.
    From this object, we need to invoke its `addMapping()` method, passing the URL
    mapping we wish our servlet to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example servlet is very simple, it simply displays a text message in the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After packing our code in a WAR file, deploying to GlassFish, and pointing
    the browser to the appropriate URL (that is, `http://localhost:8080/programmaticservletwebapp/ProgrammaticallyConfiguredServlet`,
    assuming we packaged the application in a WAR file named `programmaticservletwebapp.war`
    and didn''t override the default context root), we should see the following message
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ServletContext` interface has methods to create and add servlet filters
    and listeners, they work very similarly to the way the `addServlet()` and `createServlet()`
    methods work, therefore we won''t be discussing them in detail. Refer to the Java
    EE API documentation at: [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, servlets have created a single thread per request in Java web
    applications. After a request is processed, the thread is made available for other
    requests to use. This model works fairly well for traditional web applications,
    for which HTTP requests are relatively few and far between. However, most modern
    web applications take advantage of Ajax (Asynchronous JavaScript and XML), a technique
    that makes web applications behave much more responsively than traditional web
    applications. Ajax has the side effect of generating a lot more HTTP requests
    than traditional web applications, if some of these threads block for a long time
    waiting for a resource to be ready, or do anything that takes a long time to process,
    it is possible our application may suffer from thread starvation.
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate the situation described in the previous paragraph, the Servlet
    3.0 specification introduced asynchronous processing. Using this new capability,
    we are no longer limited to a single thread per request. We can now spawn a separate
    thread and return the original thread back to the pool, to be reused by other
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to implement asynchronous processing
    using the new capabilities introduced in Servlet 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do to make sure our asynchronous processing code
    works as expected is to set the `asyncSupported` attribute of the `@WebServlet`
    annotation to true.
  prefs: []
  type: TYPE_NORMAL
- en: To actually spawn an asynchronous process, we need to invoke the `startAsync()`
    method on the instance of `HttpServletRequest` that we receive as a parameter
    in the `doGet()` or `doPost()` method in our servlet. This method returns an instance
    of `javax.servlet.AsyncContext`. This class has a `start()` method that takes
    an instance of a class implementing `java.lang.Runnable` as its sole parameter.
    In our example, we used an anonymous inner class to implement `Runnable` in line;
    of course a standard Java class implementing `Runnable` can be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke the `start()` method of `AsyncContext`, a new thread is spawned
    and the `run()` method of the `Runnable` instance is executed. This thread runs
    in the background, the `doGet()` method returns immediately, and the request thread
    is immediately available to service other clients. It is important to notice that,
    even though the `doGet()` method returns immediately, the response is not committed
    until after the spawned thread finishes. It can signal it is done processing by
    invoking the `complete()` method on `AsyncContext`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we sent some entries to the application server log
    file to better illustrate what is going on. By observing the application server
    log right after our servlet executes, we should notice that all log entries are
    written to the log within a fraction of a second of each other; the message You
    should see this after a brief wait doesn't show in the browser until after the
    log entry indicating that we are leaving the `doGet()` method gets written to
    the log.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 server push support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP/2 is the newest version of the HTTP protocol. It offers several advantages
    over HTTP 1.1\. For example, with HTTP/2 there is a single connection between
    the browser and the server and this connection remains open until the user navigates
    to another page. HTTP/2 also offers multiplexing, meaning that several concurrent
    requests from the browser to the server are allowed. Additionally, HTTP/2 features
    server push, meaning that the server can send resources to the browser without
    the browser specifically having to request them.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP/2 server push support was added to the servlet specification in version
    4.0, released as part of Java EE 8\. In this section, we''ll see how we can write
    code to take advantage of HTTP/2''s server push functionality. The following example
    illustrates how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can push resources to the browser via the new `PushBuilder` interface, introduced
    in version 4 of the servlet specification. We can obtain an instance of a class
    implementing `PushBuilder` by invoking the new `PushBuilder()` method on the instance
    of `HttpServletRequest` we get as a parameter in our `doPost()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As its name implies, the `PushBuilder` interface implements the Builder pattern,
    meaning that most of its methods return a new instance of `PushBuilder` we can
    use, allowing us to conveniently chain together method invocations.
  prefs: []
  type: TYPE_NORMAL
- en: We indicate the path of the resource we'd like to push to the browser by invoking
    the appropriately named `path()` method from `PushBuilder`. This method takes
    a single `String` argument indicating the path of the resource to push. Paths
    beginning with a forward slash (`/`) indicate an absolute path, all other paths
    indicate a path relative to our application's context root.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have specified the path of our resource, we can optionally set some
    HTTP headers; in our case, we are pushing an image in PNG format, therefore we
    set the content type as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we invoke the `push()` method on our `PushBuilder` instance to actually
    push our resource to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: What we accomplished with our example was pushing a resource to the browser
    before the browser submitted a request for it; this task was impossible before
    the HTTP/2 protocol was released.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to develop, configure, package, and deploy servlets.
    We also covered how to process HTML form information by accessing the HTTP request
    object. Additionally, forwarding HTTP requests from one servlet to another was
    covered, as well as redirecting the HTTP response to a different server.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to persist objects in memory across requests by attaching them
    to the servlet context and the HTTP session. We also covered additional features
    of the servlet API, including configuring web applications via annotations, pluggability
    through `web-fragment.xml`, programmatic servlet configuration, and asynchronous
    processing. Finally, we covered the new Servlet 4.0 API that supports HTTP/2 server
    push.
  prefs: []
  type: TYPE_NORMAL
