["```java\nimport scalaz.Monoid\n\npackage object monoids {\n\n  // Int addition and int multiplication exist already,\n  // so we will show them in an example.\n  val stringConcatenation = new Monoid[String] {\n    override def zero: String = \"\"\n\n    override def append(f1: String, f2: => String): String = f1 + f2\n  }\n}\n```", "```java\nimport scalaz._\nimport Scalaz._\n\nobject MonoidsExample {\n\n  def main(args: Array[String]): Unit = {\n    val numbers = List(1, 2, 3, 4, 5, 6)\n    System.out.println(s\"The sum is: ${numbers.foldMap(identity)}\")\n    System.out.println(s\"The product (6!) is:\n     ${numbers.foldMap(Tags.Multiplication.apply)}\")\n    val strings = List(\"This is\\n\", \"a list of\\n\", \"strings!\")\n    System.out.println(strings.foldMap(identity)(stringConcatenation))\n  }\n}\n```", "```java\nimport org.scalacheck.Arbitrary\nimport org.scalatest.prop.Checkers\nimport org.scalatest.{FlatSpec, Matchers}\n\nimport scalaz._\n\nimport scalaz.scalacheck.ScalazProperties._\n\nclass MonoidsTest extends FlatSpec with Matchers with Checkers {\n\n  implicit def arbString(implicit ev: Arbitrary[String]):\n   Arbitrary[String] =\n    Arbitrary { ev.arbitrary.map(identity) }\n\n  \"stringConcatenation monoid\" should \"satisfy the identity rule.\" in {\n    monoid.laws[String](stringConcatenation, Equal.equalA[String],\n    arbString).check()\n  }\n}\n```", "```java\n<dependency>\n    <groupId>org.scalcheck</groupId>\n    <artifactId>scalacheck_2.12</artifactId>\n    <version>${scalacheck.version}</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.scalaz</groupId>\n    <artifactId>scalaz-scalacheck-binding_2.12</artifactId>\n    <version>${scalaz.version}</version>\n    <scope>test</scope>\n</dependency>\n```", "```java\n\"org.scalacheck\" %% \"scalacheck\" % scalacheckVersion % \"test\",\n\"org.scalaz\" %% \"scalaz-scalacheck-binding\" % scalazVersion % \"test\",\n```", "```java\nimport java.io.{PrintWriter, File}\n\nimport scala.io.Source\n\npackage object monads {\n  def readFile(path: String) = {\n    System.out.println(s\"Reading file ${path}\")\n    Source.fromFile(path).getLines()\n  }\n\n  def writeFile(path: String, lines: Iterator[String]) = {\n      System.out.println(s\"Writing file ${path}\")\n      val file = new File(path)\n      printToFile(file) { p => lines.foreach(p.println) }\n    }\n\n  private def printToFile(file: File)(writeOp: PrintWriter => Unit): Unit = {\n    val writer = new PrintWriter(file)\n    try {\n      writeOp(writer)\n    } finally {\n      writer.close()\n    }\n  }\n}\n```", "```java\nIvan   26\nMaria   26\nJohn   25\n```", "```java\ncase class Person(name: String, age: Int)\n\nobject Person {\n  def fromArray(arr: Array[String]): Option[Person] =\n    arr match {\n      case Array(name, age) => Some(Person(name, age.toInt))\n      case _ => None\n    }\n}\n```", "```java\nimport com.ivan.nikolov.monads.model.Person\n\nimport scalaz._\nimport effect._\nimport Scalaz._\nimport IO._\n\nobject IOMonadExample {\n\n  def main(args: Array[String]): Unit = {\n    args match {\n      case Array(inputFile, isWriteToFile) =>\n        val people = {\n          for {\n            line <- readFile(inputFile)\n            person <- Person.fromArray(line.split(\"\\t\"))\n          } yield person\n        }.pure[IO]\n\n        System.out.println(\"Still haven't done any IO!\")\n        System.out.println(\"About to do some...\")\n        if (isWriteToFile.toBoolean) {\n          val writePeople = for {\n            _ <- putStrLn(\"Read people successfully.\n             Where to write them down?\")\n            outputFile <- readLn\n            p <- people\n            _ <- writeFile(outputFile, p.map(_.toString)).pure[IO]\n          } yield ()\n          System.out.println(\"Writing to file using toString.\")\n          writePeople.unsafePerformIO \n        } else {\n          System.out.println(s\"Just got the following people:\n           ${people.unsafePerformIO.toList}\")\n        }\n      case _ =>\n        System.err.println(\"Please provide input file and true/false\n         whether to write to file.\")\n        System.exit(-1)\n    }\n  }\n}\n```", "```java\n<dependency>\n    <groupId>org.scalaz</groupId>\n    <artifactId>scalaz-effect_2.12</artifactId>\n    <version>${scalaz.version}</version>\n</dependency>\n```", "```java\n\"org.scalaz\" %% \"scalaz-effect\" % scalazVersion\n```", "```java\nval people = for {\n  lines <- readFile(inputFile).pure[IO]\n  p <- lines.map(i => Person(\"a\", 1)).pure[IO]\n} yield p\n```", "```java\n<dependency>\n    <groupId>com.typesafe</groupId>\n    <artifactId>config</artifactId>\n    <version>${typesafe.config.version}</version>\n</dependency>\n```", "```java\n\"com.typesafe\" % \"config\" % typesafeConfigVersion\n```", "```java\n<dependency>\n    <groupId>org.json4s</groupId>\n    <artifactId>json4s-native_2.12</artifactId>\n    <version>${json4s.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.json4s</groupId>\n    <artifactId>json4s-jackson_2.12</artifactId>\n    <version>${json4s.version}</version>\n</dependency>\n```", "```java\n\"org.json4s\" %% \"json4s-native\" % json4sVersion,\n\"org.json4s\" %% \"json4s-jackson\" % json4sVersion,\n```", "```java\n<dependency>\n    <groupId>com.typesafe.akka</groupId>\n    <artifactId>akka-actor_2.12</artifactId>\n    <version>${akka.version}</version>\n</dependency>\n```", "```java\n\"com.typesafe.akka\" %% \"akka-actor\" % akkaVersion\n```", "```java\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <version>1.4.197</version>\n</dependency>\n```", "```java\n\"com.h2database\" % \"h2\" % \"1.4.197\"\n```", "```java\nâ€¨job-scheduler {\n  config-path=\"/etc/scheduler/conf.d\"\n  config-extension=\"json\"\n  workers=4\n  db {\n    connection-string=\"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\"\n    username=\"\"\n    password=\"\"\n  }\n}\n```", "```java\npackage com.ivan.nikolov.scheduler.config.app\n\nimport com.typesafe.config.ConfigFactory\n\ntrait AppConfigComponent {\n  val appConfigService: AppConfigService\n\n  class AppConfigService() {\n    //-Dconfig.resource=production.conf for overriding\n private val conf = ConfigFactory.load()\n    private val appConf = conf.getConfig(\"job-scheduler\")\n    private val db = appConf.getConfig(\"db\")\n    val configPath = appConf.getString(\"config-path\")\n    val configExtension = appConf.getString(\"config-extension\")\n    val workers = appConf.getInt(\"workers\")\n    val dbConnectionString = db.getString(\"connection-string\")\n    val dbUsername = db.getString(\"username\")\n    val dbPassword = db.getString(\"password\")\n  }\n}\n```", "```java\npackage com.ivan.nikolov.scheduler.io\n\nimport java.io.File\n\ntrait IOServiceComponent {\n  val ioService: IOService\n\n  class IOService {\n    def getAllFilesWithExtension(basePath: String, extension: String):\n    List[String] = {\n      val dir = new File(basePath)\n      if (dir.exists() && dir.isDirectory) {\n        dir.listFiles()\n          .filter(f => f.isFile &&\n           f.getPath.toLowerCase.endsWith(s\".${extension}\"))\n          .map {\n            case f => f.getAbsolutePath\n          }.toList\n      } else {\n        List.empty\n      }\n    }\n  }\n\n}\n```", "```java\n{\n  \"name\": \"Ping Command\",\n  \"command\": \"ping google.com -c 10\",\n  \"frequency\": \"Hourly\",\n  \"type\": \"Console\",\n  \"time_options\": {\n    \"hours\": 21,\n    \"minutes\": 10\n  }\n}\n```", "```java\ncase class JobConfig(name: String, command: String, jobType: JobType, frequency: JobFrequency, timeOptions: TimeOptions)\n```", "```java\nimport org.json4s.CustomSerializer\nimport org.json4s.JsonAST.{JNull, JString}\n\nsealed trait JobType\ncase object Console extends JobType\ncase object Sql extends JobType\n\nobject JobTypeSerializer extends CustomSerializer[JobType](format => (\n  {\n    case JString(jobType) => jobType match {\n      case \"Console\" => Console\n      case \"Sql\" => Sql\n    }\n    case JNull => null\n  },\n  {\n    case jobType: JobType => \n     JString(jobType.getClass.getSimpleName.replace(\"$\", \"\"))\n  }\n))\n```", "```java\nimport org.json4s.CustomSerializer\nimport org.json4s.JsonAST.{JNull, JString}\n\nsealed trait JobFrequency\ncase object Daily extends JobFrequency\ncase object Hourly extends JobFrequency\n\ncase object JobFrequencySerializer extends CustomSerializer[JobFrequency](format => (\n  {\n    case JString(frequency) => frequency match {\n      case \"Daily\" => Daily\n      case \"Hourly\" => Hourly\n    }\n    case JNull => null\n  },\n  {\n    case frequency: JobFrequency =>\n     JString(frequency.getClass.getSimpleName.replace(\"$\", \"\"))\n  }\n))\n```", "```java\nimport java.time.LocalDateTime\nimport java.time.temporal.ChronoUnit\nimport java.util.concurrent.TimeUnit\n\nimport scala.concurrent.duration.{Duration, FiniteDuration}\n\ncase class TimeOptions(hours: Int, minutes: Int) {\n  if (hours < 0 || hours > 23) {\n    throw new IllegalArgumentException(\"Hours must be between 0 and 23:\n     \" + hours)\n  } else if (minutes < 0 || minutes > 59) {\n    throw new IllegalArgumentException(\"Minutes must be between 0 and\n     59: \" + minutes)\n  }\n\n  def getInitialDelay(now: LocalDateTime, frequency: JobFrequency):\n  FiniteDuration = {\n    val firstRun = now.withHour(hours).withMinute(minutes)\n    val isBefore = firstRun.isBefore(now)\n    val actualFirstRun = frequency match {\n      case Hourly =>\n        var tmp = firstRun\n        Iterator.continually({\n          tmp = tmp.plusHours(1); tmp\n        })\n          .takeWhile(d => d.isBefore(now))\n          .toList.lastOption.getOrElse(\n          if (isBefore)\n            firstRun\n          else\n            firstRun.minusHours(1)\n        ).plusHours(1)\n      case Daily =>\n        var tmp = firstRun\n        Iterator.continually({\n          tmp = tmp.plusDays(1); tmp\n        })\n          .takeWhile(d => d.isBefore(now))\n          .toList.lastOption\n          .getOrElse(\n            if (isBefore)\n              firstRun\n            else\n              firstRun.minusDays(1)\n          ).plusDays(1)\n    }\n    val secondsUntilRun = now.until(actualFirstRun, ChronoUnit.SECONDS)\n    Duration.create(secondsUntilRun, TimeUnit.SECONDS)\n  }\n}\n```", "```java\nimport java.io.File\nimport com.ivan.nikolov.scheduler.config.app.AppConfigComponent\nimport com.ivan.nikolov.scheduler.config.job.{JobTypeSerializer, JobFrequencySerializer, JobConfig}\nimport com.ivan.nikolov.scheduler.io.IOServiceComponent\nimport com.typesafe.scalalogging.LazyLogging\nimport org.json4s._\nimport org.json4s.jackson.JsonMethods._\n\ntrait JobConfigReaderServiceComponent {\n  this: AppConfigComponent with IOServiceComponent =>\n\n  val jobConfigReaderService: JobConfigReaderService\n\n  class JobConfigReaderService() extends LazyLogging {\n\n    private val customSerializers = List(\n JobFrequencySerializer,\n      JobTypeSerializer\n )\n\n implicit val formats = DefaultFormats ++ customSerializers +\n     JobConfig.jobConfigFieldSerializer\n\n    def readJobConfigs(): List[JobConfig] =\n      ioService.getAllFilesWithExtension(\n        appConfigService.configPath,\n        appConfigService.configExtension\n      ).flatMap {\n        case path => try {\n          val config = parse(FileInput(new File(path))).extract[JobConfig]\n          Some(config)\n        } catch {\n          case ex: Throwable =>\n            logger.error(\"Error reading config: {}\", path, ex)\n            None\n        }\n      }\n  }\n}\n```", "```java\nimport org.json4s.FieldSerializer\nimport org.json4s.JsonAST.JField\n\ncase class JobConfig(name: String, command: String, jobType: JobType, frequency: JobFrequency, timeOptions: TimeOptions)\n\nobject JobConfig {\n  val jobConfigFieldSerializer = FieldSerializer[JobConfig](\n    {\n      case (\"timeOptions\", x) => Some(\"time_options\", x)\n      case (\"jobType\", x) => Some(\"type\", x)\n    },\n    {\n      case JField(\"time_options\", x) => JField(\"timeOptions\", x)\n      case JField(\"type\", x) => JField(\"jobType\", x)\n    }\n  )\n\n}\n```", "```java\nsealed trait SchedulerMessage\ncase class Work(name: String, command: String, jobType: JobType)\ncase class Done(name: String, command: String, jobType: JobType, success: Boolean)\ncase class Schedule(configs: List[JobConfig])\n```", "```java\nclass Master(numWorkers: Int, actorFactory: ActorFactory) extends Actor with LazyLogging {\n  val cancelables = ListBuffer[Cancellable]()\n\n  val router = context.actorOf(\n Props(actorFactory.createWorkerActor()).withRouter(\n    RoundRobinPool(numWorkers)), \"scheduler-master-worker-router\"\n  )\n\n  override def receive: Receive = {\n    case Done(name, command, jobType, success) =>\n      if (success) {\n        logger.info(\"Successfully completed {} ({}).\", name, command)\n      } else {\n        logger.error(\"Failure! Command {} ({}) returned a non-zero\n         result code.\", name, command)\n      }\n    case Schedule(configs) => \n      configs.foreach {\n        case config =>\n          val cancellable = this.context.system.scheduler.schedule(\n            config.timeOptions.getInitialDelay(LocalDateTime.now(),\n             config.frequency),\n            config.frequency match {\n              case Hourly => Duration.create(1, TimeUnit.HOURS)\n              case Daily => Duration.create(1, TimeUnit.DAYS)\n            },\n            router,\n            Work(config.name, config.command, config.jobType)\n          )\n          cancellable +: cancelables\n          logger.info(\"Scheduled: {}\", config)\n      }\n  }\n\n  override def postStop(): Unit = {\n    cancelables.foreach(_.cancel())\n  }\n}\n```", "```java\nimport sys.process._\n\nclass Worker(daoService: DaoService) extends Actor with LazyLogging {\n\n  private def doWork(work: Work): Unit = {\n    work.jobType match {\n      case Console =>\n        val result = work.command.! // note - the ! are different methods\n        sender ! Done(work.name, work.command, work.jobType, result == 0)\n      case Sql =>\n        val connection = daoService.getConnection()\n        try {\n          val statement = connection.prepareStatement(work.command)\n          val result: List[String] = daoService.executeSelect(statement) {\n            case rs =>\n              val metadata = rs.getMetaData\n              val numColumns = metadata.getColumnCount\n              daoService.readResultSet(rs) {\n                case row =>\n                  (1 to numColumns).map {\n                    case i =>\n                      row.getObject(i)\n                  }.mkString(\"\\t\")\n              }\n          }\n          logger.info(\"Sql query results: \")\n          result.foreach(r => logger.info(r))\n          sender ! Done(work.name, work.command, work.jobType, true)\n        } finally {\n          connection.close()\n        }\n    }\n  }\n\n  override def receive: Receive = {\n    case w @ Work(name, command, jobType) => doWork(w)\n  }\n}\n```", "```java\npackage com.ivan.nikolov.scheduler.actors\n\nimport com.ivan.nikolov.scheduler.config.app.AppConfigComponent\nimport com.ivan.nikolov.scheduler.dao.DaoServiceComponent\n\ntrait ActorFactory {\n  def createMasterActor(): Master\n  def createWorkerActor(): Worker\n}\n\ntrait ActorFactoryComponent {\n  this: AppConfigComponent\n    with DaoServiceComponent =>\n\n  val actorFactory: ActorFactory\n\n  class ActorFactoryImpl extends ActorFactory {\n    override def createMasterActor(): Master =\n     new Master(appConfigService.workers, this)\n\n    override def createWorkerActor(): Worker = new Worker(daoService)\n  } \n}\n```", "```java\nCREATE TABLE people(\n  id INT PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  age INT NOT NULL\n);\n\nCREATE TABLE classes(\n  id INT PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n);\n\nCREATE TABLE people_classes(\n  person_id INT NOT NULL,\n  class_id INT NOT NULL,\n  PRIMARY KEY(person_id, class_id),\n  FOREIGN KEY(person_id) REFERENCES people(id) ON DELETE CASCADE ON UPDATE CASCADE,\n  FOREIGN KEY(class_id) REFERENCES classes(id) ON DELETE CASCADE ON UPDATE CASCADE\n);\n```", "```java\npackage com.ivan.nikolov.scheduler.registry\n\nimport com.ivan.nikolov.scheduler.actors.{ActorFactory, ActorFactoryComponent}\nimport com.ivan.nikolov.scheduler.config.app.AppConfigComponent\nimport com.ivan.nikolov.scheduler.dao._\nimport com.ivan.nikolov.scheduler.io.IOServiceComponent\nimport com.ivan.nikolov.scheduler.services.JobConfigReaderServiceComponent\n\nobject ComponentRegistry extends AppConfigComponent \n  with IOServiceComponent \n  with JobConfigReaderServiceComponent\n  with DatabaseServiceComponent\n  with MigrationComponent\n  with DaoServiceComponent\n  with ActorFactoryComponent {\n\n  override val appConfigService: ComponentRegistry.AppConfigService = new AppConfigService\n  override val ioService: ComponentRegistry.IOService = new IOService\n  override val jobConfigReaderService: ComponentRegistry.JobConfigReaderService = new JobConfigReaderService\n  override val databaseService: DatabaseService = new H2DatabaseService\n  override val migrationService: ComponentRegistry.MigrationService = new MigrationService\n  override val daoService: DaoService = new DaoServiceImpl\n  override val actorFactory: ActorFactory = new ActorFactoryImpl\n}\n```", "```java\npackage com.ivan.nikolov.scheduler\n\nimport akka.actor.{Props, ActorSystem}\nimport com.ivan.nikolov.scheduler.actors.messages.Schedule\nimport com.typesafe.scalalogging.LazyLogging\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.Duration\n\nobject Scheduler extends LazyLogging {\n  import com.ivan.nikolov.scheduler.registry.ComponentRegistry._\n  def main(args: Array[String]): Unit = {\n    logger.info(\"Running migrations before doing anything else.\")\n    migrationService.runMigrations()\n    logger.info(\"Migrations done!\")\n\n    val system = ActorSystem(\"scheduler\")\n\n    val master = system.actorOf(\n      Props(actorFactory.createMasterActor()),\n      \"scheduler-master\"\n    )\n\n    sys.addShutdownHook({\n      logger.info(\"Awaiting actor system termination.\")\n      // not great...\n      Await.result(system.terminate(), Duration.Inf)\n      logger.info(\"Actor system terminated. Bye!\")\n    })\n\n    master ! Schedule(jobConfigReaderService.readJobConfigs())\n    logger.info(\"Started! Use CTRL+C to exit.\")\n  }\n}\n```", "```java\npackage com.ivan.nikolov.scheduler\n\nimport com.ivan.nikolov.scheduler.actors.{ActorFactory, ActorFactoryComponent}\nimport com.ivan.nikolov.scheduler.config.app.AppConfigComponent\nimport com.ivan.nikolov.scheduler.dao._\nimport com.ivan.nikolov.scheduler.io.IOServiceComponent\nimport com.ivan.nikolov.scheduler.services.JobConfigReaderServiceComponent\nimport org.mockito.Mockito._\nimport org.scalatest.mockito.MockitoSugar\n\ntrait TestEnvironment \n  extends AppConfigComponent\n  with IOServiceComponent\n  with JobConfigReaderServiceComponent\n  with DatabaseServiceComponent\n  with MigrationComponent\n  with DaoServiceComponent\n  with ActorFactoryComponent\n  with MockitoSugar {\n\n  // use the test configuration file.\n  override val appConfigService: AppConfigService = spy(new AppConfigService)\n  // override the path here to use the test resources.\n  when(appConfigService.configPath).thenReturn(this.getClass.getResource(\"/\").getPath)\n\n  override val ioService: IOService = mock[IOService]\n  override val jobConfigReaderService: JobConfigReaderService = mock[JobConfigReaderService]\n  override val databaseService: DatabaseService = mock[DatabaseService]\n  override val migrationService: MigrationService = mock[MigrationService]\n  override val daoService: DaoService = mock[DaoService]\n  override val actorFactory: ActorFactory = mock[ActorFactory]\n}\n```", "```java\njob-scheduler {\n  config-path=\"/etc/scheduler/conf.d\"\n  config-extension=\"json\"\n  workers=4\n  db {\n    connection-string=\"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\"\n    username=\"\"\n    password=\"\"\n  }\n}\n```", "```java\n// ping.json\n{\n  \"name\": \"Ping Command\",\n  \"command\": \"ping google.com -c 10\",\n  \"frequency\": \"Hourly\",\n  \"type\": \"Console\",\n  \"time_options\": {\n    \"hours\": 21,\n    \"minutes\": 10\n  }\n}\n// ping1.json\n{\n  \"name\": \"Ping1 Command\",\n  \"command\": \"ping facebook.com -c 10\",\n  \"frequency\": \"Hourly\",\n  \"type\": \"Console\",\n  \"time_options\": {\n    \"hours\": 21,\n    \"minutes\": 15\n  }\n}\n// query.json\n{\n  \"name\": \"See all people\",\n  \"command\": \"SELECT * FROM people\",\n  \"frequency\": \"Hourly\",\n  \"type\": \"Sql\",\n  \"time_options\": {\n    \"hours\": 21,\n    \"minutes\": 5\n  }\n}\n```"]