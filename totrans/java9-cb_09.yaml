- en: GUI Programming Using JavaFX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaFX进行GUI编程
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Creating a GUI using JavaFX controls
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaFX控件创建GUI
- en: Using the FXML markup to create a GUI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FXML标记创建GUI
- en: Using CSS to style elements in JavaFX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS在JavaFX中设置元素样式
- en: Creating a bar chart
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating a pie chart
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Creating a line chart
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Creating an area chart
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a bubble chart
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Creating a scatter chart
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图
- en: Embedding HTML in an application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入HTML
- en: Embedding media in an application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入媒体
- en: Adding effects to controls
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为控件添加效果
- en: Using the new TIFF I/O API to read TIFF images
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的TIFF I/O API读取TIFF图像
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'GUI programming has been in Java since JDK 1.0, via the API called **Abstract
    Window Toolkit** (**AWT**). This was a remarkable thing during those times, but
    it had its own limitations, a few of which are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GUI编程自JDK 1.0以来就在Java中，通过名为**抽象窗口工具包**（**AWT**）的API实现。这在当时是一个了不起的事情，但它也有自己的局限性，以下是一些例子：
- en: It had a limited set of components
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有有限的组件集
- en: You couldn't create custom reusable components because AWT was using native
    components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于AWT使用原生组件，因此无法创建自定义的可重用组件
- en: The look and feel of the components couldn't be controlled and they took the
    look and feel of the host OS
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的外观和感觉无法控制，并且它们采用了宿主操作系统的外观和感觉
- en: 'Then, in Java 1.2, a new API for GUI development called **Swing** was introduced,
    which worked on the deficiencies of AWT by providing the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Java 1.2中，引入了一个新的GUI开发API，称为**Swing**，它通过提供以下功能来弥补AWT的不足：
- en: A richer components library.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更丰富的组件库。
- en: Support for creating custom components.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持创建自定义组件。
- en: Native look and feel and support for plugging in a different look and feel.
    Some of the know Java look and feel themes are Nimbus, Metal, Motif, and the system
    default.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地外观和感觉以及支持插入不同的外观和感觉。一些Java外观和感觉主题包括Nimbus、Metal、Motif以及系统默认值。
- en: A lot of desktop applications that make use of Swing have been built, and a
    lot of them are still being used. However, with time, technology has to evolve;
    otherwise, it will eventually be outdated and seldom used. In 2008, Adobe's Flex
    started gaining attention. It was a framework for building **Rich Internet applications**
    (**RIAs**). The desktop applications were always rich component-based UIs but
    the web applications were not that amazing to use. Adobe introduced a framework
    called Flex, which enabled web developers to create rich, immersive UIs on the
    web. So the web applications were no longer boring.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用Swing的桌面应用程序已经被构建，其中许多仍在使用。然而，随着时间的推移，技术必须发展；否则，它最终会过时，很少使用。2008年，Adobe的Flex开始引起关注。它是一个用于构建**丰富互联网应用程序**（**RIAs**）的框架。桌面应用程序始终是丰富的基于组件的UI，但Web应用程序并不那么令人惊叹。Adobe推出了一种名为Flex的框架，使Web开发者能够在Web上创建丰富、沉浸式的UI。因此，Web应用程序不再无聊。
- en: Adobe also introduced a rich internet application runtime environment for the
    desktop called Adobe AIR, which allowed running Flex applications on the desktop.
    This was a major blow to the age-old Swing API. In order to come back to the market,
    in 2009, Sun Microsystems introduced something called JavaFX. This framework was
    inspired by Flex (which used XML for defining the UI) and introduced its own scripting
    language called JavaFX script, somewhat closer to JSON and JavaScript. One could
    invoke Java APIs from the JavaFX script. There was a new architecture introduced,
    which had a new Windowing toolkit and a new graphics engine. It was a much better
    alternative to Swing but had a drawback--developers had to learn JavaFX script
    to develop JavaFX-based applications. In addition to Sun Microsystems not being
    able to invest more on JavaFX and the Java platform, in general, JavaFX never
    took off as envisioned.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe还推出了一种针对桌面的丰富互联网应用程序运行环境，称为Adobe AIR，它允许在桌面上运行Flex应用程序。这对古老的Swing API是一次重大打击。为了重返市场，2009年，Sun
    Microsystems推出了一种名为JavaFX的东西。这个框架受到了Flex（使用XML定义UI）的启发，并引入了自己的脚本语言，称为JavaFX脚本，它比JSON和JavaScript更接近。可以从JavaFX脚本中调用Java
    API。引入了一种新的架构，它有一个新的窗口工具包和一个新的图形引擎。它是对Swing的一个更好的替代品，但有一个缺点——开发者必须学习JavaFX脚本才能开发基于JavaFX的应用程序。除了Sun
    Microsystems无法在JavaFX和Java平台总体上投入更多之外，JavaFX从未像预期的那样起飞。
- en: Oracle (after acquiring Sun Microsystems) announced a new JavaFX version 2.0,
    which was an entire rewrite of JavaFX, thereby eliminating the scripting language
    and making JavaFX an API within the Java platform. This has made using the JavaFX
    API similar to using Swing APIs. Also, one can embed JavaFX components within
    Swing, thereby making Swing-based applications more functional. Since then, there
    has been no looking back for JavaFX.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle（在收购Sun Microsystems之后）宣布了一个新的JavaFX版本2.0，这是一个对JavaFX的全面重写，从而消除了脚本语言，使JavaFX成为Java平台内的API。这使得使用JavaFX
    API类似于使用Swing API。此外，可以在Swing中嵌入JavaFX组件，从而使基于Swing的应用程序功能更强大。从那时起，JavaFX就没有回头路了。
- en: In this chapter, we will focus entirely on the recipes around JavaFX. We will
    try to cover as many recipes as possible to give you all a good experience of
    using JavaFX.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完全关注JavaFX周围的食谱。我们将尝试涵盖尽可能多的食谱，以给您所有人提供良好的JavaFX使用体验。
- en: Creating a GUI using JavaFX controls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaFX控件创建GUI
- en: In this recipe, we will look at creating a simple GUI application using JavaFX
    controls. We will build an app that will help you compute your age by providing
    your date of birth. Optionally, you can even enter your name and the app will
    greet you and display your age. It is a pretty simple example, which tries to
    show how you can create a GUI by using layouts, components, and event handling.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看如何使用JavaFX控件创建一个简单的GUI应用程序。我们将构建一个应用程序，通过提供您的出生日期来帮助您计算年龄。可选地，您甚至可以输入您的姓名，应用程序将问候您并显示您的年龄。这是一个相当简单的例子，试图展示您如何通过使用布局、组件和事件处理来创建GUI。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The JDK you have installed comes with the JavaFX modules, so there isn''t anything
    needed to be done to start using JavaFX. Various modules that contain the JavaFX
    classes are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您已安装的JDK包含JavaFX模块，因此无需进行任何操作即可开始使用JavaFX。包含JavaFX类的各种模块如下：
- en: '`javafx.base`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.base`'
- en: '`javafx.controls`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.controls`'
- en: '`javafx.fxml`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.fxml`'
- en: '`javafx.graphics`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.graphics`'
- en: '`javafx.media`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.media`'
- en: '`javafx.swing`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.swing`'
- en: '`javafx.web`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.web`'
- en: In our recipe, we will be using a few modules as and when required from the
    preceding list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱中，我们将根据需要从前面列表中使用几个模块。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a class, which extends the `javafx.application.Application`. The `Application`
    class manages the lifecycle of the JavaFX application. The `Application` class
    has an abstract method, `start(Stage stage)`, which one has to implement. This
    would be our starting point for our JavaFX UI:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自`javafx.application.Application`的类。`Application`类管理JavaFX应用程序的生命周期。`Application`类有一个抽象方法`start(Stage
    stage)`，必须实现。这将是我们JavaFX UI的起点：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class can also be the starting point for the application by providing a
    `public static void main(String [] args) {}` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该类也可以通过提供`public static void main(String [] args) {}`方法作为应用程序的起点：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for the subsequent steps has to be written within the `start(Stage
    stage)` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 后续步骤的代码必须在`start(Stage stage)`方法中编写。
- en: 'Let''s create a container layout to properly align the components that we will
    be adding. In this case, we will use `javafx.scene.layout.GridPane` to lay the
    components in the form of a grid of rows and columns:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个容器布局，以正确对齐我们将要添加的组件。在这种情况下，我们将使用`javafx.scene.layout.GridPane`将组件排列成行和列的网格形式：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Along with creating the `GridPane` instance, we are setting its layout properties,
    such as the alignment of `GridPane`, the horizontal and vertical spaces between
    the rows and columns, and the padding within each cell of the grid.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`GridPane`实例的同时，我们正在设置其布局属性，例如`GridPane`的对齐方式、行与列之间的水平和垂直间距以及网格中每个单元格的填充。
- en: 'Create a new label, which will show the name of our application, specifically, `Age
    calculator`, and add it to `gridPane`, which we created in the preceding step:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的标签，用于显示我们应用程序的名称，特别是`Age calculator`，并将其添加到我们在前面步骤中创建的`gridPane`中：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a label and a text input combination, which will be used for accepting
    the user''s name. Then add these two components to `gridPane`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标签和一个文本输入框的组合，用于接受用户的姓名。然后将这两个组件添加到`gridPane`中：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a label and a date picker combination, which will be used for accepting
    the user''s date of birth:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标签和一个日期选择器的组合，用于接受用户的出生日期：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a button, which will be used by the user to trigger the age calculation,
    and add it to `gridPane`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮，用户将使用它来触发年龄计算，并将其添加到`gridPane`中：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a component to hold the result of the computed age:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件来保存计算出的年龄结果：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we need to bind an action to the button created in step 6\. The action
    would be to get the name entered in the name field and the date of birth entered
    in the date picker field. If the date of birth is provided, then use the Java
    time APIs to compute the period between now and the date of birth. If there is
    a name provided, then prepend a greeting, `Hello, <name>`, to the result:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将一个动作绑定到第6步中创建的按钮。这个动作将获取在姓名字段中输入的姓名和在日期选择器字段中输入的出生日期。如果提供了出生日期，则使用Java时间API计算现在和出生日期之间的时间段。如果提供了姓名，则在结果前添加问候语，`Hello,
    <name>`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create an instance of the `Scene` class by providing the `gridPane` object
    we created in step 2 and the dimensions, the width and height of the scene:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供我们在第2步中创建的`gridPane`对象和场景的宽度和高度来创建`Scene`类的实例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An instance of `Scene` holds the graph of the UI components, called scene graph.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`实例持有UI组件的图，称为场景图。'
- en: 'We have seen that the `start()` method provides us with a reference to a `Stage`
    object. The `Stage` object is the top-level container in JavaFX, something like
    a JFrame. We set the `Scene` object to the `Stage` object and use its `show()`
    method to render the UI:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到`start()`方法为我们提供了一个`Stage`对象的引用。`Stage`对象是JavaFX中的顶级容器，类似于Swing使用的AWT。我们将`Scene`对象设置到`Stage`对象，并使用其`show()`方法来渲染UI：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to launch this JavaFX UI from the main method. We use the `launch(String[]
    args)` method of the `Application` class to launch the JavaFX UI:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要从主方法启动这个JavaFX UI。我们使用`Application`类的`launch(String[] args)`方法来启动JavaFX
    UI：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete code can be found at `chp9/1_create_javafx_gui`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`chp9/1_create_javafx_gui`中找到。
- en: We have provided two scripts, `run.bat` and `run.sh`, in `chp9/1_create_javafx_gui`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/1_create_javafx_gui`中提供了两个脚本，`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，而`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下截图所示的GUI：
- en: '![](img/fad34879-3c71-4d00-bbb5-f747cf1c635d.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fad34879-3c71-4d00-bbb5-f747cf1c635d.png)'
- en: 'Enter the name and date of birth and click on `Calculate` to view the age:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输入姓名和出生日期，然后点击`Calculate`来查看年龄：
- en: '![](img/bacb4220-3851-4d61-8e84-e29c1ef47490.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bacb4220-3851-4d61-8e84-e29c1ef47490.png)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before going into the other details, let''s give you a brief overview of the
    JavaFX architecture. We have taken the following image describing the architecture
    stack from the JavaFX documentation ([http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入其他细节之前，让我们先简要概述一下JavaFX架构。我们已从JavaFX文档中提取了以下描述架构堆栈的图像（[http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)）：
- en: '![](img/5a9a9b29-e0fd-47fd-b21a-36aa95e815e2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a9a9b29-e0fd-47fd-b21a-36aa95e815e2.png)'
- en: 'Let''s start from the top of the stack:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从堆栈的顶部开始：
- en: '**The JavaFX APIs and Scene graph**: This is the starting point of the application
    and most of our focus will be around this part. This provides APIs for different
    components, layout, and other utilities to facilitate developing a JavaFX-based
    UI. The scene graph holds the visual elements of the application.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaFX API和场景图**：这是应用程序的起点，我们将大部分精力集中在这一部分。这提供了不同组件、布局和其他实用工具的API，以促进基于JavaFX的UI开发。场景图持有应用程序的视觉元素。'
- en: '**Prism, quantum toolkit, and the other stuff in blue**: These components manage
    the rendering of the UI and provide a bridge between the underlying operating
    system and JavaFX. This layer provides software rendering in the cases where the
    graphics hardware is unable to provide hardware-accelerated rendering of rich
    UI and 3D elements.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**棱镜、量子工具包以及蓝色中的其他组件**：这些组件管理UI的渲染，并在底层操作系统和JavaFX之间提供桥梁。这一层在图形硬件无法提供丰富UI和3D元素的硬件加速渲染的情况下提供软件渲染。'
- en: '**The Glass Windowing Toolkit**: This is the windowing toolkit, just like the
    AWT used by Swing.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玻璃窗口工具包**：这是窗口工具包，就像Swing使用的AWT。'
- en: '**The media engine**: This supports media in JavaFX.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体引擎**：这支持JavaFX中的媒体。'
- en: '**The web engine**: This supports the web component, which allows complete
    HTML rendering.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络引擎**：这支持网络组件，允许完全渲染HTML。'
- en: '**The JDK APIs and JVM**: These integrate with the Java API and compile the
    code down to byte code to run on the JVM.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK API 和 JVM**：这些与 Java API 集成，并将代码编译成字节码以在 JVM 上运行。'
- en: 'Let''s get back to explaining the recipe. The `javafx.application.Application`
    class is the entry point for launching the JavaFX applications. It has the following
    methods that map to the lifecycle of the application (in their invocation order):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到解释食谱。`javafx.application.Application` 类是启动 JavaFX 应用程序的入口点。它具有以下方法，这些方法映射到应用程序的生命周期（按调用顺序）：
- en: '**`init()`**: This method is invoked immediately after the instantiation of `javafx.application.Application`.
    One can override this method to do some initialization before the start of the
    application. By default, this method does nothing.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`init()`**：此方法在 `javafx.application.Application` 实例化后立即调用。可以在应用程序开始之前重写此方法以进行一些初始化。默认情况下，此方法不执行任何操作。'
- en: '`start(javafx.stage.Stage)`: This method is called immediately after `init()`
    and after the system has done the required initialization to run the application.
    This method is passed with a `javafx.stage.Stage` instance, which is the primary
    stage on which the components are rendered. One can create other `javafx.stage.Stage`
    objects but the one provided by the application is the primary stage.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start(javafx.stage.Stage)`：此方法在 `init()` 之后立即调用，并且在系统完成运行应用程序所需的初始化之后调用。此方法传递一个
    `javafx.stage.Stage` 实例，这是组件渲染的主要阶段。可以创建其他 `javafx.stage.Stage` 对象，但应用程序提供的是主要阶段。'
- en: '`stop()`: This method is called when the application should stop. One can do
    the necessary exit-related operations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`：当应用程序应该停止时调用此方法。可以执行必要的退出相关操作。'
- en: A stage is a top-level JavaFX container. The primary stage passed as an argument
    to the `start()` method is created by the platform, and the application can create
    other `Stage` containers as and when required.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段是一个顶级 JavaFX 容器。作为 `start()` 方法参数传递的主阶段是由平台创建的，并且应用程序可以在需要时创建其他 `Stage` 容器。
- en: 'The other important method related to `javafx.application.Application` is the
    `launch()` method. There are two variants of this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `javafx.application.Application` 相关的另一个重要方法是 `launch()` 方法。这个方法有两种变体：
- en: '`launch(Class<? extends Application> appClass, String... args)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch(Class<? extends Application> appClass, String... args)`'
- en: '`launch(String... args)`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch(String... args)`'
- en: This method is called from the main method and should be called only once. The
    first variant takes the name of the class that extends the `javafx.application.Application`
    class along with the arguments passed to the main method, and the second variant
    doesn't take the name of the class and, instead, should be invoked from within
    the class that extends the `javafx.application.Application` class. In our recipe,
    we have made use of the second variant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从主方法中调用，并且应该只调用一次。第一个变体接受扩展 `javafx.application.Application` 类的类的名称以及传递给主方法的参数，第二个变体不接收类的名称，而应该从扩展
    `javafx.application.Application` 类的类内部调用。在我们的食谱中，我们使用了第二个变体。
- en: We have created a class, `CreateGuiDemo`, which extends `javafx.application.Application`.
    This will be the entry point for JavaFX  UI and we also added a main method to
    the class, making it an entry point for our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `CreateGuiDemo` 的类，它扩展了 `javafx.application.Application`。这将是 JavaFX
    UI 的入口点，我们还向该类添加了一个主方法，使其成为我们应用程序的入口点。
- en: 'A layout construct determines how your components are laid out. There are multiple
    layouts supported by JavaFX, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 布局构造函数决定了你的组件如何布局。JavaFX支持多种布局，如下所示：
- en: '`javafx.scene.layout.HBox` and `javafx.scene.layout.VBox`: These are used to
    align the components horizontally and vertically'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.HBox` 和 `javafx.scene.layout.VBox`：这些用于水平垂直对齐组件'
- en: '`javafx.scene.layout.BorderPane`: This allows placing the components in the
    top, right, bottom, left, and center positions'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.BorderPane`：这允许将组件放置在顶部、右侧、底部、左侧和中心位置'
- en: '`javafx.scene.layout.FlowPane`: This layout allows placing the components in
    a flow, that is, beside each other, wrapping at the flow pane''s boundary'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.FlowPane`：这种布局允许将组件放置在流中，即并排放置，在流面板的边界处换行'
- en: '`javafx.scene.layout.GridPane`: This layout allows placing the components in
    a grid of rows and columns'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.GridPane`：这种布局允许将组件放置在行和列的网格中'
- en: '`javafx.scene.layout.StackPane`: This layout places the components in a back-to-front
    stack'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.StackPane`：这种布局将组件放置在从后到前的堆栈中'
- en: '`javafx.scene.layout.TilePane`: This layout places the components in a grid
    of uniformly sized tiles'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.TilePane`：这种布局将组件放置在大小均匀的网格中'
- en: 'In our recipe, we have made use of `GridPane` and configured the layout so
    that we can achieve the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜谱中，我们使用了`GridPane`并配置了布局，以便我们可以实现以下功能：
- en: The grid is placed at the center (`gridPane.setAlignment(Pos.CENTER);`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格被放置在中心位置（`gridPane.setAlignment(Pos.CENTER);`）
- en: Set the gap between the columns to 10 (`gridPane.setHgap(10);`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置列之间的间隔为10（`gridPane.setHgap(10);`）
- en: Set the gap between the rows to 10 (`gridPane.setVgap(10);`)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置行之间的间隔为10（`gridPane.setVgap(10);`）
- en: Set the padding within the cell of the grid (`gridPane.setPadding(new Insets(25,
    25, 25, 25));`)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置网格单元格内的填充（`gridPane.setPadding(new Insets(25, 25, 25, 25));`）
- en: A `javafx.scene.text.Text` component's font can be set using the `javafx.scene.text.Font`
    object as shown here: `appTitle.setFont(Font.font("Arial", FontWeight.NORMAL,
    15));`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.text.Font`对象可以设置`javafx.scene.text.Text`组件的字体，如下所示：`appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
- en: While adding the component to `javafx.scene.layout.GridPane`, we have to mention
    the column number, row number, and column span, that is, how many columns the
    component occupies, and the row span, that is, how many rows the component occupies
    in that order. The column span and row span are optional. In our recipe, we have
    placed `appTitle` in the first row and column, and it occupies two column spaces
    and one row space, as shown in the code here: `appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将组件添加到`javafx.scene.layout.GridPane`时，我们必须提到列号、行号和列跨度，即组件占用的列数和行跨度，即组件在该顺序中占用的行数。列跨度和行跨度是可选的。在我们的菜谱中，我们将`appTitle`放置在第一行第一列，它占用两个列空间和一个行空间，如代码所示：`appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
- en: 'The other important part in this recipe is the setting of the event for the `ageCalculator`
    button. We make use of the `setOnAction()` method of the `javafx.scene.control.Button`
    class to set the action performed when the button is clicked. This accepts an
    implementation of the `javafx.event.EventHandler<ActionEvent>` interface. As `javafx.event.EventHandler`
    is a functional interface, its implementation can be written in the form a lambda
    expression, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，另一个重要的部分是为`ageCalculator`按钮设置事件。我们使用`javafx.scene.control.Button`类的`setOnAction()`方法来设置按钮点击时执行的操作。这接受一个实现`javafx.event.EventHandler<ActionEvent>`接口的实现。由于`javafx.event.EventHandler`是一个函数式接口，其实现可以写成lambda表达式的形式，如下所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding syntax looks similar to your anonymous inner classes widely used
    during the times of Swing. You can learn more about functional interfaces and
    lambda expressions in the recipes in [Chapter 4](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml), *Going
    Functional*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法看起来与Swing时代广泛使用的匿名内部类相似。你可以在[第4章](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml)的菜谱中了解更多关于函数式接口和lambda表达式的信息，*走向函数式*。
- en: 'In our event handling code, we get the values from `nameField` and `dateOfBirthPicker` by
    using the methods, `getText()` and `getValue()`, respectively. `DatePicker` returns
    the date selected as an instance of `java.time.LocalDate`. This is one of the
    new date-time APIs added to Java 8\. It represents a date, that is, year, month,
    and day, without any timezone-related information. We then make use of the `java.time.Period`
    class to find the duration between the current date and the selected date, as
    follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的事件处理代码中，我们通过使用`getText()`和`getValue()`方法分别从`nameField`和`dateOfBirthPicker`获取值。`DatePicker`返回所选日期作为一个`java.time.LocalDate`实例。这是Java
    8中添加的新日期时间API之一。它表示一个日期，即年、月和日，没有任何时区相关信息。然后我们使用`java.time.Period`类来找到当前日期和所选日期之间的持续时间，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Period` represents the date-based duration in terms of years, months, and
    days, that is, for example, 3 years, 2 months, and 3 days. This is exactly what
    we are trying to extract with this line of code: `String.format("Your age is %d
    years %d months %d days",  period.getYears(), period.getMonths(), period.getDays())`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`以年、月和日为单位的日期持续时间表示，例如，3年、2个月和3天。这正是我们试图从这一行代码中提取的内容：`String.format("Your
    age is %d years %d months %d days", period.getYears(), period.getMonths(), period.getDays())`。'
- en: We have already mentioned that the UI components in JavaFX are represented in
    the form of a scene graph and this scene graph is then rendered on to a container,
    called `Stage`*.* The way to create a scene graph is by using the `javafx.scene.Scene`
    class. We create a `javafx.scene.Scene` instance by passing the root of the scene
    graph and also by providing the dimensions of the container in which the scene
    graph is going to be rendered.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，JavaFX中的UI组件以场景图的形式表示，然后该场景图被渲染到称为`Stage`的容器上。创建场景图的方法是使用`javafx.scene.Scene`类。我们通过传递场景图的根以及提供场景图将要渲染的容器的尺寸来创建一个`javafx.scene.Scene`实例。
- en: 'We make use of the container provided to the `start()` method, which is nothing
    but an instance of `javafx.stage.Stage`. Setting the scene for the `Stage` object
    and then calling its `show()` methods makes the complete scene graph rendered
    on the display:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`start()`方法提供的容器，这实际上是一个`javafx.stage.Stage`实例。为`Stage`对象设置场景并调用其`show()`方法，使完整的场景图在显示上渲染：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the FXML markup to create a GUI
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FXML标记创建GUI
- en: In our first recipe, we looked at using Java APIs to build a UI. It often happens
    that the person who is adept at Java might not be a good UI designer, that is,
    he may be poor at identifying the best user experience for their app. In the world
    of web development, we have developers working on the frontend, based on the designs
    given by the UX designer and the other set of developers working on the backend
    to build services that are consumed by the frontend.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个食谱中，我们探讨了使用Java API构建UI。通常情况下，精通Java的人可能不是一个好的UI设计师，也就是说，他可能在识别他们应用程序的最佳用户体验方面表现不佳。在Web开发的世界里，我们有开发者根据UX设计师提供的设计在前端工作，而另一组开发者则在后端工作，构建被前端消费的服务。
- en: Both the developer parties agree on a set of APIs and a common data interchange
    model. The frontend developers work by using some mock data based on the data
    interchange model and also integrate the UI with the required APIs. On the other
    hand, the backend developers work on implementing the APIs so that they return
    the data in the interchange model agreed upon.  So, both the parties work simultaneously
    using the expertise in their work areas.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 开发双方就一组API和公共数据交换模型达成一致。前端开发者通过使用基于数据交换模型的模拟数据来工作，并将UI与所需的API集成。另一方面，后端开发者致力于实现API，以便它们返回在交换模型中达成一致的数据。因此，双方同时使用各自工作领域的专业知识进行工作。
- en: It would be amazing if the same could be replicated (at least to some extent)
    on desktop applications. A step in this direction was the introduction of an XML-based
    language, called FXML. This enables a declarative method of UI development, where
    the developer can independently develop the UI using the same JavaFX components
    but available as XML tags. The different properties of the JavaFX components are
    available as attributes of the XML tags. Event handlers can be declared and defined
    in the Java code and then referred from FXML.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在桌面应用程序中能够实现同样的效果（至少在一定程度上），那将是非常令人惊叹的。在这个方向上迈出的一个步伐是引入了一种基于XML的语言，称为FXML。这允许使用声明性方法进行UI开发，其中开发者可以使用相同的JavaFX组件独立开发UI，这些组件作为XML标签提供。JavaFX组件的不同属性作为XML标签的属性提供。事件处理程序可以在Java代码中声明和定义，然后从FXML中引用。
- en: In this recipe, we will guide you through building the UI using FXML and then
    integrating FXML with the Java code for binding the action and for launching the
    UI defined in the FXML.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将指导你使用FXML构建UI，然后集成FXML与Java代码，以绑定动作并启动在FXML中定义的UI。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing much required if you have been able to implement the previous
    recipe. If you are coming directly to this recipe, there is nothing much to do
    either. The JavaFX APIs come with OpenJDK, which you must already have installed
    on your systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经能够实现前面的食谱，那么就没有太多需要做的。如果你是直接来到这个食谱的，也没有太多需要做的。JavaFX API与OpenJDK一起提供，你必须已经在你系统上安装了它。
- en: We will develop a simple age calculator app. This app will ask for the user's
    name (which is optional) and the date of birth, and calculate the age from the
    given date of birth and display it to the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个简单的年龄计算器应用程序。此应用程序将要求用户输入姓名（可选）和出生日期，并从给定的出生日期计算年龄，并将其显示给用户。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: All the FXML files should end with the `.fxml` extension. Let's create an empty `fxml_age_calc_gui.xml`
    file in the location, `src/gui/com/packt`. In the subsequent steps, we will update
    this file with the XML tags for the JavaFX components.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有FXML文件都应该以`.fxml`扩展名结尾。让我们在`src/gui/com/packt`位置创建一个空的`fxml_age_calc_gui.xml`文件。在后续步骤中，我们将使用JavaFX组件的XML标签更新此文件：
- en: 'Create a `GridPane` layout, which will hold all the components in a grid of
    rows and columns. We will also provide the required spacing between the rows and
    the columns using the `vgap` and `hgap` attributes. Also, we will provide `GridPane`,
    which is our root component, with the reference to the Java class where we will
    add the required event handling. This Java class will be like the controller for
    the UI:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GridPane`布局，它将按行和列的网格形式持有所有组件。我们还将使用`vgap`和`hgap`属性提供行与列之间所需的空间。此外，我们还将为我们的根组件`GridPane`提供对将添加所需事件处理的Java类的引用。这个Java类将类似于UI的控制器：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will provide the padding within each cell of the grid by defining a `padding`
    tag with `Insets` within `GridPane`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过在`GridPane`中定义一个带有`Insets`的`padding`标签来为网格中的每个单元格提供填充：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next is to add a `Text` tag, which displays the title of the application: `Age
    Calculator`. We provide the required style information in the `style` attribute
    and the placement of the `Text` component within `GridPane` using the `GridPane.columnIndex`
    and `GridPane.rowIndex` attributes. The cell occupancy information can be provided
    using the `GridPane.columnSpan` and `GridPane.rowSpan` attributes:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是添加一个显示应用程序标题的`Text`标签：`Age Calculator`。我们在`style`属性中提供所需样式信息，并使用`GridPane.columnIndex`和`GridPane.rowIndex`属性在`GridPane`中放置`Text`组件。可以使用`GridPane.columnSpan`和`GridPane.rowSpan`属性提供单元格占用信息：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then add the `Label` and `TextField` components for accepting the name.
    Note the use of the `fx:id` attribute in `TextField`. This helps in binding this
    component in the Java controller by creating a field with the same name as that
    of the `fx:id` value:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加用于接受名称的`Label`和`TextField`组件。注意在`TextField`中使用了`fx:id`属性。这有助于通过创建与`fx:id`值相同的字段来在Java控制器中绑定此组件：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We add the `Label` and `DatePicker` components for accepting the date of birth:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了用于接受出生日期的`Label`和`DatePicker`组件：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we add a `Button` object and set its `onAction` attribute to the name
    of the method in the Java controller that handles the click event of this button:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`Button`对象，并将其`onAction`属性设置为处理此按钮点击事件的Java控制器中的方法名称：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally we add a `Text` component to display the calculated age:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们添加一个`Text`组件来显示计算出的年龄：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to implement the Java class, which is directly related to
    the XML-based UI components created in the preceding steps. Create a class named `FxmlController`.
    This will contain the code that is relevant to the FXML UI; that is, it will contain
    the references to the components created in the FXML action handlers for the components
    created in the FXML:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现与前面步骤中创建的基于XML的UI组件直接相关的Java类。创建一个名为`FxmlController`的类。这将包含与FXML UI相关的代码；也就是说，它将包含对在FXML动作处理程序中创建的组件的引用：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need references to the `nameField`, `dateOfBirthPicker`, and `resultText`
    components . We use the first two to get the entered name and date of birth, respectively,
    and the third to display the result of age calculation:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`nameField`、`dateOfBirthPicker`和`resultText`组件的引用。我们使用前两个来获取输入的名称和出生日期，第三个来显示年龄计算的结果：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to implement the `calculateAge` method, which is registered
    as the action event handler for the `Calculate` button. The implementation is
    similar to the one in the previous recipe. The only difference is that it is a
    method, unlike the previous recipe, where it was a lambda expression:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现`calculateAge`方法，该方法被注册为`Calculate`按钮的动作事件处理程序。实现方式与前面的食谱类似。唯一的区别是它是一个方法，而前面的食谱中它是一个lambda表达式：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In both steps 10 and 11, we have used an annotation, `@FXML`. This annotation
    indicates that the class or the member is accessible to the FXML-based UI.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤10和11中，我们都使用了注解`@FXML`。这个注解表示类或成员对基于FXML的UI是可访问的：
- en: 'Next, we''ll create another Java class, `FxmlGuiDemo`, which is responsible
    for rendering the FXML-based UI and which would also be the entry point for launching
    the application:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个Java类，名为`FxmlGuiDemo`，它负责渲染基于FXML的UI，并且也将是启动应用程序的入口点：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we need to create a scene graph from the FXML UI definition by overriding
    the `start(Stage stage)` method of the `javafx.application.Application` class and
    then render the scene graph within the passed `javafx.stage.Stage` object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过重写`javafx.application.Application`类的`start(Stage stage)`方法来从FXML UI定义创建场景图，然后在传递的`javafx.stage.Stage`对象中渲染场景图：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we provide the `main()` method implementation:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们提供了`main()`方法的实现：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete code can be found at the location, `chp9/2_fxml_gui`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在指定位置找到，`chp9/2_fxml_gui`。
- en: We have provided two run scripts, `run.bat` and `run.sh`, in `chp9/2_fxml_gui`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/2_fxml_gui`中提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，而`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下截图所示的GUI：
- en: '![](img/759c00ef-26b6-4caf-ae90-ef377a3ce8cc.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759c00ef-26b6-4caf-ae90-ef377a3ce8cc.png)'
- en: 'Enter the name and date of birth and click on `Calculate` to view the age:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输入姓名和出生日期，然后点击`Calculate`按钮查看年龄：
- en: '![](img/4346fd9e-8e35-405f-aa5b-b5126d3584ae.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4346fd9e-8e35-405f-aa5b-b5126d3584ae.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There is no XSD defining the schema for the FXML document. So, to know the
    tags to be used, they follow a simple naming convention. The Java class name of
    the component is also the name of the XML tag. For example, the XML tag for the `javafx.scene.layout.GridPane`
    layout is `<GridPane>`, for `javafx.scene.control.TextField`, it is `<TextField>`,
    and for `javafx.scene.control.DatePicker`, it is `<DatePicker>`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 没有XSD定义FXML文档的架构。因此，为了知道要使用的标签，它们遵循一个简单的命名约定。组件的Java类名也是XML标签的名称。例如，`javafx.scene.layout.GridPane`布局的XML标签是`<GridPane>`，`javafx.scene.control.TextField`的标签是`<TextField>`，而`javafx.scene.control.DatePicker`的标签是`<DatePicker>`：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding line of code makes use of an instance of `javafx.fxml.FXMLLoader`
    to read the FXML file and get the Java representation of the UI components. `FXMLLoader`
    uses an event-based SAX parser to parse the FXML file. Instances of the respective
    Java classes for the XML tags are created via reflection and the values of attributes
    of the XML tags are populated into the respective properties of the Java classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码使用`javafx.fxml.FXMLLoader`的实例来读取FXML文件，并获取UI组件的Java表示。`FXMLLoader`使用基于事件的SAX解析器来解析FXML文件。通过反射创建相应Java类的XML标签实例，并将XML标签的属性值填充到Java类的相应属性中。
- en: As the root of our FXML is `javafx.scene.layout.GridPane`, which extends `javafx.scene.layout.Pane`,
    we can cast the return value from `FXMLoader.load()` to `javafx.scene.layout.Pane`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的FXML的根是`javafx.scene.layout.GridPane`，它扩展了`javafx.scene.layout.Pane`，因此我们可以将`FXMLLoader.load()`的返回值转换为`javafx.scene.layout.Pane`。
- en: 'The other interesting thing in this recipe is the `FxmlController` class. This
    class acts as an interface to FXML. We indicate the same in FXML by using the `fx:controller`
    attribute to the `<GridPane>` tag. We can get hold of the UI components defined
    in FXML by using the `@FXML` annotation against the member fields of the `FxmlController`
    class, as we did in this recipe:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，另一个有趣的事情是`FxmlController`类。这个类充当FXML的接口。我们在FXML中使用`fx:controller`属性对`<GridPane>`标签进行指示。我们可以通过在`FxmlController`类的成员字段上使用`@FXML`注解来获取在FXML中定义的UI组件，就像在这个食谱中所做的那样：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The name of the member is the same as that of the `fx:id` attribute value in
    FXML, and the type of the member is the same as that of the tag in FXML. For example,
    the first member is bound to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 成员名称与FXML中`fx:id`属性值的名称相同，成员的类型与FXML中标签的类型相同。例如，第一个成员绑定到以下内容：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On similar lines, we created an event handler in `FxmlController` and annotated
    it with `@FXML`, and the same has been referenced in FXML with the `onAction`
    attribute of `<Button>`. Note that we have added `#` to the beginning of the method
    name in the `onAction` attribute value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们在`FxmlController`中创建了一个事件处理器，并用`@FXML`注解它，并在FXML中用`<Button>`的`onAction`属性引用了它。请注意，我们在`onAction`属性值的开头添加了`#`。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe of this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章的以下食谱：
- en: Creating a GUI using JavaFX controls
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaFX控件创建GUI
- en: Using CSS to style elements in JavaFX
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS在JavaFX中设置元素样式
- en: Those from a web development background will be able to appreciate the usefulness
    of the **Cascading Style Sheets** (**CSS**), and for those who are not, we will
    provide an overview of what they are and how they are useful, before diving into
    CSS application in JavaFX.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 来自网页开发背景的人将能够欣赏**层叠样式表**（**CSS**）的有用性，而对于那些不熟悉的人来说，我们将在深入研究JavaFX中的CSS应用之前，提供一个概述它们是什么以及它们如何有用。
- en: The elements or the components that you see on web pages are often styled according
    to the theme of the website. This styling is possible by using a language called
    CSS. CSS consists of a group of name:value pairs, separated by semi colons. These
    name:value pairs, when associated with an HTML element, say, `<button>`, give
    it the required styling.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你在网页上看到的元素或组件通常是根据网站的主题进行样式的。这种样式可以通过使用一种叫做CSS的语言来实现。CSS由一组由分号分隔的name:value对组成。当这些name:value对与一个HTML元素关联时，比如`<button>`，就会给它赋予所需的样式。
- en: 'There are multiple ways to associate these name:value pairs to the element,
    the simplest being when you put this name:value pair within the style attribute
    of your HTML element. For example, to give the button a blue background, we can
    do the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将这些name:value对关联到元素上，最简单的方式是将这个name:value对放在你的HTML元素的style属性中。例如，为了给按钮一个蓝色背景，我们可以这样做：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are predefined names for different styling properties, and these take
    a specific set of values; that is, the property, `background-color`, will only
    take valid color values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的样式属性有预定义的名称，并且它们具有特定的值集；也就是说，属性`background-color`只会接受有效的颜色值。
- en: 'The other approach is to define these groups of name:value pairs in a different
    file with a `.css` extension. Let''s call this group of name:value pairs as CSS
    properties. We can associate these CSS properties with different selectors, that
    is, selectors for choosing the elements on the HTML page to apply the CSS properties
    to. There are three different ways of providing the selectors:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是定义这些name:value对的组在不同的文件中，具有`.css`扩展名。让我们称这个name:value对的组为CSS属性。我们可以将这些CSS属性与不同的选择器关联起来，即选择器用于选择HTML页面上的元素以应用CSS属性。提供选择器有三种不同的方式：
- en: By directly giving the name of the HTML element, that is, whether it is an anchor
    tag (`<a>`), button, or input. In such cases, the CSS properties are applied to
    all the types of HTML elements in the page.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过直接给出HTML元素的名称，即它是一个锚点标签（`<a>`）、按钮还是输入。在这种情况下，CSS属性应用于页面上的所有HTML元素类型。
- en: 'By using the `id` attribute of the HTML element. Suppose, we have a button
    with `id="btn1"`, then we can define a selector, `#btn1`, against which we provide
    the CSS properties. Take a look at the following example:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用HTML元素的`id`属性。假设我们有一个`id="btn1"`的按钮，那么我们可以定义一个选择器`#btn1`，针对这个选择器提供CSS属性。看看下面的例子：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By using the class attribute of the HTML element. Suppose we have a button
    with `class="blue-btn"`, then we can define a selector, `.blue-btn`, against which,
    we provide the CSS properties. Check out the following example:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用HTML元素的`class`属性。假设我们有一个`class="blue-btn"`的按钮，那么我们可以定义一个选择器`.blue-btn`，针对这个选择器提供CSS属性。看看下面的例子：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The advantage of using a different CSS file is that we can independently evolve
    the appearance of the web pages without getting tightly coupled to the location
    of the elements. Also, this encourages the reuse of CSS properties across different
    pages, thereby giving them a uniform look across all the pages.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的CSS文件的优势在于，我们可以独立地发展网页的外观，而不会紧密耦合到元素的位置。此外，这也鼓励在不同页面之间重复使用CSS属性，从而在整个页面上提供统一的样式。
- en: When we apply a similar approach to JavaFX, we can leverage the CSS knowledge
    already available with our web designers to build CSS for JavaFX components, and
    this helps in styling the components more easily than with the use of Java APIs.
    When this CSS is mixed with FXML, then it becomes a known domain for web developers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将类似的方法应用于JavaFX时，我们可以利用我们的网页设计师已经拥有的CSS知识来为JavaFX组件构建CSS，这有助于比使用Java API更容易地样式化组件。当这种CSS与FXML混合时，它就成为了网页开发者所熟知的领域。
- en: In this recipe, we will look at styling a few JavaFX components using an external
    CSS file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看如何使用外部CSS文件来样式化几个JavaFX组件。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is a small difference in defining the CSS properties for the JavaFX components.
    All the properties must be prefixed with `-fx-`, that is, `background-color` becomes
    `-fx-background-color`. The selectors, that is, `#id` and `.class`-name still
    remain the same in the JavaFX world as well. We can even provide multiple classes
    to the JavaFX components, thereby applying all these CSS properties to the components.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义JavaFX组件的CSS属性时存在一个小的差异。所有属性都必须以`-fx-`为前缀，即`background-color`变为`-fx-background-color`。在JavaFX世界中，选择器，即`#id`和`.class`-name仍然保持不变。我们甚至可以为JavaFX组件提供多个类，从而将这些CSS属性应用到组件上。
- en: The CSS that I have used in this recipe is based on a popular CSS framework
    called Bootstrap ([http://getbootstrap.com/css/](http://getbootstrap.com/css/)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个菜谱中使用的CSS是基于一个流行的CSS框架Bootstrap（[http://getbootstrap.com/css/](http://getbootstrap.com/css/))。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create `GridPane`, which will hold the components in a grid of rows
    and columns:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`GridPane`，它将以行和列的形式持有组件：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, we will create a button and add two classes, `btn` and `btn-primary`,
    to it. In the next step, we will define these selectors with the required CSS
    properties:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个按钮并添加两个类，`btn`和`btn-primary`。在下一步中，我们将定义这些选择器并使用所需的CSS属性：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s provide the required CSS properties for the classes, `btn` and
    `btn-primary`. The selector for the classes are of the form `.<class-name>`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为类`btn`和`btn-primary`提供所需的CSS属性。类的选择器形式为`.<class-name>`：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s create another button with a different CSS class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个具有不同CSS类的按钮：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we define the CSS properties for the `.btn-success` selector as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义`.btn-success`选择器的CSS属性如下：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s create yet another button with a different CSS class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个具有不同CSS类的按钮：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will define the CSS properties for the selector `.btn-danger`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为选择器`.btn-danger`定义CSS属性：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s add some labels with different selectors, namely `badge`, `badge-info`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些具有不同选择器的标签，即`badge`和`badge-info`：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The CSS properties for the previous selectors are:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前选择器的CSS属性如下：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s add `TextField` with a `big-input` class:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个具有`big-input`类的`TextField`：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We define CSS properties so that the content of the text box is large in size
    and red in color:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义CSS属性，以便文本框的内容大小大且颜色为红色：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s add some radio buttons:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些单选按钮：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We define CSS properties so that the labels of the radio button are large in
    size and green in color:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义CSS属性，以便单选按钮的标签大小大且颜色为绿色：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we add `javafx.scene.layout.GridPane` to the scene graph and render
    the scene graph on `javafx.stage.Stage`. We also need to associate the `stylesheet.css`
    with the `Scene`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`javafx.scene.layout.GridPane`添加到场景图中，并在`javafx.stage.Stage`上渲染场景图。我们还需要将`stylesheet.css`与`Scene`关联起来：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a `main()` method to launch the GUI:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main()`方法以启动GUI：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The complete code can be found at the location, `chp9/3_css_javafx`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在位置`chp9/3_css_javafx`找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/3_css_javafx`.
    The `run.bat` will be for running the application on Windows and `run.sh` will
    be for running the application on Linux.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/3_css_javafx`目录下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`用于在Windows上运行应用程序，而`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下GUI：
- en: '![](img/5bf193de-fa8c-41cf-98e4-0d6f9203a1a1.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bf193de-fa8c-41cf-98e4-0d6f9203a1a1.png)'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we make use of class names and their corresponding CSS selectors
    to associate components with different styling properties. JavaFX supports a subset
    of CSS properties and there are different properties applicable to different types
    of JavaFX components. The JavaFX CSS reference guide ([http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html))
    will help you identify the supported CSS properties.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用类名及其对应的CSS选择器来将组件与不同的样式属性关联起来。JavaFX支持CSS属性的一个子集，并且有适用于不同类型JavaFX组件的不同属性。JavaFX
    CSS参考指南([http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html))将帮助您识别支持的CSS属性。
- en: All the scene graph nodes extend from an abstract class, `javax.scene.Node`.
    This abstract class provides an API, `getStyleClass()`, which returns a list of
    class names (which are plain `String`) added to the node or the JavaFX component.
    As this is a simple list of class names, we can even add more class names to it
    by using `getStyleClass().add("new-class-name")`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的场景图节点都扩展自一个抽象类`javax.scene.Node`。这个抽象类提供了一个API，`getStyleClass()`，它返回一个添加到节点或JavaFX组件中的类名列表（这些是普通的`String`）。由于这是一个简单的类名列表，我们甚至可以通过使用`getStyleClass().add("new-class-name")`来向其中添加更多的类名。
- en: The advantage of using class names is that it allows us to group similar components
    by a common class name. This technique is widely used in the web development world.
    Suppose I have a list of buttons on the HTML page and I want a similar action
    to be performed on the click of each button. To achieve this, I will assign each
    of the buttons the same class, say, `my-button`, and then use `document.getElementsByClassName('my-button')`
    to get an array of these buttons. Now we can loop through the array of buttons
    obtained and add the required action handlers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类名的优点是它允许我们通过一个共同的类名将相似的组件分组。这种技术在Web开发世界中得到了广泛的应用。假设我在HTML页面上有一个按钮列表，并且我想在点击每个按钮时执行类似操作。为了实现这一点，我将为每个按钮分配相同的类，比如说`my-button`，然后使用`document.getElementsByClassName('my-button')`来获取这些按钮的数组。现在我们可以遍历获取到的按钮数组，并添加所需的动作处理程序。
- en: After assigning a class to the component, we need to write the CSS properties
    for the given class name. These properties then get applied to all the components
    with the same class name.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在将类分配给组件后，我们需要为给定的类名编写CSS属性。然后，这些属性将应用于具有相同类名的所有组件。
- en: 'Let''s pick one of the components from our recipe and see how we went about
    styling the same. Consider the following component with two classes, `btn` and
    `btn-primary`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的配方中挑选一个组件，看看我们是如何对相同的组件进行样式的。考虑以下具有两个类`btn`和`btn-primary`的组件：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have used the selectors, `.btn` and `.btn-primary`, and we have grouped
    all the CSS properties under these selectors, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了选择器`.btn`和`.btn-primary`，并且我们已经将这些CSS属性分组在这些选择器下，如下所示：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that in CSS, we have a `color` property, and its equivalent in JavaFX is
    `-fx-text-fill`. The rest of the CSS properties, namely `border-radius`, `border`,
    `font-size`, `font-weight`, `text-align`, `background-color`, and `border-color`,
    are prefixed with `-fx-`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在CSS中，我们有一个`color`属性，其在JavaFX中的等效属性是`-fx-text-fill`。其余的CSS属性，即`border-radius`、`border`、`font-size`、`font-weight`、`text-align`、`background-color`和`border-color`，都以前缀`-fx-`开头。
- en: The important part is how you associate the stylesheet with the Scene component.
    The `scene.getStylesheets().add("com/packt/stylesheet.css");` line of code associates
    stylesheets with the Scene component. As `getStylesheets()` returns a list of
    strings, we can add multiple strings to it, which means that we can associate
    multiple stylesheets to a Scene.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的部分是如何将样式表与Scene组件关联起来。代码行`scene.getStylesheets().add("com/packt/stylesheet.css");`将样式表与Scene组件关联起来。由于`getStylesheets()`返回一个字符串列表，我们可以向其中添加多个字符串，这意味着我们可以将多个样式表关联到一个Scene上。
- en: 'The documentation of `getStylesheets()` states the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStylesheets()`的文档说明了以下内容：'
- en: The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the
    URL does not have a [scheme:] component, the URL is considered to be the [path]
    component only. Any leading '/' character of the [path] is ignored and the [path]
    is treated as a path relative to the root of the application's classpath.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: URL是具有以下形式的分层URI：[scheme:][//authority][path]。如果URL没有[scheme:]组件，则URL被认为是仅有的[path]组件。任何[path]前面的'/'字符都将被忽略，并且[path]被视为相对于应用程序classpath根部的路径。
- en: In our recipe, we are using the `path` component only, and, hence, it looks
    for the file in the classpath. This is the reason why we have added the stylesheet
    in the same package as that of the scene. This is an easier way of making it available
    on the classpath.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们只使用`path`组件，因此它会在classpath中查找文件。这就是为什么我们将样式表添加到与场景相同的包中。这是一种使其在classpath上可用的更简单的方法。
- en: Creating a bar chart
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Data, when represented in the form of tables, is very hard to understand, but
    the same, when represented graphically by using charts, is comfortable for the
    eyes and easy to understand. We have seen a lot of charting libraries for web
    applications. However, the same support was lacking on the desktop application
    front. Swing didn't have native support for creating charts and we had to rely
    on third-party applications such as **JFreeChart** ([http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)).
    With JavaFX though, we have native support for creating charts, and we are going
    to show you how to represent the data in the form of charts using the JavaFX chart
    components.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以表格形式表示时很难理解，但以图表形式图形化表示时，对眼睛来说更舒适，更容易理解。我们已经看到了许多用于Web应用的图表库。然而，在桌面应用程序方面，这种支持却缺乏。Swing没有创建图表的原生支持，我们不得不依赖于第三方应用程序，如**JFreeChart**（[http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)）。但是，使用JavaFX，我们有创建图表的原生支持，我们将向您展示如何使用JavaFX图表组件以图表形式表示数据。
- en: 'JavaFX supports the following chart types:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX支持以下图表类型：
- en: Bar chart
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图
- en: Line chart
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折线图
- en: Pie chart
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图
- en: Scatter chart
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: Area chart
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积图
- en: Bubble chart
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡图
- en: In the next few recipes, we will cover the construction of each chart type.
    This segregation of each chart type into a recipe of its own will help us in explaining
    the recipes in a simpler way and will aid better understanding.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个菜谱中，我们将介绍每种图表类型的构建。将每种图表类型单独作为一个菜谱，将有助于我们以更简单的方式解释菜谱，并有助于更好地理解。
- en: 'This recipe will be all about bar charts. A sample bar chart looks something
    like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将全部关于柱状图。一个示例柱状图看起来像这样：
- en: '![](img/150d29df-9cf5-4710-bf6e-5f12ef97d960.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/150d29df-9cf5-4710-bf6e-5f12ef97d960.png)'
- en: Bar charts can have a single bar or multiple bars (like the preceding image)
    for each value on the *x*-axis. Multiple bars help us in comparing multiple value
    points for each value on the *x*-axis.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 柱状图可以为*x*轴上的每个值有一个或多个柱子（如前面的图像所示）。多个柱子有助于我们比较*x*轴上每个值的多个值点。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will make use of a subset of data from the student performance machine learning
    repository ([https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)).
    The dataset consists of student performance in two subjects, Mathematics and Portuguese,
    along with their social background information, such as their parents'' occupation
    and education, among other information. There are quite a lot of attributes in
    the dataset, but we will pick the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用学生表现机器学习仓库中的一部分数据（[https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)）。该数据集包括学生在数学和葡萄牙语两门课程的表现，以及他们的社会背景信息，例如父母的职业和教育，以及其他信息。数据集中有很多属性，但我们将选择以下内容：
- en: Student's gender
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生的性别
- en: Student's age
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生的年龄
- en: Father's education
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父亲的教育程度
- en: Father's occupation
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父亲的职业
- en: Mother's education
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母亲的教育程度
- en: Mother's occupation
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母亲的职业
- en: Whether the student has taken extra classes
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生是否参加了课外班
- en: First term grades
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一学期成绩
- en: Second term grades
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二学期成绩
- en: Final grades
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终成绩
- en: 'As we mentioned earlier, there are a lot of attributes captured in the data,
    but we should be good with a few important attributes that will help us in plotting
    some useful charts. Due to this, we have extracted the information from the dataset
    available in the machine learning repository into a separate file, which can be
    found at the location, `chp9/4_bar_charts/src/gui/com/packt/students`, in the
    code download for the book. An excerpt from the students file is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，数据中捕获了大量的属性，但我们应该能够处理几个重要的属性，这些属性将帮助我们绘制一些有用的图表。因此，我们已经从机器学习仓库中可用的数据集中提取了信息，并将其保存到一个单独的文件中，该文件位于书籍代码下载的`chp9/4_bar_charts/src/gui/com/packt/students`位置。学生文件的摘录如下：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The entries are semicolon (`;`) separated. Each entry has been explained for
    what it represents. The education information (fields 3 and 4) is a numeric value,
    where each number represents the level of education, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目是用分号（`;`）分隔的。每个条目都对其所代表的内容进行了说明。教育信息（字段3和4）是一个数值，其中每个数字代表教育水平，如下所示：
- en: '0: None'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 无'
- en: '1: Primary education (fourth grade)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 小学教育（四年级）'
- en: '2: Fifth to ninth grade'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 五到九年级'
- en: '3: Secondary education'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: 中等教育'
- en: '4: Higher education'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4: 高等教育'
- en: We have created a module for processing the student file. The module name is
    `student.processor` and its code can be found at `chp9/101_student_data_processor`.
    So, if you want to change any code there, you can rebuild the JAR by running the
    `build-jar.bat` or `build-jar.sh` file. This will create a modular JAR, `student.processor.jar`,
    in the `mlib` directory. Then, you have to replace this modular JAR with the one
    present in the `mlib` directory of this recipe, that is, `chp9/4_bar_charts/mlib`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个用于处理学生文件的模块。该模块名为 `student.processor`，其代码可以在 `chp9/101_student_data_processor`
    找到。因此，如果您想修改那里的任何代码，可以通过运行 `build-jar.bat` 或 `build-jar.sh` 文件来重新构建 JAR。这将创建一个模块化的
    JAR，名为 `student.processor.jar`，位于 `mlib` 目录中。然后，您必须用此模块化 JAR 替换此食谱中 `mlib` 目录中现有的
    JAR，即 `chp9/4_bar_charts/mlib`。
- en: We recommend you to build the student.processor modular jar from the source
    available in `chp9/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform. And then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您从 `chp9/101_student_data_processor` 中可用的源代码构建 `student.processor` 模块化 JAR。我们提供了
    `build-jar.bat` 和 `build-jar.sh` 脚本来帮助您构建 JAR。您只需运行与您的平台相关的脚本。然后，将 `101_student_data_processor/mlib`
    中的构建好的 JAR 复制到 `4_bar_charts/mlib`。
- en: This way, we can reuse this module across all the recipes on charts.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在所有图表的食谱中重用此模块。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, create `GridPane` and configure it to place the charts that we will
    be creating:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建 `GridPane` 并配置它以放置我们将要创建的图表：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use the `StudentDataProcessor` class from the `student.processor` module to
    parse the student file and load the data into `List` of `Student`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 `student.processor` 模块的 `StudentDataProcessor` 类来解析学生文件并将数据加载到 `Student`
    的 `List` 中：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The raw data, that is, the list of `Student` objects is not useful for plotting
    a chart, so we need to process the students'' grades by grouping the students
    according to their mothers'' and fathers'' education and computing the average
    of those students'' grades (all three terms). For this, we will write a simple
    method, which accepts `List<Student>`, a grouping function, that is, the value
    on which the students need to be grouped, and a mapping function, that is, the
    value that has to be used to compute the average:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始数据，即 `Student` 对象的列表，对于绘制图表没有用，因此我们需要通过根据母亲和父亲的教育程度对学生进行分组并计算这些学生的成绩平均值（所有三个学期）来处理学生的成绩。为此，我们将编写一个简单的方法，该方法接受
    `List<Student>`、一个分组函数，即学生需要分组的值，以及一个映射函数，即用于计算平均值的值：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding method uses the new Stream-based APIs. These APIs are so powerful
    that they group the students by using `Collectors.groupingBy()` and then compute
    the statistics of their grades by using `Collectors.summarizingInt()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用了新的基于流的 API。这些 API 非常强大，它们使用 `Collectors.groupingBy()` 对学生进行分组，然后使用 `Collectors.summarizingInt()`
    计算他们成绩的统计数据。
- en: 'The data for the bar chart is provided as an instance of `XYChart.Series`.
    Each series results in one `Y` value for a given `X` value, which is one bar for
    a given `X` value. We will have multiple series, one for each term, that is, first
    term grades, second term grades, and the final grades. Let''s create a method
    that takes in the statistics of each term grades and the `seriesName` and returns
    a `series` object:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 柱状图的数据以 `XYChart.Series` 实例的形式提供。每个序列对应一个给定的 `X` 值的一个 `Y` 值，即一个给定的 `X` 值对应一个柱子。我们将有多个序列，每个学期一个，即第一学期成绩、第二学期成绩和最终成绩。让我们创建一个方法，该方法接受每个学期成绩的统计数据和
    `seriesName`，并返回一个 `series` 对象：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will create two bar charts: one for the average grade by mother''s education
    and the other for the average grade by father''s education. For this, we will
    create a method that will take `List<Student>` and a classifier, that is, a function
    that will return the value to be used to group the students. This method will
    do the necessary computations and return us a `BarChart` object:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个柱状图：一个表示母亲教育程度的平均成绩，另一个表示父亲教育程度的平均成绩。为此，我们将创建一个方法，该方法将接受 `List<Student>`
    和一个分类器，即一个返回用于对学生进行分组的值的函数。此方法将执行必要的计算并返回一个 `BarChart` 对象：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create `BarChart` for the average grades by mother''s education, and add it
    to `gridPane`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `gridPane` 创建表示母亲教育程度的平均成绩的 `BarChart` 并将其添加到 `gridPane`：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create `BarChart` for average grades by father''s education and add it to `gridPane`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过父亲教育程度创建表示平均成绩的 `BarChart` 并将其添加到 `gridPane`：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a scene graph using `gridPane` and set it to `Stage`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gridPane` 创建场景图并将其设置为 `Stage`：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The complete code can be found at `chp9/4_bar_charts`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在`chp9/4_bar_charts`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/4_bar_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/4_bar_charts`目录下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，而`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下GUI：
- en: '![](img/3135a8b1-82ec-4656-9fb4-185d09904c91.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3135a8b1-82ec-4656-9fb4-185d09904c91.png)'
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's first see what it takes to create `BarChart`. `BarChart` is a two axes-based
    chart, where the data is plotted on two axes, namely the *x* axis (horizontal
    axis) and the *y* axis (vertical axis). The other two axes-based charts are area
    chart, bubble chart, and line chart.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看创建`BarChart`需要什么。`BarChart`是一个基于两个轴的图表，数据绘制在两个轴上，即*x*轴（水平轴）和*y*轴（垂直轴）。其他基于两个轴的图表还包括面积图、气泡图和折线图。
- en: 'In JavaFX, there are two types of axes supported:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX中，支持两种类型的轴：
- en: '`javafx.scene.chart.CategoryAxis`: This supports string values on the axes'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.chart.CategoryAxis`：这个支持轴上的字符串值'
- en: '`javafx.scene.chart.NumberAxis`: This supports numeric values on the axes'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.chart.NumberAxis`：这个支持轴上的数值'
- en: 'In our recipe, we created `BarChart` with `CategoryAxis` as the *x* axis, where
    we plot the education, and `NumberAxis` as the *y* axis, where we plot the grade,
    as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们创建了以`CategoryAxis`作为*x*轴的`BarChart`，其中我们绘制了教育数据，以及以`NumberAxis`作为*y*轴的`BarChart`，其中我们绘制了成绩，如下所示：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the next few paragraphs, we show you how the plotting of `BarChart` works.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几段中，我们向您展示`BarChart`的绘图是如何工作的。
- en: 'The data to be plotted on `BarChart` should be a pair of values, where each
    pair represents *(x, y)* values, that is, a point on the *x* axis and a point
    on the *y* axis. This pair of values is represented by `javafx.scene.chart.XYChart.Data`.
    `Data` is a nested class within `XYChart`, which represents a single data item
    for a two axes-based chart. An `XYChart.Data` object can be created quite simply,
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制在`BarChart`上的数据应该是一对值，其中每一对代表*(x, y)*值，即*x*轴上的一个点和*y*轴上的一个点。这对值由`javafx.scene.chart.XYChart.Data`表示。`Data`是`XYChart`中的一个嵌套类，代表一个基于两个轴的图表的单个数据项。一个`XYChart.Data`对象可以非常简单地创建，如下所示：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is just one-data item. A chart can have multiple data items, that is,
    a series of data items. To represent a series of data items, JavaFX provides a
    class called `javafx.scene.chart.XYChart.Series`. This `XYChart.Series` object
    is a named series of `XYChart.Data` items. Let''s create a simple series, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个数据项。一个图表可以有多个数据项，即一系列数据项。为了表示一系列数据项，JavaFX提供了一个名为`javafx.scene.chart.XYChart.Series`的类。这个`XYChart.Series`对象是一系列`XYChart.Data`项的命名序列。让我们创建一个简单的序列，如下所示：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`BarChart` can have multiple series of data items. If we provide it with multiple
    series, then there will be multiple bars for each data point on the *x* axis.
    For our demonstration of how this works, we will stick with one series. But the
    `BarChart` class in our recipe uses multiple series. Let''s add the series to
    the `BarChart` and then render it onto the screen:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`BarChart`可以有多个数据项系列。如果我们提供多个系列，那么*x*轴上的每个数据点都会有多个条形。为了演示它是如何工作的，我们将坚持使用一个系列。但我们的配方中的`BarChart`类使用了多个系列。让我们将系列添加到`BarChart`中，然后将其渲染到屏幕上：'
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This results in the following chart:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图表：
- en: '![](img/49e71ed2-c2fa-4572-b24d-fdc56cd1b795.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49e71ed2-c2fa-4572-b24d-fdc56cd1b795.png)'
- en: 'The other interesting part of this recipe is the grouping of students based
    on the education of mother and father and then computing the average of their
    first term, second term, and final grades. The line of code that does the grouping
    and average computation is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中另一个有趣的部分是根据母亲和父亲的教育程度对学生进行分组，然后计算他们的第一学期、第二学期和最终成绩的平均值。执行分组和平均计算的代码行如下：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding line of code does the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码执行以下操作：
- en: It creates a stream from `List<Student>`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从`List<Student>`创建一个流。
- en: It reduces this stream to the required grouping by using the `collect()` method.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过使用`collect()`方法将这个流缩减到所需的分组。
- en: One of the overloaded versions of `collect()` takes two parameters. The first
    one is the function that returns the value on which the students need to be grouped.
    The second parameter is an additional mapping function, which maps the grouped
    student object into the required format. In our case, the required format is to
    get `IntSummaryStatistics` for the group of students on any of their grade values.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect()` 的一个重载版本接受两个参数。第一个参数是返回学生需要按其分组的价值的函数。第二个参数是一个额外的映射函数，它将分组的学生对象映射到所需的格式。在我们的情况下，所需的格式是获取任何年级值的学生组
    `IntSummaryStatistics`。'
- en: The preceding two pieces (setting up the data for a bar chart and creating the
    required objects to populate a `BarChart` instance) are important parts of the
    recipe; understanding them will give you a clearer picture of the recipe.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个部分（设置条形图数据并创建填充 `BarChart` 实例所需的对象）是配方的重要部分；理解它们将为您提供一个更清晰的配方图景。
- en: See also
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下配方：
- en: Creating an area chart
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a bubble chart
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Creating a line chart
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Creating a scatter chart
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图
- en: Creating a pie chart
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建饼图
- en: 'Pie charts, as the name suggests, are circular charts with slices (either joined
    or separated out), where each slice and its size indicates the magnitude of the
    item that the slice represents. Pie charts are used to compare the magnitudes
    of different classes, categories, products, and the like. This is how a sample
    pie chart looks:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，饼图是带有切片（要么连接要么分离）的圆形图表，其中每个切片及其大小表示切片所代表的项目的量级。饼图用于比较不同类别、类别、产品等的量级。这是一个示例饼图的样子：
- en: '![](img/89fcaedc-0219-43c3-ab55-5da501bac4bf.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89fcaedc-0219-43c3-ab55-5da501bac4bf.png)'
- en: Getting ready
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will make use of the same student data (taken from the machine learning repository and
    processed at our end) that we had discussed in the recipe, *Creating a bar chart*.
    For this, we have created a module, `student.processor`, which will read the student
    data and provide us with a list of `Student` objects. The source code for the
    module can be found at `chp9/101_student_data_processor`. We have provided the
    modular jar for the `student.processor` module at `chp9/5_pie_charts/mlib` of
    this recipe's code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与我们在“创建条形图”配方中讨论的相同的学生数据（从机器学习存储库中获取并在我们端进行处理），为此，我们创建了一个模块 `student.processor`，该模块将读取学生数据并提供给我们一个
    `Student` 对象的列表。该模块的源代码可以在 `chp9/101_student_data_processor` 中找到。我们已提供 `student.processor`
    模块的模块化 jar 文件，位于本配方代码的 `chp9/5_pie_charts/mlib`。
- en: We recommend you to build the `student.processor` modular jar from the source
    available in `chp9/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform. And then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您从 `chp9/101_student_data_processor` 中可用的源代码构建 `student.processor` 模块化 jar。我们已提供
    `build-jar.bat` 和 `build-jar.sh` 脚本来帮助您构建 jar。您只需运行与您的平台相关的脚本。然后，将 `101_student_data_processor/mlib`
    中的 jar 文件复制到 `4_bar_charts/mlib`。
- en: How to do it...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create and configure `GridPane` to hold our pie charts:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建和配置 `GridPane` 以容纳我们的饼图：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create an instance of `StudentDataProcessor` (which comes from the `student.processor` module)
    and use it to load `List` of `Student`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `StudentDataProcessor` 实例（来自 `student.processor` 模块）并使用它来加载 `List` 中的 `Student`：
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we need to get the count of students by their mother''s and father''s
    profession. We will write a method, which will take a list of students and a classifier,
    that is, the function that returns the value on which the students need to be
    grouped. The method returns an instance of `PieChart`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要根据学生的母亲和父亲的职业来获取学生的数量。我们将编写一个方法，该方法将接受一个学生列表和一个分类器，即返回学生需要按其分组的价值的函数。该方法返回一个
    `PieChart` 实例：
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will invoke the preceding method twice - one with the mother''s occupation
    as the classifier and the other with the father''s occupation as the classifier.
    We then add the returned `PieChart` instance to `gridPane`. This should be done
    from within the `start()` method:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用前面的方法两次 - 一次以母亲的职业作为分类器，另一次以父亲的职业作为分类器。然后我们将返回的 `PieChart` 实例添加到 `gridPane`。这应该在
    `start()` 方法内部完成：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next is to create the scene graph using `gridPane` and add it to `Stage`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是使用 `gridPane` 创建场景图并将其添加到 `Stage` 中：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The UI can be launched from the main method by invoking the `Application.launch`
    method:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过调用 `Application.launch` 方法从主方法启动UI：
- en: '[PRE70]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The complete code can be found at `chp9/5_pie_charts`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在 `chp9/5_pie_charts` 中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/5_pie_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `chp9/5_pie_charts` 下提供了两个运行脚本，`run.bat` 和 `run.sh`。`run.bat` 脚本将用于在Windows上运行应用程序，而
    `run.sh` 将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run.bat` 或 `run.sh` 运行应用程序，你将看到以下图形用户界面：
- en: '![](img/95ecc014-5354-4387-9329-8996fe42a38b.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95ecc014-5354-4387-9329-8996fe42a38b.png)'
- en: How it works...
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The most important method that does all the work in this recipe is the `getStudentCountByOccupation()`.
    It does the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中执行所有工作的最重要的方法是 `getStudentCountByOccupation()`。它执行以下操作：
- en: 'Group the number of students by profession. This can be done in a single line
    of code using the power of the new streaming APIs (added as part of Java 8):'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按专业分组学生数量。这可以通过使用新流式API（作为Java 8的一部分添加）的单行代码来完成：
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Build data required for `PieChart`. The `PieChart` instance''s data is `ObservableList`
    of `PieChart.Data`. We first make use of `Map` obtained in the preceding step
    to create `ArrayList` of `PieChart.Data`. Then, we use the `FXCollections.observableList()`
    API to obtain `ObservableList<PieChart.Data>` from `List<PieChart.Data>`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `PieChart` 所需的数据。`PieChart` 实例的数据是 `ObservableList` 的 `PieChart.Data`。我们首先使用前一步中获得的
    `Map` 创建 `PieChart.Data` 的 `ArrayList`。然后，我们使用 `FXCollections.observableList()`
    API 从 `List<PieChart.Data>` 获取 `ObservableList<PieChart.Data>`：
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The other important thing in the recipe is the classifiers we use: `Student::getMotherJob`
    and `Student::getFatherJob`. These are the two method references that invoke the `getMotherJob`
    and `getFatherJob` methods on the different instances of `Student` in the list
    of `Student`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱中另一个重要的事情是我们使用的分类器：`Student::getMotherJob` 和 `Student::getFatherJob`。这两个方法引用在
    `Student` 列表的不同实例上调用 `getMotherJob` 和 `getFatherJob` 方法。
- en: Once we get the `PieChart` instances, we add them to `GridPane` and then construct
    the scene graph using `GridPane`. The scene graph has to be associated with `Stage`
    for it to be rendered on the screen.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得 `PieChart` 实例，我们将它们添加到 `GridPane` 中，然后使用 `GridPane` 构建场景图。场景图必须与 `Stage`
    关联，以便在屏幕上渲染。
- en: The main method launches the UI by invoking the `Application.launch(args);`
    method.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法通过调用 `Application.launch(args);` 方法启动UI。
- en: Creating a line chart
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建折线图
- en: A line chart is a two-axis chart similar to the bar chart; instead of having
    bars, the data is plotted on the X-Y plane using points, and the points are joined
    together to depict the change of data. Line charts are used to get an understanding
    of how a certain variable is performing and when combined with multiple variables,
    that is, by using multiple series, we can see how each variable is performing
    when compared to other variables.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图是一种双轴图表，类似于条形图；与条形图不同，数据使用点在X-Y平面上绘制，并且点被连接起来以描绘数据的变化。折线图用于了解某个变量的表现，并且当结合多个变量时，即通过使用多个系列，我们可以看到每个变量与其他变量相比的表现。
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will make use of crude oil and brent oil price variation
    over the last three years. This data can be found at the locations, `chp9/6_line_charts/src/gui/com/packt/crude-oil`
    and `chp9/6_line_charts/src/gui/com/packt/brent-oil`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将利用过去三年原油和布伦特原油价格的变化。这些数据可以在以下位置找到，`chp9/6_line_charts/src/gui/com/packt/crude-oil`
    和 `chp9/6_line_charts/src/gui/com/packt/brent-oil`。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a **Plain Old Java Object** (**POJO**) to represent the oil
    price in a given month and year:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 **普通Java对象**（**POJO**）来表示给定月份和年份的油价：
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next is to write a `getOilData(String oilType)` method, which will read the
    data from the given file and construct `List<OilPrice>`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是编写 `getOilData(String oilType)` 方法，该方法将读取给定文件中的数据并构建 `List<OilPrice>`：
- en: '[PRE74]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we will write a method, which will take the name of the series and the
    data to be populated in the series:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个方法，该方法将接受系列名称和要填充到系列中的数据：
- en: '[PRE75]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create an empty `start(Stage stage)`  method, which we will override in the
    next few steps:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `start(Stage stage)` 方法，我们将在接下来的几个步骤中重写它：
- en: '[PRE76]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create and configure `GridPane`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并配置 `GridPane`：
- en: '[PRE77]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create `CategoryAxis` as the *x* axis and `NumberAxis` as the *y* axis, and
    label them accordingly:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `CategoryAxis` 作为 *x* 轴和 `NumberAxis` 作为 *y* 轴，并相应地标记它们：
- en: '[PRE78]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Initialize a `LineChart` instance with the axes created in the preceding step:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面步骤中创建的轴初始化一个 `LineChart` 实例：
- en: '[PRE79]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Load the crude oil data into `List<OilPrice>`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原油数据加载到 `List<OilPrice>`：
- en: '[PRE80]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Load Brent oil data into `List<OilPrice>`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布伦特原油数据加载到 `List<OilPrice>`：
- en: '[PRE81]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a series, each for crude oil and Brent oil, and add it to `lineChart`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个系列，每个系列分别用于原油和布伦特原油，并将其添加到 `lineChart`：
- en: '[PRE82]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Add `LineChart` to `gridPane`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LineChart` 添加到 `gridPane`：
- en: '[PRE83]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create a scene graph with `GridPane` as the root and set the size as required:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GridPane` 作为根节点创建场景图，并设置所需的大小：
- en: '[PRE84]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Set the properties for the `Stage` object passed into the `start(Stage stage)`
    method and associate the scene graph created in the preceding step:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为传递给 `start(Stage stage)` 方法的 `Stage` 对象设置属性，并将前面步骤中创建的场景图关联起来：
- en: '[PRE85]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Launch the UI by invoking the `javafx.application.Application.launch()` method
    from the `main` method:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 `main` 方法调用 `javafx.application.Application.launch()` 方法来启动 UI：
- en: '[PRE86]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The complete code can be found at `chp9/6_line_charts`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在 `chp9/6_line_charts` 中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/6_line_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `chp9/6_line_charts` 下提供了两个运行脚本，`run.bat` 用于在 Windows 上运行应用程序，`run.sh` 用于在
    Linux 上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run.bat` 或 `run.sh` 运行应用程序，你将看到以下 GUI：
- en: '![](img/3822235a-49d3-44e3-aaa6-9ea275983fce.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3822235a-49d3-44e3-aaa6-9ea275983fce.png)'
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like any other two-axis chart, the line chart has the *x* axis and *y* axis.
    These axes can be of string types or numeric. String values are represented by
    `javafx.scene.chart.CategoryAxis` and numeric values by `javafx.scene.chart.NumberAxis`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如同任何其他双轴图表一样，折线图有 *x* 轴和 *y* 轴。这些轴可以是字符串类型或数值类型。字符串值由 `javafx.scene.chart.CategoryAxis`
    表示，数值值由 `javafx.scene.chart.NumberAxis` 表示。
- en: 'A new `LineChart` is created by providing the *x* axis and *y* axis objects
    as parameters to its constructor:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 *x* 轴和 *y* 轴对象作为参数传递给其构造函数来创建一个新的 `LineChart`：
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Data to `LineChart` is provided in the form of an instance of `XYChart.Series`.
    So, if `LineChart` uses `String` on the *x* axis and `Number` on the *y* axis,
    then we create an instance of `XYChart.Series<String, Number>`, as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineChart` 的数据以 `XYChart.Series` 实例的形式提供。因此，如果 `LineChart` 在 *x* 轴上使用 `String`，在
    *y* 轴上使用 `Number`，那么我们创建一个 `XYChart.Series<String, Number>` 实例，如下所示：'
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`XYChart.Series` contains data of the `XYChart.Data` type, so `XYChart.Series<String,
    Number>` will contain data of the `XYChart.Data<String, Number>` type. Let''s
    add some data to the series created in the preceding step:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`XYChart.Series` 包含 `XYChart.Data` 类型的数据，因此 `XYChart.Series<String, Number>`
    将包含 `XYChart.Data<String, Number>` 类型的数据。让我们向前面步骤中创建的系列添加一些数据：'
- en: '[PRE89]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We then add the series to the `lineChart`''s data:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将系列添加到 `lineChart` 的数据中：
- en: '[PRE90]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can create one more series on similar lines:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此基础上创建另一个系列：
- en: '[PRE91]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The chart created looks like the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的图表看起来如下：
- en: '![](img/03f0f574-091f-43a4-8ccf-a54f8c9cc620.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03f0f574-091f-43a4-8ccf-a54f8c9cc620.png)'
- en: See also
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating a bar chart
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating an area chart
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a bubble chart
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Creating a scatter chart
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图
- en: Creating an area chart
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建面积图
- en: An area chart is similar to a line chart, the only difference being the area
    between the plotted line and the axis is colored, with different series being
    colored by different colors. In this recipe, we will look at creating an area
    chart.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 面积图与折线图类似，唯一的区别是绘制线与轴之间的区域被着色，不同的系列用不同的颜色着色。在本食谱中，我们将探讨如何创建面积图。
- en: Getting ready
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will make use of the crude oil and Brent oil price variation data from the
    previous recipe (*Creating a line chart*) to plot an area chart.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用之前食谱（*创建折线图*）中的原油和布伦特原油价格变动数据来绘制面积图。
- en: How to do it...
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create a POJO to represent the oil price in a given month and year:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 POJO 来表示给定月份和年份的油价：
- en: '[PRE92]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we''ll write a method, `getOilData(String oilType)`, which will read
    the data from the given file and construct `List<OilPrice>`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个方法，`getOilData(String oilType)`，它将读取给定文件中的数据并构建 `List<OilPrice>`：
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, we will write a method that will take the name of the series and the
    data to be populated in the series:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个方法，该方法将接受序列的名称和要填充在序列中的数据：
- en: '[PRE94]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create an empty `start(Stage stage)`  method, which we will override in the
    next few steps:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的`start(Stage stage)`方法，我们将在接下来的几个步骤中重写它：
- en: '[PRE95]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create and configure `GridPane`:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并配置`GridPane`：
- en: '[PRE96]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create `CategoryAxis` as the *x* axis and `NumberAxis` as the *y* axis and
    label them accordingly:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CategoryAxis`作为*x*轴，`NumberAxis`作为*y*轴，并相应地标注它们：
- en: '[PRE97]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Initialize `AreaChart` with the axes created in the preceding steps:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一步骤中创建的坐标轴初始化`AreaChart`：
- en: '[PRE98]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Load crude oil data into `List<OilPrice>`:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原油数据加载到`List<OilPrice>`中：
- en: '[PRE99]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Load Brent oil data into `List<OilPrice>`:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布伦特原油数据加载到`List<OilPrice>`中：
- en: '[PRE100]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create a series each for crude oil and brent oil, and add it to `AreaChart`:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为原油和布伦特原油分别创建一个序列，并将其添加到`AreaChart`中：
- en: '[PRE101]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add `AreaChart` to `GridPane`:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AreaChart`添加到`GridPane`中：
- en: '[PRE102]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a scene graph with `GridPane` as the root and set the size as required:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GridPane`作为根节点创建场景图并设置所需的大小：
- en: '[PRE103]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Set the properties for the `Stage` object passed into the `start(Stage stage)`
    method and associate the scene graph created in the preceding step:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置传递给`start(Stage stage)`方法的`Stage`对象的属性，并将前一步骤中创建的场景图关联起来：
- en: '[PRE104]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Launch the UI by invoking the `javafx.application.Application.launch()` method
    from the `main` method:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从`main`方法中调用`javafx.application.Application.launch()`方法来启动UI：
- en: '[PRE105]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The complete code can be found at `chp9/7_area_charts`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在`chp9/7_area_charts`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under`chp9/7_area_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chp9/7_area_charts`目录下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本用于在Windows上运行应用程序，而`run.sh`脚本用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/60a95f3c-aaa8-42ff-a4b4-0e55264b4547.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60a95f3c-aaa8-42ff-a4b4-0e55264b4547.png)'
- en: How it works...
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Area charts are similar to line charts so we would highly recommend reading
    the recipe, *Creating a line chart*. An area chart is made up of two axes with
    data plotted on the *x* and *y* axis. The data to be plotted is provided as an
    instance of `XYChart.Series`. The axis of the chart can be either `javafx.scene.chart.CategoryAxis`
    or `javafx.scene.chart.NumberAxis`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 面积图与折线图类似，所以我们强烈建议阅读菜谱，*创建折线图*。面积图由两个坐标轴组成，数据分别绘制在*x*轴和*y*轴上。要绘制的数据以`XYChart.Series`实例的形式提供。图表的坐标轴可以是`javafx.scene.chart.CategoryAxis`或`javafx.scene.chart.NumberAxis`。
- en: '`XYChart.Series` contains data encapsulated in instances of `XYChart.Data`.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`XYChart.Series`包含封装在`XYChart.Data`实例中的数据。'
- en: See also
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下菜谱：
- en: Creating a bar chart
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating an area chart
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a bubble chart
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Creating a pie chart
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Creating a scatter chart
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图
- en: Creating a bubble chart
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: A Bubble chart is also a two-axis chart with a third dimension to the data,
    that is, the radius of the bubble. Bubble chart supports only `NumberAxis`, so
    we can have only numbers on both *x* and *y* axes.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图也是一个双轴图表，数据具有第三个维度，即气泡的半径。气泡图仅支持`NumberAxis`，因此*x*轴和*y*轴上只能有数字。
- en: In this recipe, we will create a simple bubble chart.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个简单的气泡图。
- en: Getting ready
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have provided a sample store visit data at different times during the day
    along with the sales information during that hour. This sample data file can be
    found at the location, `chp9/8_bubble_charts/src/gui/com/packt/store`. Each line
    in the data file consists of three parts:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一天中不同时间段的样本商店访问数据以及该小时的销售额信息。此样本数据文件可在位置`chp9/8_bubble_charts/src/gui/com/packt/store`找到。数据文件中的每一行由三个部分组成：
- en: The hour of the day
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 白天的小时
- en: The number of visits
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问次数
- en: Total sales
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总销售额
- en: How to do it...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a method to read the data from the file into `StoreVisit` objects:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个方法，从文件中读取数据到`StoreVisit`对象中：
- en: '[PRE106]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We also need the maximum sale value during any part of the day. So, let''s
    create a method, which accepts the `List<StoreVisit>` and returns the maximum
    sale. We will use this maximum sale to determine the radius of the bubble in the
    chart:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一天中任何时段的最大销售额。因此，让我们创建一个方法，该方法接受`List<StoreVisit>`并返回最大销售额。我们将使用这个最大销售额来确定图表中气泡的半径：
- en: '[PRE107]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create and configure a `GridPane` object where we will place the chart:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并配置一个`GridPane`对象，我们将在此处放置图表：
- en: '[PRE108]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create two `NumberAxis` objects for *x* and *y* axis and give them corresponding
    names:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为*x*轴和*y*轴创建两个`NumberAxis`对象并给它们相应的名称：
- en: '[PRE109]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create an instance of `BubbleChart` with these two axes:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这两个轴创建一个`BubbleChart`实例：
- en: '[PRE110]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create an `XYChart.Series` from the store visit data, read from the file:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取的商店访问数据创建一个`XYChart.Series`：
- en: '[PRE111]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Populate `bubbleChart` with the series created in the preceding step and add
    it to `gridPane`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面步骤中创建的序列填充`bubbleChart`并将其添加到`gridPane`：
- en: '[PRE112]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Render the chart by creating a scene graph with `gridPane` and set it to the
    `Stage` object passed into the `start(Stage stage)` method:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`gridPane`创建场景图并设置到`start(Stage stage)`方法传入的`Stage`对象中来渲染图表：
- en: '[PRE113]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The complete code can be found at `chp9/8_bubble_charts`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`chp9/8_bubble_charts`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/8_bubble_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/8_bubble_charts`目录下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本用于在Windows上运行应用程序，而`run.sh`脚本用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/6586b333-8141-4ed5-b65c-5c90a79dc4e0.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6586b333-8141-4ed5-b65c-5c90a79dc4e0.png)'
- en: How it works...
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Bubble chart is another two-axis chart just like area chart, line chart, and
    bar chart. The only difference being that the `XYChart.Data` object takes in the
    third argument in its constructor, which determines the radius of the bubble.
    The general idea is that the greater the bubble radius, the greater is the impact/contribution
    of that data point. So, in our example, we have used the sales value and the maximum
    sales value to determine the radius by using the formula, `(sales/(maxSale  *
    1d)) * 2`, which means we are sizing the sales to the scale of 2.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图是另一种双轴图，就像区域图、折线图和柱状图一样。唯一的区别在于`XYChart.Data`对象在其构造函数中接受第三个参数，该参数确定气泡的半径。一般思路是，气泡半径越大，该数据点的冲击力/贡献就越大。所以，在我们的例子中，我们使用了销售额和最大销售额来确定半径，使用公式`(sales/(maxSale
    * 1d)) * 2`，这意味着我们将销售额缩放到2的比例。
- en: The rest of the details are exactly similar to the other two-axis charts we
    have seen, namely bar charts, line charts, and area charts. Therefore, we are
    not going into its details and we would highly recommend you visit those recipes.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的细节与我们所见的其他双轴图完全相同，即柱状图、折线图和区域图。因此，我们不会深入探讨其细节，并且强烈建议您访问那些食谱。
- en: See also
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating a bar chart
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating an area chart
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建区域图
- en: Creating a line chart
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Creating a scatter chart
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图
- en: Creating a scatter chart
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建散点图
- en: A scatter chart is another type of two-axis charts, where the data is presented
    as a set of points. Each series in the chart is presented by a different shape.
    These points are not joined, unlike line charts. Such charts help us in identifying
    where the bulk of the data lies by looking at the density of the data points.
    In this recipe, we will look at creating a simple scatter chart.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是另一种类型的双轴图，其中数据以点的集合形式呈现。图表中的每个序列都由不同的形状表示。这些点不像折线图那样相连。此类图表有助于我们通过查看数据点的密度来识别数据的大致分布。在本食谱中，我们将查看如何创建一个简单的散点图。
- en: Getting ready
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I have collected the statistics from the one-day international cricket match
    between India and New Zealand held on October 26, 2016 ([http://www.espncricinfo.com/series/1030193/scorecard/1030221](http://www.espncricinfo.com/series/1030193/scorecard/1030221)).
    The data collected is the score and overs in progress during the fall of wickets
    during both New Zealand and India''s innings. This data can be found in the file, `chp9/9_scatter_charts/src/gui/com/packt/wickets`.
    The data looks like the following:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我收集了2016年10月26日在印度和新西兰之间举行的一日国际板球比赛的统计数据（[http://www.espncricinfo.com/series/1030193/scorecard/1030221](http://www.espncricinfo.com/series/1030193/scorecard/1030221)）。收集的数据是新西兰和印度回合中钩子落下时的得分和进行中的球数。这些数据可以在文件`chp9/9_scatter_charts/src/gui/com/packt/wickets`中找到。数据看起来如下：
- en: '[PRE114]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In the preceding sample, each line of data has three parts:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，每行数据有三个部分：
- en: The team
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队
- en: The over in progress during the fall of the wicket
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子落下的进行中的球数
- en: Team score during the fall of the wicket
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子落下的团队得分
- en: We will plot this data on a scatter chart and get an idea as to how the wickets
    fell during each team's innings.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此数据绘制在散点图上，并了解每个队伍回合中板球是如何失掉的。
- en: 'For those who are wondering what this game called cricket is all about, we
    would suggest you spend a few minutes reading about it here: [https://en.wikipedia.org/wiki/Cricket](https://en.wikipedia.org/wiki/Cricket).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想知道这项被称为板球的游戏是什么的人来说，我们建议你花几分钟时间在这里阅读有关它的内容：[https://en.wikipedia.org/wiki/Cricket](https://en.wikipedia.org/wiki/Cricket)。
- en: How to do it...
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s first create a method to read the fall of wickets data from the file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个方法来从文件中读取板球失球数据：
- en: '[PRE115]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'A scatter chart is also an X-Y chart; we will use `XYChart.Series` to create
    data for the chart. Let''s write a method to create an instance of `XYChart.Series<Number,Number>`
    using the data parsed from the file:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 散点图也是一个X-Y图；我们将使用`XYChart.Series`来创建图表的数据。让我们编写一个方法来使用从文件解析的数据创建`XYChart.Series<Number,Number>`的实例：
- en: '[PRE116]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Let''s now build the UI (all this code goes within the `start(Stage stage)`
    method), starting with creating an instance of `GridPane` and configuring it:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来构建UI（所有这些代码都放在`start(Stage stage)`方法中），首先创建一个`GridPane`实例并对其进行配置：
- en: '[PRE117]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Load the data from the file using the method created in the first step:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第一步中创建的方法从文件加载数据：
- en: '[PRE118]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create the required *x* and *y* axes and add them to `ScatterChart`:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的*x*和*y*轴并将它们添加到`ScatterChart`：
- en: '[PRE119]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Create `XYChart.Series` for each team''s innings and add it to `ScatterChart`:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个队伍的回合创建`XYChart.Series`并将其添加到`ScatterChart`：
- en: '[PRE120]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Add `ScatterChart` to `gridPane` and create a new `Scene` graph with `gridPane`
    as the root:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScatterChart`添加到`gridPane`并创建一个新的`Scene`图，以`gridPane`为根：
- en: '[PRE121]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Set the scene graph to the `Stage` instance to be rendered on the display:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景图设置为要渲染在显示上的`Stage`实例：
- en: '[PRE122]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Launch the UI from the `main` method, as shown here:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`main`方法启动UI，如下所示：
- en: '[PRE123]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: You can find the complete code at the location, `chp9/9_scatter_charts`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在位置找到完整的代码，`chp9/9_scatter_charts`。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/9_scatter_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/9_scatter_charts`目录下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，而`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下GUI：
- en: '![](img/3d55039a-dfd9-4e8b-998b-4d8e33e1f0c9.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d55039a-dfd9-4e8b-998b-4d8e33e1f0c9.png)'
- en: How it works...
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A scatter chart works in a similar way to how a bar chart or a line chart works.
    It's another two-axis graph, where the data points are plotted on the two axes.
    The axes are created using `javafx.scene.chart.CategoryAxis` or `javafx.scene.chart.NumberAxis`,
    depending on whether the data is string or numeric.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图的工作方式与柱状图或线图类似。它是一个双轴图，数据点绘制在两个轴上。轴是通过使用`javafx.scene.chart.CategoryAxis`或`javafx.scene.chart.NumberAxis`创建的，具体取决于数据是字符串还是数值。
- en: 'The data to be plotted is provided in the form of `XYChart.Series<X,Y>`, where
    `X` and `Y` can be `String` or any type extending `Number`, and it contains the
    data in the form of a list of `XYChart.Data` objects, something like the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制的数据以`XYChart.Series<X,Y>`的形式提供，其中`X`和`Y`可以是`String`或任何扩展`Number`的类型，并且它包含以`XYChart.Data`对象列表形式的数据，如下所示：
- en: '[PRE124]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In a scatter chart, the data is plotted in the form of points, with each series
    having a specific color and shape, and these points are not joined, unlike line
    or area charts. This can be seen in the example used in the recipe.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在散点图中，数据以点的形式绘制，每个系列都有特定的颜色和形状，这些点之间没有连接，与线图或面积图不同。这可以在食谱中使用的示例中看到。
- en: See also
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes of this chapter:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Creating a bar chart
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating an area chart
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a line chart
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线图
- en: Creating a pie chart
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Creating a bubble chart
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Embedding HTML in an application
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入HTML
- en: JavaFX provides support for managing web pages via the classes defined in the `javafx.scene.web`
    package. It supports loading the web page, either by accepting the web page URL
    or by accepting the web page content. It also manages the document model of the
    web page, applies the relevant CSS, and runs the relevant JavaScript code. It
    also extends support for a two-way communication between JavaScript and the Java
    code.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 通过 `javafx.scene.web` 包中定义的类提供对管理网页的支持。它支持通过接受网页 URL 或接受网页内容来加载网页。它还管理网页的文档模型，应用相关的
    CSS，并运行相关的 JavaScript 代码。它还扩展了对 JavaScript 和 Java 代码之间双向通信的支持。
- en: 'In this recipe, we will build a very primitive and simple web browser, which
    supports the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建一个非常原始和简单的网页浏览器，它支持以下功能：
- en: Navigating through the history of the pages visited
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问过的页面历史记录中导航
- en: Reloading the current page
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载当前页面
- en: An address bar for accepting the URL
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于接受 URL 的地址栏
- en: A button for loading the entered URL
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于加载输入 URL 的按钮
- en: Showing the web page
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示网页
- en: Showing the status of loading of the web page
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示网页加载状态
- en: Getting ready
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will require an internet connection to test the loading of pages. So, make
    sure you are connected to the internet. Apart from this, there is nothing specific
    required to work with this recipe.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要互联网连接来测试页面加载。所以，请确保你已经连接到互联网。除此之外，没有其他特定要求来使用这个配方。
- en: How to do it...
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个具有空方法的类，它将代表启动应用程序以及 JavaFX UI 的主应用程序：
- en: '[PRE125]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In the subsequent steps, we will write all our code within the `start(Stage
    stage)` method.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续步骤中，我们将把所有代码都写入 `start(Stage stage)` 方法中。
- en: 'Let''s create a `javafx.scene.web.WebView` component, which will render our
    web page. This has the required `javafx.scene.web.WebEngine` instance, which manages
    loading of the web page:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `javafx.scene.web.WebView` 组件，它将渲染我们的网页。这具有所需的 `javafx.scene.web.WebEngine`
    实例，该实例管理网页的加载：
- en: '[PRE126]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Get the instance of `javafx.scene.web.WebEngine` used by `webView`. We will
    use this instance of `javafx.scene.web.WebEngine` to navigate through the history
    and load other web pages. Then we will, by default, load the URL, [http://www.google.com](http://www.google.com):'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由 `webView` 使用的 `javafx.scene.web.WebEngine` 实例。我们将使用这个 `javafx.scene.web.WebEngine`
    实例来浏览历史记录并加载其他网页。然后，默认情况下，我们将加载以下 URL，[http://www.google.com](http://www.google.com)：
- en: '[PRE127]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, let''s create a `javafx.scene.control.TextField` component, which will
    act as our browser''s address bar:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 `javafx.scene.control.TextField` 组件，它将充当我们的浏览器地址栏：
- en: '[PRE128]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We want to change the title of the browser and the web page in the address
    bar, based on the title and URL of the completely loaded web page. This can be
    done by listening to the change in the `stateProperty` of `javafx.concurrent.Worker`
    obtained from the `javafx.scene.web.WebEngine` instance:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望根据完全加载的网页的标题和 URL 来更改浏览器和地址栏中的网页标题。这可以通过监听从 `javafx.scene.web.WebEngine`
    实例获取的 `javafx.concurrent.Worker` 的 `stateProperty` 的变化来实现：
- en: '[PRE129]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    load the web page identified by the URL entered in the address bar:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `javafx.scene.control.Button` 实例，当点击时，将加载地址栏中输入的 URL 指定的网页：
- en: '[PRE130]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    go to the previous web page in the history. To achieve this, we will execute the
    JavaScript code, `history.back()`, from within the action handler:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `javafx.scene.control.Button` 实例，当点击时，将转到历史记录中的上一个网页。为此，我们将在动作处理程序中执行
    JavaScript 代码，`history.back()`：
- en: '[PRE131]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    go to the next entry in the history maintained by `javafx.scene.web.WebEngine`
    instance. For this, we will make use of the `javafx.scene.web.WebHistory` API:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `javafx.scene.control.Button` 实例，当点击时，将转到由 `javafx.scene.web.WebEngine`
    实例维护的历史记录中的下一个条目。为此，我们将使用 `javafx.scene.web.WebHistory` API：
- en: '[PRE132]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Next is the button for reloading the current page. Again, we will make use
    of `javafx.scene.web.WebEngine` to reload the current page:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是重新加载当前页面的按钮。同样，我们将使用 `javafx.scene.web.WebEngine` 来重新加载当前页面：
- en: '[PRE133]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, we need to group all the components created so far, namely, `prevButton`, `nextButton`,
    `reloadButton`, `webAddress`, and `goButton` so that they align horizontally with
    each other. To achieve this, we will make use of `javafx.scene.layout.HBox` with
    relevant spacing and padding to make the components look well spaced:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将迄今为止创建的所有组件（即 `prevButton`、`nextButton`、`reloadButton`、`webAddress`
    和 `goButton`）分组，以便它们彼此水平对齐。为了实现这一点，我们将使用 `javafx.scene.layout.HBox` 以及相关的间距和填充，使组件看起来有良好的间距：
- en: '[PRE134]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We would want to know whether the web page is loading and whether it has finished.
    Let''s create a `javafx.scene.layout.Label` field to update the status if the
    web page is loaded. Then, we listen to the updates to `workDoneProperty` of the
    `javafx.concurrent.Worker` instance, which we can get from the `javafx.scene.web.WebEngine`
    instance:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想知道网页是否正在加载以及是否已加载完成。让我们创建一个 `javafx.scene.layout.Label` 字段来更新状态，如果网页已加载。然后，我们将监听
    `javafx.concurrent.Worker` 实例的 `workDoneProperty` 的更新，我们可以从 `javafx.scene.web.WebEngine`
    实例中获取它：
- en: '[PRE135]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Let''s align the entire address bar (with its navigation buttons), `webView`,
    and `websiteLoadingStatus` vertically:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让整个地址栏（包括其导航按钮）、`webView` 和 `websiteLoadingStatus` 垂直对齐：
- en: '[PRE136]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create a new `Scene` object with the `VBox` instance created in the preceding
    step as the root:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一步骤中创建的 `VBox` 实例作为根，创建一个新的 `Scene` 对象：
- en: '[PRE137]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We want the `javafx.stage.Stage` instance to occupy the complete screen size;
    for this, we will make use of `Screen.getPrimary().getVisualBounds()`. Then, as
    usual, we will render the scene graph on the stage:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `javafx.stage.Stage` 实例占据整个屏幕大小；为此，我们将使用 `Screen.getPrimary().getVisualBounds()`。然后，像往常一样，我们将在舞台上渲染场景图：
- en: '[PRE138]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The complete code can be found at the location, `chp9/10_embed_html`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在位置 `chp9/10_embed_html` 中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/10_embed_html`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `chp9/10_embed_html` 目录下提供了两个运行脚本，`run.bat` 和 `run.sh`。`run.bat` 脚本用于在 Windows
    上运行应用程序，而 `run.sh` 脚本用于在 Linux 上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run.bat` 或 `run.sh` 运行应用程序，您将看到以下 GUI：
- en: '![](img/1191889d-a320-41ae-8954-3975de214628.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1191889d-a320-41ae-8954-3975de214628.png)'
- en: How it works...
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The web-related APIs are available in the module, `javafx.web`, so we will
    have to require it in `module-info`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 与网页相关的 API 在模块 `javafx.web` 中可用，因此我们将在 `module-info` 中引入它：
- en: '[PRE139]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following are the important classes in `javafx.scene.` web package when
    dealing with web pages in JavaFX:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 JavaFX 中的网页时，以下是在 `javafx.scene.` web 包中重要的类：
- en: '`WebView`: This UI component uses `WebEngine` to manage the loading, rendering,
    and interaction with the web page'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebView`：这个 UI 组件使用 `WebEngine` 来管理网页的加载、渲染和与网页的交互'
- en: '`WebEngine`: This is the main component that deals with loading and managing
    the web page'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebEngine`：这是处理加载和管理网页的主要组件'
- en: '`WebHistory`: This records the web pages visited in the current `WebEngine`
    instance'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebHistory`：这记录了当前 `WebEngine` 实例中访问的网页'
- en: '`WebEvent`: These are the instances passed to the event handlers of `WebEngine` invoked
    by the JavaScript event'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebEvent`：这些是传递给由 JavaScript 事件触发的 `WebEngine` 事件处理器的实例'
- en: In our recipe, we make use of the first three classes.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们使用了前三个类。
- en: We don't directly create an instance of `WebEngine`; instead, we make use of
    `WebView` to get a reference to the `WebEngine` instance managed by it. The `WebEngine` instance
    loads the web page asynchronously by submitting the task of loading the page to
    `javafx.concurrent.Worker` instances. Then, we register change listeners on these
    worker instance properties to track the progress of loading the web page. We have
    made use of two such properties in this recipe, namely, `stateProperty` and `workDoneProperty`.
    The former tracks the change of the state of the worker, and the latter tracks
    the percentage of work done.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接创建 `WebEngine` 的实例；相反，我们使用 `WebView` 来获取它管理的 `WebEngine` 实例的引用。`WebEngine`
    实例通过将加载网页的任务提交给 `javafx.concurrent.Worker` 实例来异步加载网页。然后，我们将注册这些工作实例属性的变化监听器以跟踪网页加载的进度。在这个配方中，我们使用了两个这样的属性，即
    `stateProperty` 和 `workDoneProperty`。前者跟踪工作状态的变化，后者跟踪已完成的工作百分比。
- en: 'A worker can go through the following states (as listed in the `javafx.concurrent.Worker.State`
    enum):'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者可以经过以下状态（如 `javafx.concurrent.Worker.State` 枚举中列出）：
- en: '`CANCELLED`'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCELLED`'
- en: '`FAILED`'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED`'
- en: '`READY`'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READY`'
- en: '`RUNNING`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNING`'
- en: '`SCHEDULED`'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHEDULED`'
- en: '`SUCCEEDED`'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUCCEEDED`'
- en: In our recipe, we are only checking for `SUCCEEDED`, but you can enhance it
    to check for `FAILED` as well. This will help us report invalid URLs or even get
    the message from the event object and show it to the user.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们只检查`SUCCEEDED`，但你也可以增强它以检查`FAILED`。这将帮助我们报告无效的URL，甚至从事件对象中获取消息并显示给用户。
- en: 'The way we add the listeners to track the change in the properties is by using
    the `addListener()` method on `*Property()`, where `*` can be `state`, `workDone`,
    or any other attribute of the worker that has been exposed as a property:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`*Property()`上使用`addListener()`方法来添加监听器以跟踪属性的变化，其中`*`可以是`state`、`workDone`或任何其他已公开为属性的worker属性：
- en: '[PRE140]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Then `javafx.scene.web.WebEngine` component also supports:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`javafx.scene.web.WebEngine`组件也支持：
- en: Reloading the current page
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载当前页面
- en: Getting the history of the pages loaded by it
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取它加载的页面历史
- en: Executing the JavaScript code
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: Listening to JavaScript properties, such as showing an alert box or confirmation
    box
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听JavaScript属性，例如显示警告框或确认框
- en: Interacting with the document model of the web page using the `getDocument()`
    method
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getDocument()`方法与网页的文档模型交互
- en: 'In this recipe, we also looked at using `WebHistory` obtained from `WebEngine`.
    `WebHistory` stores the web pages loaded by the given `WebEngine` instance, which
    means one `WebEngine` instance will have one `WebHistory` instance. `WebHistory`
    supports the following:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们还探讨了使用从`WebEngine`获取的`WebHistory`。`WebHistory`存储了给定`WebEngine`实例加载的网页，这意味着一个`WebEngine`实例将有一个`WebHistory`实例。`WebHistory`支持以下功能：
- en: Getting the list of entries by using the `getEntries()` method. This will also
    get us the number of entries in the history. This is required while navigating
    forward and backward in history; otherwise, we will end up with an index out of
    bounds exception.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getEntries()`方法获取条目列表。这将也会获取历史中的条目数量。在向前和向后导航历史时需要这个数量；否则，你可能会遇到索引越界异常。
- en: Getting `currentIndex`, that is, its index within the `getEntries()` list.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取`currentIndex`，即它在`getEntries()`列表中的索引。
- en: Navigating to the specific entry in the entries list of `WebHistory`. This can
    be achieved by using the `go()` method, which accepts an offset. This offset indicates
    which web page to load, relative to the current position. For example, *+1* indicates
    the next entry and *-1* indicates the previous entry. It's important to check
    for the boundary conditions; otherwise, you will end up with going before *0*,
    that is, *-1*, or going past the entry list size.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WebHistory`的条目列表中导航到特定的条目。这可以通过使用接受偏移量的`go()`方法实现。这个偏移量表示相对于当前位置要加载哪个网页。例如，`+1`表示下一个条目，而`-1`表示上一个条目。检查边界条件很重要；否则，你可能会超出范围，即到达`0`之前的`-1`，或者超出条目列表的大小。
- en: There's more...
  id: totrans-622
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In this recipe, we showed you a basic approach to creating a web browser using
    the support provided by JavaFX. You can enhance this to support the following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们向您展示了使用JavaFX支持创建网络浏览器的基本方法。你可以增强它以支持以下功能：
- en: Better error handling and user messages, that is, to show whether the web address
    is valid or not by tracking the state change of the worker
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的错误处理和用户消息，即通过跟踪工作线程的状态变化来显示网页地址是否有效。
- en: Multiple tabs
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个标签页
- en: Bookmarking
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收藏夹
- en: Storing the state of the browser locally so that the next time it is run, it
    loads all the bookmarks and history
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地存储浏览器的状态，以便下次运行时加载所有书签和历史记录
- en: Embedding media in an application
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入媒体
- en: JavaFX provides a component, `javafx.scene.media.MediaView`, for viewing videos
    and listening to audios. This component is backed by a media engine, `javafx.scene.media.MediaPlayer`,
    which loads and manages the playback of the media.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了一个组件`javafx.scene.media.MediaView`，用于查看视频和收听音频。这个组件由媒体引擎`javafx.scene.media.MediaPlayer`支持，该引擎加载并管理媒体的播放。
- en: In this recipe, we will look at playing a sample video and controlling its playback
    by using the methods on the media engine.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看如何通过使用媒体引擎上的方法来播放示例视频并控制其播放。
- en: Getting ready
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will make use of the sample video available at `chp9/11_embed_audio_video/sample_video1.mp4`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于`chp9/11_embed_audio_video/sample_video1.mp4`的示例视频。
- en: How to do it...
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个具有空方法的类，它将代表启动应用程序以及JavaFX UI的主应用程序：
- en: '[PRE141]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Create a `javafx.scene.media.Media` object for the video located at `chp9/11_embed_audio_video/sample_video1.mp4`:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为位于`chp9/11_embed_audio_video/sample_video1.mp4`的视频创建一个`javafx.scene.media.Media`对象：
- en: '[PRE142]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a new media engine,  `javafx.scene.media.MediaPlayer`, using the `javafx.scene.media.Media`
    object created in the previous step:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步创建的`javafx.scene.media.Media`对象创建一个新的媒体引擎`javafx.scene.media.MediaPlayer`：
- en: '[PRE143]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Let''s track the status of the media player by registering a change listener
    on `statusProperty` of the `javafx.scene.media.MediaPlayer` object:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在`javafx.scene.media.MediaPlayer`对象的`statusProperty`上注册一个更改监听器来跟踪媒体播放器的状态：
- en: '[PRE144]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Let''s now create a media viewer using the media engine created in the previous
    step:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用上一步创建的媒体引擎来创建一个媒体查看器：
- en: '[PRE145]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We will restrict the width and height of the media viewer:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将限制媒体查看器的宽度和高度：
- en: '[PRE146]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Next, we create three buttons to pause the video playback, resume the playback,
    and stop the playback. We will make use of the relevant methods in the `javafx.scene.media.MediaPlayer`
    class:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建三个按钮来暂停视频播放、恢复播放和停止播放。我们将使用`javafx.scene.media.MediaPlayer`类中的相关方法：
- en: '[PRE147]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Align all these buttons horizontally using `javafx.scene.layout.HBox`:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.layout.HBox`水平对齐所有这些按钮：
- en: '[PRE148]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Align the media viewer and the buttons bar vertically using `javafx.scene.layout.VBox`:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.layout.VBox`垂直对齐媒体查看器和按钮栏：
- en: '[PRE149]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create a new scene graph using the `VBox` object as the root and set it to
    the stage object:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VBox`对象作为根创建一个新的场景图，并将其设置到舞台对象：
- en: '[PRE150]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Render the stage on the display:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示上渲染舞台：
- en: '[PRE151]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The complete code can be found at `chp9/11_embed_audio_video`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`chp9/11_embed_audio_video`找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/11_embed_audio_video`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/11_embed_audio_video`下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，而`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/7db0582c-1ac0-4783-b57c-c1e36cea43b1.png)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7db0582c-1ac0-4783-b57c-c1e36cea43b1.png)'
- en: How it works...
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The important classes, in the `javafx.scene.media` package for media playback
    are as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在`javafx.scene.media`包中，对于媒体播放的重要类如下：
- en: '`Media`: This represents the source of the media, that is, either the video
    or audio. This accepts the source in the form of HTTP/HTTPS/FILE and JAR URLs.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Media`：这个类代表媒体的源，即视频或音频。它接受HTTP/HTTPS/FILE和JAR URL形式的源。'
- en: '`MediaPlayer`: This manages the playback of the media.'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaPlayer`：这个类管理媒体的播放。'
- en: '`MediaView`: This is the UI component that allows viewing the media.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaView`：这是一个UI组件，允许查看媒体。'
- en: 'There are a few other classes, but we haven''t covered them in this recipe.
    The media-related classes are in the `javafx.media` module. So, do not forget
    to require a dependency on it, as shown here:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些类，但我们没有在这个菜谱中介绍它们。与媒体相关的类在`javafx.media`模块中。所以，不要忘记像这里所示那样要求依赖它：
- en: '[PRE152]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'In this recipe, we have a sample video at `chp9/11_embed_audio_video/sample_video1.mp4`,
    and we make use of the `java.io.File` API to build `File` URL to locate the video:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有一个示例视频在`chp9/11_embed_audio_video/sample_video1.mp4`，我们使用`java.io.File`
    API来构建`File` URL以定位视频：
- en: '[PRE153]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The media playback is managed by using the API exposed by the `javafx.scene.media.MediaPlayer`
    class. In this recipe, we made use of a few of its methods, namely `play()`, `pause()`,
    and `stop()`. The `javafx.scene.media.MediaPlayer` class is initialized by using
    the `javafx.scene.media.Media` object:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放是通过使用`javafx.scene.media.MediaPlayer`类公开的API来管理的。在这个菜谱中，我们使用了它的一些方法，即`play()`、`pause()`和`stop()`。`javafx.scene.media.MediaPlayer`类是通过使用`javafx.scene.media.Media`对象来初始化的：
- en: '[PRE154]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Rendering the media on the UI is managed by the  `javafx.scene.media.MediaView` class,
    and it is backed by a `javafx.scene.media.MediaPlayer` object:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`javafx.scene.media.MediaView`类管理UI上的媒体渲染，它背后是一个`javafx.scene.media.MediaPlayer`对象：
- en: '[PRE155]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We can set the height and width of the viewer by using the `setFitWidth()` and
    `setFitHeight()` methods.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`setFitWidth()`和`setFitHeight()`方法来设置查看器的高度和宽度。
- en: There's more...
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: We gave a basic demo of media support in JavaFX. There's a lot more to explore.
    You can add volume control options, options to seek forward or backward, playing
    of audios, and audio equalizer.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaFX中提供了一个基本的媒体支持演示。还有很多可以探索的。您可以添加音量控制选项、向前或向后查找选项、播放音频和音频均衡器。
- en: Adding effects to controls
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向控件添加效果
- en: Adding effects in a controlled way gives a good appearance to the user interface.
    There are multiple effects like blurring, shadows, reflection, blooming, and so
    on. JavaFX provides a set of classes under the `javafx.scene.effects` package,
    which can be used to add effects to enhance the look of the application. This
    package is available in the `javafx.graphics` module.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 以受控的方式添加效果会给用户界面带来良好的外观。有多种效果，如模糊、阴影、反射、光晕等。JavaFX在`javafx.scene.effects`包下提供了一套类，可以用来添加效果以增强应用程序的外观。此包在`javafx.graphics`模块中可用。
- en: 'In this recipe, we will look at a few effects: blur, shadow, and reflection.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看几个效果：模糊、阴影和反射。
- en: How to do it...
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个具有空方法的类，它将代表启动应用程序以及JavaFX UI的主应用程序：
- en: '[PRE156]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The subsequent code will be written within the `start(Stage stage)` method.
    Create and configure `javafx.scene.layout.GridPane`:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后续代码将在`start(Stage stage)`方法中编写。创建并配置`javafx.scene.layout.GridPane`：
- en: '[PRE157]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Create rectangles required for applying the blur effects:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于应用模糊效果的矩形：
- en: '[PRE158]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Add `javafx.scene.effect.BoxBlur` to `Rectangle r1`, `javafx.scene.effect.MotionBlur`
    to `Rectangle r2`, and `javafx.scene.effect.GaussianBlur` to `Rectangle r3`:'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`javafx.scene.effect.BoxBlur`添加到`Rectangle r1`，将`javafx.scene.effect.MotionBlur`添加到`Rectangle
    r2`，将`javafx.scene.effect.GaussianBlur`添加到`Rectangle r3`：
- en: '[PRE159]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Add the rectangles to `gridPane`:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形添加到`gridPane`：
- en: '[PRE160]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Create three circles, required for applying shadows:'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个圆形，用于应用阴影：
- en: '[PRE161]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Add `javafx.scene.effect.DropShadow` to `c1` and `javafx.scene.effect.InnerShadow`
    to `c2`:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`javafx.scene.effect.DropShadow`添加到`c1`，将`javafx.scene.effect.InnerShadow`添加到`c2`：
- en: '[PRE162]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Add these circles to `gridPane`:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些圆形添加到`gridPane`：
- en: '[PRE163]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Create a simple text, `Reflection Sample`, on which we will apply the reflection
    effect:'
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将应用反射效果的简单文本`Reflection Sample`上创建一个文本：
- en: '[PRE164]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Create a `javafx.scene.effect.Reflection` effect and add it to the text:'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`javafx.scene.effect.Reflection`效果并将其添加到文本中：
- en: '[PRE165]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Add the text component to `gridPane`:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本组件添加到`gridPane`：
- en: '[PRE166]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Create a scene graph using `gridPane` as the root node:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gridPane`作为根节点创建一个场景图：
- en: '[PRE167]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Set the scene graph to the stage and render it on the display:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景图设置到舞台并渲染到显示上：
- en: '[PRE168]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The complete code can be found at `chp9/12_effects_demo`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`chp9/12_effects_demo`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/12_effects_demo`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp9/12_effects_demo`下提供了两个运行脚本，`run.bat`用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你将看到以下GUI：
- en: '![](img/d460b18c-fdd4-462a-ab25-842b8a9c556a.png)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d460b18c-fdd4-462a-ab25-842b8a9c556a.png)'
- en: How it works...
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have made use of the following effects:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了以下效果：
- en: '`javafx.scene.effect.BoxBlur`'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.BoxBlur`'
- en: '`javafx.scene.effect.MotionBlur`'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.MotionBlur`'
- en: '`javafx.scene.effect.GaussianBlur`'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.GaussianBlur`'
- en: '`javafx.scene.effect.DropShadow`'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.DropShadow`'
- en: '`javafx.scene.effect.InnerShadow`'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.InnerShadow`'
- en: '`javafx.scene.effect.Reflection`'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.Reflection`'
- en: 'The `BoxBlur` effect is created by specifying the width and height of the blur
    effect, and also the number of times the effect needs to be applied:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxBlur`效果是通过指定模糊效果的宽度和高度以及效果需要应用多少次来创建的：'
- en: '[PRE169]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `MotionBlur` effect is created by providing the angle of the blur and its
    radius. This gives an effect of something captured while in motion:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionBlur`效果是通过提供模糊角度和其半径来创建的。这会产生一种在运动中捕捉到某物的效果：'
- en: '[PRE170]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `GaussianBlur` effect is created by providing the radius of the effect,
    and the effect uses the Gaussian formula to apply the effect:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`GaussianBlur`效果是通过提供效果半径来创建的，效果使用高斯公式来应用效果：'
- en: '[PRE171]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The `DropShadow` adds the shadow behind the object whereas `InnerShadow` adds
    the shadow within the object. Each of these takes the radius of the shadow, the
    *x* and *y* location of the start of shadow, and the color of the shadow:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`DropShadow`在对象后面添加阴影，而`InnerShadow`在对象内部添加阴影。每个效果都接受阴影的半径、阴影开始位置的*x*和*y*坐标以及阴影的颜色：'
- en: '[PRE172]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`Reflection` is a pretty simple effect, which adds the reflection of the object.
    We can set the fraction of how much of the original object is reflected:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflection`是一个非常简单的效果，它添加了对象的反射。我们可以设置原始对象反射的分数：'
- en: '[PRE173]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: There's more...
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'There are quite a few more effects:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 还有相当多的其他效果：
- en: The blend effect, which blends two different inputs with a predefined blending
    approach
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合效果，通过预定义的混合方法将两个不同的输入混合在一起
- en: The bloom effect, which makes the brighter portions appear brighter
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣效果，使亮度较高的部分看起来更亮
- en: The glow effect, which makes the object glow
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发光效果，使对象发光
- en: Lighting effect, which simulates a light source on the object thereby giving
    it a 3D appearance.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光效果，通过在对象上模拟光源，从而使其具有 3D 效果。
- en: We would recommend you to try out these effects in the same way as we have tried
    them out.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您以我们尝试它们的方式尝试这些效果。
- en: Using the new TIFF I/O API to read TIFF images
  id: totrans-735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的 TIFF I/O API 读取 TIFF 图像
- en: '**Tagged Image File Format** (**TIFF**) is a common image format for exchanging
    images between applications. Previously, JDK didn''t have any support for reading
    TIFF images, and developers had to use the Java Image API, which was external
    to JDK.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**标记图像文件格式** (**TIFF**) 是一种常见的图像格式，用于在应用程序之间交换图像。之前，JDK 没有任何读取 TIFF 图像的支持，开发者必须使用
    JDK 外部的 Java 图像 API。'
- en: In this recipe, we will show you how to read a TIFF image file.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将向您展示如何读取 TIFF 图像文件。
- en: Getting ready
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We have a sample TIFF image file at the location, `chp9/13_tiff_reader/sample.tif`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在位置 `chp9/13_tiff_reader/sample.tif` 有一个示例 TIFF 图像文件。
- en: How to do it...
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Get the image readers by format name, which is `tiff` for TIFF images
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过格式名称获取图像读取器，对于 TIFF 图像，格式名称是 `tiff`
- en: '[PRE174]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Get the first `ImageReader` object from the image readers obtained in the previous
    step:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一步获取的图像读取器中获取第一个 `ImageReader` 对象：
- en: '[PRE175]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Create a `FileImageInputStream` object for the `sample.tif` image:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `sample.tif` 图像创建一个 `FileImageInputStream` 对象：
- en: '[PRE176]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Use the reader obtained to read the image file:'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用获取到的读取器读取图像文件：
- en: '[PRE177]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Let''s get some attributes, such as the number of images, width, and height,
    just to confirm that we have really read the image:'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取一些属性，例如图像数量、宽度和高度，以确认我们已经真正读取了图像：
- en: '[PRE178]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The complete code for this can be found at `chp9/13_tiff_reader`. You can run
    the sample either by using `run.bat` or `run.sh`.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的完整内容可以在 `chp9/13_tiff_reader` 文件夹中找到。您可以通过使用 `run.bat` 或 `run.sh` 运行示例。
