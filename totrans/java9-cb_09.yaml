- en: GUI Programming Using JavaFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI using JavaFX controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the FXML markup to create a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSS to style elements in JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding HTML in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding media in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding effects to controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new TIFF I/O API to read TIFF images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GUI programming has been in Java since JDK 1.0, via the API called **Abstract
    Window Toolkit** (**AWT**). This was a remarkable thing during those times, but
    it had its own limitations, a few of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It had a limited set of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You couldn't create custom reusable components because AWT was using native
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The look and feel of the components couldn't be controlled and they took the
    look and feel of the host OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, in Java 1.2, a new API for GUI development called **Swing** was introduced,
    which worked on the deficiencies of AWT by providing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A richer components library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for creating custom components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native look and feel and support for plugging in a different look and feel.
    Some of the know Java look and feel themes are Nimbus, Metal, Motif, and the system
    default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of desktop applications that make use of Swing have been built, and a
    lot of them are still being used. However, with time, technology has to evolve;
    otherwise, it will eventually be outdated and seldom used. In 2008, Adobe's Flex
    started gaining attention. It was a framework for building **Rich Internet applications**
    (**RIAs**). The desktop applications were always rich component-based UIs but
    the web applications were not that amazing to use. Adobe introduced a framework
    called Flex, which enabled web developers to create rich, immersive UIs on the
    web. So the web applications were no longer boring.
  prefs: []
  type: TYPE_NORMAL
- en: Adobe also introduced a rich internet application runtime environment for the
    desktop called Adobe AIR, which allowed running Flex applications on the desktop.
    This was a major blow to the age-old Swing API. In order to come back to the market,
    in 2009, Sun Microsystems introduced something called JavaFX. This framework was
    inspired by Flex (which used XML for defining the UI) and introduced its own scripting
    language called JavaFX script, somewhat closer to JSON and JavaScript. One could
    invoke Java APIs from the JavaFX script. There was a new architecture introduced,
    which had a new Windowing toolkit and a new graphics engine. It was a much better
    alternative to Swing but had a drawback--developers had to learn JavaFX script
    to develop JavaFX-based applications. In addition to Sun Microsystems not being
    able to invest more on JavaFX and the Java platform, in general, JavaFX never
    took off as envisioned.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle (after acquiring Sun Microsystems) announced a new JavaFX version 2.0,
    which was an entire rewrite of JavaFX, thereby eliminating the scripting language
    and making JavaFX an API within the Java platform. This has made using the JavaFX
    API similar to using Swing APIs. Also, one can embed JavaFX components within
    Swing, thereby making Swing-based applications more functional. Since then, there
    has been no looking back for JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus entirely on the recipes around JavaFX. We will
    try to cover as many recipes as possible to give you all a good experience of
    using JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI using JavaFX controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at creating a simple GUI application using JavaFX
    controls. We will build an app that will help you compute your age by providing
    your date of birth. Optionally, you can even enter your name and the app will
    greet you and display your age. It is a pretty simple example, which tries to
    show how you can create a GUI by using layouts, components, and event handling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JDK you have installed comes with the JavaFX modules, so there isn''t anything
    needed to be done to start using JavaFX. Various modules that contain the JavaFX
    classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.base`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.controls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.fxml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.graphics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.media`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.swing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we will be using a few modules as and when required from the
    preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class, which extends the `javafx.application.Application`. The `Application`
    class manages the lifecycle of the JavaFX application. The `Application` class
    has an abstract method, `start(Stage stage)`, which one has to implement. This
    would be our starting point for our JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can also be the starting point for the application by providing a
    `public static void main(String [] args) {}` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for the subsequent steps has to be written within the `start(Stage
    stage)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a container layout to properly align the components that we will
    be adding. In this case, we will use `javafx.scene.layout.GridPane` to lay the
    components in the form of a grid of rows and columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Along with creating the `GridPane` instance, we are setting its layout properties,
    such as the alignment of `GridPane`, the horizontal and vertical spaces between
    the rows and columns, and the padding within each cell of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new label, which will show the name of our application, specifically, `Age
    calculator`, and add it to `gridPane`, which we created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a label and a text input combination, which will be used for accepting
    the user''s name. Then add these two components to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a label and a date picker combination, which will be used for accepting
    the user''s date of birth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a button, which will be used by the user to trigger the age calculation,
    and add it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a component to hold the result of the computed age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to bind an action to the button created in step 6\. The action
    would be to get the name entered in the name field and the date of birth entered
    in the date picker field. If the date of birth is provided, then use the Java
    time APIs to compute the period between now and the date of birth. If there is
    a name provided, then prepend a greeting, `Hello, <name>`, to the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `Scene` class by providing the `gridPane` object
    we created in step 2 and the dimensions, the width and height of the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An instance of `Scene` holds the graph of the UI components, called scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen that the `start()` method provides us with a reference to a `Stage`
    object. The `Stage` object is the top-level container in JavaFX, something like
    a JFrame. We set the `Scene` object to the `Stage` object and use its `show()`
    method to render the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to launch this JavaFX UI from the main method. We use the `launch(String[]
    args)` method of the `Application` class to launch the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/1_create_javafx_gui`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two scripts, `run.bat` and `run.sh`, in `chp9/1_create_javafx_gui`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad34879-3c71-4d00-bbb5-f747cf1c635d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name and date of birth and click on `Calculate` to view the age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bacb4220-3851-4d61-8e84-e29c1ef47490.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going into the other details, let''s give you a brief overview of the
    JavaFX architecture. We have taken the following image describing the architecture
    stack from the JavaFX documentation ([http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a9a9b29-e0fd-47fd-b21a-36aa95e815e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start from the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The JavaFX APIs and Scene graph**: This is the starting point of the application
    and most of our focus will be around this part. This provides APIs for different
    components, layout, and other utilities to facilitate developing a JavaFX-based
    UI. The scene graph holds the visual elements of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prism, quantum toolkit, and the other stuff in blue**: These components manage
    the rendering of the UI and provide a bridge between the underlying operating
    system and JavaFX. This layer provides software rendering in the cases where the
    graphics hardware is unable to provide hardware-accelerated rendering of rich
    UI and 3D elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Glass Windowing Toolkit**: This is the windowing toolkit, just like the
    AWT used by Swing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The media engine**: This supports media in JavaFX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The web engine**: This supports the web component, which allows complete
    HTML rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The JDK APIs and JVM**: These integrate with the Java API and compile the
    code down to byte code to run on the JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get back to explaining the recipe. The `javafx.application.Application`
    class is the entry point for launching the JavaFX applications. It has the following
    methods that map to the lifecycle of the application (in their invocation order):'
  prefs: []
  type: TYPE_NORMAL
- en: '**`init()`**: This method is invoked immediately after the instantiation of `javafx.application.Application`.
    One can override this method to do some initialization before the start of the
    application. By default, this method does nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start(javafx.stage.Stage)`: This method is called immediately after `init()`
    and after the system has done the required initialization to run the application.
    This method is passed with a `javafx.stage.Stage` instance, which is the primary
    stage on which the components are rendered. One can create other `javafx.stage.Stage`
    objects but the one provided by the application is the primary stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This method is called when the application should stop. One can do
    the necessary exit-related operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stage is a top-level JavaFX container. The primary stage passed as an argument
    to the `start()` method is created by the platform, and the application can create
    other `Stage` containers as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important method related to `javafx.application.Application` is the
    `launch()` method. There are two variants of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`launch(Class<? extends Application> appClass, String... args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch(String... args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called from the main method and should be called only once. The
    first variant takes the name of the class that extends the `javafx.application.Application`
    class along with the arguments passed to the main method, and the second variant
    doesn't take the name of the class and, instead, should be invoked from within
    the class that extends the `javafx.application.Application` class. In our recipe,
    we have made use of the second variant.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class, `CreateGuiDemo`, which extends `javafx.application.Application`.
    This will be the entry point for JavaFX  UI and we also added a main method to
    the class, making it an entry point for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layout construct determines how your components are laid out. There are multiple
    layouts supported by JavaFX, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.HBox` and `javafx.scene.layout.VBox`: These are used to
    align the components horizontally and vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.BorderPane`: This allows placing the components in the
    top, right, bottom, left, and center positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.FlowPane`: This layout allows placing the components in
    a flow, that is, beside each other, wrapping at the flow pane''s boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.GridPane`: This layout allows placing the components in
    a grid of rows and columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.StackPane`: This layout places the components in a back-to-front
    stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.TilePane`: This layout places the components in a grid
    of uniformly sized tiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we have made use of `GridPane` and configured the layout so
    that we can achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The grid is placed at the center (`gridPane.setAlignment(Pos.CENTER);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the gap between the columns to 10 (`gridPane.setHgap(10);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the gap between the rows to 10 (`gridPane.setVgap(10);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the padding within the cell of the grid (`gridPane.setPadding(new Insets(25,
    25, 25, 25));`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `javafx.scene.text.Text` component's font can be set using the `javafx.scene.text.Font`
    object as shown here: `appTitle.setFont(Font.font("Arial", FontWeight.NORMAL,
    15));`
  prefs: []
  type: TYPE_NORMAL
- en: While adding the component to `javafx.scene.layout.GridPane`, we have to mention
    the column number, row number, and column span, that is, how many columns the
    component occupies, and the row span, that is, how many rows the component occupies
    in that order. The column span and row span are optional. In our recipe, we have
    placed `appTitle` in the first row and column, and it occupies two column spaces
    and one row space, as shown in the code here: `appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important part in this recipe is the setting of the event for the `ageCalculator`
    button. We make use of the `setOnAction()` method of the `javafx.scene.control.Button`
    class to set the action performed when the button is clicked. This accepts an
    implementation of the `javafx.event.EventHandler<ActionEvent>` interface. As `javafx.event.EventHandler`
    is a functional interface, its implementation can be written in the form a lambda
    expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax looks similar to your anonymous inner classes widely used
    during the times of Swing. You can learn more about functional interfaces and
    lambda expressions in the recipes in [Chapter 4](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml), *Going
    Functional*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our event handling code, we get the values from `nameField` and `dateOfBirthPicker` by
    using the methods, `getText()` and `getValue()`, respectively. `DatePicker` returns
    the date selected as an instance of `java.time.LocalDate`. This is one of the
    new date-time APIs added to Java 8\. It represents a date, that is, year, month,
    and day, without any timezone-related information. We then make use of the `java.time.Period`
    class to find the duration between the current date and the selected date, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Period` represents the date-based duration in terms of years, months, and
    days, that is, for example, 3 years, 2 months, and 3 days. This is exactly what
    we are trying to extract with this line of code: `String.format("Your age is %d
    years %d months %d days",  period.getYears(), period.getMonths(), period.getDays())`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already mentioned that the UI components in JavaFX are represented in
    the form of a scene graph and this scene graph is then rendered on to a container,
    called `Stage`*.* The way to create a scene graph is by using the `javafx.scene.Scene`
    class. We create a `javafx.scene.Scene` instance by passing the root of the scene
    graph and also by providing the dimensions of the container in which the scene
    graph is going to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of the container provided to the `start()` method, which is nothing
    but an instance of `javafx.stage.Stage`. Setting the scene for the `Stage` object
    and then calling its `show()` methods makes the complete scene graph rendered
    on the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the FXML markup to create a GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first recipe, we looked at using Java APIs to build a UI. It often happens
    that the person who is adept at Java might not be a good UI designer, that is,
    he may be poor at identifying the best user experience for their app. In the world
    of web development, we have developers working on the frontend, based on the designs
    given by the UX designer and the other set of developers working on the backend
    to build services that are consumed by the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Both the developer parties agree on a set of APIs and a common data interchange
    model. The frontend developers work by using some mock data based on the data
    interchange model and also integrate the UI with the required APIs. On the other
    hand, the backend developers work on implementing the APIs so that they return
    the data in the interchange model agreed upon.  So, both the parties work simultaneously
    using the expertise in their work areas.
  prefs: []
  type: TYPE_NORMAL
- en: It would be amazing if the same could be replicated (at least to some extent)
    on desktop applications. A step in this direction was the introduction of an XML-based
    language, called FXML. This enables a declarative method of UI development, where
    the developer can independently develop the UI using the same JavaFX components
    but available as XML tags. The different properties of the JavaFX components are
    available as attributes of the XML tags. Event handlers can be declared and defined
    in the Java code and then referred from FXML.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will guide you through building the UI using FXML and then
    integrating FXML with the Java code for binding the action and for launching the
    UI defined in the FXML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing much required if you have been able to implement the previous
    recipe. If you are coming directly to this recipe, there is nothing much to do
    either. The JavaFX APIs come with OpenJDK, which you must already have installed
    on your systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop a simple age calculator app. This app will ask for the user's
    name (which is optional) and the date of birth, and calculate the age from the
    given date of birth and display it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the FXML files should end with the `.fxml` extension. Let's create an empty `fxml_age_calc_gui.xml`
    file in the location, `src/gui/com/packt`. In the subsequent steps, we will update
    this file with the XML tags for the JavaFX components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `GridPane` layout, which will hold all the components in a grid of
    rows and columns. We will also provide the required spacing between the rows and
    the columns using the `vgap` and `hgap` attributes. Also, we will provide `GridPane`,
    which is our root component, with the reference to the Java class where we will
    add the required event handling. This Java class will be like the controller for
    the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will provide the padding within each cell of the grid by defining a `padding`
    tag with `Insets` within `GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to add a `Text` tag, which displays the title of the application: `Age
    Calculator`. We provide the required style information in the `style` attribute
    and the placement of the `Text` component within `GridPane` using the `GridPane.columnIndex`
    and `GridPane.rowIndex` attributes. The cell occupancy information can be provided
    using the `GridPane.columnSpan` and `GridPane.rowSpan` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `Label` and `TextField` components for accepting the name.
    Note the use of the `fx:id` attribute in `TextField`. This helps in binding this
    component in the Java controller by creating a field with the same name as that
    of the `fx:id` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `Label` and `DatePicker` components for accepting the date of birth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a `Button` object and set its `onAction` attribute to the name
    of the method in the Java controller that handles the click event of this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we add a `Text` component to display the calculated age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the Java class, which is directly related to
    the XML-based UI components created in the preceding steps. Create a class named `FxmlController`.
    This will contain the code that is relevant to the FXML UI; that is, it will contain
    the references to the components created in the FXML action handlers for the components
    created in the FXML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need references to the `nameField`, `dateOfBirthPicker`, and `resultText`
    components . We use the first two to get the entered name and date of birth, respectively,
    and the third to display the result of age calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `calculateAge` method, which is registered
    as the action event handler for the `Calculate` button. The implementation is
    similar to the one in the previous recipe. The only difference is that it is a
    method, unlike the previous recipe, where it was a lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In both steps 10 and 11, we have used an annotation, `@FXML`. This annotation
    indicates that the class or the member is accessible to the FXML-based UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll create another Java class, `FxmlGuiDemo`, which is responsible
    for rendering the FXML-based UI and which would also be the entry point for launching
    the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a scene graph from the FXML UI definition by overriding
    the `start(Stage stage)` method of the `javafx.application.Application` class and
    then render the scene graph within the passed `javafx.stage.Stage` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we provide the `main()` method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at the location, `chp9/2_fxml_gui`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, in `chp9/2_fxml_gui`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/759c00ef-26b6-4caf-ae90-ef377a3ce8cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name and date of birth and click on `Calculate` to view the age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4346fd9e-8e35-405f-aa5b-b5126d3584ae.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no XSD defining the schema for the FXML document. So, to know the
    tags to be used, they follow a simple naming convention. The Java class name of
    the component is also the name of the XML tag. For example, the XML tag for the `javafx.scene.layout.GridPane`
    layout is `<GridPane>`, for `javafx.scene.control.TextField`, it is `<TextField>`,
    and for `javafx.scene.control.DatePicker`, it is `<DatePicker>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code makes use of an instance of `javafx.fxml.FXMLLoader`
    to read the FXML file and get the Java representation of the UI components. `FXMLLoader`
    uses an event-based SAX parser to parse the FXML file. Instances of the respective
    Java classes for the XML tags are created via reflection and the values of attributes
    of the XML tags are populated into the respective properties of the Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: As the root of our FXML is `javafx.scene.layout.GridPane`, which extends `javafx.scene.layout.Pane`,
    we can cast the return value from `FXMLoader.load()` to `javafx.scene.layout.Pane`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other interesting thing in this recipe is the `FxmlController` class. This
    class acts as an interface to FXML. We indicate the same in FXML by using the `fx:controller`
    attribute to the `<GridPane>` tag. We can get hold of the UI components defined
    in FXML by using the `@FXML` annotation against the member fields of the `FxmlController`
    class, as we did in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the member is the same as that of the `fx:id` attribute value in
    FXML, and the type of the member is the same as that of the tag in FXML. For example,
    the first member is bound to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: On similar lines, we created an event handler in `FxmlController` and annotated
    it with `@FXML`, and the same has been referenced in FXML with the `onAction`
    attribute of `<Button>`. Note that we have added `#` to the beginning of the method
    name in the `onAction` attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI using JavaFX controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSS to style elements in JavaFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those from a web development background will be able to appreciate the usefulness
    of the **Cascading Style Sheets** (**CSS**), and for those who are not, we will
    provide an overview of what they are and how they are useful, before diving into
    CSS application in JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: The elements or the components that you see on web pages are often styled according
    to the theme of the website. This styling is possible by using a language called
    CSS. CSS consists of a group of name:value pairs, separated by semi colons. These
    name:value pairs, when associated with an HTML element, say, `<button>`, give
    it the required styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to associate these name:value pairs to the element,
    the simplest being when you put this name:value pair within the style attribute
    of your HTML element. For example, to give the button a blue background, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are predefined names for different styling properties, and these take
    a specific set of values; that is, the property, `background-color`, will only
    take valid color values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other approach is to define these groups of name:value pairs in a different
    file with a `.css` extension. Let''s call this group of name:value pairs as CSS
    properties. We can associate these CSS properties with different selectors, that
    is, selectors for choosing the elements on the HTML page to apply the CSS properties
    to. There are three different ways of providing the selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: By directly giving the name of the HTML element, that is, whether it is an anchor
    tag (`<a>`), button, or input. In such cases, the CSS properties are applied to
    all the types of HTML elements in the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using the `id` attribute of the HTML element. Suppose, we have a button
    with `id="btn1"`, then we can define a selector, `#btn1`, against which we provide
    the CSS properties. Take a look at the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the class attribute of the HTML element. Suppose we have a button
    with `class="blue-btn"`, then we can define a selector, `.blue-btn`, against which,
    we provide the CSS properties. Check out the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using a different CSS file is that we can independently evolve
    the appearance of the web pages without getting tightly coupled to the location
    of the elements. Also, this encourages the reuse of CSS properties across different
    pages, thereby giving them a uniform look across all the pages.
  prefs: []
  type: TYPE_NORMAL
- en: When we apply a similar approach to JavaFX, we can leverage the CSS knowledge
    already available with our web designers to build CSS for JavaFX components, and
    this helps in styling the components more easily than with the use of Java APIs.
    When this CSS is mixed with FXML, then it becomes a known domain for web developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at styling a few JavaFX components using an external
    CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a small difference in defining the CSS properties for the JavaFX components.
    All the properties must be prefixed with `-fx-`, that is, `background-color` becomes
    `-fx-background-color`. The selectors, that is, `#id` and `.class`-name still
    remain the same in the JavaFX world as well. We can even provide multiple classes
    to the JavaFX components, thereby applying all these CSS properties to the components.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS that I have used in this recipe is based on a popular CSS framework
    called Bootstrap ([http://getbootstrap.com/css/](http://getbootstrap.com/css/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create `GridPane`, which will hold the components in a grid of rows
    and columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create a button and add two classes, `btn` and `btn-primary`,
    to it. In the next step, we will define these selectors with the required CSS
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s provide the required CSS properties for the classes, `btn` and
    `btn-primary`. The selector for the classes are of the form `.<class-name>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another button with a different CSS class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the CSS properties for the `.btn-success` selector as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create yet another button with a different CSS class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the CSS properties for the selector `.btn-danger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some labels with different selectors, namely `badge`, `badge-info`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS properties for the previous selectors are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add `TextField` with a `big-input` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We define CSS properties so that the content of the text box is large in size
    and red in color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some radio buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We define CSS properties so that the labels of the radio button are large in
    size and green in color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add `javafx.scene.layout.GridPane` to the scene graph and render
    the scene graph on `javafx.stage.Stage`. We also need to associate the `stylesheet.css`
    with the `Scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main()` method to launch the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at the location, `chp9/3_css_javafx`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/3_css_javafx`.
    The `run.bat` will be for running the application on Windows and `run.sh` will
    be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bf193de-fa8c-41cf-98e4-0d6f9203a1a1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we make use of class names and their corresponding CSS selectors
    to associate components with different styling properties. JavaFX supports a subset
    of CSS properties and there are different properties applicable to different types
    of JavaFX components. The JavaFX CSS reference guide ([http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html))
    will help you identify the supported CSS properties.
  prefs: []
  type: TYPE_NORMAL
- en: All the scene graph nodes extend from an abstract class, `javax.scene.Node`.
    This abstract class provides an API, `getStyleClass()`, which returns a list of
    class names (which are plain `String`) added to the node or the JavaFX component.
    As this is a simple list of class names, we can even add more class names to it
    by using `getStyleClass().add("new-class-name")`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using class names is that it allows us to group similar components
    by a common class name. This technique is widely used in the web development world.
    Suppose I have a list of buttons on the HTML page and I want a similar action
    to be performed on the click of each button. To achieve this, I will assign each
    of the buttons the same class, say, `my-button`, and then use `document.getElementsByClassName('my-button')`
    to get an array of these buttons. Now we can loop through the array of buttons
    obtained and add the required action handlers.
  prefs: []
  type: TYPE_NORMAL
- en: After assigning a class to the component, we need to write the CSS properties
    for the given class name. These properties then get applied to all the components
    with the same class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pick one of the components from our recipe and see how we went about
    styling the same. Consider the following component with two classes, `btn` and
    `btn-primary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the selectors, `.btn` and `.btn-primary`, and we have grouped
    all the CSS properties under these selectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that in CSS, we have a `color` property, and its equivalent in JavaFX is
    `-fx-text-fill`. The rest of the CSS properties, namely `border-radius`, `border`,
    `font-size`, `font-weight`, `text-align`, `background-color`, and `border-color`,
    are prefixed with `-fx-`.
  prefs: []
  type: TYPE_NORMAL
- en: The important part is how you associate the stylesheet with the Scene component.
    The `scene.getStylesheets().add("com/packt/stylesheet.css");` line of code associates
    stylesheets with the Scene component. As `getStylesheets()` returns a list of
    strings, we can add multiple strings to it, which means that we can associate
    multiple stylesheets to a Scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of `getStylesheets()` states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the
    URL does not have a [scheme:] component, the URL is considered to be the [path]
    component only. Any leading '/' character of the [path] is ignored and the [path]
    is treated as a path relative to the root of the application's classpath.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we are using the `path` component only, and, hence, it looks
    for the file in the classpath. This is the reason why we have added the stylesheet
    in the same package as that of the scene. This is an easier way of making it available
    on the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data, when represented in the form of tables, is very hard to understand, but
    the same, when represented graphically by using charts, is comfortable for the
    eyes and easy to understand. We have seen a lot of charting libraries for web
    applications. However, the same support was lacking on the desktop application
    front. Swing didn't have native support for creating charts and we had to rely
    on third-party applications such as **JFreeChart** ([http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)).
    With JavaFX though, we have native support for creating charts, and we are going
    to show you how to represent the data in the form of charts using the JavaFX chart
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaFX supports the following chart types:'
  prefs: []
  type: TYPE_NORMAL
- en: Bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few recipes, we will cover the construction of each chart type.
    This segregation of each chart type into a recipe of its own will help us in explaining
    the recipes in a simpler way and will aid better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will be all about bar charts. A sample bar chart looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/150d29df-9cf5-4710-bf6e-5f12ef97d960.png)'
  prefs: []
  type: TYPE_IMG
- en: Bar charts can have a single bar or multiple bars (like the preceding image)
    for each value on the *x*-axis. Multiple bars help us in comparing multiple value
    points for each value on the *x*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make use of a subset of data from the student performance machine learning
    repository ([https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)).
    The dataset consists of student performance in two subjects, Mathematics and Portuguese,
    along with their social background information, such as their parents'' occupation
    and education, among other information. There are quite a lot of attributes in
    the dataset, but we will pick the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Student's gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Student's age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Father's education
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Father's occupation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mother's education
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mother's occupation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the student has taken extra classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First term grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second term grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are a lot of attributes captured in the data,
    but we should be good with a few important attributes that will help us in plotting
    some useful charts. Due to this, we have extracted the information from the dataset
    available in the machine learning repository into a separate file, which can be
    found at the location, `chp9/4_bar_charts/src/gui/com/packt/students`, in the
    code download for the book. An excerpt from the students file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries are semicolon (`;`) separated. Each entry has been explained for
    what it represents. The education information (fields 3 and 4) is a numeric value,
    where each number represents the level of education, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: Primary education (fourth grade)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: Fifth to ninth grade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: Secondary education'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4: Higher education'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a module for processing the student file. The module name is
    `student.processor` and its code can be found at `chp9/101_student_data_processor`.
    So, if you want to change any code there, you can rebuild the JAR by running the
    `build-jar.bat` or `build-jar.sh` file. This will create a modular JAR, `student.processor.jar`,
    in the `mlib` directory. Then, you have to replace this modular JAR with the one
    present in the `mlib` directory of this recipe, that is, `chp9/4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you to build the student.processor modular jar from the source
    available in `chp9/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform. And then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can reuse this module across all the recipes on charts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create `GridPane` and configure it to place the charts that we will
    be creating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `StudentDataProcessor` class from the `student.processor` module to
    parse the student file and load the data into `List` of `Student`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw data, that is, the list of `Student` objects is not useful for plotting
    a chart, so we need to process the students'' grades by grouping the students
    according to their mothers'' and fathers'' education and computing the average
    of those students'' grades (all three terms). For this, we will write a simple
    method, which accepts `List<Student>`, a grouping function, that is, the value
    on which the students need to be grouped, and a mapping function, that is, the
    value that has to be used to compute the average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method uses the new Stream-based APIs. These APIs are so powerful
    that they group the students by using `Collectors.groupingBy()` and then compute
    the statistics of their grades by using `Collectors.summarizingInt()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data for the bar chart is provided as an instance of `XYChart.Series`.
    Each series results in one `Y` value for a given `X` value, which is one bar for
    a given `X` value. We will have multiple series, one for each term, that is, first
    term grades, second term grades, and the final grades. Let''s create a method
    that takes in the statistics of each term grades and the `seriesName` and returns
    a `series` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create two bar charts: one for the average grade by mother''s education
    and the other for the average grade by father''s education. For this, we will
    create a method that will take `List<Student>` and a classifier, that is, a function
    that will return the value to be used to group the students. This method will
    do the necessary computations and return us a `BarChart` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `BarChart` for the average grades by mother''s education, and add it
    to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `BarChart` for average grades by father''s education and add it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph using `gridPane` and set it to `Stage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/4_bar_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/4_bar_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3135a8b1-82ec-4656-9fb4-185d09904c91.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first see what it takes to create `BarChart`. `BarChart` is a two axes-based
    chart, where the data is plotted on two axes, namely the *x* axis (horizontal
    axis) and the *y* axis (vertical axis). The other two axes-based charts are area
    chart, bubble chart, and line chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaFX, there are two types of axes supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.chart.CategoryAxis`: This supports string values on the axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.chart.NumberAxis`: This supports numeric values on the axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we created `BarChart` with `CategoryAxis` as the *x* axis, where
    we plot the education, and `NumberAxis` as the *y* axis, where we plot the grade,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the next few paragraphs, we show you how the plotting of `BarChart` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data to be plotted on `BarChart` should be a pair of values, where each
    pair represents *(x, y)* values, that is, a point on the *x* axis and a point
    on the *y* axis. This pair of values is represented by `javafx.scene.chart.XYChart.Data`.
    `Data` is a nested class within `XYChart`, which represents a single data item
    for a two axes-based chart. An `XYChart.Data` object can be created quite simply,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just one-data item. A chart can have multiple data items, that is,
    a series of data items. To represent a series of data items, JavaFX provides a
    class called `javafx.scene.chart.XYChart.Series`. This `XYChart.Series` object
    is a named series of `XYChart.Data` items. Let''s create a simple series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`BarChart` can have multiple series of data items. If we provide it with multiple
    series, then there will be multiple bars for each data point on the *x* axis.
    For our demonstration of how this works, we will stick with one series. But the
    `BarChart` class in our recipe uses multiple series. Let''s add the series to
    the `BarChart` and then render it onto the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e71ed2-c2fa-4572-b24d-fdc56cd1b795.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other interesting part of this recipe is the grouping of students based
    on the education of mother and father and then computing the average of their
    first term, second term, and final grades. The line of code that does the grouping
    and average computation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a stream from `List<Student>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces this stream to the required grouping by using the `collect()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the overloaded versions of `collect()` takes two parameters. The first
    one is the function that returns the value on which the students need to be grouped.
    The second parameter is an additional mapping function, which maps the grouped
    student object into the required format. In our case, the required format is to
    get `IntSummaryStatistics` for the group of students on any of their grade values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding two pieces (setting up the data for a bar chart and creating the
    required objects to populate a `BarChart` instance) are important parts of the
    recipe; understanding them will give you a clearer picture of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pie charts, as the name suggests, are circular charts with slices (either joined
    or separated out), where each slice and its size indicates the magnitude of the
    item that the slice represents. Pie charts are used to compare the magnitudes
    of different classes, categories, products, and the like. This is how a sample
    pie chart looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89fcaedc-0219-43c3-ab55-5da501bac4bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of the same student data (taken from the machine learning repository and
    processed at our end) that we had discussed in the recipe, *Creating a bar chart*.
    For this, we have created a module, `student.processor`, which will read the student
    data and provide us with a list of `Student` objects. The source code for the
    module can be found at `chp9/101_student_data_processor`. We have provided the
    modular jar for the `student.processor` module at `chp9/5_pie_charts/mlib` of
    this recipe's code.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you to build the `student.processor` modular jar from the source
    available in `chp9/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform. And then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create and configure `GridPane` to hold our pie charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `StudentDataProcessor` (which comes from the `student.processor` module)
    and use it to load `List` of `Student`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to get the count of students by their mother''s and father''s
    profession. We will write a method, which will take a list of students and a classifier,
    that is, the function that returns the value on which the students need to be
    grouped. The method returns an instance of `PieChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We will invoke the preceding method twice - one with the mother''s occupation
    as the classifier and the other with the father''s occupation as the classifier.
    We then add the returned `PieChart` instance to `gridPane`. This should be done
    from within the `start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to create the scene graph using `gridPane` and add it to `Stage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI can be launched from the main method by invoking the `Application.launch`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/5_pie_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/5_pie_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95ecc014-5354-4387-9329-8996fe42a38b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important method that does all the work in this recipe is the `getStudentCountByOccupation()`.
    It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group the number of students by profession. This can be done in a single line
    of code using the power of the new streaming APIs (added as part of Java 8):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Build data required for `PieChart`. The `PieChart` instance''s data is `ObservableList`
    of `PieChart.Data`. We first make use of `Map` obtained in the preceding step
    to create `ArrayList` of `PieChart.Data`. Then, we use the `FXCollections.observableList()`
    API to obtain `ObservableList<PieChart.Data>` from `List<PieChart.Data>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The other important thing in the recipe is the classifiers we use: `Student::getMotherJob`
    and `Student::getFatherJob`. These are the two method references that invoke the `getMotherJob`
    and `getFatherJob` methods on the different instances of `Student` in the list
    of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the `PieChart` instances, we add them to `GridPane` and then construct
    the scene graph using `GridPane`. The scene graph has to be associated with `Stage`
    for it to be rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The main method launches the UI by invoking the `Application.launch(args);`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A line chart is a two-axis chart similar to the bar chart; instead of having
    bars, the data is plotted on the X-Y plane using points, and the points are joined
    together to depict the change of data. Line charts are used to get an understanding
    of how a certain variable is performing and when combined with multiple variables,
    that is, by using multiple series, we can see how each variable is performing
    when compared to other variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of crude oil and brent oil price variation
    over the last three years. This data can be found at the locations, `chp9/6_line_charts/src/gui/com/packt/crude-oil`
    and `chp9/6_line_charts/src/gui/com/packt/brent-oil`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a **Plain Old Java Object** (**POJO**) to represent the oil
    price in a given month and year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to write a `getOilData(String oilType)` method, which will read the
    data from the given file and construct `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will write a method, which will take the name of the series and the
    data to be populated in the series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty `start(Stage stage)`  method, which we will override in the
    next few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and configure `GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `CategoryAxis` as the *x* axis and `NumberAxis` as the *y* axis, and
    label them accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize a `LineChart` instance with the axes created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the crude oil data into `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Load Brent oil data into `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a series, each for crude oil and Brent oil, and add it to `lineChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `LineChart` to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph with `GridPane` as the root and set the size as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the properties for the `Stage` object passed into the `start(Stage stage)`
    method and associate the scene graph created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the UI by invoking the `javafx.application.Application.launch()` method
    from the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/6_line_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/6_line_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3822235a-49d3-44e3-aaa6-9ea275983fce.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other two-axis chart, the line chart has the *x* axis and *y* axis.
    These axes can be of string types or numeric. String values are represented by
    `javafx.scene.chart.CategoryAxis` and numeric values by `javafx.scene.chart.NumberAxis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new `LineChart` is created by providing the *x* axis and *y* axis objects
    as parameters to its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Data to `LineChart` is provided in the form of an instance of `XYChart.Series`.
    So, if `LineChart` uses `String` on the *x* axis and `Number` on the *y* axis,
    then we create an instance of `XYChart.Series<String, Number>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`XYChart.Series` contains data of the `XYChart.Data` type, so `XYChart.Series<String,
    Number>` will contain data of the `XYChart.Data<String, Number>` type. Let''s
    add some data to the series created in the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the series to the `lineChart`''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create one more series on similar lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The chart created looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03f0f574-091f-43a4-8ccf-a54f8c9cc620.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An area chart is similar to a line chart, the only difference being the area
    between the plotted line and the axis is colored, with different series being
    colored by different colors. In this recipe, we will look at creating an area
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of the crude oil and Brent oil price variation data from the
    previous recipe (*Creating a line chart*) to plot an area chart.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a POJO to represent the oil price in a given month and year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll write a method, `getOilData(String oilType)`, which will read
    the data from the given file and construct `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will write a method that will take the name of the series and the
    data to be populated in the series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty `start(Stage stage)`  method, which we will override in the
    next few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and configure `GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `CategoryAxis` as the *x* axis and `NumberAxis` as the *y* axis and
    label them accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `AreaChart` with the axes created in the preceding steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Load crude oil data into `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Load Brent oil data into `List<OilPrice>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a series each for crude oil and brent oil, and add it to `AreaChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `AreaChart` to `GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph with `GridPane` as the root and set the size as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the properties for the `Stage` object passed into the `start(Stage stage)`
    method and associate the scene graph created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the UI by invoking the `javafx.application.Application.launch()` method
    from the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/7_area_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under`chp9/7_area_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60a95f3c-aaa8-42ff-a4b4-0e55264b4547.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Area charts are similar to line charts so we would highly recommend reading
    the recipe, *Creating a line chart*. An area chart is made up of two axes with
    data plotted on the *x* and *y* axis. The data to be plotted is provided as an
    instance of `XYChart.Series`. The axis of the chart can be either `javafx.scene.chart.CategoryAxis`
    or `javafx.scene.chart.NumberAxis`.
  prefs: []
  type: TYPE_NORMAL
- en: '`XYChart.Series` contains data encapsulated in instances of `XYChart.Data`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Bubble chart is also a two-axis chart with a third dimension to the data,
    that is, the radius of the bubble. Bubble chart supports only `NumberAxis`, so
    we can have only numbers on both *x* and *y* axes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple bubble chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have provided a sample store visit data at different times during the day
    along with the sales information during that hour. This sample data file can be
    found at the location, `chp9/8_bubble_charts/src/gui/com/packt/store`. Each line
    in the data file consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The hour of the day
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of visits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Total sales
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a method to read the data from the file into `StoreVisit` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the maximum sale value during any part of the day. So, let''s
    create a method, which accepts the `List<StoreVisit>` and returns the maximum
    sale. We will use this maximum sale to determine the radius of the bubble in the
    chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and configure a `GridPane` object where we will place the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `NumberAxis` objects for *x* and *y* axis and give them corresponding
    names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `BubbleChart` with these two axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `XYChart.Series` from the store visit data, read from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate `bubbleChart` with the series created in the preceding step and add
    it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the chart by creating a scene graph with `gridPane` and set it to the
    `Stage` object passed into the `start(Stage stage)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/8_bubble_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/8_bubble_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6586b333-8141-4ed5-b65c-5c90a79dc4e0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bubble chart is another two-axis chart just like area chart, line chart, and
    bar chart. The only difference being that the `XYChart.Data` object takes in the
    third argument in its constructor, which determines the radius of the bubble.
    The general idea is that the greater the bubble radius, the greater is the impact/contribution
    of that data point. So, in our example, we have used the sales value and the maximum
    sales value to determine the radius by using the formula, `(sales/(maxSale  *
    1d)) * 2`, which means we are sizing the sales to the scale of 2.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the details are exactly similar to the other two-axis charts we
    have seen, namely bar charts, line charts, and area charts. Therefore, we are
    not going into its details and we would highly recommend you visit those recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scatter chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scatter chart is another type of two-axis charts, where the data is presented
    as a set of points. Each series in the chart is presented by a different shape.
    These points are not joined, unlike line charts. Such charts help us in identifying
    where the bulk of the data lies by looking at the density of the data points.
    In this recipe, we will look at creating a simple scatter chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have collected the statistics from the one-day international cricket match
    between India and New Zealand held on October 26, 2016 ([http://www.espncricinfo.com/series/1030193/scorecard/1030221](http://www.espncricinfo.com/series/1030193/scorecard/1030221)).
    The data collected is the score and overs in progress during the fall of wickets
    during both New Zealand and India''s innings. This data can be found in the file, `chp9/9_scatter_charts/src/gui/com/packt/wickets`.
    The data looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding sample, each line of data has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The over in progress during the fall of the wicket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team score during the fall of the wicket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will plot this data on a scatter chart and get an idea as to how the wickets
    fell during each team's innings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who are wondering what this game called cricket is all about, we
    would suggest you spend a few minutes reading about it here: [https://en.wikipedia.org/wiki/Cricket](https://en.wikipedia.org/wiki/Cricket).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a method to read the fall of wickets data from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'A scatter chart is also an X-Y chart; we will use `XYChart.Series` to create
    data for the chart. Let''s write a method to create an instance of `XYChart.Series<Number,Number>`
    using the data parsed from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now build the UI (all this code goes within the `start(Stage stage)`
    method), starting with creating an instance of `GridPane` and configuring it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the data from the file using the method created in the first step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the required *x* and *y* axes and add them to `ScatterChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `XYChart.Series` for each team''s innings and add it to `ScatterChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `ScatterChart` to `gridPane` and create a new `Scene` graph with `gridPane`
    as the root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the scene graph to the `Stage` instance to be rendered on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the UI from the `main` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete code at the location, `chp9/9_scatter_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/9_scatter_charts`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d55039a-dfd9-4e8b-998b-4d8e33e1f0c9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scatter chart works in a similar way to how a bar chart or a line chart works.
    It's another two-axis graph, where the data points are plotted on the two axes.
    The axes are created using `javafx.scene.chart.CategoryAxis` or `javafx.scene.chart.NumberAxis`,
    depending on whether the data is string or numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data to be plotted is provided in the form of `XYChart.Series<X,Y>`, where
    `X` and `Y` can be `String` or any type extending `Number`, and it contains the
    data in the form of a list of `XYChart.Data` objects, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In a scatter chart, the data is plotted in the form of points, with each series
    having a specific color and shape, and these points are not joined, unlike line
    or area charts. This can be seen in the example used in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding HTML in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaFX provides support for managing web pages via the classes defined in the `javafx.scene.web`
    package. It supports loading the web page, either by accepting the web page URL
    or by accepting the web page content. It also manages the document model of the
    web page, applies the relevant CSS, and runs the relevant JavaScript code. It
    also extends support for a two-way communication between JavaScript and the Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will build a very primitive and simple web browser, which
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through the history of the pages visited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An address bar for accepting the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button for loading the entered URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the status of loading of the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require an internet connection to test the loading of pages. So, make
    sure you are connected to the internet. Apart from this, there is nothing specific
    required to work with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In the subsequent steps, we will write all our code within the `start(Stage
    stage)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `javafx.scene.web.WebView` component, which will render our
    web page. This has the required `javafx.scene.web.WebEngine` instance, which manages
    loading of the web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the instance of `javafx.scene.web.WebEngine` used by `webView`. We will
    use this instance of `javafx.scene.web.WebEngine` to navigate through the history
    and load other web pages. Then we will, by default, load the URL, [http://www.google.com](http://www.google.com):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `javafx.scene.control.TextField` component, which will
    act as our browser''s address bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to change the title of the browser and the web page in the address
    bar, based on the title and URL of the completely loaded web page. This can be
    done by listening to the change in the `stateProperty` of `javafx.concurrent.Worker`
    obtained from the `javafx.scene.web.WebEngine` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    load the web page identified by the URL entered in the address bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    go to the previous web page in the history. To achieve this, we will execute the
    JavaScript code, `history.back()`, from within the action handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, on click, will
    go to the next entry in the history maintained by `javafx.scene.web.WebEngine`
    instance. For this, we will make use of the `javafx.scene.web.WebHistory` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the button for reloading the current page. Again, we will make use
    of `javafx.scene.web.WebEngine` to reload the current page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to group all the components created so far, namely, `prevButton`, `nextButton`,
    `reloadButton`, `webAddress`, and `goButton` so that they align horizontally with
    each other. To achieve this, we will make use of `javafx.scene.layout.HBox` with
    relevant spacing and padding to make the components look well spaced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We would want to know whether the web page is loading and whether it has finished.
    Let''s create a `javafx.scene.layout.Label` field to update the status if the
    web page is loaded. Then, we listen to the updates to `workDoneProperty` of the
    `javafx.concurrent.Worker` instance, which we can get from the `javafx.scene.web.WebEngine`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s align the entire address bar (with its navigation buttons), `webView`,
    and `websiteLoadingStatus` vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Scene` object with the `VBox` instance created in the preceding
    step as the root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the `javafx.stage.Stage` instance to occupy the complete screen size;
    for this, we will make use of `Screen.getPrimary().getVisualBounds()`. Then, as
    usual, we will render the scene graph on the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at the location, `chp9/10_embed_html`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/10_embed_html`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1191889d-a320-41ae-8954-3975de214628.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web-related APIs are available in the module, `javafx.web`, so we will
    have to require it in `module-info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the important classes in `javafx.scene.` web package when
    dealing with web pages in JavaFX:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebView`: This UI component uses `WebEngine` to manage the loading, rendering,
    and interaction with the web page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebEngine`: This is the main component that deals with loading and managing
    the web page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebHistory`: This records the web pages visited in the current `WebEngine`
    instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebEvent`: These are the instances passed to the event handlers of `WebEngine` invoked
    by the JavaScript event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we make use of the first three classes.
  prefs: []
  type: TYPE_NORMAL
- en: We don't directly create an instance of `WebEngine`; instead, we make use of
    `WebView` to get a reference to the `WebEngine` instance managed by it. The `WebEngine` instance
    loads the web page asynchronously by submitting the task of loading the page to
    `javafx.concurrent.Worker` instances. Then, we register change listeners on these
    worker instance properties to track the progress of loading the web page. We have
    made use of two such properties in this recipe, namely, `stateProperty` and `workDoneProperty`.
    The former tracks the change of the state of the worker, and the latter tracks
    the percentage of work done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A worker can go through the following states (as listed in the `javafx.concurrent.Worker.State`
    enum):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CANCELLED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAILED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNNING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCHEDULED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUCCEEDED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we are only checking for `SUCCEEDED`, but you can enhance it
    to check for `FAILED` as well. This will help us report invalid URLs or even get
    the message from the event object and show it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we add the listeners to track the change in the properties is by using
    the `addListener()` method on `*Property()`, where `*` can be `state`, `workDone`,
    or any other attribute of the worker that has been exposed as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `javafx.scene.web.WebEngine` component also supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Reloading the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the history of the pages loaded by it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to JavaScript properties, such as showing an alert box or confirmation
    box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the document model of the web page using the `getDocument()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we also looked at using `WebHistory` obtained from `WebEngine`.
    `WebHistory` stores the web pages loaded by the given `WebEngine` instance, which
    means one `WebEngine` instance will have one `WebHistory` instance. `WebHistory`
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the list of entries by using the `getEntries()` method. This will also
    get us the number of entries in the history. This is required while navigating
    forward and backward in history; otherwise, we will end up with an index out of
    bounds exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting `currentIndex`, that is, its index within the `getEntries()` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to the specific entry in the entries list of `WebHistory`. This can
    be achieved by using the `go()` method, which accepts an offset. This offset indicates
    which web page to load, relative to the current position. For example, *+1* indicates
    the next entry and *-1* indicates the previous entry. It's important to check
    for the boundary conditions; otherwise, you will end up with going before *0*,
    that is, *-1*, or going past the entry list size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we showed you a basic approach to creating a web browser using
    the support provided by JavaFX. You can enhance this to support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Better error handling and user messages, that is, to show whether the web address
    is valid or not by tracking the state change of the worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bookmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the state of the browser locally so that the next time it is run, it
    loads all the bookmarks and history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding media in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaFX provides a component, `javafx.scene.media.MediaView`, for viewing videos
    and listening to audios. This component is backed by a media engine, `javafx.scene.media.MediaPlayer`,
    which loads and manages the playback of the media.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at playing a sample video and controlling its playback
    by using the methods on the media engine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of the sample video available at `chp9/11_embed_audio_video/sample_video1.mp4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `javafx.scene.media.Media` object for the video located at `chp9/11_embed_audio_video/sample_video1.mp4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new media engine,  `javafx.scene.media.MediaPlayer`, using the `javafx.scene.media.Media`
    object created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s track the status of the media player by registering a change listener
    on `statusProperty` of the `javafx.scene.media.MediaPlayer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a media viewer using the media engine created in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'We will restrict the width and height of the media viewer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create three buttons to pause the video playback, resume the playback,
    and stop the playback. We will make use of the relevant methods in the `javafx.scene.media.MediaPlayer`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Align all these buttons horizontally using `javafx.scene.layout.HBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Align the media viewer and the buttons bar vertically using `javafx.scene.layout.VBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new scene graph using the `VBox` object as the root and set it to
    the stage object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the stage on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/11_embed_audio_video`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/11_embed_audio_video`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db0582c-1ac0-4783-b57c-c1e36cea43b1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important classes, in the `javafx.scene.media` package for media playback
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Media`: This represents the source of the media, that is, either the video
    or audio. This accepts the source in the form of HTTP/HTTPS/FILE and JAR URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaPlayer`: This manages the playback of the media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaView`: This is the UI component that allows viewing the media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few other classes, but we haven''t covered them in this recipe.
    The media-related classes are in the `javafx.media` module. So, do not forget
    to require a dependency on it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we have a sample video at `chp9/11_embed_audio_video/sample_video1.mp4`,
    and we make use of the `java.io.File` API to build `File` URL to locate the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The media playback is managed by using the API exposed by the `javafx.scene.media.MediaPlayer`
    class. In this recipe, we made use of a few of its methods, namely `play()`, `pause()`,
    and `stop()`. The `javafx.scene.media.MediaPlayer` class is initialized by using
    the `javafx.scene.media.Media` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the media on the UI is managed by the  `javafx.scene.media.MediaView` class,
    and it is backed by a `javafx.scene.media.MediaPlayer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: We can set the height and width of the viewer by using the `setFitWidth()` and
    `setFitHeight()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We gave a basic demo of media support in JavaFX. There's a lot more to explore.
    You can add volume control options, options to seek forward or backward, playing
    of audios, and audio equalizer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding effects to controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding effects in a controlled way gives a good appearance to the user interface.
    There are multiple effects like blurring, shadows, reflection, blooming, and so
    on. JavaFX provides a set of classes under the `javafx.scene.effects` package,
    which can be used to add effects to enhance the look of the application. This
    package is available in the `javafx.graphics` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at a few effects: blur, shadow, and reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The subsequent code will be written within the `start(Stage stage)` method.
    Create and configure `javafx.scene.layout.GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Create rectangles required for applying the blur effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `javafx.scene.effect.BoxBlur` to `Rectangle r1`, `javafx.scene.effect.MotionBlur`
    to `Rectangle r2`, and `javafx.scene.effect.GaussianBlur` to `Rectangle r3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the rectangles to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three circles, required for applying shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `javafx.scene.effect.DropShadow` to `c1` and `javafx.scene.effect.InnerShadow`
    to `c2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these circles to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a simple text, `Reflection Sample`, on which we will apply the reflection
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `javafx.scene.effect.Reflection` effect and add it to the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the text component to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph using `gridPane` as the root node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the scene graph to the stage and render it on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `chp9/12_effects_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `chp9/12_effects_demo`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d460b18c-fdd4-462a-ab25-842b8a9c556a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we have made use of the following effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.BoxBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.MotionBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.GaussianBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.DropShadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.InnerShadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.Reflection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BoxBlur` effect is created by specifying the width and height of the blur
    effect, and also the number of times the effect needs to be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MotionBlur` effect is created by providing the angle of the blur and its
    radius. This gives an effect of something captured while in motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GaussianBlur` effect is created by providing the radius of the effect,
    and the effect uses the Gaussian formula to apply the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DropShadow` adds the shadow behind the object whereas `InnerShadow` adds
    the shadow within the object. Each of these takes the radius of the shadow, the
    *x* and *y* location of the start of shadow, and the color of the shadow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '`Reflection` is a pretty simple effect, which adds the reflection of the object.
    We can set the fraction of how much of the original object is reflected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are quite a few more effects:'
  prefs: []
  type: TYPE_NORMAL
- en: The blend effect, which blends two different inputs with a predefined blending
    approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bloom effect, which makes the brighter portions appear brighter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The glow effect, which makes the object glow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting effect, which simulates a light source on the object thereby giving
    it a 3D appearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would recommend you to try out these effects in the same way as we have tried
    them out.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new TIFF I/O API to read TIFF images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tagged Image File Format** (**TIFF**) is a common image format for exchanging
    images between applications. Previously, JDK didn''t have any support for reading
    TIFF images, and developers had to use the Java Image API, which was external
    to JDK.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to read a TIFF image file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a sample TIFF image file at the location, `chp9/13_tiff_reader/sample.tif`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Get the image readers by format name, which is `tiff` for TIFF images
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the first `ImageReader` object from the image readers obtained in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `FileImageInputStream` object for the `sample.tif` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the reader obtained to read the image file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get some attributes, such as the number of images, width, and height,
    just to confirm that we have really read the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this can be found at `chp9/13_tiff_reader`. You can run
    the sample either by using `run.bat` or `run.sh`.
  prefs: []
  type: TYPE_NORMAL
