<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Improving Application Performance Using Caching Patterns</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we have seen how Spring works in the backend to access data for the application. We also saw how the Spring JDBC Module provides the <kbd>JdbcTemplate</kbd> helper class for database access. Spring provides support for integration with ORM solutions such as Hibernate, JPA, JDO, and so on, and manages transactions across application. Now, in this chapter, we will see how Spring provides caching support to improve application performance.</p>
<p>Do you ever face a volley of questions from your wife when you return home very late in the night from your office? Yes, I know it is very irritating to answer so many questions when you are tired and exhausted. It is even more irritating when you're asked the same questions over and over again..</p>
<p>Some questions can be answered with a <em>Yes</em> or <em>No</em>, but for some questions, you have to explain in detail. Consider what will happen if you are asked another lengthy question again after some time! Similarly, there are some stateless components in an application, where the components have been designed in such a way that they ask the same questions over and over again to complete each task individually. Similar to some questions asked by your wife, some questions in the system take a while to fetch the appropriate data--it may have some major complex logic behind it, or maybe, it has to fetch data from the database, or call a remote service.</p>
<p>If we know that the answer of a question is not likely to change frequently, we can remember the answer to that question for later when it is asked again by the same system. It doesn't make sense to go through the same channel to fetch it again, as it will impact your application's performance, and will be a wasteful use of your resources. In an enterprise application, caching is a way to store those frequently needed answers so that we fetch from the cache instead of going through the proper channel to get the answer for the same question over and over again. In this chapter, we will discuss Spring's Cache Abstraction feature, and how Spring declaratively supports caching implementation. It will cover the following points:</p>
<ul>
<li>What is a cache?</li>
<li>Where do we do this caching?</li>
<li>Understanding the cache abstraction</li>
<li>Enabling caching via the Proxy pattern</li>
<li>Declarative Annotation-based caching</li>
<li>Declarative XML-based caching</li>
<li>Configuring the cache storage</li>
<li>Implementing custom cache annotations</li>
<li>Caching best practices</li>
</ul>
<p>Let's begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is cache?</h1>
                </header>
            
            <article>
                
<p>In very simple terms, <strong>cache</strong> is a memory block where we store preprocessed information for the application. In this context, a key-value storage, such as a map, may be a cache in the application. In Spring, cache is an interface to abstract and represent caching. A cache interface provides some methods for placing objects into a cache storage, it can retrieve from the cache storage for given key, it can update the object in the cache storage for a given key, it remove the object from the cache storage for a given key. This cache interface provides many functions to operate with cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Where do we use caching?</h1>
                </header>
            
            <article>
                
<p>We use caching in cases where a method always returns the same result for the same argument(s). This method could do anything such as calculate data on the fly, execute a database query, and request data via RMI, JMS, and a web-service, and so on. A unique key must be generated from the arguments. That's the cache key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding cache abstraction</h1>
                </header>
            
            <article>
                
<p>Basically, caching in Java applications is applied to the Java methods to reduce the number of executions for the same information available in the cache. That means, whenever these Java methods are invoked, the cache abstraction applies the cache behavior to these methods based on the given arguments. If the information for the given argument is already available in the cache, then it is returned without having to execute the target method. If the required information is not available in the cache, then the <kbd>target</kbd> method is executed, and the result is cached and returned to the caller. Cache abstraction also provides other cache-related operations such as updating and/or removing the contents in the cache. These operations are useful when the data changes in the application sometimes.</p>
<p>Spring Framework provides cache abstraction for Spring applications by using the <kbd>org.springframework.cache.Cache</kbd> and <kbd>org.springframework.cache.CacheManager</kbd> interfaces. Caching requires the use of an actual storage to store the cache data. But cache abstraction only provides caching logic. It doesn't provide any physical storage to store the cached data. So, developers need to implement the actual storage for caching in the application. If you have a distributed application, then you will need to configure your cache provider accordingly. It depends on the use cases of your application. You can either make a copy of the same data across nodes for a distributed application, or you can make a centralized cache.</p>
<p>There are several cache providers in the market, which you could use as per as your application requirement. Some of them are as follows:</p>
<ul>
<li>Redis</li>
<li><kbd>OrmLiteCacheClient</kbd></li>
<li><kbd>Memcached</kbd></li>
<li>In Memory Cache</li>
<li>Aws DynamoDB Cache Client</li>
<li>Azure Cache Client</li>
</ul>
<p>To implement cache abstraction in your application, you have to take care of the following tasks:</p>
<ul>
<li><strong>Caching declaration</strong>: This means that you have to recognize those methods in the application that need to be cached, and annotate these methods either with caching annotations, or you can use XML configuration by using Spring AOP</li>
<li><strong>Cache configuration</strong>: This means that you have to configure the actual storage for the cached data--the storage where the data is stored and read from</li>
</ul>
<p>Let's now see how we can enable Spring's cache abstraction in a Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling caching via the Proxy pattern</h1>
                </header>
            
            <article>
                
<p>You can enable Spring's cache abstraction in the following two ways:</p>
<ul>
<li>Using Annotation</li>
<li>Using the XML namespace</li>
</ul>
<p>Spring transparently applies caching to the methods of Spring beans by using AOP. Spring applies proxy around the Spring beans where you declare the methods that need to be cached. This proxy adds the dynamic behavior of caching to the Spring beans. The following diagram illustrates the caching behavior:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="210" width="460" class=" image-border" src="assets/0cec6f6f-6fd1-4c05-a024-8fe76afe0cd8.png"/></div>
<p>In the preceding diagram, you can see that Spring applies <strong>Proxy</strong> to the <strong>AccountServiceImpl</strong> class to add the caching behavior. Spring uses the GoF proxy pattern to implement caching in the application.</p>
<p>Let's look at how to enable this feature in a Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the caching proxy using Annotation</h1>
                </header>
            
            <article>
                
<p>As you already know, Spring provides lots of features, but they are, mostly, disabled. You must enable these feature before using it. If you want to use Spring's cache abstraction in your application, you have to enable this feature. If you are using Java configuration, you can enable cache abstraction of Spring by adding the <kbd>@EnableCaching</kbd> annotation to one of your configuration classes. The following configuration class shows the <kbd>@EnableCaching</kbd> annotation:</p>
<pre>    package com.packt.patterninspring.chapter9.bankapp.config; 
 
    import org.springframework.cache.CacheManager; 
    import org.springframework.cache.annotation.EnableCaching; 
    import org.springframework.cache.concurrent.<br/>      ConcurrentMapCacheManager; 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
 
    @Configuration 
    @ComponentScan(basePackages=   <br/>    {"com.packt.patterninspring.chapter9.bankapp"}) 
    @EnableCaching //Enable caching 
    public class AppConfig { 
    
     @Bean 
     public AccountService accountService() { ... } 
 
     //Declare a cache manager 
     @Bean 
     public CacheManager cacheManager() { 
         CacheManager cacheManager = new ConcurrentMapCacheManager(); 
         return cacheManager; 
    } 
   } </pre>
<p>In the preceding Java configuration file, we added the <kbd>@EnableCaching</kbd> annotation to the configuration class <kbd>AppConfig.java</kbd>; this annotation indicates to the Spring Framework to enable Spring cache behavior for the application.</p>
<p>Let's now look at how to enable Spring's cache abstraction by using XML configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the Caching Proxy using the XML namespace</h1>
                </header>
            
            <article>
                
<p>If you're configuring your application with XML, you can enable annotation-driven caching with the <kbd>&lt;cache:annotation-driven&gt;</kbd> element from Spring's cache namespace, as follows:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
      
      
      
      
      
      
     xsi:schemaLocation="http://www.springframework.org/schema/jdbc <br/>     http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd 
     http://www.springframework.org/schema/cache   <br/>     http://www.springframework.org/schema/cache/spring-cache-4.3.xsd 
     http://www.springframework.org/schema/beans     <br/>     http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/context    <br/>     http://www.springframework.org/schema/context/spring-context.xsd 
     http://www.springframework.org/schema/aop <br/>     http://www.springframework.org/schema/aop/spring-aop-4.3.xsd 
     http://www.springframework.org/schema/tx <br/>     http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt; 
     
     &lt;!-- Enable caching --&gt; 
     &lt;cache:annotation-driven /&gt; 
     
     &lt;context:component-scan base-   <br/>     package="com.packt.patterninspring.chapter9.bankapp"/&gt; 
      
     &lt;!-- Declare a cache manager --&gt; 
     &lt;bean id="cacheManager" <br/>     class="org.springframework.cache.concurrent.<br/>     ConcurrentMapCacheManager" /&gt; 
   &lt;/beans&gt; 
 </pre>
<p>As seen in the preceding configuration files, whether you use Java configuration or XML configuration, the annotation <kbd>@EnableCaching</kbd> and namespace <kbd>&lt;cache:annotation-driven&gt;</kbd> enables Spring's cache abstraction by creating an aspect with pointcuts that trigger off of Spring's caching annotations.</p>
<p>Let's see how to use Spring's caching annotations to define cache boundaries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declarative Annotation-based caching</h1>
                </header>
            
            <article>
                
<p>In Spring applications, Spring's abstraction provides the following Annotations for caching declaration:</p>
<ul>
<li><kbd>@Cacheable</kbd>: This indicates that before execution of the actual method, look at the return value of that method in the cache. If the value is available, return this cached value, if the value is not available, then invoke the actual method, and put the returned value into the cache.</li>
<li><kbd>@CachePut</kbd>: This updates the cache without checking if the value is available or not. It always invokes the actual method.</li>
<li><kbd>@CacheEvict</kbd>: This is responsible for triggering cache eviction.</li>
<li><kbd>@Caching</kbd>: This is used for grouping multiple annotations to be applied on a method at once.</li>
<li><kbd>@CacheConfig</kbd>: This indicates to Spring to share some common cache-related settings at the class level.</li>
</ul>
<p>Let us now take a closer look at each annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Cacheable annotation</h1>
                </header>
            
            <article>
                
<p><kbd>@Cacheable</kbd> marks a method for caching. Its result is stored in a cache. For all subsequent invocations of that method with the same arguments, it will fetch data from the cache using a key. The method will not be executed. The following are the <kbd>@Cacheable</kbd> attributes:</p>
<ul>
<li><strong>value</strong>: This is the name of cache to use</li>
<li><strong>key</strong>: This is the key for each cached data item</li>
<li><strong>condition</strong>: This is a SpEL expression to evaluate true or false; if it is false, then the result of caching is not applied to the method call</li>
<li><strong>unless</strong>: This too is a SpEL expression; if it is true, it prevents the return value from being put in the cache</li>
</ul>
<p>You can use SpEL and argument(s) of method. Let's look at the following code for the simplest declaration of the <kbd>@Cacheable</kbd> annotation. It requires the name of the cache associated with that method. Please refer to the following code:</p>
<pre>    @Cacheable("accountCache ") 
    public Account findAccount(Long accountId) {...} </pre>
<p>In the preceding code, the <span><kbd>findAccount</kbd></span> method is annotated with the <kbd>@Cacheable</kbd> annotation. This means that this method is associated with a cache. The name of the cache is <strong>accountCache</strong>. Whenever this method is called for a particular <kbd>accountId</kbd>, the cache is checked for the return value of this method for the given <kbd>accountId</kbd>. You can also give multiple names to the cache as shown next:</p>
<pre>    @Cacheable({"accountCache ", "saving-accounts"}) 
    public Account findAccount(Long accountId) {...} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @CachePut annotation</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the <kbd>@Cacheable</kbd> and <kbd>@CachePut</kbd> annotations both have the same goal, that is, to populate a cache. But their working is slightly different from each other. <kbd>@CachePut</kbd> marks a method for caching, and its result is stored in a cache. For each invocation of that method with the same arguments, it always invokes the actual method without checking whether the return value of that method is available in the cache or not. The following are <kbd>@CachePut</kbd> attributes:</p>
<ul>
<li><strong>value</strong>: This is the name of the cache to use</li>
<li><strong>key</strong>: This is the key for each cached data item</li>
<li><strong>condition</strong>: This is a SpEL expression to evaluate true or false; if false, then the result of caching is not applied to the method call</li>
<li><strong>unless</strong>: This is also a SpEL expression; if it is true, it prevents the return value from being put in the cache</li>
</ul>
<p>You can also use SpEL and argument(s) of method for the <kbd>@CachePut</kbd> annotation. The following code is the simplest declaration of the <kbd>@CachePut</kbd> annotation:</p>
<pre>    @CachePut("accountCache ") 
    public Account save(Account account) {...} </pre>
<p>In the preceding code, when <kbd>save()</kbd> is invoked, it saves the <kbd>Account</kbd>. Then the returned Account is placed in the <kbd>accountCache</kbd> cache.</p>
<p>As mentioned earlier, the cache is populated by the method based on the argument of the method. It is actually a default cache key. In case of the <kbd>@Cachable</kbd> annotation, the <kbd>findAccount(Long accountId)</kbd> method has <kbd>accountId</kbd> as an argument, the <kbd>accountId</kbd> is used as the cache key for this method. But in case of the <kbd>@CachePut</kbd> annotation, the only parameter of <kbd>save()</kbd> is an Account. It is used as the cache key. It doesn't seem fine to use <kbd>Account</kbd> as a cache key. In this case, you need the cache key to be the ID of the newly saved Account and not the Account itself. So, you need to customize the key generation behavior. Let's see how you can customize the cache key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing the cache key</h1>
                </header>
            
            <article>
                
<p>You can customize the cache key by using a key attribute of <kbd>@Cacheable</kbd> and the <kbd>@CachePut</kbd> annotation. The cache key is derived by a SpEL expression using properties of the object as highlighted key attribute in the following snippet of code. Let's look at the following examples:</p>
<pre>    @Cacheable(cacheNames=" accountCache ", key="#accountId") 
    public Account findAccount(Long accountId) 
 
    @Cacheable(cacheNames=" accountCache ", key="#account.accountId") 
    public Account findAccount(Account account) 
 
    @CachePut(value=" accountCache ", key="#account.accountId") 
    Account save(Account account); </pre>
<p>You can see in the preceding code snippets how we have created the cache key by using the key attribute of the <kbd>@Cacheable</kbd> annotation.</p>
<p>Let's see another attribute of these annotations in a Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional caching</h1>
                </header>
            
            <article>
                
<p>Spring's caching annotations allow you to turn off caching for some cases by using the condition attribute of <kbd>@Cacheable</kbd> and <kbd>@CachePut</kbd> annotations. These are given a SpEL expression to evaluate the conditional value. If the value of the conditional expression is true, the method is cached. If the value of the conditional expression is false, the method is not cached, but is executed every time without performing any caching operations no matter what values in the cache or what arguments are used. Let's see an example. The following method will be cached only if the passed argument has a value greater than or equal to <kbd>2000</kbd>:</p>
<pre>    @Cacheable(cacheNames="accountCache", condition="#accountId &gt;=   <br/>    2000") 
    public Account findAccount(Long accountId); </pre>
<p>There is a one more attribute of the <kbd>@Cacheable</kbd> and <kbd>@CachePut</kbd> annotations-- <kbd>unless</kbd>. This is also given a SpEL expression. This attribute may seem the same as the condition attribute but there is some difference between them. Unlike condition, the <kbd>unless</kbd> expressions are evaluated after the method has been called. It prevents the value from being placed in the cache. Let's see the following example--We only want to cache when the bank name does not contain HDFC:</p>
<pre>    @Cacheable(cacheNames="accountCache", condition="#accountId &gt;= <br/>    2000", unless="#result.bankName.contains('HDFC')") 
    public Account findAccount(Long accountId); </pre>
<p>As you can see in the preceding code snippet, we have used both attributes--<kbd>condition</kbd> and <kbd>unless</kbd>. But the <kbd>unless</kbd> attribute has a SpEL expression as <kbd>#result.bankName.contains('HDFC')</kbd>. In this expression, the result is a SpEL extension or cache SpEL metadata. The following is a list of the caching metadata that is available in SpEL:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Expression</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.methodName</kbd></p>
</td>
<td>
<p>The name of the cached method</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.method</kbd></p>
</td>
<td>
<p>The cached method, that is, the method being invoked</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.target</kbd></p>
</td>
<td>
<p>It evaluates the target object being invoked</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.targetClass</kbd></p>
</td>
<td>
<p>It evaluates the class of the target object being invoked</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.caches</kbd></p>
</td>
<td>
<p>An array of caches against which the current method is executed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#root.args</kbd></p>
</td>
<td>
<p>An array of the arguments passed into the cached method</p>
</td>
</tr>
<tr>
<td>
<p><kbd>#result</kbd></p>
</td>
<td>
<p>The return value from the cached method; only available in unless expressions for <kbd>@CachePut</kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">Spring's <kbd>@CachePut</kbd> and <kbd>@Cacheable</kbd> annotations should never be used on the same method, because they have different behaviors. The <kbd>@CachePut</kbd> annotation forces the execution of the cache method in order to update the caches. But the <kbd>@Cacheable</kbd> annotation executes the cached method only if the return value of the method is not available on the cache.</div>
<p>You have seen how to add information to the cache by using Spring's <kbd>@CachePut</kbd> and <kbd>@Cacheable</kbd> annotations in a Spring application. But how can we remove that information from the cache? Spring's cache abstraction provides another annotation for removing cached data from the cache--the <kbd>@CacheEvict</kbd> annotation. Let's see how to remove the cached data from the cache by using the <kbd>@CacheEvict</kbd> annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @CacheEvict annotation</h1>
                </header>
            
            <article>
                
<p>Spring's cache abstraction not only allows populating caches, but also allows removing the cached data from the cache. There is a stage in the application where you have to remove stale or unused data from the cache. In that case, you can use the <kbd>@CacheEvict</kbd> annotation, because it doesn't add anything to the cache unlike the <kbd>@Cacheable</kbd> annotation. The <kbd>@CacheEvict</kbd> annotation is used only to perform cache eviction. Let's see how this annotation makes the <kbd>remove()</kbd> method of <kbd>AccountRepository</kbd> as a cache eviction:</p>
<pre>    @CacheEvict("accountCache ") 
    void remove(Long accountId); </pre>
<p>As you can see in the preceding code snippet, the value associated with the argument, <kbd>accountId</kbd>, is removed from the <kbd>accountCache</kbd> cache when the <kbd>remove()</kbd> method is invoked. The following are <kbd>@Cacheable</kbd> attributes:</p>
<ul>
<li><strong>value</strong>: This is an array of names of the cache to use</li>
<li><strong>key</strong>: This is a SpEL expression to evaluate the cache key to be used</li>
<li><strong>condition</strong>: This is a SpEL expression to evaluate true or false; if it is false, then the result of caching is not being applied to the method call</li>
<li><strong>allEntries</strong>: This implies that if the value of this attribute is true, all entries will be removed from the caches</li>
<li><strong>beforeInvocation</strong>: This means that if the value of this attribute is true, the entries are removed from the cache before the method is invoked, and if the value of this attribute is false (the default), the entries are removed after a successful method invocation</li>
</ul>
<div class="packt_infobox">We can use the <kbd>@CacheEvict</kbd> annotation on any method, even a <kbd>void</kbd> one, because it only removes the value from the cache. But in case of the <kbd>@Cacheable</kbd> and <kbd>@CachePut</kbd> annotations, we have to use a non-void return value method, because these annotations require a result to be cached.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @Caching annotation</h1>
                </header>
            
            <article>
                
<p>Spring's cache abstraction allows you to use multiple annotations of the same type for caching a method by using the <kbd>@Caching</kbd> annotation in a Spring application. The <kbd>@Caching</kbd> annotation groups other annotations such as <kbd>@Cacheable</kbd>, <kbd>@CachePut</kbd>, and <kbd>@CacheEvict</kbd> for the same method. For example:</p>
<pre>    @Caching(evict = {  
      @CacheEvict("accountCache "),  
      @CacheEvict(value="account-list", key="#account.accountId") }) 
      public List&lt;Account&gt; findAllAccount(){ 
      return (List&lt;Account&gt;) accountRepository.findAll(); 
   } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The @CacheConfig annotation</h1>
                </header>
            
            <article>
                
<p>Spring's cache abstraction allows you to annotate <kbd>@CacheConfig</kbd> at the class level to avoid repeated mentioning in each method. In some cases, applying customizations of the caches to all methods can be quite tedious. Here, you can use the <kbd>@CacheConfig</kbd> annotation to all operations of the class. For example:</p>
<pre>     @CacheConfig("accountCache ") 
     public class AccountServiceImpl implements AccountService { 
 
      @Cacheable 
      public Account findAccount(Long accountId) { 
        return (Account) accountRepository.findOne(accountId); 
      } 
    } </pre>
<p>You can see in the preceding code snippet that the <kbd>@CacheConfig</kbd> annotation is used at the class level, and it allows you to share the <kbd>accountCache</kbd> cache with all the <kbd>cacheable</kbd> methods.</p>
<div class="packt_infobox">Since Spring's cache abstraction module uses proxies, you should use the cache annotations only with public visibility methods. In all non-public methods, these annotations do not raise any error, but non-public methods annotated with these annotations do not show any caching behaviors.</div>
<p>We have already seen that Spring also offers XML namespace to configure and implement cache in a Spring application. Let's see how in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declarative XML-based caching</h1>
                </header>
            
            <article>
                
<p>To keep your configuration codes of caching separate from business codes, and to maintain loose coupling between the Spring-specific annotations and your source code, XML-based caching configuration is much more elegant than the annotation-based one. So, to configure Spring cache with XML, let's use the cache namespace along with the AOP namespace, because caching is an AOP activity, and it uses the Proxy pattern behind the declarative caching behavior.</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
      
      
      
      
     xsi:schemaLocation="http://www.springframework.org/schema/cache  <br/>     http://www.springframework.org/schema/cache/spring-cache-4.3.xsd 
     http://www.springframework.org/schema/beans<br/>     http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/context<br/>     http://www.springframework.org/schema/context/spring-context.xsd 
     http://www.springframework.org/schema/aop<br/>     http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt; 
    
     &lt;!-- Enable caching --&gt; 
     &lt;cache:annotation-driven /&gt; 
    
     &lt;!-- Declare a cache manager --&gt; 
     &lt;bean id="cacheManager"class="org.springframework.cache.<br/>     concurrent.ConcurrentMapCacheManager" /&gt; 
    &lt;/beans&gt; </pre>
<p>You can see in the preceding XML file that we have included the <kbd>cache</kbd> and <kbd>aop</kbd> namespaces. The cache namespace defines the caching configurations by using the following elements:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>XML element</strong></p>
</td>
<td>
<p><strong>Caching Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:annotation-driven&gt;</kbd></p>
</td>
<td>
<p>It is equivalent to <kbd>@EnableCaching</kbd> in Java configuration, and is used to enable the caching behavior of Spring.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:advice&gt;</kbd></p>
</td>
<td>
<p>It defines caching advice</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:caching&gt;</kbd></p>
</td>
<td>
<p>It is equivalent to the <kbd>@Caching</kbd> annotation, and is used to group a set of caching rules within the caching advice</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:cacheable&gt;</kbd></p>
</td>
<td>
<p>It is equivalent to the <kbd>@Cacheable</kbd> annotation; it makes any method cacheable</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:cache-put&gt;</kbd></p>
</td>
<td>
<p>It is equivalent to the <kbd>@CachePut</kbd> annotation, and is used to populate a cache</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;cache:cache-evict&gt;</kbd></p>
</td>
<td>
<p>It is equivalent to the <kbd>@CacheEvict</kbd> annotation, and is used for cache eviction.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Let's see the following example based on XML-based configuration.</p>
<p>Create a configuration file, <kbd>spring.xml</kbd> as follows<strong>:</strong></p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
     
     
     
     
    xsi:schemaLocation="http://www.springframework.org/schema/cache <br/>    http://www.springframework.org/schema/cache/spring-cache-4.3.xsd 
    http://www.springframework.org/schema/beans<br/>    http://www.springframework.org/schema/beans/spring-beans.xsd 
    http://www.springframework.org/schema/context<br/>    http://www.springframework.org/schema/context/spring-context.xsd 
    http://www.springframework.org/schema/aop<br/>    http://www.springframework.org/schema/aop/spring-aop-4.3.xsd"&gt; 
    
   &lt;context:component-scan base- <br/>    package="com.packt.patterninspring.chapter9.bankapp.service, <br/>    com.packt.patterninspring.chapter9.bankapp.repository"/&gt; 
 
    &lt;aop:config&gt; 
    &lt;aop:advisor advice-ref="cacheAccount" pointcut="execution(*<br/>    com.packt.patterninspring.chapter9.bankapp.service.*.*(..))"/&gt; 
   &lt;/aop:config&gt; 
    
   &lt;cache:advice id="cacheAccount"&gt; 
     &lt;cache:caching&gt; 
       &lt;cache:cacheable cache="accountCache" method="findOne" /&gt; 
         &lt;cache:cache-put cache="accountCache" method="save" <br/>          key="#result.id" /&gt; 
         &lt;cache:cache-evict cache="accountCache" method="remove" /&gt; 
         &lt;/cache:caching&gt; 
      &lt;/cache:advice&gt; 
 
   &lt;!-- Declare a cache manager --&gt; 
   &lt;bean id="cacheManager" class="org.springframework.cache.concurrent.<br/>    ConcurrentMapCacheManager" /&gt; 
   &lt;/beans&gt; </pre>
<p>In the preceding XML configuration file, the highlighted code is the Spring cache configuration. In the cache configuration, the first thing that you see is the declared <kbd>&lt;aop:config&gt;</kbd> then <kbd>&lt;aop:advisor&gt;</kbd>, which have references to the advice whose ID is <kbd>cacheAccount</kbd>, and also has a pointcut expression to match the advice. The advice is declared with the <kbd>&lt;cache:advice&gt;</kbd> element. This element can have many <kbd>&lt;cache:caching&gt;</kbd> elements. But, in our example, we have only one <kbd>&lt;cache:caching&gt;</kbd> element, which has a <kbd>&lt;cache:cacheable&gt;</kbd> element, a <kbd>&lt;cache:cache-put&gt;</kbd>, and one <kbd>&lt;cache:cache-evict&gt;</kbd> element; each declare a method from the pointcut as being cacheable.</p>
<p>Let's see the <kbd>Service</kbd> class of the application with cache annotations:</p>
<pre>    package com.packt.patterninspring.chapter9.bankapp.service; 
 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.cache.annotation.CacheEvict; 
    import org.springframework.cache.annotation.CachePut; 
    import org.springframework.cache.annotation.Cacheable; 
    import org.springframework.stereotype.Service; 
 
    import com.packt.patterninspring.chapter9.bankapp.model.Account; 
    import com.packt.patterninspring.chapter9.<br/>    bankapp.repository.AccountRepository; 
 
    @Service 
    public class AccountServiceImpl implements AccountService{ 
    
    @Autowired 
    AccountRepository accountRepository; 
 
    @Override 
    @Cacheable("accountCache") 
    public Account findOne(Long id) { 
      System.out.println("findOne called"); 
      return accountRepository.findAccountById(id); 
    } 
 
    @Override 
    @CachePut("accountCache") 
    public Long save(Account account) { 
      return accountRepository.save(account); 
    } 
 
    @Override 
    @CacheEvict("accountCache") 
    public void remove(Long id) { 
      accountRepository.findAccountById(id); 
    } 
    
   } </pre>
<p>In the preceding file definition, we have used Spring's cache annotations to create the cache in the application. Now let's see how to configure the cache storage in an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the cache storage</h1>
                </header>
            
            <article>
                
<p>Spring's cache abstraction provides a lot of storage integration. Spring provides <kbd>CacheManager</kbd> for each memory storage. You can just configure <kbd>CacheManager</kbd> with the application. Then the <kbd>CacheManager</kbd> is responsible for controlling and managing the Caches. Let's explore how to set up the <kbd>CacheManager</kbd> in an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the CacheManager</h1>
                </header>
            
            <article>
                
<p>You must specify a cache manager in the application for storage, and some cache provider given to the <kbd>CacheManager</kbd>, or you can write your own <kbd>CacheManager</kbd>. Spring provides several cache managers in the <kbd>org.springframework.cache</kbd> package, for example, <kbd>ConcurrentMapCacheManager</kbd>, which creates a <kbd>ConcurrentHashMap</kbd> for each cache storage unit.</p>
<pre>    @Bean 
    public CacheManager cacheManager() { 
      CacheManager cacheManager = new ConcurrentMapCacheManager(); 
      return cacheManager; 
    }</pre>
<p><kbd>SimpleCacheManager</kbd>, <kbd>ConcurrentMapCacheManager</kbd>, and others are cache managers of the Spring Framework's cache abstraction. But Spring provides support for integration with third-party cache managers, as we will see in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Third-party cache implementations</h1>
                </header>
            
            <article>
                
<p>Spring's <kbd>SimpleCacheManager</kbd> is ok for testing, but has no cache control options (overflow, eviction). So we have to use third-party alternatives like the following:</p>
<ul>
<li>Terracotta's EhCache</li>
<li>Google's Guava and Caffeine</li>
<li>Pivotal's Gemfire</li>
</ul>
<p>Let's see one of the configurations of third-party cache managers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ehcache-based cache</h1>
                </header>
            
            <article>
                
<p><strong>Ehcache</strong> is one of the most popular cache providers. Spring allows you to integrate with Ehcache by configuring <kbd>EhCacheCacheManager</kbd> in the application. Take for example, the following Java configuration:</p>
<pre>    @Bean 
    public CacheManager cacheManager(CacheManager ehCache) { 
      EhCacheCacheManager cmgr = new EhCacheCacheManager(); 
      cmgr.setCacheManager(ehCache); 
      return cmgr; 
    } 
    @Bean  
    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() { 
      EhCacheManagerFactoryBean eh = new EhCacheManagerFactoryBean(); 
      eh.setConfigLocation(new  <br/>      ClassPathResource("resources/ehcache.xml")); 
      return eh; 
    } </pre>
<p>In the preceding code, the bean method, <kbd>cacheManager()</kbd>, creates an object of <kbd>EhCacheCacheManager</kbd>, and set it with the <kbd>CacheManager</kbd> of Ehcache. Here, Ehcache's <kbd>CacheManager</kbd> is injected into Spring's <kbd>EhCacheCacheManager</kbd>. The second bean method, <kbd>ehCacheManagerFactoryBean()</kbd>, creates and returns an instance of <kbd>EhCacheManagerFactoryBean</kbd>. Because it's a Factory bean, it will return an instance of <kbd>CacheManager</kbd>. An XML file, <kbd>ehcache.xml</kbd>, has the Ehcache configuration. Let's refer to the following code for <kbd>ehcache.xml</kbd>:</p>
<pre>    &lt;ehcache&gt; 
       &lt;cache name="accountCache" maxBytesLocalHeap="50m"<br/>        timeToLiveSeconds="100"&gt; 
       &lt;/cache&gt; 
    &lt;/ehcache&gt; </pre>
<p>The contents of the <kbd>ehcache.xml</kbd> file vary from application to application, but you need to declare, at least, a minimal cache. For example, the following Ehcache configuration declares a cache named <strong>accountCache</strong> with 50 MB of maximum heap storage and a time-to-live of 100 seconds:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML-based configuration</h1>
                </header>
            
            <article>
                
<p>Let's create XML based configuration for the Eache, and it is configuring here <kbd>EhCacheCacheManager</kbd>. Please refer to the following code:</p>
<pre><span>    &lt;bean id="cacheManager"</span>    <br/>     class="org.springframework.cache.ehcache.EhCacheCacheManager" <br/>     p:cache-manager-ref="ehcache"/&gt; 
 
    &lt;!-- EhCache library setup --&gt; 
    &lt;bean id="ehcache" 
      class="org.springframework.cache.ehcache.<br/>      EhCacheManagerFactoryBean" p:config-<br/>      location="resources/ehcache.xml"/&gt; </pre>
<p>Similarly, in case of the XML configuration, you have to configure the cache manager for ehcache, configure the <kbd>EhCacheManagerFactoryBean</kbd> class, and set the config-location value with <kbd>ehcache.xml</kbd>, which has the Ehcache configuration as defined in the previous section.</p>
<p>There are many more third-party caching storages which have integration support with the Spring Framework. In this chapter, I have discussed only the ECache manager.</p>
<p>In the following section, we'll discuss how Spring allows you to create your own custom annotation for caching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom caching annotations</h1>
                </header>
            
            <article>
                
<p>Spring's cache abstraction allows you to create custom caching annotations for your application to recognize the cache method for the cache population or cache eviction. Spring's <kbd>@Cacheable</kbd> and <kbd>@CacheEvict</kbd> annotations are used as Meta annotations to create custom cache annotation. Let's see the following code for custom annotations in an application:</p>
<pre>    @Retention(RetentionPolicy.RUNTIME) 
    @Target({ElementType.METHOD}) 
    @Cacheable(value="accountCache", key="#account.id") 
    public @interface SlowService { 
    } </pre>
<p>In the preceding code snippet, we have defined a custom annotation named as <kbd>SlowService</kbd>, which is annotated with Spring's <kbd>@Cacheable</kbd> annotation. If we use <kbd>@Cacheable</kbd> in the application, then we have to configure it as the following code:</p>
<pre>    @Cacheable(value="accountCache", key="#account.id") 
    public Account findAccount(Long accountId) </pre>
<p>Let's replace the preceding configuration with our defined custom annotation, with the following code:</p>
<pre>    @SlowService 
    public Account findAccount(Long accountId) </pre>
<p>As you can see, we use only the <kbd>@SlowService</kbd> annotation to make a method cacheable in the application.</p>
<p>Now let's move on to the next section, where we'll see which are the best practices we should consider at the time of cache implementation in anapplication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Top caching best practices to be used in a web application</h1>
                </header>
            
            <article>
                
<p>In your enterprise web application, proper use of caching enables the web page to be rendered very fast, minimizes the database hits, and reduces the consumption of the server's resources such as memory, network, and so on. Caching is a very powerful technique to boost your application's performance by storing stale data in the cache memory. The following are the best practices which should be considered at the time of design and development of a web application:</p>
<ul>
<li>In your Spring web application, Spring's cache annotations such as <kbd>@Cacheable</kbd>, <kbd>@CachePut</kbd>, and <kbd>@CacheEvict</kbd> should be used on concrete classes instead of application interfaces. However, you can annotate the interface method as well, using interface-based proxies. Remember that Java annotations are not inherited from interfaces, which means that if you are using class-based proxies by setting the attribute <kbd>proxy-target-class="true"</kbd>, then Spring cache annotations are not recognized by the proxying.</li>
<li>If you have annotated any method with the <kbd>@Cacheable</kbd>, @CachePut, or <kbd>@CacheEvict</kbd> annotations, then never call it directly by another method of the same class if you want to benefit from the cache in the application. This is because in direct calling of a cached method, the Spring AOP proxy is never applied.</li>
<li>In an enterprise application, Java Maps or any key/value collections should never be used as a Cache. Any key/value collection cannot be a Cache. Sometimes, developers use java map as a custom caching solution, but it is not a caching solution, because Cache provides more than a key/value storage, like the following:
<ul>
<li>Cache provides eviction policies</li>
<li>You can set the max size limit of Cache</li>
<li>Cache provides a persistent store</li>
<li>Cache provides weak reference keys</li>
<li>Cache provides statistics
<ul>
<li>The Spring Framework provides the best declarative approach to implement and configure the Cache solution in an application. So, always use the cache abstraction layer--it provides flexibility in the application. We know that the <kbd>@Cacheable</kbd> annotation allows you to separate business logic code from the caching cross-cutting concern.</li>
<li>Be careful whenever you use cache in the application. Always use cache in a place where it is actually required such as a web service or an expensive database call, because every caching API has an overhead.</li>
<li>At the time of cache implementation in an application, you have to ensure that the data in the cache is in sync with the data storage. You can use distributed cache managers like Memcached for proper cache strategy implementation to provide considerable performance.</li>
<li>You should use cache only as second option if data fetching is very difficult from the database because of slow database queries. It is because, whenever we use caching behavior in the application, first the value is checked in the cache if not available then it execute actual method, so it would be unnecessary.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In this chapter, we saw how caching helps to improve the performance of anapplication. Caching mostly works on the service layer of the application. In your application, there is a data returned by a method; we can cache that data if the application code calls it over and over again from the same requirement. Caching is a great way to avoid execution of the application method for the same requirements. The return value of the method for a specific parameter is stored in a cache whenever this method is invoked for the first time. For further calls of the same method for same parameter, the value is retrieved from that cache. Caching improves application performance by avoiding some resource and time consuming operations for same answers like performing a database query.</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Spring provides Cache Manager to manage caching in a Spring application. In this chapter, you have seen how to define the caching manager for a particular caching technology. Spring provides some annotations for caching such as <kbd>@Cacheable</kbd>, <kbd>@CachePut</kbd><em>,</em> and <kbd>@CacheEvict</kbd>, which we can use in our Spring application. We can also configure caching in the Spring application by using the XML configuration. Spring framework provides cache namespace to achieve this. The <kbd>&lt;cache:cacheable&gt;</kbd>, <kbd>&lt;cache:cache-put&gt;</kbd>, and <kbd>&lt;cache:cache-evict&gt;</kbd> elements are used instead of the corresponding annotations.</p>
<p>Spring makes it possible to manage caching in anapplication by using Aspect-Oriented Programming. Caching is a cross-cutting concern for the Spring Framework. That means, caching is as an aspect in the Spring application. Spring implements caching by using around advice of the Spring AOP module.</p>
<p>In the next <a href="ef5eac66-9b41-4959-8155-96f002137409.xhtml">Chapter 10</a><em>, Implementing MVC Pattern in a Web Application using Spring</em>, we will explore how Spring we can use in the web layer and with the MVC pattern.</p>


            </article>

            
        </section>
    </body></html>