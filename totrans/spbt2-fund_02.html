<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a Spring Application</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you will learn how to interact with Spring Beans and how to configure your Spring context. This is the foundation that every Spring application is built on.</p>
<p class="mce-root">In the previous chapter, you learnt about how to create a Spring Boot project, the basic building blocks and the application context were also introduced. Lastly, you saw how to utilize Lombok to free you from creating or writing the same code over and over again.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Organize dependencies between Spring Beans</li>
<li>Create configuration classes to define Beans by hand</li>
<li>Organize Configuration Properties</li>
<li>Create strongly typed Property Classes</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency Injection in Spring</h1>
                </header>
            
            <article>
                
<p>In this section, you will see how Spring Beans can depend on each other to provide functionality. The Spring Container uses the Beans in the context to inject dependencies into other managed instances. This enables you to write concise classes that just express their dependencies, and Spring takes care of the rest.</p>
<p>There is a singleton with a <kbd>HashMap</kbd> and dedicated factories that create and wire up instances. Additionally, there are base classes that inspect the class and utilize some kind of singleton to look up other instances.</p>
<p><strong>Aspect-oriented programming</strong> (to intercept missing dependencies), <kbd>classpath</kbd> scanning (to find available dependencies and injection points), and Inversion of Control (to have control over the application lifecycle).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Autowiring</h1>
                </header>
            
            <article>
                
<p>Dependency Injection, which is the pattern to introduce the Inversion of Control for resolving dependencies, is called <strong>Autowiring</strong> in Spring. When Bean-A gets a reference for Bean-B injected, it is <strong>autowired</strong>. Autowiring only works for Spring Beans, so both need to be known to the <strong>Spring Application Context</strong>.</p>
<p>Take a look at the sample code below:</p>
<pre>@Repository<br/>public class ExampleBean {<br/>   @Autowired<br/>   private DataSource dataSource;<br/>...<br/>}</pre>
<p>This example code defines a Bean that requires the JDBC DataSource to query the database. As you can see, the field does not need to be public – it can even be private. Spring achieves this by using reflection, which is a standard Java feature. It allows you to create classes that have a very limited public interface, which makes it easier to communicate the intent of a class with code.</p>
<div class="packt_infobox"><br/>
You might know JavaEE annotations such as <kbd>@Inject</kbd>. <kbd>@Autowired</kbd> is the corresponding annotation in Spring. Spring aims to be developer-friendly, so <kbd>@Inject</kbd> also works in Spring applications. However, the parameters differ, so you should stick to plain Spring annotations if there is no special need to use the JavaEE versions.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Injection Types</h1>
                </header>
            
            <article>
                
<p>In Spring, you have a couple of ways to get access to Beans that are in the context. You have already seen <strong>Field Injection</strong>, which has been used to autowire the <kbd>DataSource</kbd>, but there are more ways to get Beans injected.</p>
<p>You can use Autowiring in:</p>
<ul>
<li>Fields</li>
<li>Properties</li>
<li>Config Methods</li>
<li>Constructors</li>
</ul>
<div class="packt_infobox"><br/>
When Spring has completely resolved the dependencies of a Bean, it looks for a method that is annotated with <kbd>PostConstruct</kbd> and executes it. There, you can perform some final initialization, which will utilize all defined dependencies.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Field Injection</h1>
                </header>
            
            <article>
                
<p>Field injection is the simplest way to get hold of another Bean. Just annotate the field with <kbd>@Autowired</kbd> and the instance will be there after the Bean's creation.</p>
<div class="packt_infobox"><kbd>TestBase</kbd> and <kbd>TestClass</kbd> are at <a href="https://bit.ly/2RSCHrf">https://bit.ly/2RSCHrf</a>, in the <kbd>blogmaniaexercise-solution</kbd> project folder. When you start the test, you will see that the instance information for <kbd>MyConfiguration</kbd> is printed twice, although one is defined in the abstract base class. This helps to group shared functionality in base classes.<br/>
Go to <a href="https://bit.ly/2Mp9kcZ">https://bit.ly/2Mp9kcZ</a> to access the code for the <kbd>TestBase.java</kbd> file. Go to <a href="https://bit.ly/2CNj6WG">https://bit.ly/2CNj6WG</a> to access the code for the <kbd>TestClass.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Property Injection</h1>
                </header>
            
            <article>
                
<p>You can add <kbd>@Autowired</kbd> for setters as well. This will trigger the so-called <strong>Config Method</strong> mechanism. Spring will call the method when the dependencies are available after the constructor has been called.</p>
<div class="packt_infobox"><br/>
A property usually means that you have a field that follows the Java Bean Standard. For example, a property of type String named <kbd>foo</kbd> will have <kbd>setFoo(String …)</kbd> and String <kbd>getFoo()</kbd> methods. There are also read-only and write-only properties, where one of these is missing. <kbd>boolean</kbd> fields have a Getter starting with <kbd>is</kbd>, so <kbd>isFoo()</kbd> would be the correct name in this case.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Config Method Injection</h1>
                </header>
            
            <article>
                
<p>Spring is able to call a method after the instance has been created and the constructor has been executed. This method can have any number of parameters which should be resolvable with Beans from the Spring Context. The method should return void; the name is arbitrary and the method does not have to be public.</p>
<p>You can have more than one of these and they will be executed in an undefined order.</p>
<p>As you can see, this fully covers property injection as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Constructor Injection</h1>
                </header>
            
            <article>
                
<p>Constructor injection is the way to inject Beans that is preferred by the Spring Framework team. You just create a constructor with all the required Beans as parameters and then you assign these values to your fields if required. You might also do something else with the provided dependencies, such as calling a method on it to fetch some data, for example. So, you do not have to store the value somewhere if you don't need it after the constructor is finished. If you have multiple constructors that have parameters, then you need to qualify one constructor by adding the <kbd>@Autowired</kbd> annotation to it. Otherwise, this can be omitted.</p>
<p>As you may recall, we use Project Lombok to avoid unnecessary code. This can be used here as well. Just add <kbd>AllArgsConstructor</kbd> or <kbd>@RequiredArgsConstructor</kbd> to your class and Spring will automatically use this generated constructor. You do not need to create one yourself or even add <kbd>@Autowired</kbd> anywhere.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Circular Dependencies</h1>
                </header>
            
            <article>
                
<p>When you have two or more Spring Beans that form a dependency circle, Spring might have a problem creating the Spring context when you use Constructor Injection everywhere.</p>
<p>Example Dependencies:</p>
<p>Bean-A =&gt; Bean-B =&gt; Bean-C =&gt; Bean-A</p>
<p>Spring has no chance to solve this when all Beans use constructor injection, because the instances cannot be instantiated without the others.</p>
<p class="mce-root"/>
<p>There are ways to work around that, but first you should reconsider if this is really the right solution; most circular dependencies are a symptom of bad design. If there is no way around it, you can configure Spring to solve that by doing the following:</p>
<ul>
<li>Creating a dynamic proxy:
<ol>
<li>For this, you need to change at least one of the constructors (it cannot be generated by Lombok).</li>
<li>Then, you can mark the constructor parameter by adding <kbd>@Lazy</kbd> to the type, which tells Spring that this dependency is not needed during class creation when the Spring Context is built.</li>
<li>Spring will create a proxy around the instance which is working as a facade in front of the real instance which is fetched from the context when it's accessed for the first time.</li>
</ol>
</li>
<li>Use Field-/Config-Method-Injection for the first class: When you use these injection styles, Spring can defer the resolution of the Bean until the other dependencies are met. You can see the first class in the error message that Spring prints out during startup.</li>
</ul>
<div class="packt_infobox"><br/>
To mark the dependency as "<kbd>lazy</kbd>", you just place the <kbd>@Lazy annotation</kbd> before or after the type.</div>
<p style="padding-left: 60px">Take a look at the following sample code:</p>
<pre style="padding-left: 60px">public BlogRepository(@Lazy List&lt;BlogEntry&gt; db) {...</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qualify Beans</h1>
                </header>
            
            <article>
                
<div class="packt_infobox"><br/>
If you have multiple Beans with the same type, then Spring won't be able to detect which instance should be assigned. In this case, the application will refuse to start and present an error message that explains what is going wrong.</div>
<p>By default, Spring will try to match the name of the parameter/field with the names of the Beans of the corresponding type, but if you need a specific Bean and the name does not match, you can just add an annotation to resolve that manually.</p>
<p>For example, you can use the following code to fetch the <kbd>myDate</kbd> Bean from the context:</p>
<pre>@Qualifier("theDate")<br/>private LocalDateTime contextStartTime;</pre>
<div class="packt_infobox"><br/>
You can access the Application Context directly and fetch a Bean by type or name from there if necessary. You can implement the <kbd>ApplicationContextAware</kbd> interface and Spring will provide a reference to the Application Context for you. This should only be used in rare cases, as most of the time, the "static wiring" should be sufficient.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bean Scopes</h1>
                </header>
            
            <article>
                
<p>By now, you have seen how you can define Spring Beans, and you saw that one instance is usually created when the application starts. But there are other use cases where this is not the right choice.</p>
<p>To specify a scope, just add the <kbd>@Scope</kbd> annotation to the Bean definition:</p>
<pre>@Repository @Scope(SCOPE_SINGLETON)<br/>public class BlogRepository {</pre>
<p>The default scope of a Bean is <kbd>singleton</kbd>, which means there is one instance of the Bean in the container and this is returned by the Spring Context. The scope reference itself is just a String.</p>
<p>The second standard scope is <kbd>prototype</kbd>, which returns a new instance whenever a Bean with that name is requested from the Context. So, if you define Bean-A with the prototype scope and Bean-C and Bean-D have an autowired field for Bean-A, then both will get their own instance. This is handy when the Bean has some kind of state that should not be shared with other Beans, such as caches, for example.</p>
<p>There are also other scopes such as <kbd>request</kbd> and <kbd>session</kbd>, which are specific to Spring WebMVC and will be covered later. You can even define your own scopes, but this is an advanced section that we won't cover in this book.</p>
<p>Spring provides static constants for the scopes in a few places. The regular scopes are defined in the <kbd>ConfigurableBeanFactory</kbd> class, while the web application-specific scopes are defined in <kbd>WebApplicationContext</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration Classes</h1>
                </header>
            
            <article>
                
<p>You have seen how to declare Spring Beans by annotating the class definition. This is the most common use case, but sometimes you need more control during the creation of a Bean. This is where configuration classes come into play. They are basically classes with factory methods for Beans. This can be used to create Beans of classes that are defined outside of your code base or, for example, to return a specific implementation of an interface depending on some configuration values.</p>
<p>Configuration classes are Spring Beans too, so you can use autowired dependencies here as well, but constructor injection should be avoided.</p>
<p>This is what a configuration class looks like:</p>
<pre>@Configuration<br/>public class MyConfiguration {<br/>   @Bean<br/>   public Date theDate(){<br/>      return new Date();<br/>   }<br/>…<br/>}</pre>
<div class="packt_infobox"><br/>
The <kbd>MyConfiguration</kbd> class in the provided source code for this section contains even more Beans with their corresponding JavaDoc.</div>
<p class="mce-root">The default behavior for configuration classes is to return the correct instance from the Spring Context. So, when you autowire a configuration class somewhere and call a method that is annotated with <kbd>@Bean</kbd>, the method may not be executed and the result from the Spring Context is returned instead. This is even true when you call a <kbd>@Bean</kbd> method from within the same Configuration. Using configuration classes as dependencies in "regular" Beans is technically possible, but not commonly done. Most projects use dedicated Factory Beans for a single type or a set of types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Bean Interdependencies</h1>
                </header>
            
            <article>
                
<p>The aim is to utilize Bean interdependencies to relay data to the repository. </p>
<p>The steps for completion are as follows:</p>
<ol>
<li>Open the IDE and the <kbd>BlogMania</kbd> application (<a href="https://bit.ly/2QpUDd1">https://bit.ly/2QpUDd1</a>) for this section.</li>
<li>Move the <kbd>BlogService</kbd> and <kbd>BlogRepository</kbd> to the <kbd>com.packt.springboot.blogmania.blogentries.service</kbd> package.</li>
</ol>
<p style="padding-left: 60px"> Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/79d60584-3e5c-4022-8137-cb0578776b1d.png" style="width:30.33em;height:20.67em;" width="878" height="598"/></div>
<div class="packt_infobox"><span><br/></span><span>Right-click on the blogentries package and create the new package from there. Then, drag and drop the classes into the package. </span></div>
<div>
<p><span>You have now created your own Spring Bean and used it in a business context in order to solve the task and save the data in memory. </span>Take a look at the output screenshot, as shown below:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/04552a82-45fc-4fe7-a55d-4e76e66d4033.png" width="1211" height="457"/></div>
</div>
<div class="packt_infobox"><br/>
<span>Go to </span><a href="https://bit.ly/2OeUPtQ">https://bit.ly/2OeUPtQ</a><span> to access the code for the </span><kbd>BlogmaniaApplicationTests.java</kbd><span> file.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration of Spring Boot Applications</h1>
                </header>
            
            <article>
                
<p>In the previous section, you saw how to connect Spring Beans and which mechanism you can use to achieve that.</p>
<p>When you write your application, you will encounter aspects of your application that need to be configurable. If you use a database, you will have different database configurations; maybe features that are enabled or disabled, or something like that.</p>
<p>In a Spring Boot application, you don't need to handle this yourself. Spring Boot has a very sophisticated system in place to configure your application with ease, even in complex scenarios.</p>
<p>In this section, you will create profiles to target different environments and configure the application with property and <strong>YAML</strong> (<strong>YAML Ain't Markup Language</strong>) files. You also will see the search order for properties in action with which you can configure your Spring Beans in multiple ways.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Profiles</h1>
                </header>
            
            <article>
                
<p>Spring applications have a simple mechanism to tell your application that it runs in different environments or modes. The application has "Active Profiles", which can influence how the application is configured or behaves. The profiles are ordered lists of words. Each of these words is a profile. If none is given, it is a default.</p>
<p>For example, you can start the application with the additional command-line parameter <kbd>--spring.profiles.active=peter</kbd>,<kbd>dev</kbd>,<kbd>postgres</kbd>. As you can see, each profile is separated by a comma.</p>
<p>This means that the profiles <kbd>peter</kbd>, <kbd>dev</kbd>, and <kbd>postgres</kbd> are active. In the following slides, you will see what you can do with these profiles.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Conditional Beans</h1>
                </header>
            
            <article>
                
<p>When you need to enable or disable certain Beans when a profile is active, you can use a simple annotation at the Bean definition. This can either be a configuration class, the annotated class definition, or the <kbd>@Bean</kbd> annotated methods.</p>
<p>For this, you just need to add the <kbd>@Profile</kbd> annotation at the class or method definition. The following code snippet is copied from the <kbd>MyConfiguration</kbd> class (<a href="https://bit.ly/2oYUl05">https://bit.ly/2oYUl05</a>) and configures the <kbd>theConfiguredDate</kbd> Bean, which is a fixed point in time in dev mode (maybe for tests) and the current date and time when the dev profile is not set. Due to the fact that we can't have both methods named the same, we used a feature of the <kbd>@Bean</kbd> annotation to override the default name of the bean with <kbd>theConfiguredDate</kbd>:</p>
<pre>@Profile("dev")<br/>@Bean("theConfiguredDate")<br/>public Instant theConfiguredFixedDate(){<br/>   return Instant.ofEpochMilli(1527854742);<br/>}<br/><br/>@Profile("!dev")<br/>@Bean<br/>public Instant theConfiguredDate(){<br/>   return Instant.now();<br/>}</pre>
<p>The <kbd>@Profile</kbd> annotations can also take a list of profiles, which in this case is any of the given profiles that are sufficient enough to trigger the Bean's creation. This means that the profiles are evaluated with an implicit <kbd>or</kbd>, not an <kbd>and</kbd>.</p>
<p><strong>Example</strong></p>
<pre>@Profile("dev", "profile2", "profile3")</pre>
<p>There is also a <kbd>@Primary</kbd> annotation on a Bean definition, which can be used to mark a Bean as a default Bean for a given type. This is used when there are multiple Beans that would match the type. To select one of the other Beans, you would need to add the <kbd>@Qualifier</kbd> annotation with the correct Bean name.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Conditional Beans for Various Implementations</h1>
                </header>
            
            <article>
                
<p>The aim is to utilize conditional Spring Beans, which can be used, for example, to switch (or select) between different implementations. Before beginning, please reuse the existing project. Go to <a href="https://bit.ly/2oYUl05">https://bit.ly/2oYUl05</a> to access the code for the blogmania directory.</p>
<p>The steps for completion are as follows:</p>
<ol>
<li>Create an interface called <strong>Randomizer</strong> with a method that returns a double and has no parameters.</li>
</ol>
<p style="padding-left: 60px">  Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/584bbe21-3d77-4358-9b75-ef186fcf3c22.png" style="width:35.67em;height:13.83em;" width="1048" height="406"/></div>
<ol start="2">
<li>Create an implementation that returns a random number using the <kbd>nextDouble()</kbd> method of the <kbd>Random</kbd> class and make it a Bean.</li>
<li>Create an implementation that always returns, for example, <kbd>3</kbd>. Make this a <span>Bean that is active when the test profile is active. It should replace or override</span> <span>the other Bean.</span></li>
</ol>
<p><span>You have seen how you can override a Bean for tests, which helps you to write concise and reliable tests. Take a look at the output screenshot, as shown below:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d341628a-2060-46bd-9bff-3a8fe198f390.png" width="1209" height="581"/></div>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2x8v1s5">https://bit.ly/2x8v1s5</a> to access the code for the <kbd>BlogmaniaApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Configuration Files</h1>
                </header>
            
            <article>
                
<p>Spring Boot applications are created by the Spring Initializr by default with an empty <kbd>application.properties</kbd> file in the resource folder. This is the default configuration file. You can write all default configurations there in the property file format, which we will see in more detail soon.</p>
<p>Next to the <kbd>application.properties</kbd> file, you can place more configuration files that are loaded based on active profiles.</p>
<p>You can create an <kbd>application-dev.properties</kbd> file there and it will only be loaded when the dev profile is active. We will cover the order in which property values are applied in a dedicated section soon.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Property Files</h1>
                </header>
            
            <article>
                
<p>Property files are very common in the Java ecosystem and are even older than the now commonly disliked XML files.</p>
<p>The format is simple:</p>
<ul>
<li>Values are stored in a <kbd>Key=value</kbd> fashion where the key usually consists of lower case dot-separated words, and the value following the <kbd>=</kbd> may contain blanks. Multiline values need to have a <kbd>\</kbd> at the end of the line that is continued in the next line.</li>
<li>Comment lines start with a <kbd>#</kbd> and are ignored by the parser.</li>
<li>You can have empty lines.</li>
</ul>
<p>Using the mechanism with the profile-based files, you can set or override values.</p>
<p>An example configuration looks like this:</p>
<pre>spring.datasource.driverClassName=com.mysql.jdbc.Driver<br/>spring.datasource.url=jdbc:mysql://localhost/test<br/>server.port=9000</pre>
<div class="packt_infobox"><br/>
Property files should always be encoded in ISO-8859-1, otherwise you will end up with weird results. It may work in tests but breaks when you start the application or vice-versa.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">YAML Files</h1>
                </header>
            
            <article>
                
<p><strong>YAML</strong> (<strong>YAML Ain't Markup Language</strong>) files are another syntax to create configuration files in Spring Boot.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The format is basically defined by the following:</p>
<ul>
<li>Values are stored in a <kbd>key: value</kbd> fashion.</li>
<li>YAML supports <kbd>subkeys</kbd> which are simply indented. Keys on the same level are grouped together until the next key is less indented.</li>
<li>Lists are supported by using a subgroup where each line starts with a dash.</li>
<li>Comments start with a <kbd>#</kbd>.</li>
</ul>
<p>The property example as YAML looks like this:</p>
<pre>spring.datasource:<br/>driverClassName: com.mysql.jdbc.Driver<br/>   url: jdbc:mysql://localhost/test<br/>server.port: 9000</pre>
<p>You can see that the dot still works as a group separator, but if you have multiple keys with the same parent groups, you can use this shorter version. This is especially handy with the deep key structure of the Spring configuration values.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multi-Profile YAML Files</h1>
                </header>
            
            <article>
                
<p>Using YAML files, you can use a special format to define values that are only active in a given profile.</p>
<p>To do this, you use three dashes followed by the <kbd>spring.profile</kbd> key with the profile that this block is supposed to be active in. Here, you can even use the negated syntax to set values when a profile is not set:</p>
<pre>server:<br/>   port: 9001<br/>my.value: dev<br/><br/>---<br/>spring:<br/>   profiles: dev<br/>my.value: dev<br/><br/>---<br/>spring:<br/>   profiles: production<br/>server:<br/>   port: 0</pre>
<p>This advanced mechanism is specified in the YAML standard, but some YAML validators may mark this as a no longer valid YAML file. The parsers cut the YAML files at the dashes and handle them internally as different (virtual) files. If you have static lint checkers on your source code, they might complain about this syntax.</p>
<div class="packt_infobox"><br/>
A <strong>lint checker</strong> is a program that checks files for syntax errors or common mistakes. There are lint checkers available for many file types and programming languages.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External Configuration Locations</h1>
                </header>
            
            <article>
                
<p>The files that we have discussed are located in the classpath, but you might have the need to have some host- or environment-specific configuration that you don't want to check into version control. For example, your security department will not be pleased when production database credentials are hosted in the widely accessible Git repository.</p>
<p>The Spring documentation lists 17 different ways of how configuration values can be set or overwritten. We will omit a few of the advanced ways for brevity, but if you want to see them all, please visit <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html</a>.</p>
<p>Whenever Spring looks up a configuration value, it searches this list for the value. As soon as the value is found, the search stops.</p>
<p>The following files that are outside the JAR are searched for in the current working directory by default:</p>
<ul>
<li>Command-line arguments</li>
<li>Properties from <kbd>SPRING_APPLICATION_JSON</kbd> (inline JSON embedded in an environment variable or system property)</li>
<li>Java System properties (set using <kbd>-Dmy.config.key=value</kbd>)</li>
<li>OS environment variables (often used with Docker containers)</li>
<li>Profile-specific application properties outside of your packaged JAR (<kbd>application-{profile}.properties</kbd> and <kbd>YAML variants</kbd>)</li>
<li>Profile-specific application properties packaged inside your JAR (<kbd>application-{profile}.properties</kbd> and <kbd>YAML variants</kbd>)</li>
<li>Application properties outside of your packaged JAR (<kbd>application.properties</kbd> and <kbd>YAML variants</kbd>)</li>
<li>Application properties packaged inside your JAR (<kbd>application.properties</kbd> and <kbd>YAML variants</kbd>)</li>
<li><kbd>@PropertySource</kbd> annotations on your <kbd>@Configuration</kbd> classes (used to load additional property files, but no YAML!)</li>
</ul>
<p>It is a bit surprising that the files loaded via <kbd>@PropertySource</kbd> are evaluated last, but the rest is very sensible and enables you to package default values with your application and override them for the concrete instance that is running on a host or in a container.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Placeholders in Configuration Files</h1>
                </header>
            
            <article>
                
<p>Within a configuration file, you can use a very simple variable replacement mechanism which is evaluated when the configuration values are all loaded, so even when the replacement refers to a value that is defined in the same file, it still can be overridden, for example, by a profile or system property. The mechanism works for property and YAML files:</p>
<pre>server.port: 9000<br/>spring:<br/>   application:<br/>         name: MyApplication<br/>info:<br/>   description: ${spring.application.name} is so nice</pre>
<p>This will set the description of the application to whatever is set as <kbd>spring. application.name</kbd> plus is so nice. The syntax looks a lot like <strong>SpEL</strong> (<strong>Spring Expression Language</strong>), but is limited to simple variable replacement. SpEL will be briefly covered soon.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing Environment Values</h1>
                </header>
            
            <article>
                
<p>We have seen many ways to define configuration values, but we have not used them yet. Spring offers multiple ways to access these values. The oldest way is to let Spring autowire an instance with the <kbd>Environment</kbd> type into your Bean. This offers ways to access configuration values using code.</p>
<p>Take a look at the example code below: (excerpt from <kbd>BlogService.java</kbd>):</p>
<pre>@Autowired<br/>public void init(Environment env) {<br/>   log.info("my.config.value={}",<br/>           env.getProperty("my.config.value",<br/>                   Integer.class, 42));<br/>}</pre>
<div class="packt_infobox"><br/>
The <kbd>log.info(...)</kbd> is provided by Project Lombok's <kbd>@Slf4j</kbd> annotation, which creates a static logger that's configured for the class with the name <kbd>log</kbd> for you.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Annotated Fields</h1>
                </header>
            
            <article>
                
<p>Using the Environment instance directly is a bit cumbersome, so the Spring developers created another annotation called <kbd>@Value</kbd> which is capable of accessing data from the environment and assigning it to a field. The field can be of any type that is supported out of the box such as primitive types or other default Java classes, or you can provide a <kbd>ConversionService</kbd> or <kbd>PropertyEditors</kbd> which are mechanisms that Spring uses to convert data to and from strings. Being able to create your own converters is out of the scope of this book.</p>
<p>Take a look at the example code below: (excerpt from <kbd>BlogService.java</kbd>):</p>
<pre>@Value("${my.config.feature.flag:false}")<br/>boolean featureFlag;</pre>
<p>This loads the value using the key <kbd>my.config.feature.flag</kbd> and converts it to a <kbd>boolean</kbd> value. The value is false by default when the config key is not set. Therefore, the syntax is <kbd>@Value("${KEY:DEFAULT}")</kbd> with the default value and <kbd>@Value("${KEY}")</kbd> without. The default value is the string representation of the default value in the same format that you expect in the config file.</p>
<p>Lists are values that are set with square brackets and comma separated values like <kbd>[1,3,5,7,9];</kbd> which is a list of odd integer values.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Expression Language</h1>
                </header>
            
            <article>
                
<p>The <strong>Spring Expression Language</strong> (<strong>SpEL</strong>) is similar to the Unified EL, which was created for Java Server Pages (JSP) in 2006. It supports querying and manipulating the Spring Context. You can think of it as a lightweight scripting language. The SpEL can be used by your code if you use the <kbd>SpelExpressionParser</kbd>.</p>
<p>SpEL is very powerful, and some of its especially useful features are as follows:</p>
<ul>
<li>Literal expressions</li>
<li>Access to Spring Bean methods and properties</li>
<li>Boolean operations</li>
<li>Call static methods</li>
<li>Filter collections</li>
</ul>
<p>Let's take a look at an example that calls the <kbd>getTimeMessage()</kbd> method on the <kbd>blogService</kbd> Spring Bean. The resultant String will be converted to uppercase afterwards:</p>
<pre>@Value("#{blogService.timeMessage.toUpperCase()}")<br/>String message;</pre>
<p>The <kbd>getTimeMessage()</kbd> method conforms to the Bean standard and represents the <kbd>timeMessage</kbd> property as read-only. This allows us to skip the get prefix.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration Property Classes</h1>
                </header>
            
            <article>
                
<p>As your application grows, you will also have a growing set of configuration options. Using the <kbd>@Value</kbd> annotation, you can access these, but scattering this all over your application may lead to a lot of duplication and maybe even work, for example, when the type, key, or default value changes. Then, you have to update all occurrences, which is not preferable.</p>
<p>To have IDE support for the properties, you need to add this dependency:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;<br/>  &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;</pre>
<p class="mce-root"/>
<p>Now, you can create a Configuration Properties class with the <kbd>@ConfigurationProperties</kbd> annotation. The class itself should have properties to store the data, and you can define default values here if you like:</p>
<pre>@Data<br/>@ConfigurationProperties("blogmania")<br/>public class MyProperties {<br/>   String message;<br/>   int myInt=4;<br/>   SubProperties subs = new SubProperties();<br/><br/>   @Data<br/>   public static class SubProperties{<br/>       boolean iLikePizza=true;<br/>   }<br/>}</pre>
<p>To create the getters and setters, we use Lombok. As you can see, you can also have deeply nested classes to store and segregate your data. The <kbd>@ConfigurationProperties</kbd> annotation should have a parameter that is a path prefix for the properties. With this, you have properties like the following ones:</p>
<pre>blogmania.message<br/>blogmania.my-int<br/>blogmania.subs.i-like-pizza</pre>
<p>For this to work, you have to do two things. First, you must register the classes that are annotated with <kbd>@ConfigurationProperties</kbd> in a configuration class definition, like this:</p>
<pre>@EnableConfigurationProperties({MyProperties.class})</pre>
<p>Make the configuration class a Bean by adding <kbd>@Component</kbd> next to <kbd>@ConfigurationProperties</kbd> or by adding a <kbd>@Bean</kbd> annotated method for it to a configuration class.</p>
<div class="packt_infobox"><br/>
You might have noticed that the <kbd>iLikePizza</kbd> property is now in <strong>kebab-case</strong> in the configuration file. The reason behind this is that this is the recommended way to write properties. Spring supports relaxed binding for <kbd>ConfigurationProperty</kbd> classes, so you could also use <strong>camelCase</strong> or <strong>snake_case</strong>, but this is not recommended, because in certain cases, this can lead to problems.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Examining Autowiring and Configurations</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To create a few classes to practice autowiring and application configuration.</p>
<p><strong>Scenario</strong></p>
<p>You should reuse the project that was used for the previous subsection and open it in the IDE. This is a simplified version of a common task, where you read something from the configuration and apply that to input.</p>
<p>You are going to create a greeting service that uses a configured suffix and a provided input to create a greeting such as <span class="packt_screen">Packt greets the world</span>.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Create the class to read the configuration value for the suffix.</li>
</ol>
<p style="padding-left: 60px"> Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/935dce09-20b9-474a-8244-23e9269d7e2f.png" width="1712" height="530"/></div>
<ol start="2">
<li>Create the greeting service.</li>
<li>Inject the required class in the service.</li>
<li>Create a public method that creates the greeting.</li>
<li>In the Application class, add a config method that executes the greeting <span>method and prints out the result.</span></li>
</ol>
<p><strong>Outcome</strong></p>
<p>The default message should be INPUT+ <span class="packt_screen">greets the world</span> (INPUT is the input with the greeter's name to the greeting method), but the location (<strong>the world</strong>) should be customizable, so you should also be able to create, for example, INPUT+ <span class="packt_screen">greets Berlin</span>. The location should be read using the <kbd>GreetingProperties</kbd>. To trigger this code, use the Application class, autowire the service here, and execute it with sample data.</p>
<p>Take a look at the output screenshot, as shown below:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4c610792-e841-4a13-9d0f-d94ff777f835.png" width="1730" height="904"/></div>
<div class="packt_infobox"><br/>
<span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 250.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have seen how you can inject Spring Beans into other Beans and how you can help Spring in cases where the injector is not uniquely identifiable. You also saw how you can configure your application with profiles and configuration files.</p>
<p>In the next chapter, we will finally start looking at ways we can test our Spring Boot applications.</p>


            </article>

            
        </section>
    </div>



  </body></html>