["```java\nclass Book(val title: String) \nclass Dictionary(name: String) extends Book(name) { \n  // data and behavior \n} \n```", "```java\nclass Book(val title: String) {\n  val chapters = scala.collection.mutable.Set[Chapter]()\n  def addChapter(chapter: Chapter) = chapters.add(chapter)\n  def pages = chapters.foldLeft(0)((b, c) => b + c.noOfPages)\n}\n\ncase class Chapter(name: String, sn: Int, noOfPages: Int)\n\nobject BookApp extends App {\n  val book = new Book(\"The New Book\")\n  book.addChapter(Chapter(\"Chapter1\", 1, 15))\n  book.addChapter(Chapter(\"Chapter2\", 2, 13))\n  book.addChapter(Chapter(\"Chapter3\", 3, 17))\n\n  println(book.title)\n  println(book.pages)\n}\n```", "```java\nclass Book(val title: String){ \n  // data and behaviour for Book \n} \n\nclass Dictionary(name: String) extends Book(name) { \n  // data and behaviour for dictionary \n} \n\nobject BookApp extends App { \n  val dictionary = new Dictionary(\"Collins\") \n  println(dictionary.title) \n} \n```", "```java\nCollins \n```", "```java\nclass Book(val title: String){ \n  def cover(cover: String): String = \"Paperback_\" + cover \n} \n\nclass Dictionary(name: String) extends Book(name){ \n  // wants to define its own version of cover method \n} \n```", "```java\nclass Dictionary(name: String) extends Book(name){ \n  override def cover(cover: String): String = \"Hardcover_\" + cover \n} \n\nobject BookApp extends App { \n  val dictionary = new Dictionary(\"Collins\") \n  println(dictionary.title) \n  println(dictionary.cover(\"The Collins Dictionary\")) \n} \n```", "```java\nCollins \nHardcover_The Collins Dictionary \n```", "```java\nError:(18, 7) overriding method cover in class Book of type (cover: String)String; \n method cover needs `override' modifier \n def cover(cover: String): String = \"Hardcover_\" + cover \n```", "```java\nError:(18, 16) method cover overrides nothing. \nNote: the super classes of class Dictionary contain the following, non-final members named cover: \ndef cover(cover: String): String \noverride def cover(cover: Cover): String = \"Hardcover_\" + cover \n```", "```java\nclass Book(val title: String){ \n  def coverType: String = \"Paperback\" \n  def cover(cover: String): String = coverType + \"_\" + cover \n} \n\nclass Dictionary(name: String) extends Book(name){ \n  override val coverType: String = \"Hardcover\" \n} \n```", "```java\nError:(19, 16) overriding value coverType in class Book of type String; \n method coverType needs to be a stable, immutable value \n  override def coverType: String = \"Hardcover\" \n```", "```java\nclass Book(val title: String){ \n  final val coverType: String = \"Paperback\" \n  def cover(cover: String): String = coverType + \"_\" + cover \n} \n```", "```java\nError:(19, 16) overriding value coverType in class Book of type String; \n value coverType cannot override final member \n override val coverType: String = \"Hardcover\" \n```", "```java\nclass Book(val title: String){ \n  val coverType: String = \"Paperback\" \n  def cover(cover: String): String = coverType + \"_\" + cover \n} \n\nclass Dictionary(name: String) extends Book(name){ \n  override val coverType: String = \"Hardcover\" \n} \n\nclass Encyclopedia(name: String) extends Book(name){ \n  override val coverType: String = \"Blue_Hardcover\" \n} \n\nobject BookApp extends App { \n  val dictionary: Book = new Dictionary(\"Collins\") \n  val encyclopedia: Book = new Encyclopedia (\"Britannica\") \n  val theBoringBook: Book = new Book(\"TheBoringBook\") \n\n  println(s\"${dictionary.title} has cover ${dictionary.cover(\"The Collins Dictionary\")}\") \n  println(s\"${encyclopedia.title} has cover ${encyclopedia.cover(\"Britannica\")}\") \n  println(s\"${theBoringBook.title} has cover ${theBoringBook.cover(\"Some Book\")}\") \n} \n```", "```java\nCollins has cover Hardcover_The Collins Dictionary \nBritannica has cover Blue_Hardcover_Britannica \nTheBoringBook has cover Paperback_Some Book \n```", "```java\nval dictionary: Book = new Dictionary(\"Collins\") \nval encyclopedia: Book = new Encyclopedia (\"Britannica\") \nval theBoringBook: Book = new Book(\"TheBoringBook\") \n```", "```java\nclass CustomStack extends util.ArrayList[String] { \n  def push(value: String) = ??? \n  def pop = ??? \n} \n```", "```java\nimport java.time.LocalDate\n\ncase class Employee(name: String, id: String, contact: String, email: String) \n\ncase class StartUp(name: String, founder: Employee, coFounders: Option[Set[Employee]], members: Option[List[Employee]], foundingDate: Option[LocalDate]) \n```", "```java\ncase class StartUp(name: String, founder: Employee, coFounders: Option[Set[Employee]], members: Option[List[Employee]], foundingDate: Option[LocalDate]){ \n\n  //founder | name \n  def this(name: String, founder: Employee) = this(name, founder, None, None, None) \n\n  //founder | foundingDate \n  def this(name: String, founder: Employee, foundingDate: LocalDate) = this(name, founder, None, None, Some(foundingDate)) \n\n  //founder | coFounders \n  def this(name: String, founder: Employee, coFounders: Set[Employee]) = this(name, founder, Some(coFounders), None, None) \n\n  //founder | coFounders | members \n  def this(name: String, founder: Employee, coFounders: Set[Employee], members: List[Employee]) = this(name, founder, Some(coFounders), Some(members), None) \n\n  //founder | coFounders | foundingDate \n  def this(name: String, founder: Employee, coFounders: Set[Employee], foundingDate: LocalDate) = this(name, founder, Some(coFounders), None, Some(foundingDate)) \n\n  //founder | members    | foundingDate \n  def this(name: String, founder: Employee, members: List[Employee], foundingDate: LocalDate) = this(name, founder, None, Some(members), Some(foundingDate)) \n\n} \n```", "```java\nobject StartUpApp extends App { \n\n  val startUpWithFoundingDate = new StartUp(\"WSup\", Employee(\"Rahul Sharma\", \"RH_ID_1\", \"9090000321\", \"rahul_sharma@abc.com\"), LocalDate.now()) \n\n  println(s\"${startUpWithFoundingDate.name} founded on ${startUpWithFoundingDate.foundingDate.get} by ${startUpWithFoundingDate.founder.name}\") \n\n  val startUp = new StartUp(\"Taken\", Employee(\"David Barbara\", \"DB_ID_1\", \"9090654321\", \"david_b@abc.com\")) \n\n  println(s\"${startUp.name} founded by ${startUp.founder.name}\") \n} \n```", "```java\nWSup founded on Sun Jun 13 20:29:00 IST 2016 by Rahul Sharma \nTaken founded by David Barbara \n```", "```java\nobject StartUpApp extends App { \n\n  val startUp = StartUp(\"Taken\", Employee(\"David Barbara\", \"DB_ID_1\", \"9090654321\", \"david_b@abc.com\")) \n  println(s\"${startUp.name} founded by ${startUp.founder.name}\")\n } \n```", "```java\nError:(30, 24) not enough arguments for method apply: (name: String, founder: chapter7.Employee, coFounders: Option[Set[chapter7.Employee]], members: Option[List[chapter7.Employee]], foundingDate: Option[java.util.Date])chapter7.StartUp in object StartUp. \nUnspecified value parameters coFounders, members, foundingDate. \nval startUp = StartUp(\"Taken\", Employee(\"David Barbara\", \"DB_ID_1\", \"9090654321\", \"david_b@abc.com\"))  \n```", "```java\nobject StartUp { \n\n  def apply(name: String, founder: Employee): StartUp = new StartUp(name, founder, None, None, None) \n} \n```", "```java\nobject StartUpApp extends App { \n\n  val startUp = StartUp(\"Taken\", Employee(\"David Barbara\", \"DB_ID_1\", \"9090654321\", \"david_b@abc.com\")) \n\n  println(s\"${startUp.name} founded by ${startUp.founder.name}\") \n} \n```", "```java\nTaken founded by David Barbara \n```", "```java\ntrait Socialize { \n\n  //people who socialise, greets. \n  def greet(name: String) = \"Hello \" + name\n}\n```", "```java\ncase class Person(val name: String) \n\nobject SocializeApp extends App { \n  val person = Person(\"Victor Mark\") \n  val employee = new Employee(\"David Barbara\") with Socialize \n\n  println(employee.greet(person.name)) \n\n  class Employee(fullName: String) extends Person(fullName) \n} \n```", "```java\nHello Victor Mark \nEmployee class that extends Person in the inheritance hierarchy. While instantiating the Employee object, we're able to extend an employee's characteristic of socializing through a mix-in. Also, we have access to the greet method from our trait. This happened on the go, we didn't specify Employee to have this characteristic statically, but dynamically. When instantiating, we extended the possibilities and characteristics of Employee. That's why traits are powerful. A few points to note about traits are as follows*:*\n```", "```java\npublic interface chapter7.Socialize { \n  public static java.lang.String greet$(chapter7.Socialize, java.lang.String); \n  public java.lang.String greet(java.lang.String); \n  public static void $init$(chapter7.Socialize); \n} \nSocialize trait. The Scala compiler compiles down a trait to its Java counterpart, interface (this happens in Scala version 2.12 and later. In previous versions, traits were also compiled to a set of classes). Here, the greet method is available as a static and a non-static member. It's possible for us to include an abstract, as well as concrete, method of a trait. For example, take a look at the following:\n```", "```java\ntrait Socialize { \n\n  def greet(name: String) = \"Hello \" + name \n\n  val socialNetworks = Set(\"Facebook\", \"LinkedIn\", \"Twitter\", \"Instagram\", \"Youtube\") \n\n  def linkToSocialNetwork(network: String, uri: String) \n} \n\nobject SocializeApp extends App { \n\n  val employee = new Employee(\"David Barbara\") \n  employee.linkToSocialNetwork(\"LinkedIn\", \"www.linkedin.com/profiles/david_b\") \n\n  println(employee.mapOfSocialNetwork) \n\n} \n\nclass Employee(fullName: String) extends Person(fullName) with Socialize { \n\n  var mapOfSocialNetwork = new scala.collection.mutable.HashMap[String, String]() \n\n  override val socialNetworks = Set(\"LinkedIn\", \"Twitter\", \"Youtube\") \n  override def linkToSocialNetwork(network: String, uri: String): Unit = if (socialNetworks contains network) mapOfSocialNetwork.put(network, uri) \n}  \n```", "```java\nMap(LinkedIn -> www.linkedin.com/profiles/david_b) \n```", "```java\ndef linkToSocialNetwork(network: String, uri: String)   \n```", "```java\npackage chapter7 \n\ncase class Amount(amt: Double, currency: String){ \n  override def toString: String = s\"$amt ${currency.toUpperCase}\" \n} \n\nabstract class CreditCard { \n  val ccType = \"Default\" \n  def creditLimit(x: Double) : Amount \n\n  //legacy creditCardNumberGeneratorLogic \n  val ccNum = scala.util.Random.nextInt(1000000000).toString \n\n  //other methods \n} \n\nobject CCApp extends App { \n  val basicCreditCard = new CreditCard { \n    override def creditLimit(x: Double): Amount = Amount(x, \"USD\") \n  } \n\n  val limit = basicCreditCard.creditLimit(1000) \n  println(s\"CreditCardNumber ${basicCreditCard.ccNum} with limit: $limit\") \n} \n```", "```java\nCreditCardNumber 44539599 with limit: 1000.0 USD \n```", "```java\nval basicCreditCard = // Some Credit Card impl \nbasicCreditCard.ccNumber \n```", "```java\ntrait CreditCardOps { \n   self: CreditCard => \n   val ccNumber: String = ccType match { \n     case \"BASIC\" => \"BC\" + ccNum \n     case _ => \"DC\" + ccNum \n   } \n} \n\nobject CCApp extends App { \n  val basicCreditCard = new CreditCard with CreditCardOps { \n    override def creditLimit(x: Double): Amount = Amount(x, \"USD\") \n  } \n\n  val limit = basicCreditCard.creditLimit(1000) \n  println(s\"CreditCardNumber ${basicCreditCard.ccNumber} with limit: $limit\") \n} \n```", "```java\nCreditCardNumber DC896146072 with limit: 1000.0 USD \n```", "```java\nclass DebitCard \nval someDebitCard = new DebitCard with CreditCardOps \n```", "```java\nself: CreditCard => \n```", "```java\ntrait CreditCardOps { \n   self: CreditCard => \n   val ccNumber: String = ccType match { \n     case \"BASIC\" => \"BC\" + ccNum \n     case _ => \"DC\" + ccNum \n   } \n} \n```", "```java\ntrait CreditCardOps { \n\n   self: CreditCard => \n   val ccNumber: String = ccType match { \n     case \"BASIC\" => \"BC\" + ccNum \n     case _ => \"DC\" + ccNum \n   } \n  override val ccNum = ccNumber // will be null \n} \n```", "```java\nnew Service with BasicPackage \n```", "```java\nnew Service with BasicPackage with DiamondPackage \n```", "```java\nabstract class CreditCard { \n  val ccType = \"Default\" \n  def creditLimit(x: Double) : Amount \n\n  //legacy creditCardNumberGeneratorLogic \n  val ccNum = scala.util.Random.nextInt(1000000000).toString \n\n  //other methods} \n```", "```java\nclass BasicCreditCard extends CreditCard { \n  override def creditLimit(x: Double): Amount = Amount(x,\"USD\") \n} \n```", "```java\ntrait GoldSubscription extends CreditCard { \n  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.10) \n} \n\ntrait PlatinumSubscription extends CreditCard { \n  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.25) \n} \n```", "```java\nabstract override def creditLimit(x: Double): Amount = //super call \n```", "```java\nobject CCApp extends App { \n  val basicCreditCard = new BasicCreditCard()       \n  println(basicCreditCard.creditLimit(15000)) \n\n  val goldCreditCard = new BasicCreditCard() with GoldSubscription \n  println(goldCreditCard.creditLimit(15000)) \n\n  val platinumCreditCard = new BasicCreditCard() with PlatinumSubscription \n  println(platinumCreditCard.creditLimit(15000)) \n\n  val gpluspCreditCard = new BasicCreditCard() with GoldSubscription with PlatinumSubscription \n  println(gpluspCreditCard.creditLimit(15000)) \n} \n```", "```java\n15000.0 USD \n16500.0 USD \n18750.0 USD \n20625.0 USD \n```", "```java\ntrait GoldSubscription extends CreditCard { \n  abstract override def creditLimit(x: Double): Amount = super.creditLimit(x * 1.10) \n} \n```", "```java\nval gpluspCreditCard = new BasicCreditCard() with GoldSubscription with PlatinumSubscription \n\nprintln(gpluspCreditCard.creditLimit(15000)) \n             and we got the desired result: 20625.0 USD \n```", "```java\nabstract class Language { \n  def sayHello: String \n} \n\ntrait British extends Language { \n  override def sayHello: String = \"Hello\" \n} \n\ntrait Spanish extends Language { \n  override def sayHello: String = \"Hola\" \n} \n\nclass Socializer extends British with Spanish { \n  override def sayHello: String = super.sayHello \n} \n\nobject Linearization extends App { \n\n  class Person(val name: String) \n\n  val albert = new Person(\"Alberto\") \n  val socializer = new Socializer() \n\n  println(s\"${socializer.sayHello} ${albert.name}\") \n} \n```", "```java\nHola Alberto \n```", "```java\nclass Socializer extends British with Spanish { \n  override def sayHello: String = super.sayHello \n} \n```", "```java\nBritish -> AnyRef -> Any\n```", "```java\nSpanish -> AnyRef -> Any\n```", "```java\nSpanish ->\n```", "```java\nSpanish -> British -> AnyRef -> Any\n```", "```java\nSocializer -> Spanish -> British -> AnyRef -> Any\n```", "```java\nHola Alberto \n```", "```java\npackage country \n\nclass Country(val name: String) { \n  import Country._ \n\n  val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n  def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))\n } \n\nobject Country {\n   def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size \n\n} \n```", "```java\n  import country.Country._ \n```", "```java\nimport country.Country \nimport customutil.Util.averagePopulation \n\npackage country { \n\n  class Country(val name: String) { \n\n    val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))\n   } \n} \n\npackage state { \n\n  class State(val name: String) { \n\n    val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values))\n   } \n\n} \n\npackage customutil { \n  object Util { \n\n    def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size \n\n  } \n} \n```", "```java\nimport country.Country \n\npackage country { \n  import customutil.Util.averagePopulation \n\n  abstract class Region \n\n  class Country(val name: String) extends Region{ \n\n    val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n    def showAveragePopulation() = println(averagePopulation(this.populationsMap.values)) \n\n  } \n\n  package state { \n\n    class State(val name: String) extends Region { \n\n      val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n      def showAveragePopulation() = println(averagePopulation(this.populationsMap.values)) \n    } \n\n  } \n} \n\npackage customutil { \n  object Util { \n\n    def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size \n\n  } \n} \n```", "```java\npackage country \npackage state \n\nclass State(val name: String) extends Region { \n\n  val populationsMap  = scala.collection.mutable.Map[Int, Double]() \n\n  def showAveragePopulation = println(averagePopulation(this.populationsMap.values)) \n} \n```", "```java\nobject CountryApp extends App { \n  import customutil.Util.averagePopulation \n  val aCountry = new Country(\"France\") \n  aCountry.populationsMap.put(2017, 64.94) \n  aCountry.populationsMap.put(2016, 64.66) \n  aCountry.populationsMap.put(2015, 64.395) \n\n  println(averagePopulation(aCountry.populationsMap.values)) \n} \n```", "```java\n64.66499999999999 \n```", "```java\npackage country {\n   abstract class Region\n\n   import customutil.{Util => u}\n\n   class Country(val name: String) extends Region {\n\n     val populationsMap  = scala.collection.mutable.Map[Int, Double]()\n\n     def showAveragePopulation = println(u.averagePopulation(this.populationsMap.values))\n   }\n\n   package state {\n\n     class State(val name: String) extends Region {\n\n       import u.{averagePopulation => ap}\n\n       val populationsMap  = scala.collection.mutable.Map[Int, Double]()\n\n       def showAveragePopulation = println(ap(this.populationsMap.values))\n     }\n\n   }\n }\n\n package customutil {\n   object Util {\n\n     def averagePopulation(populations: Iterable[Double]) = populations.sum / populations.size\n\n   }\n } \n```", "```java\nimport customutil.{Util => u} \n```", "```java\nprintln(u.averagePopulation(this.populationsMap.values)) \n```", "```java\nimport u.{averagePopulation => ap} \n```", "```java\nprintln(ap(this.populationsMap.values)) \n```", "```java\nimport package1.{Member => _} \n```", "```java\npackage restaurant \n\npackage privaterestaurant { \n\n  case class Dish(name: String) \n\n  trait Kitchen { \n    self: PrivateRestaurant => \n\n    private val secret = \"Secret to tasty dish\" //Think of a secret logical evaluation resulting in value, we don't want to expose. \n\n    def cookMyDish: Option[Dish] = Some(Dish(secret)) \n\n  } \n\n  class PrivateRestaurant extends Kitchen { \n\n    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. \n\n    def serveDish = cookMyDish // Works fine \n  } \n\n} \n```", "```java\nprotected val secret = \"Secret to tasty dish\" //Think of a secret logical evaluation resulting in value, we don't want to expose. \n```", "```java\nclass PrivateRestaurant extends Kitchen { \n\n  def serveDishWithSecret = Dish(secret) // Works fine \n  def serveDish = cookMyDish // Works fine \n} \n```", "```java\ncase class Dish(name: String) \n\nclass Restaurant \n\npackage privaterestaurant{\n   trait Kitchen { \n    self: Restaurant => \n\n    private[privaterestaurant]  val secret = \"Secret to tasty dish\" //Think of a secret logical evaluation resulting in value, we don't want to expose. \n\n    def cookMyDish: Option[Dish] = Some(Dish(secret)) \n\n  } \n\n  class  PrivateRestaurant  extends Restaurant with Kitchen  { \n\n    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. \n\n    def serveDish = cookMyDish // Works fine \n  } \n\n} \n\npackage  protectedrestaurant { \n\n  import restaurant.privaterestaurant.Kitchen \n\n  class ProtectedRestaurant extends Restaurant with Kitchen { \n\n    def serveDishWithSecret = Dish(secret) // Symbol secret is inaccessible from this place. \n\n    def serveDish = cookMyDish // Works fine \n  } \n} \n```", "```java\nprivate[privaterestaurant] val secret = \"Secret to tasty dish\" //Think of a secret logical evaluation resulting in value, \n//we don't want to expose \n```", "```java\nprivate[privaterestaurant] val secret  \n```", "```java\nsealed trait Season \n\ncase object Autumn extends Season \ncase object Winter extends Season \ncase object Spring extends Season \ncase object Summer extends Season \ncase object Monsoon extends Season \n\nobject SealedApp extends App { \n  def season(season: Season) = season match { \n    case Autumn => println(s\"It's Autumn :)\") \n    case Winter => println(s\"It's Winter, Xmas time!\") \n    case Spring => println(s\"It's Spring!!\") \n    case Summer => println(s\"It's summer, who likes summer anyway!\") \n    case Monsoon => println(s\"It's Monsoon!!\") \n  } \n  season(Spring) \n} \n```", "```java\nIt's Spring!!\" \n```"]