<html><head></head><body>
<div id="_idContainer010">
<h1 class="hapter-number" id="_idParaDest-14"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">Maintainability</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This book is about software architecture. </span><span class="koboSpan" id="kobo.3.2">One of the </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.4.1">definitions of </span><em class="itali"><span class="koboSpan" id="kobo.5.1">architecture</span></em><span class="koboSpan" id="kobo.6.1"> is </span><em class="itali"><span class="koboSpan" id="kobo.7.1">the structure of a system or process</span></em><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">In our case, it’s the structure of a </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">software system.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Architecture is designing this structure with a purpose. </span><span class="koboSpan" id="kobo.10.2">We’re consciously designing our software system to fulfill certain requirements. </span><span class="koboSpan" id="kobo.10.3">There are functional requirements</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.11.1"> that the software has to fulfill to create value for its users. </span><span class="koboSpan" id="kobo.11.2">Without functionality, software is worthless, because it produces </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">no value.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">There are also</span><a id="_idIndexMarker002"/> <strong class="bold"><span class="koboSpan" id="kobo.14.1">quality requirements</span></strong><span class="koboSpan" id="kobo.15.1"> (also called </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">non-functional requirements</span></strong><span class="koboSpan" id="kobo.17.1">) that the</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.18.1"> software should fulfill to be considered high quality by its users, developers, and stakeholders. </span><span class="koboSpan" id="kobo.18.2">One such quality requirement</span><a id="_idIndexMarker004"/> <span class="No-Break"><span class="koboSpan" id="kobo.19.1">is </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.20.1">maintainability</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">What would you say if I told you that maintainability as a quality attribute, in a way, is more important than functionality and that we should design our software for maintainability over everything else? </span><span class="koboSpan" id="kobo.22.2">Once we have established maintainability as an important quality, we will use the rest of this book to explore how we can improve the maintainability of our software by applying the concepts of Clean and </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Hexagonal Architecture.</span></span></p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.24.1">What does maintainability even mean?</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Before you write me off as a lunatic and start looking for options to return this book, let me explain what I mean </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">by maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Maintainability</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.28.1"> is only one of the many quality requirements that potentially make up a software architecture. </span><span class="koboSpan" id="kobo.28.2">I asked ChatGPT for a list of quality requirements, and this is </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the result:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Scalability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Flexibility</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Maintainability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Security</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Reliability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Modularity</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Performance</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Interoperability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Testability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Cost-effectiveness</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">The list doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">end here.</span></span><span class="No-Break"><span id="footnote-007-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-007"><span class="koboSpan" id="kobo.42.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-007">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-007-backlink"><span class="koboSpan" id="kobo.43.1">1</span></a><span class="koboSpan" id="kobo.44.1">	For some inspiration about software quality (which has been created by humans, and not a language model), have a look </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">at </span></span><a href="https://quality.arc42.org/"><span class="No-Break"><span class="koboSpan" id="kobo.46.1">https://quality.arc42.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.48.1">As software </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.49.1">architects, we design our software to fulfill the quality requirements that are most important for the software. </span><span class="koboSpan" id="kobo.49.2">For a high-throughput trading application, we might focus on scalability and reliability. </span><span class="koboSpan" id="kobo.49.3">For an application dealing with personally identifiable information in Germany, we might want to focus </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">on security.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">I think it’s wrong to lump</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.52.1"> maintainability in with the rest of the quality requirements because maintainability is special. </span><span class="koboSpan" id="kobo.52.2">If software is maintainable, that means it’s easy to change. </span><span class="koboSpan" id="kobo.52.3">If it’s easy to change, it’s flexible and probably modular. </span><span class="koboSpan" id="kobo.52.4">It’s probably cost-effective, too, because easy changes mean cheap changes. </span><span class="koboSpan" id="kobo.52.5">If it’s maintainable, we can probably evolve it to be scalable, secure, reliable, and performant, should the need arise. </span><span class="koboSpan" id="kobo.52.6">We can change the software to be interoperable with other systems because it’s easy to change. </span><span class="koboSpan" id="kobo.52.7">Last but not least, maintainability implies testability because maintainable software is most likely designed from smaller and simpler components that make </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">testing easy.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">You can see what I did here. </span><span class="koboSpan" id="kobo.54.2">I asked AI for a list of quality requirements and then tied them all back to maintainability. </span><span class="koboSpan" id="kobo.54.3">I could probably tie many more quality requirements back to maintainability with similarly plausible arguments. </span><span class="koboSpan" id="kobo.54.4">It’s a bit simplistic, of course, but the core of it is true: if software is maintainable, it’s easier to evolve in any direction, functionally and non-functionally. </span><span class="koboSpan" id="kobo.54.5">And we all know that change is common during the life of a </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">software system.</span></span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.56.1">Maintainability enables functionality</span></h1>
<p><span class="koboSpan" id="kobo.57.1">Now back to my</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.58.1"> claim that maintainability is more important than functionality from the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">If you ask a product person what’s most important in a software project, they’ll tell you that the value the software provides to its users is the most important thing. </span><span class="koboSpan" id="kobo.60.2">Software that doesn’t provide value to its users means that users don’t pay for it. </span><span class="koboSpan" id="kobo.60.3">And without paying users, we don’t have a working business model, which is the main measure of success in the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">business world.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">So, our software needs to provide value. </span><span class="koboSpan" id="kobo.62.2">But it shouldn’t provide value at the cost of maintainability.</span><span id="footnote-006-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-006"><span class="koboSpan" id="kobo.63.1">2</span></a></span><span class="koboSpan" id="kobo.64.1"> Think about how much more efficient and joyful it is to add functionality to a software system that is easily changeable as compared to a software system where you have to fight your way through one line of code at a time! </span><span class="koboSpan" id="kobo.64.2">I’m pretty sure that you’ve worked on one of those software projects where there’s so much cruft and ritual that it takes days or weeks to build a feature that you think should take no more than a couple of hours </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">to complete.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-006">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-006-backlink"><span class="koboSpan" id="kobo.66.1">2</span></a><span class="koboSpan" id="kobo.67.1">	In the context of this book, I use the term "maintainability" synonymously with "changeability of a code base". </span><span class="koboSpan" id="kobo.67.2">Also see </span><a href="https://quality.arc42.org/qualities/maintainability"><span class="koboSpan" id="kobo.68.1">https://quality.arc42.org/qualities/maintainability</span></a><span class="koboSpan" id="kobo.69.1"> for some definitions of maintainability (all of which have to do with changing </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the software).</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.71.1">In this way, maintainability is a key supporter of functionality. </span><span class="koboSpan" id="kobo.71.2">Bad maintainability means that changes in functionality become more and more expensive over time, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.72.1">Figure 1</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.73.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer005">
<span class="koboSpan" id="kobo.75.1"><img alt="Figure 1.1 – A maintainable software system has a smaller lifetime cost than a not-so-maintainable software system" src="image/Figure_01.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.76.1">Figure 1.1 – A maintainable software system has a smaller lifetime cost than a not-so-maintainable software system</span></p>
<p><span class="koboSpan" id="kobo.77.1">In a not-so-maintainable software system, changes in functionality will soon become so expensive that change is a pain. </span><span class="koboSpan" id="kobo.77.2">Product people will complain to the engineers about the cost of changes. </span><span class="koboSpan" id="kobo.77.3">The engineers will defend themselves by saying that shipping new features has always had a higher priority than increasing maintainability. </span><span class="koboSpan" id="kobo.77.4">The probability of conflict increases with the cost </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">of change.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Maintainability is a pacifier. </span><span class="koboSpan" id="kobo.79.2">It’s </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.80.1">inversely proportional to the cost of change and thus to the probability of conflict. </span><span class="koboSpan" id="kobo.80.2">Did you ever think about adding maintainability to a software system to avoid conflict? </span><span class="koboSpan" id="kobo.80.3">I think that’s a good investment </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">in itself.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">But what about those big software systems that are successful in spite of bad maintainability? </span><span class="koboSpan" id="kobo.82.2">It’s true that there are commercially successful software systems out there that are barely maintainable. </span><span class="koboSpan" id="kobo.82.3">I’ve worked on systems where adding a single field to a form is a project that takes weeks of developer time, and the client happily paid a premium for </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">my time.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Those systems usually fall into one (or both) of </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">two categories:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.86.1">They are at the end of their life where changes to the system are few and </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">far between</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">They are backed by a financially well-off company that is willing to throw money at </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the problem</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.90.1">Even in the case where a company has a lot of money to spend, the company realizes that they can reduce the maintenance tax by investing in maintainability. </span><span class="koboSpan" id="kobo.90.2">So, usually, there are already initiatives underway to make the software </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">more maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">We should always care about the maintainability of the software we’re creating so it doesn’t degrade into the dreaded </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">big ball of mud</span></strong><span class="koboSpan" id="kobo.94.1">, but if our software doesn’t fall into one of the two categories mentioned previously, we should care </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">even more.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Does this mean that we have to</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.97.1"> spend a lot of time planning out a maintainable architecture before we even start programming? </span><span class="koboSpan" id="kobo.97.2">Do we have to do a </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">big design up front</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">BDUF</span></strong><span class="koboSpan" id="kobo.101.1">), which is </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.102.1">often considered synonymous with the waterfall methodology? </span><span class="koboSpan" id="kobo.102.2">No, we don’t. </span><span class="koboSpan" id="kobo.102.3">But we need to do </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">some design up-front</span></strong><span class="koboSpan" id="kobo.104.1"> (should we call it </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">SDUF</span></strong><span class="koboSpan" id="kobo.106.1">?) to bake a seed of maintainability into the software, which can </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.107.1">make it easier to evolve the architecture to where it needs to be </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Part of that up-front design is choosing an architecture style that defines the guardrails of the software we’re building. </span><span class="koboSpan" id="kobo.109.2">This book will help you decide whether a </span><em class="itali"><span class="koboSpan" id="kobo.110.1">Clean</span></em><span class="koboSpan" id="kobo.111.1"> – or </span><em class="itali"><span class="koboSpan" id="kobo.112.1">Ports and Adapters/Hexagonal</span></em><span class="koboSpan" id="kobo.113.1"> – architecture is a good fit for </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">your context.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.115.1">Maintainability generates developer joy</span></h1>
<p><span class="koboSpan" id="kobo.116.1">As a developer, would you rather </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.117.1">work on software where changes are easy or on software where changes are hard? </span><span class="koboSpan" id="kobo.117.2">Don’t answer; it’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">rhetorical question.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Aside from the direct influence on the cost of change, maintainability has another benefit: it makes developers happy (or, depending on the current project they’re working on, it at least makes them </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">less sad).</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">The term</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.122.1"> I want to use to describe this happiness is </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">developer joy</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">It’s also</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.125.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">developer experience</span></strong><span class="koboSpan" id="kobo.127.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">developer enablement</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">Whatever we call it, it means that we provide the context developers need to do their </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">work well.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Developer joy is directly related to developer productivity. </span><span class="koboSpan" id="kobo.131.2">In general, if developers are happy, they do better work. </span><span class="koboSpan" id="kobo.131.3">And if they do good work, they are happier. </span><span class="koboSpan" id="kobo.131.4">There’s a two-way correlation between developer joy and </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">developer productivity:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<span class="koboSpan" id="kobo.133.1"><img alt="Figure 1.2 – Developer joy influences developer productivity and vice versa" src="image/Figure_01.2_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.134.1">Figure 1.2 – Developer joy influences developer productivity and vice versa</span></p>
<p><span class="koboSpan" id="kobo.135.1">This correlation has been recognized in the </span><em class="itali"><span class="koboSpan" id="kobo.136.1">SPACE framework</span></em><span class="koboSpan" id="kobo.137.1"> for developer productivity.</span><span id="footnote-005-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-005"><span class="koboSpan" id="kobo.138.1">3</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.139.1">While SPACE doesn’t provide an easy </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.140.1">answer on how to measure developer productivity, it provides five categories for such metrics so that we can consciously pick a set of metrics covering all those categories to best measure developer productivity in the context of our company and projects. </span><span class="koboSpan" id="kobo.140.2">One of these categories (the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">S</span></strong><span class="koboSpan" id="kobo.142.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">SPACE</span></strong><span class="koboSpan" id="kobo.144.1">) is </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">satisfaction and well-being</span></strong><span class="koboSpan" id="kobo.146.1">, which I’ve translated to developer joy for </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">this chapter.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-005">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-005-backlink"><span class="koboSpan" id="kobo.148.1">3</span></a> <em class="itali"><span class="koboSpan" id="kobo.149.1">The SPACE of Developer Productivity</span></em><span class="koboSpan" id="kobo.150.1"> by Nicole Forsgren et al., March 6, 2021. </span><span class="koboSpan" id="kobo.150.2">“SPACE” stands for satisfaction and well-being, performance, activity, communication and collaboration, and efficiency and flow. </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">See </span></span><a href="https://queue.acm.org/detail.cfm?id=3454124"><span class="No-Break"><span class="koboSpan" id="kobo.152.1">https://queue.acm.org/detail.cfm?id=3454124</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.154.1">Developer joy not only leads to better productivity but it naturally also leads to better retention. </span><span class="koboSpan" id="kobo.154.2">A developer who enjoys their work will stay with the company. </span><span class="koboSpan" id="kobo.154.3">Or rather, a developer who does not enjoy their work is more likely to leave for </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">greener pastures.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">So, where does maintainability come into the picture? </span><span class="koboSpan" id="kobo.156.2">Well, if our software system is maintainable, we need less time to implement a change, so we are more productive. </span><span class="koboSpan" id="kobo.156.3">Also, if our software system is maintainable, we find more joy in making changes because it’s more efficient and we can take more pride in it. </span><span class="koboSpan" id="kobo.156.4">Even if our software is not as maintainable as we would like it to be (which is a tautology, to be honest), but we get the opportunity to improve maintainability over time, we are happier and more productive. </span><span class="koboSpan" id="kobo.156.5">If we are happy, we’re more likely </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">to stay.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Expressed </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.159.1">in a diagram, it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 1.3 – Maintainability directly influences developer joy and productivity﻿ while developer joy influences retention" src="image/Figure_01.3_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 1.3 – Maintainability directly influences developer joy and productivity while developer joy influences retention</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.163.1">Maintainability supports decision-making</span></h1>
<p><span class="koboSpan" id="kobo.164.1">When building a software system, we solve</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.165.1"> problems every day. </span><span class="koboSpan" id="kobo.165.2">For most problems we face, there is more than one solution. </span><span class="koboSpan" id="kobo.165.3">We have to make decisions to choose between </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">those solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Do we copy this bit of code for the new feature we’re building? </span><span class="koboSpan" id="kobo.167.2">Do we create our objects ourselves or do we use a dependency injection framework? </span><span class="koboSpan" id="kobo.167.3">Do we use an overloaded constructor to create this object, or do we create </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">a builder?</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Many of these decisions we don’t even make consciously. </span><span class="koboSpan" id="kobo.169.2">We just apply a pattern or principle we’ve used before that our intuition says will work in the current situation, </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.171.1">We apply </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">don’t repeat yourself (DRY)</span></strong><span class="koboSpan" id="kobo.173.1"> when </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.174.1">we find </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">code duplication</span></span></li>
<li><span class="koboSpan" id="kobo.176.1">We use </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">dependency injection</span></strong><span class="koboSpan" id="kobo.178.1"> to make the code </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">more testable</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">We introduce a </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">builder</span></strong><span class="koboSpan" id="kobo.182.1"> to make it simpler to create </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">an object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.184.1">If we take a look at these and many other well-known patterns, then what is their effect? </span><span class="koboSpan" id="kobo.184.2">In many cases, the main effect is that they make the code easier to change in the future (i.e., they make it more maintainable). </span><span class="koboSpan" id="kobo.184.3">Maintainability is built into many of the decisions we’re making automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">every day!</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">We can take advantage of that even when facing tougher decisions that require more than just applying a pre-canned pattern. </span><em class="itali"><span class="koboSpan" id="kobo.187.1">Whenever we have to decide between multiple options, we can choose the one that makes the code easier to change in the future</span></em><span class="koboSpan" id="kobo.188.1">.</span><span id="footnote-004-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-004"><span class="koboSpan" id="kobo.189.1">4</span></a></span><span class="koboSpan" id="kobo.190.1"> No more agonizing between different options. </span><span class="koboSpan" id="kobo.190.2">We just take the one that increases maintainability the most. </span><span class="koboSpan" id="kobo.190.3">Expressed as a diagram, it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">pretty simple:</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-004">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-004-backlink"><span class="koboSpan" id="kobo.192.1">4</span></a><span class="koboSpan" id="kobo.193.1">	In a talk from 2022 with the same name, (Pragmatic) Dave Thomas called the principle of making decisions based on changeability "One Rule to Rule Them All". </span><span class="koboSpan" id="kobo.193.2">I didn't find the talk online, but I hope he will add it to his website at some point. </span><span class="koboSpan" id="kobo.193.3">See </span><a href="https://pragdave.me/talks-and-interviews.html"><span class="No-Break"><span class="koboSpan" id="kobo.194.1">https://pragdave.me/talks-and-interviews.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.196.1"><img alt="Figure 1.4 – Maintainability influences decision-making" src="image/Figure_01.4_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">Figure 1.4 – Maintainability influences decision-making</span></p>
<p><span class="koboSpan" id="kobo.198.1">Like most </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.199.1">principles, this is a generalization, of course. </span><span class="koboSpan" id="kobo.199.2">In a given context, the right decision might be to take the option that does not improve maintainability or even reduces maintainability. </span><span class="koboSpan" id="kobo.199.3">But as a default rule to fall back on, choosing maintainability is a guide that simplifies </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">daily decision-making.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.201.1">Maintaining maintainability</span></h1>
<p><span class="koboSpan" id="kobo.202.1">Alright, I assume that you</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.203.1"> believe me that maintainability positively influences developer joy, productivity, and decision-making. </span><span class="koboSpan" id="kobo.203.2">How do we know that the changes we make to our code base increase (or at least don’t decrease) maintainability? </span><span class="koboSpan" id="kobo.203.3">How do we manage maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">over time?</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">The answer to that question is to create and maintain an architecture that makes it easy to create maintainable code. </span><span class="koboSpan" id="kobo.205.2">A good architecture makes it easy to navigate the code base. </span><span class="koboSpan" id="kobo.205.3">In an easily navigable code base, it’s a breeze to modify existing features or add new features. </span><span class="koboSpan" id="kobo.205.4">The dependencies between the components of our application are clear and not tangled. </span><span class="koboSpan" id="kobo.205.5">In summary, good architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">increases maintainability:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.207.1"><img alt="Figure 1.5 – Software architecture influences maintainability" src="image/Figure_01.5_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">Figure 1.5 – Software architecture influences maintainability</span></p>
<p><span class="koboSpan" id="kobo.209.1">By extension, a good architecture increases developer joy, developer productivity, developer retention, and decision-making. </span><span class="koboSpan" id="kobo.209.2">We could go on and find even more things influenced directly or indirectly by </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">software architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">This correlation means that we should invest a bit of thought into how we structure our code. </span><span class="koboSpan" id="kobo.211.2">How do we group our code files into components? </span><span class="koboSpan" id="kobo.211.3">How do we manage the dependencies between those components? </span><span class="koboSpan" id="kobo.211.4">Which dependencies are necessary, and which should be discouraged to keep the code base supple to change? </span><span class="koboSpan" id="kobo.211.5">This brings us to the purpose of this book. </span><span class="koboSpan" id="kobo.211.6">This book shows one way of structuring a code base to make it maintainable. </span><span class="koboSpan" id="kobo.211.7">The architecture style described in this book is one way of implementing a Clean/Hexagonal Architecture. </span><span class="koboSpan" id="kobo.211.8">This architecture style is not a silver bullet to solve all problems with building software, however. </span><span class="koboSpan" id="kobo.211.9">As we will learn in </span><a href="B19916_15.xhtml#_idTextAnchor124"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.212.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.213.1">, </span><em class="itali"><span class="koboSpan" id="kobo.214.1">Deciding on an Architecture Style</span></em><span class="koboSpan" id="kobo.215.1">, it’s not suitable for all kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">software applications.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">I encourage you to</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.218.1"> take what you learn in this book, play around with the ideas, modify them to make them yours, and then add them to your toolbox to apply when they feel right in a given context. </span><span class="koboSpan" id="kobo.218.2">Each of the following chapters ends with a section titled </span><em class="itali"><span class="koboSpan" id="kobo.219.1">How does this help me build maintainable software?</span></em><span class="koboSpan" id="kobo.220.1"> This section will summarize the main ideas of each chapter and hopefully help you to make decisions regarding the architecture of your current or future </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">software projects.</span></span></p>
</div>
</body></html>