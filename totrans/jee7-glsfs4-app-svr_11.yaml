- en: Chapter 11. Developing RESTful Web Services with JAX-RS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style in
    which web services are viewed as resources and can be identified by Uniform Resource
    Identifiers (URIs).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Web services developed using REST are known as RESTful web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 6 added support to RESTful web services through the addition of the
    Java API for RESTful Web Services (JAX-RS). JAX-RS had been available as a standalone
    API for a while, it became part of Java EE in Version 6 of the specification.
    In this chapter, we will cover how to develop RESTful web services through the
    JAX-RS.API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to RESTful web services and JAX-RS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a simple RESTful web service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a RESTful web service client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing RESTful web services and JAX-RS
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful web services are very flexible. RESTful web services can consume several
    different kinds of MIME types, although they are typically written to consume
    and/or produce XML or JSON (JavaScript Object Notation).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Web services must support one or more of the following four HTTP methods:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: By convention, a `GET` request is used to retrieve an existing resource'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: By convention, a `POST` request is used to update an existing resource'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: By convention, a `PUT` request is used to create a new resource'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: By convention, a `DELETE` request is used to delete an existing resource'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We develop a RESTful web service with JAX-RS by creating a class with annotated
    methods that are invoked when our web service receives one of the above HTTP request
    methods. Once we have developed and deployed our RESTful web service, we need
    to develop a client that will send requests to our service. JAX-RS 2.0 introduces
    a standard client-side API that we can use to develop RESTful web service clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Developing a simple RESTful web service
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a simple web service to illustrate how to make
    methods in our service respond to the different HTTP request methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful web service using JAX-RS is simple and straightforward.
    Each of our RESTful web services needs to be invoked via its Unique Resource Identifier
    (URI). This URI is specified by the `@Path` annotation, which we need to use to
    decorate our RESTful web service resource class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing RESTful web services, we need to develop methods that will
    be invoked when our web service receives an HTTP request. We need to implement
    methods to handle one or more of the four types of request that RESTful web services
    handle: `GET`, `POST`, `PUT`, and/or `DELETE`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The JAX-RS API provides four annotations that we can use to decorate methods
    in our web service; the annotations are appropriately named `@GET`, `@POST`, `@PUT`,
    and `@DELETE`. Decorating a method in our web service with one of these annotations
    will make it respond to the corresponding HTTP method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, each method in our service must produce and/or consume a specific
    MIME type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们服务中的每个方法都必须生成和/或消耗一个特定的MIME类型。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Multipurpose Internet Mail Extensions** (**MIME**) is a standard for transferring
    nonASCII text over the Internet. MIME was originally developed to send nontextual
    data over e-mail, but later, its use was expanded to include other forms of data
    transfer such as RESTful web services.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**多用途互联网邮件扩展**（**MIME**）是在互联网上传输非ASCII文本的标准。MIME最初是为了通过电子邮件发送非文本数据而开发的，但后来其用途扩展到了包括其他形式的数据传输，如RESTful
    Web服务。'
- en: The MIME type that is going to be produced needs to be specified with the `@Produces`
    annotation; similarly, the MIME type that is going to be consumed must be specified
    with the `@Consumes` annotation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要通过`@Produces`注解指定将要生成的MIME类型；同样，将要消耗的MIME类型必须通过`@Consumes`注解指定。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please note that this example does not really do anything; its purpose is to
    illustrate how to make different methods in our RESTful web service resource class
    respond to the different HTTP methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例实际上并没有做任何事情；它的目的是说明如何在我们的RESTful Web服务资源类中使不同的方法响应不同的HTTP方法。
- en: 'The following example illustrates the concepts we have just explained:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们刚刚解释的概念：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that this class is annotated with the `@Path` annotation; this annotation
    designates the Uniform Resource Identifier (URI) for our RESTful web service.
    The complete URI for our service will include the protocol, server name, port,
    context root, the REST resources path (see the next subsection), and the value
    passed to this annotation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类被`@Path`注解标注；这个注解指定了我们的RESTful Web服务的统一资源标识符（URI）。我们服务的完整URI将包括协议、服务器名称、端口、上下文根、REST资源路径（见下一小节）以及传递给此注解的值。
- en: Assuming our web service was deployed to a server called `example.com` using
    the HTTP protocol on port 8080, and has a context root called "jaxrsintro" and
    a REST resources path called `resources`, then the complete URI for our service
    would be `http://example.com:8080/jaxrsintro/resources/customer`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的Web服务已部署到名为`example.com`的服务器上，使用HTTP协议在8080端口，上下文根为"jaxrsintro"，REST资源路径为`resources`，那么我们服务的完整URI将是`http://example.com:8080/jaxrsintro/resources/customer`。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since web browsers generate a GET request when pointed to a URL, we can test
    the GET method of our service by simply pointing the browser to our service's
    URI.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web浏览器在指向URL时会生成GET请求，我们可以通过将浏览器指向我们服务的URI来测试服务的GET方法。
- en: Notice that each of the methods in our class is annotated with one of the `@GET`,
    `@POST`, `@PUT`, or `@DELETE` annotations. These annotations make our methods
    respond to their corresponding HTTP method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们类中的每个方法都被`@GET`、`@POST`、`@PUT`或`@DELETE`注解之一标注。这些注解使我们的方法能够响应它们对应的HTTP方法。
- en: Additionally, if our method returns data to the client, we declare that the
    MIME type of the data should be returned in the `@Produces` annotation. In our
    example, only the `getCustomer()` method returns data to the client; we wish to
    return data in an XML format, therefore, we set the value of the `@Produces` annotation
    to `text/xml`. Similarly, if our method needs to consume data from the client,
    we need to specify the MIME type of the data to be consumed; this is done via
    the `@Consumes` annotation. All methods in our service except `getCustomer()`
    consume data; in all cases, we expect the data to be in XML, therefore, we again
    specify `text/xml` as the MIME type to be consumed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的方法需要向客户端返回数据，我们声明数据的MIME类型应该通过`@Produces`注解返回。在我们的示例中，只有`getCustomer()`方法向客户端返回数据；我们希望以XML格式返回数据，因此，我们将`@Produces`注解的值设置为`text/xml`。同样，如果我们的方法需要从客户端消耗数据，我们需要指定要消耗的数据的MIME类型；这是通过`@Consumes`注解完成的。我们服务中的所有方法（除了`getCustomer()`）都消耗数据；在所有情况下，我们期望数据以XML格式，因此，我们再次指定`text/xml`作为要消耗的MIME类型。
- en: Configuring the REST resources path for our application
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置应用程序的REST资源路径
- en: As briefly mentioned in the previous section, before successfully deploying
    a RESTful web service developed using JAX-RS, we need to configure the REST resources
    path for our application. We can do this by developing a class that extends `javax.ws.rs.core.Application`
    and decorating it with the `@ApplicationPath` annotation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节简要提到的，在成功部署使用JAX-RS开发的RESTful Web服务之前，我们需要为我们的应用程序配置REST资源路径。我们可以通过开发一个扩展`javax.ws.rs.core.Application`的类并使用`@ApplicationPath`注解来装饰它来实现这一点。
- en: Configuring via the @ApplicationPath annotation
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过@ApplicationPath注解进行配置
- en: As mentioned in previous chapters, Java EE 6 added several new features to the
    Java EE specification so that in many cases it isn't necessary to write a `web.xml`
    deployment descriptor. JAX-RS is no different. We can configure the REST resources
    path in Java code via an annotation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Java EE 6 向 Java EE 规范添加了几个新功能，因此在许多情况下，编写 `web.xml` 部署描述符是不必要的。JAX-RS
    也不例外。我们可以通过注解在 Java 代码中配置 REST 资源路径。
- en: To configure our REST resources path without having to rely on a `web.xml` deployment
    descriptor, all we need to do is write a class that extends `javax.ws.ApplicationPath`
    and decorate it with the `@ApplicationPath` annotation; the value passed to this
    annotation is the REST resources path for our services.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的 REST 资源路径，而无需依赖于 `web.xml` 部署描述符，我们只需编写一个扩展 `javax.ws.ApplicationPath`
    的类，并用 `@ApplicationPath` 注解装饰它；传递给此注解的值是我们服务的 REST 资源路径。
- en: 'The following code sample illustrates this process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了这个过程：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the class does not have to implement any methods. It simply needs
    to extend `javax.ws.rs.Application` and be decorated with the `@ApplicationPath`
    annotation. The class must be public, may have any name, and may be placed in
    any package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类不需要实现任何方法。它只需扩展 `javax.ws.rs.Application` 并用 `@ApplicationPath` 注解装饰。该类必须是公共的，可以具有任何名称，并且可以放在任何包中。
- en: Testing our web service
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的网络服务
- en: 'As we mentioned earlier, web browsers send a `GET` request to any URLs we point
    them to; therefore, the easiest way to test `GET` requests to our service is by
    simply pointing the browser to our service''s URI, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，网络浏览器会向它们指向的任何 URL 发送 `GET` 请求；因此，测试我们对服务发送的 `GET` 请求的最简单方法就是将浏览器指向我们的服务
    URI，如下面的截图所示：
- en: '![Testing our web service](img/6886_11_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的网络服务](img/6886_11_01.jpg)'
- en: Web browsers only support `GET` and `POST` requests. To test a `POST` request
    through the browser, we would have to write a web application containing an HTML
    form that has an action attribute value of our service's URI. Although this is
    simple to do for a single service, it can become cumbersome to do this for every
    RESTful web service we develop.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器仅支持 `GET` 和 `POST` 请求。要通过浏览器测试 `POST` 请求，我们必须编写一个包含具有我们的服务 URI 的 action
    属性值的 HTML 表单的 Web 应用程序。虽然对于单个服务来说这很简单，但对我们开发的每个 RESTful 网络服务都这样做可能会变得繁琐。
- en: Thankfully, there is an open source command-line utility called `curl` that
    we can use to test our web services. The `curl` command is included with most
    Linux distributions and can be easily downloaded for Windows, Mac OS X, and several
    other platforms. The `curl` utility can be downloaded at [http://curl.haxx.se/](http://curl.haxx.se/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为 `curl` 的开源命令行实用工具，我们可以用它来测试我们的网络服务。`curl` 命令包含在大多数 Linux 发行版中，并且可以轻松地下载到
    Windows、Mac OS X 和其他几个平台。您可以在 [http://curl.haxx.se/](http://curl.haxx.se/) 下载
    `curl` 实用工具。
- en: '`curl` can send all four request method types (`GET`, `POST`, `PUT` and `DELETE`)
    to our service. Our server''s response will simply be displayed on the command-line
    console. `curl` takes the `-X` command-line option, which allows us to specify
    what request method to send; to send a `GET` request, we simply need to type the
    following into the command line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 可以向我们的服务发送所有四种请求方法（`GET`、`POST`、`PUT` 和 `DELETE`）。我们的服务器响应将简单地显示在命令行控制台上。`curl`
    使用 `-X` 命令行选项，允许我们指定要发送的请求方法；要发送 `GET` 请求，我们只需在命令行中输入以下内容：'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This, unsurprisingly, is the same output we saw when we pointed our browser
    to our service's URI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这，不出所料，是我们指向我们的服务 URI 时看到的相同输出。
- en: 'The default request method for curl is `GET`, therefore, the `-X` parameter
    in our previous example is redundant; we could have achieved the same result by
    invoking the following command from the command line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 的默认请求方法是 `GET`，因此，我们之前示例中的 `-X` 参数是多余的；我们可以通过从命令行调用以下命令来达到相同的结果：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After submitting any of the two previous commands and examining the GlassFish
    log, we should see the output of the `System.out.println()` statements we added
    to the `getCustomer()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交任何前两个命令并检查 GlassFish 日志后，我们应该看到我们添加到 `getCustomer()` 方法的 `System.out.println()`
    语句的输出。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For all other request method types, we need to send some data to our service.
    This can be accomplished by the `--data` command-line argument to the `curl` command,
    as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他请求方法类型，我们需要向我们的服务发送一些数据。这可以通过 `curl` 命令的 `--data` 命令行参数来实现，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in this example, we need to specify the MIME type via the curl's `-H`
    command-line argument using the format shown in the example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，我们需要通过curl的`-H`命令行参数指定MIME类型，格式如示例所示。
- en: 'We can verify that the previous command worked as expected by inspecting the
    GlassFish log by executing the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查GlassFish日志来验证之前的命令是否按预期工作，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can test other request method types just as easily by executing the following
    code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下代码轻松测试其他请求方法类型：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The GlassFish log shows the corresponding output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish日志显示了相应的输出：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can test the `delete` method by executing the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来测试`delete`方法：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again the GlassFish log shows the corresponding output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，GlassFish日志显示了相应的输出：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Converting data between Java and XML with JAXB
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JAXB在Java和XML之间转换数据
- en: In our previous example, we processed raw XML data. In a real application, we
    would more than likely parse the XML data received from the client and use it
    to populate a Java object. Additionally, any XML data that we need to return to
    the client would have to be constructed from a Java object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们处理了原始的XML数据。在实际应用中，我们更有可能解析从客户端接收到的XML数据，并使用它来填充Java对象。此外，我们需要返回给客户端的任何XML数据都必须从Java对象构建。
- en: Converting data from Java to XML and back is such a common use case that the
    Java EE specification provides an API to do it. This API is the **Java API for
    XML Binding** (**JAXB**)**.**
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从Java转换为XML以及反向转换是一个如此常见的用例，以至于Java EE规范提供了一个API来完成它。这个API是**Java API for
    XML Binding**（**JAXB**）。
- en: 'JAXB makes converting data from Java to XML transparent and simple. All we
    need to do is decorate the class that we wish to convert to XML with the `@XmlRootElement`
    annotation. The following code example illustrates how to do this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JAXB使得将数据从Java转换为XML变得透明且简单。我们只需要用`@XmlRootElement`注解装饰我们希望转换为XML的类。以下代码示例说明了如何做到这一点：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in this example, other than the `@XmlRootElement` annotation at the
    class level, there is nothing unusual about the above Java class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，除了类级别的`@XmlRootElement`注解外，上述Java类没有其他不寻常之处。
- en: 'Once we have a class that we have decorated with the `@XmlRootElement` annotation,
    we need to change the parameter type of our web service from String to our custom
    class, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`@XmlRootElement`注解装饰了一个类，我们需要将我们的Web服务的参数类型从String更改为我们的自定义类，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the difference between this version of our RESTful web service
    and the previous one is that all parameter types and return values have been changed
    from `String` to `Customer`. JAXB takes care of converting our parameters and
    return types to and from XML as appropriate. When using JAXB, an object of our
    custom class is automatically populated with data from the XML data sent from
    the client, return values are similarly transparently converted to XML.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们这个版本的RESTful Web服务与之前的版本之间的区别在于，所有参数类型和返回值都已从`String`更改为`Customer`。JAXB负责将我们的参数和返回类型适当地转换为XML。当使用JAXB时，我们的自定义类对象会自动用客户端发送的XML数据填充，返回值也会类似地透明地转换为XML。
- en: Developing a RESTful web service client
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful Web服务客户端
- en: Although `curl` allows us to quickly test our RESTful web services and is a
    developer friendly tool, it is not exactly user friendly; we shouldn't expect
    to have our user enter `curl` commands in their command line to use our web service.
    For this reason, we need to develop a client for our services. JAX-RS 2.0 introduces
    a standard client-side API that we can use to easily develop RESTful web service
    clients.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`curl`允许我们快速测试RESTful Web服务，并且是一个开发者友好的工具，但它并不完全用户友好；我们不应该期望用户在命令行中输入`curl`命令来使用我们的Web服务。因此，我们需要为我们的服务开发一个客户端。JAX-RS
    2.0引入了一个标准客户端API，我们可以使用它轻松地开发RESTful Web服务客户端。
- en: 'The following example illustrates how to use the JAX-RS client API:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用JAX-RS客户端API：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing we need to do is create an instance of `javax.ws.rs.client.Client`
    by invoking the static `newClient()` method on the `javax.ws.rs.client.ClientBuilder`
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是通过在`javax.ws.rs.client.ClientBuilder`类上调用静态`newClient()`方法来创建`javax.ws.rs.client.Client`的一个实例。
- en: We then invoke the `target()` method on our `Client` instance, passing the URI
    of our RESTful web service as the parameter. The `target()` method returns an
    instance of a class implementing the `javax.ws.rs.client.WebTarget` interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的`Client`实例上调用`target()`方法，将我们的RESTful网络服务的URI作为参数传递。`target()`方法返回实现`javax.ws.rs.client.WebTarget`接口的类的实例。
- en: At this point, we invoke the `request()` method on our `WebTarget` instance;
    this method returns an implementation of the `javax.ws.rs.client.Invocation.Builder`
    interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们在我们的`WebTarget`实例上调用`request()`方法；此方法返回`javax.ws.rs.client.Invocation.Builder`接口的实现。
- en: In this particular example, we are sending an `HTTP PUT` request to our RESTful
    web service; therefore, at this point, we invoke the `put()` method of our `Invocation.Builder`
    implementation. The first parameter of the `put()` method is an instance of `javax.ws.rs.client.Entity`.
    We can create an instance of `javax.ws.rs.client.Entity` on the fly by invoking
    the static `entity()` method on the `Entity` class. The first parameter for this
    method is the object we wish to pass to our RESTful web service and the second
    parameter is the String representation of the MIME type of the data we will be
    passing to the RESTful web service. The second parameter of the `put()` method
    is the type of response the client expects from the service. After we invoke the
    `put()` method, an `HTTP PUT` request is sent to our RESTful web service and the
    method we decorated with the `@Put` annotation (`createCustomer()` in our example)
    is invoked. There are similar `get()`, `post()`, and `delete()` methods we can
    invoke to send the corresponding HTTP requests to our RESTful web service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们正在向我们的RESTful网络服务发送一个`HTTP PUT`请求；因此，在这个时候，我们调用我们的`Invocation.Builder`实现中的`put()`方法。`put()`方法的第一参数是`javax.ws.rs.client.Entity`的实例。我们可以通过在`Entity`类上调用静态`entity()`方法即时创建`javax.ws.rs.client.Entity`的实例。此方法的第一参数是我们希望传递给我们的RESTful网络服务的对象，第二个参数是我们将传递给RESTful网络服务的数据的MIME类型的字符串表示。`put()`方法的第二个参数是客户端期望从服务中获得的响应类型。在调用`put()`方法后，向我们的RESTful网络服务发送一个`HTTP
    PUT`请求，并调用我们用`@Put`注解装饰的方法（在我们的例子中是`createCustomer()`）。我们还可以调用类似的`get()`、`post()`和`delete()`方法来向我们的RESTful网络服务发送相应的HTTP请求。
- en: Working with query and path parameters
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理查询和路径参数
- en: 'In our previous examples, we have been working with a RESTful web service to
    manage a single `customer` object. In real life, this would obviously not be very
    helpful. The common case is to develop a RESTful web service to handle a collection
    of objects (customers, in our example). To determine which specific object in
    the collection we are working with, we can pass parameters to our RESTful web
    services. There are two types of parameters we can use: query and path.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们一直在使用一个RESTful网络服务来管理单个`customer`对象。在现实生活中，这显然不会很有帮助。常见的情况是开发一个RESTful网络服务来处理一组对象（在我们的例子中是客户）。为了确定我们正在处理集合中的哪个特定对象，我们可以向我们的RESTful网络服务传递参数。我们可以使用两种类型的参数：查询和路径。
- en: Query parameters
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: We can add parameters to methods that will handle HTTP requests in our web service.
    Parameters decorated with the `@QueryParam` annotation will be retrieved from
    the request URL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向将处理我们的网络服务中的HTTP请求的方法添加参数。带有`@QueryParam`注解的参数将从请求URL中检索。
- en: 'The following example illustrates how to use query parameters in our JAX-RS
    RESTful web services:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在我们的JAX-RS RESTful网络服务中使用查询参数：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that all we had to do was decorate the parameters with the `@QueryParam`
    annotation. This annotation allows JAX-RS to retrieve any query parameters matching
    the value of the annotation and assign its value to the parameter variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们唯一需要做的就是用`@QueryParam`注解装饰参数。此注解允许JAX-RS检索与注解值匹配的任何查询参数，并将其值分配给参数变量。
- en: 'We can add a parameter to the web service''s URL just like we pass parameters
    to any URL:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向网络服务的URL添加一个参数，就像我们向任何URL传递参数一样：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sending query parameters via the JAX-RS client API
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API发送查询参数
- en: 'The JAX-RS client API provides an easy and straightforward way of sending query
    parameters to RESTful web services. The following example illustrates how to do
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS客户端API提供了一个简单直接的方法来向RESTful网络服务发送查询参数。以下示例说明了如何做到这一点：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, all we need to do to pass a parameter is invoke the `queryParam()`
    method on the instance of `javax.ws.rs.client.WebTarget` returned by invoking
    the `target()` method on our `Client` instance. The first argument to this method
    is the parameter name and it must match the value of the `@QueryParam` annotation
    in the web service. The second parameter is the value that we need to pass to
    the web service. If our web service accepts multiple parameters, we can chain
    `queryParam()` method invocations, using one for each parameter that our RESTful
    web service expects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需调用我们的`Client`实例上`target()`方法返回的`javax.ws.rs.client.WebTarget`实例上的`queryParam()`方法，就可以传递参数。此方法的第一参数是参数名称，它必须与Web服务中`@QueryParam`注解的值匹配。第二个参数是我们需要传递给Web服务的值。如果我们的Web服务接受多个参数，我们可以通过链式调用`queryParam()`方法，为我们的RESTful
    Web服务期望的每个参数使用一个。
- en: Path parameters
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径参数
- en: 'Another way we can pass parameters to our RESTful web services is via path
    parameters. The following example illustrates how to develop a JAX-RS RESTful
    web service that accepts path parameters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向RESTful Web服务传递参数的另一种方式是通过路径参数。以下示例说明了如何开发一个接受路径参数的JAX-RS RESTful Web服务：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Any method that accepts a path parameter must be decorated with the `@Path`
    annotation. The `value` attribute of this annotation must be formatted as `"{paramName}/"`,
    where `paramName` is the parameter the method expects to receive. Additionally,
    method parameters must be decorated with the `@PathParam` annotation. The value
    of the `@PathParam` annotation must match the parameter name declared in the `@Path`
    annotation for the method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接受路径参数的方法都必须用`@Path`注解装饰。此注解的`value`属性必须格式化为`"{paramName}/"`，其中`paramName`是方法期望接收的参数。此外，方法参数必须用`@PathParam`注解装饰。`@PathParam`注解的值必须与方法`@Path`注解中声明的参数名称匹配。
- en: 'We can pass path parameters from the command line by adjusting our web service''s
    URI as appropriate; for example, to pass an `"id"` parameter of `1` to the `getCustomer()`
    method (which handles `HTTP GET` requests), we could do it from the command line
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整我们的Web服务的URI来从命令行传递路径参数；例如，要将`1`的`"id"`参数传递给`getCustomer()`方法（该方法处理`HTTP
    GET`请求），我们可以从命令行如下操作：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns the expected output of an XML representation of the `Customer`
    object returned by the `getCustomer()` method, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`getCustomer()`方法返回的`Customer`对象的XML表示形式的预期输出，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sending path parameters via the JAX-RS Client API
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API发送路径参数
- en: 'Sending path parameters to a web service via the JAX-RS client API is easy
    and straightforward; all we need to do is add a couple of method invocations to
    specify the path parameter and its value. The following example illustrates how
    to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JAX-RS客户端API向Web服务发送路径参数既简单又直接；我们只需添加几个方法调用，以指定路径参数及其值。以下示例说明了如何进行此操作：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we invoke the `path()` method on the instance of `WebTarget`
    returned by `client.target()`. This method appends the specified path to our `WebTarget`
    instance; the value of this method must match the value of the `@Path` annotation
    in our RESTful web service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们调用`client.target()`返回的`WebTarget`实例上的`path()`方法。此方法将指定的路径追加到我们的`WebTarget`实例；此方法的价值必须与我们的RESTful
    Web服务中`@Path`注解的值匹配。
- en: After invoking the `path()` method on our `WebTarget` instance, we need to invoke
    `resolveTemplate()`; the first parameter for this method is the name of the parameter
    (without the curly braces) and the second parameter is the value we wish to pass
    as a parameter to our RESTful web service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`WebTarget`实例上调用`path()`方法后，我们需要调用`resolveTemplate()`；此方法的第一参数是参数的名称（不带大括号），第二个参数是我们希望作为参数传递给我们的RESTful
    Web服务的值。
- en: 'If we need to pass more than one parameter to one of our web services, we simply
    need to use the following format for the `@Path` parameter at the method level:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要向我们的Web服务中的一个传递多个参数，我们只需在方法级别的`@Path`参数中使用以下格式：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then annotate the corresponding method arguments with the `@PathParam` annotation,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下方式对相应的方法参数进行`@PathParam`注解：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The web service can then be invoked by modifying the web service''s URI to
    pass the parameters in the order specified in the `@Path` annotation. For example,
    the following URI would pass the values `1` and `2` for `paramName1` and `paramName2`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以通过修改Web服务的URI来调用Web服务，将参数按`@Path`注解中指定的顺序传递。例如，以下URI将传递`paramName1`和`paramName2`的值`1`和`2`：
- en: '`http://localhost:8080/contextroot/resources/customer/1/2`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/contextroot/resources/customer/1/2`'
- en: The previous URI will work both from the command line and through a web service
    client we have developed with the JAX-RS client API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 URI 无论是从命令行还是通过我们用 JAX-RS 客户端 API 开发的网络服务客户端都可以使用。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to develop RESTful web services using JAX-RS,
    a new addition to the Java EE specification.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用 JAX-RS 开发 RESTful 网络服务，这是 Java EE 规范的新增内容。
- en: We covered how to develop a RESTful web service by adding a few simple annotations
    to our code. We also explained how to automatically convert data between Java
    and XML by taking advantage of the Java API for XML Binding (JAXB).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何通过在我们的代码中添加一些简单的注解来开发 RESTful 网络服务。我们还解释了如何利用 Java API for XML Binding
    (JAXB) 自动在 Java 和 XML 之间转换数据。
- en: We also discussed how to develop RESTful web service clients via the JAX-RS
    client API
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何通过 JAX-RS 客户端 API 开发 RESTful 网络服务客户端。
- en: Finally, we covered how to pass parameters to our RESTful web services via the
    `@PathParam` and `@QueryParam` annotations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何通过 `@PathParam` 和 `@QueryParam` 注解将参数传递给我们的 RESTful 网络服务。
