- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Primitives and Objects in Java Memory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java内存中的基本类型和对象
- en: In [*Chapter 1*](B18762_01.xhtml#_idTextAnchor014), we saw the differences between
    primitives, objects, and references. We learned that primitives are types that
    come with the Java language; in other words, we do not have to define primitive
    types, we just use them. For example, `int x;` defines (creates) a primitive variable,
    `x`, which is of (the primitive) type `int`. This means that `x` can store whole
    integer numbers only, for example, -5, 0, 12, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18762_01.xhtml#_idTextAnchor014)中，我们看到了基本类型、对象和引用之间的区别。我们了解到基本类型是Java语言自带的数据类型；换句话说，我们不需要定义基本类型，我们只需使用它们。例如，`int
    x;`定义（创建）了一个基本变量`x`，它是（基本）类型`int`。这意味着`x`只能存储整数，例如，-5、0、12等等。
- en: We also learned that objects are instantiations of a `new` keyword to create
    instances of objects. For example, assuming a `Person` class exists, `new Person();`
    instantiates (creates) an object of type `Person`. This object will be stored
    on the heap.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到对象是通过`new`关键字创建的对象实例。例如，假设存在一个`Person`类，`new Person();`实例化（创建）了一个`Person`类型的对象。这个对象将存储在堆上。
- en: 'We saw that references enable us to manipulate objects and that references
    are of four different types: `class`, `array`, `interface`, and `null`. When you
    create an object, the reference to the object is what you receive back. For example,
    in the code `Person p = new Person();`, the reference is `p` and it is of type
    `Person`. Whether the reference is placed on the stack or on the heap depends
    on the context – more on this later.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到引用使我们能够操作对象，并且引用有四种不同类型：`class`、`array`、`interface`和`null`。当你创建一个对象时，你得到的是对象的引用。例如，在代码`Person
    p = new Person();`中，引用是`p`，它是`Person`类型。引用是放在栈上还是堆上取决于上下文——稍后会有更多介绍。
- en: Understanding the differences between references and objects is very important
    and greatly simplifies core `ClassCastException` errors. Being aware of Java’s
    call-by-value mechanism and, in particular, how it relates to references can prevent
    subtle encapsulation issues known as *escaping references*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解引用和对象之间的区别非常重要，并且可以极大地简化核心`ClassCastException`错误。了解Java的按值调用机制，特别是它与引用的关系，可以防止称为*逃逸引用*的微妙封装问题。
- en: 'In this chapter, we will delve more deeply into the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨以下主题：
- en: Understanding primitives on the stack and heap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解栈和堆上的基本类型
- en: Storing objects on the heap
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆上存储对象
- en: Managing object references and security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理对象引用和安全
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management)。
- en: Understanding primitives on the stack and heap
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解栈和堆上的基本类型
- en: Java comes with a predefined set of primitive data types. Primitive data types
    are always in lowercase, for example, `double`. Contrast primitives with their
    associated wrapper counterparts, which are classes in the API, have methods (primitives
    do not), and wrappers start with a capital letter, for example, `Double`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java自带一组预定义的基本数据类型。基本数据类型始终为小写，例如，`double`。将基本数据类型与其关联的包装器对应物进行对比，这些对应物是API中的类，有方法（基本数据类型没有），并且包装器以大写字母开头，例如，`Double`。
- en: The primitive data types can be broken down into integral types (whole numbers),
    namely `byte`, `short`, `int`, `long`, and `char`, and floating-point types (decimal
    numbers), namely `float`, `double`, and `boolean` (`true` or `false`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据类型可以分为整型（整数），即`byte`、`short`、`int`、`long`和`char`，以及浮点型（小数），即`float`、`double`和`boolean`（`true`或`false`）。
- en: Primitives can be stored on both the stack and the heap. They are stored on
    the stack when they are local variables to methods, in other words, parameters
    to the method or variables declared inside the method itself. Primitives are stored
    on the heap when they are members of a class, that is, instance variables. Instance
    variables are declared within the class scope, in other words, outside all of
    the methods. Therefore, primitive variables declared within a method go on the
    stack, whereas instance variables go on the heap (inside the object).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型也可以存储在栈和堆上。当它们是方法的局部变量时，存储在栈上，换句话说，是方法的参数或方法内部声明的变量。当它们是类的成员时，即实例变量，基本类型存储在堆上。实例变量在类的作用域内声明，换句话说，在所有方法之外。因此，在方法内部声明的原始变量存储在栈上，而实例变量存储在堆上（在对象内部）。
- en: Now that we understand where primitives are stored, let us turn our attention
    to storing objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了原始类型存储的位置，让我们将注意力转向对象的存储。
- en: Storing objects on the heap
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在堆上存储对象
- en: In this section, we are going to examine storing objects on the heap. Gaining
    a full understanding of this area requires a discussion comparing references and
    objects. We will examine their types, where they are stored, and crucially, their
    differences. A sample piece of code with an associated diagram will finish the
    section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在堆上存储对象。要全面理解这一领域，需要讨论比较引用和对象。我们将检查它们的类型、存储位置以及关键的区别。一个带有相关图表的代码示例将结束本节。
- en: References
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: References refer to objects and enable us to access them. If we are accessing
    an object instance member, then we use the reference. If we are accessing a static
    (class) member, we use the class name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 引用指向对象，并使我们能够访问它们。如果我们访问的是对象实例成员，那么我们使用引用。如果我们访问的是静态（类）成员，我们使用类名。
- en: References can be stored on both the stack and the heap. If the reference is
    a local variable in a method, then the reference is stored on the stack (in the
    local method array for that method frame). If the reference is an instance variable,
    then the reference is stored inside the object, on the heap.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以存储在栈和堆上。如果引用是方法中的局部变量，那么引用就存储在栈上（在该方法帧的局部方法数组中）。如果引用是实例变量，那么引用存储在对象内部，在堆上。
- en: 'By way of comparison with objects, we can have a reference of an **abstract
    class** but not an object of an abstract class. The same applies to interfaces
    – we can have an **interface** reference type, but you cannot instantiate an interface;
    that is, you cannot create an object of an interface type. Both situations are
    demonstrated in *Figure 2**.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与对象的比较，我们可以有一个**抽象类**的引用，但不能有抽象类的对象。同样适用于接口——我们可以有一个**接口**引用类型，但不能实例化接口；也就是说，不能创建接口类型的对象。这两种情况都在**图2.1**中得到了演示：
- en: '![Figure 2.1 – Object instantiation errors](img/Figure_2.1_B18762.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 对象实例化错误](img/Figure_2.1_B18762.jpg)'
- en: Figure 2.1 – Object instantiation errors
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 对象实例化错误
- en: 'In *Figure 2**.1*, the references declared on lines `10` and `13`, an abstract
    class and an interface reference, respectively, have no issue. However, attempting
    to create an object of these types on lines `11` and `14` causes errors. Feel
    free to try out this code, contained in `ch2` folder here: [https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2](https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2).
    The reason for the compiler errors is that you cannot create an object based on
    an abstract class or interface. We will address these errors in the next section.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图2.1**中，第10行和第13行声明的引用，分别是抽象类和接口引用，没有问题。然而，尝试在第11行和第14行创建这些类型的对象会导致错误。您可以自由尝试这段代码，它位于此处的`ch2`文件夹中：[https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2](https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2)。编译错误的原因是您不能基于抽象类或接口创建对象。我们将在下一节中解决这些错误。
- en: Now that we have discussed references, let us examine objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了引用，让我们来考察对象。
- en: Objects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: All objects are stored on the heap. To understand objects, we must first understand
    a fundamental construct in OOP, the class. A class is similar to the plan of a
    house. With the plan of the house, you can view it and discuss it, but you cannot
    open any doors, put the kettle on, and so on. This is what classes are in OOP
    – they are views of what the object will look like in memory. When the house is
    built, you can now open the doors, have a cup of tea, and so forth. When the object
    is built, you have an in-memory representation of the class. Using the reference,
    we can access the instance members using the dot notation syntax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都存储在堆上。为了理解对象，我们首先必须理解面向对象编程中的一个基本结构，即类。类类似于房子的设计图。有了房子的设计图，你可以查看并讨论它，但你不能打开任何门，放水壶，等等。这就是面向对象编程中的类
    – 它们是对象在内存中外观的视图。当房子建成时，你现在可以打开门，喝杯茶，等等。当对象创建时，你就有了一个类的内存表示。使用引用，我们可以使用点符号语法访问实例成员。
- en: 'Let us address the compiler issues from *Figure 2**.1* and, in addition, show
    the dot notation syntax in operation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决 *图 2*.1 中的编译器问题，并展示点符号语法在实际操作中的使用：
- en: '![Figure 2.2 – The interface and abstract class references fixed](img/Figure_2.2_B18762.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 接口和抽象类引用已固定](img/Figure_2.2_B18762.jpg)'
- en: Figure 2.2 – The interface and abstract class references fixed
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 接口和抽象类引用已固定
- en: In *Figure 2**.2*, as lines 11 and 15 compile without any error, they demonstrate
    that the class must be a non-abstract (concrete) class before an object based
    on it can be instantiated (created). Lines 12 and 16 demonstrate the dot notation
    syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2*.2 中，由于第 11 行和第 15 行编译时没有出现任何错误，这表明在基于该类创建对象之前，该类必须是非抽象（具体）类。第 12 行和第
    16 行演示了点符号语法。
- en: Let us now examine in more detail the creation of an object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考察对象的创建。
- en: How to create objects
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何创建对象
- en: 'Objects are instantiated (created) using the `new` keyword. The purpose of
    `new` is to create an object on the heap and return its address, which we store
    in a reference variable. Line 11 from *Figure 2**.2* has the following line of
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是通过使用 `new` 关键字实例化的（创建）。`new` 的目的是在堆上创建一个对象并返回其地址，我们将它存储在一个引用变量中。*图 2*.2 中的第
    11 行有如下代码：
- en: '`h =` `new Person();`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`h = new Person();`'
- en: The reference is on the left-hand side of the assignment operator – we are initializing
    an `h` reference of type `Human`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 引用位于赋值运算符的左侧 – 我们正在初始化一个 `Human` 类型的 `h` 引用。
- en: The object to be instantiated is on the right-hand side of the assignment operator
    – we are creating an object of type `Person`, and the default `Person` constructor
    is executed. This default constructor is synthesized by the compiler (as there
    is no explicit `Person` constructor present in the code).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化的对象位于赋值运算符的右侧 – 我们正在创建一个 `Person` 类型的对象，并执行默认的 `Person` 构造函数。这个默认构造函数是由编译器合成的（因为代码中没有显式的
    `Person` 构造函数）。
- en: Now that we have looked at both objects and references, let us expand the example
    and, using a diagram, view both the stack and heap representations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了对象和引用，让我们扩展这个例子，并使用图表来查看栈和堆的表示。
- en: Understanding the differences between references and objects
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解引用和对象之间的区别
- en: 'In order to contrast the stack and the heap, both the `Person` class and the
    `main()` method have been changed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比栈和堆，`Person` 类和 `main()` 方法都进行了更改：
- en: '![Figure 2.3 – Stack and heap code](img/Figure_2.3_B18762.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 栈和堆代码](img/Figure_2.3_B18762.jpg)'
- en: Figure 2.3 – Stack and heap code
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 栈和堆代码
- en: '*Figure 2**.3* details a `Person` class containing two instance variables,
    a constructor taking two parameters, and the `toString()` instance method. The
    second class, `StackAndHeap`, is the driver class (it contains the `main()` method).
    In `main()`, we initialize a local primitive variable, `x`, and instantiate an
    instance of `Person`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2*.3 详细说明了包含两个实例变量、接受两个参数的构造函数和 `toString()` 实例方法的 `Person` 类。第二个类 `StackAndHeap`
    是驱动类（它包含 `main()` 方法）。在 `main()` 中，我们初始化一个局部原始变量 `x` 并实例化一个 `Person` 实例。'
- en: '*Figure 2**.4* shows the stack and heap representations after line 27 has been
    executed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2*.4 展示了执行第 27 行之后的栈和堆表示：'
- en: '![Figure 2.4 – A stack and heap representation of the code in Figure 2.3](img/Figure_2.4_B18762.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 图 2.3 中的代码的栈和堆表示](img/Figure_2.4_B18762.jpg)'
- en: Figure 2.4 – A stack and heap representation of the code in Figure 2.3
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 图 2.3 中代码的栈和堆表示
- en: Referring to *Figure 2**.3*, the first method to execute is `main()` on line
    23\. This results in a frame for `main()` being pushed onto the stack. The local
    variables `args` and `x` are stored in the local variable array in this frame.
    On line 25, we create an instance of `Person` passing in the `String` literal,
    `Joe Bloggs`, and the integer literal, `23`. Any `String` literal is itself a
    `String` object and is stored on the heap. In addition, as it is a `String` literal,
    this `String` object is stored in a special area of the heap called the **String
    Pool** (also known as the String Constant Pool).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图2**.3**，首先执行的是第23行的`main()`方法。这导致`main()`的帧被压入栈中。在这个帧中，局部变量`args`和`x`被存储在局部变量数组中。在第25行，我们创建了一个`Person`实例，传递了`String`字面量`Joe
    Bloggs`和整数字面量`23`。任何`String`字面量本身就是一个`String`对象，并且存储在堆上。此外，由于它是一个`String`字面量，这个`String`对象存储在堆的一个特殊区域，称为**字符串池**（也称为字符串常量池）。
- en: The instance variable `name` inside the `Person` object resides on the heap
    and is a `String` type; that is, it is a reference variable, and it refers to
    the `Person`, namely `age`, is a primitive, and its value of `23` is stored directly
    inside the object on the heap. However, the reference to the `Person` object,
    `joeBloggs`, is stored on the stack, in the frame for the `main()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`对象内部的实例变量`name`位于堆上，是`String`类型；也就是说，它是一个引用变量，它引用了`Person`对象，而`age`是一个原始类型，其值为`23`直接存储在堆上的对象内部。然而，`Person`对象的引用`joeBloggs`存储在栈上，在`main()`方法的帧中。'
- en: On line 26 in *Figure 2**.3*, we output the local variable, `x`, which outputs
    `0` to the standard output device (typically the screen). Line 27 is then executed,
    as shown in *Figure 2**.4*. First, the `println()` method from `PrintStream` (`out`
    is of type `PrintStream`) causes a frame to be pushed onto the stack. In order
    to simplify the diagram, we have not gone into any detail in that stack frame.
    Before `println()` can complete execution, `joeBloggs.toString()` must first be
    executed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图2**.3的第26行，我们输出局部变量`x`，它将`0`输出到标准输出设备（通常是屏幕）。第27行随后被执行，如**图2**.4所示。首先，`PrintStream`中的`println()`方法（`out`是`PrintStream`类型）导致一个帧被压入栈中。为了简化图示，我们没有深入到那个栈帧的细节。在`println()`完成执行之前，必须首先执行`joeBloggs.toString()`。
- en: As the `toString()` method in `Person` has now been invoked/called, a new frame
    for `toString()` is pushed onto the stack on top of the `println()` frame. Next,
    `toString()` builds up a local `String` variable named `decoratedName` using `String`
    literals and the instance variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Person`中的`toString()`方法已经被调用，一个新的`toString()`帧被压入栈中，位于`println()`帧之上。接下来，`toString()`使用`String`字面量和实例变量构建一个名为`decoratedName`的局部`String`变量。
- en: As you are probably aware, if you have a `String` instance on the left or the
    right of a `+` operator, the overall operation becomes a `String` append and you
    end up with a `String` result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，如果你在`+`运算符的左边或右边有一个`String`实例，整个操作就变成了`String`连接，最终得到一个`String`结果。
- en: These `String` literals are stored in the String Pool. The final `String` result
    is *My name is Joe Bloggs and I am 23 years old*, which is assigned to the local
    variable, `decoratedName`. This String is returned from `toString()` back to the
    `println()` statement on line `27` that called it. The returned `String` is then
    echoed to the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`String`字面量存储在字符串池中。最终的`String`结果是`My name is Joe Bloggs and I am 23 years
    old`，它被分配给局部变量`decoratedName`。这个`String`从`toString()`返回到调用它的第27行的`println()`语句。然后，返回的`String`被回显到屏幕上。
- en: That concludes our section on storing objects on the heap. Now we will turn
    our attention to areas that can cause subtle issues in your code. However, now
    that we have separated the reference from the object, these issues will be much
    easier to understand and fix.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们在堆上存储对象的章节。现在我们将注意力转向可能导致代码中微妙问题的区域。然而，由于我们已经将引用与对象分离，这些问题将更容易理解和修复。
- en: Managing object references and security
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象引用和安全
- en: In this section, we are going to examine object references and a subtle security
    issue that can arise if references are not managed with due care. This security
    issue is called *escaping references* and we will explain when and how it occurs
    with the aid of an example. In addition, we will fix the issue in the example,
    demonstrating how to address this security concern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查对象引用和一个可能出现的微妙安全问题，如果引用没有得到适当的关注，这个问题就会发生。这个安全问题被称为*逃逸引用*，我们将通过一个示例来解释它何时以及如何发生。此外，我们将在示例中修复这个问题，展示如何解决这个安全问题。
- en: Inspecting the escaping references issue
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查逃逸引用问题
- en: In this section, we will discuss and provide an example of Java’s call-by-value
    parameter passing mechanism. Once we understand call-by-value, this will enable
    us to demonstrate the issue that occurs when passing (or returning) references.
    Let us start with Java’s call-by-value mechanism.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论并提供一个 Java 值调用参数传递机制的示例。一旦我们理解了值调用，这将使我们能够演示在传递（或返回）引用时发生的问题。让我们从
    Java 的值调用机制开始。
- en: Call-by-value
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值调用
- en: 'Java uses call-by-value when passing parameters to methods and returning results
    from methods. Put simply, this means that Java *makes a copy of something*. In
    other words, when you are passing an argument to a method, a copy is made of that
    argument, and when you are returning a result from a method, a copy is made of
    that result. Why do we care? Well, what you are copying – a primitive or a reference
    – can have major implications (especially for mutable types, such as **StringBuilder**
    and **ArrayList**). This is what we want to dig into further here. We will use
    a sample program and an associated diagram to help. *Figure 2**.5* shows the sample
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在向方法传递参数和从方法返回结果时使用值调用。简单来说，这意味着 Java *会复制某个东西*。换句话说，当你向方法传递一个参数时，会复制该参数，当你从方法返回一个结果时，会复制该结果。我们为什么要关心这个呢？因为你正在复制的
    – 一个原始值或引用 – 可能会有重大影响（特别是对于可变类型，如 **StringBuilder** 和 **ArrayList**）。这正是我们想要进一步探讨的。我们将使用一个示例程序和相关图表来帮助。*图
    2.5* 展示了示例代码：
- en: '![Figure 2.5 – A call-by-value code sample](img/Figure_2.5_B18762.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 值调用代码示例](img/Figure_2.5_B18762.jpg)'
- en: Figure 2.5 – A call-by-value code sample
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 值调用代码示例
- en: '*Figure 2**.5* details a program where we have a simple `Person` class with
    two properties: a `String` name and an `int` (primitive) age. The constructor
    enables us to initialize the object state, and we have accessor/mutator methods
    for the instance variables.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.5* 详细说明了有一个简单 `Person` 类的程序，该类有两个属性：一个 `String` 类型的名称和一个 `int`（原始类型）的年龄。构造函数使我们能够初始化对象状态，我们为实例变量提供了访问器/修改器方法。'
- en: The `CallByValue` class is the driver class. In `main()` on line `27`, a local
    primitive `int` variable, namely `age`, is declared and initialized to `20`. On
    line `28`, we create an object of type `Person`, passing in the `String` literal,
    `John`, and the primitive variable, `age`. Based on these arguments, we initialize
    the object state. The reference, namely `john`, is the local variable used to
    store the reference to the `Person` object on the heap. *Figure 2**.6* shows the
    state of memory after line 28 has finished executing. For clarity, we have omitted
    the `args` array object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallByValue` 类是驱动类。在 `main()` 函数的第 `27` 行，声明并初始化了一个局部原始 `int` 变量，即 `age`，其值为
    `20`。在第 `28` 行，我们创建了一个 `Person` 类型的对象，传递了字符串字面量 `John` 和原始变量 `age`。基于这些参数，我们初始化了对象状态。引用，即
    `john`，是用于在堆上存储 `Person` 对象引用的局部变量。*图 2.6* 展示了第 `28` 行执行完毕后内存的状态。为了清晰起见，我们省略了
    `args` 数组对象。'
- en: '![Figure 2.6 – The initial state of the stack and the heap](img/Figure_2.6_B18762.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 栈和堆的初始状态](img/Figure_2.6_B18762.jpg)'
- en: Figure 2.6 – The initial state of the stack and the heap
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 栈和堆的初始状态
- en: 'As *Figure 2**.6* shows, the frame for the `main()` method is the current frame
    on the stack. It contains two local variables: the `int` primitive age with its
    value of `20` and the `Person` reference, `john`, referring to the `Person` object
    on the heap. The `Person` object has its two instance variables initialized: the
    `age` primitive variable is set to `20` and the name `String` instance variable
    is referring to the *John* `String` object in the String Pool (as *John* is a
    `String` literal, Java stores it there).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 2.6* 所示，`main()` 方法的框架是当前栈上的框架。它包含两个局部变量：值为 `20` 的 `int` 原始类型年龄和指向堆上 `Person`
    对象的 `Person` 引用 `john`。`Person` 对象有两个实例变量被初始化：`age` 原始类型变量被设置为 `20`，名称 `String`
    实例变量指向字符串池中的 *John* `String` 对象（因为 *John* 是一个 `String` 字面量，Java 会将其存储在那里）。
- en: 'Now, we execute line 29, `change(john, age);` in *Figure 2**.5*. This is where
    it gets interesting. We call the `change()` method, passing down the `john` reference
    and the `age` primitive. As Java is call-by-value, a copy is made of each of the
    arguments. *Figure 2**.7* shows the stack and the heap just as we enter the `change()`
    method and are about to execute its first instruction on line 34:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 *图 2**.5* 中执行第 29 行，`change(john, age);`。这里很有趣。我们调用`change()`方法，传递`john`引用和`age`原始值。由于Java是按值调用，每个参数都会被复制。*图
    2**.7* 展示了我们进入`change()`方法并即将执行第 34 行的第一条指令时的栈和堆：
- en: '![  Figure 2.7 – The stack and heap as the change() method is entered](img/Figure_2.7_B18762.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![  图 2.7 – 进入 change() 方法时的栈和堆](img/Figure_2.7_B18762.jpg)'
- en: Figure 2.7 – The stack and heap as the change() method is entered
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 进入 change() 方法时的栈和堆
- en: In the preceding figure, we can see that a frame has been pushed onto the stack
    for the `change()` method. As Java is call-by-value, a copy is made of both arguments
    into local variables in the method, namely `age` and `adult`. The difference here
    is crucial and requires subsections as a result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到为`change()`方法压入栈中的一个帧。由于Java是按值调用，方法中的两个参数都被复制到局部变量中，即`age`和`adult`。这里的区别是至关重要的，因此需要分节来解释。
- en: Copying a primitive
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制一个原始值
- en: Copying a primitive is similar to photocopying a sheet of paper. If you hand
    the photocopy to someone else, they can do whatever they want to that sheet –
    you still have the original. This is what is going to happen in this program;
    the called `change()` method will alter the primitive `age` variable, but the
    copy of `age` back in `main()` will be untouched.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个原始值类似于复印一张纸。如果你把复印件交给别人，他们可以随意处理那张纸 – 你仍然有原件。在这个程序中将要发生的就是这样；被调用的`change()`方法将改变原始`age`变量，但`main()`中的`age`的副本将保持不变。
- en: Copying a reference
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制一个引用
- en: Copying a reference is similar to copying a remote control for a television.
    If you hand the second/copy remote to someone else, they can change the channel
    that you are watching. This is what is going to happen in this program; the called
    `change()` method will, using the `adult` reference, alter the `name` instance
    variable in the `Person` object and the `john` reference back in `main()` will
    see that change.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个引用类似于复制电视遥控器。如果你把第二个/复制的遥控器交给别人，他们可以改变你正在观看的频道。在这个程序中将要发生的就是这样；被调用的`change()`方法将使用`adult`引用，改变`Person`对象中的`name`实例变量，而`main()`中的`john`引用将看到这个变化。
- en: 'Going back to the code example from *Figure 2**.5*, *Figure 2**.8* shows the
    stack and heap after lines 34 and 35 have finished executing but *before* the
    `change()` method returns to `main()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 *图 2**.5* 的代码示例。*图 2**.8* 展示了在执行完第 34 和 35 行之后，但 *在`change()`方法返回到`main()`之前*
    的栈和堆：
- en: '![  Figure 2.8 – The stack and heap as the change() method is exiting](img/Figure_2.8_B18762.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![  图 2.8 – change() 方法退出时的栈和堆](img/Figure_2.8_B18762.jpg)'
- en: Figure 2.8 – The stack and heap as the change() method is exiting
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – change() 方法退出时的栈和堆
- en: As can be seen, the `age` primitive in the method frame for `change()` has been
    changed to `90`. In addition, a new `String` literal object is created for *Michael*
    in the String Pool and the `name` instance variable in the `Person` object is
    referring to it. This is because `String` objects are immutable; that is, once
    initialized, you cannot change the contents of `String` objects. Note that the
    *John* `String` object in the String Pool is now eligible for garbage collection,
    as there are no references to it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`change()`方法帧中的`age`原始值已被更改为`90`。此外，在字符串池中为*Michael*创建了一个新的`String`字面量对象，并且`Person`对象中的`name`实例变量正在引用它。这是因为`String`对象是不可变的；也就是说，一旦初始化，就不能更改`String`对象的内容。请注意，字符串池中的*John*
    `String`对象现在可以回收垃圾，因为没有引用指向它。
- en: '*Figure 2**.9* show the state of the stack and heap after the `change()` method
    has finished executing and control has returned to the `main()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.9* 展示了`change()`方法执行完成后并控制返回到`main()`方法后的栈和堆状态：'
- en: '![  Figure 2.9 – The stack and heap after the change() method has finished](img/Figure_2.9_B18762.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![  图 2.9 – change() 方法完成后栈和堆的状态](img/Figure_2.9_B18762.jpg)'
- en: Figure 2.9 – The stack and heap after the change() method has finished
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – change() 方法完成后栈和堆的状态
- en: In *Figure 2**.9*, the frame on the stack for the `change()` method has been
    popped. The frame for the `main()` method is now, once again, the current frame.
    You can see that the `age` primitive is unchanged, that is, it is still `20`.
    The reference is also the same. However, the `change()` method was able to change
    the instance variable that `john` was looking at. Line 30, `System.out.println(john.getName()
    + " " + age);`, proves what has occurred by outputting *Michael 20*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2**.9*中，`change()`方法的栈帧已经被弹出。现在，`main()`方法的栈帧再次成为当前帧。你可以看到`age`原始值没有改变，即它仍然是`20`。引用也是相同的。然而，`change()`方法能够改变`john`正在查看的实例变量。第30行`System.out.println(john.getName()
    + " " + age);`通过输出*Michael 20*证明了所发生的事情。
- en: Now that we understand Java’s call-by-value mechanism, we will now discuss escaping
    references with the aid of an example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Java的按值调用机制，我们将通过一个示例来讨论逃逸引用。
- en: The problem
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问题
- en: 'The principle of encapsulation in OOP is that a class’s data is `private` and
    accessible to external classes via its `public` API. However, in certain situations,
    this is not enough to protect your `private` data due to escaping references.
    *Figure 2**.10* is an example of a class that suffers from escaping references:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的封装原则是，一个类的数据是`private`的，并且可以通过其`public` API供外部类访问。然而，由于逃逸引用，在某些情况下，这不足以保护你的`private`数据。*图2**.10*是一个受逃逸引用影响的类的例子：
- en: '![   Figure 2.10 – Code with escaping references](img/Figure_2.10_B18762.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 具有逃逸引用的代码](img/Figure_2.10_B18762.jpg)'
- en: Figure 2.10 – Code with escaping references
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 具有逃逸引用的代码
- en: The preceding figure contains a `Person` class with one `private` instance variable,
    a `StringBuilder` called `name`. The `Person` constructor initializes the instance
    variable based on the argument passed in. The class also provides a `public getName()`
    accessor method to enable external classes to retrieve the `private` instance
    variable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中包含一个`Person`类，它有一个名为`name`的`private`实例变量。`Person`构造函数根据传入的参数初始化实例变量。该类还提供了一个`public
    getName()`访问方法，以便外部类可以检索`private`实例变量。
- en: The driver class here is `EscapingReferences`. In `main()`, on line 16, a local
    `StringBuilder` object is created, containing the `String` *Dan* and `sb` is the
    name of the local reference. This reference is passed into the `Person` constructor
    in order to initialize the `name` instance variable in the `Person` object. *Figure
    2**.11* shows the stack and heap at this point, that is, just after line 17 has
    finished executing. The String Pool is omitted, in the interests of clarity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，驱动类是`EscapingReferences`。在`main()`函数中，第16行创建了一个局部`StringBuilder`对象，包含字符串`Dan`，而`sb`是该局部引用的名称。这个引用被传递到`Person`构造函数中，以便初始化`Person`对象中的`name`实例变量。*图2**.11*显示了此时的栈和堆，即第17行执行完毕后。为了清晰起见，省略了字符串池。
- en: '![Figure 2.11 – Escaping references on the way in](img/Figure_2.11_B18762.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 逃逸引用的输入过程](img/Figure_2.11_B18762.jpg)'
- en: Figure 2.11 – Escaping references on the way in
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 逃逸引用的输入过程
- en: At this point, the issue of escaping references is emerging. Upon executing
    the `Person` constructor, a copy of the `sb` reference is passed in, where it
    is stored in the `name` instance variable. Now, as *Figure 2**.11* shows, both
    the `name` instance variable and the local `main()` variable, `sb`, refer to the
    same `StringBuilder` object!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，逃逸引用的问题开始显现。在执行`Person`构造函数时，传递了一个`sb`引用的副本，它被存储在`name`实例变量中。现在，如*图2**.11*所示，`name`实例变量和局部`main()`变量`sb`都引用了同一个`StringBuilder`对象！
- en: Now, when line 18 executes in `main()`, that is, `sb.append("Dan");`, the object
    is changed to `DanDan` for *both* the local `sb` reference and the `name` instance
    variable. When we output the instance variable on line 19, it outputs *DanDan*,
    reflecting the change.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`main()`函数中的第18行执行时，即`sb.append("Dan");`，对象变为`DanDan`，对于*本地*的`sb`引用和`name`实例变量都是如此。当我们第19行输出实例变量时，它输出*DanDan*，反映了这种变化。
- en: 'So, that is one issue on the way in: initializing our instance variables to
    the (copies of) the references passed in. We will address how to fix that shortly.
    On the way out, however, we also have an issue. *Figure 2**.12* demonstrates this
    issue:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是进入过程中一个问题：将我们的实例变量初始化为传入的（副本）引用。我们将在稍后解决如何修复它。然而，在输出过程中，我们也有一个问题。*图2**.12*展示了这个问题：
- en: '![Figure 2.12 – Escaping references on the way out](img/Figure_2.12_B18762.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 逃逸引用的输出过程](img/Figure_2.12_B18762.jpg)'
- en: Figure 2.12 – Escaping references on the way out
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 逃逸引用的输出过程
- en: '*Figure 2**.12* shows the stack and heap after line 21, `StringBuilder sb2
    = p.getName();`, executes. Again, we have a local reference, this time called
    `sb2`, which refers to the same object that the `name` instance variable in the
    `Person` object on the heap is referring to. Thus, when we use the `sb2` reference
    to append `Dan` to the `StringBuilder` object and then output the instance variable,
    we get `DanDanDan`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “图2.12”显示了执行第21行`StringBuilder sb2 = p.getName();`之后的栈和堆。再次，我们有一个局部引用，这次称为`sb2`，它指向堆中`Person`对象的`name`实例变量所指向的同一对象。因此，当我们使用`sb2`引用将`Dan`追加到`StringBuilder`对象，然后输出实例变量时，我们得到`DanDanDan`。
- en: 'At this point, it is clear that just having your data `private` is not enough.
    The problem arises because `StringBuilder` is a mutable type, which means, at
    any time, you can change the (original) object. Contrast this with `String` objects,
    which are immutable (as are the wrapper types, for example: `Double`, `Integer`,
    `Float`, and `Character`).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显，仅仅将数据`private`是不够的。问题在于`StringBuilder`是一个可变类型，这意味着在任何时候，你都可以更改（原始）对象。这与不可变的`String`对象（例如：`Double`、`Integer`、`Float`和`Character`的包装类型）形成对比。
- en: Immutability
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性
- en: Java protects **String** objects because any change to a **String** object results
    in the creation of a completely new object (with the changes reflected). Thus,
    the code requesting a *change* will see the requested change (it’s just that it
    is a completely new object). The original **String** object that others may have
    been looking at is still untouched.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Java保护**String**对象，因为对**String**对象的任何更改都会导致创建一个完全新的对象（更改反映在其中）。因此，请求*更改*的代码将看到请求的更改（只是它是一个全新的对象）。其他人可能看到的原始**String**对象仍然未受影响。
- en: Now that we have discussed the issues with escaping references, let us examine
    how to solve them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了逃逸引用的问题，让我们看看如何解决这些问题。
- en: Finding a solution
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找解决方案
- en: Essentially, the solution revolves around a practice known as *defensive copying*.
    In this scenario, we do not want to store a copy of the reference for any mutable
    object. The same holds for returning references to our `private` mutable data
    in our accessor methods – we do not want to return a copy of the reference to
    the calling code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，解决方案围绕一种称为*防御性复制*的实践。在这种情况下，我们不想为任何可变对象存储引用的副本。同样，对于我们在访问器方法中返回的`private`可变数据的引用也适用
    – 我们不想返回引用的副本给调用代码。
- en: 'Therefore, we need to be careful both on the way in and on the way out. The
    solution is to copy the object contents completely in both scenarios. This is
    known as a deep copy (whereas copying the references only is known as a shallow
    copy). Thus, on the way in, we copy the contents of the object into a new object
    and store the reference to the new object. On the way out, we copy the contents
    again and return the reference to the new object. We have protected our code in
    both scenarios. *Figure 2**.13* shows the solution to the previous code from *Figure
    2**.10*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在进入和退出时都需要小心。解决方案是在这两种情况下完全复制对象内容。这被称为深度复制（而只复制引用则称为浅度复制）。因此，在进入时，我们将对象的内容复制到一个新对象中，并存储对新对象的引用。在退出时，我们再次复制内容，并返回对新对象的引用。我们已经在这两种情况下保护了我们的代码。“图2.13”显示了从“图2.10”中解决问题的方案：
- en: '![Figure 2.13 – Escaping references code fixed](img/Figure_2.13_B18762.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 逃逸引用代码修复](img/Figure_2.13_B18762.jpg)'
- en: Figure 2.13 – Escaping references code fixed
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 逃逸引用代码修复
- en: 'Line 7 shows the creation of the copy object on the way in (the constructor).
    Line 10 shows the creation of the copy object on the way out (the accessor method).
    Both lines 19 and 23 output `Dan`, as they should. *Figure 2**.14* represents
    the stack and heap as the program is about to exit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行显示了在进入时（构造函数）创建的副本对象。第10行显示了在退出时（访问器方法）创建的副本对象。第19行和第23行都输出了`Dan`，正如它们应该做的那样。图2.14表示程序即将退出时的栈和堆：
- en: '![Figure 2.14 – The stack and heap for escaping references code fix](img/Figure_2.14_B18762.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 逃逸引用代码修复的栈和堆](img/Figure_2.14_B18762.jpg)'
- en: Figure 2.14 – The stack and heap for escaping references code fix
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 逃逸引用代码修复的栈和堆
- en: 'For clarity, we omit the String Pool. We have numbered the `StringBuilder`
    objects 1 to 5\. We can match the objects to the code as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们省略了字符串池。我们已将`StringBuilder`对象编号为1到5。我们可以按照以下方式将对象与代码匹配：
- en: Line 16 creates object 1.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第16行创建了对象1。
- en: Line 17, which calls line 7, creates object 2\. The `Person` instance variable
    `name` refers to this object.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第17行调用了第7行，创建了对象2。`Person`实例变量`name`引用了这个对象。
- en: Line 18 modifies object 1, changing it to `DanDan` (note, however, that the
    object referred to by the `name` instance variable, that is, object 2, is untouched).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第18行修改了对象1，将其改为`DanDan`（然而，请注意，由`name`实例变量引用的对象，即对象2，未受到影响）。
- en: Line 19 creates object 3\. The reference is passed back to `main()` but never
    stored. As *Dan* is output, this proves that the defensive copying on the way
    *in* is working.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第19行创建了对象3。引用被传回`main()`函数，但从未被存储。由于输出了`Dan`，这证明了在输入过程中的防御性复制正在起作用。
- en: Line 21 creates object 4\. The local `main()` reference, `sb2`, refers to it.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第21行创建了对象4。局部`main()`引用`sb2`指向它。
- en: Line 22 amends object 4 to *DanDan* (leaving the object that the instance variable
    is referring to untouched).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第22行将对象4修改为`DanDan`（未修改实例变量所引用的对象）。
- en: Line 23 creates object 5\. As *Dan* is output, this proves that the defensive
    copying on the way *out* is working.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第23行创建了对象5。由于输出了`Dan`，这证明了在输出过程中的防御性复制正在起作用。
- en: '*Figure 2**.14* shows that the StringBuilder object referred to by the `name`
    instance variable never changes from *Dan*. This is exactly what we wanted.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.14*显示，由`name`实例变量引用的`StringBuilder`对象从未从`Dan`改变。这正是我们想要的。'
- en: That wraps up this chapter. We have covered a lot, so let us recap the major
    points.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。我们涵盖了很多内容，所以让我们回顾一下主要观点。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by examining how primitives are stored in memory.
    Primitives are predefined types that come with the language and can be stored
    on both the stack (local variables) and on the heap (instance variables). It is
    easy to identify primitives as they have all lowercase letters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先检查了原始数据类型在内存中的存储方式。原始数据类型是语言自带预定义的类型，可以存储在栈上（局部变量）和堆上（实例变量）。由于它们全部都是小写字母，因此很容易识别原始数据类型。
- en: In contrast, objects are only stored on the heap. In discussing objects, it
    was necessary to distinguish between references and the objects themselves. We
    discovered that while references can be of any type (interface, abstract class,
    and class), objects themselves can only be of proper, concrete classes, meaning
    the class must not be **abstract**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对象只存储在堆上。在讨论对象时，有必要区分引用和对象本身。我们发现，虽然引用可以是任何类型（接口、抽象类和类），但对象本身只能属于正确的、具体的类，这意味着该类不能是**抽象的**。
- en: Manage object references with care. If not managed properly, you could end up
    with *escaping references*. Java uses call-by-value, which means a copy is made
    of the argument passed or returned. Depending on whether the argument is a primitive
    or reference, it can have major implications. If it’s a copy of a reference to
    a mutable type, then the calling code can change your supposedly `private` data.
    This is not proper encapsulation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小心管理对象引用。如果没有正确管理，你可能会遇到*逃逸引用*。Java使用按值调用，这意味着传递或返回的参数会创建一个副本。根据参数是原始数据类型还是引用类型，这可能会产生重大影响。如果它是可变类型的引用副本，那么调用代码可以更改你所谓的`private`数据。这不是适当的封装。
- en: We examined code with this issue and associated diagrams of the stack and heap.
    The solution is to use defensive copying, that is, copying the object contents
    both on the way in and on the way out. *Thus, the references and the objects they
    refer to remain private*. Lastly, we detailed the code solution and associated
    diagrams of the stack and heap.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了存在此问题的代码以及栈和堆的关联图。解决方案是使用防御性复制，即在输入和输出过程中复制对象内容。*因此，引用及其所引用的对象保持私有*。最后，我们详细介绍了代码解决方案以及栈和堆的关联图。
- en: In the next chapter, we are going to take a closer look at the heap, the area
    of memory where objects live.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨堆，这是对象居住的内存区域。
