- en: Optimizing the Sort - Making Code Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop the sorting code and make it more general.
    We want to sort not only an array of Strings. Essentially, we will write a program
    that can sort anything that is sortable. That way, we will bring the coding to
    its full extent toward one of the major strengths of Java: *abstraction*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstraction, however, does not come without a price tag. When you have a class
    that sorts strings and you accidentally mix an integer or something else, which
    is not a string, into the sortable data, then the compiler will complain about
    it: Java does not allow you to put an `int` into a `String` array. When the code
    is more abstract, such programming errors may slip in. We will look at how to
    handle such exceptional cases catching and throwing Exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: To identify the bugs, we will use unit testing, applying the industry standard
    JUnit version 4\. As JUnit heavily uses annotation, and because annotations are
    important, you will learn about it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will modify the code to use the *generics* feature of Java that
    was introduced into the language in version 5\. Using that possibility, we will
    catch the coding error during compilation time, which is better than during run
    time. The earlier a bug is identified, the cheaper it is to fix.
  prefs: []
  type: TYPE_NORMAL
- en: For the build, we will still use Maven, but this time, we will split the code
    into small modules. Thus, we will have a multi-module project. We will have separate
    modules for the definition of a sorting module and for the different implementations.
    That way, we will look at how classes can extend each other and implement interfaces,
    and, generally, we will really start to program in the object-oriented way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also discuss **Test Driven Development** (**TDD**), and at the end
    of the section, we will start using the brand new feature of Java 9: module support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithmic complexity and quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general sorting program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a simple sort algorithm. The code can
    sort elements of a `String` array. We did this to learn. For practical use, there
    is a ready cooked sort solution in the JDK that can sort members of `collections`,
    which are comparable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JDK contains a utility class called `Collections`. This class contains
    a static `Collections.sort` method that is capable of sorting any `List` that
    has members that are `Comparable`. `List` and `Comparable` are interfaces defined
    in the JDK. Thus, if we want to sort a list of Strings, the simplest solution
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code fragment is from a sample JUnit test, which is the reason we have
    the `@Test` annotation in front of the method. We will discuss that in detail
    later. To execute that test, you can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This sort implementation, however, does not fit our needs. First of all, because
    it is there ready (no need to code) and using it does not need anything new that
    you have not learned in the previous chapters. Except for the annotation in front
    of the method, there is nothing new in the code that you cannot understand. You
    may refresh BY turning some pages back, or else consult the oracle online documentation
    of the JDK ([https://docs.oracle.com/javase/8/docs/api/](https://docs.oracle.com/javase/8/docs/api/)),
    but that is all. You already know these things.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why I wrote the URL for the Java version 8 API to the link. Well,
    then this is the moment of honesty and truth-when I wrote this book, the Java
    9 JDK was not available in its final form. I created most of the examples on my
    Mac Book using Java 8 and I only tested the features that are Java 9 specific.
    Support at the moment for Java 9 in the IDEs is not perfect. When you read this
    book, Java 9 will be available, so you can try and change that one single digit
    from 8 to 9 in the URL and get to the documentation of the version 9\. At the
    moment, I get HTTP ERROR 404.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you may need the documentation of older versions. You can use 3,
    4, 5, 6, or 7 instead of 8 in the URL. Documentation for 3 and 4 is not available
    to read online, but it can be downloaded. Hopefully, you will never need that
    anymore. Version 5, perhaps. Version 6 is still widely used at large corporations.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can learn a lot from reading code that was written by other programmers,
    I do not recommend trying to learn from the JDK source code at this early stage
    of your studies. These blocks of code are heavily optimized, not meant to be tutorial
    codes, and old. They do not get rusted during the years, but they were not refactored
    to follow the coding styles of Java as it matured. At some places, you can find
    really ugly code in the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, saying that we need to develop a new sort code because we can learn from
    it, is a bit contrived. The real reason why we need a sort implementation is that
    we want something that can sort not only `List` data types and a  `List` of something
    that implements the `Comparable` interface. We want to sort a bunch of objects.
    All we require is that the *bunch* containing the objects provides simple methods
    that are just enough to sort them and have a sorted *bunch*.
  prefs: []
  type: TYPE_NORMAL
- en: Originally I wanted to use the word *collection* instead of *bunch*, but there
    is a `Collection` interface in Java and I wanted to emphasize that we are not
    talking about `java.util.Collection` of objects.
  prefs: []
  type: TYPE_NORMAL
- en: We also do not want the objects to implement the `Comparable` interface. If
    we require the object to implement the `Comparable` interface, it may violate
    the **Single Responsibility Principle** (**SRP**).
  prefs: []
  type: TYPE_NORMAL
- en: When we design a class, it should model some object class of the real world.
    We will model the problem space with classes. The class should implement the features
    that represent the behavior of the objects that it models. If we look at the example
    of students from the second chapter, then a `Student` class should represent the
    features that all students share, and is *important from the modeling point of
    view*. A `Student` object should be able to tell the name of the student, the
    age, the average scores of the last year, and so on. All students have feet, and
    certainly each of those feet have size so we may think that a `Student` class
    should also implement a method that returns the size of the student's foot (one
    for the left and one for the right just to be precise), but we do not. We do not,
    because the size of the foot is irrelevant from the model point of view. If we
    want to sort a list containing `Student` objects, the `Student` class has to implement
    the `Comparable` interface. But wait! How do you compare two students? By names,
    by age. or by the average score of them?
  prefs: []
  type: TYPE_NORMAL
- en: Comparing a student to another is not a feature of the `Student`. Every class,
    or for that matter, package, library, or programming unit should have one responsibility
    and it should implement only that and nothing else. It is not exact. This is not
    mathematics. Sometimes, it is hard to tell if a feature fits into the responsibility
    or not. There are simple techniques. For example, in case of a student, you can
    ask the real person about his name and age, and probably they can also tell you
    their average score. If you ask one of them to `compareTo` (another student),
    as the `Comparable` interface requires this method, they will probably ask back,
    but by what attribute? Or how? Or just, what? In such a case, you can suspect
    that implementing the feature is probably not in the area of that class and this
    concern; the comparison should be segregated from the implementation of the original
    class. This is also called **Segregation of Concerns**, which is closely related
    to SRP.
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK developers were aware of this. `Collections.sort` that sorts a `List` of
    `Comparable` elements is not the only sorting method in this class. There is another
    that just sorts any `List` if you pass a second argument and object that implements
    the `Comparator` interface and is capable of comparing two elements of `List`.
    This is a clean pattern to separate the concerns. In some cases, separating the
    comparison is not needed. In other cases, it is desirable. The `Comparator` interface
    declares one single method that the implementing classes have to provide: `compare`.
    If the two arguments are equal, then this method returns `0`. If they are different,
    it should return a negative or a positive `int` depending on which argument precedes
    which one.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also `sort` methods in the JDK class, `java.util.Arrays`. They sort
    arrays, or only a slice of an array. The method is a good example of method overloading.
    There are methods with the same name, but with different arguments to sort a whole
    array for each primitive type, for a slice of each, and also two for object array
    implementing the `Comparable` interface, and also for object array to be sorted
    using `Comparator`. As you see, there is a whole range of sort implementations
    available in the JDK, and in 99 percent of the cases, you will not need to implement
    a sort yourself. The sorts use the same algorithm, a stable merge sort with some
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: What we will implement is a general approach that can be used to sort lists,
    arrays, or just anything that has elements and it is possible to swap any two
    elements of it; the solution will be able to use the bubble sort that we have
    already developed and also other algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of various sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different sorting algorithms. As I said, there are simpler and
    more complex algorithms and, in many cases, more complex algorithms are the ones
    that run faster. In this chapter, we will implement the bubble sort and quick
    sort. We have already implemented the bubble sort for strings in the previous
    chapter, so in this case, the implementation will mainly focus on the recoding
    for general sortable object sorting. Implementing quick sort will involve a bit
    of algorithmic interest.
  prefs: []
  type: TYPE_NORMAL
- en: Be warned that this section is here to give you only a taste of algorithmic
    complexity. It is far from precise and I am in the vain hope that no mathematician
    reads this and puts a curse on me. Some of the explanations are vague. If you
    want to learn computer science in depth, then after reading this book, find some
    other books or visit online courses.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about the general sorting problem, we will think about some general
    set of objects that can be compared and any two of them can be swapped while we
    sort. We will also assume that this is an in-place sort; thus, we do not create
    another list or array to collect the original objects in sorted order. When we
    talk about the speed of an algorithm, we are talking about some abstract thing
    and not milliseconds. When we want to talk about milliseconds, actual real-world
    duration, we should already have some implementation in some programming language
    running on a real computer.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms, in their abstract form, don't do that without implementation. Still,
    it is worth talking about the time and memory need of an algorithm. When we do
    that, we will usually investigate how the algorithm behaves for a large set of
    data. For a small set of data, most algorithms are just fast. Sorting two numbers
    is usually not an issue, is it?
  prefs: []
  type: TYPE_NORMAL
- en: In case of sorting, we will usually examine how many comparisons are needed
    to sort a collection of *n* elements. Bubble sort needs approximately n² (n times
    *n*) comparisons. We cannot say that this is exactly *n*² because in case of *n=2*,
    the result is 1, for *n=3* it is 3, for *n=4* it is 6, and so on. However, as
    *n* starts to get larger, the actual number of comparisons needed and *n*² will
    asymptotically be of the same value. We say that the algorithmic complexity of
    the bubble sort is *O(n²)*. This is also called the big-O notation. If you have
    an algorithm that is *O(n²)* and it works just fine for 1,000 elements finishing
    in a second, then you should expect the same algorithm finishing for 1 million
    elements in around ten days or in a month. If the algorithm is linear, say *O(n)*,
    then finishing 1,000 element in one second should make you expect 1 million to
    be finished in 1,000 seconds. That is a bit longer than a coffee break and too
    short for lunch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it feasible that if we want some serious business sorting objects,
    we will need something better than bubble sort. That many unnecessary comparisons
    are not only wasting our time, but also CPU power, consuming energy, and polluting
    the environment. The question, however, is: how fast can a sort be? Is there a
    provable minimum that we cannot overcome?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement any sorting algorithm, the implementation will execute comparisons
    and element swaps. That is the only way to sort a collection of objects. The outcome
    of a comparison can have two values. Say, these values are *0* or *1*. This is
    one bit of information. If the result of the comparison is *1*, then we swap,
    if the result is *0*, then we do not swap.
  prefs: []
  type: TYPE_NORMAL
- en: We can have the objects in different orders before we start the comparison and
    the number of different orders is *n!* (*n* factorial). That is, the numbers multiplied
    from 1 to *n*, in other words *n!*=1*2*3*...*(*n*-1)**n*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we stored the result of the individual comparisons in a number
    as a series of bits for each possible input for the sort. Now, if we reverse the
    execution of the sort and run the algorithm starting from the sorted collection,
    control the swapping using the bits that described the results of the comparison,
    and we use the bits the other way around doing the last swap first and the one
    that was done first during the sorting first, we should get back the original
    order of the objects. This way, each original order is uniquely tied to a number
    expressed as an array of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can express the original question this way: how many bits are needed
    to describe *n* factorial different numbers? That is exactly the number of comparisons
    we will need to sort *n* elements. The number of bits is *log[2](n!)* . Using
    some mathematics, we will know that *log[2](n!)* is the same as *log[2](1)+ log[2](2)+...+
    log[2](n)*. If we look at this expression''s asymptotic value, then we can say
    that this is the same *O(n*log n)*. We should not expect any general sorting algorithm
    to be faster.'
  prefs: []
  type: TYPE_NORMAL
- en: For special cases, there are faster algorithms. For example, if we want to sort
    1 million numbers that are each between one and 10, then we only need to count
    the number of the different numbers and then create a collection that contains
    that many ones, twos, and so on. This is an *O(n)* algorithm, but this is not
    applicable for the general case.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this was not a formal mathematical proof.
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sir Charles Antony Richard Hoare developed the quick sort algorithm in 1959\.
    It is a typical divide and conquer algorithm. To sort a long array, pick an element
    from the array that will be the pivot element. Then, partition the array so that
    the left side will contain all the elements that are smaller than the pivot and
    the right side will contain all the elements that are larger than, or equal to
    the pivot. When this is done, the left side and the right side of the array can
    be sorted by calling the sort recursively. To stop the recursion, when we have
    one single element in the array, we will declare it sorted.
  prefs: []
  type: TYPE_NORMAL
- en: We talk about a recursive algorithm when the algorithm is defined partially
    using itself. The most famous recursive definition is the Fibonacci series that
    is 0 and 1 for the first two elements and any later element the *n*^(th) element
    is the sum of the (*n-1)*^(th) and the (*n-2)*^(th) element. Recursive algorithms
    are many times implemented in modern programming languages implementing a method
    that does some calculation but sometimes calls itself. When designing recursive
    algorithms, it is of utmost importance to have something that stops the recursive
    calls; otherwise, recursive implementation will allocate all memory available
    for the program stack and stop the program with error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partitioning algorithm goes the following way: we will start to read the
    array using two indices from the start and end. We will first start with the index
    that is small and increase the index until it is smaller than the large index,
    or until we find an element that is greater than or equal to the pivot. After
    this, we will start to decrease the larger index so long as it is greater than
    the small index and the element indexed is greater than or equal to the pivot.
    When we stop, we swap the two elements pointed by the two indices, if the indices
    are not the same, and we will start increasing and decreasing the small and large
    indices, respectively. If the indices are the same, then we are finished with
    the partitioning. The left side of the array is from the start to the index where
    the indices met minus one; the right side starts with the index and lasts until
    the end of the to-be-sorted array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm is usually *O(n log n)*, but in some cases it can degrade to
    be *O(n²)*, depending on how the pivot is chosen. There are different approaches
    for the selection of the pivot. In this book, we will use the simplest: we will
    select the first element of the sortable collection as a pivot.'
  prefs: []
  type: TYPE_NORMAL
- en: Project structure and build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project this time will contain many modules. We will still use Maven in
    this chapter. We will set up a so-called multi-module project in Maven. In such
    a project, the directory contains the directories of the modules and `pom.xml`.
    There is no source code in this top-level directory. The `pom.xml` file in this
    directory serves the following two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It references the modules and can be used to compile, install, and deploy all
    the modules together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines parameters for the modules that are the same for all of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every `pom.xml` has a parent and this `pom.xml` is the parent of the `pom.xml`
    files in the module directories. To define the modules, the `pom.xml` file contains
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the names of the modules. These names are used as directory names
    and also as `artifactId` in the `pom.xml` module. The directories in this setup
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Maven dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dependencies are also important in the POM file. The previous project did not
    have any dependency, but this time we will use JUnit. Dependencies are defined
    in `pom.xml` using the `dependencies` tag. For example, the bubble sort module
    contains the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The actual `pom.xml` in the code set you can download will contain more code
    than this. In print, we often present a version or only a fraction that helps
    the understanding of the topic that we are discussing at that point.
  prefs: []
  type: TYPE_NORMAL
- en: It tells Maven that the module code uses classes, interfaces, and `enum` types
    that are defined in these modules that are available from some repository.
  prefs: []
  type: TYPE_NORMAL
- en: When you use Maven to compile the code, the libraries that are used by your
    code are available from repositories. When Ant was developed, the notion of repositories
    was not invented. At that time, the developers copied the used version of the
    library into a folder in the source code structure. Usually, the directory `lib`
    was used for the purpose. There were two problems with this approach. One is the
    size of the source code repository. If, for example, 100 different projects used
    JUnit, then the JAR file of the JUnit library was copied there 100 times. The
    other problem was to gather all the libraries. When a library used another library,
    the developers had to read the documentation of the library that described (many
    times outdated and not precise) what other libraries are needed to use this library.
    Those libraries had to be downloaded and installed the same way. This was time
    consuming and error prone. When a library was missing and the developers just
    did not notice it, the error was manifested during compile time when the compiler
    could not find the class or even only at runtime when the JVM was not able to
    load the class.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, Maven comes with a built-in repository manager client.
    The repository is a storage that contains the libraries. As there can be other
    types of files in a repository, not only libraries, Maven terminology is artifact.
    The `groupId`, the `artifactId`, and the `version` number identify an artifact.
    There is a very strict requirement that an artifact can only be put into a repository
    once. Even if there is an error during the release process that is identified
    after the erroneous release was uploaded, the artifact cannot be overwritten.
    For the same `groupId`, `artifactId`, and `version`, there can only be one single
    file that will never change. If there was an error, then a new artifact is to
    be created with new version number and the erroneous artifact may be deleted but
    not replaced.
  prefs: []
  type: TYPE_NORMAL
- en: If the version number ends with `-SNAPSHOT`, then this uniqueness is not guaranteed
    or required. Snapshots are usually stored in separate repository and are not published
    for the world.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories contain the artifacts in directories that are organized in a defined
    way. When Maven runs, it can access different repositories using `https` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Formerly, the `http` protocol was also used, and for non-paying customers, the
    central repository was available via `http` only. However, it was discovered that
    modules downloaded from the repository could be targets for men-in-the-middle
    security attacks and Sonatype ([http://www.sonatype.com](http://www.sonatype.com))
    changed the policy and used `https` protocol only. Never configure or use a repository
    with the `http` protocol. Never trust a file that you downloaded from HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: There is a local repository on the developer machine, usually under the `~/.m2/repository`
    directory. When you issue the `mvn install` command, Maven stores the created
    artifact here. Maven also stores an artifact here when it is downloaded from a
    repository via HTTPS. This way, subsequent compilations do not need to go out
    to the network for the artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Companies usually set up their own repository manager (the one that Sonatype,
    the company backing Maven, is providing Nexus). These applications can be configured
    to communicate with several other repositories and collect the artifacts from
    there on demand, essentially implementing proxy functionality. Artifacts travel
    to the build from the far end repositories to the closer ones in a hierarchical
    structure to the local repo and essentially to the final artifact if the packaging
    type of the project is `war`, `ear`, or some other format that encloses the dependent
    artifacts. This is essentially file caching without revalidation and cache eviction.
    This can be done because of the strict rules of artifact uniqueness. This is the
    reason for such a strict rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the project bubble were a standalone project, and not part of a multi-module
    one, then the dependency would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If `version` is not defined for a dependency, Maven will not be able to identify
    which artifact to use. In the case of a multi-module project, `version` can be
    defined in the parent and the modules can inherit the version. As the parent is
    not dependent on the actual dependency, it only defines the version attached to
    the `groupId` and `artifactId`; the XML tag is not `dependencies`, but `dependencyManagement/dependencies`
    under the top-level `project` tag as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the parent POM uses the dependencies tag directly, Maven is not able to decide
    if the parent depends on that artifact or some modules. When the modules want
    to use `junit`, they need not specify the version. They will get it from the parent
    project defined as 4.12, which is the latest from *JUnit 4*. If ever there will
    be a new version 4.12.1, with some serious bugs fixed, then the only place to
    modify the version number is the parent POM, and the modules will use the new
    version starting with the next execution of the Maven compilation.
  prefs: []
  type: TYPE_NORMAL
- en: When the new version, *JUnit 5*, comes out, however, the modules will all have
    to be modified because *JUnit* is not just a new version. Version 5 of JUnit is
    split into several modules and, this way, `groupId` and `artifactId` will also
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting that the modules that implement the interfaces from
    the `SortInterface` module are eventually dependent on this module. In this case,
    the version is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That seems to be a bit tautological (it is, actually). The `${project.version}`
    property is the version of the project and it is inherited by the `SortInterface`
    module. This is the version of the artifact that the other modules depend on.
    In other words, the modules always depend on the version that we are currently
    developing.
  prefs: []
  type: TYPE_NORMAL
- en: Code the sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the sort, first, we will define the interfaces that a sort library
    should implement. Defining the interface before the actual coding is a good practice.
    When there are many implementations, it is sometimes recommended to first create
    a simple one and start using it so that the interface may evolve during the phase,
    and when the more complex implementations are due, then the interface to be implemented
    is already fixed, more or less.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interface in our case is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The interface should do only one thing—sort something that is sortable. As we
    wanted to be very general in this approach, we also have to define what sortable
    is. To do so, we will need another interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating BubbleSort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can start creating the bubble sort that implements the `Sort` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the algorithm to execute needs two operations that we implemented
    in the code last time specific to a `String` array: comparing two elements and
    swapping two elements. As this time the sort implementation itself does not know
    what type the elements are used and also does not know if the something it sorts
    is an array, a lists or something else, it needs something that does it for the
    sort when needed. More precisely, it needs a `comparator` object capable of comparing
    two elements and it needs a `swapper` object that is capable of swapping two elements
    in the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: To get those, we can implement two setter methods that can set the objects for
    the purpose before sort is invoked. As this is not specific to the bubble sort
    algorithm but is rather general, these two methods should also be made a part
    of the interface, so the implementation is overriding it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `@Override` annotation signals for the Java compiler that the method is
    overriding a method of the parent class, or, as in this case, of the interface.
    A method can override a parent method without this annotation; however, if we
    use the annotation, the compilation fails if the method does actually not override
    something. This helps you discover during compile time that something was changed
    in the parent class or in the interface and we did not follow that change in the
    implementation, or that we just made some mistake thinking that we will override
    a method when we actually do not. As annotations are heavily used in unit tests,
    we will talk about annotations in a bit more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Amending the interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The modified `Sort` interface will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that we will need two new interfaces: `Swapper` and `Comparator`.
    We are lucky that the Java runtime already defines a `Comparator` interface that
    just fits the purpose. You may have guessed that from the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you need something very basic, like a `comparator` interface, it is most
    probably defined in the runtime. It is advisable to consult the runtime before
    writing your own version. The `Swapper` interface, however, we will have to create.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As it is used to swap two elements specified by the indices in `SortableCollection`,
    there is a method, quite trivially named `swap` for the purpose. But, we are not
    ready yet. If you try to compile the preceding code, the compiler will complain
    about the `get` and `size` methods. They are needed by the algorithm to implement
    the sort, but they are not inherently part of the sorting itself. This is a responsibility
    that should not be implemented in the sort. As we do not know what type of collections
    we will sort, it is not only unadvisable but also impossible to implement these
    functionalities inside the sort. It seems that we just cannot sort anything. There
    are some restrictions we will have to set. The sorting algorithm must know the
    size of the collection we sort and also should have access to an element by index
    so that it can pass it on to the comparator.
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions are expressed in the `SortableCollection` interface that
    we just left empty not knowing before the first sort implementation what is required
    to be there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready with the interfaces and the implementation and we can go on
    testing the code. But, before that, we will briefly reiterate what we did and
    why we did that.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created an interface and a simple implementation of it. During the implementation,
    we discovered that the interface needs other interfaces and methods that are needed
    to support the algorithm. This usually happens during the architectural design
    of the code, before implementation. For didactical reasons, I followed the build-up
    of the interfaces while we developed the code. In real life, when I created the
    interfaces, I created them all in one step as I have enough experience. I wrote
    my first quick sort code around 1983 in Fortran. However, it does not mean that
    I hit the bull's eye with just any problem and come out with the final solution.
    It just happens that sort is a too well known problem. If you need to modify the
    interfaces or other aspects of your design during development, do not feel embarrassed.
    It is a natural consequence and a proof that you understand things better and
    better as time goes by. If the architecture needs change, it is better to be done
    than not, and the sooner it is, the better. In real life enterprise environments,
    we will design interfaces just to learn during development that there were some
    aspects that we forgot. They are very true and bit more complex operations than
    sorting a collection.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the sorting problem, we abstracted the *something* we want to
    sort to the most possible extreme. The Java build in sort can sort arrays or lists.
    If you want to sort something that is not a list or an array, you have to create
    a class that implements the `java.util.List` interface with more than 24 methods
    it requires to wrap your sortable object to make it sortable by the JDK sort.
    To be honest, that is not too many, and in a real-world project, I would consider
    that as an option.
  prefs: []
  type: TYPE_NORMAL
- en: However, we do not, and cannot know, what methods of the interface the built-in
    sort uses. Those that are used should be functionally implemented and those that
    are not, can contain a simple `return` statement because they are just never invoked.
    A developer can consult the source code of the JDK and see what methods are actually
    used, but that is not the contract of the search implementation. It is not guaranteed
    that a new version will still use *only* those methods. If a new version starts
    to use a method that we implemented with a single `return` statement, the sort
    will magically fail.
  prefs: []
  type: TYPE_NORMAL
- en: It is also an interesting performance question how the swapping of two elements
    is implemented by the search using only the `List` interface. There is no `put(int,
    Object)` method in the `List` interface. There is `add(int Object)`, but that
    inserts a new element and it may be extremely costly (burning CPU, disk, energy)
    to push all elements of the list up if the objects are stored, for example, on
    disk. Furthermore, the next step may be removing the element after the one we
    just inserted, doing the costly process of moving the tail of the list again.
    That is, the trivial implementation of `put(int,Object)` that the sort may or
    may not follow. Again, this is something that should not be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: When developers use libraries, classes, and methods from the JDK, open source,
    or commercial libraries, the developers may consult the source code but they should
    not rely on the implementation. You should rely only on the contract and the definition
    of the API that the library comes with. When you implement an interface from some
    external library, and you do not need to implement some part of it, and create
    some dummy methods, feel the danger in the air. It is an ambush. It is likely
    that either the library is poor quality or you did not understand how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we separated the swapping and the comparison from the sort. The
    collection should implement these operations and provide them for the sort. The
    contract is the interface, and to use the sort, you have to implement all methods
    of the interfaces we defined.
  prefs: []
  type: TYPE_NORMAL
- en: The interface of `Sort` defines setters that set `Swapper` and `Comparator`.
    Having dependencies set that way may lead to a code that creates a new instance
    of a class implementing the `Sort` interface, but does not set `Swapper` and `Comparator`
    before invoking `Sort`. This will lead to `NullPointerException` the first time
    the `Comparator` is invoked (or when the `Swapper` is invoked in case the implementation
    invokes that first, which is not likely, but possible). The calling method should
    inject the dependencies before using the class. When it is done through setters,
    it is called **setter injection**. This terminology  is heavily used when we use
    frameworks such as Spring, Guice, or some other container. Creating these service
    classes and injecting the instance into our classes is fairly similar all the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Container implementations contain the functionality in a general way and provide
    configuration options to configure what instances are to be injected into what
    other objects. Usually, this leads to shorter, more flexible, and more readable
    code. However, dependency injection is not exclusive to containers. When we write
    the testing code in the next section, and invoke the setters, we actually do dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way of dependency injection that avoids the problem of dependencies
    not being set. This is called **constructor injection**. The dependencies are
    `final private` fields with no values. Remember that these fields should get their
    final values by the time the constructor finishes. Constructor injection passes
    the injected values to the constructor as arguments and the constructor sets the
    fields. This way, the fields are guaranteed to be set by the time the object was
    constructed. This injection, however, cannot be defined in an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we already have the code, and we know the considerations of how the interfaces
    were created. This is the time to do some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write code, we should test it. No code has ever gone into production
    before at least doing some test runs. There are different levels of tests having
    different aims, technologies, industry practices, and names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests, as the name suggests, test a unit of code. Integration tests test
    how the units integrate together. Smoke tests test a limited set of the features
    just to see that the code is not totally broken. There are other tests, until
    the final test, which is the proof of the work: user acceptance test. Proof of
    the pudding is eating it. A code is good if the user accepts it.'
  prefs: []
  type: TYPE_NORMAL
- en: Many times, I tell juniors that the name user acceptance test is a bit misleading,
    because it is not the user who accepts the result of a project, but the customer.
    By definition, the customer is the person who pays the bill. Professional development
    is paid; otherwise, it is not professional. The terminology is, however, user
    acceptance test. It just happens that customers accept the project only if the
    users can use the program.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop in Java, unit test is testing standalone classes. In other words,
    in Java development, a unit is a class when we talk about unit tests. To furnish
    unit tests, we usually use the JUnit library. There are other libraries, such
    as TestNG, but JUnit is the most widely used, so we will use *JUnit*. To use it
    as a library, first, we will have to add it to the Maven POM as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JUnit as dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that we have a multi-module project, and the dependency versions are
    maintained in the parent POM under the `dependencyManagement` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The scope of the dependency is test, which means that this library is needed
    only to compile the test code and during the execution of the test. The JUnit
    library will not make its way to the final released product; there is no need
    for it. If you find the JUnit library in some deployed production **Web Archive**
    (**WAR**) file, suspect that somebody was not properly managing the scopes of
    the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Maven supports the compilation and the execution of JUnit tests in the lifecycle
    of the project. If we want to execute the tests, only we can issue the `mvn test`
    command. The IDEs also support the execution of the unit tests. Usually, the same
    menu item that can be used to execute a class that has a `public static main`
    method can be used. If the class is a unit test utilizing JUnit, the IDE will
    recognize it and execute the tests and usually give a graphical feedback on what
    test was executing fine and which ones failed, and how.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the BubbleSortTest class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test classes are separated from the production classes. They go into the
    `src/test/java` directory. When we have a class named, for example, `BubbleSort`,
    then the test will be named `BubbleSortTest`. This convention helps the executing
    environment to separate the tests from those classes that do not contain tests
    but are needed to execute the tests. To test the sort implementation we have just
    created, we can furnish a class that contains, for now, a single `canSortStrings`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test method names are used to document the functionality being tested.
    As the JUnit framework invokes each and every method that has the `@Test` annotation,
    the name of the test is not referenced anywhere in our code. We can bravely use
    arbitrary long method names; it will not hinder readability at the place where
    the method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The method contains `ArrayList` with the actual names that we have already gotten
    familiar with. As we have a sort implementation and interface that needs `SortableCollection`,
    we will create one backed up by `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We declared a new object that has the `SortableCollection` type, which is an
    interface. To instantiate something that implements `SortableCollection`, we will
    need a class. We cannot instantiate an interface. In this case, define the class
    in the place of the instantiation. This is called an anonymous class in Java.
    The name comes from the fact that the name of the new class is not defined in
    the source code. The Java compiler will automatically create a name for the new
    class, but that is not interesting for the programmers. We will simply write `new
    SortableCollection()` and provide the needed implementation immediately following
    between `{` and `}`. It is very convenient to define this anonymous class inside
    the method as, this way, it can access `ArrayList` without passing a reference
    to `ArrayList` in the class.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, the reference is needed, but the Java compiler automatically
    does this. The Java compiler, in this case, also takes care that automatic reference
    passing this way can only be done using variables that were initialized and will
    not change during the execution of the code after the instantiation of the anonymous
    class. The variable `actualNames` was set and it should not be changed in the
    method later. As a matter of fact, we can even define `actualNames` to be final
    and this would have been a requirement if we used Java 1.7 or earlier. Starting
    with 1.8, the requirement is that the variable is effectively final, but you need
    not declare it to be final.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that we need is a `Swapper` implementation for `ArrayList`. In
    this case, we will define a whole class inside the method. It can also be an anonymous
    class, but this time I decided to use a named class to demonstrate that a class
    can be defined inside a method. Usually, we do not do that in production projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Last, but not least, we will need a comparator before we can invoke the sort.
    As we have `String`s to compare, this is easy and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Having everything prepared for the sorting, we will finally need an instance
    of the Sort implementation, set the `comparator` and the `swapper`, and invoke
    the sort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The last, but most important part of the test is to assert that the result is
    the one that we expect. JUnit helps us do that with the aid of the `Assert` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The call to `assertEquals` checks that the first argument, the expected result,
    equals the second argument, the sorted `actualNames`. If they differ, then `AssertionError`
    is thrown; otherwise, the test just finishes fine.
  prefs: []
  type: TYPE_NORMAL
- en: Good unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is this a good unit test? If you read it in a tutorial book like this, it has
    to be. Actually, it is not. It is a good code to demonstrate some of the tools
    that JUnit provides and some Java language features, but as a real JUnit test,
    I will not use it in a real life project.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a unit test good? To answer this question, we will have to find what
    the unit test is good for and what it is that we use it for.
  prefs: []
  type: TYPE_NORMAL
- en: We will create unit tests to validate the operation of the units and to document.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are not to find bugs. Developers eventually use unit tests during
    debugging sessions but, many times, the testing code created for the debugging
    is a temporary one. When the bug is fixed, the code used to find it will not get
    into the source code. For every new bug, there should be a new test created that
    covers the functionality that was not properly working, but it is hardly the test
    code that is used to find the bug. This is because unit tests are mainly for documentation.
    You can document a class using *JavaDoc*, but the experience shows that the documentation
    often becomes outdated. The developers modify the code, but they do not modify
    the documentation, and the documentation becomes obsolete and misleading. Unit
    tests, however, are executed by the build system and if **Continuous Integration**
    (**CI**) is in use (and it should be, in a professional environment), then the
    build will be broken if a test fails, all developers will get mail notification
    about it, and it will drive the developer breaking the build to fix the code or
    the test. This way, the tests verify that continuous development did not break
    anything in the code or, at least, not something that can be discovered using
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: A good unit test is readable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our test is far from being readable. A test case is readable if you look at
    it and in 15 seconds you can tell what it does. It assumes, of course, some experience
    in Java on behalf of the reader, but you get the point. Our test is cluttered
    with support classes that are not core to the test.
  prefs: []
  type: TYPE_NORMAL
- en: Our test also hardly validates that the code is working properly. It actually
    does not. There are some bugs in it that I put there deliberately, which we will
    locate and zap in the following sections. One single test that sorts a single
    `String` array is far from validating a sort implementation. If I were to extend
    this test to a real-world test, we would need methods that would have the name
    `canSortEmptyCollection`, `canSortOneElementCollection`, `canSortTwoElements`,
    `canSortReverseOrder`, or `canSortAlreadySorted`. If you look at the names, you
    will see what tests we need. Coming from the nature of the sort problem, an implementation
    may be reasonably sensitive to errors in these special cases.
  prefs: []
  type: TYPE_NORMAL
- en: What are the good points in our unit test, in addition to it being an acceptable
    demonstration tool?
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our unit test runs fast. As we execute unit tests each time, the CI fires up
    a build and the execution of the tests should not last long. You should not create
    a unit test sorting billions of elements. That is a kind of stability or load
    test and they should run in separate test periods and not every time the build
    is running. Our unit test sorts five elements that are reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are deterministic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our unit test is deterministic. Non-deterministic unit tests are the nightmare
    of the developers. If you are in a group where some builds break on the CI server,
    and when a build breaks, your fellow developer says that you just have to try
    it again; no way! If a unit test runs, it should run all times. If it fails, it
    should fail no matter how many times you start it. A non-deterministic unit test,
    in our case, will be to render random numbers and have them sorted. We will end
    up with different arrays in each test run and, in case there is some bug in the
    code that manifests for some array, we will not be able to reproduce it. Not to
    mention that the assertion that the code was running fine is also difficult.
  prefs: []
  type: TYPE_NORMAL
- en: If we sorted a random array in a unit test (something we do not), we could,
    hypothetically, assert that the array is sorted, comparing the elements one after
    the other checking that they are in ascending order. It would also be a totally
    wrong practice.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions should be as simple as possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the assertion is complex, the risk of introducing bugs in the assertion is
    higher. The more complex the assertion, the higher the risk. We will write the
    unit tests to ease our lives and not to have more code to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, one test should assert only one thing. This one assertion may
    be coded with multiple `Assert` class methods, one after the other. Still, the
    aim of these is to assert the correctness of one single feature of the unit. Remember
    the SRP: one test, one feature. A good test is like a good sniper: one shot, one
    kill.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are isolated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we test a unit *A*, any change in another unit *B*, or a bug in a different
    unit should not affect our unit test that is for the unit *A*. In our case, it
    was easy because we have only one unit. Later, when we develop the test for the
    quick sort, we will see that this separation is not that simple.
  prefs: []
  type: TYPE_NORMAL
- en: If the unit tests are properly separated, a failing unit test clearly points
    out the location of the problem. It is in the unit where the unit test failed.
    If tests do not separate the units, then a failure in one test may be caused by
    a bug in a different unit than we expect. In this case, these tests are not really
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you should make a balance. If the isolation of the units will be
    too costly, you can decide to create integration tests; and, if they still run
    fast, have them executed by the *CI system*. At the same time, you should also
    try to find out why the isolation is hard. If you cannot easily isolate the units
    in the tests, it means that the units are too strongly coupled, which may not
    be a good design.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests cover the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should test all usual and also all special cases of the functionality.
    If there is a special case of code that is not covered by the unit test, the code
    is in danger. In case of a sort implementation, the general case is sorting, say
    five elements. The special cases are much more numerous usually. How does our
    code behave if there is only one element or if there are no elements? What if
    there are two? What if the elements are in reverse order? What if they are already
    sorted?
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the special cases are not defined in the specification. The programmer
    has to think about it before coding, and some special cases are discovered during
    coding. The hard thing is that you just cannot tell if you covered all special
    cases and the functionality of the code.
  prefs: []
  type: TYPE_NORMAL
- en: What you can tell is if all the lines of code were executed during the testing
    or not. If 90% of the code lines are executed during the tests, then the code
    coverage is 90%, which is fairly good in real life, but you should never be content
    with anything less than 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage is not the same as functional coverage, but there is a correlation.
    If the code coverage is less than 100%, then at least one of the following two
    statements is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The functional coverage is not 100%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is unused code in the tested unit, which can just be deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code coverage can be measured, the functional coverage cannot. The tools
    and IDEs support code coverage measurement. These measurements are integrated
    into the editor so you will not only get the percentage of the coverage, but the
    editor will show you exactly which lines are not covered by the coverage coloring
    the lines (in Eclipse, for example) or the gutter on the left side of the editor
    window (IntelliJ). The picture shows that in IntelliJ, the tests cover the lines
    indicated by a green color on the gutter. (In the print version this is just a
    grey rectangle).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Refactor the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have discussed what a good unit test is, let''s improve our test.
    The first thing is to move the supporting classes to separate files. We will create
    `ArrayListSortableCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This class encapsulates `ArrayList` and then implements the `get` and `size`
    methods to `ArrayList` access. `ArrayList` itself is declared as `final`. Recall
    that a `final` field has to be defined by the time the constructor finishes. This
    guarantees that the field is there when we start to use the object and that it
    does not change during the object lifetime. Note, however, that the content of
    the object, in this case, the elements of `ArrayList`, may change. If it were
    not the case, we would not be able to sort it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class is `StringComparator`. This is so simple that I will not list
    it here; I will leave it to you to implement the `java.util.Comparator` interface
    that can compare two Strings. It should not be difficult, especially as this class
    was already a part of the previous version of the `BubbleSortTest` class (hint:
    it was an anonymous class that we stored in the variable named `stringCompare`).'
  prefs: []
  type: TYPE_NORMAL
- en: We also have to implement `ArrayListSwapper`, which also should not be a big
    surprise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our test will look this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now this is already a test that can be understood in 15 seconds. It documents
    well how to use a sort implementation that we defined. It still works and does
    not reveal any bug, as I promised.
  prefs: []
  type: TYPE_NORMAL
- en: Collections with wrong elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bug is not trivial, and as usual, this is not in the implementation of the
    algorithm, but rather in the definition, or the lack of it. What should the program
    do if there are not only strings in the collection that we sort?
  prefs: []
  type: TYPE_NORMAL
- en: 'If I create a new test that starts with the following lines, it will throw
    `ClassCastException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that Java collections can contain any type of elements.
    You cannot ever be sure that a collection, such as `ArrayList`, contains only
    the types that you expect. Even if you use generics (we have not learned that,
    but we will in this chapter), the chances of a bug somehow conjuring up some object
    of an inappropriate type into a collection, are smaller but are still there. Don't
    ask me how; I cannot tell you. This is the nature of the bugs—you cannot tell
    how they work until you zap them. The thing is that you have to be prepared for
    such an exceptional case.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptional cases should be handled in Java using exceptions. The `ClassCastException`
    is there and it happens when the sort tries to compare `String` to `Integer` using
    `StringComparator`, and to do that, it tries to cast an `Integer` to `String`.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown by the program using the `throw` command, or by
    the Java runtime, the execution of the program stops at that point, and instead
    of executing the next command, it continues where the exception is caught. It
    can be in the same method, or in some calling method up in the call chain. To
    catch an exception, the code throwing the exception should be inside a `try` block,
    and the catch statement following the `try` block should specify an exception
    that is compatible with the exception thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the exception is not caught, then the Java runtime will print out the message
    of the exception along with a stack trace that will contain all the classes, methods,
    and line numbers on the call stack at the time of the exception. In our case,
    the `mvn test` command will produce the following trace in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This stack trace is not really long. In the production environment in an application
    that runs on an application server, the stack trace may contain a few hundred
    elements. In this trace, you can see that Maven was starting the test execution,
    involved Maven surefire plugin, and then the JUnit executor, until we get through
    the test to the comparator, where the actual exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: This exception was not printed by the Java runtime to the console. This exception
    is caught by the JUnit library code and the stack trace is logged out to the console
    using Maven logging facility.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that the real issue is not the class casting
    failure. The real issue is that the collection contains mixed elements. It is
    only realized by the Java runtime when it tries to cast two incompatible classes.
    Our code can be smarter. We can amend the comparator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code catches the `ClassCastException` and throws a new one. The advantage
    of throwing a new exception is that you can be sure that this exception is thrown
    from the comparator and that the problem really is that there are mixed elements
    in the collection. Class casting problems may happen at other places of the code
    as well, inside some of the sort implementations. Some application code may want
    to catch the exception and want to handle the case; for example, sending an application-specific
    error message and not dumping only a stack trace to the user. This code can catch
    `ClassCastException` as well, but it cannot be sure what the real cause of the
    exception is. On the other hand, `NonStringElementInCollectionException` is definite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NonStringElementInCollectionException` is an exception that does not exist
    in the JDK. We will have to create it. Exceptions are Java classes and our exception
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Java has the notion of checked exceptions. It means that any exception that
    is not extending `RuntimeException` should be declared in the method definition.
    Suppose our exception was declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will have to declare the `compare` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the exception a method throws is part of the method signature,
    and this way `compare` will not override the `compare` method of the interface,
    and, that way, the class will not implement the `Comparator` interface. Thus,
    our exception has to be a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be a hierarchy of exceptions in an application, and often, novice
    programmers create huge hierarchies of them. If there is something you can do,
    it does not mean that you should do it. Hierarchies should be kept as flat as
    possible, and this is especially true for exceptions. If there is an exception
    in the JDK that describes the exceptional case, then use the readymade exception.
    Just as well as for any other class: if it is ready, do not implement it again.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that throwing an exception should only be done
    in exceptional cases. It is not to signal some normal operational condition. Doing
    that hinders readability of the code and also eats CPU. Throwing an exception
    is not an easy task for the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not only the exception that can be thrown. The `throw` command can throw,
    and the `catch` command can catch anything that extends the `Throwable` class.
    There are two subclasses of `Throwable`: `Error`, and `Exception`. The `Error`
    exception is thrown if some error happened during the execution of the Java code.
    The two most infamous errors are `OutOfMemoryError` and `StackOverflowError`.
    If any of these happens, you cannot do anything reliably to catch the error.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also `InternalError` and `UnknownError` in the JVM, but since JVM is
    fairly stable, you will hardly ever meet these errors.
  prefs: []
  type: TYPE_NORMAL
- en: When any of those errors happen, try to debug the code and try to find out why
    you use that much memory or such deep method calls and try to optimize your solution.
    What I have just said about creating exception hierarchies is true again to catch
    errors. The fact that you can catch errors does not mean that you should. On the
    contrary, you should never catch an error and, especially, never ever catch a
    `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we handled this special case when some programmer accidentally writes
    42 among the names, but will it be nicer if the error was identified during compile
    time? To do that, we will introduce generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a last thought before we go there. What class behavior do we test with
    the `canNotSortMixedElements` unit test? The test is inside the `BubbleSortTest`
    test class, but the functionality is in the comparator implementation, `StringComparator`.
    This test checks something that is out of the scope of the unit test class. I
    can use it for demonstration purposes, but this is not a unit test. The real functionality
    of the sort implementation can be formulized this way: whatever exception the
    comparator throws is thrown by the sort implementation. You can try to write this
    unit test, or read on; we will have it in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: The `StringComparator` class does not have a test class because `StringComparator`
    is part of the test and we will never write a test for a test. Otherwise, we will
    sink into an endless rabbit hole.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generics feature was introduced into Java in version 5\. To start with
    an example, our `Sortable` interface until now was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After introducing generics, it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `E` identifier denotes a type. It can be any type. It says that a class
    is a sortable collection if it implements the interface, namely the two methods—
    `size` and `get`. The `get` method should return something that is of type `E`,
    whatever `E` is. This may not make too much sense up until now, but you will soon
    get the point. After all, generics is a difficult topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sort` interface will become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This still does not provide much more value than the previous version without
    generics, but, at least, it does something. In the actual class implementing the
    `Sort` interface, `Comparator` should accept the same type that `SortableCollection`
    uses. It is not possible that `SortableCollection` works on strings and we inject
    a comparator for integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `BubbleSort` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The real power of generics will come when we will write the tests. The first
    test does not change much, although with the generics, it is more definite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we define `ArrayList`, we will also declare that the elements of the list
    will be strings. When we allocate the new `ArrayList`, there is no need to specify
    again that the elements are strings because it comes from the actual elements
    there. Each of them is a string; therefore, the compiler knows that the only thing
    that can come between the `<` and `>` character is `String`.
  prefs: []
  type: TYPE_NORMAL
- en: The two characters `<` and `>`, without the type definition in between, is called
    **diamond operator**. The type is inferred. If you get used to generics, this
    code brings you more information on the types that the collections work on and
    the code becomes more readable. The readability and the extra information is not
    the only point.
  prefs: []
  type: TYPE_NORMAL
- en: As we know that the `Comparator` argument is `Comparator<String>` now, we can
    use advanced features of Java available since Java 8 and can pass the `String::compareTo`
    method reference to the comparator setter.
  prefs: []
  type: TYPE_NORMAL
- en: The second test is the important one for us now. This is the test which ensures
    that `Sort` does not interfere with the exception that the comparator throws.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The thing is, that it does not even compile. The compiler says that it cannot
    infer the type of `ArrayList<>` on the third line. When all the arguments of the
    `asList` method were strings, the method returned a list of `String` elements
    and therefore the new operator was known to generate `ArrayList<String>`. This
    time, there is an integer, and thus, the compiler cannot infer that `ArrayList<>`
    is for `String` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the type definition from `ArrayList<>` to `ArrayList<String>` is
    not a cure. In that case, the compiler will complain about the value `42`. This
    is the power of generics. When you use classes that have type parameters, the
    compiler can detect when you provide a value of the wrong type. To get the value
    into `ArrayList` to check that the implementation really throws an exception,
    we will have to conjure the value into it. We can try to replace the value `42`
    with an empty `String` and then add the following line which will still not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will still know that the value you want to set in `ArrayList`
    is supposed to be `String`. To get the array with the `Integer` element, you will
    have to explicitly unlock the safety handle and pull the trigger, shooting yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We will set the Swapper to be null because it is never invoked. When I first
    wrote this code, it was evident to me. A few days later, I read the code and I
    stopped. *Why is swapper null?* Then I remembered in a second or two. But any
    time, when reading and understanding the code hicks up, I tend to think about
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: I can add a comment to the line saying `//never invoked`, but comments tend
    to remain there even when functionality changes. I learned it the hard way in
    2006, when a wrong comment prevented me from seeing how the code was executing.
    I was reading the comment while debugging, instead of the code, and bug fixing
    took two days while the system was down.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a comment, I tend to use constructs that make the code express what
    happens. The extra variable may make the class file a few bytes bigger, but it
    is optimized out by the JIT compiler so the final code does not run slower.
  prefs: []
  type: TYPE_NORMAL
- en: The comparator that throws an exception was provided as a lambda expression.
    Lambda expressions can be used in cases where an anonymous class or named class
    will be used having only one simple method. Lambda expressions are anonymous methods
    stored in variables or passed in argument for later invocation. We will discuss
    the details of lambda expressions in [Chapter 8](part0233.html), *Extending our
    E-Commerce Application*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will go on implementing `QuickSort`, and to do that, we will use
    the TDD methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test Driven Development (TDD) is a code writing approach when the developers
    first write a test based on the specification and then write the code. This is
    just the opposite that the developer community got used to. The conventional approach
    that we followed was to write the code and then write tests for it. To be honest,
    the real practice many times was to write the code and test it with ad-hoc tests
    and no unit tests at all. Being a professional, you will never do that, by the
    way. You always write tests. (And now, write it down a hundred times: I will always
    write tests.)'
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of TDD is that the tests do not depend on the code. As
    the code does not exist at the creation of the test, developers cannot rely on
    the implementation of the unit and, thus, it cannot influence the test creation
    process. This is generally good. Unit tests should be black box tests as much
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Black box test is a test that does not take into account the implementation
    of the tested system. If a system is refactored, implemented in a different way,
    but the interface it provides toward the external world is the same, then the
    black box tests should run just fine.
  prefs: []
  type: TYPE_NORMAL
- en: A white box test depends on the internal working of the system tested. When
    the code changes the white box test, the code may also need tuning to follow the
    change. The advantage of a white box test can be the simpler test code. Not always.
  prefs: []
  type: TYPE_NORMAL
- en: Gray box test is a mixture of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be black box tests, but, many times, it is not simple to write
    a black box test. Developers will write a test that they think is black box, but
    many times, this belief proves to be false. When the implementation changes, something
    is refactored and the test does not work anymore and it needs to be corrected.
    It just happens that knowing the implementation, the developers, especially those
    who wrote the unit, will write a test that depends on the internal working of
    the code. Writing the test before the code is a tool to prevent this. If there
    is no code, you cannot depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: TDD also says that the development should be an iterative approach. You write
    only one test at the start. If you run, it fails. Of course it fails! As there
    is no code yet, it has to fail. Then, you will write the code that fulfills this
    test. Nothing more, only the code that makes this test pass. Then, you will go
    on writing a new test for another part of the specification. You will run it and
    it fails. This proves that the new test does test something that was not developed
    yet. Then, you will develop the code to satisfy the new test and, possibly, you
    will also modify a block of code that you have already written in the previous
    iterations. When the code is ready, the tests will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, developers are reluctant to modify the code. This is because they
    are afraid of breaking something that was already working. When you follow TDD,
    you should not, and at the same time, you need not be afraid of this. There are
    tests for all features that were already developed. If some of the code modification
    breaks some functionality, the tests will immediately signal the error. The key
    is that you run the tests as often as possible when the code is modified.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing QuickSort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick sort, as we have already discussed, is made of two major parts. One is
    partitioning and the other one is doing the partitioning recursively until the
    whole array is sorted. To make our code modular and ready to demonstrate the Java
    9 module-handling feature, we will develop the partitioning and the recursive
    sorting into separate classes and in a separate package. The complexity of the
    code will not justify this separation.
  prefs: []
  type: TYPE_NORMAL
- en: The partitioning class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The partitioning class should provide a method that moves the elements of the
    collection based on a pivot element, and we will need to know the position of
    the pivot element after the method finishes. The signature of the method should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The class should also have access to `Swapper` and `Comparator`. In this case,
    we defined a class and not an interface; therefore, we will use constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: These constructs, like setters and constructor injectors, are so common and
    happen so frequently that IDEs support the generation of these. You will need
    to create the `final` fields in the code and use the *code generation* menu to
    create the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partitioning class will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code does nothing, but that is how TDD starts. We will create the definition
    of a requirement providing the skeleton of the code and the test that will call
    it. To do that, we will need something that we can partition. The simplest choice
    is an `Integer` array. The `partition` method needs a object of type `SortableCollection<E>`,
    and we will need something that wraps the array and implements this interface.
    We name that class `ArrayWrapper`. This class serves a general purpose and it
    is not only for the test. Because of that, we create it as production code and
    as such we put it in the directory `main` and not in the directory `test`. As
    this wrapper is independent from the implementation of `Sort`, the proper position
    of this class is in a new `SortSupportClasses` module. We will create the new
    module as it is not part of the interface. Implementations depend on the interface,
    but not on the support classes. There can also be some application that uses our
    libraries and may need the interface module and some of the implementation but
    still does not need the support classes when they deliver the wrapping functionality
    themselves. After all, we cannot implement all possible wrapping functionality.
    The SRP also holds for the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Java libraries tend to contain unrelated functionalities. For the short run,
    it makes the use of the library simpler. You will only need to specify one dependency
    in your POM file and you will have all the classes and APIs that you need. In
    the long run, the application gets bigger, carrying a lot of classes that are
    part of some of the libraries but the application never uses them.
  prefs: []
  type: TYPE_NORMAL
- en: To add the new module, the module directory has to be created along with the
    source directories and the POM file. The module has to be added to the parent
    POM and it also has to be added to the `dependencyManagement` section so that
    the test code of the `QuickSort` module can use it without specifying the version.
    The new module depends on the interface module, so this dependency has to be added
    to the POM of the support classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayWrapper` class is simple and general.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `ArraySwapper` class, which we also need, comes into the same module. It
    is just as simple as the wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Having these classes, we can create our first test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Before creating the `@Test` method, we will need two helper methods that make
    assertions. Assertions are not always simple, and in some cases, they may involve
    some coding. The general rule is that the test and the assertions in it should
    be as simple as possible; otherwise, they are just possible source of programming
    errors. Additionally, we created them to avoid programming errors, not to create
    new ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertSmallElements` method asserts that all elements before `cutIndex`
    are smaller than `pivot`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `assertLargeElements` method makes sure that all elements following `cutIndex`
    are at least as large as `pivot`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The test uses a constant array of `Integers` and wraps it into an `ArrayWrapper`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no `Comparator` for `Integer` type in the JDK, but it is easy to define
    one as a lambda function. Now we can write the `partition` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we run the test, it runs fine. However, if we run the test with coverage,
    then the IDE tells us that the coverage is only 92%. The test covered only 13
    of the 14 lines of the `partition` method.
  prefs: []
  type: TYPE_NORMAL
- en: There is a red rectangle on the gutter at line **28**. This is because the test
    array is already partitioned. There is no need to swap any element in it when
    the pivot value is `6`. It means that our test is good, but not good enough. What
    if there is an error on that line?
  prefs: []
  type: TYPE_NORMAL
- en: To amend this problem, we will extend the test, changing the test array from
    `{ 0, 7, 6 }` to `{ 0, 7, 6, 2}`. Run the test and it fails. Why? After some debugging,
    we will realize that we invoke the method `partition` with the fixed parameter
    `2` as the last index of the array. But, we made the array longer. Why did we
    write a constant there in the first place? It is a bad practice. Let's replace
    it with `partitionThis.length-1`. Now, it says that `cutIndex` is `2`, but we
    expected `1`. We forgot to adjust the assertion to the new array. Let's fix it.
    Now it works.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing is to rethink the assertions. The less code the better. The assertion
    methods are quite general, and we will use it for one single test array. The assertion
    methods are so complex that they deserve their own test. But, we do not write
    code to test. Instead of that, we can simply delete the methods and have the final
    version of the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And then again, is this a black-box test? What if the partitioning returns `{2,
    1, 7, 6}`? It fits the definition. We can create more complex tests to cover such
    cases. But a more complex test may also have a bug in the test itself. As a different
    approach, we can create tests that may be simpler but rely on the internal structure
    of the implementation. These are not black-box tests and thus not ideal unit tests.
    I will go for the second one, but I will not argue if someone chooses the other.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the quick sort with an extra class that is in the `qsort`
    package along with the partitioning class, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The method gets `SortableCollection<E>` and two index parameters. It does not
    sort the whole collection; it sorts only the elements between the `start` and
    the `end` index.
  prefs: []
  type: TYPE_NORMAL
- en: It is always important to be extremely precise with the indexing. Usually, there
    is no problem with the start index in Java, but a lot of bugs source from how
    the `end` index is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, the value of `end` can mean that the index is already not part
    of the to-be-sorted interval. In that case, the `partition` method should be invoked
    with `end-1` and the first recursive call with `cutIndex` as last parameter. It
    is a matter of taste. The important thing is to be precise and define the interpretation
    of index parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If there is only one element `(start == end)`, then there is nothing to be sorted
    and the method returns. This is the end criterion of the recursion. The method
    also assumes that the `end` index is never smaller than the `start` index. As
    this method is used only inside the library that we are developing at the moment,
    such an assumption is not too risky to make.
  prefs: []
  type: TYPE_NORMAL
- en: If there is something to be sorted, then the method takes the first element
    of the to-be-sorted interval and uses it as pivot and calls the `partition` method.
    When the partition is done, the method recursively calls itself for the two halves.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is recursive. This means that the method calls itself. When a
    method call is executed, the processor allocates some memory in an area called
    **stack** and it stores the local variables there. This area that belongs to the
    method in the stack is called **stack frame**. When the method returns, this area
    is released and the stack is restored, simply moving the stack pointer where it
    was to the previous state. This way a method can continue its execution after
    calling another method; the local variables are there.
  prefs: []
  type: TYPE_NORMAL
- en: When a method calls itself, it is not different. The local variables are local
    to the actual call of the method. When the method calls itself, it allocates space
    for the local variables again on the stack. In other words, these are new *instances*
    of the local variables.
  prefs: []
  type: TYPE_NORMAL
- en: We will use recursive methods in Java, and in other programming languages, when
    the definition of the algorithm is recursive. It is extremely important to understand
    that when the processor code runs, it is not recursive any more. On that level,
    there are instructions, register stores, and memory loads and jumps. There is
    nothing like function or method and therefore, on that level, there is nothing
    like recursion.
  prefs: []
  type: TYPE_NORMAL
- en: If you get that, it is easy to understand that any recursion can be coded as
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, it is also true the other way around—every loop can be
    coded as recursion but that is not really interesting until you start functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the recursion in Java, and in many other programming languages,
    is that it may run out of stack space. In the case of quick sort, this is not
    the case. You can safely assume that the stack for method calling in Java is a
    few hundreds of levels. Quick sort needs a stack that is approximately *log[2]n*
    deep, where *n* is the number of elements to be sorted. In the case of one billion
    elements, this is 30 that should just fit.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the stack not moved or resized? That is because the code that runs out
    of the stack space is usually bad style. They can be expressed more readable in
    form of some loop. A more robust stack implementation would only lure the novice
    programmer to do some less readable recursive coding.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special case of recursion named tail recursion. A tail recursive
    method calls itself as the last instruction of the method. When the recursive
    call returns the code, executing the method does nothing else but release the
    stack frame that was used for this method invocation. In other words, we will
    keep the stack frame during the recursive call just to throw it away afterwards.
    Why not throw it away before the call? In that case, the actual frame, which has
    the same size and call, will allocate because this is just the same method that
    is kept and the recursive call is transformed into a jump instruction. This is
    an optimization that Java does not do. Functional languages are doing it, but
    Java is not really a functional language and therefore tail-recursive functions
    should rather be avoided and transformed to a loop in the Java source level.
  prefs: []
  type: TYPE_NORMAL
- en: Non-recursive sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate that even non-tail recursive methods can be expressed in a non-recursive
    way, here is the quick sort that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code implements a stack on the Java level. While it sees that there is
    still something scheduled to be sorted in `stack`, it fetched it from the stack
    and does the sort partitioning, and schedules the two parts for being sorted.
  prefs: []
  type: TYPE_NORMAL
- en: This code is more complex than the previous one and you have to understand the
    role of the `Stack` class and how it works. On the other hand, the program uses
    only one instance of the `Partitioner` class and it is also possible to use a
    thread pool to schedule the subsequent sorts instead of handling the tasks in
    a single process. This may speed up the sort when it is executed on a multi-CPU
    machine. However, this is a bit more complex task and this chapter contains a
    lot of new things without multitasking; therefore, we will look at multithread
    code in two chapters later only.
  prefs: []
  type: TYPE_NORMAL
- en: In the very first version of the sort, I was coding it without the three lines
    that compare `cutIndex` against the interval start and increments it in the `if`
    branch. It is needed very much. But, the unit tests we created in this book do
    not discover the bug if we miss those lines. I recommend that you just delete
    those lines and try to write some unit tests that fail. Then try to understand
    what the special case is when those lines are vital and try to modify your unit
    test so that it is the simplest possible that still discovers that bug. (Finally,
    put the four lines back and see if the code works.)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, find some architectural reason why not to put this modification
    into the method `partition`. That method could just return `large+1` in case `large
    == start`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having done all this, the last thing we will need is to have `QuickSort` as
    a simple class (all the real work was already done in different classes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget that we also need a test! But, in this case, that is not much
    different than that of `BubbleSort`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This time, we used `String` array instead of `ArrayList`. This makes this test
    simpler and, this time, we already have the support classes.
  prefs: []
  type: TYPE_NORMAL
- en: You may recognize that this is not a unit test. In the case of `BubbleSort`,
    the algorithm was implemented in a single class. Testing that single class is
    a unit test. In the case of `QuickSort`, we separated the functionality into separate
    classes, and even into separate packages. A real unit test of the `QuickSort`
    class will disclose the dependency of that class on other classes. When this test
    runs, it involves the execution of `Partitioner` and also `Qsort`; therefore,
    it is not really a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Should we bother about that? Not really. We want to create unit tests that involve
    a single unit to know where the problem is when a unit test fails. If there were
    only integration tests, a failing test case would not help a lot in pointing out
    where the problem is. All it says is that there is some problem in the classes
    that are involved in the test. In this case, there are only a limited number of
    classes (three) that are involved in this test and they are tied together. They
    are actually tied together and related to each other so closely that in the real
    production code, I would have implemented them in a single class. I separated
    them here to demonstrate how to test a single unit and also to demonstrate Java
    9 module support that needs a bit more than a single class in a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module handling, also known as project **Jigsaw,** is a feature that was made
    available only in Java 9\. It was a long planned feature that the developers were
    waiting for. First it was planned for Java 7, but it was so complex that it got
    postponed to Java 8 and then to Java 9\. A year ago, it seemed that it would get
    postponed again, but finally, the project code got into the early releases and
    now nothing can stop from being part of the release.
  prefs: []
  type: TYPE_NORMAL
- en: Why modules are needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that there are four levels of access in Java. A method
    or field can be `private`, `protected`, `public`, or `default` (also known as
    package private) when no modifier is supplied. When you develop a complex library
    to be used in several projects, the library itself will contain many classes in
    many packages. There will certainly be classes and methods, fields in those that
    are used inside the library by other classes from different packages, but classes
    that are not to be used by the code outside the library. Making them anything
    less visible than `public` will render them unusable inside the library. Making
    them `public` will make them visible from outside.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, the Maven module `quick` compiled to a JAR can only be used if
    the method sort can invoke `qsort`. But, we do not want `qsort` to be used directly
    from outside. In the next version, we may want to develop a version of the sort
    that uses `qsort` from the `NonRecursiveQuickSort` class and we do not want complaining
    customers whose code does not compile or work because of a minor library upgrade.
    We can document that the internal methods and classes are still public but not
    for use, but in vain. Developers using our library do not read documentation.
    This is also why we do not write excessive comments. Nobody will read it, not
    even the processor executing the code.
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known and infamous example of this problem is the `sun.misc.Unsafe`
    class in the JDK. There is some really unsafe code in it, as the name implies.
    You can access memory out of heap, create objects without initialization, and
    so on. You should not. Why bother? You are a well-behaving developer and you just
    stick to the rules and you do not use that package. Whenever it changes in a new
    version of the JDK, your program is safe using only public and well-documented
    JDK API. Right?
  prefs: []
  type: TYPE_NORMAL
- en: Wrong! Without being aware of this, you may use some libraries that depend on
    other libraries that use the package. Mockito and Spring Framework are only two
    of the numerous in danger. In addition, Java 9 will definitely come with a new
    version of this package. However, it will also come with module handling. While
    Java 9 will provide some useful API for the libraries that were using the `Unsafe`
    package because there was no provided API for the functionality they needed, it
    will deliver modules not to recreate the same problem again.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Java module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java module is a collection of classes in a JAR or in a directory that also
    contain a special class named `module-info`. If there is this file in a JAR or
    directory then it is a module, otherwise it is just a collection of classes that
    are on the `classpath` (or not). Java 8, and the earlier versions, will just ignore
    that class as it is never used as code. This way, using older Java, causes no
    harm and backward compatibility is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: The module information defines what the module exports and what it requires.
    It has a special format. For example, we can place `module-info.java` in our `SortInterface`
    Maven module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that any class, which is `public` and inside the `packt.java9.by.example.ch03`
    package, can be used from outside. This package is exported from the module, but
    other classes from other packages are not visible from outside of the module even
    if they are `public`. The name of the module is same as the package, but this
    is mere convention in case there is only one package exported. The requirement
    is the same as in the case of packages: there should be a name that is not likely
    to collide with other module names. The reversed domain name is a good choice
    but it is not a must as you can see in this book. There is no top-level domain
    `packt`, yet.'
  prefs: []
  type: TYPE_NORMAL
- en: We should also configure the parent POM to ensure that the compiler we use is
    Java 9,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Older versions would be confused with the `module-info.java` file. (By the way,
    even the early access version of Java 9 I use for this book sometimes gives a
    hard time.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We also create a `module-info.java` file in the Maven module, `quick`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This module exports another package and requires the `packt.java9.by.example.ch03`
    module that we have just created. Now, we can compile the modules and the created
    JARs in the`./quick/target` and `./SortInterface/target` directories are now Java
    9 modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Maven does not fully support the modules yet, when I issue the `mvn install`
    command, I get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ERROR] .../genericsort/quick/src/main/java/module-info.java:[3,40] module
    not found: packt.java9.by.example.ch03`'
  prefs: []
  type: TYPE_NORMAL
- en: Maven puts the compiled modules on `classpath`, but Java 9 seeks `modulepath`
    for modules. Maven does not handle `modulepath` yet. To hack `modulepath` to the
    compiler, we will have to add the following configuration lines to the parent
    POM to the `configuration` of the compiler plugin:`<compilerArgs>`
  prefs: []
  type: TYPE_NORMAL
- en: '`<arg>-modulepath</arg>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<arg>${project.parent.basedir}/SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar:
    ...</arg>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</compilerArgs>`'
  prefs: []
  type: TYPE_NORMAL
- en: The actual file should list all the colon separated JAR files that Maven generates,
    and on which some of the modules depend. These are the `SortInterface`, `quick`,
    and `SortSupportClasses`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the functionality of module support, we will create another Maven module
    called `Main`. It has only one class, called `Main`, with a `public static void
    main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It takes the first argument (without checking that there is one, which we should
    not use in a production code) and uses that as a file name. Then, it reads the
    lines of the file into a `String` array, sorts it, and prints it to the standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: As the module support only works for modules, this Maven module also has to
    be a Java module and have a `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we will have to create a `module-info.java` file for the support
    module; otherwise, we will not be able to use it from our module.
  prefs: []
  type: TYPE_NORMAL
- en: After compiling the modules using `mvn install`, we can run it to print out
    the parent POM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is one line of command that print breaks into several lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to access `Qsort` directly inserting the following line `Qsort<String>
    qsort = new Qsort<>(String::compareTo,new ArraySwapper<>(lineArray));` into the
    `main` method, Maven will complain because the module system hides it from our
    `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The module system also supports the `java.util.ServiceLoader` based class-loading
    mechanism, which we will not discuss in this book. This is an old technology that
    is rarely used in an enterprise environment when Spring, Guice, or some other
    dependency injection framework is used. If you see a `module-info.java` file that
    contains the `uses` and `provides` keywords, then first consult with the Java
    documentation about the `ServiceLoader` class at [http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html](http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html),
    and then the Java 9 language documentation on module support ([http://openjdk.java.net/projects/jigsaw/quick-start](http://openjdk.java.net/projects/jigsaw/quick-start)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a general sorting algorithm implementing quick
    sort. We modified our project to be a multi-module Maven project and also to use
    Java module definitions. We were using JUnit to develop unit tests, and we developed
    the code using TDD. We converted the code from old style Java to new using generics,
    and we used exception handling. These are the basic tools that are needed for
    the coming chapters, where we will develop a guessing game. First we will develop
    a simpler version and in the subsequent chapter we will develop a version that
    uses parallel computing, and multiple proccessors.
  prefs: []
  type: TYPE_NORMAL
