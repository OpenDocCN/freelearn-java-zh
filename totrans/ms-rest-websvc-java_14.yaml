- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Alternative Java Frameworks to Build RESTful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 RESTful API 的替代 Java 框架
- en: Until this chapter, we have used the Spring Boot framework to demonstrate the
    API implementation in real code. By using the very popular Spring Boot, we are
    trying to the book as readable and useful for as many readers as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章为止，我们一直使用 Spring Boot 框架来演示真实代码中的 API 实现。通过使用非常流行的 Spring Boot，我们试图使本书对尽可能多的读者来说既可读又实用。
- en: Now it is time to explain why and how other Java frameworks can be used to implement
    RESTful web services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解释为什么以及如何使用其他 Java 框架来实现 RESTful 网络服务了。
- en: You will see that the same design principles and a similar code structure are
    still applicable, so you can use the concepts from the other chapters with any
    framework you may want to use for your specific situation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到相同的设计原则和类似的代码结构仍然适用，因此您可以使用其他章节中的概念，以适应您可能想要用于特定情况的任何框架。
- en: First, we will explain how standards such as Jakarta EE and MicroProfile can
    help you not get lost in the sea of frameworks and implementation stacks you could
    use to build your application. We will briefly mention the possibility of using
    reactive programming, available with most current frameworks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解释 jakarta EE 和 MicroProfile 等标准如何帮助您在众多框架和实现堆栈中不迷失方向，这些框架和实现堆栈可用于构建您的应用程序。我们将简要提及使用大多数当前框架中可用的反应式编程的可能性。
- en: The current choice of implementation technologies is the result of the history
    of innovative approaches to aid developers in creating applications that fulfill
    the current architectural and deployment preferences. We will walk you from Java
    EE through Spring to frameworks such as Quarkus and the MicroProfile specification.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选择实现技术是历史上创新方法的历史结果，旨在帮助开发者创建满足当前架构和部署偏好的应用程序。我们将从 Java EE 逐步引导您到 Quarkus
    和 MicroProfile 规范等框架。
- en: To provide you with a detailed view, we will demonstrate the similarities and
    differences in our example API implementation with the Quarkus and Helidon frameworks
    compared to the Spring Boot implementation from the previous chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供详细的视角，我们将通过与我们之前章节中 Spring Boot 实现相比的 Quarkus 和 Helidon 框架的示例 API 实现中的相似性和差异性来展示。
- en: 'This makes for the following list of sections:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下章节列表：
- en: Understanding the benefits of standards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解标准的好处
- en: Choosing imperative or reactive
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择命令式或反应式
- en: Java EE and Jakarta EE
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE 和 Jakarta EE
- en: Spring Framework and Spring Boot
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架和 Spring Boot
- en: New microservice frameworks and MicroProfile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的微服务框架和 MicroProfile
- en: Example implementation with Quarkus
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quarkus 的示例实现
- en: Example implementation with Helidon
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helidon 的示例实现
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will demonstrate the use of frameworks other than Spring
    Boot (used in previous chapters). However, the necessary dependencies will be
    downloaded during the project build automatically based on the Maven `pom.xml`
    file, so the prerequisites stay the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示除了 Spring Boot（在前面章节中使用）之外的其他框架的使用。然而，必要的依赖项将在项目构建过程中自动下载，基于 Maven
    `pom.xml` 文件，因此先决条件保持不变：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Java 语言和平台有中级了解
- en: At least basic knowledge of Spring Boot or a similar framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少对 Spring Boot 或类似框架有基本了解
- en: Java 21 and Maven 3.9.x installed (alternatively, you can use the `mvnw` command
    included in the example code, which will download the correct Maven version)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Java 21 和 Maven 3.9.x（或者，您可以使用示例代码中包含的 `mvnw` 命令，这将下载正确的 Maven 版本）
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上访问本章的代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11)。
- en: Understanding the benefits of standards
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解标准的好处
- en: Java is a versatile language with a large ecosystem of both open source and
    commercial frameworks and libraries. Hence, you have more options to choose from
    than you will ever be able to fully evaluate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种多才多艺的语言，拥有庞大的开源和商业框架和库生态系统。因此，您可以选择的选项比您能够完全评估的要多。
- en: You could even try to implement your own HTTP server or client and a custom
    framework, although it is not recommended other than for educational purposes
    due to the extreme costs of catching the details needed to make it production-ready
    and to maintain it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以尝试实现自己的HTTP服务器或客户端和自定义框架，尽管除了教育目的之外不推荐这样做，因为使其生产就绪和维护所需的细节捕捉成本极高。
- en: Choosing a framework or any component your software will depend on is difficult.
    It involves predicting both the future features your software will need and the
    future evolution and support of the framework (dependency).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个框架或任何你的软件将依赖的组件是困难的。这涉及到预测你的软件将需要的未来功能和框架（依赖）的未来发展和支持。
- en: For example, an application based on the Java Enterprise Edition standard needs
    to be deployed to an application server. Later, a need to deploy new application
    versions frequently, cloud deployment, and scalability requirements may require
    a faster startup time, smaller container size, and removing the dependency on
    the application server. Or, the version of the application server the operations
    team has experience with may become outdated and it will limit the version of
    Java that can be used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于Java企业版标准的应用程序需要部署到应用程序服务器。后来，频繁部署新应用程序版本、云部署和可伸缩性要求可能需要更快的启动时间、更小的容器大小，以及取消对应用程序服务器的依赖。或者，运维团队有经验的应用程序服务器版本可能已经过时，这将限制可以使用的Java版本。
- en: A common approach is to choose between the frameworks with large communities
    of users and developers. But we also want new innovative frameworks to enter the
    market, although their communities will naturally start small.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是在拥有大量用户和开发者的框架之间进行选择。但我们也希望新的创新框架进入市场，尽管它们的社区自然会从很小开始。
- en: Fortunately, vendor-neutral standards and specifications have been created to
    prevent the Java community from becoming fragmented by mutually incompatible frameworks.
    By choosing a framework that conforms to a standard, you retain the option to
    switch to a different implementation of the same standard. It will be much easier
    for developers to start working on your code even without experience specific
    to the framework provided they are familiar with the standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经创建了供应商中立的规范和标准，以防止Java社区因互不兼容的框架而分裂。通过选择符合标准的框架，你可以保留切换到同一标准的不同实现的选择。如果开发者熟悉标准，即使没有特定于提供的框架的经验，他们也会更容易开始工作。
- en: Therefore, in the following sections, we focus not only on the individual frameworks
    but also on the standards (specifications) they support.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的章节中，我们不仅关注单个框架，还关注它们支持的标准（规范）。
- en: Choosing imperative or reactive
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择命令式或响应式
- en: In the previous chapters, we used the imperative programming style using the
    Spring Web framework.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了Spring Web框架的命令式编程风格。
- en: The **imperative programming style** models an API operation using a simple
    Java method that takes data from the HTTP request as arguments and returns a result
    object that will be used to generate the HTTP response. The method body consists
    of statements that are executed sequentially in the order they appear in the code
    using one Java thread.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程风格通过一个简单的Java方法来模拟API操作，该方法将HTTP请求中的数据作为参数，并返回一个将用于生成HTTP响应的结果对象。方法体由按代码中出现的顺序顺序执行的语句组成，使用一个Java线程。
- en: In the following code snippet, we can see the statements `statement1` , `statement2`
    , and so on, which will be executed one after another in one thread, with access
    to the same scope of variables and the same call stack.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们可以看到`statement1`、`statement2`等语句，这些语句将在一个线程中依次执行，访问相同的变量作用域和相同的调用栈。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A similar code snippet shows the same structure when the result contains multiple
    entities. This time, the result type is a well-known Java collection ( `List`
    ).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的代码片段显示了当结果包含多个实体时具有相同的结构。这次，结果类型是一个众所周知的Java集合（`List`）。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The style is called *imperative* because the program is understood as a sequence
    of commands, telling the computer explicitly what steps to perform in which order.
    In this model, data is just parameters for the commands.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格被称为*命令式*，因为程序被理解为一系列命令的序列，明确告诉计算机按何种顺序执行哪些步骤。在这个模型中，数据只是命令的参数。
- en: Besides the “classic” imperative style, with most modern frameworks you also
    have the option of using the reactive style. For example, with the Spring framework
    family, you can use *Spring WebFlux* .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“经典”的命令式风格外，在大多数现代框架中，您还可以选择使用反应式风格。例如，在Spring框架家族中，您可以使用*Spring WebFlux*。
- en: The **reactive programming style** is built around the idea of asynchronous
    processing of streams of data. The program execution is understood as driven by
    the flow of data. The program reacts to the incoming data items using a pipeline
    of functions (data transformations).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程风格建立在异步处理数据流的思想之上。程序执行被理解为由数据流驱动。程序通过一系列函数（数据转换）对传入的数据项做出反应。
- en: The processing steps of a single request using the reactive style are executed
    asynchronously and they usually jump between different Java threads.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式风格处理单个请求的步骤是异步执行的，并且通常在不同的Java线程之间跳跃。
- en: Several libraries were created to support reactive programming in Java, among
    them *RxJava* and *Project Reactor* . All of them share common features based
    on the Observable design pattern. Their interfaces were standardized in the Reactive
    Streams specification ( [https://www.reactive-streams.org/](https://www.reactive-streams.org/)
    ). Starting from Java version 9, the interfaces from the Reactive Streams specification
    have been part of the standard Java API as interfaces embedded in the `java.util.concurrent.Flow`
    class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建了几个库来支持Java中的反应式编程，其中包括*RxJava*和*Project Reactor*。它们都基于可观察的设计模式共享共同特性。它们的接口在反应式流规范中得到了标准化（[https://www.reactive-streams.org/](https://www.reactive-streams.org/)）。从Java版本9开始，反应式流规范中的接口已成为标准Java
    API的一部分，作为嵌入在`java.util.concurrent.Flow`类中的接口。
- en: 'Now let us compare the preceding example to similar code using Spring WebFlux:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将前面的示例与使用Spring WebFlux的类似代码进行比较：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the reactive style, the handler method returns a special reactive type.
    For WebFlux (using the Project Reactor library as the reactive streams implementation),
    the result type will be `Mono` (for at most one data item) or `Flux` (a reactive
    analogy of a collection that can contain any number of items).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式风格，处理程序方法返回一个特殊反应类型。对于WebFlux（使用Project Reactor库作为反应式流实现），结果类型将是`Mono`（最多一个数据项）或`Flux`（一个可以包含任何数量项的集合的反应式类似物）。
- en: The reactive handler method is invoked and returns before even the first request
    starts being processed. It is only used to declaratively build the pipeline of
    asynchronous transformations that should be performed for each request. The actual
    request processing is then controlled by the reactive framework, depending on
    the availability of data to process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式处理程序方法在甚至第一个请求开始处理之前就被调用并返回。它仅用于声明式地构建每个请求应执行的异步转换的管道。实际的请求处理由反应式框架控制，具体取决于可处理的数据的可用性。
- en: By breaking up the processing into separate asynchronous steps (transformation
    functions), the reactive programming style lets the framework use the computing
    resources just in time when the data is available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将处理分解为单独的异步步骤（转换函数），反应式编程风格允许框架在数据可用时及时使用计算资源。
- en: 'For the reactive framework to be efficient, the pipeline steps (that would
    be the functions that are the arguments of the map functions in the preceding
    examples) are expected to be non-blocking: They should not contain statements
    that synchronously wait for an input/output to finish. Using the reactive programming
    style on the incoming API request layer (the `Controller` class in WebFlux) does
    not make for a correct reactive implementation. Instead, a reactive program should
    be reactive across all its layers, including database access and downstream API
    calls.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使反应式框架高效，期望管道步骤（即前面示例中map函数的参数函数）是非阻塞的：它们不应包含同步等待输入/输出完成的语句。在WebFlux的传入API请求层（`Controller`类）上使用反应式编程风格并不构成正确的反应式实现。相反，一个反应式程序应该在所有层，包括数据库访问和下游API调用中都是反应式的。
- en: 'The reactive programming paradigm enables the development of extremely scalable
    services and systems. Among other features, reactive streams enhance the communication
    between the code parts that implement individual processing steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程范式使得开发极其可扩展的服务和系统成为可能。在其他特性中，反应式流增强了实现单个处理步骤的代码部分之间的通信：
- en: Failures are expected and can also be processed reactively; reactive streams
    have a separate error channel for that. This is different from ordinary Java streams
    where failures (Java exceptions) break the whole pipeline, not allowing the processing
    to continue without explicit catch clauses.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data consumers can control the rate of data sent to them by the producers using
    so-called back pressure.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, with reactive programming, we pay the tax of having to fragment
    the implementation code into small non-blocking functions capable of running on
    different threads. Reactive programming increases complexity due to its asynchronous
    and multi-threaded nature, as well as by requiring the discipline to avoid blocking
    input/output. It puts an increased cognitive load on developers who need to be
    able to translate between the pipeline declarations and the runtime execution.
    Request processing spanning multiple threads makes debugging more difficult since
    the steps leading to a particular execution point are not aligned with the stack
    trace of the current thread. Therefore, it is advisable to make sure the application
    being developed needs the level of scalability that justifies the increased complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If the only problem you need to solve is the efficient use of threads so that
    CPU cores are not idle waiting for blocking operations, it can be done with the
    currently available versions of Java without incurring the cost of introducing
    reactive programming. It was explained in the in the section, *Increasing the
    throughput with virtual threads* , in [*Chapter 10*](B21843_10.xhtml#_idTextAnchor284)
    .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the criteria for choosing the imperative versus the reactive option
    of the backend framework, try to answer the following questions. The more your
    answers converge to “yes,” the more likely it makes sense to use the reactive
    implementation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Is scalability near the top of the features you optimize for?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the team ready to accept the increased cognitive load of reactive programming?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need advanced stream control features such as backpressure?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it *not* possible to use virtual threads?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can all the layers (database access, downstream API calls, etc.) of your application
    be reactive?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will take a look at various Java server-side implementation
    frameworks, grouped by the related standards, and a little bit of historical context.
    Before we move on to the next section, here is a table that is providing a chronological
    overview of major Java standards and their associated server-side framework implementations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '| **Standards** | **year** | **Implementations** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| Java 2 EE | 1999 |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '|  | 2000 |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '|  | 2001 |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '|  | 2002 |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '|  | 2003 |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '|  | 2004 | Spring Framework 1.0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '|  | 2005 |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '|  | 2006 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '|  | 2007 |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '|  | 2008 |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| JAX-RS in Java EE 6 | 2009 |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '|  | 2010 |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '|  | 2011 |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '|  | 2012 |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '|  | 2013 |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '|  | 2014 | Spring Boot 1.0 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '|  | 2015 |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| MicroProfile 1.0 | 2016 |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Java EE 8 | 2017 |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Java EE 8 | 2017 |  |'
- en: '|  | 2018 | Micronaut 1.0 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  | 2018 | Micronaut 1.0 |'
- en: '|  | 2019 | Helidon 1.0, Quarkus 1.0 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  | 2019 | Helidon 1.0, Quarkus 1.0 |'
- en: '| Jakarta EE 9 | 2020 |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 9 | 2020 |  |'
- en: '|  | 2021 |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  | 2021 |  |'
- en: '| Jakarta EE 10 | 2022 |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 10 | 2022 |  |'
- en: '|  | 2023 |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | 2023 |  |'
- en: '| MicroProfile 7.0 | 2024 |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| MicroProfile 7.0 | 2024 |  |'
- en: '| Jakarta EE 11 | 2025 |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 11 | 2025 |  |'
- en: Table 11.1 – Timeline of standards and frameworks
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – 标准和框架的时间线
- en: Java EE and Jakarta EE
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 和 Jakarta EE
- en: The Java language and platform can be used to develop various types of applications;
    however, the area where Java has become the most successful and popular is server-side
    (backend) applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言和平台可以用来开发各种类型的应用程序；然而，Java 最成功和最受欢迎的领域是服务器端（后端）应用程序。
- en: '**Java Enterprise Edition (Java EE** ) is a set of standard APIs that extend
    the **Java Standard Edition** (Java SE, commonly referred to as just “Java” and
    implemented by various products that build on the OpenJDK project) to support
    the development of server-side applications.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Enterprise Edition (Java EE**) 是一组标准 API，它扩展了 **Java Standard Edition**
    (Java SE，通常简称为“Java”，由各种基于 OpenJDK 项目构建的产品实现) 以支持服务器端应用程序的开发。'
- en: From Java 2 Platform, Enterprise Edition to Jakarta EE
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Java 2 Platform, Enterprise Edition 到 Jakarta EE
- en: Java EE started with the name Java 2 Platform, Enterprise Edition (J2EE), along
    with the release of version 2 of Java (SE) by Sun Microsystems. The Java trademark
    and Java EE passed to Oracle, which acquired Sun Microsystems in 2010. The last
    version of Java EE is Java EE 8, released in 2017.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 以 Java 2 Platform, Enterprise Edition (J2EE) 的名称开始，与 Sun Microsystems
    发布的 Java (SE) 版本 2 一起。Java 商标和 Java EE 转移给了 Oracle，后者在 2010 年收购了 Sun Microsystems。Java
    EE 的最后一个版本是 Java EE 8，于 2017 年发布。
- en: After Java EE 8, the Java EE code and documentation were donated to the Eclipse
    Foundation, and the specification, starting from version 9, is named *Jakarta
    EE* ( [https://jakarta.ee/](https://jakarta.ee/) ). The respective Java packages
    were renamed from `javax.*` to `jakarta.*` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 8 之后，Java EE 代码和文档捐赠给了 Eclipse 基金会，规范从版本 9 开始命名为 *Jakarta EE* ([https://jakarta.ee/](https://jakarta.ee/)
    )。相应的 Java 包从 `javax.*` 重命名为 `jakarta.*` 。
- en: Types of JEE containers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JEE 容器的类型
- en: An implementation of the Jakarta EE specification is called a *Jakarta EE container*
    (also known as an application server), to which Jakarta EE applications can be
    deployed in the form of **Web Archives (WAR)** or **Enterprise Application Archives
    (EAR)** . There are various commercial and open-source implementations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 规范的实现被称为 *Jakarta EE 容器*（也称为应用服务器），Jakarta EE 应用程序可以以 **Web 归档 (WAR**)
    或 **企业应用程序归档 (EAR**) 的形式部署到其中。有各种商业和开源实现。
- en: An application server can be a full Jakarta EE container (for example, WebSphere,
    OpenLiberty, JBoss, GlassFish, Payara, or TomEE) or it can be a *servlet (web)
    container* only supporting a subset of the Jakarta EE APIs (for example, Jetty
    or Apache Tomcat). The *Servlet API* is a standard way for Jakarta EE applications
    to serve HTTP requests.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器可以是完整的 Jakarta EE 容器（例如，WebSphere、OpenLiberty、JBoss、GlassFish、Payara 或
    TomEE），或者它只能是一个仅支持 Jakarta EE API 子集的 *servlet (web) 容器*（例如，Jetty 或 Apache Tomcat）。*Servlet
    API* 是 Jakarta EE 应用程序服务 HTTP 请求的标准方式。
- en: From the Servlet API to declarative endpoint handler methods
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Servlet API 到声明式端点处理方法
- en: 'The **Servlet API** models how an HTTP server sees the communication: The main
    objects are the HTTP request and response, encapsulating all the details such
    as the HTTP method, URI path, headers, and request parameters. The handler method
    must explicitly (imperatively) implement the logic to read the items of the request
    it is interested in and set them in the response. The payloads are accessed as
    Java I/O streams. The handler method has to convert between the streams of bytes
    and structured data objects (model classes).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Servlet API** 模拟了 HTTP 服务器如何看待通信：主要对象是 HTTP 请求和响应，封装了所有细节，如 HTTP 方法、URI 路径、头信息和请求参数。处理方法必须显式（命令式）实现读取它感兴趣的请求项并将其设置在响应中的逻辑。有效负载作为
    Java I/O 流访问。处理方法必须在字节流和结构化数据对象（模型类）之间进行转换。'
- en: Another Jakarta EE API specification, **Jakarta RESTful Web Services (JAX-RS)**
    , builds on the Servlet API to make implementation of RESTful web services easier
    by providing a declarative programming model where the developer only implements
    handler methods annotated with their respective resource paths and HTTP methods.
    The JAX-RS implementation automatically dispatches the HTTP requests to the matching
    handler methods. It also deserializes the request bodies and serializes the responses.
    JAX-RS in Jakarta EE is like Spring Web MVC in the Spring ecosystem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'As the handler classes provide REST resources, the convention is to call them
    “resources,” – for example, a class providing methods operating on products could
    be named `ProductResource` . The resource path is specified with the `@Path` annotation
    and there are annotations for specifying the HTTP method: `@GET` , `@POST` , `@PUT`
    , and so on. You can see that a resource class is like a controller class in Spring
    Web.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework and Spring Boot
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early versions of Java EE (most notably **Enterprise Java Beans** ) were infamous
    for being hard to use for developers and requiring a lot of boilerplate code.
    JAX-RS (mentioned above) and CDI (the dependency injection standard) only came
    to Java EE with version 6, released in 2009.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: That situation motivated the creation of the **Spring Framework** ( [https://spring.io/](https://spring.io/)
    ), with version 1.0 released in 2004. Among other features and modules, it provided
    support for dependency injection, aspect-oriented programming, and Spring Web
    MVC, the module enabling web service implementation with controller classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework with **Spring Web MVC** (commonly referred to as just **Spring
    Web** ) and many other modules, thanks to improvements in developer experience,
    has become very popular and is the most used framework for developing server-side
    Java applications currently.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The requirement to deploy applications to a separate software product, the Java
    EE container, was perceived as an unnecessary additional step by developers. Upgrades
    of application servers required organizational coordination that caused them to
    be complex and slow, impeding technical modernization, including the upgrades
    to new Java (SE) versions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: To prevent CPU and memory usage or specific extensions of one application from
    influencing other applications, there is a common practice to use a separate application
    server instance for each application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '*Spring Boot* , first released in 2014, brought the possibility to develop
    standalone Spring applications that can be run directly without a separate application
    server. The application can be packaged as a simple **Java Archive (JAR)** that
    includes an embedded web server (Tomcat by default). Simplified deployment, together
    with other features such as easy configuration and sensible defaults, made Spring
    Boot a good fit for developing microservices.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Spring Framework and Spring Boot have become a de facto standard in
    backend Java development, it is important to understand that Spring Web and many
    other Spring modules are just a layer on top of Java/Jakarta EE. When using Spring
    Web, you use not only Spring-specific abstractions but also Java/Jakarta EE features
    directly: Servlet API, Java Bean Validation API, and so on. By using a particular
    version of Spring, you automatically depend on a particular version of Java/Jakarta
    EE as well.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Spring 框架和 Spring Boot 已成为后端 Java 开发的既定标准，但重要的是要理解 Spring Web 和许多其他 Spring
    模块只是 Java/Jakarta EE 之上的一个层。当使用 Spring Web 时，你不仅使用 Spring 特定的抽象，还直接使用 Java/Jakarta
    EE 功能：Servlet API、Java Bean 验证 API 等。通过使用特定的 Spring 版本，你自动依赖于特定的 Java/Jakarta
    EE 版本。
- en: New microservice frameworks and MicroProfile
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的微服务框架和 MicroProfile
- en: Jakarta EE and Spring Boot, thanks to their long history, are the most mature
    and most well-known server-side Java application frameworks, providing reliability
    and stability to many developers. However, around the years 2018-2019, new frameworks
    such as *Micronaut* , *Helidon* , and *Quarkus* gradually appeared, which, by
    not being limited by backward compatibility, could choose innovative approaches
    to application development and better meet the current challenges of microservices
    and cloud deployment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其悠久的历史，Jakarta EE 和 Spring Boot 是最成熟和最知名的Java服务器端应用框架，为许多开发者提供了可靠性和稳定性。然而，在
    2018-2019 年左右，新的框架如 *Micronaut*、*Helidon* 和 *Quarkus* 逐渐出现，它们不受向后兼容性的限制，可以选择创新的应用开发方法，更好地满足微服务和云部署的当前挑战。
- en: 'Highly scalable cloud-native applications need to be able to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 高度可扩展的云原生应用需要能够做到以下事项：
- en: Start new service instances quickly to adapt to higher load (upscaling) or to
    restart after failures
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速启动新的服务实例以适应更高的负载（扩展）或失败后的重启
- en: Use as little CPU, memory, and networking resources as possible to optimize
    cloud service costs
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能少地使用 CPU、内存和网络资源，以优化云服务成本
- en: 'Such applications should have the following characteristics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用应具备以下特点：
- en: A small application executable code size to minimize the time delay and network
    traffic needed to transfer the application to the cloud nodes where new service
    instances should run
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的应用程序可执行代码大小，以最小化将应用程序传输到新服务实例应运行的云节点所需的时间延迟和网络流量
- en: A short service startup time (the time the service spends preparing before being
    able to serve requests)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短的服务启动时间（服务在能够处理请求之前准备的时间）
- en: A small and stable memory consumption (even if a service needs more memory during
    startup only, it will need a larger and more expensive cloud computing instance)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小而稳定的内存消耗（即使服务在启动时需要更多内存，也只需要更大、更昂贵的云计算实例）
- en: 'The new microservice frameworks address these challenges by bringing the following
    features:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新的微服务框架通过以下功能来解决这些挑战：
- en: Limiting the number and complexity of library dependencies
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制库依赖项的数量和复杂性
- en: Replacing dynamic processing during application startup (application configuration,
    dependency injection, and aspect-oriented programming) with static code generation
    during application build
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序构建期间用静态代码生成替换应用程序启动期间的动态处理（应用程序配置、依赖注入和面向切面编程）
- en: Avoiding the use of reflection, dynamic class loading, or dynamic (proxy) class
    creation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用反射、动态类加载或动态（代理）类创建
- en: The resulting applications are well-suited for ahead-of-time compilation to
    platform-native code (using **GraalVM** – see [https://www.graalvm.org/](https://www.graalvm.org/)
    )
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应用程序非常适合进行预编译到平台原生代码（使用 **GraalVM** – see [https://www.graalvm.org/](https://www.graalvm.org/)
    )
- en: On the other hand, the emergence of new frameworks brought the problems of how
    to avoid the fragmentation of the Java backend developer community and how to
    overcome the barrier of adoption of the frameworks because of a lack of developers
    familiar with their programming model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，新框架的出现带来了如何避免 Java 后端开发者社区碎片化的问题，以及如何克服由于缺乏熟悉其编程模型的开发者而导致的框架采用障碍的问题。
- en: The Micronaut framework tries to help with the transition from Spring and Spring
    Boot by providing similar abstractions (controllers), supporting many Spring annotations,
    and other compatibility features to make the transition from Spring smooth.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 框架试图通过提供类似的抽象（控制器）、支持许多 Spring 注解以及其他兼容性功能来帮助从 Spring 和 Spring Boot
    过渡，从而使过渡过程更加顺畅。
- en: All the new frameworks try to some extent to exploit the potential of the experience
    and the broad community around the Java/Jakarta EE standards. Due to their lightweight
    nature, they choose to implement only selected parts of the Jakarta EE specification.
    In contrast, they do implement additional features required by distributed cloud-native
    applications, such as declarative REST clients, observability, fault tolerance,
    and so on, that were not standardized within Jakarta EE.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的框架在某种程度上都试图利用Java/Jakarta EE标准周围的经验和广泛社区潜力。由于它们的轻量级特性，它们选择仅实现Jakarta EE规范的部分内容。相比之下，它们确实实现了分布式云原生应用所需的附加功能，例如声明式REST客户端、可观察性、容错性等，这些功能在Jakarta
    EE中并未标准化。
- en: Many of the above-mentioned features were standardized in the **MicroProfile**
    specification ( [https://microprofile.io/](https://microprofile.io/) ) whose version
    1.0 was created in 2016. Shortly after its creation, the MicroProfile project
    joined the Eclipse Foundation. The latest MicroProfile version available at the
    time of writing this book is 7.0. It is aligned with version 10.0 of Jakarta EE.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 许多上述功能已在**MicroProfile**规范（[https://microprofile.io/](https://microprofile.io/)）中标准化，其1.0版本于2016年创建。在其创建后不久，MicroProfile项目加入了Eclipse基金会。本书撰写时，可用的最新MicroProfile版本是7.0，它与Jakarta
    EE的10.0版本保持一致。
- en: The subset of Jakarta EE that overlaps with MicroProfile is named the **Core
    Profile** . The parts of the Core Profile that are the most interesting in the
    context of this book are Jakarta RESTful Web Services, Jakarta JSON Binding, and
    Jakarta JSON Processing. The Core Profile also contains the lightweight dependency
    injection framework called Jakarta CDI Lite, Jakarta Interceptors, and obviously
    Jakarta Annotations as a common dependency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与MicroProfile重叠的Jakarta EE子集被称为**Core Profile**。在本书的上下文中，Core Profile中最有趣的部分是Jakarta
    RESTful Web Services、Jakarta JSON Binding和Jakarta JSON Processing。Core Profile还包含名为Jakarta
    CDI Lite的轻量级依赖注入框架、Jakarta Interceptors以及显然是作为公共依赖的Jakarta Annotations。
- en: 'MicroProfile 7.0 extends the Core Profile with the following modules, which
    are very relevant for API and microservice implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 7.0通过以下模块扩展了Core Profile，这些模块对于API和微服务实现非常相关：
- en: '**OpenAPI** : Generating OpenAPI specification from code for the code-first
    approach, we showed its Spring alternative in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI**：从代码生成OpenAPI规范，对于代码优先方法，我们在[*第3章*](B21843_03.xhtml#_idTextAnchor076)中展示了其Spring替代方案'
- en: '**REST Client** : For consuming REST APIs using the code-first approach (we
    used the specification-first approach with client code generation in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) )'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST客户端**：用于使用代码优先方法消费REST API（我们在[*第4章*](B21843_04.xhtml#_idTextAnchor096)中使用了规范优先方法，并生成了客户端代码）'
- en: '**Fault tolerance** : Also known as resilience, discussed in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：也称为弹性，在[*第6章*](B21843_06.xhtml#_idTextAnchor135)中讨论'
- en: '**JWT** authentication: An important part of API security, discussed in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JWT**身份验证：API安全性的重要部分，在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中讨论'
- en: '**Telemetry** : Providing observability, we showed this aspect using Spring
    in [*Chapter 9*](B21843_09.xhtml#_idTextAnchor240)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遥测**：提供可观察性，我们使用Spring展示了这一方面，在[*第9章*](B21843_09.xhtml#_idTextAnchor240)中'
- en: '**Health:** Used by orchestrators such as Kubernetes to probe a service instance
    for its healthand readiness to serve requests, a functionality provided by the
    Actuator in Spring Boot, we will show this using Spring in [*Chapter 12*](B21843_12.xhtml#_idTextAnchor330)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：由Kubernetes等编排器用于探测服务实例的健康状况和准备就绪状态，这是Spring Boot中Actuator提供的一项功能，我们将在[*第12章*](B21843_12.xhtml#_idTextAnchor330)中使用Spring展示这一点'
- en: '**Config** : Flexible configuration options, a common requirement for cloud-native
    services'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：灵活的配置选项，云原生服务的一个常见要求'
- en: 'After listing the abstract concepts that the MicroProfile specification covers,
    in the following sections, we will show small examples of API implementations
    using two frameworks that fully implement the MicroProfile specification: *Quarkus*
    and *Helidon* .'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出MicroProfile规范涵盖的抽象概念之后，在接下来的章节中，我们将展示使用两个完全实现MicroProfile规范的框架（*Quarkus*和*Helidon*）的API实现的小示例。
- en: Example implementation with Quarkus
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus的示例实现
- en: '**Quarkus** ( [https://quarkus.io/](https://quarkus.io/) ) is a framework providing
    optimized startup time and memory usage. Quarkus makes deployment to Kubernetes
    and the cloud easy in many ways. Despite being relatively new, thanks to its great
    developer experience, it has been adopted quickly in many enterprise application
    development projects.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Among other features, Quarkus boasts its *development mode (dev mode)* , which
    detects changes in Java source files or resource files (e.g., configuration properties),
    recompiles them automatically, and applies them (if possible) to the running application
    (performs a so-called hot deployment) without a need for an explicit restart.
    With the dev mode, the developer gets fast feedback without losing focus on the
    code due to lengthy application rebuilds and restarts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We will start our Quarkus example by implementing the Product API, as we did
    in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) with Spring Boot.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the Product API
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same endpoint design as in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    :'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /products` to list all products'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /products/{id}` to create or update a product'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /products/{id}` to remove a product'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /products/{id}` to update product description only'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /products/{id}` to get the data of one product.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the same Clean Architecture structure, so for exposing the REST
    API we will focus on the `*.adapter.inbound.rest` package. The main class in the
    package is the resource class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The resource class
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In accordance with the Jakarta REST terminology, the class handling the REST
    resource endpoints is named `ProductResource` . The base URL path for the resource
    endpoints is specified using the `@Path` annotation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each endpoint is implemented by a handler method. Let us start with the `createOrUpdateProduct`
    operation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are multiple annotations on the method and its arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '`@PUT` : The HTTP method'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Path` : The endpoint relative path'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Consumes` : The expected request content type'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces` : The response content type'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathParam` : The argument bound to the URL path parameter'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in `@Valid` and custom `@ValidSku` bean validation annotations are
    used the same way as with Spring Boot.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` method return type, like `ResponseEntity` in Spring Boot, lets
    the method body decide on the HTTP response code and additional response headers
    dynamically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to list all products is quite simple; the only annotation needed
    is the HTTP method, and the method returns the body of the HTTP response directly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method to get one product by its ID is similar, but in addition, it needs
    the `productId` path parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the method to update a product description:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And finally, the method to remove a product:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '**Keeping within the standard**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, in the resource class, we deliberately decided to only use
    the annotations from packages starting with the `jakarta.` prefix so that our
    code stays within the MicroProfile specification. We could have used other annotations
    supported by Quarkus (and recommended in some tutorials) – for example, `org.jboss.resteasy.RestPath`
    instead of `jakarta.ws.rs.PathParam` – and we could have skipped specifying the
    parameter name ( `"productId"` ) as it would be inferred from the method argument
    name. However, that would make the code Quarkus-specific. For the reasons stated
    earlier in this chapter, it makes sense to use standardized APIs even if it means
    sacrificing a little bit of the convenience some specific implementation may offer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the package (DTOs, mappers, and the ValidSku annotation) are framework-independent,
    so the code is the same as for Spring Boot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: To handle exceptions by mapping them to the correct HTTP responses, MicroProfile
    supports the ExceptionMapper interface, described in the following section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Exception mappers
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our example API, we want to define mappings for two exception types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityNotFoundException` , meaning a product with the given ID is not found'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationException` , meaning some input does not comply with the bean validation
    annotations'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both mapper classes are alike, so it will suffice if we show the first of them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It can be seen that the `ProblemDetail` DTO is defined in our code as it is
    not provided by Jakarta REST.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will briefly mention the remaining parts of our
    application and test the REST API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Completing and testing the Quarkus application
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes in the `domain` and `usecase` packages, decoupled from the communication
    layers using Clean Architecture, need not change when we switch from Spring Boot
    to Quarkus.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: To create a working Quarkus application, we need to implement persistence. We
    use Jakarta Persistence to map the database tables to entity classes. However,
    to be able to access the database using the Repository pattern (as we did with
    Spring Data), we have to use Panache, which is a module specific to Quarkus.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern for persistence is not standardized within MicroProfile;
    however, there isthe new Jakarta Data specification in Jakarta EE 11.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: To link the components of our application together, we use dependency injection
    with Jakarta Contexts and Dependency Injection (CDI) features ( `@ApplicationScoped`
    and `@Inject` annotations) that are supported by MicroProfile.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: As persistence and dependency injection are concepts that are not specific to
    RESTful web service implementation, we are not going to explain in more detail
    how to use them with Quarkus, MicroProfile, or Jakarta EE.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have the application code complete, we can start the application using
    the convenient Quarkus dev mode:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we can try the API endpoints using the `curl` commands, creating the product
    with the `PUT` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We list all products:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next chapter, we will get the documentation of the API we have just created
    in the OpenAPI standard.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Getting the API specification from the code
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how the implementation-independent specification of an API can be generated
    for a Spring Boot application in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: A similar code-first approach is available for MicroProfile applications, thanks
    to the MicroProfile OpenAPI specification.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add just one dependency in the `pom.xml` file of our Quarkus application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can enter the Swagger UI by opening the [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    URL in a web browser.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Swagger UI generated from a Quarkus application](img/B21843_11_1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Swagger UI generated from a Quarkus application
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI specification (in YAML format) can be downloaded using the [http://localhost:8080/q/openapi](http://localhost:8080/q/openapi)
    URL.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We have shown how to create and document the Product API with Quarkus using
    the code-first approach. In the next chapter, you will see that, even with Quarkus,
    we can create APIs specification-first, using Java code generation from OpenAPI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Generating MicroProfile code from OpenAPI
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a stub (not the full implementation) of the Order Management
    API that was implemented with Spring Boot in [*Chapter 4*](B21843_04.xhtml#_idTextAnchor096)
    .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the same `Order_Management_API.yml` specification file as in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pom.xml` file contains the same Quarkus dependencies as in the *Exposing
    the Product API* section. Additionally, we add the plugin configurations to generate
    the code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some configuration parameters are the same as with Spring: package names, model
    name suffix. The generator name is different; we are using the one compliant with
    the JAX-RS specification. We use the `useJakartaEe` flag because the current version
    of the specification requires `jakarta` instead of `javax` as the package prefix.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We use the `interfaceOnly` flag because we want our manually written classes
    to implement generated interfaces. This way, if our implementation does not match
    the generated interface, it will be reported by the compiler automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the Maven `compile` goal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see the generated sources in the `target/generated-sources/openapi` directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run the Quarkus application now, and open the Swagger UI at [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    , we will see that no REST endpoints (operations) are exposed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Swagger UI showing no operations](img/B21843_11_2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Swagger UI showing no operations
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to provide an implementation of the generated interface. Before doing
    so, we need to add one more plugin to make the generated sources accessible from
    our manually written code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just to demonstrate the concept, we will create a stub implementation of the
    generated interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Opening the Swagger UI again shows that the operations are now available.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B21843_11_3.png) Figure 11.3 – Swagger UI of the Order Management
    API'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We can test it, for example, by sending the POST request with the body. The
    response will be empty (because our implementation is not complete) but successful
    (HTTP 2xx status code).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the last section of the chapter, we will see that similar code to what we
    used with Quarkus can work with another framework, Helidon.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Example implementation with Helidon
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have used the MicroProfile annotations only, exactly the same `ProductResource`
    class code that was used with Quarkus works with Helidon, too.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the Panache repository-based data persistence implementation used
    with Quarkus, we use the `EntityManager` interface of the **Jakarta Persistence
    (JPA)** specification directly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, compared to the Quarkus implementation, we had to put different dependencies
    in the `pom.xml` file, and we used different configuration files, too.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is built with this Maven command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we can start the application JAR file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, the API of the running application will behave the same way as the
    other implementations, so it can be tested with the same `curl` commands.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the MicroProfile OpenAPI compliance and Helidon OpenAPI UI module,
    when these dependencies are in our `pom.xml` file, we can see the documentation
    of the REST API in a web browser at [http://localhost:8080/openapi/ui](http://localhost:8080/openapi/ui)
    .
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – OpenAPI UI generated by Helidon](img/B21843_11_4.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – OpenAPI UI generated by Helidon
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We can see that, using the MicroProfile standard features, we get the same results
    when switching the frameworks from Quarkus to Helidon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we summarized from a high-level perspective, the different
    frameworks that can be used to implement Java services exposing REST APIs. Using
    a historical overview, we explained the different goals and features that motivated
    the creation of these frameworks. We explained how vendor-neutral standards help
    prevent developer community fragmentation and lock-in to a particular implementation
    technology. By implementing parts of our example APIs in two MicroProfile-compliant
    frameworks (Quarkus and Helidon), we demonstrated that the various REST API design
    principles we went through in the previous chapters can be applied regardless
    of the framework used and lead to application code with the same basic structure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
