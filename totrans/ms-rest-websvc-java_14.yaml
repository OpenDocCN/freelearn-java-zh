- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alternative Java Frameworks to Build RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this chapter, we have used the Spring Boot framework to demonstrate the
    API implementation in real code. By using the very popular Spring Boot, we are
    trying to the book as readable and useful for as many readers as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to explain why and how other Java frameworks can be used to implement
    RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the same design principles and a similar code structure are
    still applicable, so you can use the concepts from the other chapters with any
    framework you may want to use for your specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will explain how standards such as Jakarta EE and MicroProfile can
    help you not get lost in the sea of frameworks and implementation stacks you could
    use to build your application. We will briefly mention the possibility of using
    reactive programming, available with most current frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The current choice of implementation technologies is the result of the history
    of innovative approaches to aid developers in creating applications that fulfill
    the current architectural and deployment preferences. We will walk you from Java
    EE through Spring to frameworks such as Quarkus and the MicroProfile specification.
  prefs: []
  type: TYPE_NORMAL
- en: To provide you with a detailed view, we will demonstrate the similarities and
    differences in our example API implementation with the Quarkus and Helidon frameworks
    compared to the Spring Boot implementation from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes for the following list of sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing imperative or reactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java EE and Jakarta EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework and Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New microservice frameworks and MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example implementation with Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example implementation with Helidon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will demonstrate the use of frameworks other than Spring
    Boot (used in previous chapters). However, the necessary dependencies will be
    downloaded during the project build automatically based on the Maven `pom.xml`
    file, so the prerequisites stay the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of the Java language and platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least basic knowledge of Spring Boot or a similar framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 21 and Maven 3.9.x installed (alternatively, you can use the `mvnw` command
    included in the example code, which will download the correct Maven version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is a versatile language with a large ecosystem of both open source and
    commercial frameworks and libraries. Hence, you have more options to choose from
    than you will ever be able to fully evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: You could even try to implement your own HTTP server or client and a custom
    framework, although it is not recommended other than for educational purposes
    due to the extreme costs of catching the details needed to make it production-ready
    and to maintain it.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a framework or any component your software will depend on is difficult.
    It involves predicting both the future features your software will need and the
    future evolution and support of the framework (dependency).
  prefs: []
  type: TYPE_NORMAL
- en: For example, an application based on the Java Enterprise Edition standard needs
    to be deployed to an application server. Later, a need to deploy new application
    versions frequently, cloud deployment, and scalability requirements may require
    a faster startup time, smaller container size, and removing the dependency on
    the application server. Or, the version of the application server the operations
    team has experience with may become outdated and it will limit the version of
    Java that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: A common approach is to choose between the frameworks with large communities
    of users and developers. But we also want new innovative frameworks to enter the
    market, although their communities will naturally start small.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, vendor-neutral standards and specifications have been created to
    prevent the Java community from becoming fragmented by mutually incompatible frameworks.
    By choosing a framework that conforms to a standard, you retain the option to
    switch to a different implementation of the same standard. It will be much easier
    for developers to start working on your code even without experience specific
    to the framework provided they are familiar with the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the following sections, we focus not only on the individual frameworks
    but also on the standards (specifications) they support.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing imperative or reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we used the imperative programming style using the
    Spring Web framework.
  prefs: []
  type: TYPE_NORMAL
- en: The **imperative programming style** models an API operation using a simple
    Java method that takes data from the HTTP request as arguments and returns a result
    object that will be used to generate the HTTP response. The method body consists
    of statements that are executed sequentially in the order they appear in the code
    using one Java thread.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code snippet, we can see the statements `statement1` , `statement2`
    , and so on, which will be executed one after another in one thread, with access
    to the same scope of variables and the same call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A similar code snippet shows the same structure when the result contains multiple
    entities. This time, the result type is a well-known Java collection ( `List`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The style is called *imperative* because the program is understood as a sequence
    of commands, telling the computer explicitly what steps to perform in which order.
    In this model, data is just parameters for the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the “classic” imperative style, with most modern frameworks you also
    have the option of using the reactive style. For example, with the Spring framework
    family, you can use *Spring WebFlux* .
  prefs: []
  type: TYPE_NORMAL
- en: The **reactive programming style** is built around the idea of asynchronous
    processing of streams of data. The program execution is understood as driven by
    the flow of data. The program reacts to the incoming data items using a pipeline
    of functions (data transformations).
  prefs: []
  type: TYPE_NORMAL
- en: The processing steps of a single request using the reactive style are executed
    asynchronously and they usually jump between different Java threads.
  prefs: []
  type: TYPE_NORMAL
- en: Several libraries were created to support reactive programming in Java, among
    them *RxJava* and *Project Reactor* . All of them share common features based
    on the Observable design pattern. Their interfaces were standardized in the Reactive
    Streams specification ( [https://www.reactive-streams.org/](https://www.reactive-streams.org/)
    ). Starting from Java version 9, the interfaces from the Reactive Streams specification
    have been part of the standard Java API as interfaces embedded in the `java.util.concurrent.Flow`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us compare the preceding example to similar code using Spring WebFlux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the reactive style, the handler method returns a special reactive type.
    For WebFlux (using the Project Reactor library as the reactive streams implementation),
    the result type will be `Mono` (for at most one data item) or `Flux` (a reactive
    analogy of a collection that can contain any number of items).
  prefs: []
  type: TYPE_NORMAL
- en: The reactive handler method is invoked and returns before even the first request
    starts being processed. It is only used to declaratively build the pipeline of
    asynchronous transformations that should be performed for each request. The actual
    request processing is then controlled by the reactive framework, depending on
    the availability of data to process.
  prefs: []
  type: TYPE_NORMAL
- en: By breaking up the processing into separate asynchronous steps (transformation
    functions), the reactive programming style lets the framework use the computing
    resources just in time when the data is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the reactive framework to be efficient, the pipeline steps (that would
    be the functions that are the arguments of the map functions in the preceding
    examples) are expected to be non-blocking: They should not contain statements
    that synchronously wait for an input/output to finish. Using the reactive programming
    style on the incoming API request layer (the `Controller` class in WebFlux) does
    not make for a correct reactive implementation. Instead, a reactive program should
    be reactive across all its layers, including database access and downstream API
    calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactive programming paradigm enables the development of extremely scalable
    services and systems. Among other features, reactive streams enhance the communication
    between the code parts that implement individual processing steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Failures are expected and can also be processed reactively; reactive streams
    have a separate error channel for that. This is different from ordinary Java streams
    where failures (Java exceptions) break the whole pipeline, not allowing the processing
    to continue without explicit catch clauses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data consumers can control the rate of data sent to them by the producers using
    so-called back pressure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, with reactive programming, we pay the tax of having to fragment
    the implementation code into small non-blocking functions capable of running on
    different threads. Reactive programming increases complexity due to its asynchronous
    and multi-threaded nature, as well as by requiring the discipline to avoid blocking
    input/output. It puts an increased cognitive load on developers who need to be
    able to translate between the pipeline declarations and the runtime execution.
    Request processing spanning multiple threads makes debugging more difficult since
    the steps leading to a particular execution point are not aligned with the stack
    trace of the current thread. Therefore, it is advisable to make sure the application
    being developed needs the level of scalability that justifies the increased complexity.
  prefs: []
  type: TYPE_NORMAL
- en: If the only problem you need to solve is the efficient use of threads so that
    CPU cores are not idle waiting for blocking operations, it can be done with the
    currently available versions of Java without incurring the cost of introducing
    reactive programming. It was explained in the in the section, *Increasing the
    throughput with virtual threads* , in [*Chapter 10*](B21843_10.xhtml#_idTextAnchor284)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the criteria for choosing the imperative versus the reactive option
    of the backend framework, try to answer the following questions. The more your
    answers converge to “yes,” the more likely it makes sense to use the reactive
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Is scalability near the top of the features you optimize for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the team ready to accept the increased cognitive load of reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need advanced stream control features such as backpressure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it *not* possible to use virtual threads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can all the layers (database access, downstream API calls, etc.) of your application
    be reactive?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will take a look at various Java server-side implementation
    frameworks, grouped by the related standards, and a little bit of historical context.
    Before we move on to the next section, here is a table that is providing a chronological
    overview of major Java standards and their associated server-side framework implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Standards** | **year** | **Implementations** |'
  prefs: []
  type: TYPE_TB
- en: '| Java 2 EE | 1999 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2000 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2001 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2002 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2003 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2004 | Spring Framework 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2005 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2006 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2007 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2008 |  |'
  prefs: []
  type: TYPE_TB
- en: '| JAX-RS in Java EE 6 | 2009 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2010 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2011 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2012 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2013 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2014 | Spring Boot 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2015 |  |'
  prefs: []
  type: TYPE_TB
- en: '| MicroProfile 1.0 | 2016 |  |'
  prefs: []
  type: TYPE_TB
- en: '| Java EE 8 | 2017 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2018 | Micronaut 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2019 | Helidon 1.0, Quarkus 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Jakarta EE 9 | 2020 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2021 |  |'
  prefs: []
  type: TYPE_TB
- en: '| Jakarta EE 10 | 2022 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2023 |  |'
  prefs: []
  type: TYPE_TB
- en: '| MicroProfile 7.0 | 2024 |  |'
  prefs: []
  type: TYPE_TB
- en: '| Jakarta EE 11 | 2025 |  |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Timeline of standards and frameworks
  prefs: []
  type: TYPE_NORMAL
- en: Java EE and Jakarta EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java language and platform can be used to develop various types of applications;
    however, the area where Java has become the most successful and popular is server-side
    (backend) applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Enterprise Edition (Java EE** ) is a set of standard APIs that extend
    the **Java Standard Edition** (Java SE, commonly referred to as just “Java” and
    implemented by various products that build on the OpenJDK project) to support
    the development of server-side applications.'
  prefs: []
  type: TYPE_NORMAL
- en: From Java 2 Platform, Enterprise Edition to Jakarta EE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java EE started with the name Java 2 Platform, Enterprise Edition (J2EE), along
    with the release of version 2 of Java (SE) by Sun Microsystems. The Java trademark
    and Java EE passed to Oracle, which acquired Sun Microsystems in 2010. The last
    version of Java EE is Java EE 8, released in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: After Java EE 8, the Java EE code and documentation were donated to the Eclipse
    Foundation, and the specification, starting from version 9, is named *Jakarta
    EE* ( [https://jakarta.ee/](https://jakarta.ee/) ). The respective Java packages
    were renamed from `javax.*` to `jakarta.*` .
  prefs: []
  type: TYPE_NORMAL
- en: Types of JEE containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An implementation of the Jakarta EE specification is called a *Jakarta EE container*
    (also known as an application server), to which Jakarta EE applications can be
    deployed in the form of **Web Archives (WAR)** or **Enterprise Application Archives
    (EAR)** . There are various commercial and open-source implementations.
  prefs: []
  type: TYPE_NORMAL
- en: An application server can be a full Jakarta EE container (for example, WebSphere,
    OpenLiberty, JBoss, GlassFish, Payara, or TomEE) or it can be a *servlet (web)
    container* only supporting a subset of the Jakarta EE APIs (for example, Jetty
    or Apache Tomcat). The *Servlet API* is a standard way for Jakarta EE applications
    to serve HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: From the Servlet API to declarative endpoint handler methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Servlet API** models how an HTTP server sees the communication: The main
    objects are the HTTP request and response, encapsulating all the details such
    as the HTTP method, URI path, headers, and request parameters. The handler method
    must explicitly (imperatively) implement the logic to read the items of the request
    it is interested in and set them in the response. The payloads are accessed as
    Java I/O streams. The handler method has to convert between the streams of bytes
    and structured data objects (model classes).'
  prefs: []
  type: TYPE_NORMAL
- en: Another Jakarta EE API specification, **Jakarta RESTful Web Services (JAX-RS)**
    , builds on the Servlet API to make implementation of RESTful web services easier
    by providing a declarative programming model where the developer only implements
    handler methods annotated with their respective resource paths and HTTP methods.
    The JAX-RS implementation automatically dispatches the HTTP requests to the matching
    handler methods. It also deserializes the request bodies and serializes the responses.
    JAX-RS in Jakarta EE is like Spring Web MVC in the Spring ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the handler classes provide REST resources, the convention is to call them
    “resources,” – for example, a class providing methods operating on products could
    be named `ProductResource` . The resource path is specified with the `@Path` annotation
    and there are annotations for specifying the HTTP method: `@GET` , `@POST` , `@PUT`
    , and so on. You can see that a resource class is like a controller class in Spring
    Web.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework and Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early versions of Java EE (most notably **Enterprise Java Beans** ) were infamous
    for being hard to use for developers and requiring a lot of boilerplate code.
    JAX-RS (mentioned above) and CDI (the dependency injection standard) only came
    to Java EE with version 6, released in 2009.
  prefs: []
  type: TYPE_NORMAL
- en: That situation motivated the creation of the **Spring Framework** ( [https://spring.io/](https://spring.io/)
    ), with version 1.0 released in 2004. Among other features and modules, it provided
    support for dependency injection, aspect-oriented programming, and Spring Web
    MVC, the module enabling web service implementation with controller classes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework with **Spring Web MVC** (commonly referred to as just **Spring
    Web** ) and many other modules, thanks to improvements in developer experience,
    has become very popular and is the most used framework for developing server-side
    Java applications currently.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement to deploy applications to a separate software product, the Java
    EE container, was perceived as an unnecessary additional step by developers. Upgrades
    of application servers required organizational coordination that caused them to
    be complex and slow, impeding technical modernization, including the upgrades
    to new Java (SE) versions.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent CPU and memory usage or specific extensions of one application from
    influencing other applications, there is a common practice to use a separate application
    server instance for each application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Spring Boot* , first released in 2014, brought the possibility to develop
    standalone Spring applications that can be run directly without a separate application
    server. The application can be packaged as a simple **Java Archive (JAR)** that
    includes an embedded web server (Tomcat by default). Simplified deployment, together
    with other features such as easy configuration and sensible defaults, made Spring
    Boot a good fit for developing microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Spring Framework and Spring Boot have become a de facto standard in
    backend Java development, it is important to understand that Spring Web and many
    other Spring modules are just a layer on top of Java/Jakarta EE. When using Spring
    Web, you use not only Spring-specific abstractions but also Java/Jakarta EE features
    directly: Servlet API, Java Bean Validation API, and so on. By using a particular
    version of Spring, you automatically depend on a particular version of Java/Jakarta
    EE as well.'
  prefs: []
  type: TYPE_NORMAL
- en: New microservice frameworks and MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta EE and Spring Boot, thanks to their long history, are the most mature
    and most well-known server-side Java application frameworks, providing reliability
    and stability to many developers. However, around the years 2018-2019, new frameworks
    such as *Micronaut* , *Helidon* , and *Quarkus* gradually appeared, which, by
    not being limited by backward compatibility, could choose innovative approaches
    to application development and better meet the current challenges of microservices
    and cloud deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Highly scalable cloud-native applications need to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start new service instances quickly to adapt to higher load (upscaling) or to
    restart after failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use as little CPU, memory, and networking resources as possible to optimize
    cloud service costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such applications should have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A small application executable code size to minimize the time delay and network
    traffic needed to transfer the application to the cloud nodes where new service
    instances should run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short service startup time (the time the service spends preparing before being
    able to serve requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small and stable memory consumption (even if a service needs more memory during
    startup only, it will need a larger and more expensive cloud computing instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new microservice frameworks address these challenges by bringing the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number and complexity of library dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing dynamic processing during application startup (application configuration,
    dependency injection, and aspect-oriented programming) with static code generation
    during application build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the use of reflection, dynamic class loading, or dynamic (proxy) class
    creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting applications are well-suited for ahead-of-time compilation to
    platform-native code (using **GraalVM** – see [https://www.graalvm.org/](https://www.graalvm.org/)
    )
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the emergence of new frameworks brought the problems of how
    to avoid the fragmentation of the Java backend developer community and how to
    overcome the barrier of adoption of the frameworks because of a lack of developers
    familiar with their programming model.
  prefs: []
  type: TYPE_NORMAL
- en: The Micronaut framework tries to help with the transition from Spring and Spring
    Boot by providing similar abstractions (controllers), supporting many Spring annotations,
    and other compatibility features to make the transition from Spring smooth.
  prefs: []
  type: TYPE_NORMAL
- en: All the new frameworks try to some extent to exploit the potential of the experience
    and the broad community around the Java/Jakarta EE standards. Due to their lightweight
    nature, they choose to implement only selected parts of the Jakarta EE specification.
    In contrast, they do implement additional features required by distributed cloud-native
    applications, such as declarative REST clients, observability, fault tolerance,
    and so on, that were not standardized within Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the above-mentioned features were standardized in the **MicroProfile**
    specification ( [https://microprofile.io/](https://microprofile.io/) ) whose version
    1.0 was created in 2016. Shortly after its creation, the MicroProfile project
    joined the Eclipse Foundation. The latest MicroProfile version available at the
    time of writing this book is 7.0. It is aligned with version 10.0 of Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: The subset of Jakarta EE that overlaps with MicroProfile is named the **Core
    Profile** . The parts of the Core Profile that are the most interesting in the
    context of this book are Jakarta RESTful Web Services, Jakarta JSON Binding, and
    Jakarta JSON Processing. The Core Profile also contains the lightweight dependency
    injection framework called Jakarta CDI Lite, Jakarta Interceptors, and obviously
    Jakarta Annotations as a common dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile 7.0 extends the Core Profile with the following modules, which
    are very relevant for API and microservice implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenAPI** : Generating OpenAPI specification from code for the code-first
    approach, we showed its Spring alternative in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST Client** : For consuming REST APIs using the code-first approach (we
    used the specification-first approach with client code generation in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance** : Also known as resilience, discussed in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JWT** authentication: An important part of API security, discussed in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telemetry** : Providing observability, we showed this aspect using Spring
    in [*Chapter 9*](B21843_09.xhtml#_idTextAnchor240)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health:** Used by orchestrators such as Kubernetes to probe a service instance
    for its healthand readiness to serve requests, a functionality provided by the
    Actuator in Spring Boot, we will show this using Spring in [*Chapter 12*](B21843_12.xhtml#_idTextAnchor330)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Config** : Flexible configuration options, a common requirement for cloud-native
    services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After listing the abstract concepts that the MicroProfile specification covers,
    in the following sections, we will show small examples of API implementations
    using two frameworks that fully implement the MicroProfile specification: *Quarkus*
    and *Helidon* .'
  prefs: []
  type: TYPE_NORMAL
- en: Example implementation with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quarkus** ( [https://quarkus.io/](https://quarkus.io/) ) is a framework providing
    optimized startup time and memory usage. Quarkus makes deployment to Kubernetes
    and the cloud easy in many ways. Despite being relatively new, thanks to its great
    developer experience, it has been adopted quickly in many enterprise application
    development projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Among other features, Quarkus boasts its *development mode (dev mode)* , which
    detects changes in Java source files or resource files (e.g., configuration properties),
    recompiles them automatically, and applies them (if possible) to the running application
    (performs a so-called hot deployment) without a need for an explicit restart.
    With the dev mode, the developer gets fast feedback without losing focus on the
    code due to lengthy application rebuilds and restarts.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our Quarkus example by implementing the Product API, as we did
    in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the Product API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same endpoint design as in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /products` to list all products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /products/{id}` to create or update a product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /products/{id}` to remove a product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /products/{id}` to update product description only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /products/{id}` to get the data of one product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the same Clean Architecture structure, so for exposing the REST
    API we will focus on the `*.adapter.inbound.rest` package. The main class in the
    package is the resource class.
  prefs: []
  type: TYPE_NORMAL
- en: The resource class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In accordance with the Jakarta REST terminology, the class handling the REST
    resource endpoints is named `ProductResource` . The base URL path for the resource
    endpoints is specified using the `@Path` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each endpoint is implemented by a handler method. Let us start with the `createOrUpdateProduct`
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple annotations on the method and its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@PUT` : The HTTP method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Path` : The endpoint relative path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Consumes` : The expected request content type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces` : The response content type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathParam` : The argument bound to the URL path parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in `@Valid` and custom `@ValidSku` bean validation annotations are
    used the same way as with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` method return type, like `ResponseEntity` in Spring Boot, lets
    the method body decide on the HTTP response code and additional response headers
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to list all products is quite simple; the only annotation needed
    is the HTTP method, and the method returns the body of the HTTP response directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to get one product by its ID is similar, but in addition, it needs
    the `productId` path parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the method to update a product description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the method to remove a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Keeping within the standard**'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, in the resource class, we deliberately decided to only use
    the annotations from packages starting with the `jakarta.` prefix so that our
    code stays within the MicroProfile specification. We could have used other annotations
    supported by Quarkus (and recommended in some tutorials) – for example, `org.jboss.resteasy.RestPath`
    instead of `jakarta.ws.rs.PathParam` – and we could have skipped specifying the
    parameter name ( `"productId"` ) as it would be inferred from the method argument
    name. However, that would make the code Quarkus-specific. For the reasons stated
    earlier in this chapter, it makes sense to use standardized APIs even if it means
    sacrificing a little bit of the convenience some specific implementation may offer.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the package (DTOs, mappers, and the ValidSku annotation) are framework-independent,
    so the code is the same as for Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: To handle exceptions by mapping them to the correct HTTP responses, MicroProfile
    supports the ExceptionMapper interface, described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Exception mappers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our example API, we want to define mappings for two exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityNotFoundException` , meaning a product with the given ID is not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationException` , meaning some input does not comply with the bean validation
    annotations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both mapper classes are alike, so it will suffice if we show the first of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It can be seen that the `ProblemDetail` DTO is defined in our code as it is
    not provided by Jakarta REST.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will briefly mention the remaining parts of our
    application and test the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Completing and testing the Quarkus application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes in the `domain` and `usecase` packages, decoupled from the communication
    layers using Clean Architecture, need not change when we switch from Spring Boot
    to Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: To create a working Quarkus application, we need to implement persistence. We
    use Jakarta Persistence to map the database tables to entity classes. However,
    to be able to access the database using the Repository pattern (as we did with
    Spring Data), we have to use Panache, which is a module specific to Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern for persistence is not standardized within MicroProfile;
    however, there isthe new Jakarta Data specification in Jakarta EE 11.
  prefs: []
  type: TYPE_NORMAL
- en: To link the components of our application together, we use dependency injection
    with Jakarta Contexts and Dependency Injection (CDI) features ( `@ApplicationScoped`
    and `@Inject` annotations) that are supported by MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: As persistence and dependency injection are concepts that are not specific to
    RESTful web service implementation, we are not going to explain in more detail
    how to use them with Quarkus, MicroProfile, or Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have the application code complete, we can start the application using
    the convenient Quarkus dev mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can try the API endpoints using the `curl` commands, creating the product
    with the `PUT` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We list all products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we will get the documentation of the API we have just created
    in the OpenAPI standard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the API specification from the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how the implementation-independent specification of an API can be generated
    for a Spring Boot application in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  prefs: []
  type: TYPE_NORMAL
- en: A similar code-first approach is available for MicroProfile applications, thanks
    to the MicroProfile OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add just one dependency in the `pom.xml` file of our Quarkus application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we can enter the Swagger UI by opening the [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    URL in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Swagger UI generated from a Quarkus application](img/B21843_11_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Swagger UI generated from a Quarkus application
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI specification (in YAML format) can be downloaded using the [http://localhost:8080/q/openapi](http://localhost:8080/q/openapi)
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: We have shown how to create and document the Product API with Quarkus using
    the code-first approach. In the next chapter, you will see that, even with Quarkus,
    we can create APIs specification-first, using Java code generation from OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Generating MicroProfile code from OpenAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a stub (not the full implementation) of the Order Management
    API that was implemented with Spring Boot in [*Chapter 4*](B21843_04.xhtml#_idTextAnchor096)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the same `Order_Management_API.yml` specification file as in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pom.xml` file contains the same Quarkus dependencies as in the *Exposing
    the Product API* section. Additionally, we add the plugin configurations to generate
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Some configuration parameters are the same as with Spring: package names, model
    name suffix. The generator name is different; we are using the one compliant with
    the JAX-RS specification. We use the `useJakartaEe` flag because the current version
    of the specification requires `jakarta` instead of `javax` as the package prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `interfaceOnly` flag because we want our manually written classes
    to implement generated interfaces. This way, if our implementation does not match
    the generated interface, it will be reported by the compiler automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the Maven `compile` goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see the generated sources in the `target/generated-sources/openapi` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run the Quarkus application now, and open the Swagger UI at [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    , we will see that no REST endpoints (operations) are exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Swagger UI showing no operations](img/B21843_11_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Swagger UI showing no operations
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to provide an implementation of the generated interface. Before doing
    so, we need to add one more plugin to make the generated sources accessible from
    our manually written code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to demonstrate the concept, we will create a stub implementation of the
    generated interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Opening the Swagger UI again shows that the operations are now available.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B21843_11_3.png) Figure 11.3 – Swagger UI of the Order Management
    API'
  prefs: []
  type: TYPE_NORMAL
- en: We can test it, for example, by sending the POST request with the body. The
    response will be empty (because our implementation is not complete) but successful
    (HTTP 2xx status code).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the last section of the chapter, we will see that similar code to what we
    used with Quarkus can work with another framework, Helidon.
  prefs: []
  type: TYPE_NORMAL
- en: Example implementation with Helidon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have used the MicroProfile annotations only, exactly the same `ProductResource`
    class code that was used with Quarkus works with Helidon, too.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the Panache repository-based data persistence implementation used
    with Quarkus, we use the `EntityManager` interface of the **Jakarta Persistence
    (JPA)** specification directly.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, compared to the Quarkus implementation, we had to put different dependencies
    in the `pom.xml` file, and we used different configuration files, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is built with this Maven command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can start the application JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the API of the running application will behave the same way as the
    other implementations, so it can be tested with the same `curl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the MicroProfile OpenAPI compliance and Helidon OpenAPI UI module,
    when these dependencies are in our `pom.xml` file, we can see the documentation
    of the REST API in a web browser at [http://localhost:8080/openapi/ui](http://localhost:8080/openapi/ui)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – OpenAPI UI generated by Helidon](img/B21843_11_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – OpenAPI UI generated by Helidon
  prefs: []
  type: TYPE_NORMAL
- en: We can see that, using the MicroProfile standard features, we get the same results
    when switching the frameworks from Quarkus to Helidon.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we summarized from a high-level perspective, the different
    frameworks that can be used to implement Java services exposing REST APIs. Using
    a historical overview, we explained the different goals and features that motivated
    the creation of these frameworks. We explained how vendor-neutral standards help
    prevent developer community fragmentation and lock-in to a particular implementation
    technology. By implementing parts of our example APIs in two MicroProfile-compliant
    frameworks (Quarkus and Helidon), we demonstrated that the various REST API design
    principles we went through in the previous chapters can be applied regardless
    of the framework used and lead to application code with the same basic structure.
  prefs: []
  type: TYPE_NORMAL
