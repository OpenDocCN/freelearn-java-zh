<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the process of erecting a new building, a set of blueprints helps all related parties communicate--the architect, electricians, carpenters, plumbers, and so on. It details things such as shapes, sizes, and materials. Without them, each of the subcontractors would be left guessing as to what to do, where to do it, and how. Without these blueprints, modern architecture would be almost impossible.</p>
<p class="mce-root">What is in your hands--or on the screen in front of you--is a set of blueprints of a different sort. Rather than detailing exactly how to build your specific software system, as each project and environment has unique constraints and requirements, these blueprints offer examples of how to build a variety of Java-based systems, providing examples of how to use specific features in the <strong class="calibre8">Java Development Kit</strong>, or <strong class="calibre8">JDK</strong>, with a special focus on the new features of Java 9 that you can then apply to your specific problem.</p>
<p class="mce-root">Since it would be impossible to build an application using only the new Java 9 features, we will also be using and highlighting many of the newest features in the JDK. Before we get too far into what that entails, then, let's take a brief moment to discuss some of these great new features from recent major JDK releases. Hopefully, most Java shops are already on Java 7, so we'll focus on version 8 and, of course, version 9.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">New features in Java 8</li>
<li class="calibre14">New features in Java 9</li>
<li class="calibre14">Projects</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New features in Java 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java 8, released on March 8, 2014, brought arguably two of the most significant features since Java 5, released in 2004--lambdas and streams. With functional programming gaining popularity in the JVM world, especially with the help of languages such as Scala, Java adherents had been clamoring for more functional-style language features for several years. Originally slated for release in Java 7, the feature was dropped from that release, finally seeing a stable release with Java 8.</p>
<p class="mce-root">While it can be hoped that everyone is familiar with Java's lambda support, experience has shown that many shops, for a variety of reasons, are slow to adopt new language versions and features, so a quick introduction might be helpful.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Lambdas</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The term lambda, which has its roots in lambda calculus, developed by Alonzo Church in 1936, simply refers to an anonymous function. Typically, a function (or method, in more proper Java parlance), is a statically-named artifact in the Java source:</p>
<pre class="calibre21">    public int add(int x, int y) { 
      return x + y; 
    } </pre>
<p class="mce-root">This simple method is one named <kbd class="calibre16">add</kbd> that takes two <kbd class="calibre16">int</kbd> parameters as well as returning an <kbd class="calibre16">int</kbd> parameter. With the introduction of lambdas, this can now be written as follows:</p>
<pre class="calibre21">    (int x, int y) → x + y </pre>
<p class="mce-root">Or, more simply as this:</p>
<pre class="calibre21">    (x, y) → x + y </pre>
<p class="mce-root">This abbreviated syntax indicates that we have a function that takes two parameters and returns their sum. Depending on where this lambda is used, the types of the parameters can be inferred by the compiler, making the second, even more concise format possible. Most importantly, though, note that this method is no longer named. Unless it is assigned to a variable or passed as a parameter (more on this later), it can not be referenced--or used--anywhere in the system.</p>
<p class="mce-root">This example, of course, is absurdly simple. A better example of this might be in one of the many APIs where the method's parameter is an implementation of what is known as a <strong class="calibre8">Single Abstract Method</strong> (<strong class="calibre8">SAM</strong>) interface, which is, at least until Java 8, an interface with a single method. One of the canonical examples of a SAM is <kbd class="calibre16">Runnable</kbd>. Here is an example of the pre-lambda <kbd class="calibre16">Runnable</kbd> usage:</p>
<pre class="calibre21">    Runnable r = new Runnable() { 
      public void run() { 
        System.out.println("Do some work"); 
      } 
    }; 
    Thread t = new Thread(r); 
    t.start(); </pre>
<p class="mce-root">With Java 8 lambdas, this code can be vastly simplified to this:</p>
<pre class="calibre21">    Thread t = new Thread(() -&gt;<br class="calibre2"/>      System.out.println("Do some work")); 
    t.start(); </pre>
<p class="mce-root">The body of the <kbd class="calibre16">Runnable</kbd> method is still pretty trivial, but the gains in clarity and conciseness should be pretty obvious.</p>
<p class="mce-root">While lambdas are anonymous functions (that is, they have no names), Java lambdas, as is the case in many other languages, can also be assigned to variables and passed as parameters (indeed, the functionality would be almost worthless without this capability). Revisiting the <kbd class="calibre16">Runnable</kbd> method in the preceding code, we can separate the declaration and the use of <kbd class="calibre16">Runnable</kbd> as follows:</p>
<pre class="calibre21">    Runnable r = () { 
      // Acquire database connection 
      // Do something really expensive 
    }; 
    Thread t = new Thread(r); 
    t.start(); </pre>
<p class="mce-root">This is intentionally more verbose than the preceding example. The stubbed out body of the <kbd class="calibre16">Runnable</kbd> method is intended to mimic, after a fashion, how a real-world <kbd class="calibre16">Runnable</kbd> may look and why one may want to assign the newly-defined <kbd class="calibre16">Runnable</kbd> method to a variable in spite of the conciseness that lambdas offer. This new lambda syntax allows us to declare the body of the <kbd class="calibre16">Runnable</kbd> method without having to worry about method names, signatures, and so on. It is true that any decent IDE would help with this kind of boilerplate, but this new syntax gives you, and the countless developers who will maintain your code, much less noise to have to parse when debugging the code.</p>
<p class="mce-root">Any SAM interface can be written as a lambda. Do you have a comparator that you really only need to use once?</p>
<pre class="calibre21">    List&lt;Student&gt; students = getStudents(); 
    students.sort((one, two) -&gt; one.getGrade() - two.getGrade()); </pre>
<p class="mce-root">How about <kbd class="calibre16">ActionListener</kbd>?</p>
<pre class="calibre21">    saveButton.setOnAction((event) -&gt; saveAndClose()); </pre>
<p class="mce-root">Additionally, you can use your own SAM interfaces in lambdas as follows:</p>
<pre class="calibre21">    public &lt;T&gt; interface Validator&lt;T&gt; { 
      boolean isValid(T value); 
    } 
    cardProcessor.setValidator((card) 
    card.getNumber().startsWith("1234")); </pre>
<p class="mce-root">One of the advantages of this approach is that it not only makes the consuming code more concise, but it also reduces the level of effort, such as it is, in creating some of these concrete SAM instances. That is to say, rather than having to decide between an anonymous class and a concrete, named class, the developer can declare it inline, cleanly and concisely.</p>
<p class="mce-root">In addition to the SAMs Java developers have been using for years, Java 8 introduced a number of functional interfaces to help facilitate more functional style programming. The Java 8 Javadoc lists 43 different interfaces. Of these, there are a handful of basic function <strong class="calibre8">shapes</strong> that you should know of, some of which are as follows:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">BiConsumer&lt;T,U&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents an operation that accepts two input arguments and returns no result</p>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">BiFunction&lt;T,U,R&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents a function that accepts two arguments and produces a result</p>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">BinaryOperator&lt;T&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents an operation upon two operands of the same type, producing a result of the same type as the operands</p>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">BiPredicate&lt;T,U&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents a predicate (Boolean-valued function) of two arguments</p>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">Consumer&lt;T&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents an operation that accepts a single input argument and returns no result</p>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">Function&lt;T,R&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents a function that accepts one argument and produces a result</p>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">Predicate&lt;T&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents a predicate (Boolean-valued function) of one argument</p>
</td>
</tr>
<tr class="calibre35">
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">Supplier&lt;T&gt;</kbd></p>
</td>
<td class="calibre33">
<p class="mce-root3">This represents a supplier of results</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">There are a myriad of uses for these interfaces, but perhaps the best way to demonstrate some of them is to turn our attention to the next big feature in Java 8--Streams.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Streams</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The other major addition to Java 8, and, perhaps where lambdas shine the brightest, is the new <strong class="calibre8">Streams API</strong>. If you were to search for a definition of Java streams, you would get answers that range from the somewhat circular <strong class="calibre8">a stream of data elements</strong> to the more technical <strong class="calibre8">Java streams are monads</strong>, and they're probably both right. The Streams API allows the Java developer to interact with a stream of data elements via a <strong class="calibre8">sequence of steps</strong>. Even putting it that way isn't as clear as it could be, so let's see what it means by looking at some sample code.</p>
<p class="mce-root">Let's say you have a list of grades for a particular class. You would like to know what the average grade is for the girls in the class. Prior to Java 8, you might have written something like this:</p>
<pre class="calibre21">    double sum = 0.0; 
    int count = 0; 
    for (Map.Entry&lt;Student, Integer&gt; g : grades.entrySet()) { 
      if ("F".equals(g.getKey().getGender())) { 
        count++; 
        sum += g.getValue(); 
      } 
    } 
    double avg = sum / count; </pre>
<p class="mce-root">We initialize two variables, one to store the sums and one to count the number of hits. Next, we loop through the grades. If the student's gender is female, we increment our counter and update the sum. When the loop terminates, we then have the information we need to calculate the average. This works, but it's a bit verbose. The new Streams API can help with that:</p>
<pre class="calibre21">    double avg = grades.entrySet().stream() 
     .filter(e -&gt; "F".equals(e.getKey().getGender())) // 1 
     .mapToInt(e -&gt; e.getValue()) // 2 
     .average() // 3 
     .getAsDouble(); //4 </pre>
<p class="mce-root">This new version is not significantly smaller, but the purpose of the code is much clearer. In the preceding pre-stream code, we have to play computer, parsing the code and teasing out its intended purpose. With streams, we have a clear, declarative means to express application logic. For each entry in the map do the following:</p>
<ol class="calibre18">
<li class="chapter">Filter out each entry whose <kbd class="calibre16">gender</kbd> is not <kbd class="calibre16">F</kbd>.</li>
<li class="chapter">Map each value to the primitive int.</li>
<li class="chapter">Average the grades.</li>
<li class="chapter">Return the value as a double.</li>
</ol>
<p class="mce-root">With the stream-based and lamba-based approach, we don't need to declare temporary, intermediate variables (grade count and total), and we don't need to worry about calculating the admittedly simple average. The JDK does all of the heavy-lifting for us.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The new java.time package</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While lambdas and streams are extremely important game-changing updates, with Java 8, we were given another long-awaited change that was, at least in some circles, just as exciting: a new date/time API. Anyone who has worked with dates and times in Java knows the pain of <kbd class="calibre16">java.util.Calendar</kbd> and company. Clearly, you can get your work done, but it's not always pretty. Many developers found the API too painful to use, so they integrated the extremely popular Joda Time library into their projects. The Java architects agreed, and engaged Joda Time's author, Stephen Colebourne, to lead JSR 310, which brought a version of Joda Time (fixing various design flaws) to the platform. We'll take a detailed look at how to use some of these new APIs in our date/time calculator later in the book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Default methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before turning our attention to Java 9, let's take a look at one more significant language feature: default methods. Since the beginning of Java, an interface was used to define how a class looks, implying a certain type of behavior, but was unable to implement that behavior. This made polymorphism much simpler in a lot of cases, as any number of classes could implement a given interface, and the consuming code treats them as that interface, rather than whatever concrete class they actually are.</p>
<p class="mce-root">One of the problems that have confronted API developers over the years, though, was how to evolve an API and its interfaces without breaking existing code. For example, take the <kbd class="calibre16">ActionSource</kbd> interface from the JavaServer Faces 1.1 specification. When the JSF 1.2 expert group was working on the next revision of the specification, they identified the need to add a new property to the interface, which would result in two new methods--the getters and setters. They could not simply add the methods to the interface, as that would break every implementation of the specification, requiring the maintainers of the implementation to update their classes. Obviously, this sort of breakage is unacceptable, so JSF 1.2 introduced <kbd class="calibre16">ActionSource2</kbd>, which extends <kbd class="calibre16">ActionSource</kbd> and adds the new methods. While this approach is considered ugly by many, the 1.2 expert group had a few choices, and none of them were very good.</p>
<p class="mce-root">With Java 8, though, interfaces can now specify a default method on the interface definition, which the compiler will use for the method implementation if the extending class does not provide one. Let's take the following piece of code as an example:</p>
<pre class="calibre21">    public interface Speaker { 
      void saySomething(String message); 
    } 
    public class SpeakerImpl implements Speaker { 
      public void saySomething(String message) { 
        System.out.println(message); 
      } 
    } </pre>
<p class="mce-root">We've developed our API and made it available to the public, and it's proved to be really popular. Over time, though, we've identified an improvement we'd like to make: we'd like to add some convenience methods, such as <kbd class="calibre16">sayHello()</kbd> and <kbd class="calibre16">sayGoodbye()</kbd>, to save our users a little time. However, as discussed earlier, if we just add these new methods to the interface, we'll break our users' code as soon as they update to the new version of the library. Default methods allow us to extend the interface and avoid the breakage by defining an implementation:</p>
<pre class="calibre21">    public interface Speaker { 
      void saySomething(String message); 
      default public void sayHello() { 
        System.out.println("Hello"); 
      } 
      default public void sayGoodbye() { 
        System.out.println("Good bye"); 
      } 
    } </pre>
<p class="mce-root">Now, when users update their library JARs, they immediately gain these new methods and their behavior, without making any changes. Of course, to use these methods, the users will need to modify their code, but they need not do so until--and if--they want to.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">New features in Java 9</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As with any new version of the JDK, this release was packed with a lot of great new features. Of course, what is most appealing will vary based on your needs, but we'll focus specifically on a handful of these new features that are most relevant to the projects we'll build together. First up is the most significant, the Java Module System.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java Platform Module System/Project Jigsaw</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Despite being a solid, feature-packed release, Java 8 was considered by a fair number to be a bit disappointing. It lacked the much anticipated <strong class="calibre8">Java Platform Module System</strong> (<strong class="calibre8">JPMS</strong>), also known more colloquially, though not quite accurately, as Project Jigsaw. The Java Platform Module System was originally slated to ship with Java 7 in 2011, but it was deferred to Java 8 due to some lingering technical concerns. Project Jigsaw was started not only to finish the module system, but also to modularize the JDK itself, which would help Java SE scale down to smaller devices, such as mobile phones and embedded systems. Jigsaw was scheduled to ship with Java 8, which was released in 2014, but it was deferred yet again, as the Java architects felt they still needed more time to implement the system correctly. At long last, though, Java 9 will finally deliver this long-promised project.</p>
<p class="mce-root">That said, what exactly is it? One problem that has long haunted API developers, including the JDK architects, is the inability to hide implementation details of public APIs. A good example from the JDK of private classes that developers should not be using directly is the <kbd class="calibre16">com.sun.*/sun.*</kbd> packages and classes. A perfect example of this--of private APIs finding widespread public use--is the <kbd class="calibre16">sun.misc.Unsafe</kbd> class. Other than a strongly worded warning in Javadoc about not using these internal classes, there's little that could be done to prevent their use. Until now.</p>
<p class="mce-root">With the JPMS, developers will be able to make implementation classes public so that they may be easily used inside their projects, but not expose them outside the module, meaning they are not exposed to consumers of the API or library. To do this, the Java architects have introduced a new file, <kbd class="calibre16">module-info.java</kbd>, similar to the existing <kbd class="calibre16">package-info.java</kbd> file, found at the root of the module, for example, at <kbd class="calibre16">src/main/java/module-info.java</kbd>. It is compiled to <kbd class="calibre16">module-info.class</kbd>, and is available at runtime via reflection and the new <kbd class="calibre16">java.lang.Module</kbd> class.</p>
<p class="mce-root">So what does this file do, and what does it look like? Java developers can use this file to name the module, list its dependencies, and express to the system, both compile and runtime, which packages are exported to the world. For example, suppose, in our preceding stream example, we have three packages: <kbd class="calibre16">model</kbd>, <kbd class="calibre16">api</kbd>, and <kbd class="calibre16">impl</kbd>. We want to expose the models and the API classes, but not any of the implementation classes. Our <kbd class="calibre16">module-info.java</kbd> file may look something like this:</p>
<pre class="calibre21">    module com.packt.j9blueprints.intro { 
      requires com.foo; 
      exports com.packt.j9blueprints.intro.model; 
      exports com.packt.j9blueprints.intro.api; 
    } </pre>
<p class="mce-root">This definition exposes the two packages we want to export, and also declares a dependency on the <kbd class="calibre16">com.foo</kbd> module. If this module is not available at compile-time, the project will not build, and if it is not available at runtime, the system will throw an exception and exit. Note that the <kbd class="calibre16">requires</kbd> statement does not specify a version. This is intentional, as it was decided not to tackle the version-selection issue as part of the module system, leaving that to more appropriate systems, such as build tools and containers.</p>
<p class="mce-root">Much more could be said about the module system, of course, but an exhaustive discussion of all of its features and limitations is beyond the scope of this book. We will be implementing our applications as modules, though, so we'll see the system used--and perhaps explained in a bit more detail--throughout the book.</p>
<div class="packt_tip">Those wanting a more in-depth discussion of the Java Platform Module System can search for the article, <em class="calibre22">The State of the Module System</em>, by Mark Reinhold.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Process handling API</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In prior versions of Java, developers interacting with native operating system processes had to use a fairly limited API, with some operations requiring resorting to native code. As part of <strong class="calibre8">Java Enhancement Proposal</strong> (<strong class="calibre8">JEP</strong>) 102, the Java process API was extended with the following features (quoting from the JEP text):</p>
<ul class="calibre13">
<li class="calibre14">The ability to get the pid (or equivalent) of the current Java virtual machine and the pid of processes created with the existing API.</li>
<li class="calibre14">The ability to enumerate processes on the system. Information on each process may include its pid, name, state, and perhaps resource usage.</li>
<li class="calibre14">The ability to deal with process trees; in particular, some means to destroy a process tree.</li>
<li class="calibre14">The ability to deal with hundreds of subprocesses, perhaps multiplexing the output or error streams to avoid creating a thread per subprocess.</li>
</ul>
<p class="mce-root">We will explore these API changes in our first project, the Process Viewer/Manager (see the following sections for details).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrency changes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As was done in Java 7, the Java architects revisited the concurrency libraries, making some much needed changes, this time in order to support the reactive-streams specification. These changes include a new class, <kbd class="calibre16">java.util.concurrent.Flow</kbd>, with several nested interfaces: <kbd class="calibre16">Flow.Processor</kbd>, <kbd class="calibre16">Flow.Publisher</kbd>, <kbd class="calibre16">Flow.Subscriber</kbd>, and <kbd class="calibre16">Flow.Subscription</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">REPL</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One change that seems to excite a lot of people isn't a language change at all. It's the addition of a <strong class="calibre8">REPL</strong> (<strong class="calibre8">Read-Eval-Print-Loop</strong>), a fancy term for a language shell. In fact, the command for this new tool is <kbd class="calibre16">jshell</kbd>. This tool allows us to type or paste in Java code and get immediate feedback. For example, if we wanted to experiment with the Streams API discussed in the preceding section, we could do something like this:</p>
<pre class="calibre21"><strong class="calibre3">$ jshell 
|  Welcome to JShell -- Version 9-ea 
|  For an introduction type: /help intro 
 
jshell&gt; List&lt;String&gt; names = Arrays.asList(new String[]{"Tom", "Bill", "Xavier", "Sarah", "Adam"}); 
names ==&gt; [Tom, Bill, Xavier, Sarah, Adam] 
 
jshell&gt; names.stream().sorted().forEach(System.out::println); 
Adam 
Bill 
Sarah 
Tom 
Xavier </strong></pre>
<p class="mce-root">This is a very welcome addition that should help Java developers rapidly prototype and test their ideas.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Projects</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that brief and high-level overview of what new features are available to use, what do these blueprints we'll cover look like? We'll build ten different applications, varying in complexity and kind, and covering a wide range of concerns. With each project, we'll pay special attention to the new features we're highlighting, but we'll also see some older, tried and true language features and libraries used extensively, with any interesting or novel usages flagged. Here, then, is our project lineup.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Process Viewer/Manager</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We will explore some of the improvements to the process handling APIs as we implement a Java version of the age old Unix tool--<strong class="calibre8">top</strong>. Combining this API with JavaFX, we'll build a graphical tool that allows the user to view and manage processes running on the system.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Java 9 Process API enhancements</li>
<li class="calibre14">JavaFX</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Duplicate File Finder</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As a system ages, the chances of clutter in the filesystem, especially duplicated files, increases exponentially, it seems. Leveraging some of the new File I/O libraries, we'll build a tool to scan a set of user-specified directories to identify duplicates. Pulling JavaFX back out of the toolbox, we'll add a graphical user interface that will provide a more user-friendly means to interactively process the duplicates.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Java File I/O</li>
<li class="calibre14">Hashing libraries</li>
<li class="calibre14">JavaFX</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Date Calculator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With the release of Java 8, Oracle integrated a new library based on a redesign of Joda Time, more or less, into the JDK. Officially known as JSR 310, this new library fixed a longstanding complaint with the JDK--the official date libraries were inadequate and hard to use. In this project, we'll build a simple command-line date calculator that will take a date and, for example, add an arbitrary amount of time to it. Consider the following piece of code for example:</p>
<pre class="calibre21"><strong class="calibre3">$ datecalc "2016-07-04 + 2 weeks" 
2016-07-18 
$ datecalc "2016-07-04 + 35 days" 
2016-08-08 
$ datecalc "12:00CST to PST" 
10:00PST</strong> </pre>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Java 8 Date/Time APIs</li>
<li class="calibre14">Regular expressions</li>
<li class="calibre14">Java command-line libraries</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Social Media Aggregator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the problems with having accounts on so many social media networks is keeping tabs on what's happening on each of them. With accounts on Twitter, Facebook, Google+, Instagram, and so on, active users can spend a significant amount of time jumping from site to site, or app to app, reading the latest updates. In this chapter, we'll build a simple aggregator app that will pull the latest updates from each of the user's social media accounts and display them in one place. The features will include the following:</p>
<ul class="calibre13">
<li class="calibre14">Multiple accounts for a variety of social media networks:
<ul class="calibre13">
<li class="calibre14">Twitter</li>
<li class="calibre14">Pinterest</li>
<li class="calibre14">Instagram</li>
</ul>
</li>
<li class="calibre14">Read-only, rich listings of social media posts</li>
<li class="calibre14">Links to the appropriate site or app for a quick and easy follow-up</li>
<li class="calibre14">Desktop and mobile versions</li>
</ul>
<p class="mce-root"><span class="calibre7">This project will cover the following:</span></p>
<ul class="calibre13">
<li class="calibre14">REST/HTTP clients</li>
<li class="calibre14">JSON processing</li>
<li class="calibre14">JavaFX and Android development</li>
</ul>
<p class="mce-root">Given the size and scope of this effort, we'll actually do this in two chapters: JavaFX in the first, and Android in the second.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Email filter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Managing email can be tricky, especially if you have more than one account. If you access your mail from more than one location (that is, from more than one desktop or mobile app), managing your email rules can be trickier still. If your mail system doesn't support rules stored on the server, you're left deciding where to put the rules so that they'll run most often. With this project, we'll develop an application that will allow us to author a variety of rules and then run them via an optional background process to keep your mail properly curated at all times.</p>
<p class="mce-root">A sample <kbd class="calibre16">rules</kbd> file may look something like this:</p>
<pre class="calibre21">    [ 
      { 
        "serverName": "mail.server.com", 
        "serverPort": "993", 
        "useSsl": true, 
        "userName": "me@example.com", 
        "password": "password", 
        "rules": [ 
           {"type": "move", 
               "sourceFolder": "Inbox", 
               "destFolder": "Folder1", 
               "matchingText": "someone@example.com"}, 
            {"type": "delete", 
               "sourceFolder": "Ads", 
               "olderThan": 180} 
         ] 
      } 
    ] </pre>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">JavaMail</li>
<li class="calibre14">JavaFX</li>
<li class="calibre14">JSON Processing</li>
<li class="calibre14">Operating System integration</li>
<li class="calibre14">File I/O</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JavaFX photo management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java Development Kit has a very robust assortment of image handling APIs. In Java 9, these were augmented with improved support for the TIFF specification. In this chapter, we'll exercise this API in creating an image/photo management application. We'll add support for importing images from user-specified locations into the configured official directory. We'll also revisit the duplicate file finder and reuse some of the code developed as a part of the project to help us identify duplicate images.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">The new <kbd class="calibre16">javax.imageio</kbd> package</li>
<li class="calibre14">JavaFX</li>
<li class="calibre14">NetBeans Rich Client Platform</li>
<li class="calibre14">Java file I/O</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A client/server note application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Have you ever used a cloud-based note-taking application? Have you wondered what it would take to make your own? In this chapter, we'll create such an application, with complete front and backends. On the server side, we'll store our data in the ever popular document database, MongoDB, and we'll expose the appropriate parts of the business logic for the application via REST interfaces. On the client side, we'll develop a very basic user interface in JavaScript that will let us experiment with, and demonstrate how to use, JavaScript in our Java project.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Document databases (MongoDB)</li>
<li class="calibre14">JAX-RS and RESTful interfaces</li>
<li class="calibre14">JavaFX</li>
<li class="calibre14">JavaScript and Vue 2</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Serverless Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Serverless, also known as <strong class="calibre8">function as a service</strong> (<strong class="calibre8">FaaS</strong>), is one of the hottest trends these days. It is an application/deployment model where a small function is deployed to a service that manages almost every aspect of the function--startup, shutdown, memory, and so on, freeing the developer from worrying about such details. In this chapter, we'll write a simple serverless Java application to see how it might be done, and how you might use this new technique for your own applications.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Creating an Amazon Web Services account</li>
<li class="calibre14">Configuring AWS Lambda, Simple Notification Service, Simple Email Service, and DynamoDB</li>
<li class="calibre14">Writing and deploying a Java function</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Android desktop synchronization client</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With this project, we'll change gears a little bit and focus specifically on a different part of the Java ecosystem: Android. To do this, we'll focus on a problem that still plagues some Android users--the synchronization of an Android device and a desktop (or laptop) system. While various cloud providers are pushing us to store more and more in the cloud and streaming that to devices, some people still prefer to store, for example, photos and music directly on the device for a variety of reasons, ranging from cost for cloud resources to unreliable wireless connectivity and privacy concerns.</p>
<p class="mce-root">In this chapter, we'll build a system that will allow users to synchronize music and photos between their devices and their desktop or laptop. We'll build an Android application that provides the user interface to configure and monitor synchronization from the mobile device side as well as the Android Service that will perform the synchronization in the background, if desired. We will also build the related components on the desktop--a graphical application to configure and monitor the process from the desktop as well as a background process to handle the synchronization from the desktop side.</p>
<p class="mce-root">This project will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Android</li>
<li class="calibre14">User interfaces</li>
<li class="calibre14">Services</li>
<li class="calibre14">JavaFX</li>
<li class="calibre14">REST</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We have taken a quick look at some of the new language features we will be using. We have also seen a quick overview of the projects we will be building. One final question remains: what tools will we be using to do our work?</p>
<p class="mce-root">The Java ecosystem suffers from an embarrassment of riches when it comes to development tools, so we have much to choose from. The most fundamental choice facing us is the build tool. For our work here, we will be using Maven. While there is a strong and vocal community that would advocate Gradle, Maven seems to be the most common build tool at the moment, and seems to have more robust, mature, and native support from the major IDEs. If you do not have Maven already installed, you can visit <a href="http://maven.apache.org/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://maven.apache.org</span></a> and download the distribution for your operating system, or use whatever package management system is supported by your OS.</p>
<p class="mce-root">For the IDE, all screenshots, directions, and so forth will be using NetBeans--the free and open source IDE from Oracle. There are, of course, proponents of both IntelliJ IDEA and Eclipse, and they're both fine choices, but NetBeans offers a complete and robust development out-of-the-box, and it's fast, stable, and free. To download NetBeans, visit <a href="http://netbeans.org/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://netbeans.org</span></a> and download the appropriate installer for your operating system. Since we are using Maven, which IDEA and Eclipse both support, you should be able to open the projects presented here in the IDE of your choice. Where steps are shown in the GUI, though, you will need to adjust for the IDE you've chosen.</p>
<p class="mce-root">At the time of writing, the latest version of NetBeans is 8.2, and the best approach for using it to do Java 9 development is to run the IDE on Java 8, and to add Java 9 as an SDK. There is a development version of NetBeans that runs on Java 9, but, as it is a development version, it can be unstable from time to time. A stable NetBeans 9 should ship at roughly the same time as Java 9 itself. In the meantime, we'll push forward with 8.2:</p>
<ol class="calibre18">
<li class="chapter">To add Java 9 support, we will need to add a new Java platform, and we will do that by clicking on <span class="calibre5">Tools</span> | <span class="calibre5">Platforms</span>.</li>
<li class="chapter">This will bring up the <span class="calibre5">Java Platform Manager</span> screen:</li>
</ol>
<div class="mce-root1"><img class="image-border6" src="Images/21f6aea0-1ca2-45e8-a850-b5dfe9657170.png"/></div>
<ol start="3" class="calibre18">
<li class="chapter">Click on <span class="calibre5">Add Platform...</span> on the lower left side of your screen.</li>
</ol>
<div class="mce-root1"><img class="image-border7" src="Images/748b63db-d5da-4ddf-b243-4891f4813c7d.png"/></div>
<ol start="4" class="calibre18">
<li class="chapter">We want to add a <span class="calibre5">Java Standard Edition</span> platform, so we will accept the default and click on <span class="calibre5">Next</span>.</li>
</ol>
<div class="mce-root1"><img class="image-border8" src="Images/5d061ee9-6f7f-4c7e-bde0-e6975f484de1.png"/></div>
<ol start="5" class="calibre18">
<li class="chapter">On the <span class="calibre5">Add Java Platform</span> screen, we will navigate to where we've installed Java 9, select the JDK directory, and click on <span class="calibre5">Next</span>.</li>
</ol>
<div class="mce-root1"><img class="image-border8" src="Images/dfd08672-b200-4018-884e-5e550186cf71.png"/></div>
<ol start="6" class="calibre18">
<li class="chapter">We need to give the new Java Platform a name (NetBeans defaults to a very reasonable JDK 9) so we will click on <span class="calibre5">Finish</span> and can now see our newly added Java 9 option.</li>
</ol>
<div class="mce-root1"><img class="image-border6" src="Images/5e7c2687-619f-45a3-b5ee-ac21f8dd4088.png"/></div>
<p class="mce-root">With the project SDK set, we're ready to take these new Java 9 features for a spin, which we'll start doing in <a href="bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 18</a>, <em class="calibre20">Managing Processes in Java</em>.</p>
<div class="packt_tip">If you do run NetBeans on Java 9, which should be possible by the time this book is published, you will already have Java 9 configured. You can, however, use the preceding steps to configure Java 8, should you need that version specifically.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we've taken a quick look at some of the great new features in Java 8, including lambdas, streams, the new date/time package, and default methods. From Java 9, we took a quick look at the Java Platform Module System and Project Jigsaw, the process handling APIs, the new concurrency changes, and the new Java REPL. For each, we've discussed the what and why, and looked at some examples of how these might affect the systems we write. We've also taken a look at the types of project we'll be building throughout the book and the tools we'll be using.</p>
<p class="mce-root">Before we move on, I'd like to restate an earlier point--every software project is different, so it is not possible to write this book in such a way that you can simply copy and paste large swathes of code into your project. Similarly, every developer writes code differently; the way I structure my code may be vastly different from yours. It is important, then, that you keep that in mind when reading this book and not get hung up on the details. The purpose here is not to show you the one right way to use these APIs, but to give you an example that you can look at to get a better sense of how they might be used. Learn what you can from each example, modify things as you see fit, and go build something amazing.</p>
<p class="mce-root">With all of that said, let's turn our attention to our first project, the Process Manager, and the new process handling APIs.</p>


            </article>

            
        </section>
    </div>



  </body></html>