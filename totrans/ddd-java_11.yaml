- en: '*Chapter 9*: Integrating with External Systems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：与外部系统集成'
- en: Wholeness is not achieved by cutting off a portion of one’s being, but by integration
    of the contraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性并非通过割裂自己的某一部分来实现，而是通过整合对立面来达到。
- en: – Carl Jung
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 卡尔·荣格
- en: So far, we have used DDD to implement a robust core for our application. However,
    most solutions (by extension-bounded contexts) usually have both upstream and
    downstream dependencies that usually change at a pace, which is different from
    these core components. To maintain both agility and reliability and enable loose
    coupling, it is important to integrate with a peripheral system in a manner that
    shields the core from everything else that surrounds it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用DDD为我们应用程序实现了一个健壮的核心。然而，大多数解决方案（通过扩展有限上下文）通常既有上游也有下游依赖，这些依赖通常以不同的速度变化，这与这些核心组件不同。为了保持敏捷性和可靠性，并实现松散耦合，重要的是以一种保护核心免受周围一切影响的方式来与外围系统集成。
- en: In this chapter, we will look at the LC application processing solution and
    examine the means by which we can integrate with other components in the ecosystem.
    You will learn how to recognize relationship patterns between components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨LC应用处理解决方案，并检查我们如何与其他生态系统中的组件进行集成的手段。你将学习如何识别组件之间的关系模式。
- en: 'This chapter covers the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要内容：
- en: Continuing our design journey
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: Bounded context relationships
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限上下文关系
- en: Implementation patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模式
- en: By the end of the chapter, we will round off by looking at common patterns when
    integrating with legacy applications. Let’s dive right in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将通过查看与遗留应用集成的常见模式来结束讨论。让我们直接进入正题！
- en: Continuing our design journey
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'From our domain analysis in earlier chapters, we have arrived at four bounded
    contexts for our application, as depicted here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前章节中的领域分析中，我们已经为我们的应用程序确定了四个有限上下文，如图所示：
- en: '![Figure 9.1 – Relationship between bounded contexts'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 有限上下文之间的关系'
- en: '](img/B16716_Figure_9.01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![继续我们的设计之旅](img/B16716_Figure_9.01.jpg)'
- en: Figure 9.1 – Relationship between bounded contexts
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 有限上下文之间的关系
- en: So far, our focus has been on the implementation of the internals of the **LC
    application** bounded context. While the LC application bounded context is independent
    of the other bounded contexts, it is not completely isolated from them. For example,
    when processing an LC application, we need to perform merchandise and applicant
    checks that require interactions with the **compliance** and **customer onboarding**
    bounded contexts respectively. This means that these bounded contexts have a relationship
    with each other. These relationships are driven by the nature of collaboration
    between the teams working on the respective bounded contexts. Let’s examine how
    these team dynamics influence integration mechanisms between bounded contexts
    in a way that continues to preserve their individual integrity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的关注点一直集中在实现**LC应用**有限上下文的内部。虽然LC应用有限上下文与其他有限上下文是独立的，但它并不是完全与它们隔离。例如，在处理LC应用时，我们需要执行商品和申请人检查，这需要与**合规性**和**客户入职**有限上下文进行交互。这意味着这些有限上下文之间存在关系。这些关系是由在各自有限上下文上工作的团队之间的协作性质所驱动的。让我们考察这些团队动态如何影响有限上下文之间的集成机制，同时继续保持它们的个体完整性。
- en: Bounded context relationships
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限上下文关系
- en: 'We need bounded contexts to be as independent as possible. However, this does
    not mean that bounded contexts are completely isolated from each other. Bounded
    contexts need to collaborate with others to provide business value. Whenever there
    is collaboration required between two bounded contexts, the nature of their relationship
    is not only influenced by their individual goals and priorities but also by the
    prevailing organizational realities. In a high-performing environment, it is fairly
    common to have a single team assume ownership of a bounded context. The relationships
    between the teams owning these bounded contexts play a significant role in influencing
    the integration patterns employed to arrive at a solution. At a high level, there
    are two categories of relationships:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要边界上下文尽可能独立。然而，这并不意味着边界上下文完全相互隔离。边界上下文需要与其他上下文协作以提供业务价值。每当需要两个边界上下文之间协作时，它们关系的性质不仅受它们各自的目标和优先级的影响，还受组织现实情况的影响。在一个高绩效的环境中，一个团队承担一个边界上下文的拥有权是相当常见的。拥有这些边界上下文的团队之间的关系在影响采用以到达解决方案的集成模式中起着重要作用。从高层次来看，有两种关系类型：
- en: Symmetric
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称
- en: Asymmetric
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称
- en: Let’s look at these relationship types in more detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些关系类型。
- en: Symmetric relationship patterns
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称关系模式
- en: 'Two teams, say team A and team B, can be said to have a symmetric relationship
    when they have an equal amount of influence in the decision-making process to
    arrive at a solution. Both teams are in a position to, and, indeed, do, contribute
    more or less equally toward the outcome. Here’s a diagrammatic representation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '当两个团队，比如团队A和团队B，在决定解决方案的过程中拥有相等的影响力时，可以说它们之间存在对称关系。两个团队都处于能够，并且实际上确实，以几乎相等的方式对结果做出贡献的位置。以下是一个图示表示： '
- en: '![Figure 9.2 – Both teams have an equal say in influencing the solution'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 两个团队在影响解决方案方面拥有平等的话语权'
- en: '](img/B16716_Figure_9.02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_9.02.jpg)'
- en: Figure 9.2 – Both teams have an equal say in influencing the solution
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 两个团队在影响解决方案方面拥有平等的话语权
- en: There are three variations of symmetric relationships, each of which we will
    outline in more detail in the following subsections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对称关系有三种变体，我们将在接下来的小节中更详细地概述。
- en: Partnership
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伙伴关系
- en: 'In a partnership, both teams integrate in an ad hoc manner. There are no fixed
    responsibilities assigned when needing complete integration work. Each team picks
    up work as and when needed without the need for any specific ceremony or fanfare.
    The nature of the integration is usually two-way, with both teams exchanging solution
    artifacts as and when needed. Such relationships require extremely high degrees
    of collaboration and understanding of the work done by both teams. Check the following
    figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在伙伴关系中，两个团队以临时方式集成。在需要完全集成工作时，没有分配固定的责任。每个团队根据需要随时接手工作，无需任何特定的仪式或喧哗。集成的性质通常是双向的，两个团队根据需要交换解决方案工件。这种关系需要极高程度的协作和对两个团队所做工作的理解。查看以下图示：
- en: '![Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership
    relationship'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 伙伴关系中的团队之间存在临时的相互依赖'
- en: '](img/B16716_Figure_9.03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_9.03.jpg)'
- en: Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership
    relationship
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 伙伴关系中的团队之间存在临时的相互依赖
- en: Example
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: Let’s take as an example a web frontend team working in close collaboration
    with an API team building the BFFs ([https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html](https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html))
    for the frontend. The BFF team creates experience APIs meant to be used exclusively
    by the frontend. To fulfill any functionality, the frontend team requires capabilities
    to be exposed by the APIs team. On the other hand, the APIs team is dependent
    on the frontend team to provide advice on what capabilities to build and the order
    in which to build them. Both teams freely make use of each other’s domain models
    (for example, the same set of request and response objects that define the API)
    to implement functionality. Such reuse happens mostly arbitrarily, and when API
    changes happen, both teams coordinate changes to keep things working.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个与构建前端BFFs（[https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html](https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html)）的前端团队合作紧密的Web前端团队为例。BFF团队创建的经验API旨在仅由前端使用。为了实现任何功能，前端团队需要API团队暴露的能力。另一方面，API团队依赖于前端团队提供有关要构建哪些能力和按何种顺序构建它们的建议。两个团队都可以自由地使用对方的领域模型（例如，定义API的相同请求和响应对象集合）来实现功能。这种重用主要发生得任意，当API发生变化时，两个团队协调更改以保持一切正常工作。
- en: When to use
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: Partnership between teams requires high levels of collaboration, trust, and
    understanding. Teams tend to use this partnership when team boundaries are informal.
    It also helps if these teams are co-located and/or have a significant working
    time overlap.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 团队之间的合作关系需要高度的协作、信任和理解。当团队界限不正式时，团队往往会使用这种合作关系。如果这些团队是集中办公并且/或者有显著的工作时间重叠，这也会有所帮助。
- en: Potential pitfalls
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: Partnership relationships between teams can lead to a situation where individual
    team responsibilities become very unclear, leading a solution toward the dreaded
    *big ball of mud*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 团队之间的合作关系可能导致个人团队责任变得非常不明确，导致解决方案走向令人恐惧的*大泥球*。
- en: Shared kernel
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享内核
- en: Unlike in a partnership, when using a shared kernel, teams have a clear understanding
    of the solution artifacts and models they choose to share between themselves.
    Both teams take equal responsibility for the upkeep of these shared artifacts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与合作关系不同，当使用共享内核时，团队对自己之间选择共享的解决方案工件和模型有清晰的理解。两个团队都承担着维护这些共享工件的责任。
- en: Example
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: 'The *LC application processing* and *customer onboarding* teams in our LC application
    may choose to use a common model to represent `CustomerCreditValidatedEvent`.
    Any enhancements or changes to the event schema can affect both teams. The responsibility
    to make any changes is owned by both teams. Intentionally, these teams do not
    share anything beyond these mutually agreed-upon models and artifacts. Here’s
    a representation of a shared kernel relationship between teams:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的LC应用中，*LC应用程序处理*和*客户入职*团队可能会选择使用一个共同模型来表示`CustomerCreditValidatedEvent`。对事件架构的任何增强或更改都可能影响两个团队。做出任何更改的责任由两个团队共同承担。有意地，这些团队除了这些共同同意的模型和工件之外，不共享任何其他内容。以下是团队之间共享内核关系的表示：
- en: '![Figure 9.4 – Teams have an explicit understanding of shared models'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 团队对共享模型有明确的理解](img/B16716_Figure_9.04.jpg)'
- en: '](img/B16716_Figure_9.04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_9.04.jpg]'
- en: Figure 9.4 – Teams have an explicit understanding of shared models
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 团队对共享模型有明确的理解
- en: When to use
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: The shared kernel form of collaboration works well if shared artifacts are required
    to be consumed in an identical fashion in both contexts. Furthermore, it is attractive
    for multiple teams to coordinate and continue sharing, as opposed to duplicating
    identical models in both contexts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在两个上下文中都需要以相同的方式消费共享工件，那么共享内核形式的协作效果很好。此外，对于多个团队来说，协调并继续共享，而不是在两个上下文中复制相同的模型，这很有吸引力。
- en: Potential pitfalls
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: Changes made to the shared kernel affect both bounded contexts. This means that
    any change made to the shared kernel needs to remain compatible for both teams.
    Needless to say, as the number of teams using the shared kernel increases, the
    cost of coordination goes up manifold.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对共享内核所做的更改会影响所有边界上下文。这意味着对共享内核所做的任何更改都需要与两个团队保持兼容。不用说，随着使用共享内核的团队数量的增加，协调的成本会成倍增加。
- en: Separate ways
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离的方式
- en: 'When two teams choose to not share any artifacts or models between them, they
    go their own separate ways:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个团队选择不共享任何工件或模型时，他们会各自为政：
- en: '![Figure 9.5 – Teams go separate ways and don’t share anything between them'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – 团队分道扬镳，彼此之间不共享任何内容'
- en: '](img/B16716_Figure_9.05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_9.05.jpg]'
- en: Figure 9.5 – Teams go separate ways and don’t share anything between them
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 团队分道扬镳，彼此之间不共享任何内容
- en: Example
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: The *LC application processing* and *customer onboarding* teams may start by
    sharing the same build/deployment scripts for their services. Over a period of
    time, deployment requirements may diverge to a point where the shared cost of
    maintaining these scripts becomes prohibitively expensive, causing these teams
    to fork their deployments to regain independence from the other team.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*LC应用程序处理*和*客户入职*团队可能最初会共享他们服务的相同构建/部署脚本。随着时间的推移，部署需求可能会分歧到共享维护这些脚本的代价变得过高，导致这些团队分叉他们的部署以恢复对其他团队的独立性。'
- en: When to use
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: In some cases, two teams may be unable to collaborate for a variety of reasons,
    ranging from a drift in individual team requirements to organizational politics.
    Whatever the case may be, these teams may decide that the cost of collaboration
    is too high, resulting in them going their own separate ways.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，由于各种原因，两个团队可能无法合作，这些原因可能从个人团队需求的变化到组织政治。无论情况如何，这些团队可能会决定合作的成本太高，从而导致他们各自为政。
- en: Potential pitfalls
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: Choosing to go separate ways may result in duplicate work across affected bounded
    contexts. When working in bounded contexts that map to core subdomains, this may
    prove counterproductive, as it can lead to inconsistent behaviors unintentionally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择分道扬镳可能会导致受影响的边界上下文中出现重复工作。当在映射到核心子域的边界上下文中工作时，这可能会证明是适得其反的，因为它可能导致无意中产生不一致的行为。
- en: It is possible to transition from one relationship type to another over a period
    of time. In our experience, transitioning from any one of these relationships
    may not be straightforward. In cases where requirements are relatively clear at
    the outset, it may be easier to start with a *shared kernel*. Conversely, if requirements
    are unclear, it may be prudent to start either with a loose *partnership* or go
    *separate ways* until requirements become clear. In any of these scenarios, it
    is important to keep evaluating the nature of the relationship and transition
    to a more appropriate type, based on our enhanced understanding of the requirements
    and/or the relationship itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间内，从一种关系类型过渡到另一种关系类型是可能的。根据我们的经验，从任何一种关系过渡可能并不简单。在需求一开始相对清晰的情况下，可能更容易从*共享内核*开始。相反，如果需求不明确，可能明智地开始以松散的*伙伴关系*或*分道扬镳*，直到需求变得明确。在任何这些场景中，重要的是要持续评估关系的性质，并根据我们对需求及其本身的更深入了解，过渡到更合适的关系类型。
- en: In each of the preceding characterized relationships, the teams involved have
    a more or less equal say in how the relationship evolved and the resulting outcomes.
    However, this may not always be the case. Let’s look at examples of cases where
    one team may have a clear upper hand in terms of how the relationship evolves.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面描述的每一种关系中，涉及的团队在关系演变和最终结果方面都有或多或少的发言权。然而，这并不总是如此。让我们看看一些案例，在这些案例中，一个团队可能在关系演变方面具有明显的优势。
- en: Asymmetric relationship patterns
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称关系模式
- en: 'Two teams can be said to have an asymmetric relationship when one of the teams
    has a stronger influence in the decision-making process to arrive at a solution.
    In other words, there is a clear customer-supplier (or upstream-downstream) relationship
    where either the customer or the supplier plays a dominant role that affects solution
    design approaches. It is also likely that the customer and the supplier do not
    share common goals. Here is a representation of an asymmetric relationship between
    customer and supplier:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个团队在决策过程中对解决方案有更强的影响力时，可以说两个团队之间存在非对称关系。换句话说，存在一个明确的客户-供应商（或上游-下游）关系，其中客户或供应商在影响解决方案设计方法方面扮演着主导角色。客户和供应商可能没有共同的目标。以下是客户和供应商之间非对称关系的表示：
- en: '![Figure 9.6 – One of the teams has a dominant say in influencing the solution'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 一个团队在影响解决方案方面具有主导权'
- en: '](img/B16716_Figure_9.06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_9.06.jpg]'
- en: Figure 9.6 – One of the teams has a dominant say in influencing the solution
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 其中一个团队在影响解决方案方面具有主导权
- en: There are at least three solution patterns when teams are in an asymmetric relationship,
    each of which we will outline in more detail in the following subsections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队处于非对称关系时，至少存在三种解决方案模式，我们将在以下小节中更详细地概述。
- en: Conformist (CF)
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**顺从者（CF**）'
- en: 'It is not unusual for the side playing the supplier role to have a dominant
    say in how the relationship with one or more customers is implemented. Furthermore,
    the customer may simply choose to conform to the supplier-provided solution as
    is, making it an integral part of their own solution. In other words, the supplier
    provides a set of models and the customer uses those same models to build their
    solution. In this case, the customer is considered to be a *conformist*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商角色的一方在如何实施与一个或多个客户的关系方面拥有主导权并不罕见。此外，客户可能简单地选择接受供应商提供的解决方案，将其作为他们自己解决方案的一个组成部分。换句话说，供应商提供一系列模型，客户使用这些相同的模型来构建他们的解决方案。在这种情况下，客户被认为是**顺从者**：
- en: '![Figure 9.7 – The customer accepts dependency on the supplier model'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 客户接受对供应商模型的依赖'
- en: '](img/B16716_Figure_9.07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 客户接受对供应商模型的依赖](img/B16716_Figure_9.07.jpg)'
- en: Figure 9.7 – The customer accepts dependency on the supplier model
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 客户接受对供应商模型的依赖
- en: Example
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: When building a solution to validate the United States postal addresses of LC
    applicants, we chose to conform to the USPS Web Tools address validation API schema
    ([https://www.usps.com/business/web-tools-apis/](https://www.usps.com/business/web-tools-apis/)).
    Given that the business started with just US-based applicants, this made sense.
    This means that any references to the address model in our bounded contexts mimic
    the schema prescribed by the USPS. Furthermore, it means that we will need to
    keep up with changes that occur in the USPS API as and when they occur (regardless
    of whether those changes are needed for our own functionality).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个解决方案以验证LC申请者的美国邮政地址时，我们选择遵循USPS Web Tools地址验证API模式（[https://www.usps.com/business/web-tools-apis/](https://www.usps.com/business/web-tools-apis/)）。鉴于业务最初仅限于美国申请者，这样做是有意义的。这意味着我们边界上下文中对地址模型的任何引用都模仿了USPS规定的模式。此外，这也意味着我们需要随时关注USPS
    API发生的任何变化（无论这些变化是否需要用于我们自己的功能）。
- en: When to use
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: Being a conformist is not necessarily a negative thing. The supplier’s models
    may be a well-accepted industry standard, or they may simply be good enough for
    our needs. It may also be that the team may not have the necessary skills, motivation,
    or immediate need to do something different from what the supplier has provided.
    This approach also enables teams to make quick progress, leveraging work mostly
    done by other experts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成为顺从者并不一定是件坏事。供应商的模型可能是被广泛接受的行业标准，或者它们可能只是满足我们需求的好方法。也可能是因为团队可能没有必要的技能、动机或立即的需求去做与供应商提供的内容不同的事情。这种方法还使团队能够快速取得进展，利用其他专家大部分已完成的工作。
- en: Potential pitfalls
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在陷阱
- en: An overuse of the conformist pattern may dilute the ubiquitous language of our
    own bounded contexts, resulting in a situation where there is no clear separation
    between the supplier and customer concepts. It may also be that concepts that
    are core to the supplier’s context leak into our own, despite those concepts carrying
    little to no meaning in our context. This may result in these bounded contexts
    being very tightly coupled with each other. And if a need arises to switch to
    another supplier or support multiple suppliers, the cost of change may be prohibitively
    expensive.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用顺从者模式可能会稀释我们自身边界上下文中的通用语言，导致供应商和客户概念之间没有明确的分离。也可能出现这样的情况，即对供应商上下文核心的概念泄漏到我们自己的上下文中，尽管这些概念在我们自己的上下文中几乎没有任何意义。这可能导致这些边界上下文之间非常紧密地耦合在一起。如果需要切换到另一个供应商或支持多个供应商，变更的成本可能会非常高昂。
- en: Anti-Corruption Layer
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反腐败层
- en: 'There may be scenarios where a customer may need to collaborate with a supplier
    but may want to shield themselves from the supplier’s ubiquitous language and
    models. In such cases, it may be prudent to redefine these conflicting models
    in the customer’s own ubiquitous language using a translation layer at the time
    of integration, also known as an **Anti-Corruption Layer** (**ACL**). See the
    following figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在客户需要与供应商合作但可能希望保护自己免受供应商通用语言和模型影响的场景。在这种情况下，在集成时重新定义这些冲突模型，使用翻译层，也称为**反腐败层（ACL**），可能是明智的。参见以下图示：
- en: '![Figure 9.8 – The customer wants to protect themselves from supplier models'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 客户希望保护自己免受供应商模型的影响'
- en: '](img/B16716_Figure_9.08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.08.jpg)'
- en: Figure 9.8 – The customer wants to protect themselves from supplier models
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 客户希望保护自己免受供应商模型的影响
- en: Example
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: 'In the address validation example referenced in the *Conformist (CF)* section,
    the *LC application processing* team may need to support Canadian applicants as
    well. In such a case, being a conformist to a system that supports only US addresses
    may prove restrictive and even confusing. For example, the US *state* is analogous
    to a *province* in Canada. Similarly, a *ZIP code* in the US is called a *postal
    code* in Canada. In addition, US ZIP codes are numeric whereas Canadian postal
    codes are alphanumeric. Most importantly, we currently do not have the notion
    of a *country code* in our address model, but now we will need to introduce this
    concept to differentiate addresses within the respective countries. Let’s look
    at the address models from the respective countries here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在*一致者（CF）*部分引用的地址验证示例中，*LC应用程序处理*团队可能还需要支持加拿大申请人。在这种情况下，成为一个仅支持美国地址的系统的一致者可能会显得限制性甚至令人困惑。例如，美国的*州*相当于加拿大的*省*。同样，美国的*ZIP代码*在加拿大被称为*邮政编码*。此外，美国的ZIP代码是数字的，而加拿大的邮政编码是字母数字的。最重要的是，我们目前在我们的地址模型中没有*国家代码*的概念，但现在我们需要引入这个概念来区分各自国家内的地址。以下是我们分别国家的地址模型：
- en: '![Figure 9.9 – The address models of different countries'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 – 不同国家的地址模型'
- en: '](img/B16716_Figure_9.09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.09.jpg)'
- en: Figure 9.9 – The address models of different countries
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 不同国家的地址模型
- en: While we initially conformed to the USPS model, we have now evolved to support
    more countries. For example, *region* is used to represent the concept of *state/province*.
    Also, we have introduced the *country* value object, which was missing earlier.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们最初遵循了USPS模型，但我们现在已经发展到支持更多国家。例如，*地区*用于表示*州/省*的概念。此外，我们引入了*国家*值对象，这是之前缺失的。
- en: When to use
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: ACLs come in handy when the customer models are part of a core domain. The ACL
    shields the customer from changes in the supplier’s models and can help produce
    more loosely coupled integrations. It may also be necessary when we are looking
    to integrate similar concepts from multiple suppliers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户模型是核心领域的一部分时，ACL非常有用。ACL可以保护客户免受供应商模型的变化，并有助于产生更松散耦合的集成。在试图从多个供应商整合类似概念时，这也可能是必要的。
- en: Potential pitfalls
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: Using an ACL may be tempting in a lot of cases. However, it is less beneficial
    when the concepts being integrated don’t often change or are defined by a well-known
    authority. Using an ACL with a custom language may only cause more confusion.
    Creating an ACL usually requires additional translations and thereby may increase
    the overall complexity of the customer’s bounded context and may be considered
    premature optimization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，使用ACL可能很有吸引力。然而，当被整合的概念不经常变化或由一个众所周知的权威机构定义时，使用ACL可能不太有益。使用带有自定义语言的ACL可能会造成更多的混淆。创建ACL通常需要额外的翻译，从而可能增加客户边界上下文的总体复杂性，并且可能被认为是过早的优化。
- en: Open host service
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放主机服务
- en: 'Unlike the conformist and the ACL, where customers do not have a formal means
    to interface with the supplier, with the **Open Host Service** (**OHS**), the
    supplier defines a clear interface to interact with its customers. This interface
    may be made available in the form of a well-known published language (for example,
    a REST interface or a client SDK):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与一致者和ACL不同，在这些情况下，客户没有正式的方式与供应商接口，而在**开放主机服务**（**OHS**）中，供应商定义了一个清晰的接口来与其客户交互。这个接口可能以众所周知的发布语言的形式提供（例如，REST接口或客户端SDK）：
- en: '![Figure 9.10 – An OHS using a Published Language (PL)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10 – 使用已发布语言（PL）的OHS'
- en: '](img/B16716_Figure_9.10.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.10.jpg)'
- en: Figure 9.10 – An OHS using a Published Language (PL)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 使用已发布语言（PL）的OHS
- en: Example
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: 'The LC application processing bounded context can expose an HTTP interface
    for each of its commands, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: LC应用程序处理边界上下文可以为每个命令公开一个HTTP接口，如下所示：
- en: '![](img/9-1.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9-1.jpg)'
- en: As an addition to the HTTP interface shown here, we can even provide a client
    SDK in some of the more popular languages used by our customers. This helps hide
    more implementation details such as the MIME type and version from customers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此处所示HTTP接口的补充，我们甚至可以为客户使用的某些更流行的语言提供客户端SDK。这有助于隐藏更多实现细节，例如MIME类型和版本，从而保护客户。
- en: When to use
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: When the supplier wants to hide its internal models (ubiquitous language), making
    an OHS enables the supplier to evolve while providing a stable interface to its
    customers. In a sense, the OHS pattern is a reversal of the ACL pattern – instead
    of the customer, the supplier implements the translation of its internal model.
    Also, the supplier can consider providing an OHS when it is interested in providing
    a richer user experience for its customers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当供应商想要隐藏其内部模型（通用语言）时，创建一个OHS使得供应商在提供稳定接口给客户的同时能够进行演变。从某种意义上说，OHS模式是ACL模式的反转——不是客户，而是供应商实现了其内部模型的翻译。此外，当供应商希望为其客户提供更丰富的用户体验时，它也可以考虑提供OHS。
- en: Potential pitfalls
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在陷阱
- en: While suppliers may have good intentions by providing an OHS for its customers,
    it may result in increased implementation complexity (for example, there may be
    a need to support multiple versions of an API, or client SDKs in multiple languages).
    If the OHS does not take into account the common usage patterns of its customers,
    it may result in poor customer usability and also in degraded performance for
    the supplier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然供应商通过为顾客提供OHS可能有良好的意图，但它可能会导致实现复杂性的增加（例如，可能需要支持API的多个版本，或者多种语言的客户端SDK）。如果OHS没有考虑到客户的常见使用模式，它可能会导致客户可用性差，同时也可能降低供应商的性能。
- en: 'It is important to note that the conformist and the ACL are patterns that customers
    implement, whereas the OHS is a supplier-side pattern. For example, the following
    scenario where the supplier provides an *OHS* to one customer who is a *conformist*
    and another who has an *ACL* can be true, as depicted here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，守成者和ACL是客户实施的模式，而OHS是供应商端的模式。例如，以下场景中供应商为一位是守成者的客户和另一位有ACL的客户提供*OHS*，如图所示：
- en: '![Figure 9.11 – Asymmetric relationships with multiple customers'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11 – 与多个客户的非对称关系'
- en: '](img/B16716_Figure_9.11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.11.jpg)'
- en: Figure 9.11 – Asymmetric relationships with multiple customers
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 与多个客户的非对称关系
- en: 'Now that we have seen the various ways in which bounded contexts can integrate
    with each other, here is one possible implementation for our LC application, depicted
    in the form of a context map:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了有界上下文如何相互集成的各种方式，以下是我们LC应用程序的一个可能的实现方案，以上下文图的形式展示：
- en: '![Figure 9.12 – A simplified context map for the LC application'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 – LC应用程序的简化上下文图'
- en: '](img/B16716_Figure_9.12.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.12.jpg)'
- en: Figure 9.12 – A simplified context map for the LC application
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – LC应用程序的简化上下文图
- en: So far, we have examined the various ways in which inter-team dynamics influence
    integration mechanisms. While having clarity at the conceptual level helps, let’s
    see how these relationships manifest themselves at the implementation level.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了团队动态影响集成机制的各种方式。虽然概念层面的清晰度有帮助，但让我们看看这些关系在实现层面是如何体现的。
- en: Implementation patterns
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模式
- en: 'We have looked at integration between bounded contexts at a design level, but
    these concepts need to be translated into code. There are three broad categories
    that can be employed when integrating two bounded contexts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计层面上探讨了有界上下文之间的集成，但需要将这些概念转化为代码。在集成两个有界上下文时，可以采用三个广泛的类别：
- en: Data-based
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数据
- en: Code-based
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于代码
- en: API-based
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于API
- en: Let’s look at each method in more detail now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每种方法。
- en: Data-based
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数据
- en: In this style of integration, the bounded contexts in question share data with
    each other. If the relationship is symmetric, the teams owning these bounded contexts
    may choose to share entire databases with free access to read, write, and change
    underlying structures. Conversely, in an asymmetric relationship, the supplier
    may constrain the scope of access, based on the type of relationship.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种集成风格中，相关有界上下文之间共享数据。如果关系是对称的，拥有这些有界上下文的团队可以选择共享整个数据库，允许自由地读取、写入和更改底层结构。相反，在不对称的关系中，供应商可能会根据关系的类型限制访问范围。
- en: Shared database
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享数据库
- en: 'The simplest form of data integration is the use of a shared database. In this
    style of integration, all participating bounded contexts have unrestricted access
    to the schemas and the underlying data, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集成最简单的形式是使用共享数据库。在这种集成风格中，所有参与的有界上下文都可以无限制地访问模式和底层数据，如图所示：
- en: '![Figure 9.13 – Integration using a shared database'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 使用共享数据库的集成'
- en: '](img/B16716_Figure_9.13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 使用数据复制的集成](img/B16716_Figure_9.13.jpg)'
- en: Figure 9.13 – Integration using a shared database
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 使用共享数据库的集成
- en: When to use
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: The shared database presents a very low barrier to entry for teams looking to
    quickly enable new or enhance existing functionality by providing ready access
    to data for read and/or write use cases. More importantly, it also allows the
    use of local database transactions, which usually provides strong consistency,
    lower complexity, and better performance (especially when working with relational
    databases).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数据库为希望快速启用新功能或增强现有功能的团队提供了非常低的进入门槛，通过提供对读取和/或写入用例数据的即时访问。更重要的是，它还允许使用本地数据库事务，这通常提供强一致性、较低复杂性和更好的性能（尤其是在与关系数据库一起工作时）。
- en: Potential pitfalls
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在陷阱
- en: However, this symmetric integration style where multiple teams have shared ownership
    is usually frowned upon because it often leads to a situation where there is no
    clear ownership. Furthermore, the shared databases can become a source of tight
    coupling, accelerating the path toward the dreaded *big ball of mud*. Additionally,
    users of the shared database can suffer from the *noisy neighbor* effect where
    one co-tenant monopolizing resources adversely affects all other tenants. For
    these reasons, teams will be well advised to choose this style of integration
    sparingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种多个团队共享所有权的对称集成风格通常是不受欢迎的，因为它往往导致没有明确所有权的局面。此外，共享数据库可能成为紧密耦合的来源，加速走向令人恐惧的*一团糟*的道路。此外，共享数据库的用户可能会遭受*嘈杂邻居*效应，其中一个共同租户垄断资源会不利地影响所有其他租户。因此，团队最好谨慎选择这种集成风格。
- en: Replicated data
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制数据
- en: 'In the case of asymmetric relationships, suppliers may be unwilling to provide
    direct access to their data. However, they may choose to integrate with customers
    using a mechanism based on data sharing. An alternate form of integration is to
    provide a copy of the data required by consumers. There are many variations on
    how this can be implemented; we depict the more common ways here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在非对称关系中，供应商可能不愿意直接提供其数据的访问权限。然而，他们可以选择使用基于数据共享的机制与客户集成。另一种集成形式是提供消费者所需数据的副本。这种实现方式有很多变体；我们在此展示更常见的方法：
- en: '![Figure 9.14 – Integration using data replication'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 使用数据复制的集成'
- en: '](img/B16716_Figure_9.14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 使用数据复制的集成](img/B16716_Figure_9.14.jpg)'
- en: Figure 9.14 – Integration using data replication
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 使用数据复制的集成
- en: '**Database views**: In this form, the consumer gets or is provided access to
    a subset of data using query-based or materialized views. In either case, the
    customer usually has read-only access to the data, and both supplier and customer
    continue to share the same physical resources (usually the database engine).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库视图**：在这种形式中，消费者通过查询或物化视图获取或被提供对数据子集的访问权限。在任一情况下，客户通常只有对数据的只读访问权限，供应商和客户继续共享相同的物理资源（通常是数据库引擎）。'
- en: '**Full read replica**: In this form, the customer gets access to a read replica
    of the supplier’s entire database, usually on a physically disparate infrastructure.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整读取副本**：在这种形式中，客户可以访问供应商整个数据库的读取副本，通常在物理上分散的基础设施上。'
- en: '**Partial read replica**: In this form, the customer gets access to a read
    replica of a subset of the supplier’s database, again on a physically disparate
    infrastructure.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分读取副本**：在这种形式中，客户可以访问供应商数据库子集的读取副本，再次在物理上分散的基础设施上。'
- en: When to use
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: This style of integration may be required when there is an asymmetric relationship
    between the supplier and the customer. Like the shared database, this integration
    style usually requires less upfront effort to integrate. This is also apt when
    suppliers intend to provide read-only access to a subset of their data. It may
    also suffice to use data replication when customers are only required to read
    a subset of the supplier’s data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '当供应商和客户之间存在非对称关系时，可能需要这种集成风格。与共享数据库类似，这种集成风格通常需要较少的前期努力来集成。这也适用于供应商打算只提供其数据子集的只读访问权限。当客户只需要读取供应商数据的一个子集时，使用数据复制也可能足够。 '
- en: Potential pitfalls
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在的陷阱
- en: If we choose to use database views, we may continue to suffer from the noisy
    neighbor effect. On the other hand, if we choose to create physically disparate
    replicas, we will need to incur the cost of additional operational complexity.
    More importantly, the consumers remain tightly coupled to the supplier’s domain
    models and ubiquitous language.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择使用数据库视图，我们可能会继续遭受嘈杂邻居效应。另一方面，如果我们选择创建物理上不同的副本，我们可能需要承担额外的操作复杂性成本。更重要的是，消费者仍然紧密耦合到供应商的领域模型和通用语言。
- en: Next, let’s look at some ways to make the most of data-based integrations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些充分利用基于数据集成的途径。
- en: Increasing effectiveness
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提高效率
- en: When sharing data, the schema (the structure of the database) acts as a means
    to enforce contracts, especially when using databases that require specifying
    a formal structure (for example, relational databases). When multiple parties
    are involved, managing the schema can become a challenge.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当共享数据时，模式（数据库的结构）充当强制执行合同的手段，尤其是在使用需要指定正式结构的数据库时（例如，关系型数据库）。当涉及多方时，管理模式可能成为一个挑战。
- en: To mitigate undesirable changes, teams sharing data may want to consider the
    use of a schema migration tool. Relational databases work well with tools such
    as Liquibase ([https://www.liquibase.org/](https://www.liquibase.org/)) or Flyway
    ([https://flywaydb.org/](https://flywaydb.org/)). When working with databases
    that do not formally enforce a schema, it may be best to avoid employing this
    style of integration, especially when working in symmetric relationships where
    ownership is unclear.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻不希望的变化，共享数据的团队可能需要考虑使用模式迁移工具。关系型数据库与Liquibase ([https://www.liquibase.org/](https://www.liquibase.org/))
    或 Flyway ([https://flywaydb.org/](https://flywaydb.org/)) 等工具配合良好。当与不正式强制执行模式的数据库一起工作时，最好避免采用这种集成方式，尤其是在所有权不明确的对称关系中。
- en: In any case, if using one of the shared data styles of integration is unavoidable,
    teams may want to strongly consider employing one or more of the aforementioned
    techniques in refactoring databases to make it more manageable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果使用共享数据集成风格之一是不可避免的，团队可能需要强烈考虑在重构数据库时采用上述一项或多项技术，以使其更易于管理。
- en: Code-based
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于代码
- en: 'In this style of integration, teams coordinate by sharing code artifacts, either
    directly in the form of source code and/or binaries. At a high level, there are
    two forms:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种集成方式中，团队通过共享代码工件进行协调，这些工件可以是源代码和/或二进制文件的形式。从高层次来看，有两种形式：
- en: Sharing source code
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享源代码
- en: Sharing binaries
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享二进制文件
- en: We will describe each of these here.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里描述每个方面。
- en: Sharing source code
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分享源代码
- en: A fairly common practice within organizations is to share source code with the
    objective of promoting reuse and standardization. This may include utilities (such
    as logging and authentication), build/deployment scripts, and data transfer objects
    – in other words, any piece of source code where the cost of duplication is seen
    to be higher than reuse.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织内部，共享源代码以促进重用和标准化是一种相当常见的做法。这可能包括实用程序（如日志记录和身份验证）、构建/部署脚本和数据传输对象——换句话说，任何成本高于重用的源代码片段。
- en: When to use
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: Depending on the relationship type (symmetric/asymmetric), teams sharing code
    may have varying levels of influence on how the shared artifacts evolve. This
    works well in a symmetric relationship, where both teams are empowered to make
    changes compatible with each other. Similarly, in an asymmetric relationship,
    the supplier may accept changes from customers, while retaining ownership and
    control of the shared artifacts. This also tends to work well in the case of non-core,
    infrequently changing code artifacts. Sharing source code also enables higher
    levels of transparency and visibility for the internals of the shared artifacts
    (a case in point is open source software).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关系类型（对称/非对称），共享代码的团队对共享工件演变的影响程度可能不同。在对称关系中，这种做法效果良好，因为两个团队都有权进行相互兼容的更改。同样，在非对称关系中，供应商可能接受来自客户的更改，同时保留对共享工件的所有权和控制权。这通常也适用于非核心、不经常更改的代码工件。共享源代码也使得共享工件内部具有更高的透明度和可见性（开源软件就是一个例子）。
- en: Potential pitfalls
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜在的陷阱
- en: Sharing code artifacts means that individual teams take on the responsibility
    to make sure that the process of converting source code into binary executables
    is uniform and compatible with the requirements of all parties. This may include
    code conventions, static quality checks, tests (the presence or lack thereof),
    compilation/build flags, and versioning. When a relatively large number of teams
    is involved, maintaining this form of compatibility may become burdensome.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 分享代码工件意味着各个团队需要承担确保将源代码转换为二进制可执行文件的过程统一且符合各方要求的责任。这可能包括代码约定、静态质量检查、测试（是否存在测试）、编译/构建标志和版本控制。当涉及相对大量的团队时，维护这种兼容性可能会变得繁重。
- en: Sharing binary artifacts
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分享二进制工件
- en: Another relatively common practice is to share artifacts at the binary level.
    In this scenario, the consumers may or may not have direct access to source code
    artifacts. Examples include third-party libraries, client SDKs, and API documentation.
    This form of integration is fairly common when the relationship between the coordinating
    parties is asymmetric. The supplier of the library has clear ownership of maintaining
    the life cycle of the shared artifacts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种相对常见的做法是在二进制级别共享工件。在这种情况下，消费者可能或可能没有直接访问源代码工件。例如，第三方库、客户端SDK和API文档。当协调各方的关系不对称时，这种集成形式相当常见。库的供应商对维护共享工件的生命周期有明确的拥有权。
- en: When to use
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: Sharing just binary artifacts may be necessary when the supplier is unable/unwilling
    to share source artifacts, possibly because they may be proprietary and/or part
    of the supplier’s intellectual property. Because the supplier takes ownership
    of the *build* process, it behooves the supplier to produce artifacts that are
    compatible with most potential consumers. Hence, this works well when the supplier
    is willing to do that. On the other hand, it means that the customer places high
    levels of trust ([https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain](https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain))
    in the supplier’s software supply chain ([https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide](https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide))
    when producing these artifacts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当供应商无法或不愿意共享源代码时，仅分享二进制工件可能是必要的，这可能是由于它们可能是专有的，也可能是供应商的知识产权的一部分。由于供应商负责**构建**过程，因此供应商有责任生产与大多数潜在消费者兼容的工件。因此，当供应商愿意这样做时，这种方法效果很好。另一方面，这也意味着在生成这些工件时，客户对供应商的软件供应链（[https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain](https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain)）和[https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide](https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide)）有很高的信任度。
- en: Potential pitfalls
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: Integration through the use of binary artifact sharing reduces the visibility
    of the build process of the shared artifacts for consumers. If consumers rely
    on slow-moving suppliers, this can become untenable. For example, if a critical
    security bug is discovered in the shared binary, the consumer is solely reliant
    on the supplier to remediate it. This can be a huge risk if such dependencies
    are in critical, business-differentiating aspects of the solution (especially
    in the core subdomain). This risk can be exacerbated without the use of appropriate
    ACLs and/or **Service-Level Agreements** (**SLAs**).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用二进制工件共享进行集成，减少了消费者对共享工件构建过程的可见性。如果消费者依赖于缓慢移动的供应商，这可能会变得不可行。例如，如果在共享的二进制文件中发现一个关键的安全漏洞，消费者将完全依赖于供应商来修复它。如果这种依赖性在解决方案的关键、业务区分性方面（特别是在核心子域中），这可能会带来巨大的风险。如果没有使用适当的ACLs和/或**服务级别协议**（**SLAs**），这种风险可能会加剧。
- en: Increasing effectiveness
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高效率
- en: 'When sharing code artifacts, it becomes a lot more important to be explicit
    in how changes are made while continuing to maintain high levels of quality –
    especially when multiple teams are involved. Let’s examine some of these techniques
    in more detail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当分享代码工件时，明确如何进行更改并继续保持高质量变得尤为重要——尤其是在涉及多个团队时。让我们更详细地考察一些这些技术：
- en: '**Static analysis**: This can be as simple as adhering to a set of coding standards
    using a tool such as Checkstyle. More importantly, these tools can be used to
    conform to a set of naming conventions to allow the firmer use of the ubiquitous
    language throughout the code base. In addition, tools such as SpotBugs and PMD/CPD
    can be used to statically analyze code for the presence of bugs and duplicate
    code.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分析**：这可以简单到使用Checkstyle等工具遵循一组编码标准。更重要的是，这些工具可以用来遵循一组命名约定，以便在整个代码库中更坚定地使用通用语言。此外，SpotBugs和PMD/CPD等工具可以用来静态分析代码，以检查是否存在错误和重复代码。'
- en: '**Code architecture tests**: While static inspection tools are effective at
    operating at the level of a single compilation unit, runtime inspection can take
    this one level further to identify package cycles, dependency checks, inheritance
    trees, and so on to apply lightweight architecture governance. The use of tools
    such as JDepend and ArchUnit can help here.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码架构测试**：虽然静态检查工具在操作单个编译单元的层面上非常有效，但运行时检查可以将这一层次提升一级，以识别包循环、依赖检查、继承树等，从而应用轻量级架构治理。使用JDepend和ArchUnit等工具可以在这方面提供帮助。'
- en: '**Unit tests**: When working with shared code bases, team members are looking
    to make changes safely and reliably. The presence of a comprehensive suite of
    fast-running unit tests can go a long way toward increasing confidence. We strongly
    recommend employing test-driven design to further maximize creating a code base
    that is well designed and enables easier refactoring.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：当与共享代码库一起工作时，团队成员寻求安全可靠地进行更改。存在一套全面的快速运行的单元测试可以大大提高信心。我们强烈建议采用测试驱动设计，以进一步最大化创建一个设计良好且易于重构的代码库。'
- en: '**Code reviews**: While automation can go a long way, augmenting the process
    where a human reviews changes can be highly effective for multiple reasons. This
    can take the form of offline reviews (using pull requests) or active peer reviews
    (using paired programming). All of these techniques serve to enhance collective
    understanding, thereby reducing risk when changes are made.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码审查**：虽然自动化可以走很长的路，但增加人工审查变更的过程可以因多种原因而非常有效。这可以采取离线审查（使用拉取请求）或主动的同行审查（使用结对编程）的形式。所有这些技术都有助于增强集体理解，从而在做出变更时降低风险。'
- en: '**Documentation**: Needless to say, well-structured documentation can be invaluable
    when making contributions and also when consuming binary code artifacts. Teams
    will be well advised to proliferate the use of the ubiquitous language by striving
    to write self-documenting code throughout to maximize the derived benefits.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：不用说，良好的结构化文档在做出贡献和消费二进制代码工件时非常有价值。团队将明智地通过努力在整个过程中编写自文档化的代码来推广使用通用语言，以最大化衍生出的好处。'
- en: '**Dependency management**: When sharing binary code artifacts, managing dependencies
    can become fairly complicated due to having too many dependencies, long dependency
    chains, conflicting/cyclic dependencies, and so on. Teams should strive to reduce
    afferent (incoming) coupling as much as possible to mitigate the problems described
    previously.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：在共享二进制代码工件时，由于存在过多的依赖项、长的依赖链、冲突/循环依赖等问题，管理依赖项可能会变得相当复杂。团队应努力尽可能减少输入（进入）耦合，以减轻之前描述的问题。'
- en: '**Versioning**: In addition to minimizing the amount of afferent coupling,
    using an explicit versioning strategy can go a long way toward making dependency
    management easier. We strongly recommend considering the use of a technique such
    as semantic versioning for shared code artifacts.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：除了最小化输入耦合的数量外，采用显式的版本控制策略可以在很大程度上简化依赖管理。我们强烈建议考虑使用诸如语义版本控制等技术来处理共享代码工件。'
- en: IPC-based
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于IPC
- en: In this style of integration, the bounded contexts exchange messages using some
    form of **Inter-Process Communication** (**IPC**) to interact with each other.
    This can take the form of synchronous or asynchronous communication.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种集成风格中，边界上下文通过某种形式的**进程间通信**（**IPC**）交换消息以相互交互。这可以是同步或异步通信。
- en: Synchronous messaging
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步消息
- en: 'Synchronous messaging is a style of communication where the sender of the request
    waits for a response from the receiver, which implies that the sender and the
    receiver need to be active for this style to work. Usually, this form of communication
    is point to point. HTTP is one of the commonly used protocols for this style of
    communication. A visual representation of this form of communication is shown
    here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同步消息是一种通信风格，其中请求的发送者等待接收者的响应，这意味着发送者和接收者都需要处于活动状态才能使这种风格生效。通常，这种通信形式是点对点的。HTTP
    是这种通信风格常用的协议之一。这种通信形式的视觉表示如下所示：
- en: '![Figure 9.15 – Synchronous messaging'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.15 – 同步消息'
- en: '](img/B16716_Figure_9.15.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.15.jpg)'
- en: Figure 9.15 – Synchronous messaging
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 同步消息
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please take a look at the HTTP APIs for the commands used during LC application
    processing, which are included with the code examples for this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 HTTP API，了解 LC 应用处理过程中使用的命令，这些命令包含在本章的代码示例中。
- en: When to use
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用时机
- en: This form of integration is used when the customer is interested in the supplier’s
    response to the request. The response is then used to determine whether the request
    was successful or not. Given that the customer needs to wait for the response,
    it is advisable to use this style of messaging for low-latency operations. This
    form of integration is popular when exposing public APIs over the internet (for
    example, GitHub’s REST API, which you can learn more about at [https://docs.github.com/en/rest](https://docs.github.com/en/rest)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户对供应商对请求的响应感兴趣时，使用这种集成形式。然后使用响应来确定请求是否成功。鉴于客户需要等待响应，建议在低延迟操作中使用这种消息风格。这种集成形式在通过互联网公开
    API（例如，GitHub 的 REST API，您可以在 [https://docs.github.com/en/rest](https://docs.github.com/en/rest)
    上了解更多信息）时很受欢迎。
- en: Potential pitfalls
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: When using synchronous messaging, the customer’s ability to scale is heavily
    dependent on the supplier to satisfy the customer’s requirements. On the flip
    side, customers making requests at too high a rate may compromise the supplier’s
    ability to serve customers in a predictable manner. If there is a chain of synchronous
    messaging, the probability of cascading failure becomes much higher.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用同步消息时，客户的扩展能力高度依赖于供应商来满足客户的需求。另一方面，请求频率过高的客户可能会损害供应商以可预测的方式服务客户的能力。如果有同步消息的链式，级联失败的概率会大大增加。
- en: Asynchronous messaging
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步消息
- en: Asynchronous messaging is a style of communication where the sender does not
    wait for an explicit response from the receiver.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 异步消息是一种通信风格，其中发送者不等待接收者的明确响应。
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the terms *sender* and *receiver* instead of *customer* and *supplier*
    because they both can play the role of sender or receiver.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语 *发送者* 和 *接收者* 而不是 *客户* 和 *供应商*，因为它们都可以扮演发送者或接收者的角色。
- en: 'This is typically achieved by introducing an intermediary in the form of a
    message channel. The presence of the intermediary enables both one-to-one and
    one-to-many modes of communication. Typically, the intermediary can take the form
    of a shared filesystem, database, or queueing system:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过引入中间件（以消息通道的形式）来实现的。中间件的存在使得一对一和一对多通信模式成为可能。通常，中间件可以采用共享文件系统、数据库或队列系统的形式：
- en: '![Figure 9.16 – Asynchronous messaging'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.16 – 异步消息'
- en: '](img/B16716_Figure_9.16.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_9.16.jpg)'
- en: Figure 9.16 – Asynchronous messaging
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 异步消息
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please take a look at the event APIs for the commands used during LC application
    processing, which are included with the code examples for this chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 LC 应用处理过程中使用的命令的事件 API，这些命令包含在本章的代码示例中。
- en: When to use
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用时机
- en: This form of integration is used when the sender does not care about receiving
    an `LCApplicationSubmittedEvent` is received by both the *compliance* and *customer
    onboarding* systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送者不关心是否收到来自 *合规性* 和 *客户注册* 系统的 `LCApplicationSubmittedEvent` 时，使用这种集成形式。
- en: Potential pitfalls
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的陷阱
- en: The introduction of the intermediary component adds complexity to the overall
    solution. The non-functional characteristics of the intermediary can have a profound
    effect on the resilience characteristics of the system as a whole. It can also
    be tempting to add processing logic to the intermediary, thereby coupling the
    overall system very tightly to this component. To ensure reliable communication
    between the sender and the receiver, the intermediary may have to support a variety
    of enhanced capabilities (such as ordering, producer flow control, durability,
    and transactions).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍中间件组件会增加整体解决方案的复杂性。中间件的非功能性特性可能会对整个系统的弹性特性产生深远的影响。也可能会有诱惑在中间件中添加处理逻辑，从而将整个系统与该组件紧密耦合。为了确保发送者和接收者之间的可靠通信，中间件可能必须支持各种增强功能（如排序、生产者流控制、持久性和事务）。
- en: Increasing effectiveness
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高有效性
- en: 'When implementing integration using some form of IPC, a lot of the techniques
    discussed in the code-based implementation patterns section continue to apply.
    As discussed earlier, API documentation plays a significant role in reducing friction
    for customers. In addition, here are a few more techniques that apply specifically
    when using IPC-based integration:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用某种形式的IPC实现集成时，代码实现模式部分讨论的许多技术仍然适用。如前所述，API文档在减少客户摩擦方面发挥着重要作用。此外，以下是一些在基于IPC的集成中特别适用的技术：
- en: '**Typed protocols**: When working with this form of integration, it is important
    to minimize the amount of time taken to gather feedback on structural validations.
    This is especially critical given that the supplier and the customer may be in
    a constant state of independent evolution. The use of typed protocols such as
    Protocol Buffers, Avro, Netflix’s Falcor, and GraphQL can make it easier for customers
    to interact with suppliers while maintaining a lightweight mechanism to validate
    whether requests are correct.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型化协议**：在与这种形式的集成工作时，最小化用于收集结构验证反馈所需的时间是非常重要的。考虑到供应商和客户可能处于持续独立的演变状态，这一点尤为重要。使用类型化协议，如Protocol
    Buffers、Avro、Netflix的Falcor和GraphQL，可以使客户在与供应商互动的同时，保持一个轻量级的机制来验证请求是否正确。'
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The key word here is **lightweight**. It is pertinent to note that we are not
    advising against the use of JSON-based HTTP APIs (typically advertised as being
    RESTful), which do not enforce the use of an explicit schema. Neither are we promoting
    the use of (arguably) legacy protocols such as SOAP, WSDL, and CORBA. Each of
    these, while being well-meaning, suffered from being fairly heavyweight.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词是**轻量级**。值得注意的是，我们并不是反对使用基于JSON的HTTP API（通常宣传为RESTful），这些API不强制使用显式模式。我们也不是在推广使用（有争议的）传统协议，如SOAP、WSDL和CORBA。尽管这些协议都是出于好意，但它们都存在相对较重的缺点。
- en: '**Self-discovery**: As outlined previously, when working with an IPC-based
    integration mechanism, we should look to reduce the barrier to entry. When working
    with RESTful APIs, the use of HATEOAS ([https://restfulapi.net/hateoas](https://restfulapi.net/hateoas)),
    although difficult for suppliers to implement, can make it easier for customers
    to understand and consume APIs. In addition, making use of a service registry
    and/or a schema registry can further reduce consumption friction.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我发现**：如前所述，当使用基于IPC的集成机制时，我们应该努力降低入门门槛。当使用RESTful API时，虽然对供应商来说实施HATEOAS
    ([https://restfulapi.net/hateoas](https://restfulapi.net/hateoas))可能比较困难，但它可以使客户更容易理解和消费API。此外，利用服务注册表和/或模式注册表可以进一步减少消费摩擦。'
- en: '**Contract tests**: In the spirit of failing fast and shifting left, the practice
    of contract testing and consumer-driven contracts can further increase the quality
    and speed of integration. Tools such as Pact (https://pact.io/) and Spring Cloud
    Contract ([https://spring.io/projects/spring-cloud-contract](https://spring.io/projects/spring-cloud-contract))
    make the adoption of these practices relatively simple.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**契约测试**：在快速失败和左移的精神下，契约测试和消费者驱动的契约的实践可以进一步提高集成的质量和速度。例如，Pact (https://pact.io/)
    和 Spring Cloud Contract ([https://spring.io/projects/spring-cloud-contract](https://spring.io/projects/spring-cloud-contract))
    等工具使得这些实践的采用相对简单。'
- en: So far, we’ve discussed implementation patterns, broadly categorized into data-based,
    code-based, and IPC-based integrations. Hopefully, this gives you a good start
    in consciously choosing the appropriate approach by considering the benefits and
    caveats that they bring along with them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了实现模式，这些模式大致分为基于数据、基于代码和基于IPC的集成。希望这能帮助你通过考虑它们带来的好处和注意事项，有意识地选择适当的方法。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the different types of bounded context relationships.
    We also examined common integration patterns that can be used when implementing
    these bounded context relationships.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了不同类型的边界上下文关系。我们还检查了在实现这些边界上下文关系时可以使用的常见集成模式。
- en: You have learned when specific techniques can be used, about potential pitfalls,
    and ideas on how to increase effectiveness when employing these methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了何时可以使用特定技术，了解了潜在的风险，以及在使用这些方法时如何提高效率的想法。
- en: In the next chapter, we will explore the means to distribute these bounded contexts
    into independently deployable components (in other words, employ a microservices-based
    architecture).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将这些边界上下文分配到独立可部署的组件中的方法（换句话说，采用基于微服务的架构）。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_Table_9.1.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_Table_9.1.jpg)'
