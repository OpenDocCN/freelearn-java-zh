- en: '*Chapter 9*: Integrating with External Systems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wholeness is not achieved by cutting off a portion of one’s being, but by integration
    of the contraries.
  prefs: []
  type: TYPE_NORMAL
- en: – Carl Jung
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used DDD to implement a robust core for our application. However,
    most solutions (by extension-bounded contexts) usually have both upstream and
    downstream dependencies that usually change at a pace, which is different from
    these core components. To maintain both agility and reliability and enable loose
    coupling, it is important to integrate with a peripheral system in a manner that
    shields the core from everything else that surrounds it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the LC application processing solution and
    examine the means by which we can integrate with other components in the ecosystem.
    You will learn how to recognize relationship patterns between components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our design journey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounded context relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will round off by looking at common patterns when
    integrating with legacy applications. Let’s dive right in!
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our design journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From our domain analysis in earlier chapters, we have arrived at four bounded
    contexts for our application, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Relationship between bounded contexts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Relationship between bounded contexts
  prefs: []
  type: TYPE_NORMAL
- en: So far, our focus has been on the implementation of the internals of the **LC
    application** bounded context. While the LC application bounded context is independent
    of the other bounded contexts, it is not completely isolated from them. For example,
    when processing an LC application, we need to perform merchandise and applicant
    checks that require interactions with the **compliance** and **customer onboarding**
    bounded contexts respectively. This means that these bounded contexts have a relationship
    with each other. These relationships are driven by the nature of collaboration
    between the teams working on the respective bounded contexts. Let’s examine how
    these team dynamics influence integration mechanisms between bounded contexts
    in a way that continues to preserve their individual integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded context relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need bounded contexts to be as independent as possible. However, this does
    not mean that bounded contexts are completely isolated from each other. Bounded
    contexts need to collaborate with others to provide business value. Whenever there
    is collaboration required between two bounded contexts, the nature of their relationship
    is not only influenced by their individual goals and priorities but also by the
    prevailing organizational realities. In a high-performing environment, it is fairly
    common to have a single team assume ownership of a bounded context. The relationships
    between the teams owning these bounded contexts play a significant role in influencing
    the integration patterns employed to arrive at a solution. At a high level, there
    are two categories of relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at these relationship types in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric relationship patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two teams, say team A and team B, can be said to have a symmetric relationship
    when they have an equal amount of influence in the decision-making process to
    arrive at a solution. Both teams are in a position to, and, indeed, do, contribute
    more or less equally toward the outcome. Here’s a diagrammatic representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Both teams have an equal say in influencing the solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Both teams have an equal say in influencing the solution
  prefs: []
  type: TYPE_NORMAL
- en: There are three variations of symmetric relationships, each of which we will
    outline in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Partnership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a partnership, both teams integrate in an ad hoc manner. There are no fixed
    responsibilities assigned when needing complete integration work. Each team picks
    up work as and when needed without the need for any specific ceremony or fanfare.
    The nature of the integration is usually two-way, with both teams exchanging solution
    artifacts as and when needed. Such relationships require extremely high degrees
    of collaboration and understanding of the work done by both teams. Check the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership
    relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership
    relationship
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take as an example a web frontend team working in close collaboration
    with an API team building the BFFs ([https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html](https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html))
    for the frontend. The BFF team creates experience APIs meant to be used exclusively
    by the frontend. To fulfill any functionality, the frontend team requires capabilities
    to be exposed by the APIs team. On the other hand, the APIs team is dependent
    on the frontend team to provide advice on what capabilities to build and the order
    in which to build them. Both teams freely make use of each other’s domain models
    (for example, the same set of request and response objects that define the API)
    to implement functionality. Such reuse happens mostly arbitrarily, and when API
    changes happen, both teams coordinate changes to keep things working.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Partnership between teams requires high levels of collaboration, trust, and
    understanding. Teams tend to use this partnership when team boundaries are informal.
    It also helps if these teams are co-located and/or have a significant working
    time overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Partnership relationships between teams can lead to a situation where individual
    team responsibilities become very unclear, leading a solution toward the dreaded
    *big ball of mud*.
  prefs: []
  type: TYPE_NORMAL
- en: Shared kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike in a partnership, when using a shared kernel, teams have a clear understanding
    of the solution artifacts and models they choose to share between themselves.
    Both teams take equal responsibility for the upkeep of these shared artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *LC application processing* and *customer onboarding* teams in our LC application
    may choose to use a common model to represent `CustomerCreditValidatedEvent`.
    Any enhancements or changes to the event schema can affect both teams. The responsibility
    to make any changes is owned by both teams. Intentionally, these teams do not
    share anything beyond these mutually agreed-upon models and artifacts. Here’s
    a representation of a shared kernel relationship between teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Teams have an explicit understanding of shared models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Teams have an explicit understanding of shared models
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shared kernel form of collaboration works well if shared artifacts are required
    to be consumed in an identical fashion in both contexts. Furthermore, it is attractive
    for multiple teams to coordinate and continue sharing, as opposed to duplicating
    identical models in both contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Changes made to the shared kernel affect both bounded contexts. This means that
    any change made to the shared kernel needs to remain compatible for both teams.
    Needless to say, as the number of teams using the shared kernel increases, the
    cost of coordination goes up manifold.
  prefs: []
  type: TYPE_NORMAL
- en: Separate ways
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When two teams choose to not share any artifacts or models between them, they
    go their own separate ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Teams go separate ways and don’t share anything between them'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Teams go separate ways and don’t share anything between them
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *LC application processing* and *customer onboarding* teams may start by
    sharing the same build/deployment scripts for their services. Over a period of
    time, deployment requirements may diverge to a point where the shared cost of
    maintaining these scripts becomes prohibitively expensive, causing these teams
    to fork their deployments to regain independence from the other team.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, two teams may be unable to collaborate for a variety of reasons,
    ranging from a drift in individual team requirements to organizational politics.
    Whatever the case may be, these teams may decide that the cost of collaboration
    is too high, resulting in them going their own separate ways.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Choosing to go separate ways may result in duplicate work across affected bounded
    contexts. When working in bounded contexts that map to core subdomains, this may
    prove counterproductive, as it can lead to inconsistent behaviors unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to transition from one relationship type to another over a period
    of time. In our experience, transitioning from any one of these relationships
    may not be straightforward. In cases where requirements are relatively clear at
    the outset, it may be easier to start with a *shared kernel*. Conversely, if requirements
    are unclear, it may be prudent to start either with a loose *partnership* or go
    *separate ways* until requirements become clear. In any of these scenarios, it
    is important to keep evaluating the nature of the relationship and transition
    to a more appropriate type, based on our enhanced understanding of the requirements
    and/or the relationship itself.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the preceding characterized relationships, the teams involved have
    a more or less equal say in how the relationship evolved and the resulting outcomes.
    However, this may not always be the case. Let’s look at examples of cases where
    one team may have a clear upper hand in terms of how the relationship evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric relationship patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two teams can be said to have an asymmetric relationship when one of the teams
    has a stronger influence in the decision-making process to arrive at a solution.
    In other words, there is a clear customer-supplier (or upstream-downstream) relationship
    where either the customer or the supplier plays a dominant role that affects solution
    design approaches. It is also likely that the customer and the supplier do not
    share common goals. Here is a representation of an asymmetric relationship between
    customer and supplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – One of the teams has a dominant say in influencing the solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – One of the teams has a dominant say in influencing the solution
  prefs: []
  type: TYPE_NORMAL
- en: There are at least three solution patterns when teams are in an asymmetric relationship,
    each of which we will outline in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Conformist (CF)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is not unusual for the side playing the supplier role to have a dominant
    say in how the relationship with one or more customers is implemented. Furthermore,
    the customer may simply choose to conform to the supplier-provided solution as
    is, making it an integral part of their own solution. In other words, the supplier
    provides a set of models and the customer uses those same models to build their
    solution. In this case, the customer is considered to be a *conformist*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The customer accepts dependency on the supplier model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – The customer accepts dependency on the supplier model
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When building a solution to validate the United States postal addresses of LC
    applicants, we chose to conform to the USPS Web Tools address validation API schema
    ([https://www.usps.com/business/web-tools-apis/](https://www.usps.com/business/web-tools-apis/)).
    Given that the business started with just US-based applicants, this made sense.
    This means that any references to the address model in our bounded contexts mimic
    the schema prescribed by the USPS. Furthermore, it means that we will need to
    keep up with changes that occur in the USPS API as and when they occur (regardless
    of whether those changes are needed for our own functionality).
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Being a conformist is not necessarily a negative thing. The supplier’s models
    may be a well-accepted industry standard, or they may simply be good enough for
    our needs. It may also be that the team may not have the necessary skills, motivation,
    or immediate need to do something different from what the supplier has provided.
    This approach also enables teams to make quick progress, leveraging work mostly
    done by other experts.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An overuse of the conformist pattern may dilute the ubiquitous language of our
    own bounded contexts, resulting in a situation where there is no clear separation
    between the supplier and customer concepts. It may also be that concepts that
    are core to the supplier’s context leak into our own, despite those concepts carrying
    little to no meaning in our context. This may result in these bounded contexts
    being very tightly coupled with each other. And if a need arises to switch to
    another supplier or support multiple suppliers, the cost of change may be prohibitively
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Corruption Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There may be scenarios where a customer may need to collaborate with a supplier
    but may want to shield themselves from the supplier’s ubiquitous language and
    models. In such cases, it may be prudent to redefine these conflicting models
    in the customer’s own ubiquitous language using a translation layer at the time
    of integration, also known as an **Anti-Corruption Layer** (**ACL**). See the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The customer wants to protect themselves from supplier models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – The customer wants to protect themselves from supplier models
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the address validation example referenced in the *Conformist (CF)* section,
    the *LC application processing* team may need to support Canadian applicants as
    well. In such a case, being a conformist to a system that supports only US addresses
    may prove restrictive and even confusing. For example, the US *state* is analogous
    to a *province* in Canada. Similarly, a *ZIP code* in the US is called a *postal
    code* in Canada. In addition, US ZIP codes are numeric whereas Canadian postal
    codes are alphanumeric. Most importantly, we currently do not have the notion
    of a *country code* in our address model, but now we will need to introduce this
    concept to differentiate addresses within the respective countries. Let’s look
    at the address models from the respective countries here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The address models of different countries'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – The address models of different countries
  prefs: []
  type: TYPE_NORMAL
- en: While we initially conformed to the USPS model, we have now evolved to support
    more countries. For example, *region* is used to represent the concept of *state/province*.
    Also, we have introduced the *country* value object, which was missing earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ACLs come in handy when the customer models are part of a core domain. The ACL
    shields the customer from changes in the supplier’s models and can help produce
    more loosely coupled integrations. It may also be necessary when we are looking
    to integrate similar concepts from multiple suppliers.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using an ACL may be tempting in a lot of cases. However, it is less beneficial
    when the concepts being integrated don’t often change or are defined by a well-known
    authority. Using an ACL with a custom language may only cause more confusion.
    Creating an ACL usually requires additional translations and thereby may increase
    the overall complexity of the customer’s bounded context and may be considered
    premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Open host service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike the conformist and the ACL, where customers do not have a formal means
    to interface with the supplier, with the **Open Host Service** (**OHS**), the
    supplier defines a clear interface to interact with its customers. This interface
    may be made available in the form of a well-known published language (for example,
    a REST interface or a client SDK):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – An OHS using a Published Language (PL)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – An OHS using a Published Language (PL)
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LC application processing bounded context can expose an HTTP interface
    for each of its commands, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As an addition to the HTTP interface shown here, we can even provide a client
    SDK in some of the more popular languages used by our customers. This helps hide
    more implementation details such as the MIME type and version from customers.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the supplier wants to hide its internal models (ubiquitous language), making
    an OHS enables the supplier to evolve while providing a stable interface to its
    customers. In a sense, the OHS pattern is a reversal of the ACL pattern – instead
    of the customer, the supplier implements the translation of its internal model.
    Also, the supplier can consider providing an OHS when it is interested in providing
    a richer user experience for its customers.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While suppliers may have good intentions by providing an OHS for its customers,
    it may result in increased implementation complexity (for example, there may be
    a need to support multiple versions of an API, or client SDKs in multiple languages).
    If the OHS does not take into account the common usage patterns of its customers,
    it may result in poor customer usability and also in degraded performance for
    the supplier.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the conformist and the ACL are patterns that customers
    implement, whereas the OHS is a supplier-side pattern. For example, the following
    scenario where the supplier provides an *OHS* to one customer who is a *conformist*
    and another who has an *ACL* can be true, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Asymmetric relationships with multiple customers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Asymmetric relationships with multiple customers
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the various ways in which bounded contexts can integrate
    with each other, here is one possible implementation for our LC application, depicted
    in the form of a context map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – A simplified context map for the LC application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – A simplified context map for the LC application
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have examined the various ways in which inter-team dynamics influence
    integration mechanisms. While having clarity at the conceptual level helps, let’s
    see how these relationships manifest themselves at the implementation level.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have looked at integration between bounded contexts at a design level, but
    these concepts need to be translated into code. There are three broad categories
    that can be employed when integrating two bounded contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: Data-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each method in more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: Data-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this style of integration, the bounded contexts in question share data with
    each other. If the relationship is symmetric, the teams owning these bounded contexts
    may choose to share entire databases with free access to read, write, and change
    underlying structures. Conversely, in an asymmetric relationship, the supplier
    may constrain the scope of access, based on the type of relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Shared database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest form of data integration is the use of a shared database. In this
    style of integration, all participating bounded contexts have unrestricted access
    to the schemas and the underlying data, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Integration using a shared database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Integration using a shared database
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shared database presents a very low barrier to entry for teams looking to
    quickly enable new or enhance existing functionality by providing ready access
    to data for read and/or write use cases. More importantly, it also allows the
    use of local database transactions, which usually provides strong consistency,
    lower complexity, and better performance (especially when working with relational
    databases).
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: However, this symmetric integration style where multiple teams have shared ownership
    is usually frowned upon because it often leads to a situation where there is no
    clear ownership. Furthermore, the shared databases can become a source of tight
    coupling, accelerating the path toward the dreaded *big ball of mud*. Additionally,
    users of the shared database can suffer from the *noisy neighbor* effect where
    one co-tenant monopolizing resources adversely affects all other tenants. For
    these reasons, teams will be well advised to choose this style of integration
    sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: Replicated data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case of asymmetric relationships, suppliers may be unwilling to provide
    direct access to their data. However, they may choose to integrate with customers
    using a mechanism based on data sharing. An alternate form of integration is to
    provide a copy of the data required by consumers. There are many variations on
    how this can be implemented; we depict the more common ways here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Integration using data replication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Integration using data replication
  prefs: []
  type: TYPE_NORMAL
- en: '**Database views**: In this form, the consumer gets or is provided access to
    a subset of data using query-based or materialized views. In either case, the
    customer usually has read-only access to the data, and both supplier and customer
    continue to share the same physical resources (usually the database engine).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full read replica**: In this form, the customer gets access to a read replica
    of the supplier’s entire database, usually on a physically disparate infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial read replica**: In this form, the customer gets access to a read
    replica of a subset of the supplier’s database, again on a physically disparate
    infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This style of integration may be required when there is an asymmetric relationship
    between the supplier and the customer. Like the shared database, this integration
    style usually requires less upfront effort to integrate. This is also apt when
    suppliers intend to provide read-only access to a subset of their data. It may
    also suffice to use data replication when customers are only required to read
    a subset of the supplier’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we choose to use database views, we may continue to suffer from the noisy
    neighbor effect. On the other hand, if we choose to create physically disparate
    replicas, we will need to incur the cost of additional operational complexity.
    More importantly, the consumers remain tightly coupled to the supplier’s domain
    models and ubiquitous language.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at some ways to make the most of data-based integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing effectiveness
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When sharing data, the schema (the structure of the database) acts as a means
    to enforce contracts, especially when using databases that require specifying
    a formal structure (for example, relational databases). When multiple parties
    are involved, managing the schema can become a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate undesirable changes, teams sharing data may want to consider the
    use of a schema migration tool. Relational databases work well with tools such
    as Liquibase ([https://www.liquibase.org/](https://www.liquibase.org/)) or Flyway
    ([https://flywaydb.org/](https://flywaydb.org/)). When working with databases
    that do not formally enforce a schema, it may be best to avoid employing this
    style of integration, especially when working in symmetric relationships where
    ownership is unclear.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, if using one of the shared data styles of integration is unavoidable,
    teams may want to strongly consider employing one or more of the aforementioned
    techniques in refactoring databases to make it more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Code-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this style of integration, teams coordinate by sharing code artifacts, either
    directly in the form of source code and/or binaries. At a high level, there are
    two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will describe each of these here.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing source code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fairly common practice within organizations is to share source code with the
    objective of promoting reuse and standardization. This may include utilities (such
    as logging and authentication), build/deployment scripts, and data transfer objects
    – in other words, any piece of source code where the cost of duplication is seen
    to be higher than reuse.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on the relationship type (symmetric/asymmetric), teams sharing code
    may have varying levels of influence on how the shared artifacts evolve. This
    works well in a symmetric relationship, where both teams are empowered to make
    changes compatible with each other. Similarly, in an asymmetric relationship,
    the supplier may accept changes from customers, while retaining ownership and
    control of the shared artifacts. This also tends to work well in the case of non-core,
    infrequently changing code artifacts. Sharing source code also enables higher
    levels of transparency and visibility for the internals of the shared artifacts
    (a case in point is open source software).
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sharing code artifacts means that individual teams take on the responsibility
    to make sure that the process of converting source code into binary executables
    is uniform and compatible with the requirements of all parties. This may include
    code conventions, static quality checks, tests (the presence or lack thereof),
    compilation/build flags, and versioning. When a relatively large number of teams
    is involved, maintaining this form of compatibility may become burdensome.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing binary artifacts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another relatively common practice is to share artifacts at the binary level.
    In this scenario, the consumers may or may not have direct access to source code
    artifacts. Examples include third-party libraries, client SDKs, and API documentation.
    This form of integration is fairly common when the relationship between the coordinating
    parties is asymmetric. The supplier of the library has clear ownership of maintaining
    the life cycle of the shared artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sharing just binary artifacts may be necessary when the supplier is unable/unwilling
    to share source artifacts, possibly because they may be proprietary and/or part
    of the supplier’s intellectual property. Because the supplier takes ownership
    of the *build* process, it behooves the supplier to produce artifacts that are
    compatible with most potential consumers. Hence, this works well when the supplier
    is willing to do that. On the other hand, it means that the customer places high
    levels of trust ([https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain](https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain))
    in the supplier’s software supply chain ([https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide](https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide))
    when producing these artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Integration through the use of binary artifact sharing reduces the visibility
    of the build process of the shared artifacts for consumers. If consumers rely
    on slow-moving suppliers, this can become untenable. For example, if a critical
    security bug is discovered in the shared binary, the consumer is solely reliant
    on the supplier to remediate it. This can be a huge risk if such dependencies
    are in critical, business-differentiating aspects of the solution (especially
    in the core subdomain). This risk can be exacerbated without the use of appropriate
    ACLs and/or **Service-Level Agreements** (**SLAs**).
  prefs: []
  type: TYPE_NORMAL
- en: Increasing effectiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When sharing code artifacts, it becomes a lot more important to be explicit
    in how changes are made while continuing to maintain high levels of quality –
    especially when multiple teams are involved. Let’s examine some of these techniques
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static analysis**: This can be as simple as adhering to a set of coding standards
    using a tool such as Checkstyle. More importantly, these tools can be used to
    conform to a set of naming conventions to allow the firmer use of the ubiquitous
    language throughout the code base. In addition, tools such as SpotBugs and PMD/CPD
    can be used to statically analyze code for the presence of bugs and duplicate
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code architecture tests**: While static inspection tools are effective at
    operating at the level of a single compilation unit, runtime inspection can take
    this one level further to identify package cycles, dependency checks, inheritance
    trees, and so on to apply lightweight architecture governance. The use of tools
    such as JDepend and ArchUnit can help here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**: When working with shared code bases, team members are looking
    to make changes safely and reliably. The presence of a comprehensive suite of
    fast-running unit tests can go a long way toward increasing confidence. We strongly
    recommend employing test-driven design to further maximize creating a code base
    that is well designed and enables easier refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reviews**: While automation can go a long way, augmenting the process
    where a human reviews changes can be highly effective for multiple reasons. This
    can take the form of offline reviews (using pull requests) or active peer reviews
    (using paired programming). All of these techniques serve to enhance collective
    understanding, thereby reducing risk when changes are made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Needless to say, well-structured documentation can be invaluable
    when making contributions and also when consuming binary code artifacts. Teams
    will be well advised to proliferate the use of the ubiquitous language by striving
    to write self-documenting code throughout to maximize the derived benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: When sharing binary code artifacts, managing dependencies
    can become fairly complicated due to having too many dependencies, long dependency
    chains, conflicting/cyclic dependencies, and so on. Teams should strive to reduce
    afferent (incoming) coupling as much as possible to mitigate the problems described
    previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: In addition to minimizing the amount of afferent coupling,
    using an explicit versioning strategy can go a long way toward making dependency
    management easier. We strongly recommend considering the use of a technique such
    as semantic versioning for shared code artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this style of integration, the bounded contexts exchange messages using some
    form of **Inter-Process Communication** (**IPC**) to interact with each other.
    This can take the form of synchronous or asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous messaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Synchronous messaging is a style of communication where the sender of the request
    waits for a response from the receiver, which implies that the sender and the
    receiver need to be active for this style to work. Usually, this form of communication
    is point to point. HTTP is one of the commonly used protocols for this style of
    communication. A visual representation of this form of communication is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Synchronous messaging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Synchronous messaging
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please take a look at the HTTP APIs for the commands used during LC application
    processing, which are included with the code examples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This form of integration is used when the customer is interested in the supplier’s
    response to the request. The response is then used to determine whether the request
    was successful or not. Given that the customer needs to wait for the response,
    it is advisable to use this style of messaging for low-latency operations. This
    form of integration is popular when exposing public APIs over the internet (for
    example, GitHub’s REST API, which you can learn more about at [https://docs.github.com/en/rest](https://docs.github.com/en/rest)).
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using synchronous messaging, the customer’s ability to scale is heavily
    dependent on the supplier to satisfy the customer’s requirements. On the flip
    side, customers making requests at too high a rate may compromise the supplier’s
    ability to serve customers in a predictable manner. If there is a chain of synchronous
    messaging, the probability of cascading failure becomes much higher.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous messaging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous messaging is a style of communication where the sender does not
    wait for an explicit response from the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the terms *sender* and *receiver* instead of *customer* and *supplier*
    because they both can play the role of sender or receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is typically achieved by introducing an intermediary in the form of a
    message channel. The presence of the intermediary enables both one-to-one and
    one-to-many modes of communication. Typically, the intermediary can take the form
    of a shared filesystem, database, or queueing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Asynchronous messaging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_9.16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Asynchronous messaging
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please take a look at the event APIs for the commands used during LC application
    processing, which are included with the code examples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When to use
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This form of integration is used when the sender does not care about receiving
    an `LCApplicationSubmittedEvent` is received by both the *compliance* and *customer
    onboarding* systems.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The introduction of the intermediary component adds complexity to the overall
    solution. The non-functional characteristics of the intermediary can have a profound
    effect on the resilience characteristics of the system as a whole. It can also
    be tempting to add processing logic to the intermediary, thereby coupling the
    overall system very tightly to this component. To ensure reliable communication
    between the sender and the receiver, the intermediary may have to support a variety
    of enhanced capabilities (such as ordering, producer flow control, durability,
    and transactions).
  prefs: []
  type: TYPE_NORMAL
- en: Increasing effectiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When implementing integration using some form of IPC, a lot of the techniques
    discussed in the code-based implementation patterns section continue to apply.
    As discussed earlier, API documentation plays a significant role in reducing friction
    for customers. In addition, here are a few more techniques that apply specifically
    when using IPC-based integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Typed protocols**: When working with this form of integration, it is important
    to minimize the amount of time taken to gather feedback on structural validations.
    This is especially critical given that the supplier and the customer may be in
    a constant state of independent evolution. The use of typed protocols such as
    Protocol Buffers, Avro, Netflix’s Falcor, and GraphQL can make it easier for customers
    to interact with suppliers while maintaining a lightweight mechanism to validate
    whether requests are correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The key word here is **lightweight**. It is pertinent to note that we are not
    advising against the use of JSON-based HTTP APIs (typically advertised as being
    RESTful), which do not enforce the use of an explicit schema. Neither are we promoting
    the use of (arguably) legacy protocols such as SOAP, WSDL, and CORBA. Each of
    these, while being well-meaning, suffered from being fairly heavyweight.
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-discovery**: As outlined previously, when working with an IPC-based
    integration mechanism, we should look to reduce the barrier to entry. When working
    with RESTful APIs, the use of HATEOAS ([https://restfulapi.net/hateoas](https://restfulapi.net/hateoas)),
    although difficult for suppliers to implement, can make it easier for customers
    to understand and consume APIs. In addition, making use of a service registry
    and/or a schema registry can further reduce consumption friction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract tests**: In the spirit of failing fast and shifting left, the practice
    of contract testing and consumer-driven contracts can further increase the quality
    and speed of integration. Tools such as Pact (https://pact.io/) and Spring Cloud
    Contract ([https://spring.io/projects/spring-cloud-contract](https://spring.io/projects/spring-cloud-contract))
    make the adoption of these practices relatively simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we’ve discussed implementation patterns, broadly categorized into data-based,
    code-based, and IPC-based integrations. Hopefully, this gives you a good start
    in consciously choosing the appropriate approach by considering the benefits and
    caveats that they bring along with them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different types of bounded context relationships.
    We also examined common integration patterns that can be used when implementing
    these bounded context relationships.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned when specific techniques can be used, about potential pitfalls,
    and ideas on how to increase effectiveness when employing these methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the means to distribute these bounded contexts
    into independently deployable components (in other words, employ a microservices-based
    architecture).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/B16716_Table_9.1.jpg)'
  prefs: []
  type: TYPE_IMG
