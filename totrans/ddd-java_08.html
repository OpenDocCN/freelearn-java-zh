<html><head></head><body>
		<div id="_idContainer147">
			<h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor097"/>Chapter 6</em>: Implementing the User Interface – Task-Based</h1>
			<p class="author-quote">To accomplish a difficult task, one must first make it easy.</p>
			<p class="author-quote">– Marty Rubin</p>
			<p>The essence of <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) is about capturing the business process and user intent. In the previous chapter, we designed a set of APIs without paying much attention to how those APIs would get consumed by their eventual users. In this chapter, we will design the GUI for the LC application using the JavaFX framework. As part of that, we will examine how this approach of designing APIs in isolation can cause an impedance mismatch between the producers and the consumers. We will examine the consequences of this impedance mismatch and how task-based UIs can help cope with this mismatch.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>API styles</li>
				<li>Bootstrapping the UI</li>
				<li>Implementing the UI</li>
			</ul>
			<p>By the end of the chapter, you will know how to employ DDD principles to help you build robust user experiences that are simple and intuitive. You will also learn why it may be prudent to design your backend interfaces (APIs) from the perspective of the consumer.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p>You will need access to the following:</p>
			<ul>
				<li>JDK 1.8+ (we have used Java 16 to compile sample sources)</li>
				<li>JavaFX SDK 16 and Scene Builder</li>
				<li>Maven 3.x</li>
				<li>Spring Boot 2.4.x</li>
				<li>mvvmFX 1.8 (<a href="https://sialcasa.github.io/mvvmFX/">https://sialcasa.github.io/mvvmFX/</a>)</li>
				<li>JUnit 5.7.x (included with Spring Boot)</li>
				<li>TestFX (for UI testing)</li>
				<li>OpenJFX Monocle (for headless UI testing)</li>
				<li>Project Lombok (to reduce verbosity)</li>
			</ul>
			<p>Before we dive deep into building the GUI solution, let’s do a quick recap of where we left the APIs.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>API styles</h1>
			<p>If you recall from <a href="B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 5</em></a>, <em class="italic">Implementing Domain Logic</em>, we created the following commands:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B16716_Figure_6.1.jpg" alt="Figure 6.1 – Commands from the eventstorming session&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Commands from the eventstorming session</p>
			<p>If you observe carefully, there seem to be commands<a id="_idIndexMarker369"/> at two levels of granularity. <strong class="bold">Create LC Application</strong> and <strong class="bold">Update LC Application</strong> are coarse-grained, whereas the others are a lot more focused in terms of their intent. One possible decomposition of the coarse-grained commands can be as depicted here:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B16716_Figure_6.2.jpg" alt="Figure 6.2 – Decomposed commands&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Decomposed commands</p>
			<p>In addition to just being more fine-grained than the commands in the previous iteration, the revised commands seem to better capture the user’s intent. This may feel like a minor change in semantics, but can have a huge impact on the way our solution is used by its ultimate end users. The question then is whether we should <em class="italic">always</em> prefer fine-grained APIs over coarse-grained<a id="_idIndexMarker370"/> ones. The answer can be a lot more nuanced. When designing APIs and experiences, we see two main styles being employed:</p>
			<ul>
				<li>CRUD-based</li>
				<li>Task-based</li>
			</ul>
			<p>Let’s look at each of these in a bit more detail.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>CRUD-based APIs</h2>
			<p><strong class="bold">CRUD</strong> is an acronym used to refer<a id="_idIndexMarker371"/> to the four basic operations<a id="_idIndexMarker372"/> that can be performed on database applications: <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong>. Many programming languages and protocols<a id="_idIndexMarker373"/> have their own equivalent of CRUD, often with slight variations in naming and intent. For example, SQL – a popular language for interacting with databases – calls the four functions <strong class="source-inline">Insert</strong>, <strong class="source-inline">Select</strong>, <strong class="source-inline">Update</strong>, and <strong class="source-inline">Delete</strong>. Similarly, the HTTP protocol has <strong class="source-inline">POST</strong>, <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> as verbs to represent these CRUD operations. This approach has been extended to the design<a id="_idIndexMarker374"/> of our APIs as well. This has resulted in the proliferation of both CRUD-based APIs<a id="_idIndexMarker375"/> and user experiences. Take a look at <strong class="source-inline">CreateLCApplicationCommand</strong> from <a href="B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 5</em></a>, <em class="italic">Implementing Domain Logic</em>:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/ch6-1.jpg" alt=""/>
				</div>
			</div>
			<p>Along similar lines, it would not be uncommon to create a corresponding <strong class="source-inline">UpdateLCApplicationCommand</strong>, as depicted here:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/ch6-2.jpg" alt=""/>
				</div>
			</div>
			<p>While this is very common<a id="_idIndexMarker376"/> and also very easy to grasp, it is not without problems. Here are some<a id="_idIndexMarker377"/> questions that taking this approach raises:</p>
			<ul>
				<li>Are we allowed to change everything listed in the <strong class="source-inline">update</strong> command?</li>
				<li>Assuming that everything can change, do they all change at the same time?</li>
				<li>How do we know what exactly changed? Should we be doing a diff?</li>
				<li>What if all the attributes mentioned above are not included in the <strong class="source-inline">update</strong> command?</li>
				<li>What if we need to add attributes in the future?</li>
				<li>Is the business intent of what the user wanted to accomplish captured?</li>
			</ul>
			<p>In a simple system, the answer to these questions may not matter that much. However, as system complexity increases, will this approach remain resilient to change? We feel that it merits taking a look at another<a id="_idIndexMarker378"/> approach called task-based APIs to be able to answer<a id="_idIndexMarker379"/> these questions.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Task-based APIs</h2>
			<p>In a typical organization, individuals perform<a id="_idIndexMarker380"/> tasks relevant to their specialization. The bigger the organization, the higher the degree of specialization. This approach of segregating<a id="_idIndexMarker381"/> tasks according to one’s specialization makes sense because it mitigates the possibility of stepping on each other’s shoes, especially when getting complex pieces of work done. For example, in the LC application process, there is a need to establish the value/legality of the product while also determining the creditworthiness of the applicant. It makes sense that each of these tasks is usually performed by individuals in unrelated departments. It also follows that these tasks can be performed independently of the other.</p>
			<p>In terms of a business process, if we have a single <strong class="source-inline">CreateLCApplicationCommand</strong> command that precedes these operations, individuals in both departments firstly have to wait for the entire application to be filled out before either can commence their work. Secondly, if either piece of information is updated through a single <strong class="source-inline">UpdateLCApplicationCommand</strong> command, it is unclear what changed. This can result in a spurious notification being sent to at least one department because of this lack of clarity in the process.</p>
			<p>Since most work happens in the form of specific tasks, it can work to our advantage if our processes and, by extension, our APIs mirror these behaviors.</p>
			<p>Keeping this in mind, let’s re-examine our revised APIs for the LC application process:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B16716_Figure_6.3.jpg" alt="Figure 6.3 – Revised commands&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Revised commands</p>
			<p>While it may have appeared previously that we have simply converted our coarse-grained APIs to become more fine-grained, this, in reality, is a better representation of the tasks that the user intended to perform. So, in essence, task-based APIs are the decomposition of work in a manner that aligns more closely to the users’ intents. With our new APIs, product validation can commence as soon as <strong class="source-inline">ChangeMerchandise</strong> happens. Also, it is unambiguously clear what the user did and what needs to happen in reaction<a id="_idIndexMarker382"/> to the user’s action. It then begs the question of whether we should employ<a id="_idIndexMarker383"/> task-based APIs all the time. Let’s look at the implications in more detail.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Task-based or CRUD-based?</h2>
			<p>CRUD-based APIs seem to operate<a id="_idIndexMarker384"/> at the level of the aggregate. In our example, we have the LC aggregate. In the simplest case, this essentially translates to four operations aligned with each of the CRUD verbs. However, as we are seeing, even in our simplified version, the LC is becoming a fairly complex concept. Having to work<a id="_idIndexMarker385"/> with just four operations at the level of the LC is cognitively complex. With more<a id="_idIndexMarker386"/> requirements, this complexity will only continue to increase. For example, consider a situation where the business expresses a need to capture a lot more information about <strong class="source-inline">merchandise</strong>, where today, this is simply captured in the form of free-form text. A more elaborate version of merchandise information is shown here:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/ch6-3.jpg" alt=""/>
				</div>
			</div>
			<p>In our current design, the implications of this change are far-reaching for both the provider and the consumer(s). Let’s look at some of the consequences in more detail:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B16716_06_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>In our current design, the implications of this change are far-reaching for both the provider and the consumer(s). Let’s look at some of the consequences in more detail.</p>
			<p>As we can see, the decision<a id="_idIndexMarker387"/> between CRUD-based and task-based interfaces<a id="_idIndexMarker388"/> is nuanced. We are not suggesting that you should choose one over the other. Which style you use will depend on your specific requirements and context. In our experience, task-based interfaces treat user intents as first-class citizens and perpetuate the spirit of DDD’s ubiquitous language very elegantly. Our preference is to design interfaces as task-based where possible because they result in more intuitive interfaces that better express the problem domain.</p>
			<p>As systems evolve, and they begin to support richer user experiences and multiple channels, the CRUD-based interface seems to require additional translation layers to cater to user experience needs. The visual here depicts a typical layered architecture of a solution that supports multiple-user experience channels:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B16716_Figure_6.4.jpg" alt="Figure 6.4 – Layered architecture supporting multiple-user experience channels&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Layered architecture supporting multiple-user experience channels</p>
			<p>This setup is usually composed of the following:</p>
			<ul>
				<li>A domain tier comprised of CRUD-based services that simply map closely to database entities</li>
				<li>A composite tier comprised of business capabilities that span more than one core service</li>
				<li>A <strong class="bold">Backend for Frontend</strong> (<strong class="bold">BFF</strong>) tier, comprised of channel-specific<a id="_idIndexMarker389"/> APIs</li>
			</ul>
			<p>Note that the composite and BFF tiers exist primarily as a means to map backend capabilities to user intent. In an ideal world, where backend APIs reflect user intent closely, the need for translations<a id="_idIndexMarker390"/> should be minimal (if at all). Our experience suggests<a id="_idIndexMarker391"/> that such a setup causes business logic to get pushed closer to the user channels as opposed to being encapsulated within the confines of well-factored business services. In addition, these tiers cause inconsistent experiences across channels for the same functionality, given that modern teams are structured along tier boundaries.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We are not opposed to the use of layered architectures. We recognize that a layered architecture can bring modularity, separation of concerns, and other related benefits. However, we are opposed to creating additional tiers merely as a means to compensate for poorly factored core domain APIs.</p>
			<p>A well-factored API tier can have<a id="_idIndexMarker392"/> a profound effect on how great user experiences<a id="_idIndexMarker393"/> are built. However, this is a chapter on implementing the user interface. Let’s revert to creating the user interface for the LC application.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Bootstrapping the UI</h1>
			<p>We will simply be building the UI for the LC application<a id="_idIndexMarker394"/> we created in <a href="B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 5</em></a>, <em class="italic">Implementing Domain Logic</em>. For detailed instructions, refer to the <em class="italic">Bootstrapping the application</em> section. In addition, we will need to add the following dependencies to the <strong class="source-inline">dependencies</strong> section of the Maven <strong class="source-inline">pom.xml</strong> file in the root directory of the project:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/ch6-4.jpg" alt=""/>
				</div>
			</div>
			<p>To run UI tests, you will need<a id="_idIndexMarker395"/> to add the following dependencies:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/ch6-5.jpg" alt=""/>
				</div>
			</div>
			<p>To be able to run the application from the command<a id="_idIndexMarker396"/> line, you will need to add <strong class="source-inline">javafx-maven-plugin</strong> to the <strong class="source-inline">plugins</strong> section of your <strong class="source-inline">pom.xml</strong> file, per the following:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/ch6-6.jpg" alt=""/>
				</div>
			</div>
			<p>To run the application from<a id="_idIndexMarker397"/> the command line, use the following:</p>
			<pre class="source-code">mvn javafx:run</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you are using a JDK greater than version 1.8, the JavaFX libraries may not be bundled with the JDK itself. When running the application from your IDE, you will likely need to add the following:</p>
			<p class="callout"><strong class="source-inline">--module-path=&lt;path-to-javafx-sdk&gt;/lib/ \</strong></p>
			<p class="callout"><strong class="source-inline">--add-modules=javafx.controls,javafx.graphics,</strong></p>
			<p class="callout"><strong class="source-inline">javafx.fxml,javafx.media</strong></p>
			<p>We are making use of the mvvmFX framework to assemble the UI. To make this work with Spring Boot, the application launcher looks as depicted here:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/ch6-7.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We are required to extend from the <strong class="source-inline">MvvmfxSpringApplication</strong> mvvmFX framework class.</p>
			<p>Please refer to the <strong class="source-inline">ch06</strong> directory<a id="_idIndexMarker398"/> of the accompanying source code repository for the complete example.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Implementing the UI</h1>
			<p>When working<a id="_idIndexMarker399"/> with user interfaces, it is fairly customary to use one of these presentation patterns:</p>
			<ul>
				<li><strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>)</li>
				<li><strong class="bold">Model View Presenter</strong> (<strong class="bold">MVP</strong>)</li>
				<li><strong class="bold">Model View View Model</strong> (<strong class="bold">MVVM</strong>)</li>
			</ul>
			<p>The MVC pattern<a id="_idIndexMarker400"/> has been around for the longest time. The idea of separating<a id="_idIndexMarker401"/> concerns among collaborating model, view, and controller objects is a sound one. However, beyond the definition of these objects, actual implementations seem to vary wildly – with the controller becoming overly complex in a lot of cases. In contrast, MVP and MVVM, while being derivatives of MVC, seem to bring about a better separation of concerns between the collaborating objects. MVVM, in particular<a id="_idIndexMarker402"/> when coupled with data-binding constructs, makes for code that is much more readable, maintainable, and testable. In this book, we make use of MVVM because it enables test-driven development, which is a strong personal preference for us. Let’s look at a quick MVVM primer, as implemented in the mvvmFX framework.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>MVVM primer</h2>
			<p>Modern UI frameworks<a id="_idIndexMarker403"/> started adopting a declarative style to express the view. MVVM was designed to remove all GUI code (code-behind) from the view by making use of binding expressions. This allowed for a cleaner separation of stylistic versus programming concerns. A high-level visual of how this pattern is implemented is shown here:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B16716_Figure_6.6.jpg" alt="Figure 6.5 – MVVM design pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – MVVM design pattern</p>
			<p>The pattern comprises<a id="_idIndexMarker404"/> the following components:</p>
			<ul>
				<li><strong class="bold">Model</strong>: Responsible for housing the business logic and managing the state of the application.</li>
				<li><strong class="bold">View</strong>: Responsible for presenting data to the user and notifying the view-model about user interactions through the view delegate.</li>
				<li><strong class="bold">View Delegate</strong>: Responsible for keeping the view and the view-model in sync as changes are made by the user or on the view-model. It is also responsible for transmitting actions performed on the view to the view-model.</li>
				<li><strong class="bold">View-Model</strong>: Responsible for handling user interactions on behalf of the view. The view-model interacts with the view using the observer pattern (typically, one-way or two-way<a id="_idIndexMarker405"/> data binding to make it more convenient). The view-model interacts with the model for updates and read operations.</li>
			</ul>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Creating a new LC</h2>
			<p>Let’s consider the example<a id="_idIndexMarker406"/> of creating a new LC. To start the creation of a new LC, all we need is for the applicant to provide a friendly client reference. This is an easy-to-remember string of free text. A simple rendition of this UI is shown here:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B16716_Figure_6.7.jpg" alt="Figure 6.7 – Start LC creation screen&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Start LC creation screen</p>
			<p>Let’s examine the implementation and purpose of each component in more detail.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Declarative view</h2>
			<p>When working with JavaFX, the view<a id="_idIndexMarker407"/> can be rendered using a declarative style in FXML format. Important excerpts from the <strong class="source-inline">StartLCView.fxml</strong> file to start creating a new LC are shown here:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/ch6-8.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">The <strong class="source-inline">StartLCView</strong> class acts as the view delegate for the FXML view and is assigned using the <strong class="source-inline">fx:controller</strong> attribute of the root element (<strong class="source-inline">javafx.scene.layout.Pane</strong>, in this case).</li>
				<li>In order to reference the <strong class="source-inline">client-reference</strong> input field in the view delegate, we use the <strong class="source-inline">fx:id</strong> annotation (<strong class="source-inline">clientReference</strong>, in this case).</li>
				<li>Similarly, the start button is referenced using "<strong class="source-inline">fx:id=startButton"</strong> in the view delegate. Furthermore, the <strong class="source-inline">start</strong> method <a id="_idIndexMarker408"/>in the view delegate is assigned to handle the default action (the button press event for <strong class="source-inline">javafx.scene.control.Button</strong>).</li>
			</ol>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>View delegate</h2>
			<p>Next, let’s look<a id="_idIndexMarker409"/> at the structure of the <strong class="source-inline">com.premonition.lc.issuance.ui.views.StartLCView</strong> view delegate:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/ch6-9.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">This is the view delegate class for the <strong class="source-inline">StartLCView.fxml</strong> view.</li>
				<li>This is the Java binding for the <strong class="source-inline">clientReference</strong> textbox in the view. The name of the member needs to match exactly with the value of the <strong class="source-inline">fx:id</strong> attribute in the view. Further, it needs to be annotated with the <strong class="source-inline">@javafx.fxml.FXML</strong> annotation. The use of the <strong class="source-inline">@FXML</strong> annotation is optional if the member in the view delegate is public and matches the name in the view.</li>
				<li>Similarly, <strong class="source-inline">startButton</strong> is bound to the corresponding button widget in the view.</li>
				<li>This is the method<a id="_idIndexMarker410"/> for the action handler when <strong class="source-inline">startButton</strong> is pressed.</li>
			</ol>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>View-model</h2>
			<p>The <strong class="source-inline">StartLCViewModel</strong> view-model<a id="_idIndexMarker411"/> class for <strong class="source-inline">StartLCView</strong> is shown here:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/ch6-10.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">This is the view-model class for <strong class="source-inline">StartLCView</strong>. Note that we are required to implement the <strong class="source-inline">de.saxsys.mvvmfx.ViewModel</strong> interface provided by the mvvmFX framework.</li>
				<li>We are initializing the <strong class="source-inline">clientReference</strong> property using <strong class="source-inline">SimpleStringProperty</strong> provided by JavaFX. There are several other property classes to define<a id="_idIndexMarker412"/> more complex types. Please refer to the JavaFX documentation for more details.</li>
				<li>This is the value of <strong class="source-inline">clientReference</strong> in the view-model. We will look at how to associate this with the value of the <strong class="source-inline">clientReference</strong> textbox in the view shortly. Note that we are using <strong class="source-inline">StringProperty</strong> provided by JavaFX, which provides access to the underlying string value of the client reference.</li>
				<li>JavaFX beans are required<a id="_idIndexMarker413"/> to create a special accessor for the property itself in addition to the standard getter and setter for the underlying value.</li>
			</ol>
			<h3>Binding the view to the view-model</h3>
			<p>Next, let’s look at how to associate<a id="_idIndexMarker414"/> the view to the view-model:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/ch6-11.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">The <strong class="source-inline">mvvmFX</strong> framework requires that the <strong class="source-inline">view delegate</strong> implement the <strong class="source-inline">FXMLView&lt;?</strong> <strong class="source-inline">extends</strong> <strong class="source-inline">ViewModelType&gt;</strong>. In this case, the view-model type is <strong class="source-inline">StartLCViewModel</strong>. The <strong class="source-inline">mvvmFX</strong> framework supports other view types as well. Please refer to the framework documentation for more details.</li>
				<li>The framework provides a <strong class="source-inline">@de.saxsys.mvvmfx.InjectViewModel</strong> annotation to allow dependency, injecting the view-model into the view delegate.</li>
				<li>The framework<a id="_idIndexMarker415"/> will invoke all methods annotated with the <strong class="source-inline">@de.saxsys.mvvmfx.Initialize</strong> annotation during the initialization process. The annotation can be omitted if the method is named <strong class="source-inline">initialize</strong> and is declared public. Please refer to the framework documentation for more details.</li>
				<li>We have now bound the text property of the <strong class="source-inline">clientReference</strong> textbox in the view delegate to the corresponding property in the view-model. Note that this is a bidirectional binding, which means that the value in the view and the view-model are kept in sync if it changes on either side.</li>
				<li>This is another variation of binding in action, where we are making use of a unidirectional binding. Here, we are binding the disabled property of the start button to the corresponding property on the view-model. We will look at why we need<a id="_idIndexMarker416"/> to do this shortly.</li>
			</ol>
			<h3>Enforcing business validations in the UI</h3>
			<p>We have a business validation<a id="_idIndexMarker417"/> that the client reference for an LC needs to be at least<a id="_idIndexMarker418"/> four characters in length. This will be enforced on the backend. However, to provide a richer user experience, we will also enforce this validation on the UI.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This may feel contrary to the notion of centralizing business validations on the backend. While<a id="_idIndexMarker419"/> this may be a noble attempt at implementing the <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>) principle, in reality, it poses a lot of practical problems. Distributed systems expert Udi Dahan has a very interesting take on why this may not be such a virtuous thing to pursue. Ted Neward also talks about this in his blog, entitled <em class="italic">The Fallacies of Enterprise Computing</em>.</p>
			<p>The advantage of using MVVM is that this logic is easily testable in a simple unit test of the view-model. Let’s see this in action now:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/ch6-12.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let’s look at the implementation<a id="_idIndexMarker420"/> for this functionality<a id="_idIndexMarker421"/> in the view-model:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/ch6-13.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We declare a <strong class="source-inline">startDisabled</strong> property in the view-model to manage when the start button should be disabled.</li>
				<li>The minimum<a id="_idIndexMarker422"/> length for a valid client reference<a id="_idIndexMarker423"/> is injected into the view-model. It is conceivable that this value will be provided as part of the external configuration, or possibly from the backend.</li>
				<li>We create a binding expression to match the business requirement.</li>
				<li>We bind the view-model property to the disabled property of the start button in the view delegate.</li>
			</ol>
			<p>Let’s also look at how to write an end-to-end, headless UI test, as shown here:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/ch6-14.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We have written a convenience <strong class="source-inline">@UITest</strong> extension to combine the Spring Framework and TestFX testing. Please<a id="_idIndexMarker424"/> refer to the accompanying source code with the book<a id="_idIndexMarker425"/> for more details.</li>
				<li>We set up the Spring context to act as the dependency injection provider for the mvvmFX framework and its injection annotations (for example, <strong class="source-inline">@InjectViewModel</strong>) to work.</li>
				<li>We are using the <strong class="source-inline">@Start</strong> annotation provided by the TestFX framework to launch the UI.</li>
				<li>The TestFX framework injects an instance of the FxRobot UI helper, which we can use to access UI elements.</li>
				<li>We are using the TestFX framework-provided convenience-matchers for test assertions.</li>
			</ol>
			<p>Now, when we run the application, we can see that the start button is enabled when a valid client reference is entered:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B16716_Figure_6.8.jpg" alt="Figure 6.8 – The start button is enabled with a valid client reference&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The start button is enabled with a valid client reference</p>
			<p>Now that we have<a id="_idIndexMarker426"/> the start button enabling correctly, let’s implement<a id="_idIndexMarker427"/> the actual creation of the LC itself by invoking the backend API.</p>
			<h3>Integrating with the backend</h3>
			<p>LC creation is a complex<a id="_idIndexMarker428"/> process, requiring information about a variety of items as evidenced when we decomposed the LC creation process. In this section, we will integrate the UI with the command to start the creation of a new LC. This happens when we press the <strong class="bold">Start</strong> button on the <strong class="bold">Start LC</strong> creation screen. The revised <strong class="source-inline">StartNewLCApplicationCommand</strong> looks as shown here:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/ch6-15.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">To start a new LC application, we need <strong class="source-inline">applicantId</strong> and <strong class="source-inline">clientReference</strong>.</li>
			</ol>
			<p>Given that we are using<a id="_idIndexMarker429"/> the MVVM pattern, the code to invoke the backend service is part of the view-model. Let’s test-drive this functionality:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/ch6-16.jpg" alt=""/>
				</div>
			</div>
			<p>The view-model is enhanced<a id="_idIndexMarker430"/> accordingly to inject an instance of <strong class="source-inline">BackendService</strong> and looks as shown here:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/ch6-17.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let’s test to actually make<a id="_idIndexMarker431"/> sure that the backend gets invoked only when a valid client reference is input:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/ch6-18.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We set the logged-in user. </li>
				<li>When the client reference is blank, there should be no interactions with the backend service.</li>
				<li>When a valid value for the client reference is entered, the backend should be invoked with the entered value.</li>
			</ol>
			<p>The implementation<a id="_idIndexMarker432"/> to make this test pass looks like this:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/ch6-19.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We check that the start button is enabled before invoking the backend.</li>
				<li>These are the actual backend calls with the appropriate values.</li>
			</ol>
			<p>Now, let’s look at how<a id="_idIndexMarker433"/> to integrate the backend call from the view. We test this in a UI test, as shown here:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/ch6-20.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We inject a mock instance of the backend service.</li>
				<li>We stub the call to the backend to return successfully.</li>
				<li>We type<a id="_idIndexMarker434"/> in a valid value for the client reference.</li>
				<li>We click on the <strong class="bold">Start</strong> button.</li>
				<li>We verify that the service was indeed invoked with the correct arguments.</li>
				<li>We verify that we have moved to the next screen in the UI (the LC details screen).</li>
			</ol>
			<p>Let’s also look<a id="_idIndexMarker435"/> at what happens when the service invocation fails in another test:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/ch6-21.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We stub the backend service call to fail with an exception.</li>
				<li>We verify that we continue to remain on <strong class="source-inline">start-lc-screen</strong>.</li>
			</ol>
			<p>The view implementation for this functionality is shown here:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/ch6-22.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">JavaFX, like<a id="_idIndexMarker436"/> most frontend frameworks, is single-threaded and requires that long-running tasks not be invoked on the UI thread. For this purpose, it provides the <strong class="source-inline">javafx.concurrent.Service</strong> abstraction to handle such interactions elegantly in a background thread.</li>
				<li>The actual invocation of the backend through the view-model happens here.</li>
				<li>We show the next screen to enter more LC details here.</li>
			</ol>
			<p>Finally, the service implementation itself is shown here:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/ch6-23.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We inject <strong class="source-inline">org.axonframework.commandhandling.gateway.CommandGateway</strong> provided by Axon Framework to invoke the command.</li>
				<li>The actual invocation<a id="_idIndexMarker437"/> of the backend using the <strong class="source-inline">sendAndWait</strong> method happens here. In this case, we are blocking until the backend call completes. There are other variations that do not require this kind of blocking. Please refer to the Axon Framework documentation for more details.</li>
			</ol>
			<p>We have now seen a complete example of how to implement the UI and invoke the backend API.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Summary</h1>
			<p>In this chapter, we looked at the nuances of API styles and clarified why it is very important to design APIs that capture the users’ intent closely. We looked at the differences between CRUD-based and task-based APIs. Finally, we implemented the UI making use of the MVVM design pattern and demonstrated how it aids in test-driving frontend functionality.</p>
			<p>Now that we have implemented the creation of a new LC, for implementing the subsequent commands we will require access to an existing LC. In the next chapter, we will look at how to implement the query side and how to keep it in sync with the command side.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Further reading</h1>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B16716_06_Table_02.jpg" alt=""/>
				</div>
			</div>
		</div>
	</body></html>