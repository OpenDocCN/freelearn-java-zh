<html><head></head><body>
<div id="_idContainer048">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.2.1">Securing Your Spring Boot Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to an important stage in your Spring Boot learning journey. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we focus on security: a crucial aspect that will help you protect your applications against evolving digital threats. </span><span class="koboSpan" id="kobo.3.3">Here, you’ll learn how to implement strong security with Spring Boot 3.0, which </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.4.1">includes</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.5.1"> techniques using </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Open Authorization 2.0</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">OAuth2</span></strong><span class="koboSpan" id="kobo.9.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">JSON Web Token</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">JWT</span></strong><span class="koboSpan" id="kobo.13.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Role-Based Access Control</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">RBAC</span></strong><span class="koboSpan" id="kobo.17.1">). </span><span class="koboSpan" id="kobo.17.2">We shall </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.18.1">also go into the details of how to secure a </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">reactive application.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">You will learn how to authenticate users using OAuth2 and manage secure tokens using JWT. </span><span class="koboSpan" id="kobo.20.2">You will also master RBAC, whose job is to provide the right access to the right users. </span><span class="koboSpan" id="kobo.20.3">We even have a dedicated section just for reactive developers who want to be assured that their reactive apps are at least as secure as their standard </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">web apps.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Why does this matter? </span><span class="koboSpan" id="kobo.22.2">In our digital world, security is not a feature; it’s a way of life. </span><span class="koboSpan" id="kobo.22.3">The concepts you are going to be a master of with this will help you to craft applications that are safe and trustworthy, protecting your data and the identity </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">of users.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">In the end, you will have a secure, running sample application that implements all the security principles mentioned. </span><span class="koboSpan" id="kobo.24.2">Ready to make your applications safe and sound? </span><span class="koboSpan" id="kobo.24.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">dig in!</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">Introducing security in Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Boot 3.0</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Implementing OAuth2 </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">and JWT</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Implementing RBAC in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Spring Boot</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Securing </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">reactive applications</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">Let’s begin this journey to make your Spring Boot applications secure </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">and robust!</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.38.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.39.1">For this chapter, our local machines will need </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.41.1">Java Development Kit</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.43.1">JDK</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">) 17</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">A modern </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Integrated Development Environment</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">IDE</span></strong><span class="koboSpan" id="kobo.49.1">); I recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">IntelliJ IDEA</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">GitHub repository</span></strong><span class="koboSpan" id="kobo.52.1">: You can clone all repositories related to </span><a href="B18400_05.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.54.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">here: </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0"><span class="No-Break"><span class="koboSpan" id="kobo.56.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.57.1">Docker Desktop</span></span></li>
</ul>
<h1 id="_idParaDest-120"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.58.1">Introducing security in Spring Boot 3.0</span></h1>
<p><span class="koboSpan" id="kobo.59.1">In this chapter, we will </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.60.1">delve into the aspect of security in Spring Boot 3.0. </span><span class="koboSpan" id="kobo.60.2">Security is not a checkbox; it is an important ingredient for building any application. </span><span class="koboSpan" id="kobo.60.3">Here, we will cover security features that come integrated out of the box and are provided by Spring Boot, to secure our application from scratch. </span><span class="koboSpan" id="kobo.60.4">Now, let’s have a look at how all these features can be customized and extended to best serve our needs, ensuring that we implement not only a functional application but also a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">secure one.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Firstly, let’s explore Spring Boot’s security architecture, which has been built to be robust and flexible. </span><span class="koboSpan" id="kobo.62.2">You will see how Spring Boot makes it easy to secure your application, with some sensible defaults out of the box, but also the ability to customize them for more advanced use cases. </span><span class="koboSpan" id="kobo.62.3">By the end of this chapter, you will realize why security is so important, and what tools Spring Boot 3.0 provides to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">effective security.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.64.1">Exploring Spring Boot 3.0’s security features</span></h2>
<p><span class="koboSpan" id="kobo.65.1">As we’re starting to </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.66.1">build any kind of web application, the very first thing that comes to mind is to ensure that they are secure. </span><span class="koboSpan" id="kobo.66.2">Here, Spring Boot 3.0 comes with all the powerful utilities to secure our applications. </span><span class="koboSpan" id="kobo.66.3">In this section, we will dig into how we make a security architecture in Spring Boot 3.0 that helps us achieve that, ensuring that our web apps are safe </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">and sound.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The best thing about Spring Boot is that it’s really easy to set up security. </span><span class="koboSpan" id="kobo.68.2">It is based on Spring Security, a framework for securing everything. </span><span class="koboSpan" id="kobo.68.3">Think of Spring Security as a vigilant security guard who checks for every ID at the door; this way, it ensures that access to particular parts of your application is granted to only those who have the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">right permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The following are some of the most important</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.71.1"> security features of Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">Boot 3.0:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Configuring security in our application</span></strong><span class="koboSpan" id="kobo.74.1">: Setting up the security for your application with Spring Boot 3.0 is like configuring settings on your mobile device. </span><span class="koboSpan" id="kobo.74.2">You get to decide what you want on and what to turn off. </span><span class="koboSpan" id="kobo.74.3">Spring Boot allows us to very easily define who can access what in our application. </span><span class="koboSpan" id="kobo.74.4">We do this with a simple yet powerful configuration within </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">our code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Authenticating users</span></strong><span class="koboSpan" id="kobo.77.1">: At its most basic, authentication is how we verify who a person is. </span><span class="koboSpan" id="kobo.77.2">Spring Boot 3.0 helps with this. </span><span class="koboSpan" id="kobo.77.3">It can be through a username and password, through tokens, or in some other way, and Spring Security is there to help you. </span><span class="koboSpan" id="kobo.77.4">It is very much like having a bouncer at the door of your app, making sure only authorized users are able to </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">get in.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Authorization</span></strong><span class="koboSpan" id="kobo.80.1">: Upon identification of who a person is, one has to define what the person is allowed to do. </span><span class="koboSpan" id="kobo.80.2">Spring Security lets us set up rules for what authenticated users are allowed to access. </span><span class="koboSpan" id="kobo.80.3">It’s like giving out keys to different doors in your app, based on who needs to go where. </span><span class="koboSpan" id="kobo.80.4">As you can see, while authentication is verifying the identity of the user, authorization determines what resources and actions the user </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">is permitted.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Defense against common threats</span></strong><span class="koboSpan" id="kobo.83.1">: The internet can be like a jungle with different kinds of threats hiding in it. </span><span class="koboSpan" id="kobo.83.2">The security architecture of Spring Boot 3.0 is designed to protect against these threats. </span><span class="koboSpan" id="kobo.83.3">From </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">Cross-Site Scripting</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">XSS</span></strong><span class="koboSpan" id="kobo.87.1">) to SQL injection, Spring</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.88.1"> Security helps protect your application against commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">known vulnerabilities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Leveraging advanced security features</span></strong><span class="koboSpan" id="kobo.91.1">: Getting deeper into it, Spring Boot 3.0 provides yet another advanced security feature set. </span><span class="koboSpan" id="kobo.91.2">It adds OAuth2 for securing access to APIs</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.92.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">JSON Web Tokens</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">JWTs</span></strong><span class="koboSpan" id="kobo.96.1">) for stateless authentication. </span><span class="koboSpan" id="kobo.96.2">It’s like adding an advanced security system to your application, like cameras</span><a id="_idIndexMarker350"/> <span class="No-Break"><span class="koboSpan" id="kobo.97.1">and detectors.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.98.1">By now, we have understood and applied the security architecture of Spring Boot 3.0, and we are in a position to develop robust and secure applications. </span><span class="koboSpan" id="kobo.98.2">We have seen the basics—from authentication and authorization to protecting against threats, including advanced features. </span><span class="koboSpan" id="kobo.98.3">It’s all about ensuring that our applications are safe places for our users to visit and </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">engage with.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">This section showed that Spring Boot 3.0 has a strong set of features under its security domain, built to keep our applications safe. </span><span class="koboSpan" id="kobo.100.2">Remember that security is an ongoing process. </span><span class="koboSpan" id="kobo.100.3">Continuously monitoring and updating is the way to go. </span><span class="koboSpan" id="kobo.100.4">The steps of continuously monitoring and updating our measures for security are described in this chapter. </span><span class="koboSpan" id="kobo.100.5">This approach ensures our applications remain secure over time, adapting to new challenges as </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">they arise.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">In this section, we have learned about Spring Boot 3.0’s basic security features. </span><span class="koboSpan" id="kobo.102.2">In the next section, we will start to look at the code for implementing Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">Boot security.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.104.1">Setting up a basic security configuration</span></h2>
<p><span class="koboSpan" id="kobo.105.1">Let’s walk through setting up a</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.106.1"> basic security configuration, ensuring your app is protected right from the start. </span><span class="koboSpan" id="kobo.106.2">The following guided walk-through will show you how to introduce the security layer to our sample book store application, making it a safe space for users and </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">data alike:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">Adding Spring security dependencies</span></strong><span class="koboSpan" id="kobo.109.1">: First up, we need to add Spring Security to our project. </span><span class="koboSpan" id="kobo.109.2">As we’re using Gradle, we should include the following in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
implementation 'org.springframework.boot:spring-boot-starter-security'</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.113.1">Now we have added all the necessary libraries to </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">our project.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Configuring web security</span></strong><span class="koboSpan" id="kobo.116.1">: Next, we’ll create a basic security </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">configuration class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz -&gt; authz
                        .requestMatchers("/login").permitAll()
                        .anyRequest().authenticated()
                )
                .httpBasic(Customizer.withDefaults());
        return http.build();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.119.1">This code </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.120.1">blocks all requests except the /</span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">login</span></strong><span class="koboSpan" id="kobo.122.1"> endpoint in our current book store implementation as we don’t have that endpoint yet. </span><span class="koboSpan" id="kobo.122.2">So, all other endpoints will be authenticated by this configuration. </span><span class="koboSpan" id="kobo.122.3">You can check it by executing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">curl</span></strong><span class="koboSpan" id="kobo.124.1"> request </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">like this:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.126.1">curl -v GET --location "http://localhost:8080/books"</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.127.1">You will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">DENY</span></strong><span class="koboSpan" id="kobo.129.1"> response from this request because we have hidden the endpoints behind </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">Spring Security.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.131.1">Let’s </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.132.1">understand what we have introduced with this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> class:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">@Configuration</span></strong><span class="koboSpan" id="kobo.136.1">: This annotation marks the class as a source of Bean definitions for the application context. </span><span class="koboSpan" id="kobo.136.2">It tells Spring that this class contains </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">configuration information.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">@EnableWebSecurity</span></strong><span class="koboSpan" id="kobo.139.1">: This annotation enables Spring Security’s web security support and provides the Spring MVC integration. </span><span class="koboSpan" id="kobo.139.2">It signals to the Spring Framework to start adding </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">security configurations.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">@Bean</span></strong><span class="koboSpan" id="kobo.142.1">: This annotation tells Spring that the method will return an object that should be registered as a bean in the Spring application context. </span><span class="koboSpan" id="kobo.142.2">In this case, it’s the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">SecurityFilterChain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1"> bean.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">public SecurityFilterChain securityFilterChain(HttpSecurity http)</span></strong><span class="koboSpan" id="kobo.146.1">: This method defines the security filter chain. </span><span class="koboSpan" id="kobo.146.2">It takes an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">HttpSecurity</span></strong><span class="koboSpan" id="kobo.148.1"> as a parameter, allowing you to configure web-based security for specific </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">HTTP requests.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">.csrf(AbstractHttpConfigurer::disable)</span></strong><span class="koboSpan" id="kobo.151.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">Cross-Site Request Forgery</span></strong><span class="koboSpan" id="kobo.153.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.154.1">CSRF</span></strong><span class="koboSpan" id="kobo.155.1">) protection is disabled in this configuration. </span><span class="koboSpan" id="kobo.155.2">CSRF protection is a security</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.156.1"> feature that prevents malicious websites from performing unauthorized actions on behalf of authenticated users. </span><span class="koboSpan" id="kobo.156.2">For this reason, disabling CSRF may be appropriate for APIs or applications that are only accessed by other applications, not by </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">browsers directly.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">.sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span></strong><span class="koboSpan" id="kobo.159.1">: This configures the session creation policy to be stateless. </span><span class="koboSpan" id="kobo.159.2">In a stateless API, no session information is stored on the server between requests. </span><span class="koboSpan" id="kobo.159.3">This is typical for REST APIs, where each request is independent and authentication is done via tokens, </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">not cookies.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">.authorizeHttpRequests(authz -&gt; authz</span></strong><span class="koboSpan" id="kobo.162.1">: This part starts the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">authorization configuration.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">.requestMatchers("/login").permitAll()</span></strong><span class="koboSpan" id="kobo.165.1">: This line specifies that requests matching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">/login</span></strong><span class="koboSpan" id="kobo.167.1"> pattern should be allowed without authentication. </span><span class="koboSpan" id="kobo.167.2">It’s a way to define public endpoints within </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">your application.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">.anyRequest().authenticated()</span></strong><span class="koboSpan" id="kobo.170.1">: This ensures that any request not matched by previous matchers must be authenticated. </span><span class="koboSpan" id="kobo.170.2">It’s a catch-all that secures the rest of the application </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">by default.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">.httpBasic(Customizer.withDefaults())</span></strong><span class="koboSpan" id="kobo.173.1">: Enables HTTP Basic authentication. </span><span class="koboSpan" id="kobo.173.2">This is a simple, stateless authentication mechanism that allows a client to send a username and password with each request. </span><span class="koboSpan" id="kobo.173.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Customizer.withDefaults()</span></strong><span class="koboSpan" id="kobo.175.1"> part applies default configurations for HTTP Basic, making </span><a id="_idIndexMarker355"/><span class="No-Break"><span class="koboSpan" id="kobo.176.1">setup straightforward.</span></span></li></ul></li> </ol>
<p><span class="koboSpan" id="kobo.177.1">This code basically sets up a security filter chain that in effect disables CSRF protection and is perfect for stateless applications. </span><span class="koboSpan" id="kobo.177.2">It provides for the REST API’s required stateless session management and allows access only on a few URLs (such as through </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">/login</span></strong><span class="koboSpan" id="kobo.179.1">) as public. </span><span class="koboSpan" id="kobo.179.2">For all other URLs, it enforces to authenticate thorough authentication via HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">Basic authentication.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">In this section, you have learned how to put a basic security setup in place for your Spring Boot application. </span><span class="koboSpan" id="kobo.181.2">But our investigation into security is not </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">yet complete.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">By knowing and implementing these basic security configurations, you are making serious steps toward the creation of secure and trusted applications. </span><span class="koboSpan" id="kobo.183.2">Always keep in mind that a secure application does not only mean the protection of data but trusting your users in relation to </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the application.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.185.1">Implementing OAuth2 and JWT</span></h1>
<p><span class="koboSpan" id="kobo.186.1">Moving on with the topic of application security, we will now discuss some of the more advanced mechanisms that cater to a changing environment. </span><span class="koboSpan" id="kobo.186.2">This brings us to two important technologies: OAuth2 and JWT. </span><span class="koboSpan" id="kobo.186.3">Both of them are critical players in improving security configurations for modern applications; however, both have different roles and complement each other to achieve the overall bigger picture of secure authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">and authorization.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">In subsequent sections, we provide details of how to set up OAuth2 for Keycloak. </span><span class="koboSpan" id="kobo.188.2">We detail the configuration of OAuth2 for Keycloak, followed by the required code snippets. </span><span class="koboSpan" id="kobo.188.3">We will use Keycloak, an open source platform with full support for OAuth2 off-the-shelf protocols and extensive abilities to be customized, to </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.189.1">provide </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">Identity and Access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.191.1">Management</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.193.1">IAM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">).</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.195.1">Configuring OAuth2 with Keycloak</span></h2>
<p><span class="koboSpan" id="kobo.196.1">Going a step further into the</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.197.1"> realm of advanced</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.198.1"> security, one of the key steps in increasing the security of your application is the configuration of OAuth2. </span><span class="koboSpan" id="kobo.198.2">We are going to use Keycloak for IAM. </span><span class="koboSpan" id="kobo.198.3">We chose Keycloak because it is open source, and its setup process is very easy. </span><span class="koboSpan" id="kobo.198.4">It is a tool to simplify complexities in the security process with regard to our applications. </span><span class="koboSpan" id="kobo.198.5">It includes built-in support for OAuth2, therefore making everything that pertains to the management of user identity and the protection of user access to your applications easier. </span><span class="koboSpan" id="kobo.198.6">Think of Keycloak as a kind of gatekeeper who already knows your users well and ensures that only those who have the right permission can access certain parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Let’s start our step-by-step implementation. </span><span class="koboSpan" id="kobo.200.2">We will use Docker Compose to run Keycloak besides our PostgreSQL and MongoDB setup together. </span><span class="koboSpan" id="kobo.200.3">We will update our current </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.202.1"> file as follows. </span><span class="koboSpan" id="kobo.202.2">You can also find it in the GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml"><span class="No-Break"><span class="koboSpan" id="kobo.204.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-5-implementing-oauth2-jwt/docker-compose.yml</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.205.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
version: '3.1'
services:
  db:
    image: postgres
    restart: always
    environment:
      POSTGRES_PASSWORD: yourpassword
      POSTGRES_DB: bookstore
    ports:
      - "5432:5432"
  mongodb:
    image: mongo
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_DATABASE: bookstore
  keycloak_db:
    image: postgres
    restart: always
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: keycloakpassword
    ports:
      - "5433:5432"
  keycloak:
    image: bitnami/keycloak:latest
    restart: always
    environment:
      KEYCLOAK_USER: admin
      KEYCLOAK_PASSWORD: admin
      DB_VENDOR: POSTGRES
      DB_ADDR: keycloak_db
      DB_PORT: 5432
      DB_DATABASE: keycloak
      DB_USER: keycloak
      DB_PASSWORD: keycloakpassword
    ports:
      - "8180:8080"
    depends_on:
      - keycloak_db</span></pre> <p><span class="koboSpan" id="kobo.207.1">We kept our </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.208.1">MongoDB and PostgreSQL </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.209.1">setup as it is and introduced two new images: </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">keycloak</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">Let’s break down the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">parameters here:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">Keycloak database</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">image: postgres</span></strong><span class="koboSpan" id="kobo.218.1">: Specifies the</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.219.1"> Docker image to use for the container. </span><span class="koboSpan" id="kobo.219.2">In this case, it’s using the official </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">PostgreSQL image.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">restart: always</span></strong><span class="koboSpan" id="kobo.222.1">: This setting ensures the container always restarts if it stops. </span><span class="koboSpan" id="kobo.222.2">If Docker restarts or the container exits for any reason, this setting will cause it to </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">be restarted.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">environment</span></strong><span class="koboSpan" id="kobo.225.1">: Defines environment variables for the container. </span><span class="koboSpan" id="kobo.225.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.227.1">, it sets the PostgreSQL database (</span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">POSTGRES_DB</span></strong><span class="koboSpan" id="kobo.229.1">) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">keycloak</span></strong><span class="koboSpan" id="kobo.231.1">, the database user (</span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">POSTGRES_USER</span></strong><span class="koboSpan" id="kobo.233.1">) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">keycloak</span></strong><span class="koboSpan" id="kobo.235.1">, and the user’s password (</span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">POSTGRES_PASSWORD</span></strong><span class="koboSpan" id="kobo.237.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">keycloakpassword</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">ports</span></strong><span class="koboSpan" id="kobo.242.1">: Maps </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.243.1">ports from</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.244.1"> the container to the host machine. </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">"5433:5432" </span></strong><span class="koboSpan" id="kobo.246.1">maps the default PostgreSQL port inside the container (</span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">5432</span></strong><span class="koboSpan" id="kobo.248.1">) to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">5433</span></strong><span class="koboSpan" id="kobo.250.1"> on the host. </span><span class="koboSpan" id="kobo.250.2">This allows you to connect to the database from the host machine using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">5433</span></strong><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">We are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">5433</span></strong><span class="koboSpan" id="kobo.254.1"> because we have already used </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">5432</span></strong><span class="koboSpan" id="kobo.256.1"> in the PostgreSQL database of </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">our application.</span></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">Keycloak service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">image: bitnami/keycloak:latest</span></strong><span class="koboSpan" id="kobo.261.1">: Specifies the Docker image for the Keycloak server, using </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.262.1">the latest version of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">bitnami/keycloak</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1"> image.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">restart: always</span></strong><span class="koboSpan" id="kobo.266.1">: Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.268.1">, ensures the Keycloak container is always restarted if it stops for </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">any reason.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">environment</span></strong><span class="koboSpan" id="kobo.271.1">: Sets environment variables specific to the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">Keycloak server:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">KEYCLOAK_USER</span></strong><span class="koboSpan" id="kobo.274.1">: The admin username for </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Keycloak (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">).</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">KEYCLOAK_PASSWORD</span></strong><span class="koboSpan" id="kobo.279.1">: The admin password for </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">Keycloak (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">).</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">DB_VENDOR</span></strong><span class="koboSpan" id="kobo.284.1">: Specifies the type of database being used (</span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">POSTGRES</span></strong><span class="koboSpan" id="kobo.286.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">this case).</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">DB_ADDR</span></strong><span class="koboSpan" id="kobo.289.1">: The address of the database container. </span><span class="koboSpan" id="kobo.289.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.291.1"> service name allows Keycloak to find the database within the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Docker network.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">DB_PORT</span></strong><span class="koboSpan" id="kobo.294.1">: The port on which the database is </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">listening (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">5432</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">).</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">DB_DATABASE</span></strong><span class="koboSpan" id="kobo.299.1">: The name of the database Keycloak should </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">use (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">keycloak</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">).</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">DB_USER</span></strong><span class="koboSpan" id="kobo.304.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">DB_PASSWORD</span></strong><span class="koboSpan" id="kobo.306.1">: The credentials Keycloak will use to connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the database.</span></span></li></ul></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">ports</span></strong><span class="koboSpan" id="kobo.309.1">: Maps the Keycloak server port from the container to the host machine. </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">"8180:8080"</span></strong><span class="koboSpan" id="kobo.311.1"> maps the internal port </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">8080</span></strong><span class="koboSpan" id="kobo.313.1"> (Keycloak’s default port) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">8180</span></strong><span class="koboSpan" id="kobo.315.1"> on the host. </span><span class="koboSpan" id="kobo.315.2">This allows you to access the Keycloak server from the host machine using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">8180</span></strong><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">We have changed the original port because our Spring Boot application is using </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">8080</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">.</span></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">depends_on</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.324.1">: Specifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">keycloak</span></strong><span class="koboSpan" id="kobo.326.1"> service depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.328.1"> service. </span><span class="koboSpan" id="kobo.328.2">Docker Compose will ensure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">keycloak_db</span></strong><span class="koboSpan" id="kobo.330.1"> is started </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">before </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">keycloak</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">.</span></span></li></ul></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.334.1">This setup provides a robust and straightforward way to deploy Keycloak with a PostgreSQL database using Docker Compose. </span><span class="koboSpan" id="kobo.334.2">By understanding these parameters, you can customize your setup to fit your specific needs, such as changing ports, database names, </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">or credentials.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">When we</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.337.1"> run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.339.1"> command </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.340.1">in our terminal in the directory of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.342.1"> file, our four services (PostgreSQL, MongoDB, PostgreSQL for Keycloak, and the Keycloak service) will be up and running in our local machine. </span><span class="koboSpan" id="kobo.342.2">In the next step, we will configure the Keycloak server according to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">our needs.</span></span></p>
<h3><span class="koboSpan" id="kobo.344.1">Configuring the Keycloak service</span></h3>
<p><span class="koboSpan" id="kobo.345.1">As we defined in the</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.346.1"> Docker Compose file, we now have the URL and port of the Keycloak server. </span><span class="koboSpan" id="kobo.346.2">Open a web browser and navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">http://localhost:8180/</span></strong><span class="koboSpan" id="kobo.348.1">. </span><span class="koboSpan" id="kobo.348.2">Log in with the admin credentials we set earlier in the Docker Compose file to access the Keycloak administration console. </span><span class="koboSpan" id="kobo.348.3">In our example, the username is </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">admin</span></strong><span class="koboSpan" id="kobo.350.1"> and the password is </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">admin</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">With the following steps, let us configure a </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">Keycloak service:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.354.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">a realm:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.356.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Add realm</span></strong><span class="koboSpan" id="kobo.358.1"> and name </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">BookStoreRealm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">.</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 5.1: Add realm screen" src="image/B18400_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 5.1: Add realm screen</span></p>
<ol>
<li class="upper-roman" value="2"><span class="No-Break"><span class="koboSpan" id="kobo.364.1">Click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.365.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></li>
</ol>
<ol>
<li value="2"><span class="koboSpan" id="kobo.367.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">a client:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.369.1">Inside your </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.370.1">realm, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Clients</span></strong><span class="koboSpan" id="kobo.372.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.374.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">.</span></span></li><li class="upper-roman"><span class="koboSpan" id="kobo.376.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">Client ID</span></strong><span class="koboSpan" id="kobo.378.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">bookstore-client</span></strong><span class="koboSpan" id="kobo.380.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Root URL</span></strong><span class="koboSpan" id="kobo.382.1"> to the URL of your Spring Boot application (for our application, it </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">is </span></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">http://localhost:8080</span></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">).</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 5.2: Client create screen" src="image/B18400_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 5.2: Client create screen</span></p>
<ol>
<li class="upper-roman" value="3"><span class="koboSpan" id="kobo.388.1">On the next screen, set client authentication to true and click the save button at the end of the client </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">creation flow.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.390.1">Under </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Credentials</span></strong><span class="koboSpan" id="kobo.392.1">, note the secret as you will need it for your application properties in the Spring Boot application in the </span><em class="italic"><span class="koboSpan" id="kobo.393.1">Configuring the book store application for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.394.1">OAuth2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> section.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.396.1"><img alt="Figure 5.3: Credentials of the client screen" src="image/B18400_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.397.1">Figure 5.3: Credentials of the client screen</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.398.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">a user:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.400.1">Navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">Users</span></strong><span class="koboSpan" id="kobo.402.1">, add a </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.403.1">user, and set up a password under the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.404.1">Credentials</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1"> tab.</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.406.1"><img alt="Figure 5.4: User Credentials screen" src="image/B18400_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.407.1">Figure 5.4: User Credentials screen</span></p>
<p><span class="koboSpan" id="kobo.408.1">Now, we will have a user with a username and password and the secret of our Keycloak client, which will be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">next section.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.410.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.411.1">Keycloak regularly undergoes updates and improvements, which may result in changes to the user interface. </span><span class="koboSpan" id="kobo.411.2">As a result, the UI might look different from the descriptions and screenshots provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.413.1">Configuring the book store application for OAuth2</span></h3>
<p><span class="koboSpan" id="kobo.414.1">We have a</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.415.1"> Keycloak server and it has been configured; now, we</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.416.1"> will need to configure our book store application so it can communicate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">Keycloak server:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.418.1">Add dependencies</span></strong><span class="koboSpan" id="kobo.419.1">: Ensure your Spring Boot project has the following dependencies in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.423.1">Configure </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">application.properties</span></strong><span class="koboSpan" id="kobo.425.1">: Add the following properties to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">application.properties</span></strong><span class="koboSpan" id="kobo.427.1"> file, replacing placeholders with your actual Keycloak and </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">client details:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.429.1">
spring.security.oauth2.client.registration.keycloak.client-id=bookstore-client
spring.security.oauth2.client.registration.keycloak.client-secret=&lt;Your-Client-Secret&gt;
spring.security.oauth2.client.registration.keycloak.client-name=Keycloak
spring.security.oauth2.client.registration.keycloak.provider=keycloak
spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/keycloak
spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.430.1">These </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.431.1">settings are used to configure </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.432.1">OAuth2 client registration and resource server properties for a Spring Boot application. </span><span class="koboSpan" id="kobo.432.2">They specifically configure the application to use Keycloak as the authentication provider. </span><span class="koboSpan" id="kobo.432.3">Let’s break down what each </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">setting means:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">spring.security.oauth2.client.registration.keycloak.client-id</span></strong><span class="koboSpan" id="kobo.435.1">: This is the unique identifier for the OAuth2 client registered in Keycloak. </span><span class="koboSpan" id="kobo.435.2">In our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">bookstore-client</span></strong><span class="koboSpan" id="kobo.437.1"> is the ID that represents our application in the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">Keycloak server.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">spring.security.oauth2.client.registration.keycloak.client-secret</span></strong><span class="koboSpan" id="kobo.440.1">: This secret is used to authenticate the client with the Keycloak server. </span><span class="koboSpan" id="kobo.440.2">It’s a confidential string known only to the application and the Keycloak server, acting as </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">a password.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">spring.security.oauth2.client.registration.keycloak.client-name</span></strong><span class="koboSpan" id="kobo.443.1">: A human-readable name for the client, which is Keycloak in </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">our configuration.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">spring.security.oauth2.client.registration.keycloak.provider</span></strong><span class="koboSpan" id="kobo.446.1">: Specifies the provider’s name for this client registration. </span><span class="koboSpan" id="kobo.446.2">It’s set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">keycloak</span></strong><span class="koboSpan" id="kobo.448.1">, linking this client registration to the Keycloak provider configured further down in the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">properties file.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">spring.security.oauth2.client.registration.keycloak.scope</span></strong><span class="koboSpan" id="kobo.451.1">: Defines the scope of the access request. </span><span class="koboSpan" id="kobo.451.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">openid</span></strong><span class="koboSpan" id="kobo.453.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">profile</span></strong><span class="koboSpan" id="kobo.455.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">email</span></strong><span class="koboSpan" id="kobo.457.1"> scopes indicate that the application is requesting ID tokens and access to the user’s profile and </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">email information.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">spring.security.oauth2.client.registration.keycloak.authorization-grant-type</span></strong><span class="koboSpan" id="kobo.460.1">: Specifies the OAuth2 flow to be used. </span><span class="koboSpan" id="kobo.460.2">Here, it’s set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">authorization_code</span></strong><span class="koboSpan" id="kobo.462.1">, which is a secure and common method for obtaining access and </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">refresh tokens.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">spring.security.oauth2.client.registration.keycloak.redirect-uri</span></strong><span class="koboSpan" id="kobo.465.1">: This is the URI to which the user is redirected after logging in or out. </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">{baseUrl}</span></strong><span class="koboSpan" id="kobo.467.1"> is a placeholder that Spring Security replaces with the application’s base URL, ensuring that the redirect URI matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">application’s domain.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">spring.security.oauth2.client.provider.keycloak.issuer-uri</span></strong><span class="koboSpan" id="kobo.470.1">: This URL points to the Keycloak issuer URI for the realm you’re using (</span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">BookStoreRealm</span></strong><span class="koboSpan" id="kobo.472.1">), typically the base URL for Keycloak plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">/auth/realms/{realm-name}</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">It tells the Spring Boot application where to find the Keycloak server for </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">this realm.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">spring.security.oauth2.resourceserver.jwt.issuer-uri</span></strong><span class="koboSpan" id="kobo.477.1">: Similar to the provider issuer URI, this setting configures the issuer URI for the JWT issuer. </span><span class="koboSpan" id="kobo.477.2">It is used by the resource server (your application) to validate JWTs. </span><span class="koboSpan" id="kobo.477.3">The</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.478.1"> issuer URI must match</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.479.1"> the issuer declared in the JWT for the token to be </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">considered valid.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.481.1">These settings wire our Spring Boot application to authenticate using Keycloak, specifying how our application should register with Keycloak, what scopes it requests, and how to validate tokens issued </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">by Keycloak.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Update the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">SecurityConfig</span></strong><strong class="bold"><span class="koboSpan" id="kobo.485.1"> file</span></strong><span class="koboSpan" id="kobo.486.1">: We need to update the SecurityConfig file to use the OAuth2 login </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">with Keycloak:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.488.1">
 @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz -&gt; authz
                        .requestMatchers("/login").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()));
        return http.build();
    }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.489.1">Basically, in </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.490.1">this code, we have only changed </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.491.1">the last statement before </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1"> command.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">.oauth2ResourceServer(...)</span></strong><span class="koboSpan" id="kobo.495.1"> configures OAuth2 resource server support and </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">.jwt(Customizer.withDefaults())</span></strong><span class="koboSpan" id="kobo.497.1"> indicates that the resource server expects JWTs </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">for authentication.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.499.1">The latter uses the default JWT decoder configuration, which is suitable for most scenarios. </span><span class="koboSpan" id="kobo.499.2">This line is essential for integrating with OAuth2, where the application acts as a resource server that </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">validates JWTs.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.501.1">Also, we have excluded the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">/login</span></strong><span class="koboSpan" id="kobo.503.1"> endpoint from being secured because this endpoint should be public so that users can get credentials. </span><span class="koboSpan" id="kobo.503.2">This brings us to introducing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">LoginController</span></strong><span class="koboSpan" id="kobo.505.1"> class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">login</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1"> endpoint.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.509.1">Introduce the /</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">login</span></strong><strong class="bold"><span class="koboSpan" id="kobo.511.1"> endpoint</span></strong><span class="koboSpan" id="kobo.512.1">: We will need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">LoginRequestDto</span></strong><span class="koboSpan" id="kobo.514.1"> class, which will be used as a body object for this </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">POST</span></strong><span class="koboSpan" id="kobo.516.1"> endpoint, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">LoginController</span></strong><span class="koboSpan" id="kobo.518.1"> class. </span><span class="koboSpan" id="kobo.518.2">Let’s write them as </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">shown next.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.520.1">This is the data</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.521.1"> transfer object from the </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.522.1">client to the server. </span><span class="koboSpan" id="kobo.522.2">This object contains login credentials for the user created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">Keycloak server:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.524.1">
public record LoginRequestDto(String username, String password) {}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.525.1">Also, we need one more configuration file to introduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">RestTemplate</span></strong><span class="koboSpan" id="kobo.527.1"> bean. </span><span class="koboSpan" id="kobo.527.2">We will use it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">LoginController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1"> class:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.530.1">@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.531.1">This is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">LoginController</span></strong><span class="koboSpan" id="kobo.533.1"> class for introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">/login</span></strong><span class="koboSpan" id="kobo.535.1"> endpoint to </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">our application:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.537.1">@RestController
public class LoginController {
    @Value("${spring.security.oauth2.client.registration.keycloak.client-id}")
    private String clientId;
@Value("${spring.security.oauth2.client.registration.keycloak.client-secret}")
    private String clientSecret;
@Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri}")
    private String baseUrl;
    @PostMapping("/login")
    public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequestDto loginRequestDto) {
        String tokenUrl = baseUrl + "/protocol/openid-connect/token";
        // Prepare the request body
        MultiValueMap&lt;String, String&gt; requestBody = new LinkedMultiValueMap&lt;&gt;();
        requestBody.add("client_id", clientId);
        requestBody.add("username", loginRequestDto.username());
        requestBody.add("password", loginRequestDto.password());
        requestBody.add("grant_type", "password");
        requestBody.add("client_secret", clientSecret);
        // Use RestTemplate to send the request
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(tokenUrl, requestBody, String.class);
        // Return the response from Keycloak
        return ResponseEntity.ok(response.getBody());
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.538.1">Let’s understand what this controller does when the user sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">POST</span></strong><span class="koboSpan" id="kobo.540.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">login</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1"> endpoint.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.544.1">This is the</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.545.1"> first time we are using </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.546.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">@Value</span></strong><span class="koboSpan" id="kobo.548.1"> annotation of Spring Boot. </span><span class="koboSpan" id="kobo.548.2">This annotation injects property values into fields. </span><span class="koboSpan" id="kobo.548.3">Here, it’s used to inject the Keycloak client ID, client secret, and URL of the Keycloak server from the application’s properties file into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">clientId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1"> variable.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.551.1">Our application basically gets the username and password of the user from the request body and prepares a REST call to the Keycloak server with the parameters in the application properties file. </span><span class="koboSpan" id="kobo.551.2">It gets the response from the Keycloak server and returns the response to the user. </span><span class="koboSpan" id="kobo.551.3">In order to demonstrate what it does, please see the following figure, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.552.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.553.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">.</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.555.1"><img alt="Figure 5.5: User login process with Keycloak server" src="image/B18400_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.556.1">Figure 5.5: User login process with Keycloak server</span></p>
<p><span class="koboSpan" id="kobo.557.1">As shown in</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.558.1"> the diagram, the user makes a call. </span><span class="koboSpan" id="kobo.558.2">Our </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.559.1">application prepares the requests, makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">POST</span></strong><span class="koboSpan" id="kobo.561.1"> call to the Keycloak API, and returns the response to the user. </span><span class="koboSpan" id="kobo.561.2">We will use this access token in our calls to our application. </span><span class="koboSpan" id="kobo.561.3">We will test this out in the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">next section.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.563.1">Testing our endpoints with an access token</span></h2>
<p><span class="koboSpan" id="kobo.564.1">Let’s run our application. </span><span class="koboSpan" id="kobo.564.2">As you’ll </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.565.1">remember, in our previous tests, we </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.566.1">received the HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">403 Forbidden</span></strong><span class="koboSpan" id="kobo.568.1"> message from our application. </span><span class="koboSpan" id="kobo.568.2">Now we will test it after we get the access token from the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">login process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
curl --location "http://localhost:8080/login"
--header "Content-Type: application/json"
--data "{
    \"username\":&lt;username&gt;,
    \"password\":&lt;password&gt;
}"</span></pre> <p><span class="koboSpan" id="kobo.571.1">Please </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.572.1">change the username and password values to those of the</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.573.1"> user you have created in the Keycloak server. </span><span class="koboSpan" id="kobo.573.2">You will get a response like </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
{
    "access_token": &lt;JWT Token&gt;
    "expires_in": 300,
    "refresh_expires_in": 1800,
    "refresh_token": &lt;JWT Token&gt;,
    "token_type": "Bearer",
    "not-before-policy": 0,
    "session_state": "043d9823-7ef4-4778-b746-10dd8e75baa4",
    "scope": "email profile"
}</span></pre> <p><span class="koboSpan" id="kobo.576.1">I haven’t put the exact JWT here since it is a huge alphanumeric value. </span><span class="koboSpan" id="kobo.576.2">Let’s explain what these </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">values are:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">access_token</span></strong><span class="koboSpan" id="kobo.579.1">: This is a JWT that the client application can use to access protected resources by passing it in the authorization header of HTTP requests. </span><span class="koboSpan" id="kobo.579.2">It is encoded and contains claims (or assertions) about the authentication and authorization of the user. </span><span class="koboSpan" id="kobo.579.3">The token itself is opaque to the client but can be decoded and verified by the resource server (or any party with the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">appropriate key).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">expires_in</span></strong><span class="koboSpan" id="kobo.582.1">: Specifies the lifetime of the access token in seconds. </span><span class="koboSpan" id="kobo.582.2">After this time, the access token will no longer be valid for accessing protected resources. </span><span class="koboSpan" id="kobo.582.3">In this example, the access token expires in </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">300</span></strong><span class="koboSpan" id="kobo.584.1"> seconds (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1"> minutes).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">refresh_expires_in</span></strong><span class="koboSpan" id="kobo.588.1">: Indicates the lifetime of the refresh token in seconds. </span><span class="koboSpan" id="kobo.588.2">The refresh token can be used to obtain a new access token when the current access token expires. </span><span class="koboSpan" id="kobo.588.3">Here, it is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">1800</span></strong><span class="koboSpan" id="kobo.590.1"> seconds (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1"> minutes).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">refresh_token</span></strong><span class="koboSpan" id="kobo.594.1">: This is another JWT, similar to the access token but used solely for obtaining new access tokens without requiring the user to log in again. </span><span class="koboSpan" id="kobo.594.2">It has a longer validity period than the access token and should be </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">stored securely.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">token_type</span></strong><span class="koboSpan" id="kobo.597.1">: Specifies the type of token issued. </span><span class="koboSpan" id="kobo.597.2">In OAuth2, this is typically </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Bearer</span></strong><span class="koboSpan" id="kobo.599.1">, which means that the bearer of this token is authorized to access the resources. </span><span class="koboSpan" id="kobo.599.2">The client application should use this token type when constructing the authorization header for </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">HTTP requests.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">not-before-policy</span></strong><span class="koboSpan" id="kobo.602.1">: This field is specific to Keycloak and similar authorization servers. </span><span class="koboSpan" id="kobo.602.2">It indicates a policy or timestamp before which the token should not be considered valid. </span><span class="koboSpan" id="kobo.602.3">A value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">0</span></strong><span class="koboSpan" id="kobo.604.1"> typically means the token is valid immediately </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">upon issuance.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">session_state</span></strong><span class="koboSpan" id="kobo.607.1">: A unique identifier for the user session that the token is associated with. </span><span class="koboSpan" id="kobo.607.2">This can be used by the application for session management or </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">tracking purposes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">scope</span></strong><span class="koboSpan" id="kobo.610.1">: Specifies</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.611.1"> the scope of the access requested. </span><span class="koboSpan" id="kobo.611.2">Scopes </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.612.1">are space-delimited and indicate what access rights the application has been granted. </span><span class="koboSpan" id="kobo.612.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">email profile</span></strong><span class="koboSpan" id="kobo.614.1"> means the application can access the user’s email address and </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">profile information.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.616.1">Now, we will use this access token and use it in the header of </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">our requests:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.618.1">
curl --location "http://localhost:8080/books"
--header "Authorization: Bearer &lt;access_token&gt;"</span></pre> <p><span class="koboSpan" id="kobo.619.1">We will get a list of books as a response. </span><span class="koboSpan" id="kobo.619.2">You can also use the same token to make requests for the other endpoints. </span><span class="koboSpan" id="kobo.619.3">After </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">5</span></strong><span class="koboSpan" id="kobo.621.1"> minutes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">300</span></strong><span class="koboSpan" id="kobo.623.1"> seconds), the access token will expire, and we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">/login</span></strong><span class="koboSpan" id="kobo.625.1"> endpoint one more time to gather a new </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">access token.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">We have finally come to the end of this section. </span><span class="koboSpan" id="kobo.627.2">We ran the Keycloak server locally and defined a new realm, client, and user. </span><span class="koboSpan" id="kobo.627.3">Later, we configured our Spring Boot application to communicate with the Keycloak server. </span><span class="koboSpan" id="kobo.627.4">After all these configurations and implementations, we could gather an access token with our username and password and get a valid response from our </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">protected endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">In the next section, we will learn how to define a role and filter the role of the request by role; this is an important step to protect our endpoints with </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">role-based security.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.631.1">Implementing RBAC in Spring Boot</span></h1>
<p><span class="koboSpan" id="kobo.632.1">Making sure that users</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.633.1"> only get access to</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.634.1"> the resources that they are entitled to is of paramount importance in the landscape of modern web development. </span><span class="koboSpan" id="kobo.634.2">This is where RBAC comes in. </span><span class="koboSpan" id="kobo.634.3">Imagine setting up a series of gates within your application, each requiring a specific key that only certain users possess. </span><span class="koboSpan" id="kobo.634.4">This is the essence of RBAC—ensuring that access is granted based on the roles assigned to a user, enhancing both security </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">and usability.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Why prioritize RBAC in your Spring Boot application with Keycloak? </span><span class="koboSpan" id="kobo.636.2">Well, first of all, it simplifies the complex task of access management, making it easier for developers to define and enforce security policies. </span><span class="koboSpan" id="kobo.636.3">This allows your applications to tap into Keycloak’s great support for OAuth2 and provides a very structured, scalable way to secure endpoints. </span><span class="koboSpan" id="kobo.636.4">This will make your application more secure and its features clearer when it comes to controlling access to a user. </span><span class="koboSpan" id="kobo.636.5">As we delve more into setting up RBAC with Keycloak, remember that this isn’t about restriction per se; it is more about seamless and secure experiences for your user, meaning they get the right tools and permissions to navigate through your application with efficacy. </span><span class="koboSpan" id="kobo.636.6">Let’s embark on this journey of bringing out the full potential of role-based security within our Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">Boot applications.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.638.1">Defining roles and permissions in Keycloak</span></h2>
<p><span class="koboSpan" id="kobo.639.1">Defining roles and permissions</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.640.1"> in Keycloak is important for establishing secure applications that offer the management of user access in a very streamlined manner. </span><span class="koboSpan" id="kobo.640.2">Through this process, you will be able to specifically outline what a certain user can perform and thus enhance security and productivity in the system. </span><span class="koboSpan" id="kobo.640.3">Here’s a straightforward guide to setting up roles and permissions in Keycloak, along with insights into what kind of configuration this brings about in terms of your security </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">and management:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.642.1">First, log in to the Keycloak Admin Console (</span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">http://localhost:8180</span></strong><span class="koboSpan" id="kobo.644.1">) using your administrator credentials. </span><span class="koboSpan" id="kobo.644.2">This is our control panel for managing realms, users, roles, </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">and permissions.</span></span></li>
<li><span class="koboSpan" id="kobo.646.1">Navigate to </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.647.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">Roles</span></strong><span class="koboSpan" id="kobo.649.1"> section—select the realm you wish to configure from the drop-down menu, then click on </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">Roles</span></strong><span class="koboSpan" id="kobo.651.1"> in the left-hand menu. </span><span class="koboSpan" id="kobo.651.2">Here, you’ll see a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">existing roles.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.653.1"><img alt="Figure 5.6: Add Role screen" src="image/B18400_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.654.1">Figure 5.6: Add Role screen</span></p>
<ol>
<li class="upper-roman"><strong class="bold"><span class="koboSpan" id="kobo.655.1">Add roles</span></strong><span class="koboSpan" id="kobo.656.1">: Click on </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Add Role</span></strong><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">Enter a name for the user role and a description that helps you identify the role’s purpose within </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">your application.</span></span></li>
<li class="upper-roman"><strong class="bold"><span class="koboSpan" id="kobo.660.1">Save</span></strong><span class="koboSpan" id="kobo.661.1">: Click </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">Save</span></strong><span class="koboSpan" id="kobo.663.1">. </span><span class="koboSpan" id="kobo.663.2">You’ve now created a role that can be assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">to users.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.665.1">Add one more role </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">.</span></span></li>
</ol>
<ol>
<li value="3"><span class="koboSpan" id="kobo.669.1">Go to </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">Users</span></strong><span class="koboSpan" id="kobo.671.1">, select the user you created in the previous step and click on </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.672.1">Role Mappings</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.674.1"><img alt="Figure 5.7: Role Mappings screen of the user" src="image/B18400_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.675.1">Figure 5.7: Role Mappings screen of the user</span></p>
<ol>
<li class="upper-roman"><span class="koboSpan" id="kobo.676.1">Here, you can </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.677.1">assign the </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">User</span></strong><span class="koboSpan" id="kobo.679.1"> role to the user. </span><span class="koboSpan" id="kobo.679.2">Select the role and </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.681.1">Assign</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.683.1">Create a new user and assign the </span><strong class="bold"><span class="koboSpan" id="kobo.684.1">admin</span></strong><span class="koboSpan" id="kobo.685.1"> role to </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">this user.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.687.1">With the roles defined and assigned, let’s understand the process of including the roles we created in </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">the application.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.689.1">Tailoring the book store application for role-based access</span></h2>
<p><span class="koboSpan" id="kobo.690.1">Implementing</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.691.1"> RBAC in your Spring Boot book store application using Keycloak significantly enhances its security, ensuring that users can access only what they are permitted to according to their roles. </span><span class="koboSpan" id="kobo.691.2">This not only makes your application more secure by design but it also sets up a very solid framework for the management of user permissions. </span><span class="koboSpan" id="kobo.691.3">Let’s follow the steps to include this role-based setup in your application, wherein a new class—</span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">KeycloakRoleConverter</span></strong><span class="koboSpan" id="kobo.693.1">—is introduced and specific security configurations. </span><span class="koboSpan" id="kobo.693.2">The new class will be an adapter between roles from Keycloak and roles in Spring Security. </span><span class="koboSpan" id="kobo.693.3">Let’s learn step by step how to implement this structure into </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">our application:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.695.1">Update security configurations</span></strong><span class="koboSpan" id="kobo.696.1">: Start by defining the security filter chain in our Spring </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.697.1">Boot application. </span><span class="koboSpan" id="kobo.697.2">This involves specifying which endpoints require what level of authority. </span><span class="koboSpan" id="kobo.697.3">Here, we introduce two major changes: restricting </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">POST</span></strong><span class="koboSpan" id="kobo.699.1"> requests to </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">/books</span></strong><span class="koboSpan" id="kobo.701.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">/authors</span></strong><span class="koboSpan" id="kobo.703.1"> to users with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">ROLE_ADMIN </span></strong><span class="koboSpan" id="kobo.705.1">authority and configuring the OAuth2 resource server to use a custom JWT authentication converter. </span><span class="koboSpan" id="kobo.705.2">Open your security configuration class and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">securityFilterChain</span></strong><span class="koboSpan" id="kobo.707.1"> bean </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.709.1">
@EnableMethodSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -&gt; authz
                .requestMatchers("/login").permitAll()
                .requestMatchers(HttpMethod.POST, "/books", "/authors").hasAuthority("ROLE_ADMIN")
.requestMatchers(HttpMethod.GET, "/books/**","/reviews/**", "/authors/**", "/publishers/**").hasAnyAuthority("ROLE_USER","ROLE_ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(jwt -&gt; jwt.jwtAuthenticationConverter(new KeycloakRoleConverter())));
        return http.build();
    }
}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.710.1">Implement the</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.711.1">KeycloakRoleConverter</span></strong><strong class="bold"><span class="koboSpan" id="kobo.712.1"> class</span></strong><span class="koboSpan" id="kobo.713.1">: This class is pivotal as it translates Keycloak</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.714.1"> JWTs into Spring Security’s authentication structure. </span><span class="koboSpan" id="kobo.714.2">This custom converter extracts roles from the JWT and assigns them as authorities within the Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">Security context:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
public class KeycloakRoleConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        // Default converter for scopes/authorities
        JwtGrantedAuthoritiesConverter defaultAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        Collection&lt;GrantedAuthority&gt; defaultAuthorities = defaultAuthoritiesConverter.convert(jwt);
        // Extract realm_access roles and map them to GrantedAuthority objects
        Collection&lt;GrantedAuthority&gt; realmAccessRoles = extractRealmAccessRoles(jwt);
        // Combine authorities
        Set&lt;GrantedAuthority&gt; combinedAuthorities = new HashSet&lt;&gt;();
        combinedAuthorities.addAll(defaultAuthorities);
        combinedAuthorities.addAll(realmAccessRoles);
        return new AbstractAuthenticationToken(combinedAuthorities) {
            @Override
            public Object getCredentials() {
                return null;
            }
            @Override
            public Object getPrincipal() {
                return jwt.getSubject();
            }
        };
    }
    public static List&lt;GrantedAuthority&gt; extractRealmAccessRoles(Jwt jwt) {
        Map&lt;String, Object&gt; realmAccess = jwt.getClaimAsMap("realm_access");
        if (realmAccess == null) {
            return Collections.emptyList();
        }
        List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get("roles");
        if (roles == null) {
            return Collections.emptyList();
        }
        return roles.stream()
                .map(roleName -&gt; new SimpleGrantedAuthority("ROLE_" + roleName.toUpperCase()))
                .collect(Collectors.toList());
    }
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.717.1">We have introduced a class that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Converter</span></strong><span class="koboSpan" id="kobo.719.1"> interface to convert a JWT into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">AbstractAuthenticationToken</span></strong><span class="koboSpan" id="kobo.721.1"> class, a concept used in Spring Security for authentication</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.722.1"> information. </span><span class="koboSpan" id="kobo.722.2">With those changes made, our book store application now has a very secure and powerful RBAC system in place. </span><span class="koboSpan" id="kobo.722.3">It only lets an authenticated user with the right role do a certain action—this significantly increases the security and integrity of your application. </span><span class="koboSpan" id="kobo.722.4">Also, that setup is granular, and it affords the best control of user permissions and eases the management of access rights across </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">We can test our app now. </span><span class="koboSpan" id="kobo.724.2">When we log in using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">user</span></strong><span class="koboSpan" id="kobo.726.1"> role and make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">GET</span></strong><span class="koboSpan" id="kobo.728.1"> request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">/books</span></strong><span class="koboSpan" id="kobo.730.1">, we will get a successful response, but when we try to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">POST</span></strong><span class="koboSpan" id="kobo.732.1"> request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">/books</span></strong><span class="koboSpan" id="kobo.734.1"> and create a new book, the response will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">forbidden</span></strong><span class="koboSpan" id="kobo.736.1">. </span><span class="koboSpan" id="kobo.736.2">If we log in with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">admin</span></strong><span class="koboSpan" id="kobo.738.1"> role, we will always have success, in the case of a request having either </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">GET</span></strong><span class="koboSpan" id="kobo.740.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">POST</span></strong><span class="koboSpan" id="kobo.742.1">. </span><span class="koboSpan" id="kobo.742.2">Securing a foothold in this area of RBAC for our Spring Boot book store application will </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.743.1">open up a way for expanding the security architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">very favorably.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">The next section of our journey is into securing reactive applications. </span><span class="koboSpan" id="kobo.745.2">Moving forward, this chapter will address how all the principles of security, authentication, and authorization apply to a reactive context of programming. </span><span class="koboSpan" id="kobo.745.3">This will not only help us to gain an expanded scope of understanding the approaches to be utilized regarding security in practice but also equip us with the tools that will help us to offer adequate protection of our reactive applications. </span><span class="koboSpan" id="kobo.745.4">We will learn about the depths of reactive security to give our application the resilience needed to meet evolving </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">cyber threats.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">Securing </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">reactive applications</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">In the dynamic </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.750.1">landscape of software development, securing reactive applications brings with it a new set of challenges and opportunities. </span><span class="koboSpan" id="kobo.750.2">Having dived deeper into the world of reactive programming, now we need to tweak our security strategies to align with the non-blocking, event-driven nature of these applications. </span><span class="koboSpan" id="kobo.750.3">Reactive systems that are identified to handle a large number of concurrent data streams strongly call for a strong yet flexible security approach. </span><span class="koboSpan" id="kobo.750.4">This section will try to unfold the complications in securing reactive applications and will guide you through the essential steps and considerations in order to effectively protect your </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">reactive ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">We will look into how to use the reactive support provided by Spring Security to enable those security features without breaking the reactive principles, ensuring high responsiveness </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">and resilience.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">Transitioning to the reactive programming territory could mean a challenge in terms of security, especially with the full strength Spring Security has to offer. </span><span class="koboSpan" id="kobo.754.2">Implementing reactive security with Spring Security is actually about adapting classic security paradigms to work within this asynchronous, non-blocking model of a reactive application. </span><span class="koboSpan" id="kobo.754.3">That realignment could be described as a shift, not one of any technical change but one in how security processes interact with data flows and user requests. </span><span class="koboSpan" id="kobo.754.4">The security model is required to be functional in this environment, without seeking any compromises with the reactive principles or imposing bottlenecks </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">One of the</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.757.1"> key differences in securing reactive applications lies in the way authentication and authorization are done. </span><span class="koboSpan" id="kobo.757.2">Unlike traditional servlet-based applications where usually security contexts are tied to a thread-local, reactive security has to be able to handle this type of decoupled, stateless nature of reactive programming. </span><span class="koboSpan" id="kobo.757.3">Spring Security provides a reactive security context that gets scoped to the reactive stream, ensuring that decisions about security in a context-aware way are aligned with the flow of </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">In this series, when we look into the reactive part of Spring Security, we will see how to include them effectively within our applications for the reactive system’s security. </span><span class="koboSpan" id="kobo.759.2">This covers handling the reactive APIs offered by Spring Security, understanding who acts as a publisher for making security decisions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Mono</span></strong><span class="koboSpan" id="kobo.761.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Flux</span></strong><span class="koboSpan" id="kobo.763.1">), and making sure your application stays secure, reactive, and scalable. </span><span class="koboSpan" id="kobo.763.2">This guide, with practical examples and a step-by-step approach, will help you navigate the complexities of reactive security to ensure the application is not only secure but also performs and scales to the expectations laid down by the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">programming model.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">Let’s start implementing security into the reactive application. </span><span class="koboSpan" id="kobo.765.2">We will use the same project we developed in </span><a href="B18400_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.766.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.767.1">:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.768.1">Add dependencies</span></strong><span class="koboSpan" id="kobo.769.1">: Ensure your Spring Boot project has the following dependencies in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.771.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.772.1">
implementation 'org.springframework.security:spring-security-config'
implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.773.1">Configure </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">application.properties</span></strong><span class="koboSpan" id="kobo.775.1">: Add the following properties to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">application.properties</span></strong><span class="koboSpan" id="kobo.777.1"> file, replacing placeholders with your actual Keycloak and </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">client details:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.779.1">
spring.security.oauth2.client.registration.keycloak.client-id=bookstore-client
spring.security.oauth2.client.registration.keycloak.client-secret=&lt;Your-Client-Secret&gt;
spring.security.oauth2.client.registration.keycloak.client-name=Keycloak
spring.security.oauth2.client.registration.keycloak.provider=keycloak
spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/keycloak
spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.780.1">Define a </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">SecurityWebFilterChain</span></strong><span class="koboSpan" id="kobo.782.1"> class in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">SecurityConfig</span></strong><span class="koboSpan" id="kobo.784.1"> class to </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.785.1">specify authorization rules and set up the JWT converter for </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">role extraction:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
            .csrf(ServerHttpSecurity.CsrfSpec::disable)
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/login").permitAll()
                .pathMatchers(HttpMethod.POST, "/users").hasAuthority("ROLE_ADMIN")
                .pathMatchers(HttpMethod.GET, "/users/**").hasAnyAuthority("ROLE_ADMIN", "ROLE_USER")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2ResourceServer -&gt;
                oauth2ResourceServer.jwt(jwt -&gt;
                    jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
            );
        return http.build();
    }
    private Converter&lt;Jwt, ? </span><span class="koboSpan" id="kobo.787.2">extends Mono&lt;? </span><span class="koboSpan" id="kobo.787.3">extends AbstractAuthenticationToken&gt;&gt; jwtAuthenticationConverter() {
        ReactiveJwtAuthenticationConverter jwtConverter = new ReactiveJwtAuthenticationConverter();
        jwtConverter.setJwtGrantedAuthoritiesConverter(new KeycloakRoleConverter());
        return jwtConverter;
    }
}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.788.1">Define </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">KeycloakRoleConverter</span></strong><span class="koboSpan" id="kobo.790.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">KeycloakRoleConverter</span></strong><span class="koboSpan" id="kobo.792.1"> class is </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.793.1">essential for mapping Keycloak roles to Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">Security authorities:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.795.1">
public class KeycloakRoleConverter implements Converter&lt;Jwt, Flux&lt;GrantedAuthority&gt;&gt; {
    @Override
    public Flux&lt;GrantedAuthority&gt; convert(final Jwt jwt) {
        // Extracting roles from realm_access
        return Flux.fromIterable(getRolesFromToken(jwt))
                .map(roleName -&gt; "ROLE_" + roleName.toUpperCase()) // Prefixing role with ROLE_
                .map(SimpleGrantedAuthority::new);
    }
    private List&lt;String&gt; getRolesFromToken(Jwt jwt) {
        Map&lt;String, Object&gt; realmAccess = jwt.getClaimAsMap("realm_access");
        if (realmAccess == null) {
            return Collections.emptyList();
        }
        List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get("roles");
        if (roles == null) {
            return Collections.emptyList();
        }
        return roles;
    }
}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.796.1">Introduce the</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.797.1">token</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.798.1">endpoint</span></strong><span class="koboSpan" id="kobo.799.1">: Lastly, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">LoginController</span></strong><span class="koboSpan" id="kobo.801.1"> class to handle authentication requests, utilizing Keycloak’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">token</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1"> endpoint:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.804.1">
@RestController
public class LoginController {
    @Value("${spring.security.oauth2.client.registration.keycloak.client-id}")
    private String clientId;
    @Value("${spring.security.oauth2.client.registration.keycloak.client-secret}")
    private String clientSecret;
    @Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri}")
    private String baseUrl;
    @PostMapping("/login")
    public Mono&lt;ResponseEntity&lt;?&gt;&gt; login(@RequestBody LoginRequestDto loginRequestDto) {
        // URL for Keycloak token endpoint
        String tokenUrl = baseUrl + "/protocol/openid-connect/token";
        // Prepare the request body
        MultiValueMap&lt;String, String&gt; requestBody = new LinkedMultiValueMap&lt;&gt;();
        requestBody.add("client_id", clientId);
        requestBody.add("username", loginRequestDto.username());
        requestBody.add("password", loginRequestDto.password());
        requestBody.add("grant_type", "password");
        requestBody.add("client_secret", clientSecret);
        // Use RestTemplate to send the request
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(tokenUrl, requestBody, String.class);
        // Return the response from Keycloak
        return Mono.just(ResponseEntity.ok(response.getBody()));
    }
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.805.1">Now we’ve introduced role-based security filters into our reactive application. </span><span class="koboSpan" id="kobo.805.2">Almost everything is very similar to traditional applications, only the responses are in the reactive realm, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">Mono</span></strong><span class="koboSpan" id="kobo.807.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">Flux</span></strong><span class="koboSpan" id="kobo.809.1">. </span><span class="koboSpan" id="kobo.809.2">We can use our previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">curl</span></strong><span class="koboSpan" id="kobo.811.1"> scripts for the login to get an access token for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">user</span></strong><span class="koboSpan" id="kobo.813.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">admin</span></strong><span class="koboSpan" id="kobo.815.1"> roles, and we can test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">POST</span></strong><span class="koboSpan" id="kobo.817.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1"> endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">It means that integrating reactive security into a Spring Boot application requires deliberately configuring a sequence of custom implementations with Spring Security especially using OAuth2 with Keycloak. </span><span class="koboSpan" id="kobo.820.2">From the setup of dependencies and the configuration of properties to the security filter chain, ending in a custom role converter—every step has been described so that they can be followed to get a secure reactive environment for our book store application. </span><span class="koboSpan" id="kobo.820.3">This implementation not only leverages the non-blocking nature of reactive programming but also ensures that our application is secure and scalable for it to be able to handle the demand proficiently in a </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">reactive context.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.822.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.823.1">With this, we shall finish this chapter, which dealt with securing Spring Boot applications. </span><span class="koboSpan" id="kobo.823.2">We have now finished our journey through Spring Boot security by learning about the context and the toolsets that are required to secure our applications in an effective manner. </span><span class="koboSpan" id="kobo.823.3">Let’s summarize the key learnings from </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">this chapter:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.825.1">Understanding Spring Boot security</span></strong><span class="koboSpan" id="kobo.826.1">: We understood the need for securing our Spring Boot applications and the basic tenets of </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">Spring Security.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.828.1">Implementing with OAuth2</span></strong><span class="koboSpan" id="kobo.829.1">: We learned how to authenticate users using OAuth2 and manage secure tokens </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">using JWT.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.831.1">RBAC using Keycloak</span></strong><span class="koboSpan" id="kobo.832.1">: We showed in great detail how to configure Keycloak to manage roles and permissions in our system, thus enhancing the security structure of </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">our application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.834.1">Modified security configuration for reactive</span></strong><span class="koboSpan" id="kobo.835.1">: We elaborated on how security configurations are customized for the reactive programming model so that our applications can be both secure and capable at the </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">same time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.837.1">Reactive security with Spring Security implementation</span></strong><span class="koboSpan" id="kobo.838.1">: In order to implement security in a reactive environment, crucial differences and modifications are necessary. </span><span class="koboSpan" id="kobo.838.2">This chapter emphasized non-blocking and event-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">security mechanisms.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.840.1">This chapter gave a brief outline of what Spring Security is about. </span><span class="koboSpan" id="kobo.840.2">The next chapter, Advanced Testing Strategies, drills further into the Spring Boot ecosystem, this time getting into the depths of testing. </span><span class="koboSpan" id="kobo.840.3">The chapter will delve more into the differences between unit and integration testing, which will point out the challenges with testing reactive components, leading to a discussion of security features testing with a short introduction on the aspect of </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.842.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.843.1">TDD</span></strong><span class="koboSpan" id="kobo.844.1">) with Spring Boot 3.0. </span><span class="koboSpan" id="kobo.844.2">This progression from securing to testing our applications really underscores the comprehensive approach that needs to be taken for developing resilient, high-quality software ready to meet the demands of modern </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">application development.</span></span></p>
</div>
</body></html>