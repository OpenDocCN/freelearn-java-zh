<html><head></head><body><div class="book" title="Appendix&#xA0;A.&#xA0;JSF with HTML5, Resources, and Faces Flows" id="aid-2OM4A1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="appA" class="calibre1"/>Appendix A. JSF with HTML5, Resources, and Faces Flows</h1></div></div></div><p class="calibre7">This appendix contains a quick reference to the JSF library in two parts. The first part covers the reference material on the library, architecture resource library contracts, and internationalization configuration. The second part is dedicated to writing Faces Flows using the Java API.</p><div class="book" title="An HTML5 friendly markup"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec86" class="calibre1"/>An HTML5 friendly markup</h1></div></div></div><p class="calibre7">After Java EE 7 and the <a id="id1029" class="calibre1"/>release of JSF 2.2, the framework always renders the HTML5 document type: <code class="email">&lt;DOCTYPE html&gt;</code>. This is the default behavior for the modern digital websites. With the HTML5 support, developers can just write the content in a Facelets view (a <code class="email">*.xhtml</code> file) that is compatible with the rendering engines in a modern web browser.</p><p class="calibre7">JSF 2.2 provides two types of attributes for the HTML elements: <code class="email">pass-through</code> attributes and <code class="email">pass-through</code> elements.</p><div class="book" title="The pass-through attributes"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec115" class="calibre1"/>The pass-through attributes</h2></div></div></div><p class="calibre7">The <code class="email">pass-through</code> attributes<a id="id1030" class="calibre1"/> enable JSF to seamlessly<a id="id1031" class="calibre1"/> support the new and extended attributes that are defined by the HTML5. These attributes are applicable to the JSF HTML render kit custom tags such as <code class="email">&lt;h:inputText&gt;</code>. In order to use the <code class="email">pass-through</code> attributes, we will define a JSF namespace at the top of the Facelets view that references the <a id="id1032" class="calibre1"/>URL <a class="calibre1" href="http://xmlns.jcp.org/jsf/passthrough">http://xmlns.jcp.org/jsf/passthrough</a>.</p><p class="calibre7">Let's take an <a id="id1033" class="calibre1"/>example that uses the HTML5 attributes for a <a id="id1034" class="calibre1"/>placeholder text: </p><div class="informalexample"><pre class="programlisting">&lt;html 
      
      &gt;
...
  &lt;div class="form-group"&gt;
    &lt;label for="birthday" class="col-sm-3 control-label"&gt;
    Birthday &lt;/label&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText p:type="date"
       class="form-control" id="birthday"
       value="#{customerController.birthday}"
       p:placeholder="1977-10-25"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="email" class="col-sm-3 control-label"&gt;
    Email &lt;/label&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText p:type="email"
       class="form-control" id="email"
       value="#{customerController.email}"
       p:placeholder="yourname@yourserverhost.com"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;</pre></div><p class="calibre7">The <code class="email">pass-through</code> attribute in the preceding example is demarcated with the full namespace, <code class="email">p:placeholder</code> and <code class="email">p:type</code>. One input field annotates for the date format and the other for the e-mail address. The value of placeholder provides the customer/user with a visual hint about how to fill in the field. The JSF render kit will pass this attribute minus the XML namespace to the rendered tag output. The value of type overrides the default render kit setting.</p><p class="calibre7">Some JavaScript frameworks also rely on extended attributes such as AngularJS or certain JQuery plugins. JSF allows page content writers and interface developers to pass these values as attributes. The value of the pass-through attribute may be dynamic and can also be derived from an EL. We can thus write the following markup to validate for a secured loan amount:</p><div class="informalexample"><pre class="programlisting">  &lt;h:inputText p:type="range"
   class="form-control" id="loanAmount"
   value="#{customerController.loanAmount}"
   p:min="#{loanHelper.min}" 
   p:max="#{loanHelper.max}" p:step="#{loanHelper.step}"
   p:placeholder="Decimal number between {loanHelper.min} and {loanHelper.max}"/&gt;</pre></div><p class="calibre7">With the<a id="id1035" class="calibre1"/> preceding code extract, the <code class="email">pass-through</code> attribute <code class="email">p:type</code> as a range value causes the modern browsers to render a slider control instead <a id="id1036" class="calibre1"/>of a text control. There is a backing bean named <code class="email">loanHelper</code> that dynamically supplies the minimum, maximum, and step unit values to the control.</p></div><div class="book" title="The pass-through elements"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec116" class="calibre1"/>The pass-through elements</h2></div></div></div><p class="calibre7">The drawback of the <code class="email">pass-through</code> attributes is that they do not look at the standard HTML5 attributes<a id="id1037" class="calibre1"/> that are available in a modern web browser.  An <a id="id1038" class="calibre1"/>input field that is defined with a rapid UX markup such as <code class="email">&lt;h:inputText&gt;</code> is not directly viewable by a stakeholder client without a microservice already running in the background process.</p><p class="calibre7">To enable the <code class="email">pass-through</code> elements in our Facelets view, we must first define the JSF namespace <code class="email">http://xmns.jcp.org/jsf</code>. In order to trigger a <code class="email">pass-through</code> element, at least one of the<a id="id1039" class="calibre1"/> attributes of an HTML element must be in the namespace.</p><p class="calibre7">Let's see how this works in practice with a Facelets view:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      &gt;
  &lt;head jsf:id="head"&gt; ... &lt;/head&gt;
  &lt;body jsf:id="body"&gt;
    ...
    &lt;form jsf:id="vacationForm"&gt;
      ...
      &lt;input type="text" jsf:id="companyId"
          placeholder="Your company identity number"
          jsf:value="#{vacationController.companyNo}"/&gt;
      &lt;input type="text" jsf:id="lastName"
          placeholder="Enter last name"
          jsf:value="#{vacationController.name}"/&gt;
      ...
      &lt;button class="btn btn-primary"
        jsf:action="#{vacationController.makeRequest}"&gt;
        Make Vacation Request&lt;/button&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The HTML elements—<code class="email">head</code>, <code class="email">body</code>, <code class="email">form</code>, <code class="email">input</code>, and <code class="email">button</code>—have at least one JSF namespace attribute. JSF detects the attribute and adds a component to its rendering tree. The name of the element determines the type of the component that is added. So, the head element is in fact rendered by the equivalent of the <code class="email">&lt;h:head&gt;</code> custom tag, and the body element is also rendered by the equivalent JSF <code class="email">&lt;h:body&gt;</code> custom tag. The HTML input type is treated specially and rendered with <code class="email">&lt;h:inputText&gt;</code>. The <code class="email">id</code> and <code class="email">value</code> attribute are passed <a id="id1040" class="calibre1"/>with the JSF namespace. The placeholder <a id="id1041" class="calibre1"/>attributes are passed as normal attributes without the JSF namespace. They are surprisingly supplied and treated like <code class="email">pass-through</code> attributes!</p><p class="calibre7">We can add validation to what looks like normal HTML5 elements. Here is the code to ensure that the user enters at least six characters:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" jsf:id="companyId"
    placeholder="Your company identity number"
    jsf:value="#{vacationController.companyNo}"/&gt;
  &lt;f:validateLength minimum="6" /&gt;
&lt;/input&gt;</pre></div><p class="calibre7">We will insert <code class="email">&lt;f:validateLength&gt;</code> as the direct body content of the HTML input element. The HTML5 support ensures that the tag is translated as a JSF input component. The support also extends to the AJAX tags and library functions.</p></div></div></div>
<div class="book" title="Resource identifiers" id="aid-2PKKS1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec87" class="calibre1"/>Resource identifiers</h1></div></div></div><p class="calibre7">In JSF 2.0, a resource is an image, document, or some other digital asset. They are placed under the <code class="email">resources</code> folder at the web context folder. In a Gradle or Maven project, a particular resource<a id="id1042" class="calibre1"/> lives on the path, as shown:</p><div class="informalexample"><pre class="programlisting">src/main/webapp/resources/&lt;RESOURCE-IDENTIFIER&gt;</pre></div><p class="calibre7">A resource may also be stored in a JAR file under the <code class="email">WEB-INF/lib</code> folder:</p><div class="informalexample"><pre class="programlisting">src/main/webapp/WEB-INF/lib/&lt;SOME&gt;.jar</pre></div><p class="calibre7">If the resource is stored in a JAR file, it must be located in the <code class="email">META-INF</code> folder such that it can be located with the path:</p><div class="informalexample"><pre class="programlisting">META-INF/resources/&lt;RESOURCE-IDENTIFIER&gt;</pre></div><p class="calibre7">
<code class="email">RESOURCE-IDENTIFIER</code> can be further divided into separate paths. The widest case supports full internalization. The constituent parts are as follows:</p><div class="informalexample"><pre class="programlisting">&lt;RESOURCE-IDENTIFIER&gt; := 
  [ &lt;LOCALE-PREFIX&gt; / ] [ &lt;LIBRARY-NAME&gt; / ] 
  [ &lt;LIBRARY-VERSION&gt; / ]
  &lt;RESOURCE-NAME&gt; [ / &lt;RESOURCE-VERSION&gt; ]</pre></div><p class="calibre7">The subterms allow the resource identifiers to be easily identified and separated out.</p><p class="calibre7">The optional <code class="email">LOCALE-PREFIX</code> term represents a locale such as <code class="email">en_gb</code> (British English) or <code class="email">de</code> (Germany).</p><p class="calibre7">The optional <code class="email">LIBRARY-NAME</code> term specifies a library name. You can define the library name and use it in the JSF custom tags, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet library="default" name="styles/app.css" /&gt;
&lt;h:outputStylesheet library="admin" name="styles/app.css" /&gt;</pre></div><p class="calibre7">The preceding example retrieves an application style sheet that is appropriate to the library. This helps to distinguish the different parts of your digital application. The resource lookup may resolve to the following:</p><div class="informalexample"><pre class="programlisting">&lt;WEB-CONTEXT&gt;/resources/en/default/1_0/styles/app.css
&lt;WEB-CONTEXT&gt;src/main/webapp/resources/en/admin/1_0/styles/app.css</pre></div><p class="calibre7">These URLs map <a id="id1043" class="calibre1"/>to the following source file assets in a conventional project:</p><div class="informalexample"><pre class="programlisting">src/main/webapp/resources/en/default/1_0/styles/app.css
src/main/webapp/resources/en/admin/1_0/styles/app.css</pre></div><p class="calibre7">Developers do not specify the library version. Instead, the JSF Resource Lookup mechanism searches for the highest version files of the respective resources. The version number of the folder name must match the regex: <code class="email">\d_\d</code>. Therefore, the <code class="email">version</code> folder name <code class="email">2_0</code> is greater than <code class="email">1_5</code>, which in turn, is higher than <code class="email">1_0</code>.</p></div>
<div class="book" title="Resource Library Contracts" id="aid-2QJ5E1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec88" class="calibre1"/>Resource Library Contracts</h1></div></div></div><p class="calibre7">JSF 2.2 introduces the concept of Resource Library Contracts, which allows a digital developer to <a id="id1044" class="calibre1"/>organize a library of assets and templates in a reusable set of resources. A resource library contract must reside in the contracts directory folder in the application's web context root. In the standard Maven or Gradle build convention, this folder is <code class="email">src/main/webapp/contracts</code>. Each subfolder in the contracts folder represents a named resource contract.</p><p class="calibre7">The setup for the <a class="calibre1" title="Chapter 6. JSF Flows and Finesse" href="part0057.xhtml#aid-1MBG21">Chapter 6</a>, <span class="strong"><em class="calibre9">JSF Flows and Finesse</em></span> used a layout for the Resource Library Contracts, as follows:</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/default/</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/default/template.xhtml</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/default/styles/app.css</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/default/images/</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/victoria/</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/victoria/template.xhtml</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/victoria/styles/app.css</code>
</p><p class="calibre7">
<code class="email">/src/main/webapp/contracts/victoria/images/</code>
</p><p class="calibre7">Every contract must have at least one declared <code class="email">template.xhtml</code> file. A contract may have more than one template for its own customization. The declared template has at least one declared insertion point, which is defined as the <code class="email">&lt;ui:insert&gt;</code> tag. A template usually relies on the digital assets, and these are known as declared resources.</p><p class="calibre7">Contracts can be packaged in the JAR files for a customer's use. A resource library contract must be placed in the <code class="email">META-INF/contracts</code> folder of the JAR file. So, we could<a id="id1045" class="calibre1"/> repackage the flow examples in the following layout:</p><p class="calibre7">
<code class="email">META-INF/contracts/</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/default/javax.faces.contract.xml</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/default/template.xhtml</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/default/styles/app.css</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/default/images/</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/victoria/</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/victoria/javax.faces.contract.xml</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/victoria/template.xhtml</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/victoria/styles/app.css</code>
</p><p class="calibre7">
<code class="email">META-INF/contracts/victoria/images/</code>
</p><p class="calibre7">We will need to add an empty marker file to each contract, <code class="email">javax.faces.contract.xml</code>. The reference for this filename is found in the static <code class="email">string: javax.faces.application.ResourceHandler.RESOURCE_CONTRACT_XML</code>.</p></div>
<div class="book" title="A Faces servlet" id="aid-2RHM01"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec89" class="calibre1"/>A Faces servlet</h1></div></div></div><p class="calibre7">In JSF, FacesServlet acts as the front controller, is the conduit for all the requests, and also sends the response back to the client. This servlet is a subclass of <code class="email">javax.servlet.Servlet</code>.</p><p class="calibre7">A web browser <a id="id1046" class="calibre1"/>client sends an HTTP request to the servlet container. If it is a Faces request, then the servlet container invokes the <code class="email">service()</code> method of FacesServlet. The method hands over the processing of the request to a member instance <code class="email">javax.faces.lifecycle.LifeCycle</code> object. The method also creates a FacesContext instance. The <code class="email">LifeCycle</code> instance is responsible for the processing of a request to all of the JSF phases described in <a class="calibre1" title="Chapter 2. JavaServer Faces Lifecycle" href="part0025.xhtml#aid-NQU22">Chapter 2</a>, <span class="strong"><em class="calibre9">JavaServer Faces Lifecycle</em></span> and the rendering of the response.</p><div class="book" title="Reconfiguration of the resource paths"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec117" class="calibre1"/>Reconfiguration of the resource paths</h2></div></div></div><p class="calibre7">It is possible to change the path name of the resource lookup and contract folders as well by configuring <a id="id1047" class="calibre1"/>the web XML deployment descriptor. The constants are defined in the <code class="email">javax.faces.application.ResourceHandler</code> class. The <code class="email">WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME</code> string constant defines the resource directory property's name and <code class="email">WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME</code> defines the contract directory property.</p><p class="calibre7">We can redefine the JSF web application defaults with the following <code class="email">web.xml</code> settings:</p><div class="informalexample"><pre class="programlisting">&lt;web-app  ...&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;javax.faces.WEBAPP_RESOURCES_DIRECTORY&lt;/param-name&gt;
      &lt;param-value&gt;/myresources&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;javax.faces.WEBAPP_CONTRACTS_DIRECTORY&lt;/param-name&gt;
      &lt;param-value&gt;/mycontracts&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt; ...
&lt;/web-app&gt;</pre></div><p class="calibre7">We can specify the initial parameters on the Faces servlet in overriding the default configuration.</p></div><div class="book" title="A JSF-specific configuration"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec118" class="calibre1"/>A JSF-specific configuration</h2></div></div></div><p class="calibre7">The Faces servlet <a id="id1048" class="calibre1"/>understands several other configuration parameters. Here is a table of the possible parameter names. These are prefixed with <code class="email">javax.faces</code>:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Parameter name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">CONFIG_FILES</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1049" class="indexterm"/> specifies a comma-delimited list of the additional context related resource paths that are loaded automatically with <code class="literal">WEB-INF/faces-config.xml</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">DEFAULT_SUFFIX</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1050" class="indexterm"/>sets the suffix for the JSF files; the default is <code class="literal">*.xhtml</code>. If you change this configuration, then I recommend that you also change welcome-file-list in <code class="literal">web.xml</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">DISABLE_FACELET_JSF_VIEW_HANDLER</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">If this<a id="id1051" class="indexterm"/> parameter is set to <code class="literal">true</code>, then it disables Facelets as the default page declaration language. The default is <code class="literal">false</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">FACELETS_BUFFER_SIZE</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1052" class="indexterm"/>specifies the buffer size for a JSF response. The default size is <code class="literal">-1</code>, which means an unlimited size.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">FACELETS_REFRESH_PERIOD</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1053" class="indexterm"/>sets the interval time in seconds that the JSF compiler should check for changes. In the production mode, this value is set to <code class="literal">-1</code>, which means that the JSF compiler should not check; otherwise, the default is set to <code class="literal">2</code> in the reference implementation.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">FACELETS_SKIP_COMMENT</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1054" class="indexterm"/> is a Boolean value that determines if the XML comments in a Facelets view is included in a response. The default value is <code class="literal">true</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">FACELETS_LIBRARIES</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1055" class="indexterm"/> specifies a semicolon delimited list collection of the Facelets tag libraries by a path.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">LIFECYCLE_ID</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1056" class="indexterm"/>overrides the default implementation of the JSF <code class="literal">javax.faces.lifecycle.Lifecycle</code> instance.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">PROJECT_STAGE</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1057" class="indexterm"/> specifies the development project stage. The acceptable values are <code class="literal">Development</code>, <code class="literal">UnitTest</code>, <code class="literal">SystemTest</code>, or <code class="literal">Production</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">STATE_SAVING_METHOD</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1058" class="indexterm"/> specifies the location where a state is saved in a JSF application. The acceptable values are <code class="literal">client</code> and <code class="literal">server</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">WEBAPP_CONTRACTS_DIRECTORY</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1059" class="indexterm"/> overrides the default location of the JSF resource contracts. The default is <code class="literal">&lt;web-context&gt;/contracts</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">WEBAPP_RESOURCES_DIRECTORY</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1060" class="indexterm"/>overrides the default location of the JSF resources reserved for the digital assets. The default is <code class="literal">&lt;web-context&gt;/resources</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">These settings <a id="id1061" class="calibre1"/>are best configured in the web deployment descriptor file (<code class="email">web.xml</code>).</p></div></div>
<div class="book" title="Internationalization"><div class="book" id="aid-2SG6I2"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec90" class="calibre1"/>Internationalization</h1></div></div></div><p class="calibre7">A JSF application <a id="id1062" class="calibre1"/>can be internationalized with standard resource bundles (<code class="email">java.util.ResourceBundle</code>) and messages. Resource bundles are suitable to internationalize the text on the components, controls, and digital assets; whereas message files are meant to internationalize the JSF validation errors.</p><p class="calibre7">In a Gradle or Maven project, we will add a resource bundle or message file to the <code class="email">src/main/resources</code> project location with the necessary Java package as folders.</p><div class="book" title="Resource bundles"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec119" class="calibre1"/>Resource bundles</h2></div></div></div><p class="calibre7">We will<a id="id1063" class="calibre1"/> configure the resource bundles in the Faces <a id="id1064" class="calibre1"/>configuration file, <code class="email">/WEB-INF/faces-config.xml</code>, for the web application.</p><p class="calibre7">For the contact details application in <a class="calibre1" title="Chapter 4. JSF Validation and AJAX" href="part0043.xhtml#aid-190861">Chapter 4</a>, <span class="strong"><em class="calibre9">JSF Validation and AJAX</em></span>, we have two resource bundle files in English and German: <code class="email">appMessages.properties</code> and <code class="email">appMessage_de.properties</code> respectively.</p><p class="calibre7">Here is the English language bundle:</p><div class="informalexample"><pre class="programlisting">// uk/co/xenonique/digital/appMessages.properties
contactForm.firstName=First Name
contactForm.lastName=Last Name
contactForm.houseOrFlatNumber=House or Flat Number
contactForm.street1=Street 1
contactForm.street2=Street 2
contactForm.townOrCity=Town or City
contactForm.region=Region
contactForm.postCode=Post Code</pre></div><p class="calibre7">Here is the German language bundle:</p><div class="informalexample"><pre class="programlisting">// uk/co/xenonique/digital/appMessages_de.properties
contactForm.firstName=Vornamen
contactForm.lastName=Nachnamen
contactForm.houseOrFlatNumber=Haus oder Wohnung Nummer
contactForm.street1=Strasse 1
contactForm.street2=Strasse 2
contactForm.townOrCity=Stadt oder Gemeinde
contactForm.region=Lande
contactForm.postCode=PLZ</pre></div><p class="calibre7">In order to use these bundles in our JSF bundle, we will configure the Faces configuration as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;faces-config version="2.2"
  
  
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
  http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"&gt;
  &lt;application&gt;
    &lt;resource-bundle&gt;
       &lt;base-name&gt;uk.co.xenonique.digital.appMessages&lt;/base-name&gt;
       &lt;var&gt;appMessages&lt;/var&gt;
    &lt;/resource-bundle&gt;
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><p class="calibre7">We will define <a id="id1065" class="calibre1"/>a resource bundle configuration<a id="id1066" class="calibre1"/> in <code class="email">/WEB-INF/faces-config.xml</code> for our application messages. In this file, we can define an application scope variable for our bundle, namely <code class="email">appMessages</code>.</p><p class="calibre7">From here, we can use the bundle with an EL syntax. Here is the code for the house number in the application:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="yourAddressForm"
        styleClass="form-horizontal" p:role="form"&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="houseOrFlatNumber" 
      class="col-sm-3 control-label"&gt;
        #{appMessages['contactForm.houseOrFlatNumber']}
    &lt;/h:outputLabel&gt;...
  &lt;/div&gt; ...
&lt;/h:form&gt;</pre></div><p class="calibre7">As we use dots (<code class="email">.</code>) in our property name, we must use the map EL syntax so as to obtain the required message: <code class="email">#{appMessages['contactForm.houseOrFlatNumber']}</code>.</p><p class="calibre7">Resource bundles may also contain parameterized message properties with formatted token arguments. The token arguments are expanded during message resolution by the JSF framework or through application custom code. Here is an example of parameterized message property:</p><div class="informalexample"><pre class="programlisting">contactForm.specialNote = proctor records {0}, {1} and {2} </pre></div><p class="calibre7">Then, we will use the <code class="email">&lt;h:outputFormat&gt;</code> tag to render the output, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputFormat value="#{appMessages['contactForm.specialNote']}"&gt;
  &lt;f:param value="first argument" /&gt;
  &lt;f:param value="second argument" /&gt;
  &lt;f:param value="third argument" /&gt;
&lt;/h:outputFormat&gt;</pre></div></div><div class="book" title="Message bundles"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec120" class="calibre1"/>Message bundles</h2></div></div></div><p class="calibre7">The backing <a id="id1067" class="calibre1"/>code in the JSF applications in general may <a id="id1068" class="calibre1"/>generate messages for the output that can also be internationalized. The messages are stored in the FacesContext object. We will need to ensure that a user can see all or some of these messages. We will do this with the <code class="email">&lt;h:messages&gt;</code> or <code class="email">&lt;h:message&gt;</code> JSF tags.</p><p class="calibre7">In <a class="calibre1" title="Chapter 4. JSF Validation and AJAX" href="part0043.xhtml#aid-190861">Chapter 4</a>, <span class="strong"><em class="calibre9">JSF Validation and AJAX</em></span>, we already looked at <code class="email">faces-config.xml</code> for the message bundles.</p></div><div class="book" title="A browser configured locale"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec121" class="calibre1"/>A browser configured locale</h2></div></div></div><p class="calibre7">For many <a id="id1069" class="calibre1"/>digital sites, the user's browser<a id="id1070" class="calibre1"/> determines the locale of the website. Developers can inform JSF about the languages that are supported in an application in the <code class="email">/WEB/faces-config.xml file</code>.</p><p class="calibre7">Here is the setting for the contact details application:</p><div class="informalexample"><pre class="programlisting">&lt;faces-config&gt;
   &lt;application&gt;
      &lt;locale-config&gt;
         &lt;default-locale&gt;en&lt;/default-locale&gt;
         &lt;supported-locale&gt;fr&lt;/supported-locale&gt;
         &lt;supported-locale&gt;de&lt;/supported-locale&gt;
      &lt;/locale-config&gt;
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><p class="calibre7">In this file, we will specify that our default locale is English and the supported locales are French and German.</p></div><div class="book" title="An application controlled locale"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec122" class="calibre1"/>An application controlled locale</h2></div></div></div><p class="calibre7">There are <a id="id1071" class="calibre1"/>certain digital sites where the <a id="id1072" class="calibre1"/>requirement is to allow the user to switch between two or more locales. So, we must programmatically achieve this goal. For each rendered view in JSF, we will need to set the locale in the controller method. We will use FacesContext<a id="id1073" class="calibre1"/> to gain access to the root <a id="id1074" class="calibre1"/>view UI in the Faces response and set the locale here.</p><p class="calibre7">Suppose that we are working for a sports automotive manufacturer with their offices in London, UK, and Heidelberg, Southern Germany; then, we can write the following code:</p><div class="informalexample"><pre class="programlisting">final UIViewRoot viewRoot = FacesContext
  .getCurrentInstance().getViewRoot();
viewRoot.setLocale(new Locale("de"));</pre></div><p class="calibre7">The view will be set to the German locale.</p></div><div class="book" title="An individual page controlled locale"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec123" class="calibre1"/>An individual page controlled locale</h2></div></div></div><p class="calibre7">If the<a id="id1075" class="calibre1"/> stakeholder wants a digital site where each individual page may have its own configured locale, then JSF can achieve this goal. Developers can use the <code class="email">&lt;f:view&gt;</code> view tag to override the locale for a page. Before the JSF 2.0 standard, the view tag wrapped the content and acted as a container<a id="id1076" class="calibre1"/> element. In JSF 2.0 and later versions, this is now unnecessary and the view tag can set the locale.</p><p class="calibre7">Here is a code extract that retrieves the locale from a user profile bean with a property called <code class="email">primaryLocale</code>:</p><div class="informalexample"><pre class="programlisting">&lt;f:view locale="#{userProfile.primaryLocale}"/&gt;</pre></div><p class="calibre7">Here is the session-scoped bean that goes with the page view:</p><div class="informalexample"><pre class="programlisting">@SessionScoped
class UserProfile {
  private Locale primaryLocale = Locale.ENGLISH;
  public Locale getPrimaryLocale() {
    return primaryLocale;
  }
}</pre></div></div></div>
<div class="book" title="A web deployment descriptor" id="aid-2TEN41"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec91" class="calibre1"/>A web deployment descriptor</h1></div></div></div><p class="calibre7">This is to go to <a id="id1077" class="calibre1"/>a separate appendix.</p><p class="calibre7">Here is a reference development XML deployment descriptor for JSF 2.2 and Java EE 7:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app 
 
 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
 http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
 version="3.1"&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
    &lt;param-value&gt;Development&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.jsf&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;session-config&gt;
    &lt;session-timeout&gt; 30 &lt;/session-timeout&gt;
  &lt;/session-config&gt;
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;index.jsf&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
&lt;/web-app&gt;</pre></div></div>
<div class="book" title="Programmatic Faces Flows" id="aid-2UD7M1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec92" class="calibre1"/>Programmatic Faces Flows</h1></div></div></div><p class="calibre7">In this appendix, we will<a id="id1078" class="calibre1"/> provide a quick reference to the JavaServer Faces Flow. A flow is as per user and per web application finite state machine is with nodes. There is a default entry node and at least one exit node.</p><div class="book" title="View types"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec124" class="calibre1"/>View types</h2></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 6. JSF Flows and Finesse" href="part0057.xhtml#aid-1MBG21">Chapter 6</a>, <span class="strong"><em class="calibre9">JSF Flows and Finesse</em></span>, we discussed the building of the flow navigation from the Faces <a id="id1079" class="calibre1"/>configuration XML file. The JSF 2.2 specification describes the convention to store and set up the flows with a directory structure.</p><p class="calibre7">There are several types of nodes. They are tabulated in the following table:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Node type</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">View Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This node <a id="id1080" class="indexterm"/>represents a view. The JSF provider renders the view, the flow is still active.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Return Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1081" class="indexterm"/>node represents an exit point from the flow to the outside of this flow. The current flow terminates on the invocation of this node.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Flow Call Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1082" class="indexterm"/>node represents an invocation to another nested flow.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Method Call Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1083" class="indexterm"/>node represents an invocation to a method call in a flow-scoped bean. After leaving this method call, the current flow is still active.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Switch Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id1084" class="indexterm"/>node represents a selectable conditional state. Depending on the state, the flow may move to one or more alternative states and there is a default outcome. The current flow is still active.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Navigation Case Node</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id1085" class="indexterm"/> node represents a generalized conditional state with navigation. Depending on the state, the flow may move to a new outcome or execute an HTTP redirect out of the flow.</p>
</td></tr></tbody></table></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip45" class="calibre1"/>Tip</h3><p class="calibre7">By comparing the <a id="id1086" class="calibre1"/>Faces Flows with the other flows or business process technology, it should be acknowledged that there is no so-called initial node.</p></div></div></div>
<div class="book" title="The Faces Flows programmatic interface"><div class="book" id="aid-2VBO82"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec93" class="calibre1"/>The Faces Flows programmatic interface</h1></div></div></div><p class="calibre7">The Faces Flows are powered by CDI. It is possible to write programmatic flows by declaring a POJO that produces a Faces Flow. In order to generate a flow dynamically, we must annotate a <a id="id1087" class="calibre1"/>bean as a CDI producer and generate a flow instance.</p><p class="calibre7">Here is a basic <code class="email">SimpleFlowFactory</code> class that supplies a Faces Flow:</p><div class="informalexample"><pre class="programlisting">import javax.faces.flow.builder.*;

public class SimpleFlowFactory implements Serializable {
  @Inject DocumentIdGenerator generator;

  @Produces @FlowDefinition
  public Flow createFlow( 
    @FlowBuilderParameter FlowBuilder flowBuilder)
  {
    final String documentId = generator.generate();
    flowBuilder.id(documentId, "simpleFlow");
    flowBuilder.viewNode("simpleFlow", 
      "/simpleFlow/simpleFlow.xhtml")
      .markAsStartNode();
    return flowBuilder.getFlow();
  }
}</pre></div><p class="calibre7">We will annotate the <code class="email">createFlow()</code> method as a CDI producer with the special qualifier, <code class="email">@FlowDefinition</code>. We will also supply this method with a single argument, <code class="email">FlowBuilder</code>, which is also annotated with <code class="email">@FlowBuilderParameter</code>. These definitions, by the way, are found in the reserved imported package: <code class="email">javax.faces.flow.builder</code>. We use an injected <code class="email">FlowBuilder</code> to generate a specific flow. The actual node types are found in the <code class="email">javax.faces.flow</code> package.</p><p class="calibre7">A Faces Flow requires a flow identifier, which is <code class="email">simpleFlow</code>. We can optionally also define a specific document ID. We will use a dependent generator instance to demonstrate how this works. If there is no need for a document ID, then supply an empty string.</p><p class="calibre7">A Faces Flow requires at least one view, which is usually the default name in the XML configuration. In <a id="id1088" class="calibre1"/>order to complete the first view node, we will define a ViewNode and the URI for the flow's view template: <code class="email">/simpleFlow/simpleFlow.xhtml</code>. We will also need to set the flow's start node with the call set to <code class="email">markAsStartNode()</code>, because a Faces Flow requires an initial node. The API for <code class="email">FlowBuilder</code> is taken from the fluent builder pattern. At the end of the <code class="email">createFlow()</code> method, we will generate a flow instance and return it. The JSF provider takes over the flow definition from this point onwards.</p><p class="calibre7">Remember that as we are building the flow ourselves, we don't have to follow all the rules of the XML configuration exactly. However, all the view templates for a flow definition must fall under one single folder in the root context of the web application.</p><p class="calibre7">Just because we defined a flow definition producer, we will still require the actually flow-scoped bean, namely:</p><div class="informalexample"><pre class="programlisting">@Named("simpleFlowController")
@FlowScoped("simple")
public class SimpleFlow implements Serializable {
  /* ... */
}</pre></div><p class="calibre7">We will look at the specifics of each node type in the following sections.</p><p class="calibre7">The following UML class diagram illustrates the key types in the API:</p><div class="mediaobject"><img src="../Images/image00428.jpeg" alt="The Faces Flows programmatic interface" class="calibre10"/><div class="caption"><p class="calibre24">UML class diagram for the Faces Flow API</p></div></div><p class="calibre11"> </p><div class="book" title="ViewNode"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec125" class="calibre1"/>ViewNode</h2></div></div></div><p class="calibre7">With <code class="email">FlowBuilder</code>, we<a id="id1089" class="calibre1"/> can define the ViewNode instances. The actual type is a subclass of <code class="email">javax.faces.faces.ViewNode</code>.</p><p class="calibre7">The following example of a code extends the last flow instance and provides additional view nodes:</p><div class="informalexample"><pre class="programlisting">@Produces @FlowDefinition
public Flow createFlow( 
  @FlowBuilderParameter FlowBuilder flowBuilder)
{
  final String documentId = generator.generate();
  flowBuilder.id(documentId, "simpleFlow");
  /* ... */
  flowBuilder.viewNode("page1", "/simpleFlow/page1.xhtml")
  flowBuilder.viewNode("page2", "/simpleFlow/page2.xhtml")
  flowBuilder.viewNode("page3", "/simpleFlow/page3.xhtml")
  return flowBuilder.getFlow();
}</pre></div><p class="calibre7">The <code class="email">viewNode()</code> method accepts two arguments. The first argument is the view node ID, which we will <a id="id1090" class="calibre1"/>write in and refer to in the view content. The second argument is the view description language document identifier, which translates to the URI of the Facelets view.</p><p class="calibre7">The path of the URI can also be a relative URL. This means the eventual path is relative to the flow URI path. Otherwise, the URI must be absolute in terms of the web context root path, as we can see in the preceding code extract.</p><p class="calibre7">The <code class="email">viewNode()</code> method returns a <code class="email">ViewBuilder</code> type, which has only one additional <code class="email">markAsStartNode()</code> method.</p></div><div class="book" title="ReturnNode"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec126" class="calibre1"/>ReturnNode</h2></div></div></div><p class="calibre7">We can also generate a ReturnNode instance from <code class="email">FlowBuilder</code>. This is straightforward with the <code class="email">returnNode()</code> method. The actual type is a subclass of <code class="email">javax.faces.faces.ReturnNode</code>.</p><p class="calibre7">This is an <a id="id1091" class="calibre1"/>extract of the <code class="email">createFlow()</code> method that specifies a return node:</p><div class="informalexample"><pre class="programlisting">@Produces @FlowDefinition
public Flow createFlow( 
  @FlowBuilderParameter FlowBuilder flowBuilder)
{
  final String documentId = generator.generate();
  flowBuilder.id(documentId, "simpleFlow");
  /* ... */
  flowBuilder.returnNode("return-backup").fromOutcome("welcome");
  return flowBuilder.getFlow();
}</pre></div><p class="calibre7">The <code class="email">returnNode()</code> method accepts a single argument the view node ID and returns an instance of <code class="email">ReturnBuilder</code>. The <code class="email">fromOutcome()</code> method call specifies the view name of the <a id="id1092" class="calibre1"/>outcome that we navigate to after returning from the current flow.</p></div><div class="book" title="MethodCall"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec127" class="calibre1"/>MethodCall</h2></div></div></div><p class="calibre7">With the <code class="email">FlowBuilder</code> instance, we can also create a method call node and add it to the Faces Flow. The<a id="id1093" class="calibre1"/> actual type is a subclass of <code class="email">javax.faces.faces.MethodCallNode</code>. Here is the POJO class:</p><div class="informalexample"><pre class="programlisting">@Produces @FlowDefinition
public Flow createFlow( 
  @FlowBuilderParameter FlowBuilder flowBuilder)
{
  /* ... */
  flowBuilder.methodCallNode("check-funds")  
    .expression(
      "#{loanController.verifyCustomer(customer.account)}", 
      new Class[]{String.class});  
    .defaultOutcome("no-funds-available")
  return flowBuilder.getFlow();
}</pre></div><p class="calibre7">The <code class="email">methodCallNode()</code> call accepts a view node ID and creates a <code class="email">MethodCallBuilder</code> instance. This node requires an expression that informs JSF about the name of the bean and the method to invoke. Here, the method is <code class="email">verifyCustomer()</code> on an accessible backing bean controller <code class="email">loanController</code>. We can also pass the account record in the customer's details using an expression language. In case the target method invocation returns null or an empty string, we can specify a default outcome view identifier.</p><p class="calibre7">I recommend that you should reduce the coupling in a layered architecture as much as possible. Be careful about mixing too much presentation tier information with the business logic.</p></div><div class="book" title="FlowCall"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec128" class="calibre1"/>FlowCall</h2></div></div></div><p class="calibre7">We will <a id="id1094" class="calibre1"/>create a flow call node using the same abstract class type <code class="email">FlowBuilder</code>. This node type invokes a nested Faces Flow. The <code class="email">flowCallNode()</code> method accepts a single argument in the view node ID and returns a <code class="email">FlowCallBuilder</code> instance. The actual type is a subclass of <code class="email">javax.faces.faces.FlowCallNode</code>.</p><p class="calibre7">In this code extract, which is based on the <span class="strong"><em class="calibre9">Industrial sector carbon footprint</em></span> discussion from <a class="calibre1" title="Chapter 6. JSF Flows and Finesse" href="part0057.xhtml#aid-1MBG21">Chapter 6</a>, <span class="strong"><em class="calibre9">JSF Flows and Finesse</em></span>, we will rewrite the flow definition XML file called <code class="email">footprint-flow.xml</code> as the following <code class="email">SectorFlowFactory</code> POJO class:</p><div class="informalexample"><pre class="programlisting">class SectorFlowFactory implements Serializable {
  /* ... */
  @Produces @FlowDefinition
  public Flow createFlow( 
    @FlowBuilderParameter FlowBuilder flowBuilder)
  {
    flowBuilder.id("", "sector-flow");
    /* ... */
    flowBuilder.flowCallNode("callFootprintFlow")
      .flowReference("", "footprint-flow)
      .outboundParameter("param1FromSectorFlow", 
        "param1 sectorFlow value")
      .outboundParameter("param2FromSectorFlow", 
        "param2 sectorFlow value")
      .outboundParameter("param3FromSectorFlow", 
        "#{sectorFlow.footprint}");
    return flowBuilder.getFlow();
  }
}</pre></div><p class="calibre7">In the preceding<a id="id1095" class="calibre1"/> code, the node is identified as <code class="email">callFootprintFlow</code>. We must provide the node ID of the nest flow through a <code class="email">flowReference()</code> method. The first argument of <code class="email">flowReference()</code> is the flow document ID, which is an empty string here. The nested flow is identified as footprint-flow by the second argument.</p><p class="calibre7">We will use the <code class="email">outboundParameter()</code> method on <code class="email">FlowCallBuilder</code> in order to declare the outbound parameters that pass the data from the calling sector-flow to the nested footprint-flow. The first argument to <code class="email">outboundParameter()</code> is the parameter name and the second argument is a literal string or an expression.</p><p class="calibre7">We can also rewrite the flow definition XML file from the nested flow programmatically. Here is an extract of the <code class="email">FootprintFlowFactory</code> class:</p><div class="informalexample"><pre class="programlisting">class FootprintFlowFactory implements Serializable {
  /* ... */
  @Produces @FlowDefinition
  public Flow createFlow( 
    @FlowBuilderParameter FlowBuilder flowBuilder)
  {
    flowBuilder.id("", "footprint-flow");
    flowBuilder.inboundParameter("param1FromSectorFlow", 
      "#{flowScope.param1Value}");
    flowBuilder.inboundParameter("param2FromSectorFlow", 
      "#{flowScope.param2Value}");
    flowBuilder.inboundParameter("param3FromSectorFlow", 
      "#{flowScope.param3Value}");
    /* ... */
    return flowBuilder.getFlow();
  }
}</pre></div><p class="calibre7">In this code, we<a id="id1096" class="calibre1"/> notice that the footprint-flow ID must match the caller reference ID. For this Faces Flow, we will declare the inbound parameters with the <code class="email">inboundParameter()</code> method call. The first argument is the parameter name and the second is an expression language reference that defines where the value is stored.</p></div><div class="book" title="SwitchNode"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec129" class="calibre1"/>SwitchNode</h2></div></div></div><p class="calibre7">We can use <code class="email">FlowBuilder</code> to create the declaration of a switch node. These node types are composed <a id="id1097" class="calibre1"/>of an association between a conditional statement and the outcome. The outcome is the view ID. A switch node has one or more conditional statements. It may also have a default outcome. During the processing of the flow, JSF executes each conditional statement in turn. If it evaluates to true (or rather, <code class="email">Boolean.TRUE</code>), then the associated outcome is the chosen one. The actual type is a subclass of <code class="email">javax.faces.faces.SwitchNode</code>.</p><p class="calibre7">Let 's see an example of the switch node in action in a POJO. Here is another class for a monetary loan decision maker called <code class="email">LoanDecisionFlowFactory</code>:</p><div class="informalexample"><pre class="programlisting">class LoanDecisionFlowFactory implements Serializable {
  /* ... */
  @Produces @FlowDefinition
  public Flow createFlow( 
    @FlowBuilderParameter FlowBuilder flowBuilder)
  {
    flowBuilder.id("", "loan-application");
    /* ... */
    flowBuilder.switchNode("loan-decision")
      .defaultOutcome("home")
      .switchCase()  
        .condition("#{loanMaker.decision=='Agreed'}")
        .fromOutcome("loan-agreement")
      .switchCase()  
        .condition("#{loanMaker.decision=='Declined'}")
        .fromOutcome("loan-declined")
      .switchCase()  
        .condition("#{loanMaker.decision=='Pending'}")
        .fromOutcome("loan-pending")
    /* ... */
    return flowBuilder.getFlow();
  }
}</pre></div><p class="calibre7">In the <code class="email">createFlow()</code> method, we will create a Faces Flow identified as loan-application. We will then create a switch node declaration with <code class="email">switchNode()</code> and identified as loan-decision. This <a id="id1098" class="calibre1"/>method returns a <code class="email">SwitchBuilder</code> type. This builder type has <code class="email">switchCase()</code> that returns <code class="email">SwitchCaseBuilder</code>. The other overloaded methods included are called <code class="email">defaultCome()</code>.</p><p class="calibre7">It is recommended that you also declare a default outcome with the <code class="email">defaultOutcome()</code> method, which accepts a view ID. In this way, the flow always moves to the next viable location.</p><p class="calibre7">Given the <code class="email">SwitchBuilder</code> builder type, we will declare the individual cases with the <code class="email">condition()</code> and <code class="email">fromOutCome()</code> methods. The <code class="email">condition()</code> call accepts an expression string and it returns <code class="email">SwitchCaseBuilder</code>. The only property on this builder is a valid outcome, which is a view identifier.</p></div><div class="book" title="NavigationCase node"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec130" class="calibre1"/>NavigationCase node</h2></div></div></div><p class="calibre7">The final <a id="id1099" class="calibre1"/>builder type in the API relates to a general abstract class type <code class="email">NavigationCaseBuilder</code>. We can create a navigation case node with <code class="email">FlowBuilder</code>. The actual type is a subclass of <code class="email">javax.faces.faces.FlowNode</code>.</p><p class="calibre7">Here is a POJO from the financial services domain that is designed to allow the back office staff in an investment bank to post the process trades in a workflow:</p><div class="informalexample"><pre class="programlisting">class PostProcessTradeFlowFactory implements Serializable {
  /* ... */
  @Produces @FlowDefinition
  public Flow createFlow( 
    @FlowBuilderParameter FlowBuilder flowBuilder)
  {
    flowBuilder.id("", "post-process-trade-flow"); /* ... */
    flowBuilder.navigationCase()
      .fromOutcome("trade-check")
      .condition("#{trade.amount &gt; global.risk.limit}")
      .toViewId("exceptional");

    flowBuilder.navigationCase()
      .fromOutcome("trade-check")
      .condition("#{trade.settlementCcy != 'USD'")
      .redirect().includeViewParams()
      .parameter("deskCodeNotice", "OUT_OF_CURRENCY_DEAL");
    /* ... */
    return flowBuilder.getFlow();
  }
}</pre></div><p class="calibre7">In this <code class="email">PostProcessTradeFlowFactory</code> POJO, we again have a <code class="email">createFlow()</code> method, but <a id="id1100" class="calibre1"/>this time we will call <code class="email">navigationCase()</code> twice. This method has no arguments and returns a <code class="email">NavigationCaseBuilder</code> type that creates the specified Faces Flow. A navigation case flow requires a trigger point, a conditional expression, and an outcome or redirection response.</p><p class="calibre7">In the first flow, we will call the <code class="email">fromOutcome()</code> method on <code class="email">NavigationCaseBuilder</code> in order to declare the JSF view ID that triggers the check. The <code class="email">condition()</code> method defines the expression that must return a Boolean value. The <code class="email">toViewId()</code> method defines the outcome view ID to navigate if the conditional expression evaluates as <code class="email">Boolean.TRUE</code>. So, therefore, if the trade value exceeds the firm-wide exposure limit (<code class="email">trade.amount &gt; global.risk.limit</code>), then the flow navigates to the exceptional view.</p><p class="calibre7">With the second flow declaration, we will define a navigation case to handle an out-of-currency deal, which might be a Swap, Bond, or some other derivative. With the same trigger outcome trade check, we will trap on the expression for the currencies that settles in non-US dollars: <code class="email">trade.settlementCcy != 'USD'</code>. With this navigation case node, we will execute an HTTP redirect that causes the customer to exit the entire flow. We will invoke <code class="email">redirect()</code> and it will return <code class="email">NavigationCaseBuilder.RedirectBuilder</code>. This nested abstract class has two methods: <code class="email">includeViewParams()</code> and <code class="email">parameter()</code>. The <code class="email">includeViewParams()</code> method adds all of the view parameters to the redirect URL. The <code class="email">parameter()</code> method adds the name and value pairs to the redirect URL. Remember that after the flow is completed, from a security digital developer's point of view, these parameters will be highly visible in the URL of the eventual HTTP GET request!</p></div><div class="book" title="Builder types"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec131" class="calibre1"/>Builder types</h2></div></div></div><p class="calibre7">The builder types—<code class="email">ViewBuilder</code>, <code class="email">ReturnBuilder</code>, <code class="email">MethodCallBuilder</code>, <code class="email">FlowCallBuilder</code>, <code class="email">SwitchBuilder</code>, <code class="email">SwitchCaseBuilder</code>, and <code class="email">NavigationCaseBuilder</code> are abstract classes. They are implementations of the <code class="email">javax.faces.flow.builder.NodeBuilder</code> interface. The Faces Flow API is an example of an <a id="id1101" class="calibre1"/>embedded Domain Specific Language.</p></div></div></body></html>