<html><head></head><body>
		<div id="_idContainer013">
			<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor088"/>5</h1>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Algorithm Efficiencies</h1>
			<p>Developers focused on ensuring their Java applications perform at a high level must consider the efficiency of individual algorithms. We do not judge an algorithm’s efficiency by its lines of code; rather, we make this judgment after analyzing <span class="No-Break">test results.</span></p>
			<p>This chapter is intended to help you learn how to choose the right algorithm for any given requirement. It also covers the concept of time complexity to include strategies for reducing time complexity. We will also focus on lean and efficient code. This chapter also emphasizes the importance of <span class="No-Break">algorithm testing.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Algorithm selection</span></li>
				<li>Low <span class="No-Break">time complexity</span></li>
				<li>Testing algorithms <span class="No-Break">for efficiency</span></li>
			</ul>
			<p>By the end of this chapter, you should have a strong theoretical understanding of algorithm efficiencies as well as hands-on experience creating and modifying algorithms. This experience can help ensure you get high performance out of your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, please refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter05</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Algorithm selection</h1>
			<p>One of the best things about writing<a id="_idIndexMarker239"/> software is that there is no single solution to a problem. We are free to use a style that’s unique to us and to incorporate data structures, libraries, and algorithms as long as we obtain the correct results. This is a bit of an overstatement. We can write an algorithm in essentially infinite different ways and get the <span class="No-Break">same results.</span></p>
			<p>This programming flexibility can also be a detriment, as evidenced by low-performant algorithms. So, just because we can write algorithms with reckless abandon, it does not mean we should. We should be strategic in our algorithm selection and creation as it will have a significant impact on the overall efficiency of our <span class="No-Break">Java applications.</span></p>
			<p>In this section, we will look at a specific process of selecting algorithms, a case study, and <span class="No-Break">evolving trends.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Selection process</h2>
			<p>While there is no industry-wide<a id="_idIndexMarker240"/> official algorithm selection process, here is a <span class="No-Break">six-step approach:</span></p>
			<ol>
				<li>Fully understand the requirements. It may seem obvious, but so many developers get this wrong. It is critical to fully understand the requirements. This is the problem we want an algorithm to solve. Understanding the problem involves learning about constraints, datasets, inputs, outputs, and more. Once we have fully understood the requirements, we can move on to the <span class="No-Break">next step.</span></li>
				<li>In this second step, we should become familiar with the data that our algorithm will be associated with. This might include static data, data streams, or even generating data. This step is where you fully immerse yourself in anything related to the application’s data. In addition to data familiarity, we should start thinking about what type of data structures our algorithms <span class="No-Break">should use.</span></li>
				<li>Consider the computational complexity of each potential algorithm. Points for consideration here include the time and memory requirements. You can implement benchmarking to help inform <span class="No-Break">your decision.</span></li>
			</ol>
			<p>In this step, you should identify resource limitations related to processing and memory. Knowing these upper boundaries will aid your <span class="No-Break">algorithm decision.</span></p>
			<p>This is where you test your algorithms, make refinements, and retest. This is an iterative process where you should make small, incremental changes to your algorithms to help identify what <span class="No-Break">works best.</span></p>
			<p>Document your final decision and all factors that led to it. The more detailed your document, the better. This will be helpful when revisiting your <span class="No-Break">selection later.</span></p>
			<p>Ideally, you should adopt<a id="_idIndexMarker241"/> a continual process improvement mindset and not hesitate to question previous decisions. Even if you select and refine an algorithm that results in the best possible performance, it should be periodically reviewed. Environments, data, and other factors can change over time and impact your <span class="No-Break">algorithm’s efficiency.</span></p>
			<p>Now, let’s see how these steps can be implemented by reviewing a case study in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Case study</h2>
			<p>It can be helpful to review <a id="_idIndexMarker242"/>case studies to help solidify our understanding of how algorithm selection can significantly improve Java application performance. This section details the algorithm selection for a business’ e-commerce platform. The business noted that its system processed search requests inefficiently, resulting in user complaints that the system was sluggish. So, the business hopes to improve the search function and, therefore, the overall performance of <span class="No-Break">their application.</span></p>
			<p>The first step in this case is to identify what is causing the problem. For our example, the e-commerce platform implemented a linear search algorithm that matches user requests with database entries. The search algorithm has not changed since the initial system was developed and the database continues to increase in size. All search results <span class="No-Break">are slow.</span></p>
			<p>Our second step is to understand the data. So, the developer reviews the database schema and sampled database records to become familiar with the system’s data requirements and use. In the next two steps, the developer reviews the computational complexity of the search feature and identifies any <span class="No-Break">resource limitations.</span></p>
			<p>The developer is now poised to evaluate alternative algorithms. In this example, possible alternatives could include binary searches and other proven search patterns. The review of these alternatives leads to the adoption of an inverted index for a data structure that can be optimized for <span class="No-Break">full-text searches.</span></p>
			<p class="callout-heading">Inverted index</p>
			<p class="callout">A data structure commonly used for full-text searches. The indexing identifies each unique term and lists where that term appears. Implementation typically includes using a dictionary <span class="No-Break">or hashmap.</span></p>
			<p>Now the developer can tailor their selection based on their system’s needs. Next, they will perform multiple tests and document the results. In this example case, the system’s search function is now highly <a id="_idIndexMarker243"/>performant. What is left is to document the decision and <span class="No-Break">decision factors.</span></p>
			<p>The example case showed developers that they need to balance application performance and resource utilization. Next, let’s look at some evolving trends in <span class="No-Break">algorithm selection.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Evolving trends</h2>
			<p>Java software development is a dynamic field, as are the algorithms we create and use. There are several trends<a id="_idIndexMarker244"/> regarding algorithm efficiencies, and five of them are described in <span class="No-Break">this section.</span></p>
			<ul>
				<li><strong class="bold">AI and ML</strong>: Many people in the tech space have coined 2023 as the year of <strong class="bold">Artificial Intelligence</strong> (<strong class="bold">AI</strong>). AI and <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) are not new, but their widespread use<a id="_idIndexMarker245"/> and adoption have never been more <a id="_idIndexMarker246"/>prevalent, thanks to OpenAI’s launch <a id="_idIndexMarker247"/>in 2015 and the introduction of <strong class="bold">Generative Pre-trained Transformers</strong> (<strong class="bold">GPTs</strong>), such as ChatGPT. The industry is experiencing a shift towards <span class="No-Break">AI-related algorithms.</span><p class="list-inset">You can learn more about leveraging AI for high-performance Java applications in <a href="B21942_18.xhtml#_idTextAnchor345"><span class="No-Break"><em class="italic">Chapter 18</em></span></a><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Concurrency</strong>: With the proliferation of multi-core processors, the need to focus algorithms on parallel processing has increased. Fortunately, Java has robust support <span class="No-Break">for concurrency.</span><p class="list-inset">You can learn more about concurrency strategies in <a href="B21942_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Cloud optimizations</strong>: As more applications are being hosted in the cloud, the need for updating our Java applications for cloud optimization increases. Cloud computing requires us to consider concepts such as scalability and distributed processing. These considerations are important for new Java applications that are being developed for the cloud as well as existing applications that we want to migrate to <span class="No-Break">the cloud.</span></li>
				<li><strong class="bold">Security</strong>: One thing in software development that seems to remain the same is the ever-increasing number of cyber threats to our systems and data. Security is a mindset, not a step in software development. The trend here is the increased emphasis on security throughout the product <span class="No-Break">life cycle.</span></li>
				<li><strong class="bold">Community</strong>: There is impressive growth in the area of crowdsourced algorithm design and other open source contributions. The systems and algorithms that result<a id="_idIndexMarker248"/> are increasingly robust <span class="No-Break">and diverse.</span></li>
			</ul>
			<p>Now that we have reviewed algorithm selection, shared a case study, and discussed evolving algorithm trends, we can look at low time complexity as it relates to <span class="No-Break">algorithm efficiencies.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Low time complexity</h1>
			<p>Time complexity refers to the measure<a id="_idIndexMarker249"/> of the time efficiency of any given algorithm. We want to determine the execution time of our Java applications and ensure our algorithms do not add time complexity to our applications. The overall goal is to reduce algorithm execution time. We should test our algorithms using a variety of possible inputs <span class="No-Break">and environments.</span></p>
			<p>In this section, we will look at specific strategies to help you reduce the time complexity of your algorithms. We will also <a id="_idIndexMarker250"/>address the common pitfalls associated with <span class="No-Break">time complexity.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Strategies for reducing time complexity</h2>
			<p>There are several strategies<a id="_idIndexMarker251"/> we can adopt to help us reduce the time complexity of our algorithms. Perhaps the easiest strategy is to simply ensure our algorithms are not overly complicated. This strategy requires us to double-check our algorithmic logic and use the optimization techniques covered throughout this book. Reducing unnecessary calculations within a loop, especially with recursion, is a great <span class="No-Break">optimization strategy.</span></p>
			<p>Sometimes our algorithms might seem to be overly complex and we cannot find a way to simplify them. In those cases, it is worth considering breaking the algorithm into multiple algorithms, each executing a subset of the original set <span class="No-Break">of instructions.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Common pitfalls</h2>
			<p>When reviewing the common<a id="_idIndexMarker252"/> pitfalls related to algorithm time efficiency, we can refer to previous chapters and look at others yet to come. As you can see from the list of the top four common pitfalls listed here, details can be found in several chapters of <span class="No-Break">this book:</span></p>
			<ul>
				<li>Improper use of data structures (<a href="B21942_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">)</span></li>
				<li>Overuse of non-standard libraries (<a href="B21942_13.xhtml#_idTextAnchor227"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">)</span></li>
				<li>Inadequate testing and profiling (<a href="B21942_14.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">)</span></li>
				<li>Lack of focus on readability and maintainability (<a href="B21942_16.xhtml#_idTextAnchor307"><span class="No-Break"><em class="italic">Chapter 16</em></span></a><span class="No-Break">)</span></li>
			</ul>
			<p>In addition, we might simply be overlooking the big picture of our application’s overall performance. Sometimes, we can get stuck in the minutiae of our code at the expense of overall algorithm or <span class="No-Break">application efficiency.</span></p>
			<p>As we have seen, low-time complexity is both a concept and a goal. It is an essential consideration when our ultimate aim is to increase the performance of our <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Testing algorithms for efficiency</h1>
			<p>At this point, it is clear<a id="_idIndexMarker253"/> that we need our algorithms to be efficient. This section focuses on how we can measure algorithm efficiency based on our requirements. We will start with a short section on the importance of testing, then how to prepare for testing, how to conduct the tests, and what to do <span class="No-Break">after testing.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Importance of testing</h2>
			<p>Simply put, if we do not test our algorithms<a id="_idIndexMarker254"/> for efficiency, we will not know for sure if they are efficient or inefficient. Optimizations are pointless if we do not measure their impact on a specific algorithm and overall <span class="No-Break">application performance.</span></p>
			<p>We might assume that we know what optimizations will result in the best performance based on our experience. Although this is experience-based, it is still merely anecdotal. Changes in input and the operating environment can challenge our previous knowledge of algorithm efficiency, so we should not assume <span class="No-Break">without testing.</span></p>
			<p class="callout-heading">Tip: Become a testing zealot</p>
			<p class="callout">Good programmers focused on high performance are dedicated to the idea that algorithm efficiency testing is a core part of the software <span class="No-Break">life cycle.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Preparing for algorithm efficiency testing</h2>
			<p>It can take time to set up a testing<a id="_idIndexMarker255"/> environment, so it is important to plan for it and allot sufficient time in your development project for it. Here is an overview of a seven-step process of preparing for algorithm <span class="No-Break">efficiency testing:</span></p>
			<ol>
				<li><strong class="bold">Identify requirements</strong>: In this first step, we need to thoroughly understand what the algorithm<a id="_idIndexMarker256"/> is intended to do and what <strong class="bold">Key Performance Indicators</strong> (<strong class="bold">KPIs</strong>) you will use in <span class="No-Break">your testing.</span></li>
				<li><strong class="bold">Establish the test environment</strong>: We rarely test in a production environment, so we need to replicate data and conditions in the development environment. The goal is to mirror, as closely as possible, the <span class="No-Break">production environment.</span></li>
				<li><strong class="bold">Tool selection</strong>: In this step, we select the profiling and benchmarking tools we <span class="No-Break">will use.</span></li>
				<li><strong class="bold">Obtaining test data</strong>: Here, we want to create a replica of live data so we can use it <span class="No-Break">for testing.</span></li>
				<li><strong class="bold">Benchmarking</strong>: In this step, we establish baselines so that we can compare our current algorithms to future, <span class="No-Break">optimized versions.</span></li>
				<li><strong class="bold">Thorough documentation</strong>: It is important to document our testing plans so we can replicate them in <span class="No-Break">the future.</span></li>
				<li><strong class="bold">Iterative testing</strong>: This final step is essentially a scheduling step. In order to support the need for iterative<a id="_idIndexMarker257"/> testing, multiple iterations should <span class="No-Break">be scheduled.</span></li>
			</ol>
			<p>Now that you know how to prepare for testing, let’s look at how to conduct <span class="No-Break">the tests.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Conducting the tests</h2>
			<p>You are now ready to implement<a id="_idIndexMarker258"/> your testing plan. Let’s look at a simple example of what this looks like in <span class="No-Break">Java code.</span></p>
			<p>Our example will be to test a bubble sort algorithm’s execution time. Here is our bubble <span class="No-Break">sort algorithm:</span></p>
			<pre class="console">
public class EfficiencyTestExample {
  public static void main(String[] args) {
    algorithmEfficiencyTest();
  }
  // Here is our bubble sort algorithm
  public static void ourBubbleSort(int[] array) {
    int nbrElements = array.length;
    int temp;
    for (int i = 0; i &lt; nbrElements; i++) {
      for (int j = 1; j &lt; (nbrElements - i); j++) {
        if (array[j - 1] &gt; array[j]) {
          temp = array[j - 1];
          array[j - 1] = array[j];
          array[j] = temp;
        }
      }
    }
  }
}</pre>			<p>Next, we need to create a method<a id="_idIndexMarker259"/> for testing the execution time of our bubble sort algorithm. This is what that would <span class="No-Break">look like:</span></p>
			<pre class="console">
public static void algorithmEfficiencyTest() {
  int[] ourTestArray = new int[30000];
  for (int i = 0; i &lt; ourTestArray.length; i++) {
    ourTestArray[i] = (int) (Math.random() * 30000);
  }
  long startTime = System.nanoTime();
  ourBubbleSort(ourTestArray);
  long endTime = System.nanoTime();
  long duration = (endTime - startTime);
  System.out.println("Execution Time (nanoseconds): " + duration);
}</pre>			<p>As you can see, we created a test array with 30,000 elements and then populated it with random numbers. Next, we logged our start time, executed the bubble sort, and then logged the end time. With both the start and end times, we know how long the algorithm took. This is what<a id="_idIndexMarker260"/> the output might <span class="No-Break">look like:</span></p>
			<pre class="console">
Execution Time (nanoseconds): 1054427380</pre>			<p>Next, let’s look at what our post-testing actions <span class="No-Break">should be.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Post-test actions</h2>
			<p>Our work does not end after<a id="_idIndexMarker261"/> we complete our tests. We need to perform the following <span class="No-Break">post-test actions:</span></p>
			<ul>
				<li>Thoroughly analyze our <span class="No-Break">test results</span></li>
				<li>Optimize our algorithms based on our <span class="No-Break">test results</span></li>
				<li>Document changes to our algorithms and record why we made <span class="No-Break">the changes</span></li>
				<li>As appropriate, share your findings and process <span class="No-Break">with stakeholders</span></li>
				<li>When necessary, update our <span class="No-Break">test environments</span></li>
				<li>Adopt a continuous process improvement mindset with <span class="No-Break">constant monitoring</span></li>
				<li>Conduct an after-action reflection and document what you learned about the process and how it can <span class="No-Break">be improved</span></li>
			</ul>
			<p>When we thoroughly analyze our test results and conduct the other post-test actions, we increase the chance of our testing plans being properly executed and with <span class="No-Break">valid results.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Summary</h1>
			<p>This chapter was intended to help you learn how to choose the right algorithm for any given requirement and how to measure your results. It covered the concept of time complexity and included strategies for reducing time complexity. We also emphasized the importance of algorithm testing. You should now have a strong theoretical understanding of algorithm efficiencies as well as hands-on experience of creating and modifying algorithms. This experience can help ensure you get high performance out of your <span class="No-Break">Java applications.</span></p>
			<p>In the next chapter, <em class="italic">Strategic Object Creation and Immutability</em>, we will introduce strategies for object creation with the mindset of improving the overall performance of our Java applications. That chapter covers minimizing object creation, object immutability, and <span class="No-Break">garbage collection.</span></p>
		</div>
	

		<div class="Content" id="_idContainer014">
			<h1 id="_idParaDest-105" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor104"/>Part 2: Memory Optimization and I/O Operations</h1>
			<p>Memory management is crucial for high-performance Java applications. This part focuses on strategic object creation and the use of immutability to optimize memory usage. It also covers the effective handling of string objects and the identification and prevention of memory leaks. The chapters in this part provide practical insights into managing memory efficiently and ensuring robust <span class="No-Break">I/O operations.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21942_06.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Strategic Object Creation and Immutability</em></li>
				<li><a href="B21942_07.xhtml#_idTextAnchor127"><em class="italic">Chapter 7</em></a>, <em class="italic">String Objects</em></li>
				<li><a href="B21942_08.xhtml#_idTextAnchor143"><em class="italic">Chapter 8</em></a>, <em class="italic">Memory Leaks</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer015">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer016">
			</div>
		</div>
	</body></html>