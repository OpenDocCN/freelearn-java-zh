<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Familiarizing Yourself with Basic Monads</h1>
                </header>
            
            <article>
                
<p class="p1">In the previous chapter, we got to know Functors, an abstraction that gives the <kbd>map</kbd> method <span>the effects defined in the standard library</span>. Looking back at <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects</em>, there is still something missing here—the source of the <kbd>flatMap</kbd> method, which all standard effects also have.</p>
<p class="p1">In this chapter, we will finally meet the concept of a monad, the structure that defines <kbd>flatMap</kbd>. To learn about this function inside and out, we'll implement four different monads.</p>
<p class="p1">By the end of this chapter, you'll be familiar with the following topics:</p>
<ul>
<li class="p1">Abstracting a monad and its properties</li>
<li><span>Implementing monads for standard effects</span></li>
<li class="p1">The implementation and applicability of the following basic monads:
<ul>
<li class="p1">Id</li>
<li class="p1">State</li>
<li class="p1">Reader</li>
<li class="p1">Writer</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li>JDK 1.8+</li>
<li class="mce-root">SBT 1.2+</li>
</ul>
<p class="mce-root">The source code for this chapter is available in our GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to monads</h1>
                </header>
            
            <article>
                
<p>It took us three chapters to get to the moment where we're ready to discuss the origins of the <kbd>flatMap</kbd> method in regards to the effects we looked at in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a><span>, </span><em>Exploring Built-In Effects</em>. The reason for this is not the complexity of the topic, but the richness of the family of abstractions related to it.</p>
<p>After this introduction, a suspicious reader will think with disappointment—OK, now they are going to use their usual trick and say that there is an abstraction for <kbd>flatMap</kbd>, <kbd>flattener</kbd> or <kbd>flatMapative</kbd>, pull some laws out of thin air, and consider themselves done. What cheaters!</p>
<p>Well, technically we're not cheating because we're not pulling things out of anywhere. Instead, we're taking them from category theory, the branch of mathematics we mentioned previously. The rules our abstractions must obey are defined by mathematicians. There is an advantage to this approach, though<span>—</span>as soon as we can prove that our implementation obeys the required laws, we can use everything that has been proved by category theory to our advantage. One example of this is the possibility of combining two applicatives into one, just like in the example we discussed in the previous chapter.</p>
<p>Going back to our <kbd>flatMap</kbd> method, there is still some intrigue there. The abstraction name is <kbd>Monad</kbd>, and it is defined by two methods, <kbd>flatMap</kbd>, and <kbd>unit</kbd>:</p>
<pre><span>import scala.language.higherKinds<br/>trait </span>Monad[<span>F</span>[_]] {<br/>  <span>def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>F</span>[<span>A</span>]<br/>  <span>def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>F</span>[<span>B</span>]): <span>F</span>[<span>B</span>]<br/>}</pre>
<p>The monad is defined for a container of type <kbd>F</kbd>. The <kbd>unit</kbd> method <em>lifts</em> its parameter into the context of <kbd>F</kbd>; the <kbd>flatMap</kbd> is similar to the plain <kbd>map</kbd> method in a sense that it applies <kbd>f</kbd> to <kbd>a</kbd>. What is different in <kbd>flatMap</kbd> and what makes it special is its ability to <em>collapse</em> or <em>flatten</em> two layers of <kbd>F</kbd> into one. This is easy to see from the type signatures of <kbd>a</kbd> and <kbd>f</kbd>.</p>
<p>This possibility to flatten <kbd>F[F[A]]</kbd> into <kbd>F[A]</kbd> is the reason why monads are often expressed with a different set of methods; that is, <kbd>map</kbd> and <kbd>flatten</kbd>:</p>
<pre><span>trait </span>Monad[<span>F</span>[_]] {<br/>  <span>def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>F</span>[<span>A</span>]<br/>  <span>def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): <span>F</span>[<span>B</span>]<br/>  <span>def </span><span>flatten</span>[<span>A</span>](fa: <span>F</span>[<span>F</span>[<span>A</span>]]): <span>F</span>[<span>A</span>]<br/>}</pre>
<p>The <kbd>flatten</kbd> method does exactly what we just said<span>—</span>it allows us to reduce the stack of Fs into a single <kbd>F</kbd>. Sometimes, the <kbd>flatten</kbd> method is also called a <kbd>join</kbd>. We will see in a moment why this name makes sense.</p>
<p>Clearly, we have the same situation with monads that we had with applicatives—we can choose the set of primitive functions and implement the rest of functionality in terms of primitives. For instance, the <kbd>flatMap</kbd> is equally powerful as a combination of <kbd>map</kbd> and <kbd>flatten</kbd>, and we can choose one of these combinations.</p>
<p>Let's stick to the initial definition and implement other methods in terms of <kbd>flatMap</kbd>. This is what <kbd>map</kbd> will look like:</p>
<pre><span>def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): <span>F</span>[<span>B</span>] = <br/>  flatMap(a)(a =&gt; unit(f(a)))</pre>
<p>What we're doing here is basically mapping with the function <kbd>f</kbd> and lifting the result in context of <kbd>F</kbd> as the types require.</p>
<p>Can you remember the name of the abstraction that is characterized by having a <kbd>map</kbd> method? Right, this is the functor. Our ability to define a <kbd>map</kbd> solely in terms of <kbd>flatMap</kbd> for every <kbd>Monad</kbd> proves that every <kbd>Monad</kbd> is a <kbd>Functor</kbd>. Because of this, we can state that <kbd>Monad extends Functor</kbd>. </p>
<p>The definition of the <kbd>flatten</kbd> method is similarly straightforward:</p>
<pre><span>def </span><span>flatten</span>[<span>A</span>](a: <span>F</span>[<span>F</span>[<span>A</span>]]): <span>F</span>[<span>A</span>] = flatMap(a)(<span>identity</span>)</pre>
<p>With the <kbd>identity</kbd> function, we are using part of the <kbd>flatMap</kbd> power to convert two layers of <kbd>F</kbd> into one without actually doing anything with <kbd>a</kbd>.</p>
<p>Can we go further and apply a function that is already in the context of <kbd>F</kbd> to the <kbd>a</kbd>? It turns out that we can, and we know the method that does this—this is the <kbd>apply</kbd> defined in <kbd>Applicative</kbd>:</p>
<pre><span>def </span><span>apply</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>F</span>[<span>A </span>=&gt; <span>B</span>]): <span>F</span>[<span>B</span>] =<br/>  flatMap(f) { fab: (<span>A </span>=&gt; <span>B</span>) =&gt; map(a) { a: <span>A </span>=&gt; fab(a) }}</pre>
<p>Here, we're pretending that <kbd>f</kbd> is a value, so we just need to represent <kbd>a</kbd> as a function that can be applied to this value. The <kbd>fab</kbd> function takes a function called <kbd>A =&gt; B</kbd> that we use to <kbd>map</kbd> over the original <kbd>a</kbd>, returning <kbd>B</kbd>, which becomes an <kbd>F[B]</kbd> because of the application of <kbd>map</kbd>. </p>
<p>The <kbd>apply</kbd> function is also defined in terms of <kbd>flatMap</kbd> (and <kbd>map</kbd>, which is derived from <kbd>flatMap</kbd>) for every monad. This provides evidence that every <kbd>Monad</kbd> is an <kbd>Applicative</kbd>. Thus, our definition of <kbd>Monad</kbd> can be changed into the following form:</p>
<pre><span>trait </span>Monad[<span>F</span>[_]] <span>extends ch08.</span>Applicative[<span>F</span>] {<br/>  <span>def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>F</span>[<span>B</span>]): <span>F</span>[<span>B</span>]<br/><br/>  <span>def </span><span>flatten</span>[<span>A</span>](a: <span>F</span>[<span>F</span>[<span>A</span>]]): <span>F</span>[<span>A</span>] = flatMap(a)(<span>identity</span>)<br/><br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>F</span>[<span>A</span>]<br/>  <br/>  <span>override def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): <span>F</span>[<span>B</span>] = <br/>    flatMap(a)(a =&gt; unit(f(a)))<br/><br/>  <span>override def </span><span>apply</span>[<span>A</span><span>, </span><span>B</span>](a: <span>F</span>[<span>A</span>])(f: <span>F</span>[<span>A </span>=&gt; <span>B</span>]): <span>F</span>[<span>B</span>] =<br/>    flatMap(f) { fab: (<span>A </span>=&gt; <span>B</span>) =&gt; map(a) { a: <span>A </span>=&gt; fab(a) }}<br/>}</pre>
<p>We can see that the <kbd>flatMap</kbd> method is only available for the <kbd>Monad</kbd>, not for an <kbd>Applicative</kbd>. This leads to interesting consequences, which we will look at later in this chapter.</p>
<p>Now, before switching gears and starting to implement the instances of specific monads, let's discuss the monadic laws first.</p>
<p>Fortunately, there are only two of them, and both are very similar to the functor laws we discussed in the previous chapter; that is, the <em>identity</em> and <em>associativity</em> laws. </p>
<p>The identity law states that applying <kbd>flatMap</kbd> and <kbd>unit</kbd> should return the original argument. Depending on the order of application, there are left and right identities. We'll represent them formally as usual with <kbd>ScalaCheck</kbd> properties (the following snippet does not show the implicit parameters; please consult the accompanying code for the full definition):</p>
<pre><span>val </span>leftIdentity = <span>forAll </span>{ as: <span>M</span>[<span>A</span>] =&gt;<br/>  M.flatMap(as)(M.unit(_)) == as<br/>}</pre>
<p>The left identity stipulates that the result of using <kbd>flatMap</kbd> over the argument by lifting it into the context of the monad should be equal to the original argument.</p>
<p>The right identity is a bit more complex:</p>
<pre><span>val </span>rightIdentity = <span>forAll </span>{ (a: <span>A</span><span>, </span>f: <span>A </span>=&gt; <span>M</span>[<span>B</span>]) =&gt;<br/>  M.flatMap(M.unit(a))(f) == f(a)<br/>}</pre>
<p>Basically, the rule is that lifting <kbd>a</kbd> into the context and then flatmapping it with some function, <kbd>f</kbd>, should produce the same result as <span>applying this function to <kbd>a</kbd> directly.</span></p>
<p>Now, all we need to do is combine both of these properties into a single identity property. We'll need quite a bit of different <kbd>implicit Arbitrary</kbd> arguments in order to generate input data, including <kbd>A, M[A]</kbd> and <kbd>A =&gt; M[B]</kbd>, but the property itself should be anything but surprising:</p>
<pre><span>import org.scalacheck._<br/>import org.scalacheck.Prop._<br/><br/>def </span><span>id</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>M</span>[_]](<span>implicit </span>M: Monad[<span>M</span>]<span>,<br/></span><span>                   </span>arbFA: Arbitrary[<span>M</span>[<span>A</span>]]<span>,<br/></span><span>                   </span>arbFB: Arbitrary[<span>M</span>[<span>B</span>]]<span>,<br/></span><span>                   </span>arbA: Arbitrary[<span>A</span>]<span>,<br/></span><span>                   </span>cogenA: Cogen[<span>A</span>]): Prop = {<br/>  <span>val </span>leftIdentity = <span>forAll </span>{ as: <span>M</span>[<span>A</span>] =&gt;<br/>    M.flatMap(as)(M.unit(_)) == as<br/>  }<br/>  <span>val </span>rightIdentity = <span>forAll </span>{ (a: <span>A</span><span>, </span>f: <span>A </span>=&gt; <span>M</span>[<span>B</span>]) =&gt;<br/>    M.flatMap(M.unit(a))(f) == f(a)<br/>  }<br/>  leftIdentity &amp;&amp; rightIdentity<br/>}</pre>
<p>The associativity property says that flatmapping using functions in succession should be the same as applying functions in the context of the monad:</p>
<pre><span>forAll</span>((a: <span>M</span>[<span>A</span>]<span>, </span>f: <span>A </span>=&gt; <span>M</span>[<span>B</span>]<span>, </span>g: <span>B </span>=&gt; <span>M</span>[<span>C</span>]) =&gt; {<br/>  <span>val </span>leftSide = M.flatMap(M.flatMap(a)(f))(g)<br/>  <span>val </span>rightSide = M.flatMap(a)(a =&gt; M.flatMap(f(a))(g))<br/>  leftSide == rightSide<br/>})</pre>
<p>We'll omit the definition of the implicit parameters for this and a combination rule:</p>
<pre><span>def </span><span>monad</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>C</span><span>, </span><span>M</span>[_]](<span>implicit </span>M: Monad[<span>M</span>]<span>, ...</span>): Prop = {<br/>  <span>id</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>M</span>] &amp;&amp; <span>associativity</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>C</span><span>, </span><span>M</span>]<br/>}</pre>
<div class="packt_infobox">Please look up the source code in GitHub to see the full signature of these properties.</div>
<p>Now that we have an understanding of what methods we need to define and how they should behave, let's implement some monads! We'll need to know the internals of the respective containers in order to implement the <kbd>flatMap</kbd>. In the previous chapter, we implemented the <kbd>map</kbd> method by delegating to the underlying container. Now, we'll use a low-level approach to show that the knowledge of the structure is indeed necessary. </p>
<p>As usual, we will start with the simplest of the standard effects, <kbd>Option</kbd>. This is how we implement <kbd>Monad[Option]</kbd>:</p>
<pre><span>implicit val </span><span>optionMonad </span>= <span>new </span>Monad[Option] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): Option[<span>A</span>] = <span>Some</span>(a)<br/><br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: Option[<span>A</span>])(f: <span>A </span>=&gt; Option[<span>B</span>]): Option[<span>B</span>] = a <span>match </span>{<br/>    <span>case </span><span>Some</span>(value) =&gt; f(value)<br/>    <span>case </span>_ =&gt; None<br/>  }<br/>}</pre>
<p>The implementation of <kbd>unit</kbd> should be apparent—the only way to turn <kbd>A</kbd> into <kbd>Option[A]</kbd> is by wrapping it. Like we did previously, we're using the case class constructor directly to preserve the structure in the case that <kbd>a</kbd> is <kbd>null</kbd>.</p>
<p>The <kbd>flatMap</kbd> implementation is also very transparent—we can't apply a given function to <kbd>None</kbd>, and hence we return <kbd>None</kbd> as is. In the case that we have provided <kbd>a</kbd> is defined, we unwrap the value and apply <kbd>f</kbd> to it. This <em>unwrapping</em> is exactly the moment where we're using our knowledge of the internals of <kbd>Option</kbd> to flatten the potentially nested result.</p>
<p>We can check that our implementation obeys monadic laws by defining a couple of properties for different types of <kbd>a</kbd> and <kbd>f</kbd>:. These properties need to be placed in a class extending <kbd>org.scalacheck.Properties</kbd>, as usual:</p>
<pre><span>property</span>(<span>"Monad[Option] and Int =&gt; String, String =&gt; Long"</span>) = {<br/>  <span>monad</span>[<span>Int, </span><span>String</span><span>, Long, </span>Option]<br/>}<br/><span>property</span>(<span>"Monad[Option] and String =&gt; Int, Int =&gt; Boolean"</span>) = {<br/>  <span>monad</span>[<span>String</span><span>, Int, Boolean, </span>Option]<br/>}<br/>+ Monad.Monad[Option] and Int =&gt; String, String =&gt; Long: OK, passed 100 tests.<br/>+ Monad.Monad[Option] and String =&gt; Int, Int =&gt; Boolean: OK, passed 100 tests.</pre>
<p>Given that our properties hold for two different types of <kbd>a</kbd> and two different types of functions, we can be pretty sure that our code is correct and proceed with other containers.</p>
<p>For <kbd>Either</kbd>, we have a small complication, exactly like we had when we defined a Functor for it - two type parameters instead of one required by the <kbd>Monad</kbd>. Are you ready to deal with it the same way as before<span>—</span>by fixing the second type parameter and using the type lambda to define the final type of the monad? The good news is that we won't need to do this! The type lambda is such a common thing that's used in type class programming that many people craved an easier way to do this. This is the projector that plugin was created for. It allows us to use simplified syntax for type lambdas in Scala.</p>
<p>All we need to do so that we can start using the plugin is add the dependency to our project configuration in the <kbd>build.sbt</kbd> file:</p>
<pre>addCompilerPlugin(<span>"org.spire-math" </span>%% <span>"kind-projector" </span>% <span>"0.9.8"</span>)</pre>
<p>Now that we have this, we can simplify the type lambda syntax from our usual <kbd>({type T[A] = Either[L, A]})#T</kbd> to just <kbd>Either[L, ?]</kbd>. The plugin is feature-rich, and we will not go into further details here; visiting the documentation page at <a href="https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7">https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7</a> is highly recommended.</p>
<p>With our new tool, the definition of <kbd>eitherMonad</kbd> is easy to read:</p>
<pre><span>implicit def </span><span>eitherMonad</span>[<span>L</span>] = <span>new </span>Monad[<span>Either</span>[<span>L</span><span>, </span>?]] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>Either</span>[<span>L</span><span>, </span><span>A</span>] = <span>Right</span>(a)<br/><br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: <span>Either</span>[<span>L</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; <span>Either</span>[<span>L</span><span>, </span><span>B</span>]): <span>Either</span>[<span>L</span><span>, </span><span>B</span>] = a <span>match </span>{<br/>    <span>case </span><span>Right</span>(r) =&gt; f(r)<br/>    <span>case </span><span>Left</span>(l) =&gt; <span>Left</span>(l)<br/>  }<br/>}</pre>
<p>The type class constructor takes a type parameter, <kbd>L</kbd>, for the left side of <kbd>Either</kbd>. The rest of the implementation should be very familiar by now. It's worth reminding yourself that <kbd>Either</kbd> is right-biased—this it the reason we're returning <kbd>Right</kbd> from the <kbd>unit</kbd> method. It's also worth mentioning the last case in the <kbd>flatMap</kbd> pattern match where we repacked <kbd>l</kbd> from <kbd>Left<span>[L, A]</span></kbd> into <kbd>Left<span>[L, B]</span></kbd>. This is done to help the compiler infer the correct return type<span>.</span></p>
<p>For the property definition, we also have to fix a type of the left side. We can do this by defining a type alias, which will improve readability:</p>
<pre><span>type </span><span>UnitEither</span>[<span>R</span>] = <span>Either</span>[<span>Unit, </span><span>R</span>]<br/><br/><span>property</span>(<span>"Monad[UnitEither[Int]] and Int =&gt; String, String =&gt; Long"</span>) = {<br/>  <span>monad</span>[<span>Int, </span><span>String</span><span>, Long, </span><span>UnitEither</span>]<br/>}<br/><br/><span>property</span>(<span>"Monad[UnitEither[String]] and String =&gt; Int, Int =&gt; Boolean"</span>) = {<br/>  <span>monad</span>[<span>String</span><span>, Int, Boolean, </span><span>UnitEither</span>]<br/>}</pre>
<p>Except for the type alias, the definition of properties is the same as we had for <kbd>Option</kbd>.</p>
<p>The definition of <kbd>Monad[Try]</kbd> is done by analogy, and we'll leave it as an exercise for the reader.</p>
<p>In contrast, <kbd>Monad[List]</kbd> (or <kbd>Monad[Bucket]</kbd>, if we're to use terms from the previous chapter) is quite different as the <kbd>List</kbd> can contain more than one element:</p>
<pre><span>implicit val </span><span>listMonad </span>= <span>new </span>Monad[<span>List</span>] {<br/>  <span>def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>) = <span>List</span>(a)<br/><br/>  <span>def </span><span>flatMap</span>[<span>A</span><span>,</span><span>B</span>](as: <span>List</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>List</span>[<span>B</span>]): <span>List</span>[<span>B</span>] = as <span>match </span>{<br/>    <span>case </span><span>Nil </span>=&gt; <span>Nil<br/></span><span>    </span><span>case </span>a <span>:: </span>as =&gt; f(a) ::: flatMap(as)(f)<br/>  }<br/>}</pre>
<p>The <kbd>unit</kbd> is implemented in the same way as the other effects were<span>—</span>just by wrapping its argument. The <kbd>flatMap</kbd> is defined in a recursive manner. For <kbd>Nil</kbd>, we return <kbd>Nil</kbd>. This case is analogous to the case of <kbd>None</kbd> in <kbd>Monad[Option]</kbd>. In the case of a non-empty list, we have to apply the given function to all of the elements of the list and flatten the result at the same time. This is done in the second matching case.</p>
<p>Let's see if our property holds:</p>
<pre><span>property</span>(<span>"Monad[List] and Int =&gt; String, String =&gt; Long"</span>) = {<br/>  <span>monad</span>[Int<span>, </span>String<span>, </span>Long<span>, </span>List]<br/>}<br/><span>property</span>(<span>"Monad[List] and String =&gt; Int, Int =&gt; Boolean"</span>) = {<br/>  <span>monad</span>[String<span>, </span>Int<span>, </span>Boolean<span>, </span>List]<br/>}<br/>+ Monad.Monad[List] and Int =&gt; String, String =&gt; Long: OK, passed 100 tests.<br/>+ Monad.Monad[List] and String =&gt; Int, Int =&gt; Boolean: OK, passed 100 tests.</pre>
<p>It looks like it is, but the only reason for this is that the list generator in <kbd>ScalaCheck</kbd> does not generate input lists of a significant size. If it did, our property would fail with <kbd>StackOverflowError</kbd> because it is not tail-recursive!</p>
<p>Let's fix this by using the techniques that we discussed in <a href="9f67be8e-4fee-4050-ab96-8444bb795138.xhtml">Chapter 3</a>, <em>Deep Dive into Functions</em>:</p>
<pre><span>override def </span><span>flatMap</span>[<span>A</span><span>,</span><span>B</span>](as: <span>List</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>List</span>[<span>B</span>]): <span>List</span>[<span>B</span>] = {<br/>  <span>@tailrec<br/></span><span>  </span><span>def </span><span>fMap</span>(as: <span>List</span>[<span>A</span>]<span>, </span>acc: <span>List</span>[<span>B</span>])(f: <span>A </span>=&gt; <span>List</span>[<span>B</span>]): <span>List</span>[<span>B</span>] = as <span>match </span>{<br/>    <span>case </span><span>Nil </span>=&gt; acc<br/>    <span>case </span>a <span>:: </span>aas =&gt; fMap(aas<span>, </span>acc ::: f(a))(f)<br/>  }<br/>  fMap(as<span>, </span><span>Nil</span>)(f)<br/>}</pre>
<p>Now that we have made our implementation tail-recursive by introducing the accumulator, we can safely use it with lists of an arbitrary length. But this approach is still quite direct and slow because of that. On my laptop, this implementation consumed approximately five times more time than the "native" optimized implementation of List's <kbd>flatMap</kbd> method. It turns out that this is exactly the case where delegating makes sense:</p>
<pre><span>override def </span><span>flatMap</span>[<span>A</span><span>,</span><span>B</span>](as: <span>List</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>List</span>[<span>B</span>]): <span>List</span>[<span>B</span>] = as.flatMap(f)</pre>
<p>OK, so we have ignored <kbd>Future</kbd>, but have implemented type class instances for all of the containers we discussed in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects</em>. Are we done with monads? It turns out that we're not—<span>not by a long shot</span>. Just like it's possible to define an indefinite number of applicatives for different types constructors as long as the applicative properties hold, it is possible to do the same with monads.</p>
<p>In the following section, we'll put some widely used monads such as Id, State, Reader, and Writer into code and discuss what are they good for.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Id Monad</h1>
                </header>
            
            <article>
                
<p>The same way <kbd>Option</kbd> encodes optionality, the <kbd>Id</kbd> represents <em>nothing special</em>. It wraps a value but does nothing with it. Why would we need something that's <em>not a thing</em><span>? The</span> <kbd>Id</kbd> <span>is kind of a</span> <em>meta-lifting</em><span>, which can</span> represent <span>anything as an effect without changing it. How can this be done? Well, first of all, we have to say to the compiler that an</span> <kbd>Id[A]</kbd> <span>is the same thing as an</span> <kbd>A</kbd><span>. This is easily done with a type alias:</span></p>
<pre><span>type </span><span>Id</span>[<span>A</span>] = <span>A<br/></span></pre>
<p>This type definition will dictate the details of the monad's implementation:</p>
<pre><span>implicit val </span><span>idMonad </span>= <span>new </span>Monad[<span>Id</span>] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>Id</span>[<span>A</span>] = a<br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: <span>Id</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>Id</span>[<span>B</span>]): <span>Id</span>[<span>B</span>] = f(a)<br/>}</pre>
<p>Obviously, <kbd>unit(a)</kbd> is just <kbd>a</kbd>, and by having the type alias we just defined, we're making the compiler believe that it is not of type <kbd>A</kbd>, but an <kbd>Id[A]</kbd>. Similarly, with the <kbd>flatMap</kbd>, we can't do anything fancy, so we're just applying the given function <kbd>f</kbd> to <kbd>a</kbd>, utilizing the fact that <kbd>Id[A]</kbd> is actually just <kbd>A</kbd>.</p>
<p>Obviously, as we're doing nothing, the monadic laws should hold. But just to be 100% sure, we'll encode them as properties:</p>
<pre><span>property</span>(<span>"Monad[Id] and Int =&gt; String, String =&gt; Long"</span>) = {<br/>  <span>monad</span>[<span>Int, </span><span>String</span><span>, Long, </span><span>Id</span>]<br/>}<br/><span>property</span>(<span>"Monad[Id] and String =&gt; Int, Int =&gt; Boolean"</span>) = {<br/>  <span>monad</span>[<span>String</span><span>, Int, Boolean, </span><span>Id</span>]<br/>}<br/>+ Monad.Monad[Id] and Int =&gt; String, String =&gt; Long: OK, passed 100 tests.<br/>+ Monad.Monad[Id] and String =&gt; Int, Int =&gt; Boolean: OK, passed 100 tests.</pre>
<p class="mce-root">The property holds—what else would you expect from something that does nothing? But why do we need this something in the first place? </p>
<p>This question has multiple answers. From an abstract perspective, the <kbd>Id</kbd> monad carries the function of (surprise!) an identity element in the space of monads in the same way that zero or one are the identity elements in the space of numbers under addition or multiplication. Because of this, it can be used as a placeholder for monad transformers (we'll learn about them in the next chapter). It can also be useful in a situation where in existing code expects a monad but we don't need one. We will see how this approach works later in this chapter.</p>
<p>Now that we have got our feet wet with the simplest monad, it is time to do something more involving<span>—</span>implementing the State monad.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">State monad</h1>
                </header>
            
            <article>
                
<p>In imperative programming, we have the concept of global variables—variables that are available anywhere in the program. This approach is considered to be a bad practice, but is still used quite often. The concept of global state extends global variables by including system resources. As there is only one filesystem or system clock, it totally makes sense to make them globally and universally accessible from anywhere in the program code, right?</p>
<p>In JVM, some of these global resources are available via the <kbd>java.lang.System</kbd> class. It contains, for instance, references to "standard" input, output, and error streams, the system timer, environment variables, and properties. The global state should definitely be a good idea, then, if Java exposes it on a language level!</p>
<p>The problem with global state is that it breaks the <em>referential transparency</em> of the code. In essence, referential transparency means that it should always be possible to replace a part of the code, for example, a function call, with the result of the evaluation of this call everywhere in the program, and this change should not cause observable changes in program behaviour.</p>
<p>The concept of referential transparency is closely related to the concept of a <kbd>pure function</kbd>—a function is pure if it is referentially transparent for all its referentially transparent arguments.</p>
<p>We will see how this works in a moment, but for starters, please consider the following example:</p>
<pre><span>var </span><span>globalState </span>= <span>0<br/></span><span><br/></span><span>def </span><span>incGlobal</span>(count: <span>Int</span>): <span>Int </span>= {<br/>  <span>globalState </span>+= count<br/>  <span>globalState<br/></span>}<br/><br/><span>val </span><span>g1 </span>= <span>incGlobal</span>(<span>10</span>) <span>// g1 == 10<br/></span><span>val </span><span>g2 </span>= <span>incGlobal</span>(<span>10</span>) <span>// g1 == 20</span></pre>
<p>In the case of <kbd>incGlobal</kbd>, the function is not pure because it is not referentially transparent (because we cannot replace a call of it with the result of evaluation since these results are different each time the function is called). This makes it impossible to reason about the possible outcomes of the program without knowing the global state at every moment it is accessed or modified.</p>
<p>In contrast, the following function is referentially transparent and pure:</p>
<pre><span>def </span><span>incLocal</span>(count: <span>Int, </span>global: <span>Int</span>): <span>Int </span>= global + count<br/><br/><span>val </span><span>l1 </span>= <span>incLocal</span>(<span>10</span><span>, </span><span>0</span>) <span>// l1 = 10<br/></span><span>val </span><span>l2 </span>= <span>incLocal</span>(<span>10</span><span>, </span><span>0</span>) <span>// l2 = 10</span></pre>
<p>In functional programming, we are expected to use only pure functions. This makes global state as a concept unsuitable for functional programming.</p>
<p>But there are still many cases where it is necessary to accumulate and modify state, but how should we deal with that?</p>
<p>This is where the <kbd>State</kbd> monad comes into play. The state monad is build around a function that takes a relevant part of the <em>global state</em> as an argument and returns a result and modified state (of course, without changing anything in a <em>global</em> sense). The signature of such a function looks like this: <kbd>type StatefulFunction[S, A] = S =&gt; (A, S)</kbd>.</p>
<p>We can wrap this definition into a case class to simplify the definition of helper methods on it. This <kbd>State</kbd> class will denote our effect:</p>
<pre><span>final case class </span>State[<span>S</span><span>, </span><span>A</span>](run: <span>S </span>=&gt; (<span>A</span><span>, </span><span>S</span>))</pre>
<p>We can also define a few constructors in the companion object so that we're able to create a state in three different situations (to do this in REPL you need to use <kbd>:paste</kbd> command and paste <em>both</em> the case class and a companion object, then press <em>Ctrl</em> + <em>D</em>:</p>
<pre><span>object </span>State {<br/>  def apply[S, A](a: =&gt; A): State[S, A] = State(s =&gt; (a, s))<br/>  <span>def </span><span>get</span>[<span>S</span>]: State[<span>S</span><span>, </span><span>S</span>] = <span>State</span>(s =&gt; (s<span>, </span>s))<br/>  <span>def </span><span>set</span>[<span>S</span>](s: =&gt; <span>S</span>): State[<span>S</span><span>, Unit</span>] = <span>State</span>(_ =&gt; (()<span>, </span>s))<br/>}</pre>
<p>The default constructor lifts some value, <kbd>a: A</kbd>, into the context of <kbd>State</kbd> by returning the given argument as a result and propagating the existing state without changes. The getter creates a <kbd>State</kbd> that wraps some function, returning the given argument both as the state and as a result. The setter wraps the <kbd>State</kbd> over the function, which takes a state to be wrapped and produces no result. The semantics of these are similar to reading the global state (hence the result is the equal state) and setting it (hence the result is <kbd>Unit</kbd>), but applied to <kbd>s: S</kbd>.</p>
<p>For now, the <kbd>State</kbd> is nothing but a thin wrapper around some computation which involves pushing through (and potentially changing) a bit of state. What we would like to be able to do is compose this computation with the next one. We'd like to do this similarly to how we compose functions, but instead of <kbd>(A =&gt; B) compose (B =&gt; C)</kbd>, we now have <kbd>State[S, A] compose State[S, B]</kbd>. How can we do this?</p>
<p>By definition, our second computation accepts the result of the first one as its argument, hence we start with <kbd>(a: A) =&gt;</kbd> . We also stated that, as a result (because of the possible state change and return type of the second state), we'll have a <kbd>State[S, B]</kbd>  which gives us a full signature for the computation to compose with the first one: <kbd>f: A =&gt; State[S, B]</kbd> .</p>
<p>We can implement this composition as a method on <kbd>State</kbd>:</p>
<pre><span>final case class </span>State[<span>S</span><span>, </span><span>A</span>](run: <span>S </span>=&gt; (<span>A</span><span>, </span><span>S</span>)) {<br/>  <span>def </span><span>compose</span>[<span>B</span>](f: <span>A </span>=&gt; State[<span>S</span><span>, </span><span>B</span>]): State[<span>S</span><span>, </span><span>B</span>] = {<br/>    <span>val </span>composedRuns = (s: <span>S</span>) =&gt; {<br/>      <span>val </span>(a<span>, </span>nextState) = run(s)<br/>      f(a).run(nextState)<br/>    }<br/>    <span>State</span>(composedRuns)<br/>  }<br/>}</pre>
<p>We define our composed computation as a combination of two runs. The first is done with the input provided to the first state, which we decompose into the result and a next state. We then call the provided transformation <kbd>f</kbd> on the result and <kbd>run</kbd> it with the next state. These two successive runs might seem strange at first glance, but they just represent the fact that we're fusing two <kbd>run</kbd> functions from different states into one function defined on the composed state.</p>
<p>Now, we have an effect and can create a monad for it. You should have noticed by now that the signature of the <kbd>compose</kbd> method we just defined is the same as that of the monadic <kbd>flatMap</kbd>.</p>
<div class="packt_infobox">The <kbd>compose</kbd> in this and the following cases does not refer to the function composition we learned about in <a href="9f67be8e-4fee-4050-ab96-8444bb795138.xhtml">Chapter 3</a>, <em>Deep Dive into Functions</em>, but to the concept of Kleisli composition. It is often called Kleisli arrow, and in essence is just a wrapper over the <kbd>A =&gt; F[B]</kbd> function, which allows for the composition of functions returning monadic values. It is frequently named <kbd>&gt;&gt;=</kbd>, but we'll stick to <kbd>compose</kbd> here.</div>
<p>This allows us to delegate monadic behavior to the logic we already have in the <kbd>State</kbd>, the same way as we could do for standard effects:</p>
<pre><span>import ch09._<br/>implicit def </span><span>stateMonad</span>[<span>S</span>] = <span>new </span>Monad[State[<span>S</span><span>, </span>?]] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): State[<span>S</span><span>, </span><span>A</span>] = <span>State</span>(a)<br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: State[<span>S</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; State[<span>S</span><span>, </span><span>B</span>]): State[<span>S</span><span>, </span><span>B</span>] = a.compose(f)<br/>}</pre>
<p>Luckily, we can also delegate the lifting done by the <kbd>unit</kbd> to the default constructor! This means that we're done with the definition of the monad and can continue with our rigorous testing approach by specifying a property check for it.</p>
<p>Except in this case, we won't.</p>
<p>The rationale behind this is the fact that the <kbd>State</kbd> is quite different from the other effects we looked at until now in regard to the value it incorporates. The <kbd>State</kbd> is the first effect which is built <em>exclusively</em> around some function. Technically, because functions are first-class values in Scala, other effects such as <kbd>Option</kbd> could also contain a function and not a value, but this is an exception.</p>
<p>This brings complications to our testing attempts. Earlier, we modified the value contained in the effect in different ways and checked that the results we equal, as required by the monadic laws, by comparing them. With the requirement to have a function as a value of the effect, we face the challenge of comparing two functions for equality. At the time of writing this book, this is a topic of active academic research. For our practical purposes, there is currently no other way to prove that two functions are equal other than testing them for each possible input parameter(s) and checking whether they return same results—<span>w</span>hich we obviously cannot afford to do in our properties.</p>
<p>Instead, we will <em>prove</em> that our implementation is correct. We will use a method called the <em>substitution model</em> for this. The essence of the method is in using referential transparency in order to substitute all of the variables and function calls with values they return repeatedly until the resulting code can't be simplified anymore—very much like solving an algebraic equation.</p>
<p>Let's see how this works.</p>
<p>To get us prepared before proving the monadic laws, we'll prove a useful lemma first.</p>
<p>The lemma is stated as follows: having <kbd>as: M[A], f: A =&gt; M[B]</kbd> and <kbd><span>M = State</span></kbd> so that <kbd>as.run = s =&gt; (a, s1)</kbd> (the run method returns a pair of <kbd>a</kbd> and <kbd>s1</kbd> for some input <kbd>s</kbd> and <kbd>f(b) = (b: A) =&gt; State(s1 =&gt; (b, s2)</kbd>), <kbd>M.flatMap(as)(f)</kbd> will always yield <kbd>State(s =&gt; (b, s2))</kbd>.</p>
<p>This is how we're getting this formula:</p>
<ol>
<li>By definition, <kbd>as.run = s =&gt; (a, s1)</kbd>, which gives us <kbd>as = State(s =&gt; (a, s1))</kbd></li>
<li>The <kbd>flatMap</kbd><span> delegates to the</span> <kbd>compose</kbd> <span>method defined on </span><kbd>State</kbd><span>, and therefore</span> <kbd>M.flatMap(a)(f)</kbd> <span>for</span> <kbd>M = State</kbd> <span>becomes</span> <kbd>a.compose(f)</kbd></li>
<li>In terms of <kbd>as</kbd> <span>and</span> <kbd>f</kbd><span>, </span><kbd>as.compose(f)</kbd> <span>can be formulated as</span> <kbd>State(s =&gt; (a, s1)).compose(f)</kbd></li>
</ol>
<p>Now, we're going to substitute the call of the <kbd>compose</kbd> method with its definition:</p>
<pre>State(s =&gt; (a, s1)).compose(f) = State(s =&gt; {<br/>  f(a).run(s1) // substituting f(a) with the result of the call<br/>}) = State(s =&gt; {<br/>  State(s1 =&gt; (b, s2)).run(s1)<br/>}) = State(s =&gt; (b, s2))</pre>
<p>Here, we have proved our assumption that <kbd>Monad[State].flatMap(as)(f) = State(s =&gt; (b, s2))</kbd> for <kbd>as = State(s =&gt; (a, s1))</kbd> and <kbd>f(a) = (b: A) =&gt; State(s1 =&gt; (b, s2))</kbd>.</p>
<p>Now, we can use this lemma while proving the monadic laws for <kbd>State</kbd>.</p>
<p>We'll start with the identity laws, and more specifically, with the left identity. This is how we formulated it in our <kbd>ScalaCheck</kbd> property:</p>
<pre><span>val </span>leftIdentity = <span>forAll </span>{ as: <span>M</span>[<span>A</span>] =&gt;<br/>  M.flatMap(as)(M.unit(_)) == as<br/>}</pre>
<p>Thus, we want to prove that if we let <kbd>M = State</kbd>, then every <kbd>as: M[A]</kbd> following it is always true:</p>
<pre>M.flatMap(as)(M.unit(_)) == as</pre>
<p>Let's simplify the left side of the equation first. By definition, we can replace <kbd>as</kbd> with <kbd>State</kbd> implementation:</p>
<pre>M.flatMap(State(s =&gt; (a, s1)))(M.unit(_))</pre>
<p>The next step that we must do is substitute the call of the <kbd>unit</kbd> method with its implementation. We're just delegating to the default constructor of the <kbd>State</kbd>, which is defined as follows:</p>
<pre> def apply[S, A](a: =&gt; A): State[S, A] = State(s =&gt; (a, s))</pre>
<p>Hence, our definition becomes the following:</p>
<pre> M.flatMap(State(s =&gt; (a, s1)))(b =&gt; State(s1 =&gt; (b, s1)))</pre>
<p>To substitute the <kbd>flatMap</kbd> call, we have to recall that all it does is just delegate to the <kbd>compose</kbd> method defined on <kbd>State</kbd>:</p>
<pre>State(s =&gt; (a, s1)).compose(b =&gt; State(s1 =&gt; (b, s1)))</pre>
<p>Now, we can use our lemma for state composition, which gives us the following simplified form:</p>
<pre><span>State(s =&gt; (a, s1))</span></pre>
<p>This can't be simplified further, so we will now take a look at the right side of equation, <kbd>as</kbd>. Again, by definition, <kbd>as</kbd> can be represented as <kbd>State(s =&gt; (a, s1))</kbd>. This gives us final proof that <kbd>State(s =&gt; (a, s1)) == State(s =&gt; (a, s1))</kbd>, which always holds for any <kbd>a: A</kbd>.</p>
<p>The right side identity is proved similarly to the left side, and we leave this as an exercise to the reader.</p>
<p>The second law we need to prove is the associative law. Let's recall how it is described in ScalaCheck terms:</p>
<pre><span>forAll</span>((as: <span>M</span>[<span>A</span>]<span>, </span>f: <span>A </span>=&gt; <span>M</span>[<span>B</span>]<span>, </span>g: <span>B </span>=&gt; <span>M</span>[<span>C</span>]) =&gt; {<br/>  <span>val </span>leftSide = M.flatMap(M.flatMap(as)(f))(g)<br/>  <span>val </span>rightSide = M.flatMap(as)(a =&gt; M.flatMap(f(a))(g))<br/>  leftSide == rightSide<br/>})</pre>
<p>Let's see what we can do with that, starting with the  <kbd>leftSide</kbd>,  <kbd>M.flatMap(M.flatMap(as)(f))(g)</kbd>.</p>
<p>By substituting <kbd>M</kbd> with <kbd>State</kbd> in the internal part, <kbd>M.flatMap(as)(f)</kbd> becomes <kbd>State(s =&gt; (a, s1)).compose(f)</kbd>, which by the application of our lemma transforms it into <kbd>State(s =&gt; (b, s2))</kbd>.</p>
<p>Now, we can substitute the outer <kbd>flatMap</kbd>:</p>
<p><kbd>M.flatMap(State(s =&gt; (b, s2)))(g)</kbd> is the same as  <kbd>State(s =&gt; (b, s2)).compose(g)</kbd> <strong>(1)</strong></p>
<p>Let's leave it in this form and look at the <kbd>rightSide</kbd>: <kbd>M.flatMap(as)(a =&gt; M.flatMap(f(a))(g))</kbd>.</p>
<p>First we substitute the internal <kbd>flatMap</kbd> with the <kbd>compose</kbd>, before turning <span><kbd>a =&gt; M.flatMap(f(a))(g)</kbd> into <kbd>(a: A) =&gt; f(a).compose(g)</kbd>.</span></p>
<p>Now, by the definition of <kbd>f</kbd> we used for the left side, we have <kbd>f(a) = a =&gt; State(s1 =&gt; (b, s2))</kbd> and thus the internal <kbd>flatMap</kbd> becomes <kbd>a =&gt; State(b, s2).compose(g)</kbd>.</p>
<p>Replacing the outer <kbd>flatMap</kbd> with <kbd>compose</kbd> gives us—in combination with the previous definition<span>—</span><kbd>State(s =&gt; (a, s1)).compose(a =&gt; State(s1 =&gt; (b, s2)).compose(g))</kbd>.</p>
<p>We'll use our lemma again to substitute the first application of <kbd>compose</kbd>, which will have <kbd><span>State(s =&gt; (b, s2)).compose(g)</span></kbd> <strong> </strong>as the outcome. <strong>(2)</strong></p>
<p><strong>(1)</strong> and <strong>(2)</strong> are identical, which means that the <kbd>leftSide</kbd> and <kbd>rightRide</kbd> of our property are always equal; we just proved the associativity law.</p>
<p>Great, we have an implementation of the <kbd>State</kbd> and the corresponding monad, which has been proven to be correct. It's time to look at them in action. As an example, let's imagine that we're going fishing by boat. The boat has a position and direction, and can go forward for some time or change <span>direction</span>:</p>
<pre><span>final case class </span>Boat(direction: <span>Double, </span>position: (<span>Double, Double</span>)) {<br/>  <span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>): Boat = ??? // please see the accompanying code<br/>  <span>def </span><span>turn</span>(angle: <span>Double</span>): Boat = ??? // please see the accompanying code<br/>}</pre>
<p>We could go around with this boat by calling its methods:</p>
<pre>scala&gt; import ch09._<br/>import ch09._<br/>scala&gt; val boat = Boat(0, (0d, 0d))<br/>boat: Boat = Boat(0.0,(0.0,0.0))<br/>scala&gt; boat.go(10, 5).turn(0.5).go(20, 20).turn(-0.1).go(1,1)<br/>res1: Boat = Boat(0.4,(401.95408575015193,192.15963378398988))</pre>
<p>There is a problem with this approach, though—it does not include fuel consumption. Unfortunately, this aspect was not envisioned at the time the boat's navigation was developed, and has been added later as a global state. We will now refactor the old style with the state monad. If the quantity of fuel is modelled as a number of litres, the most straightforward way to define the state is as follows:</p>
<pre>type FuelState = State[Float, Boat]</pre>
<p>Now, we can define our boat moving logic that takes <span>fuel consumption </span>into account. But before doing that, we are going to simplify the syntax of our monadic calls a bit. Currently, the <kbd>flatMap</kbd> and <kbd>map</kbd> methods of our Monad take two parameters—the container and the function to apply to the container.</p>
<p>We would like to create a wrapper that will incorporate both the effect and a monad so that we have an instance of the effect and only need to pass the transforming function to the mapping methods. This is how we can express this approach:</p>
<pre><span>object </span>lowPriorityImplicits {<br/>  <span>implicit class </span>MonadF[<span>A</span><span>, </span><span>F</span>[_] : Monad](<span>val </span>value: <span>F</span>[<span>A</span>]) {<br/>    <span>private val </span><span>M </span>= <span>implicitly</span>[Monad[<span>F</span>]]<br/>    <span>def </span><span>unit</span>(a: <span>A</span>) = <span>M</span>.unit(a)<br/>    <span>def </span><span>flatMap</span>[<span>B</span>](fab: <span>A </span>=&gt; <span>F</span>[<span>B</span>]): <span>F</span>[<span>B</span>] = <span>M</span>.flatMap(value)(fab)<br/>    <span>def </span><span>map</span>[<span>B</span>](fab: <span>A </span>=&gt; <span>B</span>): <span>F</span>[<span>B</span>] = <span>M</span>.map(value)(fab)<br/>  }<br/>}</pre>
<p>The implicit conversion <kbd>MonadF</kbd> will wrap any effect, <kbd>F[A]</kbd>, as soon as there is an implicit monad definition available for <kbd>F</kbd>. Having <kbd><span>value</span></kbd>, we can use it as a first parameter for the <kbd>flatMap</kbd> and <kbd>map</kbd> methods defined on monad—thus, in the case of <kbd>MonadF</kbd>, they are reduced to higher-order functions taking <span>single parameters</span>. By importing this implicit conversion, we now can call <kbd>flatMap</kbd> and <kbd>map</kbd> directly on <kbd>State</kbd>:</p>
<pre><span>State</span>[<span>Float, </span>Boat](boat).flatMap((boat: Boat) =&gt; State[Float, Boat](???))</pre>
<p>We also need to create pure functions that will take fuel consumption into account while moving the boat. Assuming that we can't change the original definition of <kbd><span>Boat</span></kbd>, we have to pass the <kbd>boat</kbd> as a parameter <span>to these functions</span>:</p>
<pre><span>lazy val consumption = 1f<br/>def </span><span>consume</span>(speed: <span>Float, </span>time: <span>Float</span>) = <span>consumption </span>* time * speed<br/><span>def turn(angle: Double)(boat: Boat): FuelState =<br/>  State(boat.turn(angle))<br/>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): <span>FuelState </span>= <br/><span>  new </span>State(fuel =&gt; {<br/>    <span>val </span>newFuel = fuel - <span>consume</span>(speed<span>, </span>time)<br/>    (boat.go(speed<span>, </span>time)<span>, </span>newFuel)<br/>  })<br/><br/></pre>
<p>The <kbd>consume</kbd> function calculates fuel consumption based on <kbd>speed</kbd> and <kbd>time</kbd>. In the <kbd>turn</kbd> function, we're taking a <kbd>boat</kbd>, turning it by the specified <kbd>angle</kbd> (by delegating to the default implementation), and returning the result as an instance of <kbd>FuelState</kbd>.</p>
<p>A similar approach is used in the <kbd>go</kbd> method—to compute the boat's position, we are delegating to the boat logic. To sum the new volume of fuel available, we reduce the initial fuel quantity (which is passed as a parameter) and return the result as a part of the state. </p>
<p>We can finally create the same chain of actions we had defined initially, but this time by tracking fuel consumption:</p>
<pre><span>import Monad.lowPriorityImplicits._<br/>def </span><span>move</span>(boat: Boat) = <span>State</span>[<span>Float, </span>Boat](boat).<br/>  flatMap(<span>go</span>(<span>10</span><span>, </span><span>5</span>)).<br/>  flatMap(<span>turn</span>(<span>0.5</span>)).<br/>  flatMap(<span>go</span>(<span>20</span><span>,</span><span>20</span>)).<br/>  flatMap(<span>turn</span>(-<span>0.1</span>)).<br/>  flatMap{b: Boat =&gt; go(1,1)(b)}</pre>
<p>If you compare this snippet with the original definition, you'll see that the path of the boat is the same. However, much more is happening behind the scenes. Each call of the <kbd>flatMap</kbd> passes the state over—<span>this is</span> how it is defined in the code of the monad. In our case, the definition is the <kbd>compose</kbd> method defined on the <kbd>State</kbd>. The function given as a parameter to the <kbd>flatMap</kbd> method describes what should happen with the result and possibly with the passed state. In a sense, using monads gives us a responsibility separation<span>—</span><em>the monad describes what should happen between computation steps</em> as the result of one step being passed to the next step, and <em>our logic describes what should happen with the result before it is passed over to the next computation</em>.</p>
<p>We defined our logic with partially applied functions, which obscure what is really happening a bit<span>—</span>to make this obvious, the last step is defined using explicit syntax. We could also make the process of<span> passing</span> results between steps more explicit by using for-comprehension:</p>
<pre><span>def move</span>(boat: Boat) = <span>for </span>{<br/>  a &lt;- <span>State</span>[<span>Float, </span>Boat](boat)<br/>  b &lt;- <span>go</span>(<span>10</span><span>,</span><span>5</span>)(a)<br/>  c &lt;- <span>turn</span>(<span>0.5</span>)(b)<br/>  d &lt;- <span>go</span>(<span>20</span><span>, </span><span>20</span>)(c)<br/>  e &lt;- <span>turn</span>(-<span>0.1</span>)(d)<br/>  f &lt;- <span>go</span>(<span>1</span><span>,</span><span>1</span>)(e)<br/>} <span>yield </span>f</pre>
<p>The approach is the same as before, but just the syntax has changed—Now, passing the boat between steps is done explicitly, but the state passing had visually disappeared—The for-comprehension makes monadic code look like it's imperative. This is the result of executing both of these approaches:</p>
<pre><span>scala&gt; println</span>(<span>move</span>(<span>boat</span>).value.run(<span>1000f</span>))<br/>(Boat(0.4,(401.95408575015193,192.15963378398988)),549.0)</pre>
<p>How can we be sure that the state has been passed correctly? Well, this is what monad law guarantees. For those of you that are curious, we can even manipulate the state using methods we've defined in the state's companion object:</p>
<pre><span>def logFuelState(f: Float) = println(s"Current fuel level is $f")<br/><br/>def </span><span>loggingMove</span>(boat: Boat) = <span>for </span>{<br/>  a &lt;- <span>State</span>[<span>Float, </span>Boat](boat)<br/>  f1 &lt;- State.<span>get</span>[<span>Float</span>]<br/>  _ = <span>logFuelState</span>(f1)<br/>  _ &lt;- State.<span>set</span>(Math.<span>min</span>(<span>700</span><span>, </span>f1))<br/>  b &lt;- <span>go</span>(<span>10</span><span>,</span><span>5</span>)(a)<br/>  f2 &lt;- State.<span>get</span>[<span>Float</span>]<span>; </span>_ = <span>logFuelState</span>(f2)<br/>  c &lt;- <span>turn</span>(<span>0.5</span>)(b)<br/>  f3 &lt;- State.<span>get</span>[<span>Float</span>]<span>; </span>_ = <span>logFuelState</span>(f3)<br/>  d &lt;- <span>go</span>(<span>20</span><span>, </span><span>20</span>)(c)<br/>  f3 &lt;- State.<span>get</span>[<span>Float</span>]<span>; </span>_ = <span>logFuelState</span>(f3)<br/>  e &lt;- <span>turn</span>(-<span>0.1</span>)(d)<br/>  f3 &lt;- State.<span>get</span>[<span>Float</span>]<span>; </span>_ = <span>logFuelState</span>(f3)<br/>  f &lt;- <span>go</span>(<span>1</span><span>,</span><span>1</span>)(e)<br/>} <span>yield </span>f</pre>
<p>We augmented our previous for-comprehension with logging statements to output the current state after each step—These are the statements of the form:</p>
<pre>  f1 &lt;- State.<span>get</span>[<span>Float</span>]<br/>  _ = <span>logFuelState</span>(f1)</pre>
<p>Does it feel like we're really reading some global state? Well, in reality, what is happening is that we're getting the current <kbd>State</kbd> as a result (this is how we defined <kbd>State.get</kbd> earlier), which is passed then over to the next computation—the logging statement. Further computations just use the results of the previous steps explicitly, just like they had before. </p>
<p>Using this technique, we're also modifying the state:</p>
<pre>  _ &lt;- State.<span>set</span>(Math.<span>min</span>(<span>700</span><span>, </span>f1))</pre>
<p>Here, we're simulating that our boat has a fuel tank of a maximal capacity equal to 700. We're doing this by first reading the current state and then setting back whatever is smaller—the state passed by the caller of the <kbd>run</kbd> method or our tank capacity. The <kbd>State.set</kbd> method returns <kbd>Unit</kbd><span>—</span>this is why we ignore it.</p>
<p>The output of the definition augmented with the logging looks like this:</p>
<pre>scala&gt; println(loggingMove(boat).value.run(1000f))<br/>Current fuel level is 1000.0<br/>Current fuel level is 650.0<br/>Current fuel level is 650.0<br/>Current fuel level is 250.0<br/>Current fuel level is 250.0</pre>
<p>As we can see, the limit of 700 was applied before the first movements of the boat.</p>
<p>There is still an issue with our implementation of <kbd>move</kbd>—it uses hardcoded <kbd>go</kbd> and <kbd>turn</kbd> functions as if we would only be able to navigate one specific boat. However, this is not the case—we should be able to do this with any boat which has <kbd>go</kbd> and <kbd>turn</kbd> functionality, even if they are implemented slightly differently. We could model this by passing the <kbd>go</kbd> and <kbd>turn</kbd> functions as parameters to the <kbd>move</kbd> method:</p>
<pre><span>def </span>move(<br/>  go: (Float<span>, </span>Float) =&gt; Boat =&gt; FuelState<span>, <br/></span>  turn: Double =&gt; Boat =&gt; FuelState<br/>)(boat: Boat): FuelState</pre>
<p>This definition will allow us to have different implementations for the <kbd>go</kbd> and <kbd>turn</kbd> functions in different situations, but still, steer the boat along the given hardcoded path.</p>
<p>If we look carefully, we'll see that after creating the initial wrapper over the provided boat parameter, the definition of the <kbd>move</kbd> method has no further notion of the <kbd>State</kbd>—we need it to be a monad to be able to use for-comprehension, but this requirement is much more generic than the State we currently have.</p>
<p>We can make the <span>definition of the </span><kbd>move</kbd> function generic by improving on these two aspects<span>—</span>by passing the effect instead of creating it and making the method polymorphic:</p>
<pre>def move[A, M[_]: Monad](<br/>  go: (Float, Float) =&gt; A =&gt; M[A], <br/>  turn: Double =&gt; A =&gt; M[A]<br/>)(boat: M[A]): M[A] = for {<br/>  a &lt;- boat<br/>  b &lt;- go(<span>10</span><span>,</span><span>5</span>)(a)<br/>  // the rest of the definition is exactly like before<br/>} <span>yield </span>f</pre>
<p>Now, we can follow the given path with any type which has a monad and the <kbd>go</kbd> and <kbd>turn</kbd> functions with specified signatures. Given the fact that this functionality is now generic, we can also move it into the <kbd>Boat</kbd> companion object along with the definition of the default boat.</p>
<p>Let's see how this approach works together with the state monad. It turns out that our definition of the <kbd>go</kbd> and <kbd>turn</kbd> methods does not need to change at all. All we need to do is call the new generic <kbd>move</kbd> method:</p>
<pre><span>import </span>Boat.{<span>move</span><span>, </span><span>boat</span>}<br/><span>println</span>(<span>move</span>(go<span>, </span>turn)(State(boat)).run(<span>1000f</span>))</pre>
<p>It looks much nicer, but still there is some room for improvement. Specifically, the <kbd>turn</kbd> method does nothing but propagate the call to the default implementation. We can make it generic in the same way as we did for the <kbd>move</kbd> method:</p>
<pre><span>def </span><span>turn</span>[<span>M</span>[_]: Monad]: <span>Double </span>=&gt; Boat =&gt; <span>M</span>[Boat] =<br/>  angle =&gt; boat =&gt; <span>Monad</span>[<span>M</span>].unit(boat.turn(angle))</pre>
<p>We can't make it polymorphic in regard to the <kbd>Boat</kbd> because we need to propagate a call to the specific type, but we still have the generic monad type. This specific code uses the implicit definition of <kbd>Monad.apply</kbd> to summon the monad of a specific type.</p>
<p>Actually, we can also do the same for the <kbd>go</kbd> method—provide a default facade implementation<span>—</span><span>and</span> place them both into the companion object of the <kbd>Boat</kbd>:</p>
<pre><span>object </span>Boat {<br/>  <span>val </span><span>boat </span>= <span>Boat</span>(<span>0</span><span>, </span>(<span>0d</span><span>, </span><span>0d</span>))<br/>  <span>import </span>Monad.lowPriorityImplicits._<br/>  <span>def </span><span>go</span>[<span>M</span>[_]: Monad]: (<span>Float, Float</span>) =&gt; Boat =&gt; <span>M</span>[Boat] =<br/>    (speed<span>, </span>time) =&gt; boat =&gt; <span>Monad</span>[<span>M</span>].unit(boat.go(speed<span>, </span>time))<br/>  <span>def </span><span>turn</span>[<span>M</span>[_]: Monad]: <span>Double </span>=&gt; Boat =&gt; <span>M</span>[Boat] =<br/>    angle =&gt; boat =&gt; <span>Monad</span>[<span>M</span>].unit(boat.turn(angle))<br/>  <span>def </span><span>move</span>[<span>A</span><span>, </span><span>M</span>[_]: Monad](go: (<span>Float, Float</span>) =&gt; <span>A </span>=&gt; <span>M</span>[<span>A</span>]<span>, </span>turn: <span>Double </span>=&gt; <span>A </span>=&gt; <span>M</span>[<span>A</span>])(boat: <span>M</span>[<span>A</span>]): <span>M</span>[<span>A</span>] = // definition as above<br/>}</pre>
<p>Again, to put this definition into the REPL you need to use the <kbd>:paste</kbd> command, followed by both the definition of <kbd>boat</kbd> case class and a companion object, and a combination of <em>Ctrl</em> +<em> </em><em>D</em><span>.</span></p>
<p>Now, we can use the default implementations for the cases where we don't need to override the default behavior. For instance, we can get rid of the default <kbd>turn</kbd> implementation for the case of State and call <kbd>move</kbd> with the default one:</p>
<pre><span>import ch09._<br/>import </span>Boat.{<span>move =&gt; moveB</span><span>, </span><span>turn =&gt; turnB</span><span>, </span><span>boat</span>}<br/>import StateExample._<br/><span>type </span><span>FuelState</span>[<span>B</span>] = State[<span>Float, </span><span>B</span>]<br/><span>println</span>(<span>moveBoat</span>(<span>go</span><span>, </span><span>turnB</span>[<span>FuelState</span>])(<span>State</span>(<span>boat</span>)).run(<span>1000f</span>))</pre>
<p>We have to help the compiler to infer the correct type of monad to use by providing the type parameter, but now our definition of stateful behavior is reduced to the overriden definition of the <kbd>go</kbd> method—the rest of the code is generic.</p>
<p>As an illustration, we can reuse everything we have used so far with the <kbd>Id</kbd> monad—the result should be the same as executing the chain of calls directly on <kbd>Boat</kbd>. This is the complete implementation that's done with the <kbd>Id</kbd> monad:</p>
<pre><span>import </span>Monad.<span>Id<br/></span><span>import </span>Boat._<br/><span>println</span>(<span>move</span>(<span>go</span>[<span>Id</span>]<span>, </span><span>turn</span>[<span>Id</span>])(<span>boat</span>))</pre>
<p>Again, we're providing the type of monad to use, but this is pretty much it. Since <kbd>Id[Boat] = Boat</kbd>, we even can pass the <kbd>boat</kbd> directly without wrapping it into the <kbd>Id</kbd>.</p>
<p>Isn't that nice? We could use any monad we've defined so far to pass different effects to the main logic formulated in monadic terms. We'll leave the easy part—using existing definitions—as an exercise for the reader, and will now implement two other monads representing the read and write side of the <kbd>State</kbd>, that is, the <kbd>Reader</kbd> and <kbd>Writer</kbd> monads.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reader monad</h1>
                </header>
            
            <article>
                
<p>The <kbd>State</kbd> monad represents an external (to the definition of the logic) state, which needs to be taken into account and possibly modified. The <kbd>Reader</kbd> monad is similar in the taking into account part—it accepts an external context and passes it over unchanged to every computation down the queue. In terms of the global state we discussed during the examination of the state monad, the <kbd>Reader</kbd> will have access to read-only system properties. Because of this, the reader monad is often known as a mechanism for dependency injection—because it takes some outside configuration (not necessarily basic things like strings or numbers, but also possibly other complex components, database access mechanisms, network sockets, or other resources) and makes it available for the function it wraps.</p>
<p>Let's see how <kbd>Reader</kbd> is defined. We have already compared <kbd>State</kbd> and <kbd>Reader</kbd>, and the definition is also quite similar<span>—</span><span>with the only difference that we don't need to return the changed context (it is read-only, after all). In code, it looks like this:</span></p>
<pre><span>final case class </span>Reader[<span>R</span><span>, </span><span>A</span>](run: <span>R </span>=&gt; <span>A</span>) {<br/>  <span>def </span><span>compose</span>[<span>B</span>](f: <span>A </span>=&gt; Reader[<span>R</span><span>, </span><span>B</span>]): Reader[<span>R</span><span>, </span><span>B</span>] = <br/><span>    Reader </span>{ r: <span>R </span>=&gt; <br/>      f(run(r)).run(r)<br/>    }<br/>}</pre>
<p>The <kbd>Reader</kbd> type is just a wrapper over a function which takes a context of type <kbd>R</kbd> and returns some result of type <kbd>A</kbd>. The <kbd>flatMap</kbd> combines two <kbd>run</kbd> functions together<span>—</span>we're doing this by calling <kbd>run</kbd> with a given context, applying the given transformation to the result, and then calling the <kbd>run</kbd> for the result. The first call of the <kbd>run</kbd> is basically for <kbd>this</kbd>, while the second is for the <kbd>Reader</kbd> we're getting by applying <kbd>f</kbd>.</p>
<p>We can also define a constructor for some value that ignores any given context:</p>
<pre><span>object </span>Reader {<br/>  <span>def </span><span>apply</span>[<span>R</span><span>, </span><span>A</span>](a: =&gt; <span>A</span>): Reader[<span>R</span><span>, </span><span>A</span>] = <span>Reader</span>(_ =&gt; a)<br/>}</pre>
<p>Now that we have this model, we can have a monad for it, just like we did with the state monad<span>—</span>by using the kind-projector syntax:</p>
<pre><span>implicit def </span><span>readerMonad</span>[<span>R</span>] = <span>new </span>Monad[Reader[<span>R</span><span>, </span>?]] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): Reader[<span>R</span><span>, </span><span>A</span>] = <span>Reader</span>(a)<br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: Reader[<span>R</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; Reader[<span>R</span><span>, </span><span>B</span>]): Reader[<span>R</span><span>, </span><span>B</span>] = a.compose(f)<br/>}</pre>
<p>Unsurprisingly, the monad just delegates to both the constructor and the <kbd>compose</kbd> method we just defined. Surprisingly, now that we've done this, we're done defining the reader monad and can use it with our definition of the move function!</p>
<p>Let's imagine that we have a regulation that defines a speed limit for boats and the maximal angle they are allowed to turn at once (sounds strange, but in the place, we're fishing we have case law, so this is what we've got).</p>
<p>As this is external regulation, we have to model it with a case class:</p>
<pre><span>final case class </span>Limits(speed: <span>Float, </span>angle: <span>Double</span>)<br/><span>type </span><span>ReaderLimits</span>[<span>A</span>] = ch09.Reader[Limits<span>, </span><span>A</span>]</pre>
<p>We'll also define an alias fixes the type of context for a <kbd>Reader</kbd> to be <kbd>Limits</kbd>.</p>
<p>Now, we can redefine our <kbd>go</kbd> and <kbd>turn</kbd> methods by applying these limits, like so:</p>
<pre><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): <span>ReaderLimits</span>[Boat] =<br/>  ch09.<span>Reader</span>(limits =&gt; {<br/>    <span>val </span>lowSpeed = Math.<span>min</span>(speed<span>, </span>limits.speed)<br/>    boat.go(lowSpeed<span>, </span>time)<br/>  })<br/><br/><span>def </span><span>turn</span>(angle: <span>Double</span>)(boat: Boat): <span>ReaderLimits</span>[Boat] =<br/>  ch09.<span>Reader</span>(limits =&gt; {<br/>    <span>val </span>smallAngle = Math.<span>min</span>(angle<span>, </span>limits.angle)<br/>    boat.turn(smallAngle)<br/>  })</pre>
<p>There is nothing special about the implementation itself. The type signature of functions are predefined by the <kbd>move</kbd> method. After each action, we return <kbd>Reader[Limits, Boat]</kbd>. To calculate the new state of the boat, we delegate to its methods after figuring out the maximal speed or angle we can apply. </p>
<p>As we designed the rest of the code in a generic way, this is all we need to do—Let's <kbd>move</kbd>:</p>
<pre><span>import </span>Monad.<span>readerMonad<br/></span><span>import </span>Boat._<br/><span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>)(ch09.<span>Reader</span>(<span>boat</span>)).run(<span>Limits</span>(<span>10f</span><span>, </span><span>0.1</span>)))<br/>Boat(0.0,(250.00083305560517,19.96668332936563))</pre>
<p>To run this example, please use the SBT <kbd>run</kbd> command.</p>
<p>We're passing the <kbd>go</kbd> and <kbd>turn</kbd> functions we just defined to the generic <kbd>move</kbd> method, along with the properly wrapped <kbd>boat</kbd>, and <kbd>run</kbd> it afterward. By looking at the result, we can say that the speed limits were properly applied.</p>
<p>After scrutinizing the state monad, there is not much left to discuss the reader, so we're good to proceed to the Writer monad.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writer monad</h1>
                </header>
            
            <article>
                
<p>The <kbd>Writer</kbd> monad is a sibling of the state and the reader, oriented on modifying the state. Its main purpose is to provide a facility to write into some kind of log by passing this log between computations. The type of the log is not specified, but usually, some structure with a possibly low overhead of the append operation is chosen. To name a few suitable possibilities, you could use a <kbd>Vector</kbd> from the standard library or a <kbd>List</kbd>. In the case of the List, we need to prepend the log entries and revert the resulting log at the very end. </p>
<p>Before we get too deep into the discussion about the type of log, it is good to realize that we can defer the decision until later. All we need to know is how to append an entry to the existing log. Or, in other words, how to combine two logs, one of which contains just a single entry, together. We already know about the structure with such a functionality—it is a <kbd>Semigroup</kbd>. Actually, we also need to be able to represent an empty log, and so our end decision will be to have a <kbd>Monoid</kbd>. </p>
<p>Let's bring this together. The Writer takes two type arguments, one for the log entry, and one for the result. We also need to be able to have a <kbd>Monoid</kbd> for the log. The logic itself does not take anything from outside; it just returns the result and updated log:</p>
<pre><span>import ch07._<br/>final case class </span>Writer[<span>W</span>: Monoid<span>, </span><span>A</span>](run: (<span>A</span><span>, </span><span>W</span>))</pre>
<p>Next, we want to compose our writer with another monadic function, just like we did before:</p>
<pre>final case class Writer[W: Monoid, A](run: (A, W)) {<br/>  def compose[B](f: A =&gt; Writer[W, B]): Writer[W, B] = Writer {<br/>    val (a, w) = run<br/>    val (b, ww) = f(a).run<br/>    val www = implicitly[Monoid[W]].op(w, ww)<br/>    (b, www)<br/>  }<br/>}</pre>
<p>The signature of the method is very similar to other monads we had in this chapter. Inside, we are decomposing the state of our current <kbd>Writer</kbd> into the result <kbd>a</kbd> and log <kbd>w</kbd>. Then, we apply the given function to the result and collect the next result and the log entries. Finally, we combine the log entries by utilizing the monoid operation and returning the result and the combined log.</p>
<p>We can also define the default constructor, which just returns a given argument with an empty log:</p>
<pre><span>object </span>Writer {<br/>  <span>def </span><span>apply</span>[<span>W</span>: Monoid<span>, </span><span>A</span>](a: =&gt; <span>A</span>): Writer[<span>W</span><span>, </span><span>A</span>] = <span>Writer</span>((a<span>, </span><span>implicitly</span>[Monoid[<span>W</span>]].identity))<br/>}</pre>
<p>The monad definition is now a mechanical delegation to these methods. The only small difference is the requirement for the <kbd>Monoid[W]</kbd> to be available:</p>
<pre><span>implicit def </span><span>writerMonad</span>[<span>W </span>: Monoid] = <span>new </span>Monad[Writer[<span>W</span><span>, </span>?]] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): Writer[<span>W</span><span>, </span><span>A</span>] = <span>Writer</span>(a)<br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: Writer[<span>W</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; Writer[<span>W</span><span>, </span><span>B</span>]): Writer[<span>W</span><span>, </span><span>B</span>] = a.compose(f)<br/>}</pre>
<p>Yet again, we are done, and we can start to use our new abstraction. Let's suppose that now regulations require us to write every bot movement into the journal. We are happy to comply. As long as it is only about movements, we don't need to touch the <kbd>turn</kbd> function—we'll only need to extend the <kbd>go</kbd> definition:</p>
<pre><span>type </span><span>WriterTracking</span>[<span>A</span>] = Writer[<span>Vector</span>[(<span>Double, Double</span>)]<span>, </span><span>A</span>]<br/><br/><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): <span>WriterTracking</span>[Boat] = <span>new </span>WriterTracking((boat.go(speed<span>, </span>time)<span>, </span><span>Vector</span>(boat.position)))</pre>
<p>We are writing the position of the boat in the journal represented by a <kbd>Vector</kbd>. In the definition, we merely propagate the call to the boat again and return the position of the boat before the move as the log entry. We also need to satisfy the monoid requirement. The monoid is defined in a similar fashion to the one we had in <a href="c1798142-6829-479c-bb7b-d50ccd16e629.xhtml">Chapter 7</a>, <em>Understanding Algebraic Structures</em>:</p>
<pre><span>implicit def </span><span>vectorMonoid</span>[<span>A</span>]: Monoid[<span>Vector</span>[<span>A</span>]] = <br/><span>  new </span>Monoid[<span>Vector</span>[<span>A</span>]] {<br/>    <span>override def </span><span>identity</span>: <span>Vector</span>[<span>A</span>] = <span>Vector</span>.<span>empty</span>[<span>A</span>]<br/>    <span>override def </span><span>op</span>(l: <span>Vector</span>[<span>A</span>]<span>, </span>r: <span>Vector</span>[<span>A</span>]): <span>Vector</span>[<span>A</span>] = l ++ r<br/>  }</pre>
<p>With these preparations, we are ready to move our boat once again in SBT session using the <kbd>run</kbd> command:</p>
<pre><span>import </span>Monad.<span>writerMonad<br/></span><span>import </span>Boat.{<span>move</span><span>, </span><span>boat</span><span>, </span><span>turn</span>}<br/><span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>[<span>WriterTracking</span>])(<span>Writer</span>(<span>boat</span>)).run)<br/><br/>(Boat(0.4,(401.95408575015193,192.15963378398988)),Vector((0.0,0.0), (50.0,0.0), (401.0330247561491,191.77021544168122)))</pre>
<p>We are passing the augmented <kbd>go</kbd> function and the original <kbd>turn</kbd> function (though typed with the <kbd>WriterTracking</kbd>) as a first parameter list and a <kbd>boat</kbd> wrapped in the <kbd>Writer</kbd> as a second parameter list. The output speaks for itself<span>—</span>it is the original result and vector containing positions of our boat before each move<span>—</span>all without touching the definition of the steering logic!</p>
<p>The <kbd>Writer</kbd> monad concludes our tour of the land of monads. In the next chapter, we'll take a look at combining them. If your intuition tells you that it can be a bit more involving than combining applicatives—after all, there is a whole chapter dedicated to that topic—then you're right. It is more complex, but also more interesting. Let's take a look!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">In this chapter, we looked at monads as a way of sequencing computations. We studied how the meaning of this sequencing changes among the different monads we've implemented. <span>The</span> <kbd>Id</kbd> <span>just composes computations as is. </span>The <kbd>Option</kbd> adds a possibility to stop with no result if one of the steps returns no result. <kbd>Try</kbd> and <kbd>Either</kbd> have semantics similar to <kbd>Option</kbd> but allow you to specify the meaning of <em>no result</em> in terms of an <kbd>Exception</kbd> or as a <kbd>Left</kbd> side of <kbd>Either</kbd>. The <kbd>Writer</kbd> makes an append-only log available for computation in the chain. The <kbd>Reader</kbd> provides some configuration to every computation step. The <kbd>State</kbd> carries a <em>mutable</em> state between actions.</p>
<p class="p1">We discussed how the two primitive methods defining a monad, <kbd>unit</kbd> and <kbd>flatMap</kbd>, allow you to implement other useful methods such as <kbd>map</kbd>, <kbd>map2</kbd>, and <kbd>apply</kbd>, thus proving that every monad is a functor and an applicative.</p>
<p class="p1">In terms of <kbd>map</kbd> and <kbd>flatMap</kbd>—as for-comprehensions<span>—</span>we defined some small business logic to steer a boat. We then demonstrated how this logic can be reused without changes, even if the implementation of the underlying monad was reshaped.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Implement <kbd><span>Monad[Try]</span></kbd><span>.</span></li>
<li>Prove the right identity law for the <kbd>State</kbd> monad.</li>
<li>Pick one of the monads we defined in this chapter and implement the <kbd>go</kbd> function, which will encode the notion of sinking the boat with a probability of 1%.</li>
<li>Please do the same as question 3, but encode the notion of motor breaking in 1% of the moves, leaving the boat immobilized.</li>
<li>Describe the essence of the monads we defined in this chapter by using the<span> (loosely)</span> following template—The state monad passes state between chained computations. The computation itself accepts the outcome of the previous calculation and returns the result, along with the new state.</li>
</ol>
<ol start="6">
<li><span>Define a</span> <kbd>go</kbd> <span>method that both tracks the position of the boat and takes the possibility of sinking the boat by using the structure with the following type:</span></li>
</ol>
<pre style="color: black;padding-left: 30px">type WriterOption[B] = Writer[Vector[(Double, Double)], Option[Boat]]</pre>
<ol start="7">
<li>Compare the answer to the 6th question and the way we combined <kbd>Applicatives</kbd> in the previous chapter.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Atul S. Khot, <em>Scala Functional Programming Patterns</em>: </span><em><span>Grok and performing effective functional programming in Scala</span></em></li>
<li><span>Ivan Nikolov, </span><em>Scala Design Patterns<span> </span>- Second Edition: Learn how to write efficient, clean, and reusable code with Scala</em></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>