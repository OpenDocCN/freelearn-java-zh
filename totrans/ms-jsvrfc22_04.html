<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;JSF Configurations Using XML Files and Annotations &#x2013; Part 1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1</h1></div></div></div><p>Starting with JSF 2.0, there is no need to create the configuration file, <code class="literal">faces-config.xml</code>. Well, this affirmation is partially true, because JSF annotations still don't cover several configurations, such as resource bundles, factories, phase listeners, and so on. Usually, JSF annotations provide sufficient support for our applications; however, as you will see in this chapter, there are still many cases when <code class="literal">faces-config.xml</code> is mandatory, or additional configurations must be added in the <code class="literal">web.xml</code> file.</p><p>Nevertheless, JSF 2.2 provides a programmatic approach that can be used to reproduce <code class="literal">faces-config.xml</code>, without writing it in the classical approach. Later in this chapter, you will see how to take advantage of this new feature. For now, you will see a mix of creating and configuring different kinds of JSF artifacts. They will be arbitrarily presented—some of them are well known, from JSF 1.x and 2.0, while others are new, starting with JSF 2.2. Since these configurations are straightforward, they can be listed as barren documentation, but gluing each configuration into an example is more useful and provides a good point to start when you need to use them.</p><p>Therefore, in this chapter you will learn about JSF artifacts' configurations, but you will also see some examples of working with these artifacts. The following is a short overview of what we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSF 2.2 new namespaces</li><li class="listitem" style="list-style-type: disc">JSF 2.2 programmatic configuration</li><li class="listitem" style="list-style-type: disc">Configuring managed beans in XML</li><li class="listitem" style="list-style-type: disc">Working with multiple configuration files</li><li class="listitem" style="list-style-type: disc">Configuring locales and resource bundles</li><li class="listitem" style="list-style-type: disc">Configuring validators and converters</li><li class="listitem" style="list-style-type: disc">Configuring navigation</li><li class="listitem" style="list-style-type: disc">Configuring action listeners</li><li class="listitem" style="list-style-type: disc">Configuring system event listeners</li><li class="listitem" style="list-style-type: disc">Configuring phase listeners</li><li class="listitem" style="list-style-type: disc">Working with <code class="literal">@ListenerFor</code> and <code class="literal">@ListenersFor</code></li></ul></div><p>Obviously, we have a lot of work to do and a lot of JSF 2.2 features to cover (for example, JSF 2.2 injection in more artifacts then before), so let's begin!</p><div class="section" title="JSF 2.2 new namespaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>JSF 2.2 new namespaces</h1></div></div></div><p>JSF 2.2 modified <a id="id472" class="indexterm"/>the<a id="id473" class="indexterm"/> existing <a id="id474" class="indexterm"/>JSF <a id="id475" class="indexterm"/>namespaces,<a id="id476" class="indexterm"/> as you<a id="id477" class="indexterm"/> can <a id="id478" class="indexterm"/>see in<a id="id479" class="indexterm"/> the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Namespace</p>
</th><th style="text-align: left" valign="bottom">
<p>Before JSF 2.2</p>
</th><th style="text-align: left" valign="bottom">
<p>JSF 2.2</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Faces <a id="id480" class="indexterm"/>Core</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf/core</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/core</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HTML_BASIC</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf/html</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/html</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Facelets<a id="id481" class="indexterm"/> Templating</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf/facelets</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/facelets</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Composite<a id="id482" class="indexterm"/> Components</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf/composite</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/composite</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>JSTL<a id="id483" class="indexterm"/> Core</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsp/jstl/core</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsp/jstl/core</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>JSTL<a id="id484" class="indexterm"/> Functions</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsp/jstl/functions</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsp/jstl/functions</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pass <a id="id485" class="indexterm"/>Through Attributes</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf/passthrough</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/passthrough</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pass<a id="id486" class="indexterm"/> Through <a id="id487" class="indexterm"/>Elements</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://java.sun.com/jsf</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@FacesComponent</code> <a id="id488" class="indexterm"/>default<a id="id489" class="indexterm"/> namespace</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><code class="literal">http://xmlns.jcp.org/jsf/component</code></p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="JSF 2.2 programmatic configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>JSF 2.2 programmatic configuration</h1></div></div></div><p>Starting with JSF 2.2, we can programmatically reproduce the content and tasks of <code class="literal">faces-config.xml</code>. The starting point consists of a callback method, named <code class="literal">populateApplicationConfiguration</code>, which gets a single argument of type <code class="literal">org.w3c.dom.Document</code>—this class belongs to DOM API. Basically, a <code class="literal">Document</code> (tree node)<a id="id490" class="indexterm"/> is a representation<a id="id491" class="indexterm"/> in memory of an XML document, and we can manipulate it by adding, removing, importing, or adopting nodes, elements, and text. For each of these operations, there are dedicated methods. For some JSF developers, this API can be something new that should be learned; therefore, this can be a drawback of programmatic configuration.</p><p>For now, let's resume the dissertation from the callback method. The <code class="literal">populateApplicationConfiguration</code> method<a id="id492" class="indexterm"/> is provided by a class that extends and implements the abstract class <code class="literal">ApplicationConfigurationPopulator</code> found in the <code class="literal">javax.faces.application</code> package. In order to tell JSF about this class, you need to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a JAR package (for example, <code class="literal">faces-config.jar</code> or by using any other name).</li><li class="listitem">In this JAR package, create a folder named <code class="literal">META-INF</code>.</li><li class="listitem">In the <code class="literal">META-INF</code> folder, create a folder named <code class="literal">services</code>.</li><li class="listitem">In the <code class="literal">services</code> folder, create an empty file named <code class="literal">javax.faces.application.ApplicationConfigurationPopulator</code>.</li><li class="listitem">In this file, write the fully qualified name of the class that extends and implements the abstract class <code class="literal">ApplicationConfigurationPopulator</code>.</li><li class="listitem">In the JAR root, place the class that extends and implements the abstract class <code class="literal">ApplicationConfigurationPopulator</code>.</li></ol></div><p>Done! Now when you add this JAR package in your project <code class="literal">CLASSPATH</code>, JSF will process it and apply the found configurations.</p><p>Supposing that the class that extends and implements the abstract class <code class="literal">ApplicationConfigurationPopulator</code> is named <code class="literal">faces.config.Initializer</code> (you can use any other name), then the JAR content will look like in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_04_01.jpg" alt="JSF 2.2 programmatic configuration"/></div><p>In this chapter, you will see some programmatic examples as an alternative to classical <code class="literal">faces-config.xml</code>. When we are working directly on a DOM tree node, we tend to make stupid mistakes, like forgetting to add the text of an element, or placing an element in an<a id="id493" class="indexterm"/> improper place, and so on. In order to eliminate these errors without headaches, you can write a simple method to serialize the DOM in an XML file, which can be easily debugged visually or using a specialized tool. The following method accomplishes this task, and you will find it in all the examples in this chapter:</p><div class="informalexample"><pre class="programlisting">private void serializeFacesConfig(Document document,String path) {

  FileOutputStream fileOutputStream = null;
  OutputFormat outputFormat = new OutputFormat();
  outputFormat.setIndent(5);
  outputFormat.setLineWidth(150);

  ...
  fileOutputStream = new FileOutputStream(path);

  XMLSerializer xmlSerializer = new XMLSerializer();
  xmlSerializer.setOutputFormat(outputFormat);
  xmlSerializer.setOutputByteStream((OutputStream)
                                    fileOutputStream);

  xmlSerializer.serialize(document);
...
}</pre></div></div>
<div class="section" title="Configuring managed beans in XML"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Configuring managed beans in XML</h1></div></div></div><p>JSF managed bean configuration <a id="id494" class="indexterm"/>was essentially improved starting with JSF 2.0. Most commonly, a managed bean is annotated with <code class="literal">@ManagedBean</code> and <a id="id495" class="indexterm"/>another annotation indicating a JSF scope (for example, <code class="literal">@RequestScoped</code>). But managed beans can be configured in <code class="literal">faces-config.xml</code> as well, and this approach is not deprecated or obsolete. The simplest configuration contains the managed bean's name, class, and scope:</p><div class="informalexample"><pre class="programlisting">&lt;managed-bean&gt;
  &lt;managed-bean-name&gt;playersBean&lt;/managed-bean-name&gt;
  &lt;managed-bean-class&gt;book.beans.PlayersBean&lt;/managed-bean-class&gt;
  &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
...
&lt;/managed-bean&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note68"/>Note</h3><p>In case that you need a managed bean that should be eagerly initialized, you can use the <code class="literal">eager</code> attribute of the <code class="literal">&lt;managed-bean&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;managed-bean eager="true"&gt;</pre></div></div></div><p>Managed beans' properties <a id="id496" class="indexterm"/>can be initialized from <code class="literal">faces-config.xml</code> using the <code class="literal">&lt;managed-property&gt;</code> tag as<a id="id497" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">&lt;managed-property&gt;
  &lt;property-name&gt;name&lt;/property-name&gt;
  &lt;value&gt;Nadal&lt;/value&gt;
&lt;/managed-property&gt;
&lt;managed-property&gt;
  &lt;property-name&gt;surname&lt;/property-name&gt;
  &lt;value&gt;Rafael&lt;/value&gt;
&lt;/managed-property&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>Inside the <code class="literal">&lt;value&gt;</code> tag, we can use EL expressions as well. For example, we can initialize a property of managed bean <code class="literal">A</code> with the value of a property belonging to managed bean <code class="literal">B</code>. But, it is important to know that JSF doesn't support cyclic dependency for managed bean reference—you cannot refer managed bean <code class="literal">A</code> from managed bean <code class="literal">B</code>, and vice versa.</p></div></div><p>An interesting case involves setting a property with the value of a context initialization parameter. Such parameters are configured in the deployment descriptor (<code class="literal">web.xml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;rafakey&lt;/param-name&gt;
  &lt;param-value&gt;Vamos Rafa!&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Programmatically, these kinds of parameters can be extracted through the initialization map or by their name, as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext.getCurrentInstance().getExternalContext().getInitParameterMap();
FacesContext.getCurrentInstance().getExternalContext().getInitParameter(<span class="emphasis"><em>param_name</em></span>);</pre></div><p>These parameters <a id="id498" class="indexterm"/>can be accessed from <code class="literal">faces-config.xml</code> using the EL implicit object, <code class="literal">initParam</code>. JSF provides the ability to reference EL implicit objects from a managed bean property, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;managed-property&gt;
  &lt;property-name&gt;rafakey&lt;/property-name&gt;
  &lt;value&gt;#{initParam.rafakey}&lt;/value&gt;
&lt;/managed-property&gt;</pre></div><p>From <code class="literal">faces-config.xml</code>, we can initialize more complex properties such as enumerations<a id="id499" class="indexterm"/> and collections. Consider the following enumeration:</p><div class="informalexample"><pre class="programlisting">public enum Plays {
    Left, Right
    };

private Plays play;

//getters and setters
...</pre></div><p>The preceding property can be initialized as follows:</p><div class="informalexample"><pre class="programlisting">&lt;managed-property&gt;
  &lt;property-name&gt;play&lt;/property-name&gt;
  &lt;value&gt;Left&lt;/value&gt;
&lt;/managed-property&gt;</pre></div><p>In case of collections, we can easily initialize<a id="id500" class="indexterm"/> maps and lists. A map (<code class="literal">java.util.Map</code>) can be initialized as follows:</p><div class="informalexample"><pre class="programlisting">&lt;managed-property&gt;
  &lt;property-name&gt;matchfacts&lt;/property-name&gt;
  &lt;map-entries&gt;
    &lt;map-entry&gt;
      &lt;key&gt;Aces&lt;/key&gt;
      &lt;value&gt;12&lt;/value&gt;
    &lt;/map-entry&gt;
    &lt;map-entry&gt;
      &lt;key&gt;Double Faults&lt;/key&gt;
      &lt;value&gt;2&lt;/value&gt;
    &lt;/map-entry&gt;
    &lt;map-entry&gt;
      &lt;key&gt;1st Serve&lt;/key&gt;
      &lt;value&gt;70%&lt;/value&gt;
    &lt;/map-entry&gt;
  &lt;/map-entries&gt;
&lt;/managed-property&gt;</pre></div><p>While a<a id="id501" class="indexterm"/> list <code class="literal">java.util.List</code> (or array) can be initialized as follows:</p><div class="informalexample"><pre class="programlisting">&lt;managed-property&gt;
  &lt;property-name&gt;titles_2013&lt;/property-name&gt;
  &lt;list-entries&gt;
    &lt;value-class&gt;java.lang.String&lt;/value-class&gt;
    &lt;value&gt;Sao Paulo&lt;/value&gt;
    &lt;value&gt;Acapulco&lt;/value&gt;
    &lt;value&gt;Barcelona&lt;/value&gt;
    &lt;value&gt;...&lt;/value&gt;
  &lt;/list-entries&gt;
&lt;/managed-property&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>A property can be initialized with a <code class="literal">null</code> value by using the <code class="literal">&lt;null-value/&gt;</code> tag.</p></div></div><p>If you prefer to<a id="id502" class="indexterm"/> configure managed beans in the XML descriptor (instead of using annotations), then it is a good practice is to place them into another<a id="id503" class="indexterm"/> descriptor and not in <code class="literal">faces-config.xml</code>. Keep this descriptor for application-level configurations. For example, you can name it <code class="literal">faces-beans.xml</code>. JSF will know how to use this file when it inspects the application descriptor, <code class="literal">web.xml</code>, for the following predefined context parameter:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;javax.faces.CONFIG_FILES&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/faces-beans.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Now you can keep <code class="literal">faces-config.xml</code> for other configurations.</p><p>Obviously, it is much easier to use annotations instead of tags, but sometimes this approach can be really useful. For example, you can have some annotated managed beans whose behavior you want to change, but for different reasons you cannot edit the source code. In such a scenario, you can write the modifications in an XML file, because at runtime, configurations from the XML file will take precedence against annotations.</p><p>A complete example, named <code class="literal">ch4_12</code>, is available in the code bundle of this chapter.</p><p>The JSF 2.2 programmatic approach can reproduce the<a id="id504" class="indexterm"/> configuration file of the <code class="literal">ch4_12</code> application<a id="id505" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">public class Initializer extends ApplicationConfigurationPopulator {

  @Override
  public void populateApplicationConfiguration (Document toPopulate) {

    String ns = toPopulate.getDocumentElement().getNamespaceURI();

    Element managedbeanEl = toPopulate.createElementNS(ns, "managed-bean");

    Element managedbeannameEl = toPopulate.createElementNS(ns, "managed-bean-name");
    managedbeannameEl.appendChild(toPopulate.createTextNode("playersBean"));
    managedbeanEl.appendChild(managedbeannameEl);

    Element managedbeanclassEl = toPopulate.createElementNS(ns, "managed-bean-class");
    managedbeanclassEl.appendChild(toPopulate.
          createTextNode("book.beans.PlayersBean"));
    managedbeanEl.appendChild(managedbeanclassEl);

    Element managedbeanscopeEl = toPopulate.
          createElementNS(ns, "managed-bean-scope");
    managedbeanscopeEl.appendChild(toPopulate.
          createTextNode("request"));
    managedbeanEl.appendChild(managedbeanscopeEl);

    Element managedproperty0El = toPopulate.
          createElementNS(ns, "managed-property");
    Element propertyNameEl = toPopulate.
          createElementNS(ns, "property-name");        
    propertyNameEl.appendChild(toPopulate.createTextNode("name"));
    Element valueNameEl = toPopulate.createElementNS(ns, "value");          
    valueNameEl.appendChild(toPopulate.createTextNode("Nadal"));
    managedproperty0El.appendChild(propertyNameEl);
    managedproperty0El.appendChild(valueNameEl);
    managedbeanEl.appendChild(managedproperty0El);
    ...
    Element managedproperty5El = toPopulate.
          createElementNS(ns, "managed-property");
    Element propertyMatchfactsEl = toPopulate.
          createElementNS(ns, "property-name");
    propertyMatchfactsEl.appendChild(toPopulate.
          createTextNode("matchfacts"));
    Element mapEntriesEl = toPopulate.
          createElementNS(ns, "map-entries");
    Element mapEntry0El = toPopulate.
          createElementNS(ns, "map-entry");
    Element key0El = toPopulate.createElementNS(ns, "key");
    key0El.appendChild(toPopulate.createTextNode("Aces"));
    Element value0El = toPopulate.createElementNS(ns, "value");
    value0El.appendChild(toPopulate.createTextNode("12"));
    mapEntry0El.appendChild(key0El);
    mapEntry0El.appendChild(value0El);
    ...
    mapEntriesEl.appendChild(mapEntry0El);
    mapEntriesEl.appendChild(mapEntry1El);
    mapEntriesEl.appendChild(mapEntry2El);
    managedproperty5El.appendChild(propertyMatchfactsEl);
    managedproperty5El.appendChild(mapEntriesEl);
    managedbeanEl.appendChild(managedproperty5El);

    Element managedproperty6El = toPopulate.
          createElementNS(ns, "managed-property");
    Element propertyTitles_2013El = toPopulate.
          createElementNS(ns, "property-name");
    propertyTitles_2013El.appendChild(toPopulate.
          createTextNode("titles_2013"));
    Element listEntriesEl = toPopulate.
          createElementNS(ns, "list-entries");
    Element valueClassEl = toPopulate.
          createElementNS(ns, "value-class");
    valueClassEl.appendChild(toPopulate.
          createTextNode("java.lang.String"));
    Element value0lEl = toPopulate.createElementNS(ns, "value");
    value0lEl.appendChild(toPopulate.createTextNode("Sao Paulo"));
    ...
    listEntriesEl.appendChild(valueClassEl);
    listEntriesEl.appendChild(value0lEl);
    listEntriesEl.appendChild(value1lEl);
    listEntriesEl.appendChild(value2lEl);
    listEntriesEl.appendChild(value3lEl);
    listEntriesEl.appendChild(nullValuelEl);
    managedproperty6El.appendChild(propertyTitles_2013El);
    managedproperty6El.appendChild(listEntriesEl);
    managedbeanEl.appendChild(managedproperty6El);

    toPopulate.getDocumentElement().appendChild(managedbeanEl);

    //serializeFacesConfig(toPopulate, "D://faces-config.xml");
  }
  ...
}</pre></div><p>The<a id="id506" class="indexterm"/> complete<a id="id507" class="indexterm"/> application is named <code class="literal">ch4_14_1</code>.</p></div>
<div class="section" title="Working with multiple configuration files"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Working with multiple configuration files</h1></div></div></div><p>JSF 2.0 provides<a id="id508" class="indexterm"/> support for ordering the configuration resources. We can use <span class="strong"><strong>partial ordering</strong></span> (represented by the <code class="literal">&lt;ordering&gt;</code> tag) and <span class="strong"><strong>absolute ordering</strong></span> (represented by the <code class="literal">&lt;absolute-ordering&gt;</code> tag).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>Each document that is involved in the ordering plan is identified by the top-level tag, <code class="literal">&lt;name&gt;</code>.</p></div></div><p>Partial ordering<a id="id509" class="indexterm"/> is specific to a single configuration document. We can use the <code class="literal">&lt;before&gt;</code> and <code class="literal">&lt;after&gt;</code> tags to indicate that a certain document should be processed before or after another document. Nested inside the <code class="literal">&lt;before&gt;</code> and <code class="literal">&lt;after&gt;</code> tags, we may have the <code class="literal">&lt;others/&gt;</code> tag, which indicates that a certain document should be processed before (respectively after) all the other documents that are sorted.</p><p>Listed here is an example<a id="id510" class="indexterm"/> where we have documents <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">faces-config.xml</code> alias <code class="literal">D</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Document <code class="literal">C</code> needs to be executed before others; hence, it will be executed first:<div class="informalexample"><pre class="programlisting">&lt;name&gt;C&lt;/name&gt;
&lt;ordering&gt;
  &lt;before&gt;
    &lt;others/&gt;
  &lt;/before&gt;
&lt;/ordering&gt;</pre></div></li><li class="listitem">Document <code class="literal">B</code> has no specified order; hence, it will be executed second:<div class="informalexample"><pre class="programlisting">&lt;name&gt;B&lt;/name&gt;</pre></div></li><li class="listitem">Document <code class="literal">A</code> needs to be executed after document <code class="literal">B</code>; hence, it will be executed third:<div class="informalexample"><pre class="programlisting">&lt;name&gt;A&lt;/name&gt;
&lt;ordering&gt;
  &lt;after&gt;
    &lt;name&gt;B&lt;/name&gt;
  &lt;/after&gt;
&lt;/ordering&gt;</pre></div></li><li class="listitem">Document <code class="literal">D</code> (<code class="literal">faces-config.xml</code>) is executed last and doesn't need any ordering specifications.</li></ol></div><p>The order will<a id="id511" class="indexterm"/> be implementation-specific configuration resource, that is, <code class="literal">C</code>, <code class="literal">B</code>, <code class="literal">A</code>, and <code class="literal">faces-config.xml</code> (<code class="literal">D</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>The ordering process (partial or absolute) has no effect over two documents: the respective implementation's (Mojarra or MyFaces) default configuration resource is always processed first, and <code class="literal">faces-config.xml</code> (if exists) is always processed last.</p></div></div><p>A simple test can be performed using several phase listeners and firing some customized messages. Each <a id="id512" class="indexterm"/>phase listener is configured in a separate document and some partial ordering schema is applied. A complete example can be found in the code bundle of this chapter and is named <code class="literal">ch4_13_1</code>. The console output will reveal the effect of partial ordering.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note73"/>Note</h3><p>If a document has ordering requirements, but no name, then the ordering requirements will be ignored.</p></div></div><p>The absolute ordering<a id="id513" class="indexterm"/> is accomplished by the <code class="literal">&lt;absolute-ordering&gt;</code> tag. This tag can appear only in <code class="literal">faces-config.xml</code> and provides us control over the order that configuration documents will be processed. For example, we have added the<a id="id514" class="indexterm"/> absolute ordering in the <code class="literal">faces-config.xml</code> document (alias document <code class="literal">D</code>) as follows:</p><div class="informalexample"><pre class="programlisting">&lt;absolute-ordering&gt;
  &lt;others/&gt;
  &lt;name&gt;C&lt;/name&gt;
  &lt;name&gt;B&lt;/name&gt;
  &lt;name&gt;A&lt;/name&gt;
&lt;/absolute-ordering&gt;</pre></div><p>And, the<a id="id515" class="indexterm"/> processing order is: implementation specific configuration resource , <code class="literal">C</code>, <code class="literal">B</code>, <code class="literal">A</code>, and <code class="literal">faces-config.xml</code> (<code class="literal">D</code>).</p><p>The<a id="id516" class="indexterm"/> complete example for absolute ordering is named, <code class="literal">ch4_13_2</code>.</p></div>
<div class="section" title="Configuring locales and resource bundles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Configuring locales and resource bundles</h1></div></div></div><p>A properties file that contains messages can be named <code class="literal">PlayerMessages.properties</code>. When we have messages in several languages, we can create a properties file for each language and name it accordingly. For example, for English it will be <code class="literal">PlayerMessages_en.properties</code>, and for French it will be <code class="literal">PlayerMessages_fr.properties</code>. A convenient place to store them is in the application source folder directly or in subfolders (or, in NetBeans, under <code class="literal">Other Sources</code> folder in a Maven web application project). A resource bundle<a id="id517" class="indexterm"/> is capable of loading and displaying messages from these files.</p><p>A resource bundle<a id="id518" class="indexterm"/> can be configured locally or globally. A local resource bundle<a id="id519" class="indexterm"/> loads the properties file for the specified page only. For this, use the <code class="literal">&lt;f:loadBundle&gt;</code> tag<a id="id520" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;f:loadBundle basename="players.msgs.PlayerMessages" var="msg"/&gt;</pre></div><p>A global resource bundle<a id="id521" class="indexterm"/> loads the properties file for all the JSF pages. In this case, we need a declarative loading in <code class="literal">faces-config.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
  &lt;resource-bundle&gt;
    &lt;base-name&gt;players.msgs.PlayerMessages&lt;/base-name&gt;
    &lt;var&gt;msg&lt;/var&gt;
  &lt;/resource-bundle&gt;
&lt;/application&gt;</pre></div><p>When we have files for<a id="id522" class="indexterm"/> multiple languages, we also have to indicate the locale. Locally, this is accomplished in the <code class="literal">&lt;f:view&gt;</code> tag by adding the locale attribute, as follows (here we indicate the French language):</p><div class="informalexample"><pre class="programlisting">&lt;f:view locale="fr"&gt;</pre></div><p>Globally, in <code class="literal">faces-config.xml</code>, we indicate the default<a id="id523" class="indexterm"/> locale via <code class="literal">&lt;default-locale&gt;</code> and the list of supported locales using <a id="id524" class="indexterm"/>the <code class="literal">&lt;supported-locale&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
  &lt;locale-config&gt;
    &lt;default-locale&gt;en&lt;/default-locale&gt; 
    &lt;supported-locale&gt;fr&lt;/supported-locale&gt;
    &lt;supported-locale&gt;en&lt;/supported-locale&gt;
  &lt;/locale-config&gt;
  &lt;resource-bundle&gt;
    &lt;base-name&gt;players.msgs.PlayerMessages&lt;/base-name&gt;
    &lt;var&gt;msg&lt;/var&gt;
  &lt;/resource-bundle&gt;
&lt;/application&gt;</pre></div><p>Programmatically, we <a id="id525" class="indexterm"/>may depict the<a id="id526" class="indexterm"/> locale as follows:</p><div class="informalexample"><pre class="programlisting">UIViewRoot viewRoot = FacesContext.getCurrentInstance().getViewRoot();
viewRoot.setLocale(new Locale("fr"));</pre></div><p>A simple entry in the properties file will be as follows:</p><div class="informalexample"><pre class="programlisting">HELLO = Hello from Rafael Nadal!</pre></div><p>The messages will be displayed using the <a id="id527" class="indexterm"/>
<code class="literal">msg</code> variable (declared by the <code class="literal">var</code> attribute or the <code class="literal">&lt;var&gt;</code> tag):</p><div class="informalexample"><pre class="programlisting">#{msg['HELLO']}</pre></div><p>But, messages can be more complex than static text. For example, they can be parameterized, as follows:</p><div class="informalexample"><pre class="programlisting">HELLOPARAM = Hello from {0} {1}!</pre></div><p>And parameters can<a id="id528" class="indexterm"/> be replaced using the <code class="literal">&lt;h:outputFormat&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputFormat value="#{msg['HELLOPARAM']}"&gt;
 &lt;f:param value="Roger" /&gt;
 &lt;f:param value="Federer" /&gt;
&lt;/h:outputFormat&gt;</pre></div><p>But, how about a message of the following type:</p><div class="informalexample"><pre class="programlisting">REGISTERED = You have {0} players registered!</pre></div><p>When you have one player, the message will be as follows:</p><div class="informalexample"><pre class="programlisting">You have 1 players registered!</pre></div><p>This is grammatically incorrect; therefore, you need to use a pattern similar to the following:</p><div class="informalexample"><pre class="programlisting">REGISTERED = You have {0} {0, choice, 0#players|1#player|2#players} registered!</pre></div><p>This will fix the problem. The arguments used here are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0, choice</code>: Take the first parameter and base the output on a choice of available formats</li><li class="listitem" style="list-style-type: disc"><code class="literal">0#players</code>: If the first parameter contains 0 (or below), then it should print "players"</li><li class="listitem" style="list-style-type: disc"><code class="literal">1#player</code>: If the first parameter contains 1, then it should print "player"</li><li class="listitem" style="list-style-type: disc"><code class="literal">2#players</code>: If the first parameter contains 2 (or above), then it should print "players"</li></ul></div><p>You can find the <a id="id529" class="indexterm"/>complete example under the name <code class="literal">ch4_4</code>, in the code bundle of this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>Do not confuse the <code class="literal">&lt;resource-bundle&gt;</code> tag with <code class="literal">&lt;message-bundle&gt;</code>. The former is used for registering custom<a id="id530" class="indexterm"/> localized static text, while the latter is used for registering custom error/info/warn messages, which are displayed by <code class="literal">&lt;h:message&gt;</code> and <code class="literal">&lt;h:messages&gt;</code>.</p></div></div><p>The <code class="literal">&lt;message-bundle&gt;</code> option<a id="id531" class="indexterm"/> is ideally used as follows:</p><div class="informalexample"><pre class="programlisting">&lt;message-bundle&gt;
  players.msgs.ErrorsMessages
&lt;/message-bundle&gt;</pre></div><p>The message file can be loaded with the <code class="literal">&lt;f:loadBundle&gt;</code> tag.</p></div>
<div class="section" title="Configuring validators and converters"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Configuring validators and converters</h1></div></div></div><p>Data validation is<a id="id532" class="indexterm"/> an important part of a JSF application (which has existed since JSF 1.2), because it allows us to separate the business logic from the tedious checks that help<a id="id533" class="indexterm"/> us to obtain only valid information from the user. Data is validated in the <span class="emphasis"><em>Process Validations</em></span> phase (if the <code class="literal">immediate</code> attribute is set to <code class="literal">true</code>, this processing will occur at the end of the <span class="emphasis"><em>Apply Request Values</em></span> phase instead) and should be valid and ready to be used before the <span class="emphasis"><em>Update Model Values</em></span> phase.</p><p>Besides the built-in validators, we can write our own customized validators. A public class that implements the <code class="literal">Validator</code> interface and overrides the <code class="literal">validate</code> method is recognized by JSF as a <span class="strong"><strong>validator</strong></span>. There are two ways to configure a validator in JSF: using the <code class="literal">@FacesValidator</code> annotation or the <code class="literal">&lt;validator&gt;</code> tag in <code class="literal">faces-config.xml</code>.</p><p>Suppose that we have the<a id="id534" class="indexterm"/> following e-mail validator configured using <code class="literal">@FacesValidator</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  @FacesValidator(value = "emailValidator")</strong></span>
  public class EmailValidator implements Validator {

    @Override
    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {

      ...
    }
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>In JSF 2.2, the name can now be omitted from components, converters, and validators, so the preceding code will become <code class="literal">@FacesValidator</code>. Here, we need to note that when the name is omitted, JSF will use the class name, without the package name, with the first letter de-capitalized.</p></div></div><p>If you prefer to use <code class="literal">faces-config.xml</code>, then <code class="literal">EmailValidator</code> can be configured as follows:</p><div class="informalexample"><pre class="programlisting">&lt;validator&gt;
  &lt;validator-id&gt;emailValidator&lt;/validator-id&gt;
  &lt;validator-class&gt;book.beans.EmailValidator&lt;/validator-class&gt;
&lt;/validator&gt;</pre></div><p>Now, you can<a id="id535" class="indexterm"/> easily link <code class="literal">validator</code> to an input component:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}"&gt;
  &lt;f:validator validatorId="emailValidator"/&gt;
&lt;/h:inputText&gt;</pre></div><p>An alternate way <a id="id536" class="indexterm"/>to do this is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}" validator="emailValidator"/&gt;</pre></div><p>The complete example of <code class="literal">EmailValidator</code> is available in the code bundle of this chapter and is named <code class="literal">ch4_3_1</code>. Besides this application, consider, as a bonus, two applications that are useful when validators are involved. The first one is named <code class="literal">ch4_2</code>, and requires passing extra parameters to a validator using <code class="literal">&lt;f:attribute&gt;</code>, and the other one is named <code class="literal">ch4_11</code>, which is an example of validating multiple fields using a custom validator and the <code class="literal">&lt;f:attribute&gt;</code> tag. The latter one is also developed using the <code class="literal">PostValidateEvent</code> system event—check the <span class="emphasis"><em>Configuring system event listeners</em></span> section later in this chapter.</p><p>Well, there are many articles about JSF validators, but just a few discuss injection in JSF validators. By default, JSF 2.0 does not support injection in validators, since only managed beans are injection targets, but there are several tricks that can bring dependency injection in discussion.</p><p>In order to obtain a validator eligible for injection, you need to apply the following modifications, which basically transform the validator into a bean:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Replace the <code class="literal">@FacesValidator</code> annotation with <code class="literal">@Named</code> or <code class="literal">@ManagedBean</code> (or even with a Spring annotation, <code class="literal">@Component</code>).</li><li class="listitem">Put the bean in a request scope (use the proper <code class="literal">@RequestScoped</code> annotation)<div class="informalexample"><pre class="programlisting">@Named(value="emailValidator")
@RequestScoped
public class EmailValidator implements Validator {

  @Override
  public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {
    ...
  }
}</pre></div></li><li class="listitem">Refer to it using the proper EL expression:<div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}"
             validator="#{emailValidator.validate}" /&gt;</pre></div></li></ol></div><p>Done! Now, you can use <code class="literal">@Inject</code> in this validator.</p><p>The complete example is <a id="id537" class="indexterm"/>available in the code bundle of this chapter and is named <code class="literal">ch4_3_2</code>.</p><p>A more complicated task is to <a id="id538" class="indexterm"/>use <code class="literal">@EJB</code> for injecting <span class="strong"><strong>Enterprise JavaBeans</strong></span> (<span class="strong"><strong>EJB</strong></span>) session beans. In this case, we need to manually lookup the<a id="id539" class="indexterm"/> EJB session bean from <span class="strong"><strong>Java Naming and Directory Interface</strong></span> (<span class="strong"><strong>JNDI</strong></span>). When the EJBs are deployed<a id="id540" class="indexterm"/> in <span class="strong"><strong>Web application ARchive</strong></span> (<span class="strong"><strong>WAR</strong></span>) the lookup generally is of the following type:</p><div class="informalexample"><pre class="programlisting">java:app/<span class="emphasis"><em>app-name</em></span>/<span class="emphasis"><em>bean-name</em></span>[! <span class="emphasis"><em>fully-qualified-interface-name</em></span>]</pre></div><p>When the EJBs are in <a id="id541" class="indexterm"/>an <span class="strong"><strong>Enterprise ARchive</strong></span> (<span class="strong"><strong>EAR</strong></span>), the common lookup type is as follows:</p><div class="informalexample"><pre class="programlisting">java:global/<span class="emphasis"><em>app-name</em></span>/<span class="emphasis"><em>module-name</em></span>/<span class="emphasis"><em>bean-name</em></span>[! <span class="emphasis"><em>fully-qualified-interface-name</em></span>]</pre></div><p>When EJBs are deployed in WAR, use the following approach:</p><div class="informalexample"><pre class="programlisting">@FacesValidator
public class EmailValidator implements Validator {

  private LoginEJBBean loginEJBBean;

  @Override
  public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {

    try {
<span class="strong"><strong>      loginEJBBean = (LoginEJBBean) new InitialContext().</strong></span>
<span class="strong"><strong>                lookup("java:app/ch4_3_5/LoginEJBBean");</strong></span>
     } catch (NamingException e) {
       throw new ExceptionInInitializerError(e);
 }
...</pre></div><p>When EJBs are<a id="id542" class="indexterm"/> deployed in the EAR, use<a id="id543" class="indexterm"/> the following approach:</p><div class="informalexample"><pre class="programlisting">@FacesValidator public class EmailValidator implements Validator {

 private LoginEJBBean loginEJBBean;

 @Override
 public void validate(FacesContext context,
        UIComponent component, Object value) throws ValidatorException {
        
 try {
<span class="strong"><strong>     loginEJBBean = (LoginEJBBean) new InitialContext().</strong></span>
<span class="strong"><strong>     lookup("java:global/ch4_3_6/ch4_3_6-ejb/LoginEJBBean");</strong></span>
     } catch (NamingException e) {
       throw new ExceptionInInitializerError(e);
 }
...</pre></div><p>You can find the complete <a id="id544" class="indexterm"/>examples in the code bundle of this chapter. The example for EJBs deployed in the WAR is named <code class="literal">ch4_3_5</code>, and the EJBs deployed in EAR case is named <code class="literal">ch4_3_6</code>.</p><p>These approaches are just some engrafts for bringing dependency injection in validators and this seems to be the only workaround in JSF 2.0. Starting with JSF 2.2, injection is possible in many more artifacts, but as the specification says, converters and validators are still not injection targets. It seems that this will be available from JSF 2.3.</p><p>Contrary to this affirmation, I tried to write a validator and use the injection as it should natively work. I used <code class="literal">@Inject</code> as follows where <code class="literal">LoginBean</code> is a CDI application scoped bean:</p><div class="informalexample"><pre class="programlisting">@FacesValidator
public class EmailValidator implements Validator {

 @Inject
 LoginBean loginBean;

 @Override
 public void validate(FacesContext context,
        UIComponent component, Object value) throws ValidatorException {
...</pre></div><p>Moreover, I also tried to inject an EJB using <code class="literal">@EJB</code> and <code class="literal">@Inject</code> where <code class="literal">LoginEJBBean</code> is a stateless session bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@FacesValidator
public class EmailValidator implements Validator {

 @EJB
 LoginEJBBean loginEJBBean;
 //@Inject
 //LoginEJBBean loginEJBBean;
 
 @Override
 public void validate(FacesContext context,
        UIComponent component, Object value) throws ValidatorException {
...</pre></div><p>I have to admit that I was<a id="id545" class="indexterm"/> expecting to see a <code class="literal">null</code> value for the injected resource, but surprisingly, everything worked as expected in all cases. There are rumors that, initially, the injection mechanism for validators and convertors was added in JSF 2.2, but it was removed at the last moment because some tests failed. Even if the preceding examples worked fine, it doesn't mean that is a good practice to use this approach in production. You'd better wait until it is guaranteed by the JSF team.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>If you are a fan of OmniFaces, then you can use <code class="literal">@Inject</code> and <code class="literal">@EJB</code> with <code class="literal">@FacesValidator</code>. This great facility was added starting with Version 1.6 (<a class="ulink" href="http://showcase.omnifaces.org/cdi/FacesValidator">http://showcase.omnifaces.org/cdi/FacesValidator</a>). Moreover, MyFaces CODI (<a class="ulink" href="http://myfaces.apache.org/extensions/cdi/">http://myfaces.apache.org/extensions/cdi/</a>) can also be a workaround, but it<a id="id546" class="indexterm"/> requires an additional <code class="literal">@Advanced</code> annotation.</p></div></div><p>The complete examples are available in the code bundle of this chapter and they are named <code class="literal">ch4_3_3</code> (web application) and <code class="literal">ch4_3_4</code> (enterprise application), respectively.</p><p>When discussing <span class="strong"><strong>converters</strong></span>, let's remember that the conversion between two <code class="literal">UIInput</code> instances happens in the <span class="emphasis"><em>Process Validations</em></span> phase (default), which can be moved to <span class="emphasis"><em>Apply Request Values</em></span> phase<a id="id547" class="indexterm"/> using the <code class="literal">immediate</code> attribute set to <code class="literal">true</code>. For <code class="literal">UIOutput</code>, the conversion happens in the <span class="emphasis"><em>Render Response</em></span> phase.</p><p>Beside the built-in converters, we can write our custom converters. A public class that implements the <code class="literal">Converter</code> interface and overrides the <code class="literal">getAsObject</code> and <code class="literal">getAsString</code> methods is recognized by JSF as a <span class="strong"><strong>converter</strong></span>. There are two ways to configure a converter in JSF: using the <code class="literal">@FacesConverter</code> annotation or the <code class="literal">&lt;converter&gt;</code> tag in <code class="literal">faces-config.xml</code>.</p><p>Concerning we have the following converter configured using <code class="literal">@FacesConverter</code> (remember that JSF 2.2 doesn't need the <code class="literal">value</code> attribute):</p><div class="informalexample"><pre class="programlisting">@FacesConverter(value="playerConverter")
public class PlayerConverter implements Converter{

 @Override
 public Object getAsObject(FacesContext context,
               UIComponent component, String value) {
   PlayerName playerName = new
          PlayerName(value.toLowerCase(), value.toUpperCase());
        
   return playerName;
   }

   @Override
   public String getAsString(FacesContext context,
          UIComponent component, Object value) {

   PlayerName playerName = (PlayerName)value;

   return "Mr. " + playerName.getUppercase();
   }    
}</pre></div><p>If you prefer to use <code class="literal">faces-config.xml</code>, then <code class="literal">PlayerConverter</code> can be configured as follows:</p><div class="informalexample"><pre class="programlisting">&lt;converter&gt;
 &lt;converter-id&gt;playerConverter&lt;/converter-id&gt;
 &lt;converter-class&gt;book.beans.PlayerConverter&lt;/converter-class&gt;
&lt;/converter&gt;</pre></div><p>Now, you can easily link the converter to an input component as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}"&gt;
 &lt;f:converter converterId="playerConverter"/&gt;
&lt;/h:inputText&gt;</pre></div><p>An alternate way to do this is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}" converter="playerConverter"/&gt;</pre></div><p>Moreover, you can write this as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}"/&gt;</pre></div><p>If you configure the<a id="id548" class="indexterm"/> converter using the<a id="id549" class="indexterm"/> <code class="literal">forClass</code> attribute, skip the <code class="literal">value</code> attribute as follows:</p><div class="informalexample"><pre class="programlisting">@FacesConverter(forClass=PlayerName.class)</pre></div><p>The complete example of <code class="literal">PlayerConverter</code> is available in the code bundle of this chapter and it is named <code class="literal">ch4_6_1</code>.</p><p>Speaking about <a id="id550" class="indexterm"/>dependency injection, having converters as targets is pretty similar with the situation of validators:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Replace the <code class="literal">@FacesConverter</code> annotation with <code class="literal">@Named</code> and <code class="literal">@ManagedBean</code> (for Spring, you can use <code class="literal">@Component</code> also)</li><li class="listitem">Put the bean in the request scope (use the proper <code class="literal">@RequestScoped</code> annotation) as follows:<div class="informalexample"><pre class="programlisting">@Named(value="playerConverter")
@RequestScoped
public class PlayerConverter implements Converter{

 @Override
 public Object getAsObject(FacesContext context,
        UIComponent component, String value) {
 ...
 }

 @Override
 public String getAsString(FacesContext context,
        UIComponent component, Object value) {
 ...
 }
}</pre></div></li><li class="listitem">Refer to it using the proper EL expression as follows:<div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{<span class="emphasis"><em>bean property</em></span>}" converter="#{playerConverter}"/&gt;</pre></div></li></ol></div><p>The complete example can be found in the code bundle of this chapter and it is named <code class="literal">ch4_6_2</code>. EJBs can be injected in converters by looking up the EJB session bean from JNDI. Refer to the examples <code class="literal">ch4_6_5</code> (EJBs in EAR) and <code class="literal">ch4_6_6</code> (EJBs in WAR).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The following block of code in the <code class="literal">ch4_6_5</code> application; <code class="literal">RandomEJBBean</code> is a stateless session bean:<div class="informalexample"><pre class="programlisting">@FacesConverter(value = "playerConverter")
public class PlayerConverter implements Converter {

 private static RandomEJBBean randomEJBBean;

  static {
      try {
        randomEJBBean = (RandomEJBBean) new InitialContext().
         lookup("java:global/ch4_6_5/ch4_6_5-ejb/RandomEJBBean");
      } catch (NamingException e) {
        throw new ExceptionInInitializerError(e);
      }
}
...</pre></div></li><li class="listitem" style="list-style-type: disc">The following block<a id="id551" class="indexterm"/> of code in the <code class="literal">ch4_6_6</code> application; <code class="literal">RandomEJBBean</code> is a stateless session bean:<div class="informalexample"><pre class="programlisting">@FacesConverter(value = "playerConverter")
public class PlayerConverter implements Converter {

    private static RandomEJBBean randomEJBBean;

    static {
        try {
            randomEJBBean = (RandomEJBBean) new InitialContext().
             lookup("java:app/ch4_6_6/RandomEJBBean");
        } catch (NamingException e) {
            throw new ExceptionInInitializerError(e);
        }
    }
...</pre></div></li></ul></div><p>Moreover, under GlassFish 4.0 and Mojarra 2.2.x, I was able to successfully run two applications that use <a id="id552" class="indexterm"/>injection in converters without any fancy workaround. See examples <code class="literal">ch4_6_3</code> and <code class="literal">ch4_6_4</code>. Do remember that this approach is not officially adopted, however.</p></div>
<div class="section" title="Configuring navigation"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Configuring navigation</h1></div></div></div><p>Starting with JSF 2, navigation <a id="id553" class="indexterm"/>became much easier. Navigation can be accomplished using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implicit navigation</li><li class="listitem" style="list-style-type: disc">Conditional navigation</li><li class="listitem" style="list-style-type: disc">Preemptive navigation</li><li class="listitem" style="list-style-type: disc">Programmatic navigation</li></ul></div><p>We can talk for hours and hours about JSF navigation, but there are a few golden rules that save us from falling for the most common mistakes when we need to choose between <code class="literal">GET</code> and <code class="literal">POST</code>. It might be useful to know that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is recommended to use the <code class="literal">GET</code> request for page-to-page navigation, search forms, URLs that you want to be visible and bookmarkable, and, in general, for any idempotent request. By specification, <code class="literal">GET</code>, <code class="literal">HEAD</code>, <code class="literal">PUT</code>, <code class="literal">DELETE</code>, <code class="literal">OPTIONS</code>, and <code class="literal">TRACE</code> are idempotent.</li><li class="listitem" style="list-style-type: disc">For requests that shouldn't be bookmarkable, use the same view repeatedly (use forward, not redirect).</li><li class="listitem" style="list-style-type: disc">For requests that shouldn't be bookmarkable, but have bookmarkable targets, use <code class="literal">POST</code> and redirect.</li></ul></div><div class="section" title="Implicit navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Implicit navigation</h2></div></div></div><p><span class="strong"><strong>Implicit navigation</strong></span><a id="id554" class="indexterm"/> interprets navigation outcomes as target view IDs. The<a id="id555" class="indexterm"/> simplest implicit navigation case is accomplished by JSF itself whenever you perform an action and no navigation is indicated. In<a id="id556" class="indexterm"/> this case, JSF will post a form (via <code class="literal">HTTP POST</code>) back to the current view (render the current view again).</p><p>Without declarative navigation in <code class="literal">faces-config.xml</code>, we can easily write navigation cases, such as the following where JSF 2 knows how to treat <code class="literal">outcome</code> (or the <code class="literal">action</code> value) as the targeted page name:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputLink value="success.xhtml"&gt;Success&lt;/h:outputLink&gt;
&lt;h:link value="Success" outcome="success"/&gt;
&lt;h:button value="Success" outcome="success"/&gt;
&lt;h:commandButton value="Success" action="success"/&gt;
&lt;h:commandLink value="Success" action="success"/&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>If the <code class="literal">success.xhtml</code> page exists, then all the given examples will navigate to this page. The <code class="literal">&lt;h:outputLink&gt;</code> element will navigate independently of JSF (that means it doesn't interact with JSF). The <code class="literal">&lt;h:link&gt;</code> and <code class="literal">&lt;h:button&gt;</code> elements will navigate via a bookmarkable <code class="literal">GET</code> request and aren't capable of form submissions (as you will see, this is actually preemptive navigation). The <code class="literal">&lt;h:commandButton&gt;</code> and <code class="literal">&lt;h:commandLink&gt;</code> elements are the main components for navigating within a JSF application. They fire <code class="literal">POST</code> requests and are capable of form submissions. Whenever you want to add the application context path in a URL (for example, the URL generated via <code class="literal">&lt;h:outputLink&gt;</code>, you can use the <code class="literal">ExternalContext.getApplicationContextPath</code> method of JSF 2.2. For example, take a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputLink value="#{facesContext.externalContext. applicationContextPath}/next.xhtml"&gt;Next&lt;/h:outputLink&gt;</pre></div></div></div><p>The declarative<a id="id557" class="indexterm"/> version of this is as follows—thanks to<a id="id558" class="indexterm"/> implicit navigation, this code is not needed:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;*&lt;/from-view-id&gt;
 &lt;navigation-case&gt;               
  &lt;from-outcome&gt;success&lt;/from-outcome&gt;
  &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p>The outcome of <code class="literal">&lt;h:link&gt;</code> and <code class="literal">&lt;h:button&gt;</code> are evaluated during the <span class="emphasis"><em>Render Response</em></span> phase; therefore, the URLs are available right from the start of the corresponding view. On the other hand, when the button (<code class="literal">&lt;h:commandButton&gt;</code>) or link (<code class="literal">&lt;h:commandLink&gt;</code>) is clicked, JSF will merge the <code class="literal">action</code> value <code class="literal">success</code> with the XHTML extension and find the view name <code class="literal">success.xhtml</code> in the current page directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>Wildcard ("*") is supported to specify a navigation rule that applies to all pages. It can be useful for a logout page.</p></div></div><p>The navigation case can also pass through a bean method, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Success" action="#{playerBean.playerDone()}"/&gt;</pre></div><p>Also, the <code class="literal">PlayerBean</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">public String playerDone() {
 logger.log(Level.INFO, "playerDone method called ...");
 return "success";
}</pre></div><p>In these examples, the <code class="literal">outcome</code>/<code class="literal">action</code> values and the target view ID matches. However, the <code class="literal">outcome</code>/<code class="literal">action</code> values and target view ID are not always that simple. The <code class="literal">outcome</code>/<code class="literal">action</code> values are used to determine the target view ID even if they don't have the same root. For example, refer to the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Success" action="done"/&gt;</pre></div><p>The preceding code indicates the <code class="literal">done.xhtml</code> page, but this page doesn't exist; therefore, no navigation<a id="id559" class="indexterm"/> happens. We need to add a declarative <a id="id560" class="indexterm"/>navigation rule in <code class="literal">faces-config.xml</code> in order to link the <code class="literal">action</code> value (or the <code class="literal">outcome</code> value that is fetched via preemptive navigation, which we will see soon), <code class="literal">done</code>, with target view ID, <code class="literal">success.xhtml</code>. This navigation rule can be seen in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;               
   &lt;from-outcome&gt;done&lt;/from-outcome&gt;
   &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;  </pre></div><p>If the bean method returns the outcome <code class="literal">done</code>, then the navigation rules are modified as follows:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;
  &lt;from-action&gt;#{playerBean.playerDone()}&lt;/from-action&gt;
  &lt;from-outcome&gt;done&lt;/from-outcome&gt;
  &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p>By default, between <span class="strong"><strong>forward</strong></span> and <span class="strong"><strong>redirect</strong></span>, JSF will navigate from one page to another using the forward mechanism (<code class="literal">HTTP POST</code>). When JSF receives the user action, it will forward the user to the determined target page, which means that the URL displayed by the browser will not be updated to reflect the current target. Keeping the browser URL updated implies the page redirection<span class="emphasis"><em> </em></span>mechanism; in this case, JSF, delegates the browser to send a separate <code class="literal">GET</code> request to the target page.</p><p>You can use the page redirection mechanism by attaching the <code class="literal">faces-redirect=true</code> parameter to the outcome query string as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Success" action="success?faces-redirect=true;"/&gt;</pre></div><p>Alternatively, you can use the <code class="literal">&lt;redirect/&gt;</code> tag inside the navigation rule as follows:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;               
  &lt;from-outcome&gt;done&lt;/from-outcome&gt;
  &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
<span class="strong"><strong>  &lt;redirect/&gt;</strong></span>
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>In the forward case, the browser URL is not updated (is with a step behind navigation URL), but there is a single request. In the redirect case, the browser URL is up to date, but there are two requests. Since forward needs a single request, it is faster than page redirection. The speed is lower, but page redirection solves the duplicated form submission problem found in the Post-Redirect-Get design pattern. Of course, this is not the case for <code class="literal">&lt;h:link&gt;</code>, <code class="literal">&lt;h:button&gt;</code>, and <code class="literal">&lt;h:outputLink&gt;</code>.</p></div></div><p>These examples are<a id="id561" class="indexterm"/> grouped in the <code class="literal">ch4_5_1</code> application<a id="id562" class="indexterm"/> in the code bundle of this chapter.</p></div><div class="section" title="Conditional navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Conditional navigation</h2></div></div></div><p><span class="strong"><strong>Conditional navigation</strong></span><a id="id563" class="indexterm"/> allows us to specify preconditions for choosing the desired navigation case; a precondition must be met in order for the navigation case<a id="id564" class="indexterm"/> to be accepted. For this, we use the <code class="literal">&lt;if&gt;</code> tag as a child of the <code class="literal">&lt;navigation-case&gt;</code> tag and use an EL expression that can be evaluated to a Boolean value; here the <code class="literal">true</code> value matches the navigation case.</p><p>Let's have a simple button that logs the user into the application. This is done using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Login" action="#{playerBean.playerLogin()}"/&gt;</pre></div><p>When the <span class="strong"><strong>Login</strong></span> button is clicked, JSF <a id="id565" class="indexterm"/>will call the <code class="literal">playerLogin</code> method. This method will not return an outcome, actually it returns <code class="literal">void</code>. In this example, we simulate a login process through a random number and set a Boolean value, <code class="literal">login</code>, accordingly, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private boolean login  = false;
...
public boolean isLogin() {
 return login;
}   

public void setLogin(boolean login) {
 this.login = login;
}    

public void playerLogin() {

 Random random = new Random();
 int r = random.nextInt(10);
 if (r &lt;= 5) {
  login = false;
  } else {
    login = true;
  }
 }</pre></div><p>Next, we can use the <code class="literal">&lt;if&gt;</code> tag to<a id="id566" class="indexterm"/> decide if we navigate <a id="id567" class="indexterm"/>to the <code class="literal">success.xhtml</code> page (equivalent to <code class="literal">login</code> equals <code class="literal">true</code>) or to the <code class="literal">failed.xhtml</code> page (equivalent to <code class="literal">login</code> equals <code class="literal">false</code>):</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;
  &lt;from-action&gt;#{playerBean.playerLogin()}&lt;/from-action&gt;
  &lt;if&gt;#{playerBean.login}&lt;/if&gt;
  &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
  &lt;redirect/&gt;
 &lt;/navigation-case&gt;
 &lt;navigation-case&gt;
  &lt;from-action&gt;#{playerBean.playerLogin()}&lt;/from-action&gt;
  &lt;if&gt;#{!playerBean.login}&lt;/if&gt;
  &lt;to-view-id&gt;/failed.xhtml&lt;/to-view-id&gt;
  &lt;redirect/&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>In conditional navigation, the navigation cases are evaluated even when the outcome is <code class="literal">null</code> or <code class="literal">void</code>. Notice that there is no <code class="literal">&lt;else&gt;</code> tag or multiple conditional checking; therefore, in such cases, you have to emulate a <code class="literal">switch</code> statement. If you want to simply match the <code class="literal">null</code> outcome in any case, then you can use a condition of type: <code class="literal">&lt;if&gt;#{true}&lt;/if&gt;</code>.</p><p>Moreover, the sequence of the navigation rule affects the navigation flow; therefore, it is a good practice to prioritize conditions.</p></div></div><p>You can find the complete example in the code bundle of this chapter, under the name <code class="literal">ch4_5_2</code>.</p><p>We can write conditional navigation cases without the <code class="literal">&lt;if&gt;</code> tag by delegating the decision of choosing <a id="id568" class="indexterm"/>the navigation case to a bean method. For this, we have to replace the static value of the <code class="literal">&lt;to-view-id&gt;</code> tag with an EL expression, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;
  &lt;from-action&gt;#{playerBean.playerLogin()}&lt;/from-action&gt;  
  &lt;to-view-id&gt;#{playerBean.navigateHelper()}&lt;/to-view-id&gt;
  &lt;redirect/&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p>Notice that this is<a id="id569" class="indexterm"/> not a real conditional navigation (since <code class="literal">&lt;if&gt;</code> is missing); therefore, we need to return an outcome from the <code class="literal">playerLogin</code> method:</p><div class="informalexample"><pre class="programlisting">public String playerLogin() {

 Random random = new Random();
 int r = random.nextInt(10);
 login = r &gt; 5;        
 return "done";
}</pre></div><p>When the <code class="literal">login</code> property is set and the outcome <code class="literal">done</code> is returned, JSF will follow the preceding navigation case and reach<a id="id570" class="indexterm"/> for the <code class="literal">navigateHelper</code> method:</p><div class="informalexample"><pre class="programlisting">public String navigateHelper() {
 if (!login) {
  return "failed.xhtml";
 } else {
  return "success.xhtml";
 }
}</pre></div><p>In a real application, the method that returns the outcome and the method that chooses the navigation case will probably be in different beans. If you take into account that you can pass arguments to the decisional method, then many navigation cases can be solved.</p><p>You can find the <a id="id571" class="indexterm"/>complete example in the code bundle of this chapter, under <a id="id572" class="indexterm"/>the name <code class="literal">ch4_5_3</code>.</p></div><div class="section" title="Preemptive navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Preemptive navigation</h2></div></div></div><p><span class="strong"><strong>Preemptive navigation</strong></span> is<a id="id573" class="indexterm"/> available starting with JSF 2.0. The navigation rules are more permissive and they are evaluated during the <span class="emphasis"><em>Render Response</em></span> phase instead of the <span class="emphasis"><em>Invoke Application</em></span> phase.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>This is known as predetermined navigation or preemptive navigation. The current view ID and specified outcome are used to determine the target view ID. Afterwards, the target view ID is translated into a bookmarkable URL and used as the hyperlink's target. Practically, the URL is prepared without user interaction.</p></div></div><p>The main usage <a id="id574" class="indexterm"/>of preemptive navigation appears in bookmarkable component tags, <code class="literal">&lt;h:link&gt;</code> and <code class="literal">&lt;h:button&gt;</code>. For example, the following are two classical examples of preemptive navigation:</p><div class="informalexample"><pre class="programlisting">&lt;h:link value="Success" outcome="success"/&gt;
&lt;h:button value="Success" outcome="success"/&gt;</pre></div><p>When the application starts, you can check the source code of the page to see how the corresponding URLs were mapped in the HTML tag <code class="literal">&lt;a&gt;</code> in case of <code class="literal">&lt;h:link&gt;</code>, and the HTML tag <code class="literal">&lt;input type="button"&gt;</code> in case of <code class="literal">&lt;h:button&gt;</code>. Even if you never use those URLs, they are ready to serve.</p><p>Well, before JSF 2.0, navigation rules were explicitly the domain of <code class="literal">POST</code> requests (<code class="literal">NavigationHandler.handleNavigation</code> was doing the dirty job behind the scene), but the new support for GET-based navigation and bookmarkability takes navigation to another level of flexibility and transparency (for example, the <code class="literal">ConfigurableNavigationHandler</code> API).</p><p>The interesting part here is how the query string of a URL is assembled. The simplest case consists of the implicit query string parameter as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:link value="Done" outcome="done?id=done"/&gt;</pre></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Communication in JSF">Chapter 2</a>, <span class="emphasis"><em>Communication in JSF</em></span>, you saw how to build the query string using <code class="literal">&lt;f:param&gt;</code> and <code class="literal">&lt;f:viewParam&gt;</code>.</p><p>Another way consists in using the <code class="literal">&lt;view-param&gt;</code> tag nested in a <code class="literal">&lt;redirect&gt;</code> tag in a navigation case. For example, we can add query string parameters to a redirect URL in the navigation rules. Let's create the following button:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Success" action="#{playerBean.playerDone()}"/&gt;</pre></div><p>Also, a silly method named <code class="literal">playerDone</code> is as follows:</p><div class="informalexample"><pre class="programlisting">private String player;

 public String getPlayer() {
  return player;
 }       

 public void setPlayer(String player) {
  this.player = player;
 }        

 public String playerDone() {
  player = "Rafael Nadal";
  return "done";
 }</pre></div><p>Now, we can add the <code class="literal">player</code> property value (of course, you can add any other value) as a parameter in the query<a id="id575" class="indexterm"/> string of the<a id="id576" class="indexterm"/> redirection navigation URL:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
 &lt;from-view-id&gt;/index.xhtml&lt;/from-view-id&gt;
 &lt;navigation-case&gt;
  &lt;from-action&gt;#{playerBean.playerDone()}&lt;/from-action&gt;
  &lt;from-outcome&gt;done&lt;/from-outcome&gt;
  &lt;to-view-id&gt;/success.xhtml&lt;/to-view-id&gt;
  &lt;redirect&gt;
   &lt;view-param&gt;
    &lt;name&gt;playerparam&lt;/name&gt;
    &lt;value&gt;#{playerBean.player}&lt;/value&gt;
   &lt;/view-param&gt;
  &lt;/redirect&gt;
 &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</pre></div><p>A URL like this will be of the format (notice how the request parameter was attached based on the navigation rule) <code class="literal">http://</code><span class="emphasis"><em>host</em></span><code class="literal">:</code><span class="emphasis"><em>port</em></span><code class="literal">/</code><span class="emphasis"><em>app-name</em></span><code class="literal">/faces/success.xhtml?playerparam=Rafael+Nadal</code>.</p><p>The <code class="literal">playerparam</code> value will be available through the <code class="literal">param</code> implicit object:</p><div class="informalexample"><pre class="programlisting">#{param['playerparam']}</pre></div><p>You can find the complete example in the code bundle of this chapter, under the name <code class="literal">ch4_5_4</code>.</p></div><div class="section" title="Programmatic Navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Programmatic Navigation</h2></div></div></div><p>Sometimes, you need to<a id="id577" class="indexterm"/> control navigation directly from the application. JSF provides the <code class="literal">NavigationHandler</code> and <code class="literal">ConfigurableNavigationHandler</code> APIs that can<a id="id578" class="indexterm"/> be used for tasks such as accessing navigation cases, customizing navigation handlers, conditional<a id="id579" class="indexterm"/> navigations, and so on. It is good to know that, programmatically speaking, we can do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Obtain access to<a id="id580" class="indexterm"/> navigation handler (<code class="literal">NavigationHandler</code>) using the following code:<div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
Application application = context.getApplication();
NavigationHandler nh = application.getNavigationHandler();</pre></div></li><li class="listitem">Invoke navigation case using <code class="literal">NavigationHandler</code> as follows:<div class="informalexample"><pre class="programlisting">nh.handleNavigation(<span class="emphasis"><em>context,fromAction,outcome</em></span>);
nh.handleNavigation(<span class="emphasis"><em>context,fromAction,outcome,toFlowDocumentId</em></span>);</pre></div></li><li class="listitem">Access the <code class="literal">ConfigurableNavigationHandler</code> API using the following code:<div class="informalexample"><pre class="programlisting">ConfigurableNavigationHandler cnh = (ConfigurableNavigationHandler) FacesContext.getCurrentInstance().getApplication().getNavigationHandler();</pre></div></li><li class="listitem">Invoke navigation case using <code class="literal">ConfigurableNavigationHandler</code> as follows:<div class="informalexample"><pre class="programlisting">cnh.handleNavigation(<span class="emphasis"><em>context,fromAction,outcome</em></span>);
cnh.handleNavigation(<span class="emphasis"><em>context,fromAction,outcome,toFlowDocumentId</em></span>);</pre></div></li><li class="listitem">Retrieve one <code class="literal">NavigationCase</code> object by the action expression signature and outcome as shown in the following code:<div class="informalexample"><pre class="programlisting">NavigationCase case = cnh.getNavigationCase(<span class="emphasis"><em>context,fromAction,outcome</em></span>);
NavigationCase case = cnh.getNavigationCase(<span class="emphasis"><em>context,fromAction,outcome, toFlowDocumentId</em></span>);</pre></div></li><li class="listitem">Access all navigation rules into <code class="literal">Map&lt;String, Set&lt;NavigationCase&gt;&gt;</code>, where the keys are the <code class="literal">&lt;from-view-id&gt;</code> values as follows:<div class="informalexample"><pre class="programlisting">Map&lt;String, Set&lt;NavigationCase&gt;&gt; cases = cnh.getNavigationCases();</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note82"/>Note</h3><p>Starting with JSF 2.2, we have <span class="strong"><strong>wrappers</strong></span><a id="id581" class="indexterm"/> for many classes that provide basic implementations and help developers to extend those classes and override only the necessary methods. Among them, we have a wrapper class for <code class="literal">NavigationHandler</code>, named <code class="literal">NavigationHandlerWrapper</code>, one for <code class="literal">ConfigurableNavigationHandler</code>, named <code class="literal">ConfigurableNavigationHandlerWrapper</code>, and one for <code class="literal">NavigationCase</code>, named <code class="literal">NavigationCaseWrapper</code>.</p></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication">Chapter 3</a>, <span class="emphasis"><em>JSF Scopes – Lifespan and Use in Managed Beans Communication</em></span>, you saw a custom implementation of <code class="literal">ConfigurableNavigationHandler</code> in <span class="emphasis"><em>The flow scope</em></span> section, and you<a id="id582" class="indexterm"/> saw a custom implementation of <code class="literal">NavigationHandler</code> in the <span class="emphasis"><em>Controlling the custom scope lifespan with the navigation handler</em></span> section.</p></div></div>
<div class="section" title="Configuring action listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Configuring action listeners</h1></div></div></div><p>Action listeners are a great facility provided by JSF for dealing with action events. Commonly, action<a id="id583" class="indexterm"/> listeners are attached to command buttons (<code class="literal">&lt;h:commandButton&gt;</code>) or command links (<code class="literal">&lt;h:commandLink&gt;</code>) using the <a id="id584" class="indexterm"/>
<code class="literal">actionListener</code> attribute.</p><p>When a button/link is clicked, JSF calls the action listener during the <span class="emphasis"><em>Invoke Application </em></span>phase. Notice that if you are using <code class="literal">immediate="true"</code>, then the action listener is called during the <span class="emphasis"><em>Apply Request Values</em></span> phase. The method, indicated as a listener, should be public, should return <code class="literal">void</code>, and should accept an <code class="literal">ActionEvent</code> object<a id="id585" class="indexterm"/> (this object can be used to access the<a id="id586" class="indexterm"/> component that invoked the action), which can perform specific tasks. When its execution has finished, JSF will call the method bound by the <code class="literal">action</code> attribute (if it exists!). This method is responsible to indicate the navigation case. The action listener method can alter the response returned by the action method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note83"/>Note</h3><p>As a practice, <code class="literal">actionListener</code> is used to have some "fun" before the real business and navigation task, which is the responsibility of <code class="literal">action</code>. So, do not abuse <code class="literal">actionListener</code> for solving business logic tasks!</p></div></div><p>Let's use an example of a simple command button that uses an action listener, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Player Listener 1"
                 actionListener="#{playerBean.playerListener}"
                 action="#{playerBean.playerDone()}"/&gt;</pre></div><p>The <code class="literal">PlayerBean</code> contains the following code:</p><div class="informalexample"><pre class="programlisting">public void playerListener(ActionEvent e) {
 logger.log(Level.INFO, "playerListener method called ...");
}

public String playerDone() {
 logger.log(Level.INFO, "playerDone method called ...");
 return "done";
}</pre></div><p>Well, the log messages reveal the order of calls as follows:</p><div class="informalexample"><pre class="programlisting">INFO:   playerListener method called ...
INFO:   playerDone method called ...</pre></div><p>This kind of listener doesn't need any special configuration.</p><p>Another type of listener <a id="id587" class="indexterm"/>can be written by implementing the <code class="literal">ActionListener</code> interface and overriding the <code class="literal">processAction</code> method. In this case, we need to use the <code class="literal">&lt;f:actionListener&gt;</code> tag<a id="id588" class="indexterm"/> for attaching the action listener to a command button/link:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Player Listener 2"
                 action="#{playerBean.playerDone()}"&gt;
  &lt;f:actionListener type="book.beans.PlayerListener"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>Well, the <code class="literal">PlayerListener</code> is<a id="id589" class="indexterm"/> defined as follows:</p><div class="informalexample"><pre class="programlisting">public class PlayerListener implements ActionListener {

  private static final Logger logger =
        Logger.getLogger(PlayerListener.class.getName());
    
 @Override
 public void processAction(ActionEvent event)
                          throws AbortProcessingException {
        
  logger.log(Level.INFO, "Player listener class called ...");
 }            
}</pre></div><p>And, the output of the log messages will be as follows:</p><div class="informalexample"><pre class="programlisting">INFO:   Player listener class called ...
INFO:   playerDone method called ...</pre></div><p>Again, these kinds of listeners do not need any special configurations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note84"/>Note</h3><p>Starting with JSF 2.2 the <code class="literal">ActionListener</code> interface was wrapped in a simple implementation named, <code class="literal">ActionListenerWrapper</code>. You need to extend this class and override <code class="literal">getWrapped</code> to return the wrapped instance.</p></div></div><p>For example, the <code class="literal">PlayerListener </code>may be called via the following wrapper:</p><div class="informalexample"><pre class="programlisting">public class PlayerListenerW extends ActionListenerWrapper {

    PlayerListener playerListener = new PlayerListener();

    @Override
    public ActionListener getWrapped() {
        return playerListener;
    }
}</pre></div><p>You can even<a id="id590" class="indexterm"/> combine these two listeners into a single command button, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Player Listener 3"
                 actionListener="#{playerBean.playerListener}"
                 action="#{playerBean.playerDone()}"&gt;
 &lt;f:actionListener type="book.beans.PlayerListener"/&gt;
&lt;/h:commandButton&gt;</pre></div><p>In this case, the log messages are as follows:</p><div class="informalexample"><pre class="programlisting">INFO:   playerListener method called ...
INFO:   Player listener class called ...
INFO:   playerDone method called ...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note85"/>Note</h3><p>Well, this example gives us an important rule: the action listeners are invoked before <code class="literal">action</code> and in the same order as they are declared inside the component.</p></div></div><div class="section" title="Application action listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Application action listeners</h2></div></div></div><p>So far so good! The last category of action listeners are known as application action listeners. They<a id="id591" class="indexterm"/> are set on the application level and are<a id="id592" class="indexterm"/> called by JSF even for command buttons/links that do not specify any action listener explicitly. Such an action listener may look like the following code:</p><div class="informalexample"><pre class="programlisting">public class ApplicationPlayerListener implements ActionListener {

 private static final Logger logger =
         Logger.getLogger(PlayerListener.class.getName());
 private ActionListener actionListener;

 public ApplicationPlayerListener() {      
 }

 public ApplicationPlayerListener(ActionListener actionListener) {
  this.actionListener = actionListener;
 }
    
 @Override
 public void processAction(ActionEvent event)
                    throws AbortProcessingException {

  logger.log(Level.INFO, "Application player listener class called ...");  
  actionListener.processAction(event);
 }            
}</pre></div><p>This action listener will<a id="id593" class="indexterm"/> be called for a command button/link even if it doesn't specify it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Player Listener 4"
                 action="#{playerBean.playerDone()}" /&gt;   </pre></div><p>The output will be as follows:</p><div class="informalexample"><pre class="programlisting">INFO:   Application player listener class called ...
INFO:   playerDone method called ...</pre></div><p>In JSF 2.2, we can write this implementation<a id="id594" class="indexterm"/> by extending <code class="literal">ActionListenerWrapper</code> as follows:</p><div class="informalexample"><pre class="programlisting">public class ApplicationPlayerListenerW extends ActionListenerWrapper {

 private ActionListener actionListener;
 private static final Logger logger =
         Logger.getLogger(ApplicationPlayerListenerW.class.getName());

  public ApplicationPlayerListenerW(){}
    
  public ApplicationPlayerListenerW(ActionListener actionListener){
   this.actionListener = actionListener;
  }
    
  @Override
  public void processAction(ActionEvent event)
         throws AbortProcessingException {
  logger.log(Level.INFO, "Application player listener
                                 (wrapper) class called ...");
  getWrapped().processAction(event);
 }

 @Override
 public ActionListener getWrapped() {        
  return this.actionListener;
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note86"/>Note</h3><p>Application action listeners are called after the action listeners that are explicitly set via the <code class="literal">actionListener</code> attribute or the <code class="literal">&lt;f:actionListener&gt;</code> tag.</p></div></div><p>In order to be called, such<a id="id595" class="indexterm"/> listeners must be <a id="id596" class="indexterm"/>configured in <code class="literal">faces-config.xml</code>. For example, the preceding listener can be configured as follows:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
 &lt;action-listener&gt;book.beans.ApplicationPlayerListener&lt;/action-listener&gt;
&lt;/application&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note87"/>Note</h3><p>When you are using application action listeners, it is important to keep in mind a few things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Application action listeners cannot invoke other listeners.</li><li class="listitem" style="list-style-type: disc">Application action listeners are responsible for processing the <code class="literal">action</code> attribute.</li><li class="listitem" style="list-style-type: disc">Application action listeners cannot catch events from other listeners.</li></ul></div></div></div><p>You have probably noticed that an action listener throws an <code class="literal">AbortProcessingException</code> exception. When this exception appears, JSF will directly jump to render the response and ignore <a id="id597" class="indexterm"/>further action listeners. The error is <span class="emphasis"><em>swallowed</em></span> by default, so don't expect to see it! You can make it visible by altering the default mechanism of treating exceptions.</p><p>You might think that action listeners rock! Wait till you see this starting with JSF 2.2. We can use the injection mechanism for injecting CDI managed beans and EJBs in action listener classes. For example, the simple bean shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class DemoBean {

    private String demo = "TEST INJECTION VALUE ...";

    public String getDemo() {
        return demo;
    }

    public void setDemo(String demo) {
        this.demo = demo;
    }
}</pre></div><p>This bean can be injected in our application action listener as follows:</p><div class="informalexample"><pre class="programlisting">public class ApplicationPlayerListener implements ActionListener {

  @Inject
  private DemoBean demoBean;
...</pre></div><p>Obviously, this facility <a id="id598" class="indexterm"/>opens new perspectives in<a id="id599" class="indexterm"/> implementing applications. And, as you will see next, injection mechanism is available for many other JSF artifacts that do not support it in JSF 2.0.</p><p>A complete example named <code class="literal">ch4_1</code>, is available in the code bundle of this chapter.</p></div></div>
<div class="section" title="Configuring system event listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Configuring system event listeners</h1></div></div></div><p>JSF 2.0 allows us to use <span class="strong"><strong>system events</strong></span>. These<a id="id600" class="indexterm"/> are events that can be fired by arbitrary objects at arbitrary points during the request processing lifecycle. Since the number<a id="id601" class="indexterm"/> of these events is quite big, you will not see them entirely covered here, but the next five examples should clarify the basic aspects of system events. You can find all of them in the <code class="literal">javax.faces.event</code> package.</p><div class="section" title="Using &lt;f:event&gt;"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Using &lt;f:event&gt;</h2></div></div></div><p>The easiest way to use system <a id="id602" class="indexterm"/>event listeners consists in passing the name of the managed bean method in the <code class="literal">listener</code> attribute of the <code class="literal">&lt;f:event&gt;</code> tag. For example, <code class="literal">PostValidateEvent</code> is<a id="id603" class="indexterm"/> a system event that gets fired after all components are validated. This can be useful to validate<a id="id604" class="indexterm"/> multiple components. Suppose, that a user submits a form that contains his name, surname, bank account, and the confirmation of that bank account (like a password that should be typed twice for confirmation). In order to check if the same bank account was typed in both fields, we can use <code class="literal">PostValidateEvent</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;        
 &lt;h:form id="registerForm"&gt;            
<span class="strong"><strong>  &lt;f:event listener="#{playersBean.validateAccount}" </strong></span>
<span class="strong"><strong>           type="postValidate" /&gt;</strong></span>
  ...
  &lt;h:inputText id="bankAccountId" value="#{playersBean.bank}" 
               required="true" /&gt;
  &lt;h:message for="bankAccountId" style="color: red;" /&gt;              
  &lt;h:inputText id="confirmBankAccountId" 
               value="#{playersBean.cbank}" required="true" /&gt;
  &lt;h:message for="confirmBankAccountId" style="color: red;" /&gt;
  &lt;h:commandButton action="done" value="Send" /&gt;
 &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>Now, in <code class="literal">PlayersBean</code>, we <a id="id605" class="indexterm"/>need to implement<a id="id606" class="indexterm"/> the <code class="literal">validateAccount</code> method<a id="id607" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">public void validateAccount(ComponentSystemEvent event) {

 UIComponent uis = event.getComponent();

 //obtain bank account
 String bankAccount = null;
 UIInput uiBankAccount = (UIInput) 
        uis.findComponent("bankAccountId");
 Object bankAccountObj = uiBankAccount.getLocalValue();
 if (bankAccountObj != null) {
     bankAccount = String.valueOf(bankAccountObj).trim();
 }

 //obtain bank account confirmation
 String bankAccountC = null;
 UIInput uiBankAccountC = (UIInput) 
         uis.findComponent("confirmBankAccountId");
 Object bankAccountCObj = uiBankAccountC.getLocalValue();
 if (bankAccountCObj != null) {
     bankAccountC = String.valueOf(bankAccountCObj).trim();
 }

 if ((bankAccount != null) &amp;&amp; (bankAccountC != null)) {
      if (!bankAccount.equals(bankAccountC)) {
          FacesContext facesContext =  
               FacesContext.getCurrentInstance();
          FacesMessage facesMessage = new FacesMessage("Bank 
               account must match bank account confirmation !");
                         
          facesMessage.setSeverity(FacesMessage.SEVERITY_ERROR);
                 
          facesContext.addMessage(uiBankAccount.getClientId(),  
               facesMessage);
          facesContext.renderResponse();
      }
 }
}</pre></div><p>Done! If you don't provide<a id="id608" class="indexterm"/> the same bank account, then <a id="id609" class="indexterm"/>you will see the corresponding message. The complete application is named <code class="literal">ch4_7</code>.</p></div><div class="section" title="Implementing SystemEventListener"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Implementing SystemEventListener</h2></div></div></div><p>Another approach of handling system<a id="id610" class="indexterm"/> events is<a id="id611" class="indexterm"/> based on the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implementing the <code class="literal">SystemEventListener</code> interface.</li><li class="listitem">Overriding the <code class="literal">processEvent</code> and <code class="literal">isListenerForSource</code> methods.</li><li class="listitem">Configuring the listener in <code class="literal">faces-config.xml</code>.</li></ol></div><p>The registered system event can be fired by many kinds of sources (components). We can sort and accept certain sources in the <code class="literal">isListenerForSource</code> method. It returns <code class="literal">true</code> when the listener should receive events from the source passed to it as an argument (usually a simple test using the <code class="literal">instanceof</code> operator should do the work). When a source is accepted, the <code class="literal">processEvent</code> method is called and we can add a custom behavior.</p><p>For example, let's suppose that we want to remove certain resources included by JSF, such as CSS style sheets or JS scripts (it could be even resources added by third-party libraries). Speaking about CSS resources, they are always rendered in the <code class="literal">HEAD</code> section of an HTML page. Knowing that, we can configure our listener to be executed if the event source is a <code class="literal">UIViewRoot</code> instance. Further, we exploit JSF API to loop through the CSS resources and remove some of them (or, all of them). The code of our listener is pretty simple, as you can see in the following code:</p><div class="informalexample"><pre class="programlisting">public class ResourcesListener implements SystemEventListener {

 @Override
 public void processEvent(SystemEvent event)
             throws AbortProcessingException {

  FacesContext context = FacesContext.getCurrentInstance();
      
  int i = context.getViewRoot().
          getComponentResources(context, "HEAD").size() - 1;

  while (i &gt;= 0) {
   UIComponent resource = context.getViewRoot().
               getComponentResources(context, "HEAD").get(i);

   String resourceLibrary = (String)
               resource.getAttributes().get("library");
   String resourceName = (String) resource.getAttributes().get("name");

   if ((resourceLibrary.equals("default")) &amp;&amp;
               (resourceName.equals("css/roger.css"))) {
    context.getViewRoot().removeComponentResource
                                  (context, resource, "HEAD");
   }
  i--;
  }
 }

 @Override
 public boolean isListenerForSource(Object source) {
  return (source instanceof UIViewRoot);
 }
}</pre></div><p>The listener <a id="id612" class="indexterm"/>should be <a id="id613" class="indexterm"/>configured in <code class="literal">faces-config.xml</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;system-event-listener&gt;
 &lt;system-event-listener-class&gt;
  book.beans.ResourcesListener
 &lt;/system-event-listener-class&gt;
 &lt;system-event-class&gt;
  javax.faces.event.PreRenderViewEvent
 &lt;/system-event-class&gt;
 &lt;source-class&gt;
  javax.faces.component.UIViewRoot
 &lt;/source-class&gt;
&lt;/system-event-listener&gt;</pre></div><p>So, even if initially we write the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:head&gt;
 &lt;h:outputStylesheet library="default" name="css/rafa.css"/&gt;
 &lt;h:outputStylesheet library="default" name="css/roger.css"/&gt;
&lt;/h:head&gt;</pre></div><p>JSF will render the following code:</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
 &lt;title&gt;&lt;/title&gt;
 &lt;link type="text/css" rel="stylesheet"
      href="/ch4_9_1/faces/javax.faces.resource/css/rafa.css?ln=default"&gt;
&lt;/head&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note88"/>Note</h3><p>The <code class="literal">&lt;source-class&gt;</code> tag is actually overriding the condition from the <code class="literal">isListenerForSource</code> method. So, you can always return <code class="literal">true</code> from the <code class="literal">isListenerForSource</code> method and use this tag, or vice versa.</p></div></div><p>You can find the complete example under the name <code class="literal">ch4_9_1</code>, in the code bundle of this chapter.</p><p>Now, let's see another example. A common<a id="id614" class="indexterm"/> approach, when some form input fields are invalid, is to color the<a id="id615" class="indexterm"/> background in red. In JSF 2.0, we can do that using the following code:</p><div class="informalexample"><pre class="programlisting">.ui-invalid {
    background-color:red
}
...
&lt;h:inputText value="#{...}" required="true" styleClass="#{not component.valid ? 'ui-invalid' : ''}" /&gt;</pre></div><p>Well, that is really cool! But, if the form has several input fields, then we have to repeat the condition again and again, which isn't cool anymore! But, with a little magic, we can generalize this behavior. We can write a listener that will be executed only from the <code class="literal">UIInput </code>objects and modify their <code class="literal">styleClass</code> attribute based on the result returned by the <code class="literal">isValid</code> method:</p><div class="informalexample"><pre class="programlisting">public class InputValidationListener implements SystemEventListener {

 @Override
 public void processEvent(SystemEvent event)
             throws AbortProcessingException {

  UIInput inputSource = (UIInput) event.getSource();

  if(!inputSource.isValid()) {
     inputSource.getAttributes().put("styleClass", "ui-invalid");
  }
 }

 @Override
 public boolean isListenerForSource(Object source) {
  return (source instanceof UIInput);
 }    
}</pre></div><p>Of course, this is simple and there is nothing to explain. Actually, the key lies in the configuration file, because<a id="id616" class="indexterm"/> we have to choose the right system event from the plethora of available events. Since we need to<a id="id617" class="indexterm"/> color the background of invalid input fields in red, the right choice should be <code class="literal">PostValidateEvent</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;system-event-listener&gt;
 &lt;system-event-listener-class&gt;
  book.beans.InputValidationListener
 &lt;/system-event-listener-class&gt;
 &lt;system-event-class&gt;
  javax.faces.event.PostValidateEvent
 &lt;/system-event-class&gt;
 &lt;source-class&gt;
  javax.faces.component.html.HtmlInputText
 &lt;/source-class&gt;
&lt;/system-event-listener&gt;</pre></div><p>Done! A functional example is available in the code bundle of this chapter and is named <code class="literal">ch4_9_3</code>. The JSF 2.2 programmatic reflection of this configuration is listed as follows:</p><div class="informalexample"><pre class="programlisting">public class Initializer extends 
       ApplicationConfigurationPopulator {

 @Override
 public void populateApplicationConfiguration
       (Document toPopulate) {

  String ns = toPopulate.getDocumentElement().getNamespaceURI();

  Element applicationEl = toPopulate.
          createElementNS(ns, "application");
  Element systemeventlistenerEl = toPopulate.
          createElementNS(ns, "system-event-listener");
  Element systemeventlistenerclassEl = 
          toPopulate.createElementNS(ns,
          "system-event-listener-class");
  systemeventlistenerclassEl.appendChild
          (toPopulate.createTextNode
          ("book.beans.InputValidationListener"));
  Element systemeventclassEl = toPopulate.
          createElementNS(ns, "system-event-class");
  systemeventclassEl.appendChild(toPopulate.
          createTextNode("javax.faces.event.PostValidateEvent"));
  Element sourceclassEl = toPopulate.
          createElementNS(ns, "source-class");
  sourceclassEl.appendChild(toPopulate.createTextNode
          ("javax.faces.component.html.HtmlInputText"));
         
  systemeventlistenerEl.appendChild(systemeventlistenerclassEl);
  systemeventlistenerEl.appendChild(systemeventclassEl);
  systemeventlistenerEl.appendChild(sourceclassEl);
  applicationEl.appendChild(systemeventlistenerEl);
  toPopulate.getDocumentElement().appendChild(applicationEl);

  //serializeFacesConfig(toPopulate, "D://faces-config.xml");
 }
 ...
}</pre></div><p>The complete application<a id="id618" class="indexterm"/> is named <code class="literal">ch4_14_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note89"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection in system event listeners(<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). For example, instead of hardcoding the CSS resources that we need to remove from <code class="literal">HEAD</code>, we can pass them through injection of a CDI bean or an EJB session bean. You can see a complete example in the code bundle of this chapter. This one is named <code class="literal">ch4_9_2</code>.</p></div></div><p>After you map the <a id="id619" class="indexterm"/>CSS classes names in a CDI bean (for example <code class="literal">StyleResourcesBean</code>) or EJB bean (for example <code class="literal">StyleResourcesEJBBean</code>), you can use any of the following injections:</p><div class="informalexample"><pre class="programlisting">@Inject
StyleResourcesBean styleResourcesBean;    
@Inject
StyleResourcesEJBBean styleResourcesEJBBean;
@EJB
StyleResourcesEJBBean styleResourcesEJBBean;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note90"/>Note</h3><p>Besides the injection facility, JSF 2.2 comes with a set of four brand new system events dedicated to Flash scope. These are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PostKeepFlashValueEvent</code>: This event is fired when a value is kept in the Flash</li><li class="listitem" style="list-style-type: disc"><code class="literal">PostPutFlashValueEvent</code>: This event is fired when a value is stored in the Flash</li><li class="listitem" style="list-style-type: disc"><code class="literal">PreClearFlashEvent</code>: This event is fired before the Flash is cleared</li><li class="listitem" style="list-style-type: disc"><code class="literal">PreRemoveFlashValueEvent</code>: This event is fired when a value is removed from the Flash</li></ul></div></div></div><p>Remember that in <a class="link" href="ch02.html" title="Chapter 2. Communication in JSF">Chapter 2</a>, <span class="emphasis"><em>Communication in JSF</em></span>, you saw an application based on the Flash scope. In this chapter, we will<a id="id620" class="indexterm"/> write a system <a id="id621" class="indexterm"/>event listener to monitor two of these events, <code class="literal">PostKeepFlashValueEvent</code> and <code class="literal">PreClearFlashEvent</code>. The code for this is as follows:</p><div class="informalexample"><pre class="programlisting">public class FlashListener implements SystemEventListener {

 private final static Logger LOGGER =
        Logger.getLogger(FlashListener.class.getName());

 @Override
 public void processEvent(SystemEvent event)
        throws AbortProcessingException {

 if (event.getSource() instanceof String) {
  LOGGER.log(Level.INFO, "The following parameter was added
                     in flash scope: {0}", event.getSource());
 } else if (event.getSource() instanceof Map) {
   LOGGER.info("Preparing to clear flash scope ...");
   LOGGER.info("Current content:");
   Iterator iterator = ((Map) event.getSource()).entrySet().iterator();
   while (iterator.hasNext()) {
         Map.Entry mapEntry = (Map.Entry) iterator.next();
         LOGGER.log(Level.INFO, "{0}={1}", new
                 Object[]{mapEntry.getKey(), mapEntry.getValue()});
   }
  }
 }

 @Override
 public boolean isListenerForSource(Object source) {
  return ((source instanceof String) || (source instanceof Map));
 }
}</pre></div><p>Do not forget to configure the listener in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;system-event-listener&gt;
 &lt;system-event-listener-class&gt;
  book.beans.FlashListener
 &lt;/system-event-listener-class&gt;
 &lt;system-event-class&gt;
  javax.faces.event.PostKeepFlashValueEvent
 &lt;/system-event-class&gt;
&lt;/system-event-listener&gt;
&lt;system-event-listener&gt;
 &lt;system-event-listener-class&gt;
  book.beans.FlashListener
 &lt;/system-event-listener-class&gt;
 &lt;system-event-class&gt;
  javax.faces.event.PreClearFlashEvent  
 &lt;/system-event-class&gt;
&lt;/system-event-listener&gt;</pre></div><p>A functional example is<a id="id622" class="indexterm"/> available in<a id="id623" class="indexterm"/> the code bundle of this chapter, and is named <code class="literal">ch4_9_4</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note91"/>Note</h3><p>Generally speaking, from JSF 2.2 onwards, the <code class="literal">PostRestoreStateEvent</code> system event is published using <code class="literal">Application.publishEvent</code> without making <code class="literal">UIComponents</code> default listeners, but still doing the traditional tree traversal. This event was an exception for the rule in the previous JSF versions!</p></div></div></div></div>
<div class="section" title="Configuring phase listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Configuring phase listeners</h1></div></div></div><p>As the name suggests, a <span class="strong"><strong>phase listener</strong></span> is<a id="id624" class="indexterm"/> capable to listen to the start and end of each of the six <a id="id625" class="indexterm"/>JSF life-cycle phases (a detailed diagram of how JSF phases interact with each other is available in <a class="link" href="apa.html" title="Appendix A. The JSF Life Cycle">Appendix</a>, <span class="emphasis"><em>The JSF Life Cycle</em></span>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Restore the View phase</li><li class="listitem" style="list-style-type: disc">Apply the Request Values phase</li><li class="listitem" style="list-style-type: disc">Process the Validations phase</li><li class="listitem" style="list-style-type: disc">Update the Model Values phase</li><li class="listitem" style="list-style-type: disc">Invoke the Application phase</li><li class="listitem" style="list-style-type: disc">Render the Response phase</li></ul></div><p>You can <a id="id626" class="indexterm"/>easily capture the events of each phase by following<a id="id627" class="indexterm"/> these three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implementing the <code class="literal">PhaseListener</code> interface.</li><li class="listitem">Overriding the <code class="literal">afterPhase</code>, <code class="literal">beforePhase</code>, and <code class="literal">getPhaseId</code> methods.</li><li class="listitem">Configuring the phase listener in <code class="literal">faces-config.xml</code>.</li></ol></div><p>A good point to start is a simple but useful <code class="literal">PhaseListener</code> that<a id="id628" class="indexterm"/> can be used to debug the phases. If you ever had the curiosity to see what is happening in JSF request lifecycle, then you can use<a id="id629" class="indexterm"/> this phase listener, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">public class DebugPhaseListener implements PhaseListener {

    public DebugPhaseListener() {
    }

    @Override
    public void afterPhase(PhaseEvent event) {
        System.out.println("After Phase: " + event.getPhaseId());
    }

    @Override
    public void beforePhase(PhaseEvent event) {
        System.out.println("Before Phase:" + event.getPhaseId());
    }

    @Override
    public PhaseId getPhaseId() {
        return PhaseId.ANY_PHASE;
    }
}</pre></div><p>Finally, configure the custom phase listener in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;lifecycle&gt;
 &lt;phase-listener&gt;book.beans.DebugPhaseListener&lt;/phase-listener&gt;
&lt;/lifecycle&gt;</pre></div><p>Now, you can play different scenarios with different pages and components to see the output. A simple scenario consists in an implicit navigation case, as you can see in application <code class="literal">ch4_8_3</code>, available in the code bundle of this chapter.</p><p>The programmatic reflection of this configuration in JSF 2.2 is as follows:</p><div class="informalexample"><pre class="programlisting">public class Initializer extends 
       ApplicationConfigurationPopulator {

 @Override
 public void populateApplicationConfiguration
       (Document toPopulate) {

 String ns = toPopulate.getDocumentElement().getNamespaceURI();

 Element lifecycleEl = toPopulate.createElementNS(ns, "lifecycle");
 Element phaselistenerEl = toPopulate.
         createElementNS(ns, "phase-listener");
 phaselistenerEl.appendChild(toPopulate.
         createTextNode("book.beans.DebugPhaseListener"));
 lifecycleEl.appendChild(phaselistenerEl);
 toPopulate.getDocumentElement().appendChild(lifecycleEl);

 serializeFacesConfig(toPopulate, "D://faces-config.xml");
 }
 ...
}</pre></div><p>The complete application is named <code class="literal">ch4_14_3</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note92"/>Note</h3><p>The <code class="literal">getPhaseId</code> method<a id="id630" class="indexterm"/> is used to determine the phases that pass through the listener. For capturing all the phase events, the method needs to return <code class="literal">PhaseId.ANY_PHASE</code>.</p></div></div><p>Phase listeners<a id="id631" class="indexterm"/> can also be used to alter components. For example, you can color the background of <code class="literal">UIInput</code>, based on the submitted value, by intercepting the <span class="emphasis"><em>Render Response</em></span> phase as follows:</p><div class="informalexample"><pre class="programlisting">public class PlayerPhaseListener implements PhaseListener {

 @Override
 public void afterPhase(PhaseEvent event) {
 }

 @Override
 public void beforePhase(PhaseEvent event) {
  processComponents(event.getFacesContext().getViewRoot());
 }

 @Override
 public PhaseId getPhaseId() {
  return PhaseId.RENDER_RESPONSE;
 }

 private void processComponents(UIComponent root) {
  for (UIComponent child : root.getChildren()) {
      if (child.getId().equals("playerId")) {
         HtmlInputText inputText = (HtmlInputText) child;
         String value = (String) inputText.getValue();

         if (value != null) {
            if (value.equalsIgnoreCase("rafa")) {
                inputText.setStyleClass("rafa-style");
            } else if (value.equalsIgnoreCase("roger")) {
                       inputText.setStyleClass("roger-style");
            }
         }
      }
  processComponents(child);
  }
 }
}</pre></div><p>The complete example is <a id="id632" class="indexterm"/>available in the code bundle of this chapter, and is named <code class="literal">ch4_8_1</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note93"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection in phase listeners (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). For example, instead of hardcoding the CSS classes or the text against which we choose the CSS class, we can pass them through the injection of a CDI bean or an EJB session bean. You can see a complete example in the code bundle of this chapter under the name <code class="literal">ch4_8_2</code>.</p></div></div><p>After you map the CSS class' names in a CDI bean (for example, <code class="literal">StyleResourcesBean</code>) or an EJB bean (for example, <code class="literal">StyleResourcesEJBBean</code>), you can use any of the following injections in the phase listener as follows:</p><div class="informalexample"><pre class="programlisting">@Inject
StyleResourcesBean styleResourcesBean;    
@Inject
StyleResourcesEJBBean styleResourcesEJBBean;
@EJB
StyleResourcesEJBBean styleResourcesEJBBean;</pre></div><p>A phase listener can alter many kinds of JSF artifacts, not just UI components. For example, the following phase listener collects all <code class="literal">FacesMessages</code> and modifies the global ones. Obviously, you can choose to do anything else such as filter them by ID or save them in a special place.</p><div class="informalexample"><pre class="programlisting">public class MsgPhaseListener implements PhaseListener {
    
 private static final Logger logger = 
  Logger.getLogger(MsgPhaseListener.class.getName());    
    
 @Override
 public void afterPhase(PhaseEvent event) {}

 @Override
 public void beforePhase(PhaseEvent event) {
  FacesContext facesContext = event.getFacesContext();
  Iterator&lt;String&gt; ids = facesContext.getClientIdsWithMessages();

  while (ids.hasNext()) {
    String id = ids.next();
    Iterator&lt;FacesMessage&gt; messages = facesContext.getMessages(id);
    while (messages.hasNext()) {
           FacesMessage message = messages.next();
           logger.log(Level.INFO, "User ID:{0} Message: {1}"
                    , new Object[]{id, message.getSummary()});
           if(id == null){
              message.setSummary(message.getSummary() + 
                            "alerted by a phase listener!");
           }
    }
  }
 }

 @Override
 public PhaseId getPhaseId() {
  return PhaseId.RENDER_RESPONSE;
 }     
}</pre></div><p>The complete <a id="id633" class="indexterm"/>application is named <code class="literal">ch4_15</code>.</p></div>
<div class="section" title="Working with @ListenerFor and @ListenersFor"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Working with @ListenerFor and @ListenersFor</h1></div></div></div><p>The <code class="literal">@ListenerFor</code> annotation<a id="id634" class="indexterm"/> is an interesting annotation available from JSF 2.0. This annotation allows a component to subscribe to particular events with the component itself being the listener. For this, we need to follow the ensuing steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement the <code class="literal">ComponentSystemEventListener</code> interface (the name indicates that the event will always be associated with a <code class="literal">UIComponent</code> instance).</li><li class="listitem">Override the <code class="literal">processEvent</code> method (here we can <span class="emphasis"><em>play</em></span> with the component).</li><li class="listitem">Use the <code class="literal">@ListenerFor</code> to indicate the event that the UI component will subscribe for, and the source class of the UI component.</li></ol></div><p>For example, the <code class="literal">UIInput</code> component can subscribe to the <code class="literal">PostAddToViewEvent</code> event for adding<a id="id635" class="indexterm"/> attributes to the component, for example, following <a id="id636" class="indexterm"/>is a case, where we add some CSS to each <code class="literal">UIInput </code>component:</p><div class="informalexample"><pre class="programlisting">@ListenerFor(systemEventClass = PostAddToViewEvent.class, sourceClass = javax.faces.component.UIInput.class)
public class PlayerRenderer extends TextRenderer
             implements ComponentSystemEventListener {

 @Override
 public void processEvent(ComponentSystemEvent event)
              throws AbortProcessingException {

  UIInput inputSource = (UIInput) event.getComponent();
  inputSource.getAttributes().put("styleClass", "rafa-style");
 }
}</pre></div><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch4_10_1</code>.</p><p>The <code class="literal">@ListenersFor</code> annotation<a id="id637" class="indexterm"/> allows a component to subscribe to more than one event. In the previous example, we have added some CSS to each <code class="literal">UIInput</code> component. Next, we want to extend this functionality by adding a separate CSS to the invalid <code class="literal">UIInput</code> components. For this, the <code class="literal">UIInput</code> components must subscribe to <code class="literal">PostValidateEvent</code>. This approach will help us to distinguish between the valid <code class="literal">UIInput</code> instances and invalid <code class="literal">UIInput</code> instances. The code for the same is as follows:</p><div class="informalexample"><pre class="programlisting">@ListenersFor({
  @ListenerFor(systemEventClass=PostAddToViewEvent.class,
              sourceClass = javax.faces.component.UIInput.class),
 @ListenerFor(systemEventClass=PostValidateEvent.class,
              sourceClass = javax.faces.component.UIInput.class)
})
public class PlayerRenderer extends TextRenderer
       implements ComponentSystemEventListener {

@Override
 public void processEvent(ComponentSystemEvent event)
                          throws AbortProcessingException {

  UIInput inputSource = (UIInput) event.getComponent();
  inputSource.getAttributes().put("styleClass", "rafa-style");
        
  if(!inputSource.isValid()){
     inputSource.getAttributes().put("styleClass", "ui-invalid");
    }
  }
}</pre></div><p>The complete<a id="id638" class="indexterm"/> application is available in the code bundle of this chapter and is named <code class="literal">ch4_10_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note94"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with <code class="literal">@ListenerFor</code>/<code class="literal">@ListenersFor</code> (<code class="literal">@Inject </code>and <code class="literal">@EJB</code>). For example, instead of hardcoding the CSS classes from the previous examples, we can pass them through injection of a CDI bean or an EJB session bean. You can see a complete example in the code bundle of this chapter, under the name <code class="literal">ch4_10_3</code>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Summary</h1></div></div></div><p>Well, this was a pretty heavy chapter, but many of the important aspects in JSF were touched upon here. You learned how to create, extend, and configure several of the main JSF 2.x artifacts and how they have been improvised upon by JSF 2.2, especially with the dependency injection mechanism.</p><p>There are still a lot of things that were not discussed here; however, in the next chapter, we will continue this journey and cover other things, such as renders, handlers, and factories.</p></div></body></html>