- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Federated and Scalable DaaS with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to publish ingested data in a format
    that is platform- and language-agnostic using the REST API. We also learned how
    to design and develop a **Data as a Service** (**DaaS**) layer using the REST
    API, as well as how to containerize and deploy the application on AWS ECS. Then,
    we learned what an API management system is and how it can help monitor and manage
    APIs more efficiently. Finally, we learned how to create an API management layer
    on top of our REST DaaS application using Amazon API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement DaaS using GraphQL instead of
    REST. To do so, we will learn what GraphQL is, and why and when it should be used.
    We will explore the benefits and shortcomings that GraphQL has concerning REST
    while discussing the various architectural patterns available for GraphQL-based
    solutions. Finally, we will learn about the power of federation in the GraphQL
    layer. By the end of this chapter, you should know about the basic concepts surrounding
    GraphQL and when to use this tool in data engineering solutions. You will also
    know how to design, implement, and test a GraphQL solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GraphQL – what, when, and why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core architectural patterns of GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical use case – exposing federated data models using GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prior knowledge of Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK-1.11 installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL Playground installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ Idea community or ultimate edition installed on your local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be downloaded from this book’s GitHub repository:
    [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GraphQL – what, when, and why
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore what GraphQL is. According to [graphql.org](http://graphql.org),
    the official definition of GraphQL is that “*GraphQL is a query language for APIs
    and a runtime for fulfilling those queries with your existing data.*” Let’s dive
    a bit deeper to understand GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) has been the standard way of
    publishing data across systems, which is platform, device, and tool/language-agnostic.
    However, there are two major bottlenecks with REST:'
  prefs: []
  type: TYPE_NORMAL
- en: For fetching different related entities, we need multiple REST requests. We
    must also be mindful of different versions of the API. Having different endpoints
    and their versions for each entity of functionality is a maintenance headache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request and response parameters are always fixed in REST. For example, there
    is a REST API that returns 100 fields. Suppose there is a consumer who only needs
    10 fields. However, since responses are fixed, a REST request will always calculate
    and send all 100 fields. This, in turn, affects performance as it takes more time
    to form the response, as well as consumes more bandwidth to transfer a bigger
    payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GraphQL is the answer to overcome these challenges. GraphQL is an open standard
    or specification created by Facebook. It is a query language for APIs, where the
    client can query multiple entities and the desired fields from those entities
    while making the GraphQL request. The following diagram describes how GraphQL
    operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – How GraphQL operates ](img/B17084_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – How GraphQL operates
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, in GraphQL, it is the GraphQL client that
    defines what data it needs, while the GraphQL server publishes what data is available.
    So, essentially, GraphQL is a declarative way of fetching and updating data over
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to understand this with an example. Since GraphQL was created by
    Facebook, we will take an example from a social networking use case. Let’s suppose
    that we want to fetch users, their posts, and the comments related to that post.
    The following diagram shows how this can be designed using REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A REST-based design requires three separate endpoints ](img/B17084_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A REST-based design requires three separate endpoints
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, REST will have three endpoints – one for users, one for posts,
    and one for comments. To fetch a user’s posts and comments on those posts, REST
    will require one call for users, one call for the posts, and one call per post
    for the comments. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Three separate calls are needed when using REST ](img/B17084_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Three separate calls are needed when using REST
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are at least three REST calls (provided that the user
    has only one post) required for this use case to fetch data. Think of the number
    of calls required for a real user on a social platform. If the user has posted
    *n* number of posts, then the number of calls required to fetch this information
    will be *n+2*. That would seriously affect the UI experience and the performance
    of the website. However, in GraphQL, it only takes one call to fetch this information.
    The following diagram shows what a GraphQL request would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A single GraphQL call can fetch all the required data ](img/B17084_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – A single GraphQL call can fetch all the required data
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the request payload of GraphQL declares the entities and fields
    that it needs to fetch. Therefore, the GraphQL client determines what data it
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Operation types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand what GraphQL is, let’s try to understand the various
    types of operations that GraphQL supports, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queries**: These help query the API and only support data read operations.
    A sample query is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the preceding payload, you can optionally use a keyword query followed
    by the name that you want to assign to the query (here, it is `myquery`). `byApplicationId`
    is a query in GraphQL (like an endpoint in REST) that takes request arguments
    as parameters. Here, the `byApplicationId` query takes an argument called `applicationId`.
    Also, as you can see, the request contains the names of the fields that it wants
    to have returned, such as `applicationId`, `id`, and `riskscore`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutations**: Mutations support both read and write operations. A sample query
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the preceding code, a mutation can be labeled with a mutation name
    using the `mutation` keyword. Here, it updates the application status in the database.
    So, it is used to write data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscriptions**: In addition to queries and mutations, GraphQL also supports
    subscriptions. Like queries, they are used to fetch data, but they use long-lasting
    connections, which can change their result over time. This enables an event notification
    pattern, by which the server can push changes to the client. The following code
    shows what a subscription query looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are subscribing to the comments written for the post with a `postId`.
    Hence, a long-lasting connection is established between the client and the GraphQL
    server. The GraphQL server pushes any changes that are made on the comments to
    the client automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s discuss the GraphQL schema. A GraphQL schema is a contract between
    the client and the server. It declares what operations and fields are available
    in GraphQL. It is strongly typed and is written using a standard **Schema Definition
    Language** (**SDL**). The following code block shows an example of a GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, the `applicationId` field is of the `ID` data type,
    `genderCode` is of the `String` data type. and so on. In SDL, data types of GraphQL
    schemas are also known as scalars; the inbuilt data types are denoted as inbuilt
    scalars and customized data types are referred to as custom scalars. The exclamation
    mark after `ID` while defining `applicationId` denotes that it is a mandatory
    field. Similarly, `cars` is defined as a list since its data type is wrapped with
    `[]` (square brackets).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have internalized the basic concepts of GraphQL, we will explore
    why and when to use GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Why use GraphQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will explore the various benefits of GraphQL that make
    it a great solution. The advantages of GraphQL are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strongly typed schema for a platform-independent API**: Usually, in the SOAP
    and REST APIs, our response is a platform-independent structure such as XML or
    JSON. However, neither of these formats is strongly typed. In GraphQL, each field
    in a schema must have a scalar type (it can either be an inbuilt scalar type or
    a customized one). This ensures GraphQL is less error-prone, more validated, and
    provides easy auto-completion capabilities for editors such as GraphQL Playground.
    The following screenshot shows the auto-completion suggestion provided by GraphQL
    Playground:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Auto-completion feature in GraphQL Playground ](img/B17084_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Auto-completion feature in GraphQL Playground
  prefs: []
  type: TYPE_NORMAL
- en: '**No over-fetching or under-fetching**: In GraphQL, the client can only fetch
    the data that it requires. For example, if a GraphQL API supports hundreds of
    fields in its API response, the client doesn’t need to fetch all those fields.
    If a client only needs 10 fields, the client can request the GraphQL API to send
    only those fields. However, if the same API is written in REST, even though the
    client requires only 10 fields, the response will return all the fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over-fetching is a common problem in REST, where, irrespective of the number
    of fields a client requires, it always fetches all the fields defined in the response
    body. For example, for a social networking site such as LinkedIn, a person’s profile
    contains a huge number of columns, including demographic columns, skill set columns,
    awards and certification columns, and so on. A REST-based solution to solve this
    problem can be designed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a single API with all columns**: If we use this approach, a client
    requiring only demographic information will encounter an over-fetching problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create separate APIs for demographics, skill sets, awards and certifications,
    and so on**: Let’s look at a scenario where the client needs all the information
    available. Multiple calls are required to fetch the data if we use this approach.
    This leads to under-fetching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we need a single solution that can solve these issues for both types of
    client requests. GraphQL solves this problem by allowing the client to choose
    which fields it wants to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saves time and bandwidth**: GraphQL allows you to make multiple resource
    requests in a single GraphQL call, which saves a lot of time and bandwidth by
    reducing the number of network round trips to the GraphQL server. This is especially
    useful for improving the user experience and speed of fetching data on a client
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No need for versioning**: In REST, when adding a new field or deleting an
    old field, this needs to be published as a new version to support consumer compatibility.
    With GraphQL, versioning is no longer required – one, because GraphQL supports
    partial data fetching from the response structure, and two, it supports publishing
    depreciation warnings to a depreciated field for the GraphQL client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema stitching or combining multiple GraphQL schema**: GraphQL provides
    multiple ways to combine different GraphQL schemas and APIs into a single endpoint
    without much coding or implementation hassle. This feature helps develop a single,
    centralized GraphQL gateway. A GraphQL gateway enables multiple GraphQL APIs to
    be consumed from a single endpoint. It also enables the dynamic addition of newer
    GraphQL APIs in the future seamlessly. This makes GraphQL federated and scalable.
    Combining schemas can be achieved by technologies such as Apollo GraphQL Federation
    and Atlassian GraphQL Braids.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see when we should use GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: When to use GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are a few scenarios where the GraphQL API is a better solution
    than the REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: Apps where bandwidth usage matters, such as mobile apps or IoT device apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications where there is a need for nested data to be fetched. GraphQL saves
    a lot of time and bandwidth, thus enabling better performance for GraphQL clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that publish DaaS. Here, this DaaS is consumed by multiple downstream
    teams with different data fetch requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When enabling GraphQL capabilities such as partial data fetching of the response
    and exposing a single endpoint by composing multiple APIs to improve the consumer
    experience for legacy REST-based applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned what GraphQL is and looked at typical use cases
    when GraphQL is used. In the next section, we will discuss the most popular GraphQL
    patterns that are used in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Core architectural patterns of GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the various architectural patterns that are
    used for GraphQL. These patterns are independent of the technology used to implement
    it or the platform where it is deployed and executed. There are five different
    GraphQL patterns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DaaS pattern**: Here, GraphQL server is used to expose the database layer.
    It can expose three operations – queries, mutations, and subscriptions (please
    refer to the *Operation types* section of this chapter). Using these operations,
    it can achieve **Create, Read, Update and Delete** (**CRUD**) operations like
    REST but also supports subscriptions on top of it. The following diagram shows
    this pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – DaaS pattern ](img/B17084_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – DaaS pattern
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, GraphQL exposes its queries and operations using the HTTP protocol.
    GraphQL provides server libraries in multiple languages, using which teams can
    build and run GraphQL Server applications. Also, GraphQL supports a variety of
    GraphQL client libraries in different languages. A list of supported languages
    is available at [https://graphql.org/code/](https://graphql.org/code/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration layer pattern**: Here, GraphQL Server caters to data to provide
    access to multiple data sources in one go. This enables GraphQL to act like a
    data integration hub. The following diagram depicts how the integration layer
    pattern works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Integration layer pattern ](img/B17084_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Integration layer pattern
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, GraphQL server is acting as an integration hub. It enables clients
    to make a single call, but the GraphQL server is fetching that data from different
    ecosystems such as microservices, legacy apps, and cloud APIs and sending a unified
    response to the client. This automatically reduces the complexity and number of
    calls that a GraphQL client must make.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hybrid pattern**: The third GraphQL pattern is called the hybrid pattern
    because it explores a hybrid approach to the first two patterns. Here, GraphQL
    Server not only needs to be connected to microservices legacy systems, but also
    databases. The following diagram shows this pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Hybrid pattern ](img/B17084_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Hybrid pattern
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, GraphQL Server has its own database apart from the connections
    to different apps such as microservices and legacy systems. Therefore, GraphQL
    provides unified access to its client for different kinds of data sources when
    this pattern is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphQL with managed API**: To expose GraphQL APIs in an enterprise, it is
    necessary to have security and monitoring enabled. In this pattern, API Gateway
    provides monitoring, security, and throttling on GraphQL Server. The following
    diagram shows this pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – GraphQL with managed API ](img/B17084_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – GraphQL with managed API
  prefs: []
  type: TYPE_NORMAL
- en: '**Federated GraphQL pattern**: Here, a centralized GraphQL braid or federated
    GraphQL server is created. Other GraphQL nodes are connected to this GraphQL braid.
    Each of these nodes, in turn, fetches data from either a database, micro-service,
    or legacy app. The following diagram shows the federated GraphQL pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Federated GraphQL pattern ](img/B17084_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Federated GraphQL pattern
  prefs: []
  type: TYPE_NORMAL
- en: The real power of this pattern is its amazing scalability and data federation.
    Newer nodes can be seamlessly added at any time to the GraphQL braid, without
    any application downtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the various core GraphQL patterns, how they
    operate, and when they are useful. In the next section, we will learn how to develop
    a GraphQL server application.
  prefs: []
  type: TYPE_NORMAL
- en: A practical use case – exposing federated data models using GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to develop DaaS using GraphQL in Java. To
    implement the solution, we will publish the same set of APIs that we published
    earlier using REST, but this time, we will implement the solution using GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing GraphQL, it is important to design the GraphQL
    schema for our use case. In our use case, we need to read credit card applications
    from MongoDB using either the application ID or consumer ID. This was why we needed
    two separate endpoints in the REST-based solution (please refer to [*Chapter 9*](B17084_09.xhtml#_idTextAnchor144),
    *Exposing MongoDB Data as a Service*, for the REST-based DaaS solution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the requirements from a different perspective – that is, while
    considering the GraphQL-based solution. The biggest difference that GraphQL makes
    is that it reduces the number of endpoints, as well as the number of calls. So,
    for our use case, we will have a single endpoint. Also, according to our use case,
    we are only interested in fetching data. Hence, we will only be using the `Query`
    type of operation. To support multiple functionalities in GraphQL, we must have
    multiple such fields in the query that can take arguments such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we need two such fields – `byApplicationId` and `byCustomerId`
    – both of which should return a custom type called `Application`. The following
    code snippet shows part of our GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code block, `byApplicationId` always returns only
    one `Application`, as `applicationId` is a primary key. Therefore, `byApplicationId`
    is of the `Application` type. However, since there can be multiple applications
    for the same customer, `byCustomerId` is of the `[Application]` type, which denotes
    a list of `Application`. Now, let’s define the type – `Application` – in the GraphQL
    schema. The following code block shows the SDL for the `Application` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the SDL for the `Application` type, `applicationId` is of the `ID`
    type, which denotes that it is the unique key for the `Application` type. Also,
    the exclamation mark (`!`) seen in the `applicationId` and `id` fields denotes
    that those fields are non-nullable. The complete schema is available at [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Spring Boot Maven project and add the required Maven dependencies,
    the following Maven dependencies should be added in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from this, the following dependencies should be added to support MongoDB-related
    dependencies, as well as QueryDSL-related dependencies, in the Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from these dependencies, we need to add build-plugins in the `pom.xml`
    file. These plugins help generate Q classes dynamically, which are required for
    QueryDSL to work properly. The following plugins need to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'GraphQL-related dependencies also need to be added to the POM file of the project.
    The following GraphQL dependencies need to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code block, to implement GraphQL server in Java, we
    need to import the `graphql-java` dependencies and the Spring Boot starter for
    GraphQL JAR file called `graphql-java-spring-boot-starter-webmvc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added all the necessary dependencies, we will create the entry
    point, or the `Main` class, of our Spring Boot application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create the `MongoConfig` class, which creates two Mongo Spring
    beans of the `MongoClient` and `MongoTemplate` type, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a POJO class called `Application`, which represents the
    data model. It should be annotated by `org.springframework.data.mongodb.core.mapping.Document
    annotation` and `com.querydsl.core.annotations.QueryEntity annotation`. The following
    code denotes the `Application` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `@Document` denotes that the POJO is a bean that is mapped to a document
    in MongoDB, while `@QueryEntity` is required to enable QueryDSL’s querying capabilities
    over the `Application` bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just like the REST-based solution discussed in [*Chapter 9*](B17084_09.xhtml#_idTextAnchor144),
    *Exposing MongoDB Data as a Service*, we must create an `ApplicationRepository`
    interface that extends the `MongoRepository` and `QuerydslPredicateExecutor` interfaces.
    Using this class, we will define two methods to fetch application data from MongoDB
    using QueryDSL. The following code snippet is for the `ApplicationRepository`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will skip explaining this repository interface as it is identical to the
    interface we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have finished developing the DAO layer, let’s create a package
    called `helper`. In a GraphQL Java application, we need two kinds of classes –
    one should be the GraphQL provider and the other should be the GraphQL data fetcher.
    Here, we will start by writing the provider class under the `helper` package.
    In the `GraphQLProvider` class, first, we will define a property of the `graphql.GraphQL`
    type and initialize it as soon as the `GraphQLProvider` bean is initialized by
    Spring Boot. The code snippet for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A GraphQL server should have a strongly typed well-defined schema (please refer
    to the earlier discussion about the GraphQL schema). Here, in the `init` method,
    we load the GraphQL schema from the resources. The GraphQL schema definition is
    read and stored in the string `object named sdl` using the utility methods of
    `com.google.common.io.Resources`. Then, the `GraphQLSchema` object is derived
    from the `sdl` object, which is built using the `buildSchema` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `buildSchema` method, the `sdl` object is parsed using `SchemaParser`
    and converted into the `TypeDefinitionRegistry` object. Runtime wiring is the
    process of attaching data fetchers, type resolvers, and custom scalars. First,
    we build the wiring required to complete the GraphQL schema using the `buildWiring`
    method. Then, using `SchemaGenerator.makeExecutableSchema`, we create a `GraphQLSchema`
    object with the required `runtimeWiring`.
  prefs: []
  type: TYPE_NORMAL
- en: Necessary reference
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, to completely create an executable GraphQL schema, three kinds of
    bindings might be required. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Data fetchers**, which are interfaces that help fetch data for a GraphQL
    schema.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Type resolvers, which are custom methods that resolve the value of a GraphQL
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Custom scalars, which refer to any customized data types. Data types in GraphQL
    are known as **scalars**.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the implementation of the `buildWiring` method. This method
    creates a new `Runtimewiring` by attaching GraphQL data fetchers to the two different
    fields (`byApplicationId` and `byCustomerId`) in the GraphQL schema (the GraphQL
    schema for this use case was discussed earlier in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, using this `GraphQLSchema`, we build and instantiate the GraphQL property.
    Now, we can expose a bean called `GraphQL` by returning this GraphQL object, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While implementing the `buildWiring` method, two methods from the `GraphQLDataFetcher`
    class called `getApplicationbyApplicationIdDataFetcher` and `getApplicationsbyCustomerIdDataFetcher`
    are called. So, let’s discuss how the `GraphQLDatafetcher` class is implemented.
    All the data fetcher methods must return an object of the `graphql.schema.DataFetcher`
    type. The definition of the `DataFetcher` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code block, the `DataFetcher` interface has only
    one method, which takes an argument of the `graphql.schema.DataFetchingEnvironment`
    type. So, we can implement this interface as a Lambda function in Java. In our
    case, we call the `applicationRepository` class to fetch the data required for
    populating the `Application` object(s) we are publishing. The following code shows
    the implementation of `getApplicationbyApplicationIdDataFetcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While implementing the `getApplicationbyApplicationIdDataFetcher` method, we
    are returning the Lambda function, which takes the `dataFetchingEnvironment` argument.
    All the arguments of the field that a data fetcher is written for can be accessed
    by the `getArgument` method of the `DataFetchingEnvironment` class. In this scenario,
    it is fetching the `applicationId` argument. Finally, as evident from the code
    snippet, we use `applicationRepository` to fetch data from MongoDB. Similar logic
    is used for writing the `getApplicationsbyCustomerIdDataFetcher` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to keep the `schema.graphqls` file, which contains the GraphQL
    schema, in the `resource` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to define the `application.yaml` file to run the Spring Boot
    application. The `application.yaml` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have developed the GraphQL Server application, let’s explore how
    can we test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the application by running the `Main` class, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Running the GraphQL server application ](img/B17084_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Running the GraphQL server application
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to test the application, open GraphQL Playground and enter the DaaS endpoint.
    The DaaS endpoint should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you hit this URL on GraphQL Playground and enter a proper `graphql` request
    payload, you will get the result in GraphQL Playground, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground ](img/B17084_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, while calling the GraphQL Service application, the client sends
    the list of fields it wants to fetch. As shown in the request payload, although
    the GraphQL Server application supports many more fields, in this example, the
    client has only requested four fields – that is, `applicationId`, `genderCode`,
    `id`, and `riskScore`. Hence, GraphQL resolves and sends only those four fields
    back to the consumer. This feature of GraphQL helps overcome the problem of over-fetching
    or under-fetching (typically seen in REST-based DaaS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, GraphQL supports multiple functionalities in a single call. In our use
    case, we have two functions – fetch application by `applicationId` and fetch all
    the applications for a customer using `customerid`. Both can be achieved in a
    single call using GraphQL. The following screenshot shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Supporting multiple business operations in a single GraphQL
    call ](img/B17084_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Supporting multiple business operations in a single GraphQL call
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both fields – `byApplicationId` and `byCustomerId` – can be requested
    in a single GraphQL call that fetches data for both fields in a single GraphQL
    response. This reduces the number of hits to the GraphQL service and clients can
    improve their application performance by making fewer calls to the GraphQL Server
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these two advantages, GraphQL also enables easy schema and document
    sharing. As shown in the preceding screenshot, there are two sidewise tabs called
    **DOCS** and **SCHEMA** to the extreme right. **SCHEMA** can show us the supported
    GraphQL schema from the server. It tells us what data points are available as
    a part of this GraphQL API. The following screenshot shows how a client can see
    the schema of a GraphQL service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Checking the GraphQL schema from GraphQL Playground ](img/B17084_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Checking the GraphQL schema from GraphQL Playground
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this, documentation is another cool feature that GraphQL provides.
    In the world of REST, sharing the API with the client is not sufficient. Therefore,
    we need to build and maintain the documentation separately (either using Swagger
    or otherwise) and share it. However, GraphQL allows you to easily maintain and
    publish documents, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Easily sharing GraphQL documentation ](img/B17084_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Easily sharing GraphQL documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s more interesting about GraphQL documentation is that it is very easy
    to configure and maintain. All we need to do is add a documentation comment above
    each field and query it to support the documentation. For example, the documentation
    of the `applicationId` field can easily be incorporated into the GraphQL Schema
    SDL, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all the documentation is written inside a documentation comment,
    which starts with three double quotes (`""`) and ends with three double quotes
    (`""`). GraphQL automatically uses the schema SDL to publish the documentation,
    hence making maintenance and publishing documentation super simple and easy.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to develop a GraphQL server application using
    Java. We also learned about GraphQL DSL for developing GraphQL schemas. Finally,
    we learned how to effectively test and verify the GraphQL DaaS API using GraphQL
    Playground. Now, let’s summarize what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basic concepts of GraphQL. First, we learned
    how GraphQL can overcome the pitfalls of REST-based DaaS and the benefits it provides.
    Then, we discussed when to choose GraphQL as a preferred solution. Finally, we
    learned how to develop a GraphQL server application using Java and how to test
    that application using GraphQL Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to design and develop data engineering solutions
    for both data ingestion scenarios and data publication scenarios, in the next
    chapter, we will discuss performance engineering and learn how to use a data-driven
    approach to make architectural decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Section 4 – Choosing Suitable Data Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final section of the book, you will learn how to measure a solution and
    determine the efficiency of a solution. You will also learn how to communicate
    and present their solution to leadership/clients who may not be very technical.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B17084_11.xhtml#_idTextAnchor168)*, Measuring Performance and
    Benchmarking Your Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B17084_12.xhtml#_idTextAnchor180)*, Evaluating, Recommending,
    and Presenting Your Solutions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
