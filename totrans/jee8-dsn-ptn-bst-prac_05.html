<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Aspect-Oriented Programming and Design Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this c<span class="calibre10">hapter, </span>we will look at the concept of <strong class="calibre8">aspect-oriented programming</strong> (<strong class="calibre8">AOP</strong>), focusing on which situations AOP should be used in, as well as how to achieve AOP with the use of CDI interceptors and decorators. Finally, we will also look at some examples of its implementation. By the end of this chapter, you will be able to identify a situation that requires AOP with the use of interceptors and decorators. Furthermore, you will also be able to identify the best approach to implementing these concepts. The topics covered in this chapter are as follows:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Aspect-oriented programming</span></li>
<li class="calibre16"><span class="calibre5">AOP in a JEE scenario – the interceptor</span></li>
<li class="calibre16"><span class="calibre5">EJB interceptor implementation</span></li>
<li class="calibre16"><span class="calibre5">CDI interceptor implementation</span></li>
<li class="calibre16"><span class="calibre5">The decorator pattern</span></li>
<li class="calibre16"><span class="calibre5">The decorator pattern in a JEE scenario</span></li>
<li class="calibre16"><span class="calibre5">Decorator implementation</span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Aspect-oriented programming</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">AOP is a programming paradigm that allows us to separate business logic from some technical code that crosscuts all applications. In other words, AOP allows the separation of crosscutting concerns. We will encounter crosscutting code when we input the logging code in certain methods to show technical support information. We also encounter it when we input statistic code to see how many times a method calls or who the user using the application is, or even for exception and error handling. We see this kind of code in almost all <span class="calibre10">parts of an </span><span class="calibre10">application—it is code that is repeated along the whole application. This kind of code has its own objectives and concerns, and it is a very good idea to separate it from the business code, which is related to the application use cases.</span></p>
<p class="mce-root">These aspects of the system (such as logging or exception handling) are very difficult to implement in a modular way. What we are saying here is that we don't want to mix these aspects with business code. By mixing these two types of code, we are left with a final code that is more difficult to maintain.</p>
<p class="mce-root">With AOP, we can join or add an executable code to our source code without changing it, meaning that the source code remains intact. As we said, if we want to log a method, for instance, then we can do that without disrupting our business code with a service code, such as the logging service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Compile-time versus run-time AOP</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">AOP is achieved through code injection during compile-time or runtime.</p>
<p class="mce-root">Frameworks that implement AOP at compile-time change the binary code (the <kbd class="calibre18">.class</kbd> <span class="calibre10">file</span><span class="calibre10">), so when the interceptor code is injected, we are left with a <kbd class="calibre18">.class</kbd> file that is different from the <kbd class="calibre18">.class</kbd> that would be generated without the injection code. The resulting <kbd class="calibre18">.class</kbd> file then becomes incompatible with the source code.</span></p>
<p class="mce-root">On the other hand, the run-time injection does not modify either the source code or the <kbd class="calibre18">.class</kbd> file. In this case, the interception <span class="calibre10">method</span><span class="calibre10"> is done in a separate code from the class or place that contains the method. As a consequence, the interception codes that are executed before and after the method's original call are found in another class.</span></p>
<p class="mce-root">Java does not offer a built-in solution for AOP, but some third-party frameworks, such as Eclipse AspectJ and Spring, are widely used in Java applications. We could use <span class="calibre10">Eclipse AspectJ, for instance, to </span>implement AOP. Eclipse AspectJ is a seamless aspect-oriented extension to the Java programming language. It is a Java platform that is compatible and easy to use. However, JEE implements AOP using a new idea concept known as an <strong class="calibre8">interceptor</strong>, and we <span class="calibre10">will see how this functions </span><span class="calibre10">in the following section</span><span class="calibre10">. All JEE programmers can have AOP using</span> interceptors, without it being<span class="calibre10"> nece</span><span class="calibre10">ssary to get the JAR's dependency related to the AspectJ solution and putting this into our application. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">AOP in JEE scenario – the interceptor</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">Aspect-oriented software development enables the clean modularization of crosscutting concerns. For the benefit of all JEE</span> programmers, <span class="calibre10">we can also separate business code from crosscutting concerns,</span> which is a solution that t<span class="calibre10">he interceptor technologies offer by implementing JEE.</span></p>
<p class="mce-root">When an<span class="calibre10"> EJB method or a managed bean is called and there is an interceptor associated with this call (we will see how this is implemented soon), we can write a code to be executed immediately before the method calls and also just after the method calls (that is, after the return of the method).</span></p>
<p class="mce-root"><span class="calibre10">Intercepting filter patterns is another pattern </span><span class="calibre10">that is used for intercepting a request. In JEE, we can implement the filter pattern using web filters and servlets. By using a web filter, a Java web application implements the interception of web requests and responses. The web application can intercept the request, fulfill an action, and also intercept the response. The following list contains several examples of filters that have many actions:<br class="calibre9"/></span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Authentication/authorization filters</span></li>
<li class="calibre16"><span class="calibre5">Logging and auditing filters</span></li>
<li class="calibre16"><span class="calibre5">Image conversion filters</span></li>
<li class="calibre16"><span class="calibre5">Data compression filters</span></li>
<li class="calibre16"><span class="calibre5">Encryption filters</span></li>
<li class="calibre16"><span class="calibre5">Tokenizing filters</span></li>
</ul>
<p class="mce-root">The interceptor acts as a filter, and therefore we can consider a web filter as an interceptor<span class="calibre10">. However, this mechanism is related to web requests and responses. We will not talk about this type of interception in this chapter. Instead, we will cover the</span> i<span class="calibre10">nterceptor patterns that are used in managed beans—that is, the</span><span class="calibre10"> </span><span class="calibre10">EJB interceptor, the </span><span class="calibre10">CDI beans interceptor, and a kind of business logic interceptor referred to as <em class="calibre12">the decorator</em>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A brief word about CDI and beans</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We are presuming that the reader knows the basic characteristics that surround the CDI, as well as its main objectives and uses. However, it is very important to emphasize some definitions and aspects of the CDI.</p>
<p class="mce-root">The CDI technology is one of the pillars of the JEE platform, and it is present in most of its services. This means that these services depend in some way on the CDI mechanism—CDI is closely related to the bean concept within the EE specification, so let's take a look at what a bean actually is.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The bean</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The idea of a bean is quite generic. Here, we are not talking about the concept of JavaBeans, with the <span class="calibre10">getters and setters </span><span class="calibre10">access method. Instead, we are talking about the concept of the bean as a web component or business component. In this scenario, we encounter several types of beans, such as Java classes in web and JEE-related beans, such as EJB beans and JSF-managed beans. There are even some third-party frameworks outside of the JEE specification (s</span><span class="calibre10">uch as Spring)</span><span class="calibre10"> that have a different concept of the bean. The concept of a JEE bean is known as a <strong class="calibre8">managed bean</strong>, which is managed by a container that requires little intervention by the programmer and has a well-defined life cycle. As well as this, a managed bean can provide mechanisms for intercepting its execution and life cycle callback methods, and can be injected into other beans or JEE objects.</span></p>
<p class="mce-root">Consequently, an object that has a well-defined life cycle contex<span class="calibre10">t can be considered a bean or a managed bean. In other words, a</span><span class="calibre10"> managed bean is a component that the container constructs and destroys (as part of managing its life cycle). </span><span class="calibre10">CDI includes built-in support for several different kinds of bean. The following <span class="calibre10">Java EE components can be injected:</span></span><span class="calibre10"><span class="calibre10"> </span></span></p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Managed beans</strong>:<span class="calibre5"> </span>EJB session beans, classes annotated with <kbd class="calibre18">@ManagedBean</kbd>, decorators, and classes that conform to the CDI rules for becoming a managed bean</li>
<li class="calibre16"><strong class="calibre3">Java EE resources</strong>:<span class="calibre5"> </span>Resources that can be referenced from the component environment naming space</li>
<li class="calibre16"><strong class="calibre3">Arbitrary objects</strong>:<strong class="calibre3"> </strong>Objects<span class="calibre5"> </span>that are returned by producer methods and fields</li>
</ul>
<p class="mce-root"><span class="calibre10">Managed beans may also inject other beans. </span></p>
<p class="mce-root"><strong class="calibre8">Obs:</strong> <span class="calibre10">The JSF specification also describes a technology known as managed beans. These managed beans are different from the ones we describe here. The Java EE foundational managed beans are a generalization of the JSF ones, and are not limited to web modules.</span></p>
<p class="mce-root">There are other objects from the JEE platform (such as the servlet and interceptor objects) that are not classified as JEE beans, and which may have injected beans via the CDI mechanism. The JEE platform components that may have beans injected are as follows:</p>
<ul class="calibre15">
<li class="calibre16">Servlets (including servlet filters and servlet event listeners)</li>
<li class="calibre16">JSP tag handlers and tag library event listeners</li>
<li class="calibre16">JSF scope-managed beans</li>
<li class="calibre16"><span class="calibre5">JAX–RS components</span></li>
<li class="calibre16">JAX–WS service endpoints and handlers</li>
<li class="calibre16">WebSocket endpoints</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Managed beans in CDI</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are several ways to declare a Java class as a managed bean. For example, if we annotate a class with <kbd class="calibre18">@ManageBean</kbd>, it is defined as a managed bean. However, the CDI specification insists that a class has to be considered as a managed bean according to certain criteria. These criteria are as follows:</p>
<ul class="calibre15">
<li class="calibre16">It is not a nonstatic inner class</li>
<li class="calibre16">It is a concrete class or it is annotated with <kbd class="calibre18">@Decorator</kbd></li>
<li class="calibre16">It is not an EJB component</li>
<li class="calibre16">It does not implement <kbd class="calibre18">javax.enterprise.inject.spi.Extension</kbd></li>
<li class="calibre16">It either has a <kbd class="calibre18">no-argument</kbd> constructor, or declares a constructor annotated with <kbd class="calibre18">@Inject</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Loose coupling</h1>
                </header>
            
            <article class="calibre2">
                
<div class="title-page-name">
<p class="calibre4"><span class="calibre5">Some of the objectives of using patterns in the JEE context are to reduce the coupling between classes on different layers—or even on the same layer—as well as the code reuse (that is, the use of some existing code that provides a certain functionality). With these two objectives, we are able to improve software maintenance and quality. But how?</span></p>
</div>
<p class="mce-root">Loose coupling allows programmers to fix bugs or to develop new functionalities in a layer with minimum impact on the other layers. In addition, with every tested code, <span class="calibre10">methods </span><span class="calibre10">of special beans or objects may be called from different parts of an application, thereby improving software organization and clarity. As a result of this, software quality is improved and development time </span><span class="calibre10">decreased.</span></p>
<p class="mce-root">As we know, loose coupling makes the code easier to maintain.</p>
<p class="mce-root"><span class="calibre10">In fact, the CDI provides loose coupling. In addition, the</span> <span class="calibre10"><span class="calibre10">CDI </span></span><span class="calibre10">works in a strong, safe way using qualifier annotations instead of string identification.</span></p>
<p class="mce-root">In JEE, the use of events, interceptors, and decorators provides loose coupling, as described in the following list:</p>
<ul class="calibre15">
<li class="calibre61"><strong class="calibre3">Event notifications</strong>: Establish a decoupling between event-generating clients and event listeners (observers)</li>
<li class="calibre61"><strong class="calibre3">Interceptors</strong>: Separate technical concerns from business logic</li>
<li class="calibre61"><strong class="calibre3">Decorators</strong>: Allow business concerns to be extended (adding business functionality to existing ones)</li>
</ul>
<p class="mce-root">In this chapter, we will see how the interceptors and decorators achieve this goal. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Interceptors in the JEE platform</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An Oracle tutorial defines an interceptor as follows:</p>
<div class="packt_quote1">"<span class="calibre5"><em class="calibre19">An interceptor is a class used to interpose in invocation </em></span><em class="calibre19">methods </em><em class="calibre19">or life cycle events that occur in an associated target class."</em></div>
<p class="mce-root">As previously mentioned, interceptors are generally used for technical tasks, referred to as cross-cutting tasks. This includes auditing, logging, <span class="calibre10">controlling</span><span class="calibre10"> statistics, and so on. These tasks are separate from the business logic, and may be repeated over the entire application. Consequently, we can put the interceptor code into a separate class that is different from the target class that we want to intercept in order to improve code maintenance.</span></p>
<p class="mce-root">The concept of the interceptor was <span class="calibre10">first</span><span class="calibre10"> </span><span class="calibre10">introduced </span><span class="calibre10">in JEE5, and it was only used for EJBs (</span><span class="calibre10">session beans and message-driven beans</span><span class="calibre10">). With the introduction of</span> <strong class="calibre8">context and dependency injection</strong> (<strong class="calibre8">CDI</strong>) in JEE6, <span class="calibre10">the interceptors were extended to all managed beans—that is, to beans that meet the CDI-managed bean. </span></p>
<p class="mce-root">Interceptor methods are invoked on an associated target class.</p>
<p class="mce-root">We can define an interceptor within the target class as an interceptor method, or we can define an interceptor in a separate class (called an <strong class="calibre8">interceptor class</strong>) that contains the interceptor method. Interceptor methods are always invoked when a target class <span class="calibre10">method</span><span class="calibre10"> is annotated to be intercepted and is then invoked, or when a life cycle callback method is intercepted (</span><span class="calibre10">such as before the construction or after the destruction of a bean)</span><span class="calibre10">. It is important to note that for simple applications, we can put interceptors in the target class. However, for a more complex application, or for when the application grows in complexity, we should put the interceptor in a separate class.</span></p>
<p class="mce-root">Each element that you want to intercept is called an <strong class="calibre8">advice</strong>. We say that an interceptor decorates the advice, and each time an advice is called, an interceptor code is executed (if it exists). The location of the point where this code is executed is called the <strong class="calibre8">pointcut</strong>. </p>
<div class="packt_tip">Interceptor methods on an associated target class are invoked when advice target class methods are invoked, or when there is a life cycle event and the life cycle callback method related to the event is called.</div>
<p class="mce-root">The following figure shows an interceptor sequence diagram:</p>
<div class="cdpaligncenter"><img src="Images/615b4cb0-2b60-4df4-9678-d88895353e5d.png" class="calibre62"/></div>
<p class="mce-root"><span class="calibre10">This sequence diagram shows a chain of interceptors. When a client calls a business method a</span>nd there i<span class="calibre10">s a chain of interceptors</span> associated w<span class="calibre10">ith it,</span><span class="calibre10"> </span><span class="calibre10">the first interceptor is called and does something (that is, this first interceptor method's code is executed), then calls the second interceptor explicitly, and so on. This continues until the last interceptor in the chain calls the bean's business method. W</span><span class="calibre10">e will see how this call is made later. For now, we can say that an element of the chain of interceptors calls the next element in the same way until the last element—which is the business method of the managed bean itself—is invoked.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">We can define interceptor classes and interceptor methods using annotations, or, alternatively, we can define the deployment descriptor of the application. However, in this section, we will only cover the use of annotations. The following table shows the annotations used in interceptor methods that define the <span class="calibre10">condition or when the interception occurs</span>:</p>
<table border="1" class="calibre35">
<tbody class="calibre36">
<tr class="calibre37">
<td class="calibre39">
<div class="cdpaligncenter"><strong class="calibre3"><span class="calibre5">Interceptor annotation</span></strong></div>
</td>
<td class="calibre39">
<div class="cdpaligncenter"><strong class="calibre3"><span class="calibre5">Description</span></strong></div>
</td>
</tr>
<tr class="calibre38">
<td class="calibre39"><kbd class="calibre18">javax.i<span class="calibre5">nterceptor.Arou</span><span class="calibre5">ndConstruct</span></kbd></td>
<td class="calibre39">This defines an intercept method that receives a callback when the constructor of the target class is invoked</td>
</tr>
<tr class="calibre37">
<td class="calibre39"><kbd class="calibre18">javax.interceptor.AroundInvoke</kbd></td>
<td class="calibre39">This defines an intercept method that is executed when a method of the target class that is marked to be intercepted with an annotation is invoked</td>
</tr>
<tr class="calibre38">
<td class="calibre39"><kbd class="calibre18"><span class="calibre5">javax.interceptor.AroundTimeout</span></kbd></td>
<td class="calibre39">This defines an interceptor method that interposes on timeout methods</td>
</tr>
<tr class="calibre37">
<td class="calibre39"><kbd class="calibre18">javax.annotation.PostConstruct</kbd></td>
<td class="calibre39">This defines an interceptor method for post-construct life cycle events</td>
</tr>
<tr class="calibre40">
<td class="calibre39"><kbd class="calibre18">javax.annotation.PreDestroy</kbd></td>
<td class="calibre39">This defines an interceptor method for predestroy life cycle events</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">EJB interceptor implementation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">In this section, we will look at an example of the original EJB interceptor implementation.</span></p>
<p class="mce-root"><span class="calibre10">Suppose that there is a stateless session EJB, such as <kbd class="calibre18">AcademicFacadeImpl</kbd>, as well as a business method called <kbd class="calibre18">testReview</kbd>. This method is responsible for scheduling a student test review. Let's say that we want to know, statistically, which students have made the most test review requests. We could do this within the business code, but that is not what we want. Instead, we want to separate statistic logic from business logic statistics—we want a statistic interceptor. </span></p>
<p class="mce-root">First of all, we will create an EJB target class named <span class="calibre10"><kbd class="calibre18">AcademicFacadeImpl</kbd></span> <span class="calibre10">(this class was already created in the last chapter). In the beginning, there is no interceptor reference, as shown in the following code:</span></p>
<pre class="calibre23">@Stateless<br class="calibre2"/>@LocalBean <br class="calibre2"/>public class AcademicFacadeImpl {<br class="calibre2"/>    ...<br class="calibre2"/>    ...<br class="calibre2"/>    // this method will be intercepted for some statistical <br class="calibre2"/>    // interceptor:<br class="calibre2"/>    public void requestTestReview (@Observes TestRevisionTO <br class="calibre2"/>    testRevisionTO) {<br class="calibre2"/>        System.out.println("enrollment : " + <br class="calibre2"/>        testRevisionTO.getEnrollment());<br class="calibre2"/>        LocalDateTime dateTime = scheduleTestReview (testRevisionTO);<br class="calibre2"/>        // send an email with the schedule date for review:<br class="calibre2"/>        sendEmail (testRevisionTO, dateTime); <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">So, we define an interceptor using one of the interceptor annotations listed in the previous table. This can be found within the target class or in a separate interceptor class. The following code shows an <kbd class="calibre18">@AroundInvoke</kbd> interceptor method declared in the target class:</p>
<pre class="calibre23">@Stateless<br class="calibre2"/>public class AcademicFacadeImpl {<br class="calibre2"/>   ...<br class="calibre2"/>   ...<br class="calibre2"/>   @AroundInvoke<br class="calibre2"/>  public Object statisticMethod (InvocationContext invocationContext)  throws Exception{<br class="calibre2"/>   ...<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">Alternatively, we can use a separate interceptor class. We may apply the <kbd class="calibre18">@Interceptor</kbd> <span class="calibre10">annotation</span>, but interceptor classes do not have to be annotated. An interceptor class must have a <kbd class="calibre18">public</kbd> and <kbd class="calibre18">no-argument</kbd> constructor. The following code shows an interceptor class with an <kbd class="calibre18">@Interceptor</kbd> and <span class="calibre10"><kbd class="calibre18">@AroundInvoke</kbd> interceptor method:</span></p>
<pre class="calibre23">@Interceptor<br class="calibre2"/>public class StatisticInterceptor implements Serializable {<br class="calibre2"/>  <br class="calibre2"/>  @Inject <br class="calibre2"/>  private Event&lt;String&gt; event; <br class="calibre2"/>  <br class="calibre2"/>  @AroundInvoke<br class="calibre2"/>  public Object statisticMethod (InvocationContext invocationContext) throws Exception{<br class="calibre2"/>    System.out.println("Statistical method : "<br class="calibre2"/>        + invocationContext.getMethod().getName() + " " <br class="calibre2"/>        + invocationContext.getMethod().getDeclaringClass()<br class="calibre2"/>        );<br class="calibre2"/>    <br class="calibre2"/>    // get the enrollment:<br class="calibre2"/>    TestRevisionTO testRevisionTO = <br class="calibre2"/>    (TestRevisionTO)invocationContext.getParameters()[0];<br class="calibre2"/>    <br class="calibre2"/>    System.out.println("Enrolment : " + <br class="calibre2"/>    testRevisionTO.getEnrollment());<br class="calibre2"/>    <br class="calibre2"/>    // fire an asynchronous statistical event:<br class="calibre2"/>    event.fire (testRevisionTO.getEnrollment());<br class="calibre2"/>        <br class="calibre2"/>    return invocationContext.proceed();<br class="calibre2"/><br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>}</pre>
<p class="mce-root">In this example, we use the CDI event API. This API is used to implement an event-firing mechanism. Basically, this uses a bean to fire an event, and one or more beans observe this firing. This mechanism is implemented from an <kbd class="calibre18">Event</kbd> class object, as shown in the code. We use a <kbd class="calibre18">String</kbd> type to qualify the event, but we could use any other type, or use qualifiers to qualify our event.</p>
<p class="mce-root">We can <span class="calibre10">also</span><span class="calibre10"> </span><span class="calibre10">see the</span> <kbd class="calibre18">InvocationContext</kbd><span class="calibre10"> </span><span class="calibre10">object</span><span class="calibre10"> </span><span class="calibre10">that is a parameter of the</span> <kbd class="calibre18">statisticMethod</kbd> <span class="calibre10">method. This object provides information about the context of the intercepted invocation. In addition, this object has methods for controlling the chain interceptor. For example, the</span> <kbd class="calibre18">proceed</kbd><span class="calibre10"> method calls the next interceptor in the interceptor chain, or the intercepted method of the business object. We will learn more about </span><kbd class="calibre18">InvocationContext</kbd> <span class="calibre10">later.</span></p>
<p class="mce-root">Next, we must use the <kbd class="calibre18">@Interceptors</kbd> annotation to define at least one interceptor. We can define interceptors at the class or method level of the target class by indicating whether we want to intercept all the business methods or just some specific business methods. The following code shows only one interceptor declared at the class level:</p>
<pre class="calibre23">@Stateless<br class="calibre2"/>@Interceptors({StatisticInterceptor.class})<br class="calibre2"/>public class AcademicFacadeImpl</pre>
<p class="mce-root"><span class="calibre10">The following code declares the same interceptor, but at the method level:</span></p>
<pre class="calibre23">@Stateless<br class="calibre2"/>public class AcademicFacadeImpl{<br class="calibre2"/>   ...<br class="calibre2"/>   @Interceptors({StatisticInterceptor.class})<br class="calibre2"/>   public void requestTestReview (@Observes TestRevisionTO <br class="calibre2"/>   testRevisionTO) {<br class="calibre2"/>      ...<br class="calibre2"/>   }<br class="calibre2"/>}</pre>
<p class="mce-root">We will put <kbd class="calibre18">@Interceptors</kbd> at the method level. This is because we don't want to intercept all other EJB methods.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Finally, we must create a class that will observe the statistical event. This class will handle statistical issues. This is shown in the following code:</p>
<pre class="calibre23">public class StatisticalFacadeImpl {<br class="calibre2"/> <br class="calibre2"/>    public void control (@Observes String enrolment ) {<br class="calibre2"/>        System.out.println("This enrolment is asking for a test <br class="calibre2"/>        revision : " +  enrolment);<br class="calibre2"/>        // Here we can persist this information, for example. <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">When <span class="calibre10">the</span> <span class="calibre10"><kbd class="calibre18">requestTestReview</kbd> method of the <kbd class="calibre18">AcademicFacadeImpl</kbd> class is called</span>, it is intercepted (this method is marked with an interceptor), so the <kbd class="calibre18">statisticMethod</kbd> method of the <kbd class="calibre18">StatisticInterceptor</kbd> class is called. During the execution of this method, a statistical event is triggered. The purpose here is to perform statistical control asynchronously <span class="calibre10"><span class="calibre10">for </span></span>execution of the business method.</p>
<p class="mce-root">As an alternative, we could convert the <kbd class="calibre18">StatisticalFacadeImpl</kbd> into an EJB and annotate the <kbd class="calibre18">control</kbd> method with <kbd class="calibre18">@Asynchronous</kbd>. As a result, we would not have to fire a statistical event, and instead, we could call the following asynchronous method:</p>
<pre class="calibre23">@Stateless<br class="calibre2"/>@LocalBean<br class="calibre2"/>public class StatisticalFacadeImpl {<br class="calibre2"/>    @Asynchronous<br class="calibre2"/>    public void control (String enrolment ) {<br class="calibre2"/>        System.out.println("This enrolment is asking for a test <br class="calibre2"/>        revision : " +  enrolment);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Intercepting method invocation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If we want a specific method to be a pointcut, we have to annotate it with the<span class="calibre10"> </span><kbd class="calibre18">@AroundInvoke</kbd><span class="calibre10"> </span>annotation. The<span class="calibre10"> </span><span class="calibre10"><kbd class="calibre18">@AroundInvoke</kbd> method (or the pointcut method) </span>must<em class="calibre12"> return an object</em><span class="calibre10">, </span>and must have a parameter of the <kbd class="calibre18">InvocationContext</kbd> type. As well as this, the pointcut method should<span class="calibre10"> </span><em class="calibre12">throw an exception</em>. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The <kbd class="calibre18">InvocationContext</kbd> methods can be called in order to access <span class="calibre10">information</span><span class="calibre10"> about the</span><span class="calibre10"> current context, such as the name of the pointcut, the method annotations, the method parameters, and so on. However, it is important to note that in an interception situation, the target class method is invoked only when the</span> <kbd class="calibre18">@AroundInvoke</kbd> <span class="calibre10">method calls the <kbd class="calibre18">proceed</kbd> method. As a result, the</span> <kbd class="calibre18">@AroundInvoke</kbd> <span class="calibre10">method must call the <kbd class="calibre18">proceed</kbd> method in order to invoke the target class method. In the case of the chain of interceptors, every time an EJB business method is called, each</span> <kbd class="calibre18">@AroundInvoke</kbd> <span class="calibre10">method of each chain interceptor is called in the order that is configured for them (via</span> <kbd class="calibre18">@Interceptors</kbd><span class="calibre10">) until the target class method is invoked. </span></p>
<p class="mce-root"><span class="calibre10">These</span><span class="calibre10"> </span><span class="calibre10"><kbd class="calibre18">@AroundInvoke</kbd></span> <span class="calibre10">interceptor methods can have any of the access-level modifiers—public, protected, private, or package. However, the methods must not be static or final.</span> Keep in mind that only one <kbd class="calibre18">@AroundInvoke</kbd> interceptor method per class is permitted.</p>
<div class="packt_tip"><kbd class="calibre63">AroundInvoke</kbd> interceptor methods have the following form:<br class="calibre2"/>
<kbd class="calibre63">@AroundInvoke</kbd><br class="calibre2"/>
<kbd class="calibre63">[public, protected, private or package-level ] Object method-name (InvocationContext) throws Exception { ...}</kbd><br class="calibre2"/>
Only <span class="calibre5">one <kbd class="calibre63">AroundInvoke</kbd> interceptor method per class is allowed.</span></div>
<p class="mce-root">Another important thing to keep in mind is that a<span class="calibre10">n <kbd class="calibre18">AroundInvoke</kbd> interceptor can have the same transaction context as the target method.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Interceptor class and multiple method interceptors</h1>
                </header>
            
            <article class="calibre2">
                
<div class="title-page-name">
<p class="calibre4">Having an interceptor in a separate class improves code maintenance by providing a clear division of responsibilities between classes, meaning that the classes become more cohesive. In addition<span class="calibre5">, interceptor classes may have resources and managed beans injected into them. </span></p>
<p class="calibre4"><span class="calibre5">Another important factor worth mentioning is that the interceptor method belongs to the same EJB transaction context. So, whenever we want to intercept a business logic to do a technical task, such as logging or statistic persistence, we must take care. For instance, we don't want any errors to be thrown during statistic control, thereby generating a business transaction rollback.</span></p>
<p class="calibre4"><span class="calibre5">In this case, we should perform asynchronous statistic controlling. This would guarantee that any eventual error would occur in a new transaction</span><span class="calibre5">, separate from the current transaction. So, it is essential that good software design and strong business knowledge are achieved before coding.</span></p>
</div>
<div class="packt_infobox">Interceptor classes <span class="calibre5">may have resources and managed beans injected into them.</span></div>
<div class="title-page-name">
<p class="calibre4"><span class="calibre5">The</span><span class="calibre5"> </span><kbd class="calibre18"><span class="calibre5">@Interceptors</span></kbd><span class="calibre5"> </span><span class="calibre5">annotation is used to inject one or more interceptors into the EJB target class or into the EJB target</span> <span class="calibre5">method. </span>See the following code:</p>
</div>
<div class="title-page-name">
<div class="title-page-name">
<pre class="calibre23">@Interceptors({PrimaryInterceptor.class, SecondaryInterceptor.class,
        LastInterceptor.class})
public void method(String prm) { ... }</pre></div>
</div>
<div class="title-page-name">
<p class="calibre4"><span class="calibre5">The interceptors are invoked in the order in which they were defined within the </span><kbd class="calibre18">@Interceptors</kbd> annotation. However, if the interceptors are also defined in the deployment descriptor, this order can be overridden. Consequently, if there is an interceptor chain, an interceptor calls the next one by invoking the <kbd class="calibre18">InvocationContext.proceed</kbd> method within the order specified in <kbd class="calibre18">@Interceptors</kbd>. This continues until the business method is invoked.</p>
<p class="calibre4">The interceptor class is referenced in the EJB target class, which causes the target class to discover the interceptor class. This situation establishes a coupling between both classes. We will cover how the CDI interceptor mechanism corrects this situation <span class="calibre5">later.</span><span class="calibre5"> </span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Intercepting life cycle callback events </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The interceptor methods that are used for the life cycle callback events (<kbd class="calibre18">AroundConstruct</kbd>, <kbd class="calibre18">PostConstruct</kbd>, and <kbd class="calibre18">PreDestroy</kbd>) follow the same model for implementing the interceptors as previously described in regards to location. This <span class="calibre10">may be defined in the target class, in interceptor classes, or in both classes. </span><span class="calibre10">In this chapter, we will only see examples of <kbd class="calibre18">PostConstruct</kbd> and <kbd class="calibre18">PreDestroy</kbd> callback events.</span></p>
<p class="mce-root"><span class="calibre10">As described in the previous table containing the interceptor annotations, a method with the <kbd class="calibre18">@PostConstruct</kbd> annotation is used to intercept the <kbd class="calibre18">PostConstruct</kbd> life cycle event, and a method with a <kbd class="calibre18">@PreDestroy</kbd> annotation is used to intercept the <kbd class="calibre18">PreDestroy</kbd> life cycle event. Intercepting classes have the same life cycle as the target classes. This means that when an instance of the target class is created, an interceptor object is also created for each declaration of the interceptor class in the target class.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">However, there is another way to approach this. We can define callback methods for life cycle events and define interceptor methods for these callback methods. So what we really want is to intercept a callback method. The callback method for a life cycle event within the target class </span><span class="calibre10">(or a life cycle event interceptor on the target class side) </span><span class="calibre10">has the following</span> <span class="calibre10">syntax</span><span class="calibre10">:</span></p>
<pre class="calibre23">void someMethod() { ... }</pre>
<p class="mce-root"><span class="calibre10">An example of this could be the following:</span></p>
<pre class="mce-root2">@PostConstruct
void initialize() { ... }<br class="calibre2"/><br class="calibre2"/>@PreDestroy<br class="calibre2"/>void finalize () { ...}</pre>
<p class="mce-root">The interceptor method for this callback  method defined in an interceptor class <span class="calibre10">(or a life cycle event interceptor on the interceptor class side) </span><span class="calibre10">has the following syntax:</span></p>
<pre class="mce-root2">void someOtherMethod(InvocationContext ctx) { ... }</pre>
<p class="mce-root"><span class="calibre10">An example could be the following:</span></p>
<pre class="mce-root2">@PostConstruct<br class="calibre2"/>void initialize (InvocationContext ctx){...}<br class="calibre2"/>@PreDestroy
void cleanup(InvocationContext ctx) { ... }</pre>
<div class="packt_tip"><span class="calibre5">We can define callback methods for life cycle events (<kbd class="calibre63">AroundConstruct</kbd>, <kbd class="calibre63">PostConstruct</kbd>, and <kbd class="calibre63">PreDestroy</kbd>) and we can also define interceptor methods for these callback methods.</span></div>
<p class="mce-root">When testing various situations, we noticed some interesting things.</p>
<p class="mce-root">For the <kbd class="calibre18">@Interceptors</kbd> at class level, if both methods for the same life cycle event are defined in both the target class and interceptor class, then only the callback interceptor is called. However, if there is an explicit invocation of <kbd class="calibre18">InvocationContext.proceed</kbd> inside the callback interceptor, then the callback method in the target class is also called. Let's see what happens when we annotate both the EJB class and the <kbd class="calibre18">Interceptor</kbd> class with the <kbd class="calibre18">@PostConstruct</kbd> annotation.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">The following code shows the</span> <kbd class="calibre18">initialize</kbd> <span class="calibre10">method (which has a <kbd class="calibre18">@PostConstruct</kbd>) of the EJB </span><span class="calibre10"><kbd class="calibre18">AcademicFacadelImpl</kbd> </span><span class="calibre10">class:</span></p>
<pre class="calibre23">public <span class="calibre5">AcademicFacadelImpl </span> () {<br class="calibre2"/>    System.out.println ("creating  bean.");<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>@PostConstruct<br class="calibre2"/>public void initialize () {<br class="calibre2"/>    System.out.println ("post construct of bean.");<br class="calibre2"/>}</pre>
<p class="mce-root">The following code shows the <kbd class="calibre18">initialize</kbd> method <span class="calibre10">(which has a <kbd class="calibre18">@PostConstruct</kbd></span>)<span class="calibre10"> </span>of the <kbd class="calibre18">Interceptor</kbd> class:</p>
<pre class="calibre23">@PostConstruct<br class="calibre2"/> public void initialize (InvocationContext ctx) {<br class="calibre2"/>    System.out.println ("intercepting post construct of bean.");<br class="calibre2"/> }</pre>
<p class="mce-root"><span class="calibre10">We will then receive the following response</span>:</p>
<pre class="mce-root2"><strong class="calibre3">creating  bean.</strong><br class="calibre2"/><strong class="calibre3">intercepting post construct of bean.</strong></pre>
<p class="mce-root">However, we may do this in the <kbd class="calibre18">Interceptor</kbd> class, as follows:</p>
<pre class="calibre23">@PostConstruct<br class="calibre2"/> public void initialize (InvocationContext ctx) {<br class="calibre2"/>    System.out.println ("intercepting post construct of bean.");<br class="calibre2"/>    ctx.proceed();<br class="calibre2"/> }</pre>
<p class="mce-root">By doing this, we will receive the following response:</p>
<pre class="mce-root2"><strong class="calibre3">c</strong><strong class="calibre3">reating bean.</strong><br class="calibre2"/><strong class="calibre3">intercepting post construct of bean.</strong><br class="calibre2"/><strong class="calibre3">post construct of bean</strong></pre>
<p class="mce-root">For the <kbd class="calibre18">@Interceptors</kbd> at the method level, only the callback method is called, regardless of whether the <kbd class="calibre18">InvocationContext.proceed</kbd> is called at the interceptor class.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">CDI interceptor implementation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Along with the introduction to the CDI mechanism, a new approach to interceptors was built based on the functionality of the Java EE interceptors that were previously seen. With the CDI engine, you can intercept business methods for the CDI-managed beans, not just for the EJB beans. A key difference for the interceptor under the CDI context is the way in which the interceptor is injected into the managed bean. We now have the concept of the interceptor <span class="calibre10">bind</span><span class="calibre10">ing t</span>ype. This is an annotation that qualifies the desired type of interceptor for the bean.</p>
<p class="mce-root">Suppose we want to create an interceptor for logging. In this case, we would initially create an interceptor binding type named <kbd class="calibre18">@Loggable</kbd>, which is described as follows:</p>
<pre class="calibre23">@Inherited<br class="calibre2"/>@InterceptorBinding<br class="calibre2"/>@Retention(RUNTIME)<br class="calibre2"/>@Target({METHOD, TYPE})<br class="calibre2"/>public @interface Loggable {<br class="calibre2"/>}</pre>
<p class="mce-root">We will then create an interceptor class. The interceptor class is annotated with both the interceptor binding type and the <kbd class="calibre18">@Interceptor</kbd> annotation. For this example, we create the <kbd class="calibre18">LoggedInterceptor</kbd> class, as shown in the following code:</p>
<pre class="calibre23">@Loggable<br class="calibre2"/>@Interceptor<br class="calibre2"/>public class LoggedInterceptor implements Serializable {<br class="calibre2"/> <br class="calibre2"/> @AroundInvoke<br class="calibre2"/> public Object logMethod (InvocationContext invocationContext) throws <br class="calibre2"/> Exception{<br class="calibre2"/> System.out.println("Entering method : "<br class="calibre2"/> + invocationContext.getMethod().getName() + " " <br class="calibre2"/> + invocationContext.getMethod().getDeclaringClass()<br class="calibre2"/> );<br class="calibre2"/> return invocationContext.proceed();<br class="calibre2"/> }<br class="calibre2"/>}</pre>
<p class="mce-root">The <kbd class="calibre18">@AroundInvoke</kbd> method works in the same way as previously described in the EJB interceptor.</p>
<p class="mce-root">Furthermore, <kbd class="calibre18">@Loggable</kbd> works as a qualifier for the class interceptor. Since it is a kind of qualifier, it is always interesting to declare <span class="calibre10">the interceptor binding type</span> as an adjective. Consequently, we use the word <em class="calibre12">loggable</em><em class="calibre12">, </em>which means that it is suitable for logging.</p>
<p class="mce-root"/>
<p class="mce-root">Once we have created the interceptor binding type and the interceptor class, we can annotate the entire bean or some individual bean methods with the binding type to intercept either all bean methods or specific methods. Look at the following examples:</p>
<pre class="mce-root2">@Loggable<br class="calibre2"/>public class ProfessorDAO implements Serializable {<br class="calibre2"/> ...<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre10">For specific methods, we would use the following:</span></p>
<pre class="mce-root2">public class ProfessorDAO implements Serializable {<br class="calibre2"/>   ...<br class="calibre2"/>    @Loggable<br class="calibre2"/>    public Professor findByName (String name) {<br class="calibre2"/>        ... <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">For an interceptor CDI to be invoked, it must be specified in the <kbd class="calibre18">beans.xml</kbd>, as shown in the <span class="calibre10">following code</span>:</p>
<pre class="mce-root2">&lt;interceptors&gt;<br class="calibre2"/> &lt;class&gt;academic.interceptors.LoggedInterceptor&lt;/class&gt;<br class="calibre2"/> &lt;/interceptors&gt;</pre>
<p class="mce-root">An application may use multiple interceptors. If an application uses more than one interceptor, then the interceptors are invoked in the order specified in the <kbd class="calibre18">beans.xml</kbd> file.</p>
<p class="mce-root">There is a fundamental difference between the CDI interceptor and past EJB interceptors. The CDI bean knows nothing about the interceptor implementation class; it only knows about the interceptor binding type. This approach results in loose coupling.</p>
<p class="mce-root">Let's use the same example as the EJB interceptor. However, this time <span class="calibre10">we are going to use the CDI interceptor mechanism. We will use the same EJB of <kbd class="calibre18">AcademicFacadeImpl</kbd>, but instead of <kbd class="calibre18">@Interceptors</kbd>, we will use an interceptor binding type called <kbd class="calibre18">Statistic</kbd> and will annotate the <kbd class="calibre18">Statisticlnterceptor</kbd> class with this binding type.</span></p>
<p class="mce-root">Let's look at the following code:</p>
<pre class="calibre23">@Inherited<br class="calibre2"/>@InterceptorBinding<br class="calibre2"/>@Retention (RetentionPolicy.RUNTIME)<br class="calibre2"/>@Target({ElementType.METHOD, ElementType.TYPE})<br class="calibre2"/>public @interface Statistic {<br class="calibre2"/>}<br class="calibre2"/>@Statistical<br class="calibre2"/>@Interceptor<br class="calibre2"/>public class StatisticInterceptor implements Serializable {<br class="calibre2"/>  <br class="calibre2"/>  @Inject <br class="calibre2"/>  Event&lt;String&gt; event; <br class="calibre2"/>  <br class="calibre2"/>  @AroundInvoke<br class="calibre2"/>  public Object statisticMethod (InvocationContext invocationContext) <br class="calibre2"/>  throws Exception{<br class="calibre2"/>    System.out.println("Statistical method : "<br class="calibre2"/>        + invocationContext.getMethod().getName() + " " <br class="calibre2"/>        + invocationContext.getMethod().getDeclaringClass()<br class="calibre2"/>        );<br class="calibre2"/>    <br class="calibre2"/>    // get the enrolment:<br class="calibre2"/>    TestRevisionTO testRevisionTO = (TestRevisionTO)invocationContext.getParameters()[0];<br class="calibre2"/>    <br class="calibre2"/>    System.out.println("Enrollment : " + testRevisionTO.getEnrollment());<br class="calibre2"/>    <br class="calibre2"/>    // fire an asynchronous statistical event:<br class="calibre2"/>    event.fire (testRevisionTO.getEnrollment());<br class="calibre2"/>    return invocationContext.proceed();<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>}</pre>
<p class="mce-root">We will use the same EJB of <kbd class="calibre18">StatisticalFacadeImpl</kbd> to handle the statistical elements, as shown in the following code:</p>
<pre class="calibre23">/**<br class="calibre2"/> * Session Bean implementation class StatisticalFacadeImpl<br class="calibre2"/> */<br class="calibre2"/>@Stateless<br class="calibre2"/>public class StatisticalFacadeImpl {<br class="calibre2"/><br class="calibre2"/>    /**<br class="calibre2"/>     * Default constructor. <br class="calibre2"/>     */<br class="calibre2"/>    public StatisticalFacadeImpl() {<br class="calibre2"/>        // TODO Auto-generated constructor stub<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void control (@Observes String enrolment ) {<br class="calibre2"/>      System.out.println("This enrolment is asking for a test revision : " + enrolment);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Finally, we will annotate our business method (or class) with <kbd class="calibre18">@Statistic</kbd>. In this case, we will annotate a business method:</p>
<pre class="calibre23">**<br class="calibre2"/> * Session Bean implementation class AcademicFacadeImpl<br class="calibre2"/> */<br class="calibre2"/>@Stateless<br class="calibre2"/>public class AcademicFacadeImpl  {<br class="calibre2"/>   ...<br class="calibre2"/>   ...<br class="calibre2"/>@Statistic<br class="calibre2"/>public void requestTestReview (@Observes TestRevisionTO testRevisionTO) {<br class="calibre2"/>    System.out.println("Enrollment : " + testRevisionTO.getEnrollment());<br class="calibre2"/>    LocalDateTime dateTime = scheduleTestReview (testRevisionTO);<br class="calibre2"/>    sendEmail (testRevisionTO, dateTime); // send an email with the schedule date for the test review:<br class="calibre2"/>  }   <br class="calibre2"/>    ...<br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">Every time a client calls the EJB method <span class="calibre10">(or any intercepted method of any CDI-managed bean) that is </span>annotated with <kbd class="calibre18">@Statistic</kbd>, the <kbd class="calibre18">@AroundInvoke</kbd> method of the <kbd class="calibre18">StatisticInterceptor</kbd> class is invoked first. In our example, the <span class="calibre10"><kbd class="calibre18">@AroundInvoke</kbd> method fires an asynchronous event. It was deliberately set up in this way so that statistical control does not participate in the business process.<br class="calibre9"/></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decorator </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A decorator is a pattern that makes it possible to extend the business logic of a specific functionality at run-time dynamically. The decorator pattern works as a business component wrapper, intercepting the <kbd class="calibre18"><span class="calibre5">call</span></kbd><span class="calibre10"> </span><span class="calibre10">method that is responsible for executing the function. In other words, this pattern decorates the original business object by packaging the same object and providing additional functionality while also keeping the </span><span class="calibre10">existing functionality </span><span class="calibre10">intact. The decorator pattern is a structural design pattern.</span></p>
<p class="mce-root">This pattern dynamically changes the way in which an object functions at run-time without impacting the existing functionality of the objects. In short, this pattern adds additional behavior to the object by wrapping it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The decorator pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <span class="calibre10">decorator pattern</span> is one of the most frequently used GoF structural patterns. Its class diagram is shown in the following figure:</p>
<div class="cdpaligncenter"><img src="Images/be43dd1a-1c56-4700-980b-945bf23a5002.png" class="calibre64"/></div>
<p class="mce-root"/>
<p class="mce-root">The constituent elements of this pattern are described in <em class="calibre12">Design Patterns</em>: <em class="calibre12">Elements Of Reusable Object-Oriented Software</em> (the GoF book), and are shown in the following table:</p>
<table border="1" class="calibre35">
<tbody class="calibre36">
<tr class="calibre37">
<td class="calibre39"><kbd class="calibre18">Component</kbd></td>
<td class="calibre39">This defines the interface for objects that can have responsibilities added to them dynamically</td>
</tr>
<tr class="calibre38">
<td class="calibre39"><kbd class="calibre18">ConcreteComponent</kbd></td>
<td class="calibre39">This defines an object to which additional responsibilities can be attached</td>
</tr>
<tr class="calibre37">
<td class="calibre39"><kbd class="calibre18">Decorator</kbd></td>
<td class="calibre39">This maintains a reference to a component object, and defines an interface that conforms to a component's interface</td>
</tr>
<tr class="calibre40">
<td class="calibre39"><kbd class="calibre18">ConcreteDecorator</kbd></td>
<td class="calibre39">This adds responsibilities to the component</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root"><span class="calibre10">We can always use inheritance or composition to extend the basic behavior of a business class or domain in compile-time. However, we cannot do this at run-time. The decorator pattern is used to accomplish the task of extending functionality at run-time.</span></p>
<p class="mce-root">In order to explain the <span class="calibre10">decorator pattern</span> better, let's take an example from the academic world. Imagine that we have a domain class called <kbd class="calibre18">BasicEngineering</kbd>, and this class has a method that performs the task of listing the disciplines used for basic engineering. Let's say that we also have two other engineering models—mechanical engineering and electrical engineering. Each of these models has their own disciplines. Consequently, each of the engineering models has a list of the basic disciplines plus its own list of specific disciplines.</p>
<p class="mce-root">The following class diagram shows this arrangement:</p>
<div class="cdpaligncenter"><img src="Images/c683c250-cfac-4c50-bdca-fb7c251c80f8.png" class="calibre65"/></div>
<p class="mce-root">We could implement this pattern in a classic <span class="calibre10">decorator pattern</span>, but this is not our goal. In fact, we do not need to implement it in a trivial way because JEE technology already provides us with a mechanism for implementing the <span class="calibre10">decorator pattern</span> with the use of CDI technology. We will use the <kbd class="calibre18">@Decorator</kbd> annotation to implement this pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The decorator in a JEE scenario</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First of all, we create an <kbd class="calibre18">Engineering</kbd> interface that <span class="calibre10"><span class="calibre10">has </span></span>the business method we want to decorate. We then create an abstract class named <kbd class="calibre18">BasicEngineering</kbd> that extends <kbd class="calibre18">Engineering</kbd>. As the following code shows, we can make an abstract <kbd class="calibre18">EngineeringDecorator</kbd> using two concrete decorators, or we can make two abstract decorator classes that implement <kbd class="calibre18">Engineering</kbd> directly. There is no obligation to keep the decorator classes concrete.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">For the sake of simplicity, let's create the two decorator classes as abstract, without having to extend them from a basic decorator class. So, both the <kbd class="calibre18">ElectronicDecorator</kbd> and <kbd class="calibre18">MechanicalDecorator</kbd> classes will decorate the <kbd class="calibre18">Engineering</kbd> objects (<kbd class="calibre18">ElectronicEngineering</kbd> and <kbd class="calibre18">MechanicalEngineering</kbd>).</p>
<p class="mce-root">The following code shows the model classes that are used in this example:</p>
<pre class="calibre23">public interface Engineering {<br class="calibre2"/> List&lt;String&gt; getDisciplines ();<br class="calibre2"/>}<br class="calibre2"/>public class BasicEngineering implements Engineering {<br class="calibre2"/><br class="calibre2"/> @Override<br class="calibre2"/> public List&lt;String&gt; getDisciplines() {<br class="calibre2"/> return Arrays.asList("d7", "d3");<br class="calibre2"/> }<br class="calibre2"/>}<br class="calibre2"/>@Electronic<br class="calibre2"/>public class ElectronicEngineering extends BasicEngineering {<br class="calibre2"/> ... <br class="calibre2"/>}<br class="calibre2"/>@Mechanical<br class="calibre2"/>public class MechanicalEngineering extends BasicEngineering {<br class="calibre2"/> ...<br class="calibre2"/>}</pre>
<p class="mce-root">We can see that the <kbd class="calibre18">ElectronicEngineering</kbd> and <kbd class="calibre18">MechanicalEngineering</kbd> classes are qualified with the <kbd class="calibre18">@Electronic</kbd> and <kbd class="calibre18">@Mechanical</kbd> decorators respectively. We can see that with the qualifiers, we can identify which type of object we are going to decorate. Thus, the <kbd class="calibre18">MechanicalDecorator</kbd> decorates any <kbd class="calibre18">Engineering</kbd> that has the <span class="calibre10"><kbd class="calibre18">@Mechanical</kbd></span> <span class="calibre10">qualifier</span><span class="calibre10">, and the</span> <kbd class="calibre18">ElectronicDecorator</kbd> <span class="calibre10">decorates any <kbd class="calibre18">Engineering</kbd> that has the</span> <kbd class="calibre18">@Electronic</kbd> <span class="calibre10">qualifier</span><span class="calibre10">. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decorator implementation </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">The following code shows</span> the <kbd class="calibre18">MechanicalDecorator</kbd> <span class="calibre10">and the <kbd class="calibre18">ElectronicDecorator</kbd> decorator classes:</span></p>
<pre class="calibre23">@Decorator<br class="calibre2"/>public abstract class MechanicalDecorator implements Engineering {<br class="calibre2"/>   @Mechanical<br class="calibre2"/>   @Any<br class="calibre2"/>   @Inject<br class="calibre2"/>   @Delegate<br class="calibre2"/>   Engineering engineering;<br class="calibre2"/><br class="calibre2"/>   @Override<br class="calibre2"/>   public List&lt;String&gt; getDisciplines() {<br class="calibre2"/>      System.out.println("Decorating Mechanical Engineering");<br class="calibre2"/>      List&lt;String&gt; disciplines = new ArrayList&lt;&gt;<br class="calibre2"/>      (engineering.getDisciplines());<br class="calibre2"/>      disciplines.addAll (Arrays.asList("d31", "d37", "d33", "d34", <br class="calibre2"/>      "d32"));<br class="calibre2"/>      return disciplines;<br class="calibre2"/>    }<br class="calibre2"/>}<br class="calibre2"/>@Decorator<br class="calibre2"/>public abstract class EngineeringDecorator implements Engineering {<br class="calibre2"/>   @Electronic<br class="calibre2"/>   @Any<br class="calibre2"/>   @Inject<br class="calibre2"/>   @Delegate<br class="calibre2"/>   Engineering engineering;<br class="calibre2"/><br class="calibre2"/>   @Override<br class="calibre2"/>   public List&lt;String&gt; getDisciplines() {<br class="calibre2"/>      System.out.println("Decorating Electronic");<br class="calibre2"/>      List&lt;String&gt; disciplines = new ArrayList&lt;&gt;<br class="calibre2"/>      (engineering.getDisciplines());<br class="calibre2"/>      disciplines.addAll (Arrays.asList("d21", "d27", "d23", "d24", <br class="calibre2"/>      "d22"));<br class="calibre2"/>      return disciplines;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">We can see that the <kbd class="calibre18">Engineering</kbd> object is annotated with <kbd class="calibre18">@Delegate</kbd>. This is the business object that will be decorated. When invoked, the <kbd class="calibre18">getDisciplines</kbd> business method will pass the call to the <kbd class="calibre18">getDisciplines</kbd> method of the decorator. At this point, the decorator takes care of the situation. The decorator's <kbd class="calibre18">getDisciplines</kbd> method calls the delegate object's <kbd class="calibre18">getDisciplines</kbd> method and adds decorated disciplines. This means that it extends the functionality by adding the specific disciplines to the basic ones.</p>
<p class="mce-root">It is also important to bear in mind that the <kbd class="calibre18">@Electronic</kbd> qualifier identifies the decorated object. So, <kbd class="calibre18">ElectronicDecorator</kbd> decorates the <kbd class="calibre18">@Electronic</kbd> object while <kbd class="calibre18">MechanicalDecorator</kbd> decorates the <kbd class="calibre18">@Mechanical</kbd> object. </p>
<p class="mce-root">It is logical to wonder why the <kbd class="calibre18">getDisciplines</kbd> method cannot be put into each of the model classes. Depending on the type of business, this approach would be better. However, let's say that the disciplines can vary widely, and that we have a large number of engineering models. In this case, things can get more complicated, and the use of a decorator adds functionality to something already established.</p>
<p class="mce-root"/>
<p class="mce-root">A decorator can be declared as an abstract class so that it does not have to implement all the business methods of the interface.</p>
<p class="mce-root">Furthermore, for a decorator to be invoked in a CDI context, it must be specified—like an interceptor—in the <kbd class="calibre18">beans.xml</kbd> file. So, the decorators of our example are specified as follows:</p>
<pre class="calibre23">&lt;decorators&gt;<br class="calibre2"/>     &lt;class&gt;book.chapter3.decorator.ElectronicDecorator&lt;/class&gt;<br class="calibre2"/>     &lt;class&gt;book.chapter3.decorator.MechanicalDecorator&lt;/class&gt;<br class="calibre2"/> &lt;/decorators&gt;</pre>
<p class="mce-root">If an application uses more than one decorator, then the decorators are invoked in the order in which they are specified in the <kbd class="calibre18">beans.xml</kbd> file.</p>
<p class="mce-root">If an application has both interceptors and decorators, then the interceptors are invoked first. </p>
<div class="packt_infobox">A decorator must be specified like <span class="calibre5">an interceptor in the</span> <span class="calibre5"><kbd class="calibre63">beans.xml</kbd> file. </span><span class="calibre5">The decorators are invoked in the order in which they are specified in the <kbd class="calibre63">beans.xml</kbd> file.</span></div>
<p class="mce-root">In fact, we could create another decorator, known as <kbd class="calibre18">BasicEngineeringDecorator</kbd>, which would be responsible for decorating any <kbd class="calibre18">Engineering</kbd>. <span class="calibre10">We then simply input the <kbd class="calibre18">@any</kbd> qualifier to qualify the <kbd class="calibre18">Engineering</kbd> object. </span>Of course, we should also worry about the order. This should be the first factor to be called. Consequently, the decorators are listed in the <kbd class="calibre18">beans.xml</kbd> file, as follows:</p>
<pre class="calibre23">&lt;decorators&gt;<br class="calibre2"/>     &lt;class&gt;book.chapter3.decorator.BasicEngineeringDecorator&lt;/class&gt;<br class="calibre2"/>         &lt;class&gt;book.chapter3.decorator.ElectronicEngineeringDecorator&lt;/class&gt;<br class="calibre2"/>     &lt;class&gt;book.chapter3.decorator.MechanicalEngineeringDecorator&lt;/class&gt;<br class="calibre2"/> &lt;/decorators&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we have seen that interceptors and decorators are the platforms through which the JEE platform provides aspect<span class="calibre10">-oriented</span> <span class="calibre10">programming</span>. Interceptors are used to interpose the invocation of some method or life cycle events that occur in an associated target class. The interceptor takes care of technical tasks, called <strong class="calibre8">crosscutting tasks</strong>, that are repeated throughout an application, such as logging, auditing, and exception handling. These tasks are separate from business logic, and it's a good idea to put the interceptor in a separate class for easy maintenance.</p>
<p class="mce-root">We learned how the classic interceptor mechanism works for EJB, as well as the CDI inspector mechanism, which can intercept any managed bean and not just EJB-managed beans.</p>
<p class="mce-root">While the interceptor takes care of the technical tasks, we can add functionality to the existing business logic with the decorators. We learned that the <span class="calibre10">decorator pattern</span> is a well-known <span class="calibre10">structural design pattern</span>. A decorator is a type of interceptor for business classes, and is used when we want to add functionality to a business class while also keeping it intact.</p>
<p class="mce-root">The use of interceptor and decorators promotes low coupling and easy maintenance. However, we must use them carefully. For example, with regards to decorators, we should avoid excessively spreading them through the application. Excessive decentralization can cause an inverse effect and worsen code maintenance.</p>
<p class="mce-root">An interceptor belongs to the same transactional context of the business class that it interposes. As an interceptor only deals with technical issues, tasks related to it cannot influence the execution of business logic. Consequently, errors generated in technical tasks cannot be thrown to the business logic. In a similar way, the execution time of these tasks cannot compose the execution time of business logic.</p>


            </article>

            
        </section>
    </div>



  </body></html>