- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Refactoring?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Picture this. It’s your first day at a new job, and you’re filled with excitement
    and eager to showcase your skills. Your new colleagues are enjoyable to be around,
    the company seems fine, and you’re itching to get started. Your “onboarding buddy”
    begins showing you the project that you’ll be working on for the next several
    months or even years. The concepts behind it are promising, and the business itself
    is stable. However, the code base is an enormous, chaotic mess—like a smoking,
    tangled plate of spaghetti. Well, perhaps you don’t need to imagine it. It’s likely
    you’ve been in that situation before. Maybe you’re even experiencing it right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you open your IDE, you’re greeted with a plethora of modules with
    very similar names. Once you enter a module, you’re met with a daunting number
    of classes, some of which run hundreds of lines. These classes often house methods
    with vague names such as “`manageThis`” or “`processThat`,” and they tend to be
    burdened with an excessive number of parameters. Suffice it to say, this isn’t
    the most conducive environment for grasping the inner workings of your new project.
    Brace yourself for a few challenging weeks – or even months – of work, as the
    code base and architecture of the project are far from optimal. Lack of documentation
    or poor code commenting can make things even more challenging when dealing with
    existing code issues. However, if the code itself is well written and follows
    good architecture practices, it can compensate for the lack of documentation (which
    is definitely not something desirable) and minimize the need for excessive comments
    (we’ll delve into this in the book).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me be clear: it’s not about blaming. Every one of us – and by “us,” I mean
    a large group of people I could call “The Software Development Community” – has
    a slightly different way of solving the very same problem. And everyone, at least
    once in their lifetime, thought “I would have done it better.” But again, every
    one of us knows – or will know – that it’s a lot about circumstances. If a certain
    module or piece of code was completed quickly but poorly, it is likely because
    someone requested it to be completed quickly. Sometimes, we come across situations
    where contradictory requirements are given to us or when priorities change due
    to internal or external events that take place. This request may have been made
    due to a valid business reason, a critical security concern, or any other reason
    that they deemed important. No one is lazy; (almost) nobody works poorly. It’s
    just a matter of circumstances. We’ve all felt that pressure.'
  prefs: []
  type: TYPE_NORMAL
- en: The techniques and concepts that fall under the broad umbrella of “refactoring”
    help prevent you from ending up in that situation, ensuring that your code doesn’t
    become that plate of spaghetti. These techniques, and, more importantly, the mindset
    associated with refactoring, can also assist you in improving the existing code
    base, gracefully navigating the swamp you find yourself in, without feeling overwhelmed.
    In this chapter, we will explore the meaning of refactoring and, in reality, how
    elusive it can be. I will try to narrate, also based on my experience, the motivations
    behind refactoring – motivations that will probably be familiar to you. I will
    then give you some advice on how to organize your refactoring sessions and how
    to prioritize the various parts that need to be fixed in your code.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s start slowly, trying to agree on what we mean by the term that gives
    the title to this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean by refactoring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why you should consider refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you should refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you should refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do we mean by refactoring?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we should give a strict definition of refactoring, we could be in some trouble,
    because it is often interpreted in different ways. The most common meaning, anyway,
    is related to code rewriting. Code refactoring is the process of restructuring
    and improving existing code without changing its behavior. Code is rewritten so
    that it is easier to understand and easier to modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also give a “recursive” definition of refactoring: a series of refactorings
    applied to the software without changing its behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me highlight this again because it’s very important: the software will
    return the very same results as before, no more and no less. It will just be written
    differently. The main (maybe the only) target you have to achieve is to make your
    code easier to understand, and this is one of the most important yet most difficult
    tasks to accomplish.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring could also be bounded with another couple of concepts.
  prefs: []
  type: TYPE_NORMAL
- en: It can be viewed as a way of iteratively improving the design of a software
    system. As the system evolves, its design can degrade and become outdated, leading
    to issues such as increased complexity, reduced maintainability, and reduced flexibility.
    Refactoring helps to address these issues by making incremental changes to the
    design of the system, improving its overall quality and maintainability. Moreover,
    refactoring can be used as a technique for discovering the underlying design of
    a system. By identifying patterns and commonalities in the code, developers can
    gain insights into the design of the system and identify areas for improvement.
    We’ll deepen this concept in the following paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and clean code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring is also closely tied to the concept of clean code. We’ll go into
    details in the next chapter, but we can briefly say that clean code refers to
    code that is easy to read, understand, and *maintain*. Refactoring is one of the
    primary ways in which developers can ensure that their code remains clean. By
    continuously improving the design of their code through refactoring, developers
    can eliminate code smells (a code smell is a sign of a potential problem in the
    source code – we’ll deep dive into this later on in the book) and improve the
    overall quality of the code base. Refactoring helps to keep the code base *maintainable*
    and extensible, reducing the risk of issues. Refactoring can help to ensure that
    the code base remains aligned with the principles of clean code. When your code
    is not clean enough – and we will see what this means in the following chapter
    – what you have to do is just stop and refactor.
  prefs: []
  type: TYPE_NORMAL
- en: Misconceptions about refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various concepts that may resemble refactoring but are not synonymous
    with it. Exploring these concepts can contribute to a better comprehension of
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is not about optimization. However, refactored code could have better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain a little bit better. The main purpose of refactoring is to make
    your code easier to read, not to – for instance – reduce its cyclomatic complexity.
    (Cyclomatic complexity is a way to measure how complex a program’s flow is. It
    counts the number of different paths or decision points in the code. The higher
    the complexity, the more complicated the code becomes. It’s a useful tool for
    gauging code maintainability and finding areas that could use some simplification
    or extra testing.) It’s quite the opposite! Improving your code’s performance
    will probably reduce its readability… and it’s OK because the purposes are different.
    Refactoring is one thing; improving performance is another. Nonetheless, it is
    also true that more readable code could be, in some cases, also more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a very simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have this (very old-school) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can easily see, this method just takes an array of `int` elements and
    sums them, scanning the array one element at a time. We could try to make this
    method faster, without changing its behavior, by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactored method uses a `while` loop instead of a `for` loop and increments
    the loop counter by 2 in each iteration. This allows the method to process two
    elements of the array at a time, effectively reducing the number of iterations
    needed to sum the array. This is a bit more efficient, but it is not more readable
    for sure. We reached the goal of optimization, but we did not refactor the code.
    How could we reach both goals? For instance, using a plain, simple one-liner such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `IntStream` class from Java 8’s Stream API to perform a
    parallel sum operation on the elements of the array. The `parallel()` method enables
    parallel processing, allowing multiple threads to work on different portions of
    the array simultaneously. The `sum()` method then calculates the sum of all the
    elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring is not “fixing bugs.” This is much like the matter of complexity
    we just saw: you could fix a bug by refactoring a piece of code but it would be
    almost accidental. Or, better, it would be like killing two birds with a stone:
    if you can fix a bug *and* refactor a piece of code, it’s a big win! But remember
    – it’s generally advised not to mix different code actions in a single code change,
    even though it frequently happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring can actually *help* you solve bugs, but we’ll see it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most important, refactoring is not “adding features.” When you’re adding functions
    to your software, you should not change existing code, but just add capabilities.
    On the contrary, when you refactor, your northern star shouldn’t be to change
    the existing behavior. As a software professional, you will probably find yourself
    switching between these two aspects. The important thing is that you are aware
    of what you are doing: you structure the code better, then you add new functionality;
    once the new functionalities are tested and proven to be working, you can refactor
    again; and so on. It’s like you’re wearing two hats (using Kent Beck’s metaphor)
    and you keep swapping them: you can and you should, but remember which one you’re
    wearing at each moment.'
  prefs: []
  type: TYPE_NORMAL
- en: In certain situations, there might be pressure from the business to prioritize
    adding new features instead of allocating time for refactoring, which may be seen
    as having no immediate value or merely serving the IT department. As a result,
    attempting to incorporate refactoring tasks discreetly within feature releases
    can lead to a blurring of roles. This means that you are not maintaining separate
    focuses or responsibilities (you’re not *wearing two hats*), thus creating a mixture
    of objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know, more or less, what refactoring means, we are ready to get
    the reasons behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Why you should consider refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw that refactoring is highly coupled with the concept of clean code.
    Hence, we could say that one of the most important outtakes of refactoring your
    code is to improve its readability. In other words, refactoring makes your code
    easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the main goal of writing code is to tell a machine to do what you want,
    exactly the way you want it, it’s important to underline something that we tend
    to forget, sometimes: you have to be understood not only by computers, but first
    and foremost you have to be understood by human beings. And one of those human
    beings is you: your future self! In my experience, I’ve found myself a lot of
    times asking, “Why?!” looking at a piece of code I wrote, maybe just weeks before.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it may seem simple or even naive, the idea of writing readable code
    is often overlooked due to the urgency of making our programs work. While this
    is certainly important, we must also remember that a significant portion of our
    work as software professionals is devoted to maintenance. In my experience, the
    opportunity to start a project from scratch is rare; more often than not, we inherit
    code from someone else and must maintain or build upon it. By prioritizing readability,
    we can benefit in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s important to write code that is easy to understand in the future,
    it’s also helpful to transform complex and unreadable code into clear and organized
    code. Just like Indiana Jones or Lara Croft, developers often have to delve deep
    into the projects they are working on to comprehend the intentions of their programmer
    ancestors. However, this can be significantly more challenging if the code is
    difficult to read. By refactoring the code, you can gain confidence in the functionality
    of the code you’ll be working with.
  prefs: []
  type: TYPE_NORMAL
- en: Another good reason for having readable code is when the code is intended to
    be open sourced. Whether it is due to a personal interest in collaborating with
    open source projects, a company’s approach or using it as a showcase for professional
    profile building, having readable code becomes even more crucial in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Another situation where readable code is valuable is when your code undergoes
    peer review or is used for training junior team members. In such cases, having
    code that is easy to follow and comprehend helps ensure effective collaboration
    and knowledge transfer within the team.
  prefs: []
  type: TYPE_NORMAL
- en: I also like readable code because I have a very bad memory. I am unable to hold
    more than a certain amount of information in my head; actually, I don’t want it.
    There’s no need if you can retrieve the information by simply reading the code
    like it was a piece of prose. It’s not fair to expect my future self or colleagues
    to recall details that could easily be included in the code, such as why a particular
    approach was taken, why certain information was sourced from a particular location,
    or why one solution was chosen over another. One of the most frequent questions
    I ask myself when dealing with legacy code is, “Is this a mistake or is it intentional?”;
    readable code (coupled with the correct amount of tests, code comments, and coding
    standards, but we’ll see this later) is the right choice to remove doubts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many techniques to make the code more readable, and we will expand
    on them later in this book. There is something else I’d like to highlight first:
    readability can be something very subjective. What is readable for me may not
    be for my teammates. Some prefer one-liners, and others prefer to isolate a couple
    of lines in a single method. You may prefer to make explicit the type of every
    single variable; I prefer to use the `var` keyword. My suggestion is simple: talk
    to your teammates and agree on a trade-off. Remove from the discussion objective
    improvements (for example, using streams in place of classic loops) and agree
    on a general “code style” level (you could use a coding standard document or a
    unique formatter for your IDE, but we’ll deep dive into this later). It is important
    to keep the code consistent in all of the project classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the design of your software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refactoring helps you improve the design of your software. If you don’t do
    it, the design will (not so slowly) decay; it will be more difficult to understand,
    for instance, where to put new features or how to implement them. Refactoring
    is like “tidying up” your project once a new functionality is guaranteed. If you
    don’t do it, you will probably fall into pitfalls, one of which is, the ancient
    monster that lies in almost every software company. Reducing duplicated code is
    not just a matter of “doing things properly” (even if doing things properly should
    be the norm) but has a direct benefit: when you have to modify that code, you
    will modify it only once. Believe me when I say that this very basic concept is
    not always respected. I will quote Martin Fowler here, in his book *Refactoring:
    Improving the Design of Existing Code*: “*By eliminating the duplicates, you ensure
    that the code says everything once and only once, which is the essence of* *good
    design.*”'
  prefs: []
  type: TYPE_NORMAL
- en: 'If code is poorly designed or implemented, you’ll have to do extra work to
    add functionalities, fix bugs, or improve performance: that extra work is due
    to something called **technical debt**. Technical debt happens when you prioritize
    speed over long-term benefits in your design or implementation choices. Just like
    a loan, it accumulates interest over time, making it harder to maintain and improve
    the software later. Constant refactoring improves design and quality; a better
    design reduces technical debt.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability and scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said before, software development is a lot about maintainability. If
    refactoring helps you keep a good design, that is a clear understanding of what
    each piece of code does and where to put any new code. In a situation such as
    this, maintainability is facilitated: by improving code organization and structure,
    it becomes easier to identify and fix issues or add new features over time. If
    you take care of your software and refactor when you think it’s necessary (see
    the next subsection), the consequent good design will help you to scale your code.
    While improving performance isn’t the main reason for refactoring, it often ends
    up being a nice bonus. If a certain functionality is properly isolated, for instance,
    it will be likely easier to parallelize it or to remove it and put it in another
    service, using a remote call to retrieve information from it.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding, avoiding, and fixing bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good design means that each part of your code does one thing, and it does it
    well. But things can go bananas, sometimes; bugs are just around the corner. One
    of the first things to do when you fight against a bug is to understand what’s
    happening and where. Refactoring helps to understand the code (because you have
    to rewrite or restructure it a little bit without changing the external behavior),
    and thus you get to know the code better. If you know and understand your code,
    it will be faster to spot bugs or implement fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you some advice: try to avoid having “restricted areas” in projects
    you’re working on. In this case, a restricted area refers to a library, module,
    or another part of your code base that you rely on and understand its purpose,
    but you’re afraid to touch because it’s really fragile. You know what it does,
    but not exactly how it does it. It’s like a big mess that no one in your company
    wants to deal with. The more complex and old the system is, and the more people
    have worked on it, the harder it becomes to understand the code base. Sometimes
    these restricted areas are unavoidable, especially if the previous developers
    didn’t leave any documentation. It’s not a big deal if you have some of these
    areas, but it’s best to minimize them as much as possible. Refactoring can help,
    but there are certain conditions that need to be met, such as having good test
    coverage (but we can talk about that later).'
  prefs: []
  type: TYPE_NORMAL
- en: Faster development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the previous considerations bring us to one, big deal: refactoring helps
    to do things faster. It may sound a bit counterintuitive, but if you think about
    it a little bit, it becomes crystal clear. Having well-designed, bug-free, understandable
    software means keeping good quality software. And of course, the main goal of
    having high-quality software is to add functionality faster, to scale it quickly,
    and to fix bugs in the blink of an eye.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that writing software is a craft. As software developers, we are
    like artisans who shape and mold our applications and engineer and assemble our
    services. Even though we don’t use physical tools such as hammers and wrenches,
    we are still artisans. The main difference is that what we create is flexible
    and adaptable. We have the ability to revisit our work, improve upon it, and make
    it more receptive to change. By doing so, we can establish a solid foundation
    to build upon whenever we need to expand our work.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no proper design, engineering tasks turn into an endless cycle of
    quick fixes and hacks. If you continue to approach projects in this way, relying
    on one temporary solution after another, it is only a matter of time before the
    project becomes unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: If your manager is more focused on schedules and timelines rather than technical
    aspects or quality in general (yes – that can happen), highlighting faster development
    as a key benefit of refactoring can be a compelling selling point.
  prefs: []
  type: TYPE_NORMAL
- en: When you should refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have a clear understanding of what refactoring is and why
    it holds such significant importance or, I would even go as far as to say, it
    is crucial in our daily work. You may be wondering when is the appropriate time
    to engage in this activity. There are several factors to consider when deciding
    on the timing of refactoring. It is no secret that refactoring can be time-consuming,
    so how can we effectively incorporate it into our workflow? When is the optimal
    time to execute this activity?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me start with some fundamental advice based on our experience: it’s always
    a good idea to do some minor refactoring whenever you have the chance, even if
    it means integrating it into your current task. For example, while running tests
    or performing static code analysis, you might come across a variable named *x*.
    That name doesn’t convey much meaning, does it? So, you’ll spend some time trying
    to figure out what that variable represents, only to discover that it contains
    a user’s name. You went through the trouble of deciphering it, but why should
    others have to do the same thing? Why should you have to go through the same hassle
    3 weeks later when you revisit the code? Just take a moment to rename the variable
    `username`. It’s a simple and almost effortless task (your IDE can do that) that
    can save others time and effort. I try to maintain this mindset at all times,
    which aligns with my “lazy” attitude of achieving maximum results with minimal
    effort.'
  prefs: []
  type: TYPE_NORMAL
- en: The “Rule of Three”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Rule of Three** suggests that code should not be duplicated more than
    twice and that once duplication occurs for the third time, it should be extracted
    into a reusable module or function. It is unclear who originally stated this principle
    as it has been widely used and adapted by various software developers and teams
    over the years (it was popularized by Martin Fowler, who credits it to Don Roberts).
    A more effective way to state the same is *three strikes and* *you refactor*.
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory refactoring for smooth feature implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When adding a new feature to your code base, it is often helpful to engage
    in **preparatory refactoring**. This means taking the time to analyze parts of
    your code base that will be affected by the new feature and making necessary changes
    beforehand. I’ll borrow Martin Fowler’s excellent analogy for preparatory refactoring:
    it’s like taping off electrical sockets, door frames, and skirting boards when
    painting a wall. The taping itself isn’t painting, but it makes the painting process
    quicker and easier.'
  prefs: []
  type: TYPE_NORMAL
- en: During the analysis phase of preparatory refactoring, you may notice areas where
    a small change in the code could lead to significant improvements in speed or
    efficiency. For example, you may realize that using a method parameter instead
    of a literal or a class hierarchy instead of a `switch` statement would improve
    the flexibility and adaptability of your code. By making these changes through
    refactoring, you can make your code more open to change in the future and ultimately
    make development easier overall.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for bug fixing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often overlooked, but fixing a bug can present a great opportunity for
    a refactor. This is because a significant portion of bug-fixing-related refactoring
    is aimed at improving the readability of your code. By making your code more understandable,
    you can identify the root cause of the bug sooner and fix it more efficiently.
    The bug had been present all along, but it went unnoticed due to the lack of readability
    in your code. So, it’s always a good practice to take the time to refactor when
    fixing bugs to prevent them from happening again in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me be a bit clearer here: refactoring and bug fixing are two different
    things. It’s important to fix the bug first and then focus on improving the code.
    They may be related but separate steps, and one doesn’t automatically include
    the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehension refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don’t need a bug to make your code cleaner and more understandable; you
    can refactor your code while trying to understand it or – we all have been there
    – remember what you were trying to do 2 months ago. I will repeat this concept
    several times because I think it’s one of the most important in our job: writing
    code is not only talking to a set of machines; it is more about talking to our
    future selves and our colleagues. Martin Fowler refers to this technique as **comprehension
    refactoring**. The idea can be likened to organizing one’s wardrobe, where the
    goal is to have a clear and complete view of all available clothing options to
    select the best-fitting outfit. In the same way, comprehension refactoring involves
    streamlining code to improve its readability and comprehensibility.'
  prefs: []
  type: TYPE_NORMAL
- en: The “Boy Scout Rule”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And then comes one of my favorite concepts related to software engineering,
    which is borrowed from the camping world and should also be applied in real life.
    Leave code better than you found it; at least, leave it as clean as it was. Do
    not leave it worse. Just like when you go camping or you picnic on a green field,
    you must think that that green field is not yours – you’re just borrowing it;
    do not leave your trash. If you find some trash, take some time to pick it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our world, if you find some code that is – let’s say – understandable
    but that you think could work better (for instance, parametrizing a function or
    using another library method with a better signature), just do not ignore the
    problem and fix it. Pick up that small amount of trash you found along your path.
    At the same time, remember that you were doing something else; your task was not
    to pick up the trash but to enjoy your day in the open air (just to continue this
    joyful metaphor). So, find a trade-off between your actual task and this litter-picking
    refactoring; something I found useful, sometimes, is just to keep note that someone
    will have to clean that piece of code: how you do it (a Jira task, a `git pull`
    request, a Post-it on your monitor) depends on how your team works. But this is
    the kind of small-step refactoring that you will find very useful and, I would
    say, almost mind-changing.'
  prefs: []
  type: TYPE_NORMAL
- en: Planned refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this time, it could seem that refactoring must be an activity included in
    your software developer routine, something “opportunistic;” and of course it is.
    You should refactor code as part of your daily activity. Writing software can
    be seen as adding functionalities upon functionalities, resulting in a never-ending
    stack of features and, thus, code modules, but developers know that most of the
    time it’s easier just to change existing code to add a new feature. You should
    never think about software as “done;” it is alive, and it is ever-changing. The
    moment software stays the same for too much time, there’s probably a problem:
    it could be too hard to change or to extend (not enough refactoring has been done),
    or maybe it has been replaced by something else (and so, my advice is… dismiss
    it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'What I’m trying to say here is that it is not always possible to write excellent
    code on the first try; sometimes you have to stop, rewatch what you’ve done, and…
    try to do it better. Sometimes, you’ll even have to plan to refactor because you
    understand that changes are too hard to make on the existing code base; the concept
    is similar to the preparatory refactoring we mentioned before, but it is like
    a level up because you plan the refactoring. You should do it rarely, because
    this means that you didn’t include small refactorings into your daily activity,
    but it can happen. In this case, plan with attention: sometimes it could be better,
    for instance, to use separate branches or commits for new features and refactorings;
    someone else says that this would separate the refactoring from its purpose. I
    don’t really have a suggestion here: just do what fits best for your team.'
  prefs: []
  type: TYPE_NORMAL
- en: Long-term refactoring and “Branch by Abstraction”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although most refactoring tasks can be completed in just a few minutes or hours,
    certain activities may require several weeks of effort to complete. These typically
    include tasks such as isolating specific logic into a separate component or replacing
    one library with another. To address these more complex tasks, it can be helpful
    for a team to establish a practice of performing refactoring whenever they approach
    a “danger zone” that has been identified as in need of improvement. One useful
    technique for achieving this is called **Branch by Abstraction**, which can be
    used to change a library or service call in a gradual and controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: Branch by Abstraction consists of five phases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to replace the outdated `FaultyPay` payment service that
    you integrated into your system several years ago. Naturally, you don’t want to
    cause your customers any problems or inconvenience during the transition process.
    Here, you can see that there is a call and response between the client code and
    `FaultyPay` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response](img/B20912_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you identified the service you want to replace, you build an abstraction
    layer to allow continued communication between the systems that are being replaced
    and the entities requesting that service. This abstraction layer acts as a contract,
    exposing functionality while concealing the implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – An abstraction layer, often represented by a Java interface,
    is inserted between the client code and the component that needs to be eliminated](img/B20912_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – An abstraction layer, often represented by a Java interface, is
    inserted between the client code and the component that needs to be eliminated
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, start replacing the legacy system by systematically building the replacement
    system (we’ll call it `ShinyPay`) and gradually integrating each rebuilt feature
    into the abstraction layer as they are completed. It is important to keep in mind
    that during this process, all traffic – both from the new and the old system –
    will be passing through the abstraction layer. It is also important to note that
    you could also choose (if this is possible – it is not always) to migrate one
    function at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer](img/B20912_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction layer can also be used to fine-tune the service, such as directing
    only a portion of the traffic or specific features to the new component (feature
    toggle). It could also be possible to migrate one method at a time. It is important
    to ensure that both the legacy and the new system adhere to the same contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the code in the old system (`FaultyPay`, in our example) becomes
    obsolete, so you can delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The previous implementation (FaultyPay) is disconnected from
    the system; all traffic and functionalities are now exclusively directed toward
    the new implementation (ShinyPay)](img/B20912_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – The previous implementation (FaultyPay) is disconnected from the
    system; all traffic and functionalities are now exclusively directed toward the
    new implementation (ShinyPay)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the legacy code has been removed, you have the option to dismantle
    the abstraction layer. Alternatively, you may choose to retain this layer for
    the purpose of extensibility or future-proofing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)](img/B20912_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has several obvious advantages. Apart from the primary advantage
    of enabling seamless migration of large features in continuous integration, there
    are several additional benefits of using the Branch by Abstraction technique:'
  prefs: []
  type: TYPE_NORMAL
- en: The release schedule is completely independent of architectural changes, making
    it easy and cost-effective to pause and resume the migration process as needed.
    This is because the new implementation is safeguarded by the system, allowing
    for quick adaptation to urgent requests or priority features from the leadership
    team or customer service department or to fix bugs. In contrast, when using a
    standard feature branch, it can be more challenging to resume a migration that
    has been paused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The potential for merge conflicts is also limited to the abstraction layer only,
    which can significantly reduce the scope of conflicts that may arise. Without
    the abstraction layer, a code base refactor sitting in a feature branch for an
    extended period could generate a wide range of merge conflicts that might be difficult
    to resolve completely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of switching completely to the new system, you could choose to turn
    new features on and off when you need to. These “specific switches” are called
    **feature toggles**. A feature toggle, also known as a feature flag or feature
    switch, is a technique that allows developers to enable or disable specific features
    or functionality in an application, at runtime and without modifying the code
    base. By using feature toggles, developers can release new features to a subset
    of users, test them in production environments, or enable/disable features based
    on certain conditions or user segments. This approach provides flexibility, allows
    for gradual rollouts, and reduces risk associated with deploying new features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring in a code review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **code review** is a process of reviewing the source code. It is usually done
    by other developers or peers who are more or less familiar with the programming
    language and the project’s requirements. We'll cover code reviews in detail in
    [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183).
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a code review is to ensure that the code is written in a clear,
    concise, and efficient manner and that it meets the project’s requirements and
    coding standards. Code reviews can help to identify and fix potential bugs or
    security issues, as well as improve the overall quality and maintainability of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: During a code review, the reviewer examines the code line by line and provides
    feedback on issues such as code structure, syntax errors, performance, and readability.
    The review may also involve discussions and suggestions for improvement, as well
    as questions and clarifications about the code’s functionality and design. Code
    reviews are an important part of the software development process and are typically
    conducted before the code is merged into the main code base or released to customers.
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler suggests that code reviews are a great time to do some refactoring.
    If you want to understand someone else’s code (as we’ve already said), the best
    way is to refactor it. Otherwise, you might only get bits and pieces of it and
    give vague feedback. Refactoring helps you get a clearer picture. By the way,
    there’s something called **pair programming** (and something called **mob programming**)
    that takes code review to the next level. We’ll talk about it more in this book
    later.
  prefs: []
  type: TYPE_NORMAL
- en: What you should refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in my career, we've come across situations where I wanted to make
    changes to different parts of my project. Maybe there was something that wasn’t
    working properly or something that I didn’t fully understand, or simply something
    that could be improved. It’s important to decide which parts to focus on and prioritize.
    And in some cases, it might even be better to leave things as they are and not
    make any changes at all.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no hard and fast rule when it comes to refactoring, but with a little
    thought, you can come up with a solid plan that meets your specific needs. Remember
    – in our profession and in life, we often have to make compromises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, I came across a helpful concept in Gary Keller’s book, *The One Thing*
    (*Bard Press*, *2013*). While it’s not specifically related to software development,
    it can be applied to our needs. The idea is this: “What’s the one thing you can
    do, such that by doing it, everything else will be easier or unnecessary?” While
    this is a broad question with many implications that we can’t discuss here, it
    can be a useful starting point for deciding what to do with our code base. This
    approach is super helpful when it comes to refactoring code. So, when you’re starting
    a new task or feature, take a look at your code and ask yourself if there’s anything
    that, if improved, would make the rest of the project work a lot easier or completely
    unnecessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is focused on what you can do, which forces you to think in actionable
    terms. It’s not about what you would do if certain conditions were met, but rather
    what you’re capable of doing right now. By identifying the one thing that can
    make everything else easier or unnecessary, we can focus our efforts on the most
    critical task at hand. It’s like distilling the essence of our job down to its
    core: doing the minimum necessary to achieve the maximum impact. This approach
    can be particularly valuable in software development, where there are often many
    different areas that could benefit from refactoring or improvement, but we need
    to prioritize and focus our efforts to achieve the greatest impact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you an example to illustrate this point. Picture yourself working
    at a travel company that’s doing well, but facing challenges in handling a complex
    ecosystem with multiple travel providers and their solutions. The trouble is,
    there’s some outdated code causing problems, and the booking process occasionally
    fails. The system technically works without any bugs, but it’s outdated, difficult
    to maintain, lacks proper documentation (in one word: its *legacy*), and definitely
    not ready to handle the expected surge in traffic. We really need to refactor
    it, or else the company won’t be able to handle all the upcoming new customers.
    Meanwhile, there’s an internal team responsible for managing website content,
    and they’re struggling with a tool they only use twice a month. It’s incredibly
    confusing and impractical, making even simple tasks time-consuming. We absolutely
    have to refactor that tool to make it more user-friendly for the team. While both
    issues are important, it’s clear that the first problem with the legacy code and
    booking process should be addressed first, because travel booking is the core
    business of the company and because those people would be free to deal with something
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyways, let’s face it – refactoring legacy code can be overwhelming, especially
    when you’re pressed for time and resources. While “the one thing” rule is a fantastic
    approach, it’s also pretty broad. So, let me show you something more precise that
    can help you decide which parts of the code base require your attention the most.
  prefs: []
  type: TYPE_NORMAL
- en: Impact analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Impact analysis** is like detective work in software refactoring. It’s all
    about figuring out how changes to one part of the code base will affect other
    parts of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: So, first, the developers identify code modules that need to be refactored or
    updated. Then, they investigate the connections and relationships between these
    modules and other parts of the software, such as external libraries, user interfaces,
    and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these dependencies, the developers can get a good sense of
    how changes will ripple through the system. They can pinpoint areas that might
    be particularly tricky to change and take steps to reduce the chances of bugs
    or other issues cropping up.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, impact analysis is a crucial tool in the software refactoring toolkit.
    It helps developers make changes in a more thoughtful and careful way so that
    the code remains stable and easy to maintain in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an impact analysis involves thoroughly assessing the potential effects
    of making changes to a system or project. Here’s a breakdown of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation**: Define the change, clearly stating what you want to do. Collect
    data about the proposed change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify affected areas and dependencies**: Brainstorm which parts of the
    system will be impacted by the change and how the change will affect other components
    in the system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify affected elements in each area**: Evaluate how the change will impact
    functionality, performance, security, and other aspects. Identify potential risks
    and problems that could arise from the change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluate**: Conducting an evaluation, the team identifies both positive and
    negative impacts of the proposed change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deal with negative consequences**: With a clearer understanding of the negative
    impacts, the team can now focus on addressing them. They have the opportunity
    to consult with team members and stakeholders to discuss whether the change should
    proceed or not. Additionally, conducting regression testing becomes crucial in
    this scenario.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Risk assessment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Risk assessment** is a fancy way of saying “figuring out what could go wrong.”
    In software refactoring, it’s all about taking a hard look at the code base and
    identifying potential risks before making changes.'
  prefs: []
  type: TYPE_NORMAL
- en: When assessing risk, developers consider a range of factors, including the complexity
    of the code, the likelihood of introducing bugs, and the potential impact of any
    issues that might arise. There may be impacts on data (some pieces of code are
    maybe dealing with crucial information such as personal or financial data), possible
    downtimes (some pieces of code, in case of issues, may bring down the entire system
    or some core functionalities), business issues (pieces of code that if broken
    could cause financial issues or contract infringements), or security breaches.
    They may also look at the time and resources available for the refactoring project
    and the potential impact on users and stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Once risks have been identified, developers can take steps to mitigate them.
    For example, they might create test cases to ensure that the refactored code works
    as expected, or they might make changes in small increments to reduce the chances
    of something going wrong. We will talk more deeply about test coverage later in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, risk assessment is an important part of software refactoring because
    it helps developers make informed decisions about how to proceed. By taking the
    time to consider potential risks and plan accordingly, they can ensure that the
    refactoring project is successful and that the code base remains stable and maintainable
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: Value estimation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Value estimation** in software refactoring is all about figuring out whether
    a particular refactoring project is worth the time and resources required to complete
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: When estimating value, developers consider a variety of factors, such as the
    current state of the code base, the potential benefits of the refactoring, and
    the potential costs and risks involved. They might also take into account factors
    such as user feedback, performance metrics, and the needs of stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Once the potential value of a refactoring project has been estimated, developers
    can decide whether it makes sense to move forward. In some cases, the potential
    benefits might not outweigh the costs, and the project may be shelved or postponed.
    In other cases, the benefits may be significant enough to justify the investment,
    and the project may move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Value estimation is an important part of software refactoring because it helps
    developers prioritize their efforts and make strategic decisions about how to
    allocate resources. By focusing on projects with high potential value and avoiding
    those with lower potential value, developers can ensure that they are making the
    most efficient use of their time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritization matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **prioritization matrix** (also known as the **Eisenhower Matrix**) is a tool
    used in software refactoring to help developers prioritize their efforts and make
    informed decisions about which refactoring projects to tackle first. It typically
    involves a matrix with two axes, one representing the level of urgency given to
    a project and the other representing the potential impact on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Each project is evaluated based on these two factors and then plotted on the
    matrix accordingly. Projects that require the least effort and have the greatest
    potential impact are considered the highest priority, while those that require
    more effort and have a lower potential impact are considered lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a prioritization matrix can help developers make strategic decisions
    about which projects to tackle first, based on the potential benefits and costs
    of each project. By focusing on the highest priority projects first, developers
    can make the most efficient use of their time and resources, and ensure that they
    are addressing the most critical issues in the code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – You should put your activities in a prioritization matrix in
    order to choose the right priority for execution](img/B20912_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – You should put your activities in a prioritization matrix in order
    to choose the right priority for execution
  prefs: []
  type: TYPE_NORMAL
- en: The higher priority should be assigned to activities that have high urgency
    and impact. Lower priority (or no importance at all) should be given to activities
    that are not urgent and will have no impact.
  prefs: []
  type: TYPE_NORMAL
- en: Further considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s more to think about when it comes to refactoring. I’ll jot it down here
    just to cover all our bases, but honestly, it might be a bit beyond the scope
    of this chapter. Once you’ve figured out which parts of your code base to prioritize
    for refactoring, the next step is to create a detailed plan that includes the
    scope, goals, steps, and timeline for the project. It’s also crucial to communicate
    this plan to everyone involved, such as your team, manager, clients, and users.
    You need to explain why you’re refactoring, what you’ll be doing, how you’ll be
    doing it, and when it’ll be done. It’s important to set clear expectations and
    manage them throughout the refactoring process.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to execute the plan with discipline and diligence. Stick to
    best practices such as making small and frequent changes, running tests before
    and after each change, committing and documenting each change, and reviewing and
    verifying each change. Keep an eye on how the refactoring is affecting things
    such as code quality, system performance, and user feedback. Measure the outcomes
    and compare them with your goals and expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor or rewrite?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various opinions on this matter, which I have observed to be a common
    source of disputes among teammates and colleagues. The truth is there is no simple
    answer. It’s just one of those things where there are a ton of conflicting opinions
    out there, and it’s tough to figure out what to believe. But I’ll do my best to
    share some of those opinions with you and offer up some advice, for whatever it’s
    worth.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations when it’s simply not justifiable to refactor your code.
    Perhaps it’s plagued with too many bugs, the design is overly complicated, and
    comprehending it is nearly impossible. Going through it’s like trying to solve
    the Rubik’s Cube blindfolded – or, quoting a former colleague of mine, like counting
    money with a fan blowing nearby. In such cases, rewriting it from the ground up
    may be the better option, and it’s something that many software developers find
    enjoyable. After all, it’s often more comfortable to create something new than
    to take small, incremental steps that are still tied to what was previously done.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we often fall into the trap of wanting to rewrite everything,
    thinking that what’s already there is terrible, when in reality, we may not have
    put in the effort to fully understand it. It’s important to remember one of the
    fundamental rules of programming, according to American developer Joel Spolsky:
    *it’s harder to read code than to write it*. Let’s not immediately denigrate the
    legacy code we come across in our code bases, which typically wasn’t written by
    us (our own code is, of course, beautiful). Legacy code has a history; it has
    been thoroughly tested and integrated with all necessary use cases and has often
    demonstrated good performance. We should respect legacy code.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a really complicated decision, and as I said, there’s no general rule.
    Perhaps, a very simple rule to adopt could be to try to evaluate the cost (both
    in terms of time and complexity) of rewriting and refactoring code and choose
    the option that seems best to you. Note that I didn’t say “the option that costs
    less,” because it’s often an investment. Another useful thing could be to break
    down the part under examination into smaller parts (the good old “divide and conquer”)
    and choose to refactor (or rewrite) only that part, so as not to be “stuck” for
    too long.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to rewrite a piece of code, a module, or an entire component,
    let me give you a heartfelt piece of advice: don’t get too attached to what has
    already been done. Let me explain. Surely, it will be useful to try and understand
    what the code does and the individual steps that make up the logical flow. It
    will be equally useful to understand how users currently behave and which business
    cases are currently implemented. However, I have often found that what is currently
    present does not correspond to the real needs of users; perhaps it never did,
    or perhaps needs have changed over time. Perhaps half of that software is simply
    no longer needed. So, it’s fine to read what exists and try to rewrite it better
    or differently, but often this reverse-engineering process can be quite complicated,
    time-consuming, and, especially, error-prone. Instead, try to identify what users
    need, possibly with the help of the Product Owner (to know what a PO exactly is,
    you can refer to [https://www.scrum.org/resources/what-is-a-product-owner](https://www.scrum.org/resources/what-is-a-product-owner)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This may actually encounter some resistance, which depends on the mentality
    of the company you are working for. Many times, I have been told: It must have
    the same logic as before, but it must work better. This is obviously a great way
    to cover one’s back, but it almost never leads to effective results. It forces
    engineers to do huge reverse-engineering work, which in light of (often) changing
    user needs can be partially useless; it does not allow the team (both the so-called
    tech part and the so-called product part, assuming such differentiation makes
    sense) to focus on the importance of individual features, in order to prioritize
    activities and perhaps avoid unnecessary ones. So, I suggest you always start
    from the needs – from the why, before the how. Think about the goal before how
    to get there.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into the concept of refactoring and its elusive nature.
    It examines the underlying motivations for refactoring and offers insights into
    organizing effective refactoring sessions, as well as prioritizing different areas
    requiring attention in your code. Furthermore, it emphasizes the significance
    of integrating refactoring seamlessly into your regular activities. In conclusion,
    the chapter provides a comprehensive summary and presents a range of techniques
    to successfully incorporate refactoring into your professional routine.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will discuss a set of recommended practices that
    are considered “good habits” for software professionals to adopt in their work.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Martin Fowler*, *Refactoring*, *Addison-Wesley Professional*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do you prioritize which legacy code to refactor** **first?** [https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor](https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor vs. rewrite: Deciding what to do with problem** **software**: [https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software](https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Things You Should Never Do, Part** **I**: [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature Toggles (aka Feature** **Flags)**: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BranchByAbstraction**: [https://martinfowler.com/bliki/BranchByAbstraction.html](https://martinfowler.com/bliki/BranchByAbstraction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
