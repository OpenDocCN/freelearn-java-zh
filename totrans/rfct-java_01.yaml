- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What is Refactoring?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是重构？
- en: Picture this. It’s your first day at a new job, and you’re filled with excitement
    and eager to showcase your skills. Your new colleagues are enjoyable to be around,
    the company seems fine, and you’re itching to get started. Your “onboarding buddy”
    begins showing you the project that you’ll be working on for the next several
    months or even years. The concepts behind it are promising, and the business itself
    is stable. However, the code base is an enormous, chaotic mess—like a smoking,
    tangled plate of spaghetti. Well, perhaps you don’t need to imagine it. It’s likely
    you’ve been in that situation before. Maybe you’re even experiencing it right
    now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下。这是你在新工作的第一天，你充满了兴奋和渴望展示你的技能。你的新同事们很愉快相处，公司看起来也不错，你迫不及待地想要开始。你的“入职伙伴”开始向你展示你将在接下来的几个月甚至几年里工作的项目。其背后的概念很有前景，公司本身也很稳定。然而，代码库却是一个庞大而混乱的混乱——就像一团冒着烟的、纠缠在一起的意大利面。好吧，也许你不需要想象它。很可能你之前已经遇到过这种情况。也许你现在正经历着它。
- en: As soon as you open your IDE, you’re greeted with a plethora of modules with
    very similar names. Once you enter a module, you’re met with a daunting number
    of classes, some of which run hundreds of lines. These classes often house methods
    with vague names such as “`manageThis`” or “`processThat`,” and they tend to be
    burdened with an excessive number of parameters. Suffice it to say, this isn’t
    the most conducive environment for grasping the inner workings of your new project.
    Brace yourself for a few challenging weeks – or even months – of work, as the
    code base and architecture of the project are far from optimal. Lack of documentation
    or poor code commenting can make things even more challenging when dealing with
    existing code issues. However, if the code itself is well written and follows
    good architecture practices, it can compensate for the lack of documentation (which
    is definitely not something desirable) and minimize the need for excessive comments
    (we’ll delve into this in the book).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开你的集成开发环境（IDE）时，你会看到许多具有非常相似名称的模块。一旦你进入一个模块，你会遇到令人畏惧的大量类，其中一些类运行数百行。这些类通常包含具有模糊名称的方法，例如“`manageThis`”或“`processThat`”，并且它们往往带有过多的参数。简而言之，这不是一个有助于理解你新项目内部运作的环境。准备好迎接几周——甚至几个月——的挑战性工作，因为项目的代码库和架构远非最佳。缺乏文档或糟糕的代码注释在处理现有代码问题时会使事情更加困难。然而，如果代码本身写得很好，并且遵循良好的架构实践，它可以弥补文档的不足（这绝对不是什么可取之处）并最小化过度注释的需求（我们将在书中深入探讨这一点）。
- en: 'Let me be clear: it’s not about blaming. Every one of us – and by “us,” I mean
    a large group of people I could call “The Software Development Community” – has
    a slightly different way of solving the very same problem. And everyone, at least
    once in their lifetime, thought “I would have done it better.” But again, every
    one of us knows – or will know – that it’s a lot about circumstances. If a certain
    module or piece of code was completed quickly but poorly, it is likely because
    someone requested it to be completed quickly. Sometimes, we come across situations
    where contradictory requirements are given to us or when priorities change due
    to internal or external events that take place. This request may have been made
    due to a valid business reason, a critical security concern, or any other reason
    that they deemed important. No one is lazy; (almost) nobody works poorly. It’s
    just a matter of circumstances. We’ve all felt that pressure.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我明确一点：这并不是在责怪。我们中的每一个人——通过“我们”，我指的是一个我可能称之为“软件开发社区”的大群体——都有一种稍微不同的方式来解决同一个问题。每个人，至少在他们的一生中，都曾想过“我会做得更好”。但再次强调，我们中的每一个人都知道——或者将会知道——这很大程度上是关于环境。如果某个模块或代码片段完成得快但质量差，很可能是因为有人要求它快速完成。有时，我们会遇到有人给出相互矛盾的要求，或者由于内部或外部事件的发生而改变优先级。这个请求可能是因为一个有效的商业原因、一个关键的安全问题，或者他们认为重要的任何其他原因。没有人是懒惰的；（几乎）没有人工作得差。这只是环境问题。我们都感受到了那种压力。
- en: The techniques and concepts that fall under the broad umbrella of “refactoring”
    help prevent you from ending up in that situation, ensuring that your code doesn’t
    become that plate of spaghetti. These techniques, and, more importantly, the mindset
    associated with refactoring, can also assist you in improving the existing code
    base, gracefully navigating the swamp you find yourself in, without feeling overwhelmed.
    In this chapter, we will explore the meaning of refactoring and, in reality, how
    elusive it can be. I will try to narrate, also based on my experience, the motivations
    behind refactoring – motivations that will probably be familiar to you. I will
    then give you some advice on how to organize your refactoring sessions and how
    to prioritize the various parts that need to be fixed in your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 属于“重构”这一广泛范畴的技术和概念有助于防止你陷入那种情况，确保你的代码不会变成那盘意大利面。这些技术和，更重要的是，与重构相关的思维方式，还可以帮助你改进现有的代码库，优雅地应对你所面临的困境，而不会感到不知所措。在本章中，我们将探讨重构的含义，以及实际上它可能有多么难以捉摸。我将尝试根据我的经验，讲述重构背后的动机——这些动机可能对你来说很熟悉。然后，我将给你一些建议，关于如何组织你的重构会话以及如何优先处理代码中需要修复的各个部分。
- en: But let’s start slowly, trying to agree on what we mean by the term that gives
    the title to this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从慢一点开始，试图就本书标题所涉及的术语达成一致。
- en: 'In this chapter, we’ll cover these topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What do we mean by refactoring?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所说的重构是什么意思？
- en: Why you should consider refactoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该考虑重构
- en: When you should refactor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在何时重构
- en: What you should refactor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该重构什么
- en: What do we mean by refactoring?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们所说的重构是什么意思？
- en: If we should give a strict definition of refactoring, we could be in some trouble,
    because it is often interpreted in different ways. The most common meaning, anyway,
    is related to code rewriting. Code refactoring is the process of restructuring
    and improving existing code without changing its behavior. Code is rewritten so
    that it is easier to understand and easier to modify.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给重构下一个严格的定义，我们可能会遇到一些麻烦，因为它的含义经常被不同地解读。无论如何，最常见的含义与代码重写相关。代码重构是指在不改变其行为的前提下，对现有代码进行重构和改进的过程。代码被重写，以便更容易理解和修改。
- en: 'We could also give a “recursive” definition of refactoring: a series of refactorings
    applied to the software without changing its behavior.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给重构下一个“递归”的定义：一系列不改变软件行为的重构。
- en: 'Let me highlight this again because it’s very important: the software will
    return the very same results as before, no more and no less. It will just be written
    differently. The main (maybe the only) target you have to achieve is to make your
    code easier to understand, and this is one of the most important yet most difficult
    tasks to accomplish.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再强调一遍，因为这非常重要：软件将返回与之前完全相同的结果，不多也不少。它只是会被以不同的方式编写。你主要（也许唯一）要实现的目标是使你的代码更容易理解，而这是一项非常重要但难度很大的任务。
- en: Refactoring could also be bounded with another couple of concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重构也可以与另外几个概念相关联。
- en: It can be viewed as a way of iteratively improving the design of a software
    system. As the system evolves, its design can degrade and become outdated, leading
    to issues such as increased complexity, reduced maintainability, and reduced flexibility.
    Refactoring helps to address these issues by making incremental changes to the
    design of the system, improving its overall quality and maintainability. Moreover,
    refactoring can be used as a technique for discovering the underlying design of
    a system. By identifying patterns and commonalities in the code, developers can
    gain insights into the design of the system and identify areas for improvement.
    We’ll deepen this concept in the following paragraph.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被视为一种迭代改进软件系统设计的方式。随着系统的演变，其设计可能会退化并变得过时，导致诸如复杂性增加、可维护性降低和灵活性降低等问题。重构通过逐步改变系统的设计来帮助解决这些问题，从而提高其整体质量和可维护性。此外，重构还可以作为一种发现系统潜在设计的技术。通过识别代码中的模式和共性，开发者可以深入了解系统的设计，并确定改进的区域。我们将在下一段中深入探讨这一概念。
- en: Refactoring and clean code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构与清洁代码
- en: Refactoring is also closely tied to the concept of clean code. We’ll go into
    details in the next chapter, but we can briefly say that clean code refers to
    code that is easy to read, understand, and *maintain*. Refactoring is one of the
    primary ways in which developers can ensure that their code remains clean. By
    continuously improving the design of their code through refactoring, developers
    can eliminate code smells (a code smell is a sign of a potential problem in the
    source code – we’ll deep dive into this later on in the book) and improve the
    overall quality of the code base. Refactoring helps to keep the code base *maintainable*
    and extensible, reducing the risk of issues. Refactoring can help to ensure that
    the code base remains aligned with the principles of clean code. When your code
    is not clean enough – and we will see what this means in the following chapter
    – what you have to do is just stop and refactor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重构也与清洁代码的概念紧密相关。我们将在下一章详细介绍，但我们可以简要地说，清洁代码指的是易于阅读、理解和*维护*的代码。重构是开发者确保其代码保持清洁的主要方式之一。通过不断通过重构改进代码的设计，开发者可以消除代码异味（代码异味是源代码中潜在问题的迹象——我们将在本书稍后深入探讨这一点）并提高代码库的整体质量。重构有助于保持代码库的*可维护性和可扩展性*，降低问题的风险。重构有助于确保代码库与清洁代码的原则保持一致。当你的代码不够清洁时——我们将在下一章中看到这意味着什么——你所要做的就是停下来重构。
- en: Misconceptions about refactoring
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重构的误解
- en: There are various concepts that may resemble refactoring but are not synonymous
    with it. Exploring these concepts can contribute to a better comprehension of
    refactoring.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多概念可能类似于重构，但并不等同于重构。探索这些概念有助于更好地理解重构。
- en: Refactoring is not about optimization. However, refactored code could have better
    performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不是关于优化。然而，重构后的代码可能会有更好的性能。
- en: Let me explain a little bit better. The main purpose of refactoring is to make
    your code easier to read, not to – for instance – reduce its cyclomatic complexity.
    (Cyclomatic complexity is a way to measure how complex a program’s flow is. It
    counts the number of different paths or decision points in the code. The higher
    the complexity, the more complicated the code becomes. It’s a useful tool for
    gauging code maintainability and finding areas that could use some simplification
    or extra testing.) It’s quite the opposite! Improving your code’s performance
    will probably reduce its readability… and it’s OK because the purposes are different.
    Refactoring is one thing; improving performance is another. Nonetheless, it is
    also true that more readable code could be, in some cases, also more efficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更详细地解释一下。重构的主要目的是使你的代码更容易阅读，而不是——例如——减少其圈复杂度。（圈复杂度是一种衡量程序流程复杂度的方法。它计算代码中的不同路径或决策点的数量。复杂性越高，代码就越复杂。它是衡量代码可维护性和发现需要简化或额外测试的区域的有用工具。）这与目的正好相反！提高代码的性能可能会降低其可读性……但这没关系，因为目的不同。重构是一回事；提高性能是另一回事。尽管如此，这也意味着更易读的代码在某些情况下也可能是更高效的。
- en: Here’s a very simple example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的例子。
- en: 'Suppose you have this (very old-school) method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个这个（非常老式）的方法：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can easily see, this method just takes an array of `int` elements and
    sums them, scanning the array one element at a time. We could try to make this
    method faster, without changing its behavior, by writing the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很容易看到的，这个方法只是接受一个`int`元素的数组并将它们相加，逐个扫描数组中的元素。我们可以尝试通过编写以下代码来使这个方法更快，而不改变其行为：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The refactored method uses a `while` loop instead of a `for` loop and increments
    the loop counter by 2 in each iteration. This allows the method to process two
    elements of the array at a time, effectively reducing the number of iterations
    needed to sum the array. This is a bit more efficient, but it is not more readable
    for sure. We reached the goal of optimization, but we did not refactor the code.
    How could we reach both goals? For instance, using a plain, simple one-liner such
    as this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的方法使用`while`循环而不是`for`循环，并在每次迭代中增加循环计数器2。这使得方法能够一次处理数组中的两个元素，从而有效地减少了求和数组所需的迭代次数。这确实更有效率，但肯定不是更易读的。我们达到了优化的目标，但我们并没有重构代码。我们如何达到这两个目标呢？例如，使用一个简单的一行代码，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method uses the `IntStream` class from Java 8’s Stream API to perform a
    parallel sum operation on the elements of the array. The `parallel()` method enables
    parallel processing, allowing multiple threads to work on different portions of
    the array simultaneously. The `sum()` method then calculates the sum of all the
    elements in the array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用Java 8的Stream API中的`IntStream`类对数组的元素执行并行求和操作。`parallel()`方法启用并行处理，允许多个线程同时处理数组的不同部分。然后`sum()`方法计算数组中所有元素的总和。
- en: 'Refactoring is not “fixing bugs.” This is much like the matter of complexity
    we just saw: you could fix a bug by refactoring a piece of code but it would be
    almost accidental. Or, better, it would be like killing two birds with a stone:
    if you can fix a bug *and* refactor a piece of code, it’s a big win! But remember
    – it’s generally advised not to mix different code actions in a single code change,
    even though it frequently happens.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不是“修复bug”。这就像我们刚才看到的复杂性问题：你可以通过重构一段代码来修复一个bug，但这几乎是一个意外。或者，更好的说法是，这就像一石二鸟：如果你能修复一个bug并且重构一段代码，那将是一个巨大的胜利！但记住——通常建议不要在单个代码更改中混合不同的代码操作，尽管这经常发生。
- en: Refactoring can actually *help* you solve bugs, but we’ll see it later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重构实际上可以*帮助*你解决bug，但我们会稍后讨论。
- en: 'Most important, refactoring is not “adding features.” When you’re adding functions
    to your software, you should not change existing code, but just add capabilities.
    On the contrary, when you refactor, your northern star shouldn’t be to change
    the existing behavior. As a software professional, you will probably find yourself
    switching between these two aspects. The important thing is that you are aware
    of what you are doing: you structure the code better, then you add new functionality;
    once the new functionalities are tested and proven to be working, you can refactor
    again; and so on. It’s like you’re wearing two hats (using Kent Beck’s metaphor)
    and you keep swapping them: you can and you should, but remember which one you’re
    wearing at each moment.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，重构不是“添加功能”。当你向你的软件添加功能时，你不应该更改现有代码，而只是添加功能。相反，当你重构时，你的北极星不应该是为了改变现有的行为。作为一名软件专业人士，你可能会发现自己在这两个层面之间切换。重要的是你要意识到你在做什么：你更好地组织代码，然后添加新功能；一旦新功能经过测试并证明可以正常工作，你就可以再次重构；依此类推。这就像你戴着两顶帽子（使用Kent
    Beck的比喻）并且不断交换它们：你可以，你也应该，但记住你每次戴的是哪一顶。
- en: In certain situations, there might be pressure from the business to prioritize
    adding new features instead of allocating time for refactoring, which may be seen
    as having no immediate value or merely serving the IT department. As a result,
    attempting to incorporate refactoring tasks discreetly within feature releases
    can lead to a blurring of roles. This means that you are not maintaining separate
    focuses or responsibilities (you’re not *wearing two hats*), thus creating a mixture
    of objectives.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会来自业务的压力，要求优先考虑添加新功能而不是为重构分配时间，这可能被视为没有立即价值或仅仅服务于IT部门。因此，尝试在功能发布中秘密地整合重构任务可能会导致角色模糊。这意味着你并没有保持不同的焦点或责任（你不是*戴着两顶帽子*），从而产生目标混合。
- en: Now that we know, more or less, what refactoring means, we are ready to get
    the reasons behind it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对重构的含义有了更多或更少的了解，我们准备了解其背后的原因。
- en: Why you should consider refactoring
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你为什么应该考虑重构
- en: We just saw that refactoring is highly coupled with the concept of clean code.
    Hence, we could say that one of the most important outtakes of refactoring your
    code is to improve its readability. In other words, refactoring makes your code
    easier to understand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，重构与清洁代码的概念高度相关。因此，我们可以这样说，重构代码最重要的收获之一是提高其可读性。换句话说，重构使你的代码更容易理解。
- en: 'Even if the main goal of writing code is to tell a machine to do what you want,
    exactly the way you want it, it’s important to underline something that we tend
    to forget, sometimes: you have to be understood not only by computers, but first
    and foremost you have to be understood by human beings. And one of those human
    beings is you: your future self! In my experience, I’ve found myself a lot of
    times asking, “Why?!” looking at a piece of code I wrote, maybe just weeks before.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编写代码的主要目的是告诉机器按照你想要的方式执行你想要的操作，精确到每个细节，但有时我们容易忘记的是：你不仅要让计算机理解，首先你必须让人类理解，尤其是你未来的自己！在我的经验中，我发现自己很多次在看着自己可能只是几周前写的代码时，会问：“为什么？！”
- en: Although it may seem simple or even naive, the idea of writing readable code
    is often overlooked due to the urgency of making our programs work. While this
    is certainly important, we must also remember that a significant portion of our
    work as software professionals is devoted to maintenance. In my experience, the
    opportunity to start a project from scratch is rare; more often than not, we inherit
    code from someone else and must maintain or build upon it. By prioritizing readability,
    we can benefit in many ways.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能很简单甚至有些天真，但由于急于让我们的程序工作，编写可读代码的想法往往被忽视。虽然这确实很重要，但我们还必须记住，作为软件专业人士，我们工作中很大一部分是致力于维护。根据我的经验，从头开始一个项目的机会很少；大多数情况下，我们必须继承他人的代码并对其进行维护或扩展。通过优先考虑可读性，我们可以从许多方面受益。
- en: Although it’s important to write code that is easy to understand in the future,
    it’s also helpful to transform complex and unreadable code into clear and organized
    code. Just like Indiana Jones or Lara Croft, developers often have to delve deep
    into the projects they are working on to comprehend the intentions of their programmer
    ancestors. However, this can be significantly more challenging if the code is
    difficult to read. By refactoring the code, you can gain confidence in the functionality
    of the code you’ll be working with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写易于未来理解代码很重要，但将复杂且难以阅读的代码转换为清晰和有组织的代码也很有帮助。就像印第安纳·琼斯或劳拉·克劳馥一样，开发者经常需要深入他们正在工作的项目，以理解程序员祖先的意图。然而，如果代码难以阅读，这可能会变得更具挑战性。通过重构代码，你可以对自己的代码功能有信心。
- en: Another good reason for having readable code is when the code is intended to
    be open sourced. Whether it is due to a personal interest in collaborating with
    open source projects, a company’s approach or using it as a showcase for professional
    profile building, having readable code becomes even more crucial in these scenarios.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个拥有可读代码的好理由是当代码打算开源时。无论是由于对与开源项目协作的个人兴趣，还是公司的策略或将其用作专业形象展示，在这些情况下，拥有可读代码变得尤为重要。
- en: Another situation where readable code is valuable is when your code undergoes
    peer review or is used for training junior team members. In such cases, having
    code that is easy to follow and comprehend helps ensure effective collaboration
    and knowledge transfer within the team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可读代码有价值的情况是当你的代码接受同行评审或用于培训初级团队成员时。在这种情况下，拥有易于遵循和理解的代码有助于确保团队内部的有效协作和知识转移。
- en: I also like readable code because I have a very bad memory. I am unable to hold
    more than a certain amount of information in my head; actually, I don’t want it.
    There’s no need if you can retrieve the information by simply reading the code
    like it was a piece of prose. It’s not fair to expect my future self or colleagues
    to recall details that could easily be included in the code, such as why a particular
    approach was taken, why certain information was sourced from a particular location,
    or why one solution was chosen over another. One of the most frequent questions
    I ask myself when dealing with legacy code is, “Is this a mistake or is it intentional?”;
    readable code (coupled with the correct amount of tests, code comments, and coding
    standards, but we’ll see this later) is the right choice to remove doubts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我也喜欢可读的代码，因为我记忆力非常差。我无法在脑海中保留超过一定量的信息；实际上，我也不想这么做。如果你能像阅读散文一样简单地通过阅读代码来检索信息，那就没有必要了。要求我的未来自我或同事回忆那些可以轻易包含在代码中的细节是不公平的，比如为什么采取特定的方法，为什么从特定位置获取某些信息，或者为什么选择一个解决方案而不是另一个。当我处理遗留代码时，我最常问自己的问题是：“这是错误还是故意的？”；可读的代码（结合正确的测试量、代码注释和编码标准，但我们会稍后讨论）是消除疑虑的正确选择。
- en: 'There are many techniques to make the code more readable, and we will expand
    on them later in this book. There is something else I’d like to highlight first:
    readability can be something very subjective. What is readable for me may not
    be for my teammates. Some prefer one-liners, and others prefer to isolate a couple
    of lines in a single method. You may prefer to make explicit the type of every
    single variable; I prefer to use the `var` keyword. My suggestion is simple: talk
    to your teammates and agree on a trade-off. Remove from the discussion objective
    improvements (for example, using streams in place of classic loops) and agree
    on a general “code style” level (you could use a coding standard document or a
    unique formatter for your IDE, but we’ll deep dive into this later). It is important
    to keep the code consistent in all of the project classes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以使代码更易于阅读，我们将在本书的后面部分详细讨论它们。首先，我想强调的是：可读性可能是一个非常主观的东西。对我来说可读的，可能对我的队友来说不可读。有些人喜欢一行代码，而有些人喜欢在一个方法中隔离几行代码。你可能更喜欢明确每个变量的类型；我更喜欢使用`var`关键字。我的建议很简单：与你的队友交谈并达成妥协。从讨论中排除客观改进（例如，用流代替经典循环）并就一般的“代码风格”水平达成一致（你可以使用编码标准文档或为你的IDE使用独特的格式化工具，但我们将在后面深入探讨这个问题）。保持项目所有类中的代码一致性是很重要的。
- en: Improving the design of your software
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进你的软件设计
- en: 'Refactoring helps you improve the design of your software. If you don’t do
    it, the design will (not so slowly) decay; it will be more difficult to understand,
    for instance, where to put new features or how to implement them. Refactoring
    is like “tidying up” your project once a new functionality is guaranteed. If you
    don’t do it, you will probably fall into pitfalls, one of which is, the ancient
    monster that lies in almost every software company. Reducing duplicated code is
    not just a matter of “doing things properly” (even if doing things properly should
    be the norm) but has a direct benefit: when you have to modify that code, you
    will modify it only once. Believe me when I say that this very basic concept is
    not always respected. I will quote Martin Fowler here, in his book *Refactoring:
    Improving the Design of Existing Code*: “*By eliminating the duplicates, you ensure
    that the code says everything once and only once, which is the essence of* *good
    design.*”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重构有助于你改进软件的设计。如果你不这么做，设计将会（不会太慢地）退化；例如，将新功能放在哪里或如何实现它们将变得更加困难。重构就像在确保了新功能后对项目进行一次“整理”。如果你不这么做，你可能会陷入陷阱，其中之一就是几乎每个软件公司都存在的古老怪物。减少重复代码不仅仅是“正确做事”的问题（即使正确做事应该是规范），但它有一个直接的好处：当你必须修改那段代码时，你只需修改一次。当我说这个非常基本的概念并不总是受到尊重时，请相信我。在这里，我将引用马丁·福勒在其著作《重构：现有代码的设计改进》中的一段话：“通过消除重复，你确保代码只说一次，并且只说一次，这是良好设计的本质。”
- en: 'If code is poorly designed or implemented, you’ll have to do extra work to
    add functionalities, fix bugs, or improve performance: that extra work is due
    to something called **technical debt**. Technical debt happens when you prioritize
    speed over long-term benefits in your design or implementation choices. Just like
    a loan, it accumulates interest over time, making it harder to maintain and improve
    the software later. Constant refactoring improves design and quality; a better
    design reduces technical debt.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码设计或实现得不好，你将不得不做额外的工作来添加功能、修复错误或提高性能：这额外的工作是由于所谓的**技术债务**。技术债务发生在你在设计或实现选择中优先考虑速度而不是长期利益时。就像贷款一样，它会随着时间的推移积累利息，使得以后维护和改进软件变得更加困难。持续的重构可以改进设计和质量；更好的设计可以减少技术债务。
- en: Maintainability and scalability
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性和可扩展性
- en: 'As we said before, software development is a lot about maintainability. If
    refactoring helps you keep a good design, that is a clear understanding of what
    each piece of code does and where to put any new code. In a situation such as
    this, maintainability is facilitated: by improving code organization and structure,
    it becomes easier to identify and fix issues or add new features over time. If
    you take care of your software and refactor when you think it’s necessary (see
    the next subsection), the consequent good design will help you to scale your code.
    While improving performance isn’t the main reason for refactoring, it often ends
    up being a nice bonus. If a certain functionality is properly isolated, for instance,
    it will be likely easier to parallelize it or to remove it and put it in another
    service, using a remote call to retrieve information from it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Understanding, avoiding, and fixing bugs
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good design means that each part of your code does one thing, and it does it
    well. But things can go bananas, sometimes; bugs are just around the corner. One
    of the first things to do when you fight against a bug is to understand what’s
    happening and where. Refactoring helps to understand the code (because you have
    to rewrite or restructure it a little bit without changing the external behavior),
    and thus you get to know the code better. If you know and understand your code,
    it will be faster to spot bugs or implement fixes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you some advice: try to avoid having “restricted areas” in projects
    you’re working on. In this case, a restricted area refers to a library, module,
    or another part of your code base that you rely on and understand its purpose,
    but you’re afraid to touch because it’s really fragile. You know what it does,
    but not exactly how it does it. It’s like a big mess that no one in your company
    wants to deal with. The more complex and old the system is, and the more people
    have worked on it, the harder it becomes to understand the code base. Sometimes
    these restricted areas are unavoidable, especially if the previous developers
    didn’t leave any documentation. It’s not a big deal if you have some of these
    areas, but it’s best to minimize them as much as possible. Refactoring can help,
    but there are certain conditions that need to be met, such as having good test
    coverage (but we can talk about that later).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Faster development
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the previous considerations bring us to one, big deal: refactoring helps
    to do things faster. It may sound a bit counterintuitive, but if you think about
    it a little bit, it becomes crystal clear. Having well-designed, bug-free, understandable
    software means keeping good quality software. And of course, the main goal of
    having high-quality software is to add functionality faster, to scale it quickly,
    and to fix bugs in the blink of an eye.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that writing software is a craft. As software developers, we are
    like artisans who shape and mold our applications and engineer and assemble our
    services. Even though we don’t use physical tools such as hammers and wrenches,
    we are still artisans. The main difference is that what we create is flexible
    and adaptable. We have the ability to revisit our work, improve upon it, and make
    it more receptive to change. By doing so, we can establish a solid foundation
    to build upon whenever we need to expand our work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编写软件是一门手艺。作为软件开发者，我们就像工匠，塑造和塑造我们的应用程序，设计和组装我们的服务。尽管我们不使用像锤子和扳手这样的物理工具，但我们仍然是工匠。主要区别在于我们创造的是灵活和适应性强的。我们有能力回顾我们的工作，对其进行改进，并使其更容易适应变化。通过这样做，我们可以在需要扩展我们的工作时，建立一个坚实的基础。
- en: If there is no proper design, engineering tasks turn into an endless cycle of
    quick fixes and hacks. If you continue to approach projects in this way, relying
    on one temporary solution after another, it is only a matter of time before the
    project becomes unmanageable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的设计，工程任务就会变成一个无休止的快速修复和黑客攻击的循环。如果你继续以这种方式处理项目，依赖一个又一个的临时解决方案，那么项目变得难以管理只是时间问题。
- en: If your manager is more focused on schedules and timelines rather than technical
    aspects or quality in general (yes – that can happen), highlighting faster development
    as a key benefit of refactoring can be a compelling selling point.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的经理更关注进度和截止日期，而不是技术方面或整体质量（是的，这种情况可能发生），强调重构可以加快开发速度作为关键优势，可以成为一个有说服力的卖点。
- en: When you should refactor
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该在何时重构
- en: At this point, we have a clear understanding of what refactoring is and why
    it holds such significant importance or, I would even go as far as to say, it
    is crucial in our daily work. You may be wondering when is the appropriate time
    to engage in this activity. There are several factors to consider when deciding
    on the timing of refactoring. It is no secret that refactoring can be time-consuming,
    so how can we effectively incorporate it into our workflow? When is the optimal
    time to execute this activity?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对重构有了清晰的理解，以及为什么它具有如此重大的重要性，或者我甚至可以说，它在我们的日常工作中至关重要。你可能想知道何时是进行这项活动的适当时间。在决定重构的时间时，需要考虑几个因素。重构可能会消耗时间，这是众所周知的，那么我们如何有效地将其融入我们的工作流程中？执行这项活动的最佳时间是什么时候？
- en: 'Let me start with some fundamental advice based on our experience: it’s always
    a good idea to do some minor refactoring whenever you have the chance, even if
    it means integrating it into your current task. For example, while running tests
    or performing static code analysis, you might come across a variable named *x*.
    That name doesn’t convey much meaning, does it? So, you’ll spend some time trying
    to figure out what that variable represents, only to discover that it contains
    a user’s name. You went through the trouble of deciphering it, but why should
    others have to do the same thing? Why should you have to go through the same hassle
    3 weeks later when you revisit the code? Just take a moment to rename the variable
    `username`. It’s a simple and almost effortless task (your IDE can do that) that
    can save others time and effort. I try to maintain this mindset at all times,
    which aligns with my “lazy” attitude of achieving maximum results with minimal
    effort.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从一些基于我们经验的基本建议开始：每次有机会时，做一些小的重构总是一个好主意，即使这意味着将其整合到你的当前任务中。例如，在运行测试或执行静态代码分析时，你可能会遇到一个名为
    *x* 的变量。这个名字并没有传达太多意义，对吧？所以，你可能会花一些时间去试图弄清楚这个变量代表什么，结果发现它包含了一个用户的姓名。你费了很大劲去解读它，但为什么别人也要做同样的事情？为什么你3周后再次查看代码时还要经历同样的麻烦？只需花一点时间将变量重命名为
    `username`。这是一个简单且几乎不费力的任务（你的IDE可以做到这一点），可以节省他人的时间和精力。我总是试图保持这种心态，这与我“懒惰”的态度相符，即以最小的努力实现最大的成果。
- en: The “Rule of Three”
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “三法则”
- en: The **Rule of Three** suggests that code should not be duplicated more than
    twice and that once duplication occurs for the third time, it should be extracted
    into a reusable module or function. It is unclear who originally stated this principle
    as it has been widely used and adapted by various software developers and teams
    over the years (it was popularized by Martin Fowler, who credits it to Don Roberts).
    A more effective way to state the same is *three strikes and* *you refactor*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory refactoring for smooth feature implementation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When adding a new feature to your code base, it is often helpful to engage
    in **preparatory refactoring**. This means taking the time to analyze parts of
    your code base that will be affected by the new feature and making necessary changes
    beforehand. I’ll borrow Martin Fowler’s excellent analogy for preparatory refactoring:
    it’s like taping off electrical sockets, door frames, and skirting boards when
    painting a wall. The taping itself isn’t painting, but it makes the painting process
    quicker and easier.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: During the analysis phase of preparatory refactoring, you may notice areas where
    a small change in the code could lead to significant improvements in speed or
    efficiency. For example, you may realize that using a method parameter instead
    of a literal or a class hierarchy instead of a `switch` statement would improve
    the flexibility and adaptability of your code. By making these changes through
    refactoring, you can make your code more open to change in the future and ultimately
    make development easier overall.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for bug fixing
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often overlooked, but fixing a bug can present a great opportunity for
    a refactor. This is because a significant portion of bug-fixing-related refactoring
    is aimed at improving the readability of your code. By making your code more understandable,
    you can identify the root cause of the bug sooner and fix it more efficiently.
    The bug had been present all along, but it went unnoticed due to the lack of readability
    in your code. So, it’s always a good practice to take the time to refactor when
    fixing bugs to prevent them from happening again in the future.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me be a bit clearer here: refactoring and bug fixing are two different
    things. It’s important to fix the bug first and then focus on improving the code.
    They may be related but separate steps, and one doesn’t automatically include
    the other.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Comprehension refactoring
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don’t need a bug to make your code cleaner and more understandable; you
    can refactor your code while trying to understand it or – we all have been there
    – remember what you were trying to do 2 months ago. I will repeat this concept
    several times because I think it’s one of the most important in our job: writing
    code is not only talking to a set of machines; it is more about talking to our
    future selves and our colleagues. Martin Fowler refers to this technique as **comprehension
    refactoring**. The idea can be likened to organizing one’s wardrobe, where the
    goal is to have a clear and complete view of all available clothing options to
    select the best-fitting outfit. In the same way, comprehension refactoring involves
    streamlining code to improve its readability and comprehensibility.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The “Boy Scout Rule”
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And then comes one of my favorite concepts related to software engineering,
    which is borrowed from the camping world and should also be applied in real life.
    Leave code better than you found it; at least, leave it as clean as it was. Do
    not leave it worse. Just like when you go camping or you picnic on a green field,
    you must think that that green field is not yours – you’re just borrowing it;
    do not leave your trash. If you find some trash, take some time to pick it up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our world, if you find some code that is – let’s say – understandable
    but that you think could work better (for instance, parametrizing a function or
    using another library method with a better signature), just do not ignore the
    problem and fix it. Pick up that small amount of trash you found along your path.
    At the same time, remember that you were doing something else; your task was not
    to pick up the trash but to enjoy your day in the open air (just to continue this
    joyful metaphor). So, find a trade-off between your actual task and this litter-picking
    refactoring; something I found useful, sometimes, is just to keep note that someone
    will have to clean that piece of code: how you do it (a Jira task, a `git pull`
    request, a Post-it on your monitor) depends on how your team works. But this is
    the kind of small-step refactoring that you will find very useful and, I would
    say, almost mind-changing.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Planned refactoring
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this time, it could seem that refactoring must be an activity included in
    your software developer routine, something “opportunistic;” and of course it is.
    You should refactor code as part of your daily activity. Writing software can
    be seen as adding functionalities upon functionalities, resulting in a never-ending
    stack of features and, thus, code modules, but developers know that most of the
    time it’s easier just to change existing code to add a new feature. You should
    never think about software as “done;” it is alive, and it is ever-changing. The
    moment software stays the same for too much time, there’s probably a problem:
    it could be too hard to change or to extend (not enough refactoring has been done),
    or maybe it has been replaced by something else (and so, my advice is… dismiss
    it).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'What I’m trying to say here is that it is not always possible to write excellent
    code on the first try; sometimes you have to stop, rewatch what you’ve done, and…
    try to do it better. Sometimes, you’ll even have to plan to refactor because you
    understand that changes are too hard to make on the existing code base; the concept
    is similar to the preparatory refactoring we mentioned before, but it is like
    a level up because you plan the refactoring. You should do it rarely, because
    this means that you didn’t include small refactorings into your daily activity,
    but it can happen. In this case, plan with attention: sometimes it could be better,
    for instance, to use separate branches or commits for new features and refactorings;
    someone else says that this would separate the refactoring from its purpose. I
    don’t really have a suggestion here: just do what fits best for your team.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Long-term refactoring and “Branch by Abstraction”
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although most refactoring tasks can be completed in just a few minutes or hours,
    certain activities may require several weeks of effort to complete. These typically
    include tasks such as isolating specific logic into a separate component or replacing
    one library with another. To address these more complex tasks, it can be helpful
    for a team to establish a practice of performing refactoring whenever they approach
    a “danger zone” that has been identified as in need of improvement. One useful
    technique for achieving this is called **Branch by Abstraction**, which can be
    used to change a library or service call in a gradual and controlled manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Branch by Abstraction consists of five phases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to replace the outdated `FaultyPay` payment service that
    you integrated into your system several years ago. Naturally, you don’t want to
    cause your customers any problems or inconvenience during the transition process.
    Here, you can see that there is a call and response between the client code and
    `FaultyPay` service:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response](img/B20912_01_1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'After you identified the service you want to replace, you build an abstraction
    layer to allow continued communication between the systems that are being replaced
    and the entities requesting that service. This abstraction layer acts as a contract,
    exposing functionality while concealing the implementation details:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – An abstraction layer, often represented by a Java interface,
    is inserted between the client code and the component that needs to be eliminated](img/B20912_01_2.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – An abstraction layer, often represented by a Java interface, is
    inserted between the client code and the component that needs to be eliminated
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, start replacing the legacy system by systematically building the replacement
    system (we’ll call it `ShinyPay`) and gradually integrating each rebuilt feature
    into the abstraction layer as they are completed. It is important to keep in mind
    that during this process, all traffic – both from the new and the old system –
    will be passing through the abstraction layer. It is also important to note that
    you could also choose (if this is possible – it is not always) to migrate one
    function at a time:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer](img/B20912_01_3.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction layer can also be used to fine-tune the service, such as directing
    only a portion of the traffic or specific features to the new component (feature
    toggle). It could also be possible to migrate one method at a time. It is important
    to ensure that both the legacy and the new system adhere to the same contract.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the code in the old system (`FaultyPay`, in our example) becomes
    obsolete, so you can delete it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The previous implementation (FaultyPay) is disconnected from
    the system; all traffic and functionalities are now exclusively directed toward
    the new implementation (ShinyPay)](img/B20912_01_4.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – The previous implementation (FaultyPay) is disconnected from the
    system; all traffic and functionalities are now exclusively directed toward the
    new implementation (ShinyPay)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the legacy code has been removed, you have the option to dismantle
    the abstraction layer. Alternatively, you may choose to retain this layer for
    the purpose of extensibility or future-proofing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)](img/B20912_01_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has several obvious advantages. Apart from the primary advantage
    of enabling seamless migration of large features in continuous integration, there
    are several additional benefits of using the Branch by Abstraction technique:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The release schedule is completely independent of architectural changes, making
    it easy and cost-effective to pause and resume the migration process as needed.
    This is because the new implementation is safeguarded by the system, allowing
    for quick adaptation to urgent requests or priority features from the leadership
    team or customer service department or to fix bugs. In contrast, when using a
    standard feature branch, it can be more challenging to resume a migration that
    has been paused.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The potential for merge conflicts is also limited to the abstraction layer only,
    which can significantly reduce the scope of conflicts that may arise. Without
    the abstraction layer, a code base refactor sitting in a feature branch for an
    extended period could generate a wide range of merge conflicts that might be difficult
    to resolve completely.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of switching completely to the new system, you could choose to turn
    new features on and off when you need to. These “specific switches” are called
    **feature toggles**. A feature toggle, also known as a feature flag or feature
    switch, is a technique that allows developers to enable or disable specific features
    or functionality in an application, at runtime and without modifying the code
    base. By using feature toggles, developers can release new features to a subset
    of users, test them in production environments, or enable/disable features based
    on certain conditions or user segments. This approach provides flexibility, allows
    for gradual rollouts, and reduces risk associated with deploying new features.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring in a code review
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **code review** is a process of reviewing the source code. It is usually done
    by other developers or peers who are more or less familiar with the programming
    language and the project’s requirements. We'll cover code reviews in detail in
    [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a code review is to ensure that the code is written in a clear,
    concise, and efficient manner and that it meets the project’s requirements and
    coding standards. Code reviews can help to identify and fix potential bugs or
    security issues, as well as improve the overall quality and maintainability of
    the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: During a code review, the reviewer examines the code line by line and provides
    feedback on issues such as code structure, syntax errors, performance, and readability.
    The review may also involve discussions and suggestions for improvement, as well
    as questions and clarifications about the code’s functionality and design. Code
    reviews are an important part of the software development process and are typically
    conducted before the code is merged into the main code base or released to customers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler suggests that code reviews are a great time to do some refactoring.
    If you want to understand someone else’s code (as we’ve already said), the best
    way is to refactor it. Otherwise, you might only get bits and pieces of it and
    give vague feedback. Refactoring helps you get a clearer picture. By the way,
    there’s something called **pair programming** (and something called **mob programming**)
    that takes code review to the next level. We’ll talk about it more in this book
    later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: What you should refactor
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in my career, we've come across situations where I wanted to make
    changes to different parts of my project. Maybe there was something that wasn’t
    working properly or something that I didn’t fully understand, or simply something
    that could be improved. It’s important to decide which parts to focus on and prioritize.
    And in some cases, it might even be better to leave things as they are and not
    make any changes at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There’s no hard and fast rule when it comes to refactoring, but with a little
    thought, you can come up with a solid plan that meets your specific needs. Remember
    – in our profession and in life, we often have to make compromises.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, I came across a helpful concept in Gary Keller’s book, *The One Thing*
    (*Bard Press*, *2013*). While it’s not specifically related to software development,
    it can be applied to our needs. The idea is this: “What’s the one thing you can
    do, such that by doing it, everything else will be easier or unnecessary?” While
    this is a broad question with many implications that we can’t discuss here, it
    can be a useful starting point for deciding what to do with our code base. This
    approach is super helpful when it comes to refactoring code. So, when you’re starting
    a new task or feature, take a look at your code and ask yourself if there’s anything
    that, if improved, would make the rest of the project work a lot easier or completely
    unnecessary.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is focused on what you can do, which forces you to think in actionable
    terms. It’s not about what you would do if certain conditions were met, but rather
    what you’re capable of doing right now. By identifying the one thing that can
    make everything else easier or unnecessary, we can focus our efforts on the most
    critical task at hand. It’s like distilling the essence of our job down to its
    core: doing the minimum necessary to achieve the maximum impact. This approach
    can be particularly valuable in software development, where there are often many
    different areas that could benefit from refactoring or improvement, but we need
    to prioritize and focus our efforts to achieve the greatest impact.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you an example to illustrate this point. Picture yourself working
    at a travel company that’s doing well, but facing challenges in handling a complex
    ecosystem with multiple travel providers and their solutions. The trouble is,
    there’s some outdated code causing problems, and the booking process occasionally
    fails. The system technically works without any bugs, but it’s outdated, difficult
    to maintain, lacks proper documentation (in one word: its *legacy*), and definitely
    not ready to handle the expected surge in traffic. We really need to refactor
    it, or else the company won’t be able to handle all the upcoming new customers.
    Meanwhile, there’s an internal team responsible for managing website content,
    and they’re struggling with a tool they only use twice a month. It’s incredibly
    confusing and impractical, making even simple tasks time-consuming. We absolutely
    have to refactor that tool to make it more user-friendly for the team. While both
    issues are important, it’s clear that the first problem with the legacy code and
    booking process should be addressed first, because travel booking is the core
    business of the company and because those people would be free to deal with something
    else.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Anyways, let’s face it – refactoring legacy code can be overwhelming, especially
    when you’re pressed for time and resources. While “the one thing” rule is a fantastic
    approach, it’s also pretty broad. So, let me show you something more precise that
    can help you decide which parts of the code base require your attention the most.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Impact analysis
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Impact analysis** is like detective work in software refactoring. It’s all
    about figuring out how changes to one part of the code base will affect other
    parts of the system.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: So, first, the developers identify code modules that need to be refactored or
    updated. Then, they investigate the connections and relationships between these
    modules and other parts of the software, such as external libraries, user interfaces,
    and interfaces.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these dependencies, the developers can get a good sense of
    how changes will ripple through the system. They can pinpoint areas that might
    be particularly tricky to change and take steps to reduce the chances of bugs
    or other issues cropping up.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Basically, impact analysis is a crucial tool in the software refactoring toolkit.
    It helps developers make changes in a more thoughtful and careful way so that
    the code remains stable and easy to maintain in the long run.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an impact analysis involves thoroughly assessing the potential effects
    of making changes to a system or project. Here’s a breakdown of the steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation**: Define the change, clearly stating what you want to do. Collect
    data about the proposed change.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify affected areas and dependencies**: Brainstorm which parts of the
    system will be impacted by the change and how the change will affect other components
    in the system.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify affected elements in each area**: Evaluate how the change will impact
    functionality, performance, security, and other aspects. Identify potential risks
    and problems that could arise from the change.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluate**: Conducting an evaluation, the team identifies both positive and
    negative impacts of the proposed change.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deal with negative consequences**: With a clearer understanding of the negative
    impacts, the team can now focus on addressing them. They have the opportunity
    to consult with team members and stakeholders to discuss whether the change should
    proceed or not. Additionally, conducting regression testing becomes crucial in
    this scenario.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Risk assessment
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Risk assessment** is a fancy way of saying “figuring out what could go wrong.”
    In software refactoring, it’s all about taking a hard look at the code base and
    identifying potential risks before making changes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: When assessing risk, developers consider a range of factors, including the complexity
    of the code, the likelihood of introducing bugs, and the potential impact of any
    issues that might arise. There may be impacts on data (some pieces of code are
    maybe dealing with crucial information such as personal or financial data), possible
    downtimes (some pieces of code, in case of issues, may bring down the entire system
    or some core functionalities), business issues (pieces of code that if broken
    could cause financial issues or contract infringements), or security breaches.
    They may also look at the time and resources available for the refactoring project
    and the potential impact on users and stakeholders.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Once risks have been identified, developers can take steps to mitigate them.
    For example, they might create test cases to ensure that the refactored code works
    as expected, or they might make changes in small increments to reduce the chances
    of something going wrong. We will talk more deeply about test coverage later in
    this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Overall, risk assessment is an important part of software refactoring because
    it helps developers make informed decisions about how to proceed. By taking the
    time to consider potential risks and plan accordingly, they can ensure that the
    refactoring project is successful and that the code base remains stable and maintainable
    over time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Value estimation
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Value estimation** in software refactoring is all about figuring out whether
    a particular refactoring project is worth the time and resources required to complete
    it.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: When estimating value, developers consider a variety of factors, such as the
    current state of the code base, the potential benefits of the refactoring, and
    the potential costs and risks involved. They might also take into account factors
    such as user feedback, performance metrics, and the needs of stakeholders.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Once the potential value of a refactoring project has been estimated, developers
    can decide whether it makes sense to move forward. In some cases, the potential
    benefits might not outweigh the costs, and the project may be shelved or postponed.
    In other cases, the benefits may be significant enough to justify the investment,
    and the project may move forward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Value estimation is an important part of software refactoring because it helps
    developers prioritize their efforts and make strategic decisions about how to
    allocate resources. By focusing on projects with high potential value and avoiding
    those with lower potential value, developers can ensure that they are making the
    most efficient use of their time and resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Prioritization matrix
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **prioritization matrix** (also known as the **Eisenhower Matrix**) is a tool
    used in software refactoring to help developers prioritize their efforts and make
    informed decisions about which refactoring projects to tackle first. It typically
    involves a matrix with two axes, one representing the level of urgency given to
    a project and the other representing the potential impact on the system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Each project is evaluated based on these two factors and then plotted on the
    matrix accordingly. Projects that require the least effort and have the greatest
    potential impact are considered the highest priority, while those that require
    more effort and have a lower potential impact are considered lower priority.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a prioritization matrix can help developers make strategic decisions
    about which projects to tackle first, based on the potential benefits and costs
    of each project. By focusing on the highest priority projects first, developers
    can make the most efficient use of their time and resources, and ensure that they
    are addressing the most critical issues in the code base:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – You should put your activities in a prioritization matrix in
    order to choose the right priority for execution](img/B20912_01_6.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – You should put your activities in a prioritization matrix in order
    to choose the right priority for execution
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The higher priority should be assigned to activities that have high urgency
    and impact. Lower priority (or no importance at all) should be given to activities
    that are not urgent and will have no impact.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Further considerations
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s more to think about when it comes to refactoring. I’ll jot it down here
    just to cover all our bases, but honestly, it might be a bit beyond the scope
    of this chapter. Once you’ve figured out which parts of your code base to prioritize
    for refactoring, the next step is to create a detailed plan that includes the
    scope, goals, steps, and timeline for the project. It’s also crucial to communicate
    this plan to everyone involved, such as your team, manager, clients, and users.
    You need to explain why you’re refactoring, what you’ll be doing, how you’ll be
    doing it, and when it’ll be done. It’s important to set clear expectations and
    manage them throughout the refactoring process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to execute the plan with discipline and diligence. Stick to
    best practices such as making small and frequent changes, running tests before
    and after each change, committing and documenting each change, and reviewing and
    verifying each change. Keep an eye on how the refactoring is affecting things
    such as code quality, system performance, and user feedback. Measure the outcomes
    and compare them with your goals and expectations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Refactor or rewrite?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various opinions on this matter, which I have observed to be a common
    source of disputes among teammates and colleagues. The truth is there is no simple
    answer. It’s just one of those things where there are a ton of conflicting opinions
    out there, and it’s tough to figure out what to believe. But I’ll do my best to
    share some of those opinions with you and offer up some advice, for whatever it’s
    worth.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: There are situations when it’s simply not justifiable to refactor your code.
    Perhaps it’s plagued with too many bugs, the design is overly complicated, and
    comprehending it is nearly impossible. Going through it’s like trying to solve
    the Rubik’s Cube blindfolded – or, quoting a former colleague of mine, like counting
    money with a fan blowing nearby. In such cases, rewriting it from the ground up
    may be the better option, and it’s something that many software developers find
    enjoyable. After all, it’s often more comfortable to create something new than
    to take small, incremental steps that are still tied to what was previously done.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we often fall into the trap of wanting to rewrite everything,
    thinking that what’s already there is terrible, when in reality, we may not have
    put in the effort to fully understand it. It’s important to remember one of the
    fundamental rules of programming, according to American developer Joel Spolsky:
    *it’s harder to read code than to write it*. Let’s not immediately denigrate the
    legacy code we come across in our code bases, which typically wasn’t written by
    us (our own code is, of course, beautiful). Legacy code has a history; it has
    been thoroughly tested and integrated with all necessary use cases and has often
    demonstrated good performance. We should respect legacy code.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: It’s a really complicated decision, and as I said, there’s no general rule.
    Perhaps, a very simple rule to adopt could be to try to evaluate the cost (both
    in terms of time and complexity) of rewriting and refactoring code and choose
    the option that seems best to you. Note that I didn’t say “the option that costs
    less,” because it’s often an investment. Another useful thing could be to break
    down the part under examination into smaller parts (the good old “divide and conquer”)
    and choose to refactor (or rewrite) only that part, so as not to be “stuck” for
    too long.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to rewrite a piece of code, a module, or an entire component,
    let me give you a heartfelt piece of advice: don’t get too attached to what has
    already been done. Let me explain. Surely, it will be useful to try and understand
    what the code does and the individual steps that make up the logical flow. It
    will be equally useful to understand how users currently behave and which business
    cases are currently implemented. However, I have often found that what is currently
    present does not correspond to the real needs of users; perhaps it never did,
    or perhaps needs have changed over time. Perhaps half of that software is simply
    no longer needed. So, it’s fine to read what exists and try to rewrite it better
    or differently, but often this reverse-engineering process can be quite complicated,
    time-consuming, and, especially, error-prone. Instead, try to identify what users
    need, possibly with the help of the Product Owner (to know what a PO exactly is,
    you can refer to [https://www.scrum.org/resources/what-is-a-product-owner](https://www.scrum.org/resources/what-is-a-product-owner)).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'This may actually encounter some resistance, which depends on the mentality
    of the company you are working for. Many times, I have been told: It must have
    the same logic as before, but it must work better. This is obviously a great way
    to cover one’s back, but it almost never leads to effective results. It forces
    engineers to do huge reverse-engineering work, which in light of (often) changing
    user needs can be partially useless; it does not allow the team (both the so-called
    tech part and the so-called product part, assuming such differentiation makes
    sense) to focus on the importance of individual features, in order to prioritize
    activities and perhaps avoid unnecessary ones. So, I suggest you always start
    from the needs – from the why, before the how. Think about the goal before how
    to get there.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into the concept of refactoring and its elusive nature.
    It examines the underlying motivations for refactoring and offers insights into
    organizing effective refactoring sessions, as well as prioritizing different areas
    requiring attention in your code. Furthermore, it emphasizes the significance
    of integrating refactoring seamlessly into your regular activities. In conclusion,
    the chapter provides a comprehensive summary and presents a range of techniques
    to successfully incorporate refactoring into your professional routine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will discuss a set of recommended practices that
    are considered “good habits” for software professionals to adopt in their work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Martin Fowler*, *Refactoring*, *Addison-Wesley Professional*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do you prioritize which legacy code to refactor** **first?** [https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor](https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor vs. rewrite: Deciding what to do with problem** **software**: [https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software](https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Things You Should Never Do, Part** **I**: [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature Toggles (aka Feature** **Flags)**: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BranchByAbstraction**: [https://martinfowler.com/bliki/BranchByAbstraction.html](https://martinfowler.com/bliki/BranchByAbstraction.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
