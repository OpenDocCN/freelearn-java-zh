- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What is Refactoring?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是重构？
- en: Picture this. It’s your first day at a new job, and you’re filled with excitement
    and eager to showcase your skills. Your new colleagues are enjoyable to be around,
    the company seems fine, and you’re itching to get started. Your “onboarding buddy”
    begins showing you the project that you’ll be working on for the next several
    months or even years. The concepts behind it are promising, and the business itself
    is stable. However, the code base is an enormous, chaotic mess—like a smoking,
    tangled plate of spaghetti. Well, perhaps you don’t need to imagine it. It’s likely
    you’ve been in that situation before. Maybe you’re even experiencing it right
    now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下。这是你在新工作的第一天，你充满了兴奋和渴望展示你的技能。你的新同事们很愉快相处，公司看起来也不错，你迫不及待地想要开始。你的“入职伙伴”开始向你展示你将在接下来的几个月甚至几年里工作的项目。其背后的概念很有前景，公司本身也很稳定。然而，代码库却是一个庞大而混乱的混乱——就像一团冒着烟的、纠缠在一起的意大利面。好吧，也许你不需要想象它。很可能你之前已经遇到过这种情况。也许你现在正经历着它。
- en: As soon as you open your IDE, you’re greeted with a plethora of modules with
    very similar names. Once you enter a module, you’re met with a daunting number
    of classes, some of which run hundreds of lines. These classes often house methods
    with vague names such as “`manageThis`” or “`processThat`,” and they tend to be
    burdened with an excessive number of parameters. Suffice it to say, this isn’t
    the most conducive environment for grasping the inner workings of your new project.
    Brace yourself for a few challenging weeks – or even months – of work, as the
    code base and architecture of the project are far from optimal. Lack of documentation
    or poor code commenting can make things even more challenging when dealing with
    existing code issues. However, if the code itself is well written and follows
    good architecture practices, it can compensate for the lack of documentation (which
    is definitely not something desirable) and minimize the need for excessive comments
    (we’ll delve into this in the book).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开你的集成开发环境（IDE）时，你会看到许多具有非常相似名称的模块。一旦你进入一个模块，你会遇到令人畏惧的大量类，其中一些类运行数百行。这些类通常包含具有模糊名称的方法，例如“`manageThis`”或“`processThat`”，并且它们往往带有过多的参数。简而言之，这不是一个有助于理解你新项目内部运作的环境。准备好迎接几周——甚至几个月——的挑战性工作，因为项目的代码库和架构远非最佳。缺乏文档或糟糕的代码注释在处理现有代码问题时会使事情更加困难。然而，如果代码本身写得很好，并且遵循良好的架构实践，它可以弥补文档的不足（这绝对不是什么可取之处）并最小化过度注释的需求（我们将在书中深入探讨这一点）。
- en: 'Let me be clear: it’s not about blaming. Every one of us – and by “us,” I mean
    a large group of people I could call “The Software Development Community” – has
    a slightly different way of solving the very same problem. And everyone, at least
    once in their lifetime, thought “I would have done it better.” But again, every
    one of us knows – or will know – that it’s a lot about circumstances. If a certain
    module or piece of code was completed quickly but poorly, it is likely because
    someone requested it to be completed quickly. Sometimes, we come across situations
    where contradictory requirements are given to us or when priorities change due
    to internal or external events that take place. This request may have been made
    due to a valid business reason, a critical security concern, or any other reason
    that they deemed important. No one is lazy; (almost) nobody works poorly. It’s
    just a matter of circumstances. We’ve all felt that pressure.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我明确一点：这并不是在责怪。我们中的每一个人——通过“我们”，我指的是一个我可能称之为“软件开发社区”的大群体——都有一种稍微不同的方式来解决同一个问题。每个人，至少在他们的一生中，都曾想过“我会做得更好”。但再次强调，我们中的每一个人都知道——或者将会知道——这很大程度上是关于环境。如果某个模块或代码片段完成得快但质量差，很可能是因为有人要求它快速完成。有时，我们会遇到有人给出相互矛盾的要求，或者由于内部或外部事件的发生而改变优先级。这个请求可能是因为一个有效的商业原因、一个关键的安全问题，或者他们认为重要的任何其他原因。没有人是懒惰的；（几乎）没有人工作得差。这只是环境问题。我们都感受到了那种压力。
- en: The techniques and concepts that fall under the broad umbrella of “refactoring”
    help prevent you from ending up in that situation, ensuring that your code doesn’t
    become that plate of spaghetti. These techniques, and, more importantly, the mindset
    associated with refactoring, can also assist you in improving the existing code
    base, gracefully navigating the swamp you find yourself in, without feeling overwhelmed.
    In this chapter, we will explore the meaning of refactoring and, in reality, how
    elusive it can be. I will try to narrate, also based on my experience, the motivations
    behind refactoring – motivations that will probably be familiar to you. I will
    then give you some advice on how to organize your refactoring sessions and how
    to prioritize the various parts that need to be fixed in your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 属于“重构”这一广泛范畴的技术和概念有助于防止你陷入那种情况，确保你的代码不会变成那盘意大利面。这些技术和，更重要的是，与重构相关的思维方式，还可以帮助你改进现有的代码库，优雅地应对你所面临的困境，而不会感到不知所措。在本章中，我们将探讨重构的含义，以及实际上它可能有多么难以捉摸。我将尝试根据我的经验，讲述重构背后的动机——这些动机可能对你来说很熟悉。然后，我将给你一些建议，关于如何组织你的重构会话以及如何优先处理代码中需要修复的各个部分。
- en: But let’s start slowly, trying to agree on what we mean by the term that gives
    the title to this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从慢一点开始，试图就本书标题所涉及的术语达成一致。
- en: 'In this chapter, we’ll cover these topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What do we mean by refactoring?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所说的重构是什么意思？
- en: Why you should consider refactoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该考虑重构
- en: When you should refactor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在何时重构
- en: What you should refactor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该重构什么
- en: What do we mean by refactoring?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们所说的重构是什么意思？
- en: If we should give a strict definition of refactoring, we could be in some trouble,
    because it is often interpreted in different ways. The most common meaning, anyway,
    is related to code rewriting. Code refactoring is the process of restructuring
    and improving existing code without changing its behavior. Code is rewritten so
    that it is easier to understand and easier to modify.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给重构下一个严格的定义，我们可能会遇到一些麻烦，因为它的含义经常被不同地解读。无论如何，最常见的含义与代码重写相关。代码重构是指在不改变其行为的前提下，对现有代码进行重构和改进的过程。代码被重写，以便更容易理解和修改。
- en: 'We could also give a “recursive” definition of refactoring: a series of refactorings
    applied to the software without changing its behavior.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给重构下一个“递归”的定义：一系列不改变软件行为的重构。
- en: 'Let me highlight this again because it’s very important: the software will
    return the very same results as before, no more and no less. It will just be written
    differently. The main (maybe the only) target you have to achieve is to make your
    code easier to understand, and this is one of the most important yet most difficult
    tasks to accomplish.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再强调一遍，因为这非常重要：软件将返回与之前完全相同的结果，不多也不少。它只是会被以不同的方式编写。你主要（也许唯一）要实现的目标是使你的代码更容易理解，而这是一项非常重要但难度很大的任务。
- en: Refactoring could also be bounded with another couple of concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重构也可以与另外几个概念相关联。
- en: It can be viewed as a way of iteratively improving the design of a software
    system. As the system evolves, its design can degrade and become outdated, leading
    to issues such as increased complexity, reduced maintainability, and reduced flexibility.
    Refactoring helps to address these issues by making incremental changes to the
    design of the system, improving its overall quality and maintainability. Moreover,
    refactoring can be used as a technique for discovering the underlying design of
    a system. By identifying patterns and commonalities in the code, developers can
    gain insights into the design of the system and identify areas for improvement.
    We’ll deepen this concept in the following paragraph.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被视为一种迭代改进软件系统设计的方式。随着系统的演变，其设计可能会退化并变得过时，导致诸如复杂性增加、可维护性降低和灵活性降低等问题。重构通过逐步改变系统的设计来帮助解决这些问题，从而提高其整体质量和可维护性。此外，重构还可以作为一种发现系统潜在设计的技术。通过识别代码中的模式和共性，开发者可以深入了解系统的设计，并确定改进的区域。我们将在下一段中深入探讨这一概念。
- en: Refactoring and clean code
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构与清洁代码
- en: Refactoring is also closely tied to the concept of clean code. We’ll go into
    details in the next chapter, but we can briefly say that clean code refers to
    code that is easy to read, understand, and *maintain*. Refactoring is one of the
    primary ways in which developers can ensure that their code remains clean. By
    continuously improving the design of their code through refactoring, developers
    can eliminate code smells (a code smell is a sign of a potential problem in the
    source code – we’ll deep dive into this later on in the book) and improve the
    overall quality of the code base. Refactoring helps to keep the code base *maintainable*
    and extensible, reducing the risk of issues. Refactoring can help to ensure that
    the code base remains aligned with the principles of clean code. When your code
    is not clean enough – and we will see what this means in the following chapter
    – what you have to do is just stop and refactor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重构也与清洁代码的概念紧密相关。我们将在下一章详细介绍，但我们可以简要地说，清洁代码指的是易于阅读、理解和*维护*的代码。重构是开发者确保其代码保持清洁的主要方式之一。通过不断通过重构改进代码的设计，开发者可以消除代码异味（代码异味是源代码中潜在问题的迹象——我们将在本书稍后深入探讨这一点）并提高代码库的整体质量。重构有助于保持代码库的*可维护性和可扩展性*，降低问题的风险。重构有助于确保代码库与清洁代码的原则保持一致。当你的代码不够清洁时——我们将在下一章中看到这意味着什么——你所要做的就是停下来重构。
- en: Misconceptions about refactoring
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重构的误解
- en: There are various concepts that may resemble refactoring but are not synonymous
    with it. Exploring these concepts can contribute to a better comprehension of
    refactoring.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多概念可能类似于重构，但并不等同于重构。探索这些概念有助于更好地理解重构。
- en: Refactoring is not about optimization. However, refactored code could have better
    performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不是关于优化。然而，重构后的代码可能会有更好的性能。
- en: Let me explain a little bit better. The main purpose of refactoring is to make
    your code easier to read, not to – for instance – reduce its cyclomatic complexity.
    (Cyclomatic complexity is a way to measure how complex a program’s flow is. It
    counts the number of different paths or decision points in the code. The higher
    the complexity, the more complicated the code becomes. It’s a useful tool for
    gauging code maintainability and finding areas that could use some simplification
    or extra testing.) It’s quite the opposite! Improving your code’s performance
    will probably reduce its readability… and it’s OK because the purposes are different.
    Refactoring is one thing; improving performance is another. Nonetheless, it is
    also true that more readable code could be, in some cases, also more efficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更详细地解释一下。重构的主要目的是使你的代码更容易阅读，而不是——例如——减少其圈复杂度。（圈复杂度是一种衡量程序流程复杂度的方法。它计算代码中的不同路径或决策点的数量。复杂性越高，代码就越复杂。它是衡量代码可维护性和发现需要简化或额外测试的区域的有用工具。）这与目的正好相反！提高代码的性能可能会降低其可读性……但这没关系，因为目的不同。重构是一回事；提高性能是另一回事。尽管如此，这也意味着更易读的代码在某些情况下也可能是更高效的。
- en: Here’s a very simple example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的例子。
- en: 'Suppose you have this (very old-school) method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个这个（非常老式）的方法：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can easily see, this method just takes an array of `int` elements and
    sums them, scanning the array one element at a time. We could try to make this
    method faster, without changing its behavior, by writing the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很容易看到的，这个方法只是接受一个`int`元素的数组并将它们相加，逐个扫描数组中的元素。我们可以尝试通过编写以下代码来使这个方法更快，而不改变其行为：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The refactored method uses a `while` loop instead of a `for` loop and increments
    the loop counter by 2 in each iteration. This allows the method to process two
    elements of the array at a time, effectively reducing the number of iterations
    needed to sum the array. This is a bit more efficient, but it is not more readable
    for sure. We reached the goal of optimization, but we did not refactor the code.
    How could we reach both goals? For instance, using a plain, simple one-liner such
    as this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的方法使用`while`循环而不是`for`循环，并在每次迭代中增加循环计数器2。这使得方法能够一次处理数组中的两个元素，从而有效地减少了求和数组所需的迭代次数。这确实更有效率，但肯定不是更易读的。我们达到了优化的目标，但我们并没有重构代码。我们如何达到这两个目标呢？例如，使用一个简单的一行代码，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method uses the `IntStream` class from Java 8’s Stream API to perform a
    parallel sum operation on the elements of the array. The `parallel()` method enables
    parallel processing, allowing multiple threads to work on different portions of
    the array simultaneously. The `sum()` method then calculates the sum of all the
    elements in the array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用Java 8的Stream API中的`IntStream`类对数组的元素执行并行求和操作。`parallel()`方法启用并行处理，允许多个线程同时处理数组的不同部分。然后`sum()`方法计算数组中所有元素的总和。
- en: 'Refactoring is not “fixing bugs.” This is much like the matter of complexity
    we just saw: you could fix a bug by refactoring a piece of code but it would be
    almost accidental. Or, better, it would be like killing two birds with a stone:
    if you can fix a bug *and* refactor a piece of code, it’s a big win! But remember
    – it’s generally advised not to mix different code actions in a single code change,
    even though it frequently happens.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不是“修复bug”。这就像我们刚才看到的复杂性问题：你可以通过重构一段代码来修复一个bug，但这几乎是一个意外。或者，更好的说法是，这就像一石二鸟：如果你能修复一个bug并且重构一段代码，那将是一个巨大的胜利！但记住——通常建议不要在单个代码更改中混合不同的代码操作，尽管这经常发生。
- en: Refactoring can actually *help* you solve bugs, but we’ll see it later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重构实际上可以*帮助*你解决bug，但我们会稍后讨论。
- en: 'Most important, refactoring is not “adding features.” When you’re adding functions
    to your software, you should not change existing code, but just add capabilities.
    On the contrary, when you refactor, your northern star shouldn’t be to change
    the existing behavior. As a software professional, you will probably find yourself
    switching between these two aspects. The important thing is that you are aware
    of what you are doing: you structure the code better, then you add new functionality;
    once the new functionalities are tested and proven to be working, you can refactor
    again; and so on. It’s like you’re wearing two hats (using Kent Beck’s metaphor)
    and you keep swapping them: you can and you should, but remember which one you’re
    wearing at each moment.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，重构不是“添加功能”。当你向你的软件添加功能时，你不应该更改现有代码，而只是添加功能。相反，当你重构时，你的北极星不应该是为了改变现有的行为。作为一名软件专业人士，你可能会发现自己在这两个层面之间切换。重要的是你要意识到你在做什么：你更好地组织代码，然后添加新功能；一旦新功能经过测试并证明可以正常工作，你就可以再次重构；依此类推。这就像你戴着两顶帽子（使用Kent
    Beck的比喻）并且不断交换它们：你可以，你也应该，但记住你每次戴的是哪一顶。
- en: In certain situations, there might be pressure from the business to prioritize
    adding new features instead of allocating time for refactoring, which may be seen
    as having no immediate value or merely serving the IT department. As a result,
    attempting to incorporate refactoring tasks discreetly within feature releases
    can lead to a blurring of roles. This means that you are not maintaining separate
    focuses or responsibilities (you’re not *wearing two hats*), thus creating a mixture
    of objectives.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会来自业务的压力，要求优先考虑添加新功能而不是为重构分配时间，这可能被视为没有立即价值或仅仅服务于IT部门。因此，尝试在功能发布中秘密地整合重构任务可能会导致角色模糊。这意味着你并没有保持不同的焦点或责任（你不是*戴着两顶帽子*），从而产生目标混合。
- en: Now that we know, more or less, what refactoring means, we are ready to get
    the reasons behind it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对重构的含义有了更多或更少的了解，我们准备了解其背后的原因。
- en: Why you should consider refactoring
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你为什么应该考虑重构
- en: We just saw that refactoring is highly coupled with the concept of clean code.
    Hence, we could say that one of the most important outtakes of refactoring your
    code is to improve its readability. In other words, refactoring makes your code
    easier to understand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，重构与清洁代码的概念高度相关。因此，我们可以这样说，重构代码最重要的收获之一是提高其可读性。换句话说，重构使你的代码更容易理解。
- en: 'Even if the main goal of writing code is to tell a machine to do what you want,
    exactly the way you want it, it’s important to underline something that we tend
    to forget, sometimes: you have to be understood not only by computers, but first
    and foremost you have to be understood by human beings. And one of those human
    beings is you: your future self! In my experience, I’ve found myself a lot of
    times asking, “Why?!” looking at a piece of code I wrote, maybe just weeks before.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编写代码的主要目的是告诉机器按照你想要的方式执行你想要的操作，精确到每个细节，但有时我们容易忘记的是：你不仅要让计算机理解，首先你必须让人类理解，尤其是你未来的自己！在我的经验中，我发现自己很多次在看着自己可能只是几周前写的代码时，会问：“为什么？！”
- en: Although it may seem simple or even naive, the idea of writing readable code
    is often overlooked due to the urgency of making our programs work. While this
    is certainly important, we must also remember that a significant portion of our
    work as software professionals is devoted to maintenance. In my experience, the
    opportunity to start a project from scratch is rare; more often than not, we inherit
    code from someone else and must maintain or build upon it. By prioritizing readability,
    we can benefit in many ways.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能很简单甚至有些天真，但由于急于让我们的程序工作，编写可读代码的想法往往被忽视。虽然这确实很重要，但我们还必须记住，作为软件专业人士，我们工作中很大一部分是致力于维护。根据我的经验，从头开始一个项目的机会很少；大多数情况下，我们必须继承他人的代码并对其进行维护或扩展。通过优先考虑可读性，我们可以从许多方面受益。
- en: Although it’s important to write code that is easy to understand in the future,
    it’s also helpful to transform complex and unreadable code into clear and organized
    code. Just like Indiana Jones or Lara Croft, developers often have to delve deep
    into the projects they are working on to comprehend the intentions of their programmer
    ancestors. However, this can be significantly more challenging if the code is
    difficult to read. By refactoring the code, you can gain confidence in the functionality
    of the code you’ll be working with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写易于未来理解代码很重要，但将复杂且难以阅读的代码转换为清晰和有组织的代码也很有帮助。就像印第安纳·琼斯或劳拉·克劳馥一样，开发者经常需要深入他们正在工作的项目，以理解程序员祖先的意图。然而，如果代码难以阅读，这可能会变得更具挑战性。通过重构代码，你可以对自己的代码功能有信心。
- en: Another good reason for having readable code is when the code is intended to
    be open sourced. Whether it is due to a personal interest in collaborating with
    open source projects, a company’s approach or using it as a showcase for professional
    profile building, having readable code becomes even more crucial in these scenarios.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个拥有可读代码的好理由是当代码打算开源时。无论是由于对与开源项目协作的个人兴趣，还是公司的策略或将其用作专业形象展示，在这些情况下，拥有可读代码变得尤为重要。
- en: Another situation where readable code is valuable is when your code undergoes
    peer review or is used for training junior team members. In such cases, having
    code that is easy to follow and comprehend helps ensure effective collaboration
    and knowledge transfer within the team.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可读代码有价值的情况是当你的代码接受同行评审或用于培训初级团队成员时。在这种情况下，拥有易于遵循和理解的代码有助于确保团队内部的有效协作和知识转移。
- en: I also like readable code because I have a very bad memory. I am unable to hold
    more than a certain amount of information in my head; actually, I don’t want it.
    There’s no need if you can retrieve the information by simply reading the code
    like it was a piece of prose. It’s not fair to expect my future self or colleagues
    to recall details that could easily be included in the code, such as why a particular
    approach was taken, why certain information was sourced from a particular location,
    or why one solution was chosen over another. One of the most frequent questions
    I ask myself when dealing with legacy code is, “Is this a mistake or is it intentional?”;
    readable code (coupled with the correct amount of tests, code comments, and coding
    standards, but we’ll see this later) is the right choice to remove doubts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我也喜欢可读的代码，因为我记忆力非常差。我无法在脑海中保留超过一定量的信息；实际上，我也不想这么做。如果你能像阅读散文一样简单地通过阅读代码来检索信息，那就没有必要了。要求我的未来自我或同事回忆那些可以轻易包含在代码中的细节是不公平的，比如为什么采取特定的方法，为什么从特定位置获取某些信息，或者为什么选择一个解决方案而不是另一个。当我处理遗留代码时，我最常问自己的问题是：“这是错误还是故意的？”；可读的代码（结合正确的测试量、代码注释和编码标准，但我们会稍后讨论）是消除疑虑的正确选择。
- en: 'There are many techniques to make the code more readable, and we will expand
    on them later in this book. There is something else I’d like to highlight first:
    readability can be something very subjective. What is readable for me may not
    be for my teammates. Some prefer one-liners, and others prefer to isolate a couple
    of lines in a single method. You may prefer to make explicit the type of every
    single variable; I prefer to use the `var` keyword. My suggestion is simple: talk
    to your teammates and agree on a trade-off. Remove from the discussion objective
    improvements (for example, using streams in place of classic loops) and agree
    on a general “code style” level (you could use a coding standard document or a
    unique formatter for your IDE, but we’ll deep dive into this later). It is important
    to keep the code consistent in all of the project classes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以使代码更易于阅读，我们将在本书的后面部分详细讨论它们。首先，我想强调的是：可读性可能是一个非常主观的东西。对我来说可读的，可能对我的队友来说不可读。有些人喜欢一行代码，而有些人喜欢在一个方法中隔离几行代码。你可能更喜欢明确每个变量的类型；我更喜欢使用`var`关键字。我的建议很简单：与你的队友交谈并达成妥协。从讨论中排除客观改进（例如，用流代替经典循环）并就一般的“代码风格”水平达成一致（你可以使用编码标准文档或为你的IDE使用独特的格式化工具，但我们将在后面深入探讨这个问题）。保持项目所有类中的代码一致性是很重要的。
- en: Improving the design of your software
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进你的软件设计
- en: 'Refactoring helps you improve the design of your software. If you don’t do
    it, the design will (not so slowly) decay; it will be more difficult to understand,
    for instance, where to put new features or how to implement them. Refactoring
    is like “tidying up” your project once a new functionality is guaranteed. If you
    don’t do it, you will probably fall into pitfalls, one of which is, the ancient
    monster that lies in almost every software company. Reducing duplicated code is
    not just a matter of “doing things properly” (even if doing things properly should
    be the norm) but has a direct benefit: when you have to modify that code, you
    will modify it only once. Believe me when I say that this very basic concept is
    not always respected. I will quote Martin Fowler here, in his book *Refactoring:
    Improving the Design of Existing Code*: “*By eliminating the duplicates, you ensure
    that the code says everything once and only once, which is the essence of* *good
    design.*”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重构有助于你改进软件的设计。如果你不这么做，设计将会（不会太慢地）退化；例如，将新功能放在哪里或如何实现它们将变得更加困难。重构就像在确保了新功能后对项目进行一次“整理”。如果你不这么做，你可能会陷入陷阱，其中之一就是几乎每个软件公司都存在的古老怪物。减少重复代码不仅仅是“正确做事”的问题（即使正确做事应该是规范），但它有一个直接的好处：当你必须修改那段代码时，你只需修改一次。当我说这个非常基本的概念并不总是受到尊重时，请相信我。在这里，我将引用马丁·福勒在其著作《重构：现有代码的设计改进》中的一段话：“通过消除重复，你确保代码只说一次，并且只说一次，这是良好设计的本质。”
- en: 'If code is poorly designed or implemented, you’ll have to do extra work to
    add functionalities, fix bugs, or improve performance: that extra work is due
    to something called **technical debt**. Technical debt happens when you prioritize
    speed over long-term benefits in your design or implementation choices. Just like
    a loan, it accumulates interest over time, making it harder to maintain and improve
    the software later. Constant refactoring improves design and quality; a better
    design reduces technical debt.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码设计或实现得不好，你将不得不做额外的工作来添加功能、修复错误或提高性能：这额外的工作是由于所谓的**技术债务**。技术债务发生在你在设计或实现选择中优先考虑速度而不是长期利益时。就像贷款一样，它会随着时间的推移积累利息，使得以后维护和改进软件变得更加困难。持续的重构可以改进设计和质量；更好的设计可以减少技术债务。
- en: Maintainability and scalability
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性和可扩展性
- en: 'As we said before, software development is a lot about maintainability. If
    refactoring helps you keep a good design, that is a clear understanding of what
    each piece of code does and where to put any new code. In a situation such as
    this, maintainability is facilitated: by improving code organization and structure,
    it becomes easier to identify and fix issues or add new features over time. If
    you take care of your software and refactor when you think it’s necessary (see
    the next subsection), the consequent good design will help you to scale your code.
    While improving performance isn’t the main reason for refactoring, it often ends
    up being a nice bonus. If a certain functionality is properly isolated, for instance,
    it will be likely easier to parallelize it or to remove it and put it in another
    service, using a remote call to retrieve information from it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，软件开发很大程度上关乎可维护性。如果重构能帮助你保持良好的设计，那就是对每一块代码的功能和放置新代码的位置有清晰的理解。在这种情况下，可维护性得到了提升：通过改进代码组织和结构，随着时间的推移，更容易识别和修复问题或添加新功能。如果你关心你的软件，并在认为必要时进行重构（参见下一小节），随之而来的良好设计将帮助你扩展你的代码。虽然提高性能不是重构的主要原因，但它通常会成为一项不错的额外收益。例如，如果某个功能被正确地隔离，那么它可能更容易并行化或将其移除并放入另一个服务中，使用远程调用来获取其信息。
- en: Understanding, avoiding, and fixing bugs
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解、避免和修复错误
- en: Good design means that each part of your code does one thing, and it does it
    well. But things can go bananas, sometimes; bugs are just around the corner. One
    of the first things to do when you fight against a bug is to understand what’s
    happening and where. Refactoring helps to understand the code (because you have
    to rewrite or restructure it a little bit without changing the external behavior),
    and thus you get to know the code better. If you know and understand your code,
    it will be faster to spot bugs or implement fixes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计意味着你的代码的每一部分只做一件事，而且做得很好。但有时事情可能会变得混乱；错误就在眼前。当你与错误作斗争时，首先要做的事情之一是了解发生了什么以及在哪里。重构有助于理解代码（因为你必须在不改变外部行为的情况下稍微重写或重构它），因此你会更好地了解代码。如果你了解并理解你的代码，那么发现错误或实施修复就会更快。
- en: 'Let me give you some advice: try to avoid having “restricted areas” in projects
    you’re working on. In this case, a restricted area refers to a library, module,
    or another part of your code base that you rely on and understand its purpose,
    but you’re afraid to touch because it’s really fragile. You know what it does,
    but not exactly how it does it. It’s like a big mess that no one in your company
    wants to deal with. The more complex and old the system is, and the more people
    have worked on it, the harder it becomes to understand the code base. Sometimes
    these restricted areas are unavoidable, especially if the previous developers
    didn’t leave any documentation. It’s not a big deal if you have some of these
    areas, but it’s best to minimize them as much as possible. Refactoring can help,
    but there are certain conditions that need to be met, such as having good test
    coverage (but we can talk about that later).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一些建议：尽量在你的项目中避免有“受限区域”。在这种情况下，“受限区域”指的是一个库、模块或代码库的另一个部分，你依赖并理解其目的，但因为你害怕触摸它而觉得它非常脆弱。你知道它做什么，但不知道它是如何做到的。它就像一个混乱，你公司里没有人愿意处理。系统越复杂、越老，参与工作的人越多，理解代码库就越困难。有时这些受限区域是不可避免的，尤其是如果之前的开发者没有留下任何文档。如果你有一些这样的区域，那并不是什么大问题，但最好尽可能地最小化它们。重构可以帮助，但需要满足某些条件，例如拥有良好的测试覆盖率（但我们稍后再谈）。
- en: Faster development
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快的开发
- en: 'All of the previous considerations bring us to one, big deal: refactoring helps
    to do things faster. It may sound a bit counterintuitive, but if you think about
    it a little bit, it becomes crystal clear. Having well-designed, bug-free, understandable
    software means keeping good quality software. And of course, the main goal of
    having high-quality software is to add functionality faster, to scale it quickly,
    and to fix bugs in the blink of an eye.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些考虑都让我们得出一个结论：重构有助于更快地完成任务。这听起来可能有点反直觉，但如果你稍微思考一下，就会变得非常清晰。拥有设计良好、无错误、易于理解的软件意味着保持良好的软件质量。当然，拥有高质量软件的主要目标是更快地添加功能、快速扩展以及快速修复错误。
- en: Keep in mind that writing software is a craft. As software developers, we are
    like artisans who shape and mold our applications and engineer and assemble our
    services. Even though we don’t use physical tools such as hammers and wrenches,
    we are still artisans. The main difference is that what we create is flexible
    and adaptable. We have the ability to revisit our work, improve upon it, and make
    it more receptive to change. By doing so, we can establish a solid foundation
    to build upon whenever we need to expand our work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编写软件是一门手艺。作为软件开发者，我们就像工匠，塑造和塑造我们的应用程序，设计和组装我们的服务。尽管我们不使用像锤子和扳手这样的物理工具，但我们仍然是工匠。主要区别在于我们创造的是灵活和适应性强的。我们有能力回顾我们的工作，对其进行改进，并使其更容易适应变化。通过这样做，我们可以在需要扩展我们的工作时，建立一个坚实的基础。
- en: If there is no proper design, engineering tasks turn into an endless cycle of
    quick fixes and hacks. If you continue to approach projects in this way, relying
    on one temporary solution after another, it is only a matter of time before the
    project becomes unmanageable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的设计，工程任务就会变成一个无休止的快速修复和黑客攻击的循环。如果你继续以这种方式处理项目，依赖一个又一个的临时解决方案，那么项目变得难以管理只是时间问题。
- en: If your manager is more focused on schedules and timelines rather than technical
    aspects or quality in general (yes – that can happen), highlighting faster development
    as a key benefit of refactoring can be a compelling selling point.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的经理更关注进度和截止日期，而不是技术方面或整体质量（是的，这种情况可能发生），强调重构可以加快开发速度作为关键优势，可以成为一个有说服力的卖点。
- en: When you should refactor
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该在何时重构
- en: At this point, we have a clear understanding of what refactoring is and why
    it holds such significant importance or, I would even go as far as to say, it
    is crucial in our daily work. You may be wondering when is the appropriate time
    to engage in this activity. There are several factors to consider when deciding
    on the timing of refactoring. It is no secret that refactoring can be time-consuming,
    so how can we effectively incorporate it into our workflow? When is the optimal
    time to execute this activity?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对重构有了清晰的理解，以及为什么它具有如此重大的重要性，或者我甚至可以说，它在我们的日常工作中至关重要。你可能想知道何时是进行这项活动的适当时间。在决定重构的时间时，需要考虑几个因素。重构可能会消耗时间，这是众所周知的，那么我们如何有效地将其融入我们的工作流程中？执行这项活动的最佳时间是什么时候？
- en: 'Let me start with some fundamental advice based on our experience: it’s always
    a good idea to do some minor refactoring whenever you have the chance, even if
    it means integrating it into your current task. For example, while running tests
    or performing static code analysis, you might come across a variable named *x*.
    That name doesn’t convey much meaning, does it? So, you’ll spend some time trying
    to figure out what that variable represents, only to discover that it contains
    a user’s name. You went through the trouble of deciphering it, but why should
    others have to do the same thing? Why should you have to go through the same hassle
    3 weeks later when you revisit the code? Just take a moment to rename the variable
    `username`. It’s a simple and almost effortless task (your IDE can do that) that
    can save others time and effort. I try to maintain this mindset at all times,
    which aligns with my “lazy” attitude of achieving maximum results with minimal
    effort.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从一些基于我们经验的基本建议开始：每次有机会时，做一些小的重构总是一个好主意，即使这意味着将其整合到你的当前任务中。例如，在运行测试或执行静态代码分析时，你可能会遇到一个名为
    *x* 的变量。这个名字并没有传达太多意义，对吧？所以，你可能会花一些时间去试图弄清楚这个变量代表什么，结果发现它包含了一个用户的姓名。你费了很大劲去解读它，但为什么别人也要做同样的事情？为什么你3周后再次查看代码时还要经历同样的麻烦？只需花一点时间将变量重命名为
    `username`。这是一个简单且几乎不费力的任务（你的IDE可以做到这一点），可以节省他人的时间和精力。我总是试图保持这种心态，这与我“懒惰”的态度相符，即以最小的努力实现最大的成果。
- en: The “Rule of Three”
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “三法则”
- en: The **Rule of Three** suggests that code should not be duplicated more than
    twice and that once duplication occurs for the third time, it should be extracted
    into a reusable module or function. It is unclear who originally stated this principle
    as it has been widely used and adapted by various software developers and teams
    over the years (it was popularized by Martin Fowler, who credits it to Don Roberts).
    A more effective way to state the same is *three strikes and* *you refactor*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**三一律规则**建议代码不应超过两次重复，一旦发生第三次重复，应将其提取为可重用的模块或函数。这个原则最初由谁提出并不清楚，因为它已被各种软件开发人员和团队广泛使用和改编多年（它被马丁·福勒普及，他将其归功于唐·罗伯茨）。更有效的方式是将其表述为“三振出局，然后重构”。'
- en: Preparatory refactoring for smooth feature implementation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为平滑功能实现做准备的重构
- en: 'When adding a new feature to your code base, it is often helpful to engage
    in **preparatory refactoring**. This means taking the time to analyze parts of
    your code base that will be affected by the new feature and making necessary changes
    beforehand. I’ll borrow Martin Fowler’s excellent analogy for preparatory refactoring:
    it’s like taping off electrical sockets, door frames, and skirting boards when
    painting a wall. The taping itself isn’t painting, but it makes the painting process
    quicker and easier.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当向你的代码库添加新功能时，进行**准备重构**通常很有帮助。这意味着花时间分析代码库中受新功能影响的部分，并在之前进行必要的更改。我将借用马丁·福勒关于准备重构的出色类比：就像在刷墙时，先封好电源插座、门框和踢脚线。封口本身不是刷墙，但它使刷墙过程更快、更简单。
- en: During the analysis phase of preparatory refactoring, you may notice areas where
    a small change in the code could lead to significant improvements in speed or
    efficiency. For example, you may realize that using a method parameter instead
    of a literal or a class hierarchy instead of a `switch` statement would improve
    the flexibility and adaptability of your code. By making these changes through
    refactoring, you can make your code more open to change in the future and ultimately
    make development easier overall.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备重构的分析阶段，你可能会注意到一些地方，代码的微小改动可以带来速度或效率的显著提升。例如，你可能会意识到使用方法参数而不是字面量或使用类层次结构而不是`switch`语句可以提高代码的灵活性和适应性。通过重构进行这些改动，你可以使代码在未来更容易接受变化，从而总体上使开发更加容易。
- en: Refactoring for bug fixing
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为错误修复的重构
- en: It is often overlooked, but fixing a bug can present a great opportunity for
    a refactor. This is because a significant portion of bug-fixing-related refactoring
    is aimed at improving the readability of your code. By making your code more understandable,
    you can identify the root cause of the bug sooner and fix it more efficiently.
    The bug had been present all along, but it went unnoticed due to the lack of readability
    in your code. So, it’s always a good practice to take the time to refactor when
    fixing bugs to prevent them from happening again in the future.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点往往被忽视，但修复一个错误可以提供一个重构的绝佳机会。这是因为与错误修复相关的重构很大一部分是为了提高代码的可读性。通过使代码更易于理解，你可以更快地识别错误的根本原因并更有效地修复它。错误一直存在，但由于代码的可读性不足而未被发现。因此，在修复错误时花时间重构以防止未来再次发生是一个好习惯。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Let me be a bit clearer here: refactoring and bug fixing are two different
    things. It’s important to fix the bug first and then focus on improving the code.
    They may be related but separate steps, and one doesn’t automatically include
    the other.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更清晰地说明：重构和错误修复是两回事。首先修复错误，然后专注于改进代码是很重要的。它们可能是相关的，但却是独立的步骤，一个不自动包含另一个。
- en: Comprehension refactoring
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解重构
- en: 'You don’t need a bug to make your code cleaner and more understandable; you
    can refactor your code while trying to understand it or – we all have been there
    – remember what you were trying to do 2 months ago. I will repeat this concept
    several times because I think it’s one of the most important in our job: writing
    code is not only talking to a set of machines; it is more about talking to our
    future selves and our colleagues. Martin Fowler refers to this technique as **comprehension
    refactoring**. The idea can be likened to organizing one’s wardrobe, where the
    goal is to have a clear and complete view of all available clothing options to
    select the best-fitting outfit. In the same way, comprehension refactoring involves
    streamlining code to improve its readability and comprehensibility.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要一个错误来让你的代码更干净、更易于理解；你可以在试图理解代码的同时重构代码——我们都有过这样的经历——记住你两个月前试图做什么。我会多次重复这个概念，因为我认为这是我们工作中最重要的概念之一：编写代码不仅仅是与一组机器对话；更多的是与我们的未来自己和同事对话。马丁·福勒将这种技术称为**理解重构**。这个想法可以比作整理自己的衣柜，目标是清楚地看到所有可用的服装选项，以便选择最合适的搭配。同样，理解重构涉及简化代码以提高其可读性和可理解性。
- en: The “Boy Scout Rule”
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “童子军规则”
- en: And then comes one of my favorite concepts related to software engineering,
    which is borrowed from the camping world and should also be applied in real life.
    Leave code better than you found it; at least, leave it as clean as it was. Do
    not leave it worse. Just like when you go camping or you picnic on a green field,
    you must think that that green field is not yours – you’re just borrowing it;
    do not leave your trash. If you find some trash, take some time to pick it up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我的一个最喜欢的与软件工程相关的概念，这个概念是从露营世界借用的，并且也应该应用于现实生活中。让你的代码比找到它时更好；至少，让它保持和原来一样干净。不要让它变得更糟。就像当你去露营或在绿色田野上野餐时，你必须认为那片绿色田野不是你的——你只是在借用它；不要留下你的垃圾。如果你发现一些垃圾，花点时间捡起来。
- en: 'Going back to our world, if you find some code that is – let’s say – understandable
    but that you think could work better (for instance, parametrizing a function or
    using another library method with a better signature), just do not ignore the
    problem and fix it. Pick up that small amount of trash you found along your path.
    At the same time, remember that you were doing something else; your task was not
    to pick up the trash but to enjoy your day in the open air (just to continue this
    joyful metaphor). So, find a trade-off between your actual task and this litter-picking
    refactoring; something I found useful, sometimes, is just to keep note that someone
    will have to clean that piece of code: how you do it (a Jira task, a `git pull`
    request, a Post-it on your monitor) depends on how your team works. But this is
    the kind of small-step refactoring that you will find very useful and, I would
    say, almost mind-changing.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的世界，如果你发现一些代码——比如说——是可以理解的，但你认为可以工作得更好（例如，参数化一个函数或使用具有更好签名的另一个库方法），那么请不要忽视这个问题并修复它。捡起你沿途发现的那些小垃圾。同时，记住你当时在做其他事情；你的任务不是捡垃圾，而是享受户外的一天（只是为了继续这个愉快的比喻）。所以，在你的实际任务和这个垃圾清理重构之间找到一个平衡；我发现有时候有用的一种方法就是记下有人会清理那块代码：你如何做（一个Jira任务，一个`git
    pull`请求，在你的显示器上的便利贴）取决于你的团队如何工作。但这是那种你会发现非常有用，我可以说，几乎是改变思维的微小步骤重构。
- en: Planned refactoring
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划重构
- en: 'At this time, it could seem that refactoring must be an activity included in
    your software developer routine, something “opportunistic;” and of course it is.
    You should refactor code as part of your daily activity. Writing software can
    be seen as adding functionalities upon functionalities, resulting in a never-ending
    stack of features and, thus, code modules, but developers know that most of the
    time it’s easier just to change existing code to add a new feature. You should
    never think about software as “done;” it is alive, and it is ever-changing. The
    moment software stays the same for too much time, there’s probably a problem:
    it could be too hard to change or to extend (not enough refactoring has been done),
    or maybe it has been replaced by something else (and so, my advice is… dismiss
    it).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，可能会觉得重构必须是你作为软件开发者的日常活动之一，一种“机会主义”的活动；当然，它确实是。你应该将重构代码作为你日常活动的一部分。编写软件可以看作是在功能之上添加功能，从而产生一个永无止境的功能堆栈和，因此，代码模块，但开发者知道，大多数时候，仅仅更改现有代码来添加新功能会更容易。你不应该认为软件是“完成的”；它是活生生的，并且一直在变化。当软件长时间保持不变时，可能存在一个问题：它可能太难更改或扩展（没有进行足够的重构），或者可能已经被其他东西所取代（因此，我的建议是……放弃它）。
- en: 'What I’m trying to say here is that it is not always possible to write excellent
    code on the first try; sometimes you have to stop, rewatch what you’ve done, and…
    try to do it better. Sometimes, you’ll even have to plan to refactor because you
    understand that changes are too hard to make on the existing code base; the concept
    is similar to the preparatory refactoring we mentioned before, but it is like
    a level up because you plan the refactoring. You should do it rarely, because
    this means that you didn’t include small refactorings into your daily activity,
    but it can happen. In this case, plan with attention: sometimes it could be better,
    for instance, to use separate branches or commits for new features and refactorings;
    someone else says that this would separate the refactoring from its purpose. I
    don’t really have a suggestion here: just do what fits best for your team.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里试图说明的是，并不总是可能第一次就写出优秀的代码；有时你必须停下来，重新审视你所做的，然后……尝试做得更好。有时，你可能甚至需要计划进行重构，因为你理解对现有代码库的更改太难了；这个概念与我们之前提到的预备重构类似，但它是一个升级，因为你计划了重构。你应该很少这样做，因为这意味着你没有将小的重构纳入你的日常活动中，但它可能发生。在这种情况下，要仔细计划：有时，例如，使用单独的分支或提交来处理新功能和重构可能更好；有人说这会将重构与其目的分开。我这里没有特别的建议：只是做最适合你团队的事情。
- en: Long-term refactoring and “Branch by Abstraction”
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期重构和“抽象分支”
- en: Although most refactoring tasks can be completed in just a few minutes or hours,
    certain activities may require several weeks of effort to complete. These typically
    include tasks such as isolating specific logic into a separate component or replacing
    one library with another. To address these more complex tasks, it can be helpful
    for a team to establish a practice of performing refactoring whenever they approach
    a “danger zone” that has been identified as in need of improvement. One useful
    technique for achieving this is called **Branch by Abstraction**, which can be
    used to change a library or service call in a gradual and controlled manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数重构任务可以在几分钟或几小时内完成，但某些活动可能需要几周的时间才能完成。这些通常包括将特定逻辑隔离到单独的组件中或用另一个库替换一个库的任务。为了解决这些更复杂的问题，团队在接近已被确定为需要改进的“危险区域”时，建立一种在重构的实践可能是有帮助的。实现这一目标的一个有用技术被称为**抽象分支**，它可以用来以渐进和可控的方式更改库或服务调用。
- en: Branch by Abstraction consists of five phases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象分支包括五个阶段。
- en: 'Imagine that you need to replace the outdated `FaultyPay` payment service that
    you integrated into your system several years ago. Naturally, you don’t want to
    cause your customers any problems or inconvenience during the transition process.
    Here, you can see that there is a call and response between the client code and
    `FaultyPay` service:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要替换你几年前集成到系统中的过时的 `FaultyPay` 支付服务。自然地，你不想在过渡过程中给你的客户带来任何问题或不便。在这里，你可以看到客户端代码和
    `FaultyPay` 服务之间存在调用和响应：
- en: '![Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response](img/B20912_01_1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 一种非常基本的情况：我们的客户端代码调用遗留系统并得到响应](img/B20912_01_1.jpg)'
- en: 'Figure 1.1 – A very basic situation: our client code calls a legacy system
    and gets a response'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 一种非常基本的情况：我们的客户端代码调用遗留系统并得到响应
- en: 'After you identified the service you want to replace, you build an abstraction
    layer to allow continued communication between the systems that are being replaced
    and the entities requesting that service. This abstraction layer acts as a contract,
    exposing functionality while concealing the implementation details:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在你确定了要替换的服务后，你构建一个抽象层，以允许被替换的系统与请求该服务的实体之间继续通信。这个抽象层充当契约，暴露功能同时隐藏实现细节：
- en: '![Figure 1.2 – An abstraction layer, often represented by a Java interface,
    is inserted between the client code and the component that needs to be eliminated](img/B20912_01_2.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 抽象层，通常由Java接口表示，被插入到客户端代码和需要消除的组件之间](img/B20912_01_2.jpg)'
- en: Figure 1.2 – An abstraction layer, often represented by a Java interface, is
    inserted between the client code and the component that needs to be eliminated
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 抽象层，通常由Java接口表示，被插入到客户端代码和需要消除的组件之间
- en: 'Then, start replacing the legacy system by systematically building the replacement
    system (we’ll call it `ShinyPay`) and gradually integrating each rebuilt feature
    into the abstraction layer as they are completed. It is important to keep in mind
    that during this process, all traffic – both from the new and the old system –
    will be passing through the abstraction layer. It is also important to note that
    you could also choose (if this is possible – it is not always) to migrate one
    function at a time:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开始系统地构建替换系统（我们将它称为`ShinyPay`），并在完成每个重建的功能后，将其逐步集成到抽象层。重要的是要记住，在这个过程中，所有流量——无论是新系统还是旧系统的——都将通过抽象层。还应注意，你也可以选择（如果可能——这并不总是可能的）一次迁移一个功能：
- en: '![Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer](img/B20912_01_3.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 一旦准备好的替换组件，就可以连接到抽象层](img/B20912_01_3.jpg)'
- en: Figure 1.3 – Once the replacement component is prepared, it can be connected
    to the abstraction layer
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 一旦准备好的替换组件，就可以连接到抽象层
- en: The abstraction layer can also be used to fine-tune the service, such as directing
    only a portion of the traffic or specific features to the new component (feature
    toggle). It could also be possible to migrate one method at a time. It is important
    to ensure that both the legacy and the new system adhere to the same contract.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层还可以用于微调服务，例如仅将部分流量或特定功能定向到新组件（功能切换）。也可能一次迁移一个方法。重要的是确保遗留系统和新的系统都遵守相同的契约。
- en: 'At this point, the code in the old system (`FaultyPay`, in our example) becomes
    obsolete, so you can delete it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，旧系统中的代码（在我们的例子中是`FaultyPay`）变得过时，因此你可以删除它：
- en: '![Figure 1.4 – The previous implementation (FaultyPay) is disconnected from
    the system; all traffic and functionalities are now exclusively directed toward
    the new implementation (ShinyPay)](img/B20912_01_4.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 之前的实现（FaultyPay）已从系统中断开；所有流量和功能现在都仅指向新的实现（ShinyPay）](img/B20912_01_4.jpg)'
- en: Figure 1.4 – The previous implementation (FaultyPay) is disconnected from the
    system; all traffic and functionalities are now exclusively directed toward the
    new implementation (ShinyPay)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 之前的实现（FaultyPay）已从系统中断开；所有流量和功能现在都仅指向新的实现（ShinyPay）
- en: 'Once all of the legacy code has been removed, you have the option to dismantle
    the abstraction layer. Alternatively, you may choose to retain this layer for
    the purpose of extensibility or future-proofing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有遗留代码都被移除，你可以选择拆除抽象层。或者，你也可以选择保留这一层以实现可扩展性或未来保障：
- en: '![Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)](img/B20912_01_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 我们已经回到了理想的情况，但有了我们的新组件！如果我们小心、熟练且幸运，没有人会注意到任何东西（这意味着没有中断）](img/B20912_01_5.jpg)'
- en: Figure 1.5 – We have returned to the ideal situation but with our new component!
    If we have been careful, skilled, and lucky, nobody has noticed anything (meaning
    there has been no disruption)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 我们已经回到了理想的情况，但有了我们的新组件！如果我们小心、熟练且幸运，没有人会注意到任何东西（这意味着没有中断）
- en: 'This approach has several obvious advantages. Apart from the primary advantage
    of enabling seamless migration of large features in continuous integration, there
    are several additional benefits of using the Branch by Abstraction technique:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法具有几个明显的优点。除了能够实现持续集成中大型功能无缝迁移的主要优点外，使用抽象分支技术的几个额外好处还包括：
- en: The release schedule is completely independent of architectural changes, making
    it easy and cost-effective to pause and resume the migration process as needed.
    This is because the new implementation is safeguarded by the system, allowing
    for quick adaptation to urgent requests or priority features from the leadership
    team or customer service department or to fix bugs. In contrast, when using a
    standard feature branch, it can be more challenging to resume a migration that
    has been paused.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布计划完全独立于架构变更，这使得根据需要暂停和恢复迁移过程变得容易且成本低廉。这是因为新的实现由系统保护，可以快速适应紧急请求或来自领导团队或客户服务部门的优先功能，或修复错误。相比之下，当使用标准功能分支时，恢复已暂停的迁移可能更具挑战性。
- en: The potential for merge conflicts is also limited to the abstraction layer only,
    which can significantly reduce the scope of conflicts that may arise. Without
    the abstraction layer, a code base refactor sitting in a feature branch for an
    extended period could generate a wide range of merge conflicts that might be difficult
    to resolve completely.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并冲突的可能性也仅限于抽象层，这可以显著减少可能出现的冲突范围。如果没有抽象层，一个在功能分支中长时间停留的代码库重构可能会产生广泛的各种合并冲突，这些冲突可能难以完全解决。
- en: Instead of switching completely to the new system, you could choose to turn
    new features on and off when you need to. These “specific switches” are called
    **feature toggles**. A feature toggle, also known as a feature flag or feature
    switch, is a technique that allows developers to enable or disable specific features
    or functionality in an application, at runtime and without modifying the code
    base. By using feature toggles, developers can release new features to a subset
    of users, test them in production environments, or enable/disable features based
    on certain conditions or user segments. This approach provides flexibility, allows
    for gradual rollouts, and reduces risk associated with deploying new features.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不必完全切换到新系统，而可以选择在需要时开启或关闭新功能。这些“特定开关”被称为**功能开关**。功能开关，也称为功能标志或功能切换，是一种允许开发者在运行时启用或禁用应用程序中特定功能或功能的技术，而无需修改代码库。通过使用功能开关，开发者可以向用户子集发布新功能，在生产环境中测试它们，或根据某些条件或用户群体启用/禁用功能。这种方法提供了灵活性，允许逐步推出，并减少了部署新功能相关的风险。
- en: Refactoring in a code review
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查中的重构
- en: A **code review** is a process of reviewing the source code. It is usually done
    by other developers or peers who are more or less familiar with the programming
    language and the project’s requirements. We'll cover code reviews in detail in
    [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码审查**是审查源代码的过程。通常由其他熟悉编程语言和项目要求的开发者或同行进行。我们将在[*第8章*](B20912_08.xhtml#_idTextAnchor183)中详细讨论代码审查。'
- en: The purpose of a code review is to ensure that the code is written in a clear,
    concise, and efficient manner and that it meets the project’s requirements and
    coding standards. Code reviews can help to identify and fix potential bugs or
    security issues, as well as improve the overall quality and maintainability of
    the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查的目的是确保代码以清晰、简洁和高效的方式编写，并且符合项目的要求和编码标准。代码审查有助于识别和修复潜在的错误或安全问题，以及提高代码的整体质量和可维护性。
- en: During a code review, the reviewer examines the code line by line and provides
    feedback on issues such as code structure, syntax errors, performance, and readability.
    The review may also involve discussions and suggestions for improvement, as well
    as questions and clarifications about the code’s functionality and design. Code
    reviews are an important part of the software development process and are typically
    conducted before the code is merged into the main code base or released to customers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码审查过程中，审查者逐行检查代码，并提供关于代码结构、语法错误、性能和可读性等方面的问题反馈。审查还可能涉及改进讨论、对代码功能设计和设计的提问和澄清。代码审查是软件开发过程中的重要部分，通常在代码合并到主代码库或发布给客户之前进行。
- en: Martin Fowler suggests that code reviews are a great time to do some refactoring.
    If you want to understand someone else’s code (as we’ve already said), the best
    way is to refactor it. Otherwise, you might only get bits and pieces of it and
    give vague feedback. Refactoring helps you get a clearer picture. By the way,
    there’s something called **pair programming** (and something called **mob programming**)
    that takes code review to the next level. We’ll talk about it more in this book
    later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒建议代码审查是进行重构的好时机。如果你想理解别人的代码（正如我们之前所说的），最好的方式就是重构它。否则，你可能只能得到一些零散的信息，并给出模糊的反馈。重构可以帮助你获得更清晰的画面。顺便说一句，有一种叫做**结对编程**（以及一种叫做**团队编程**）的东西，它将代码审查提升到了一个新的水平。我们将在本书的后面更多地讨论这个问题。
- en: What you should refactor
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该重构什么
- en: Sometimes in my career, we've come across situations where I wanted to make
    changes to different parts of my project. Maybe there was something that wasn’t
    working properly or something that I didn’t fully understand, or simply something
    that could be improved. It’s important to decide which parts to focus on and prioritize.
    And in some cases, it might even be better to leave things as they are and not
    make any changes at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在我的职业生涯中，我们会遇到需要对我的项目不同部分进行修改的情况。可能是因为某些部分工作不正常，或者是我没有完全理解的部分，或者仅仅是能够改进的地方。决定哪些部分需要关注和优先处理是很重要的。在某些情况下，甚至可能更好让事情保持原样，不做任何修改。
- en: There’s no hard and fast rule when it comes to refactoring, but with a little
    thought, you can come up with a solid plan that meets your specific needs. Remember
    – in our profession and in life, we often have to make compromises.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构方面没有固定的规则，但只要稍加思考，你就可以制定出一个符合你特定需求的稳固计划。记住——在我们这个职业和生活中，我们经常不得不做出妥协。
- en: 'Recently, I came across a helpful concept in Gary Keller’s book, *The One Thing*
    (*Bard Press*, *2013*). While it’s not specifically related to software development,
    it can be applied to our needs. The idea is this: “What’s the one thing you can
    do, such that by doing it, everything else will be easier or unnecessary?” While
    this is a broad question with many implications that we can’t discuss here, it
    can be a useful starting point for deciding what to do with our code base. This
    approach is super helpful when it comes to refactoring code. So, when you’re starting
    a new task or feature, take a look at your code and ask yourself if there’s anything
    that, if improved, would make the rest of the project work a lot easier or completely
    unnecessary.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我在加里·凯勒的书籍《最重要的事》(*Bard Press*, *2013*)中遇到了一个有用的概念。虽然它不是专门与软件开发相关的，但它可以应用于我们的需求。这个想法是这样的：“你能做哪一件事情，通过做这件事，其他所有事情都会变得更容易或不再必要？”虽然这是一个广泛的问题，有很多含义我们在这里无法讨论，但它可以成为决定我们如何处理代码库的有用起点。这种方法在重构代码时特别有帮助。所以，当你开始一个新的任务或功能时，看看你的代码，问问自己是否有任何改进，可以使整个项目的工作变得容易得多或完全不再必要。
- en: 'The question is focused on what you can do, which forces you to think in actionable
    terms. It’s not about what you would do if certain conditions were met, but rather
    what you’re capable of doing right now. By identifying the one thing that can
    make everything else easier or unnecessary, we can focus our efforts on the most
    critical task at hand. It’s like distilling the essence of our job down to its
    core: doing the minimum necessary to achieve the maximum impact. This approach
    can be particularly valuable in software development, where there are often many
    different areas that could benefit from refactoring or improvement, but we need
    to prioritize and focus our efforts to achieve the greatest impact.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是关注你能做什么，这迫使你从可操作的角度去思考。这并不是关于在满足某些条件时你会做什么，而是关于你现在能做什么。通过确定那一件可以使其他所有事情都变得更容易或不再必要的事情，我们可以将我们的努力集中在最关键的当前任务上。这就像将我们工作的本质提炼到核心：做最必要的最小工作以达到最大的影响。这种方法在软件开发中尤其有价值，因为通常有很多不同的领域可以从重构或改进中受益，但我们需要优先考虑并集中我们的努力以达到最大的影响。
- en: 'Let me give you an example to illustrate this point. Picture yourself working
    at a travel company that’s doing well, but facing challenges in handling a complex
    ecosystem with multiple travel providers and their solutions. The trouble is,
    there’s some outdated code causing problems, and the booking process occasionally
    fails. The system technically works without any bugs, but it’s outdated, difficult
    to maintain, lacks proper documentation (in one word: its *legacy*), and definitely
    not ready to handle the expected surge in traffic. We really need to refactor
    it, or else the company won’t be able to handle all the upcoming new customers.
    Meanwhile, there’s an internal team responsible for managing website content,
    and they’re struggling with a tool they only use twice a month. It’s incredibly
    confusing and impractical, making even simple tasks time-consuming. We absolutely
    have to refactor that tool to make it more user-friendly for the team. While both
    issues are important, it’s clear that the first problem with the legacy code and
    booking process should be addressed first, because travel booking is the core
    business of the company and because those people would be free to deal with something
    else.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子来说明这一点。想象一下，你在一家人气旺盛的旅行社工作，但面临着处理多个旅游提供商及其解决方案的复杂生态系统的挑战。问题是，有一些过时的代码导致问题，预订过程偶尔会失败。系统技术上没有错误，但它是过时的，难以维护，缺乏适当的文档（一句话：它的*遗留性*），而且肯定无法应对预期的流量激增。我们真的需要重构它，否则公司将无法应对即将到来的新客户。同时，有一个内部团队负责管理网站内容，他们正在与一个每月只使用两次的工具作斗争。这个工具极其复杂且不实用，甚至简单的任务也会变得耗时。我们绝对必须重构这个工具，使其对团队更友好。虽然这两个问题都很重要，但很明显，遗留代码和预订流程的第一个问题应该首先解决，因为旅游预订是公司的核心业务，而且那些人将能够自由地处理其他事情。
- en: Anyways, let’s face it – refactoring legacy code can be overwhelming, especially
    when you’re pressed for time and resources. While “the one thing” rule is a fantastic
    approach, it’s also pretty broad. So, let me show you something more precise that
    can help you decide which parts of the code base require your attention the most.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们面对现实——重构遗留代码可能会让人感到不知所措，尤其是在时间和资源紧张的情况下。虽然“一事一做”规则是一种绝佳的方法，但它也相当宽泛。所以，让我给你展示一些更精确的方法，可以帮助你决定哪些代码库的部分最需要你的关注。
- en: Impact analysis
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响分析
- en: '**Impact analysis** is like detective work in software refactoring. It’s all
    about figuring out how changes to one part of the code base will affect other
    parts of the system.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**影响分析**就像软件重构中的侦探工作。它全部关乎于弄清楚代码库中某一部分的变更将如何影响系统的其他部分。'
- en: So, first, the developers identify code modules that need to be refactored or
    updated. Then, they investigate the connections and relationships between these
    modules and other parts of the software, such as external libraries, user interfaces,
    and interfaces.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，开发者需要确定需要重构或更新的代码模块。然后，他们调查这些模块与其他软件部分（如外部库、用户界面和接口）之间的联系和关系。
- en: By understanding these dependencies, the developers can get a good sense of
    how changes will ripple through the system. They can pinpoint areas that might
    be particularly tricky to change and take steps to reduce the chances of bugs
    or other issues cropping up.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些依赖关系，开发者可以很好地了解变更将如何在整个系统中产生连锁反应。他们可以确定可能特别难以更改的区域，并采取措施减少出现错误或其他问题的可能性。
- en: Basically, impact analysis is a crucial tool in the software refactoring toolkit.
    It helps developers make changes in a more thoughtful and careful way so that
    the code remains stable and easy to maintain in the long run.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，影响分析是软件重构工具箱中的关键工具。它帮助开发者以更深思熟虑和谨慎的方式做出更改，从而使代码在长期内保持稳定且易于维护。
- en: 'Performing an impact analysis involves thoroughly assessing the potential effects
    of making changes to a system or project. Here’s a breakdown of the steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 进行影响分析涉及彻底评估对系统或项目进行变更的潜在影响。以下是步骤分解：
- en: '**Preparation**: Define the change, clearly stating what you want to do. Collect
    data about the proposed change.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备**：定义变更，明确说明你想要做什么。收集关于提议变更的数据。'
- en: '**Identify affected areas and dependencies**: Brainstorm which parts of the
    system will be impacted by the change and how the change will affect other components
    in the system.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别受影响区域和依赖关系**：头脑风暴系统哪些部分会受到变更的影响，以及变更将如何影响系统中的其他组件。'
- en: '**Identify affected elements in each area**: Evaluate how the change will impact
    functionality, performance, security, and other aspects. Identify potential risks
    and problems that could arise from the change.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别每个领域的受影响元素**：评估更改将如何影响功能、性能、安全性和其他方面。识别可能由更改引起的风险和问题。'
- en: '**Evaluate**: Conducting an evaluation, the team identifies both positive and
    negative impacts of the proposed change.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估**：进行评估时，团队会识别出所提议更改的正面和负面影响。'
- en: '**Deal with negative consequences**: With a clearer understanding of the negative
    impacts, the team can now focus on addressing them. They have the opportunity
    to consult with team members and stakeholders to discuss whether the change should
    proceed or not. Additionally, conducting regression testing becomes crucial in
    this scenario.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理负面后果**：对负面影响的更清晰理解后，团队现在可以专注于解决这些问题。他们有机会与团队成员和利益相关者协商，讨论是否应该继续更改。此外，在这种情况下进行回归测试变得至关重要。'
- en: Risk assessment
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风险评估
- en: '**Risk assessment** is a fancy way of saying “figuring out what could go wrong.”
    In software refactoring, it’s all about taking a hard look at the code base and
    identifying potential risks before making changes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**风险评估**是一种说法，即“找出可能出错的事情”。在软件重构中，这涉及到在做出更改之前，对代码库进行严格的审视并识别潜在的风险。'
- en: When assessing risk, developers consider a range of factors, including the complexity
    of the code, the likelihood of introducing bugs, and the potential impact of any
    issues that might arise. There may be impacts on data (some pieces of code are
    maybe dealing with crucial information such as personal or financial data), possible
    downtimes (some pieces of code, in case of issues, may bring down the entire system
    or some core functionalities), business issues (pieces of code that if broken
    could cause financial issues or contract infringements), or security breaches.
    They may also look at the time and resources available for the refactoring project
    and the potential impact on users and stakeholders.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估风险时，开发者会考虑一系列因素，包括代码的复杂性、引入错误的可能性和可能出现的问题的潜在影响。可能对数据（某些代码可能处理关键信息，如个人或财务数据）产生影响，可能出现的停机时间（某些代码在出现问题时可能会使整个系统或某些核心功能崩溃），业务问题（如果某些代码损坏可能会导致财务问题或合同违规），或安全漏洞。他们还可能考虑重构项目的可用时间和资源以及可能对用户和利益相关者产生的影响。
- en: Once risks have been identified, developers can take steps to mitigate them.
    For example, they might create test cases to ensure that the refactored code works
    as expected, or they might make changes in small increments to reduce the chances
    of something going wrong. We will talk more deeply about test coverage later in
    this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出风险，开发者可以采取措施来减轻它们。例如，他们可能会创建测试用例以确保重构后的代码按预期工作，或者他们可能会分小步骤进行更改以减少出错的可能性。我们将在本书的后面更深入地讨论测试覆盖率。
- en: Overall, risk assessment is an important part of software refactoring because
    it helps developers make informed decisions about how to proceed. By taking the
    time to consider potential risks and plan accordingly, they can ensure that the
    refactoring project is successful and that the code base remains stable and maintainable
    over time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，风险评估是软件重构的重要部分，因为它帮助开发者做出明智的决定，关于如何继续进行。通过花时间考虑潜在的风险并相应地制定计划，他们可以确保重构项目成功，并且代码库在长时间内保持稳定和可维护。
- en: Value estimation
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 价值评估
- en: '**Value estimation** in software refactoring is all about figuring out whether
    a particular refactoring project is worth the time and resources required to complete
    it.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**价值评估**在软件重构中，就是确定特定的重构项目是否值得投入所需的时间和资源来完成。'
- en: When estimating value, developers consider a variety of factors, such as the
    current state of the code base, the potential benefits of the refactoring, and
    the potential costs and risks involved. They might also take into account factors
    such as user feedback, performance metrics, and the needs of stakeholders.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估价值时，开发者会考虑各种因素，例如代码库的当前状态、重构的潜在好处以及涉及的成本和风险。他们还可能考虑用户反馈、性能指标和利益相关者的需求等因素。
- en: Once the potential value of a refactoring project has been estimated, developers
    can decide whether it makes sense to move forward. In some cases, the potential
    benefits might not outweigh the costs, and the project may be shelved or postponed.
    In other cases, the benefits may be significant enough to justify the investment,
    and the project may move forward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对重构项目的潜在价值进行了评估，开发者可以决定是否继续推进。在某些情况下，潜在的利益可能不足以抵消成本，项目可能会被搁置或推迟。在其他情况下，利益可能足够显著，足以证明投资的合理性，项目可能会继续进行。
- en: Value estimation is an important part of software refactoring because it helps
    developers prioritize their efforts and make strategic decisions about how to
    allocate resources. By focusing on projects with high potential value and avoiding
    those with lower potential value, developers can ensure that they are making the
    most efficient use of their time and resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 价值评估是软件重构的一个重要部分，因为它有助于开发者优先考虑他们的努力并就如何分配资源做出战略决策。通过关注具有高潜在价值的项目并避免那些潜在价值较低的项目，开发者可以确保他们最有效地利用他们的时间和资源。
- en: Prioritization matrix
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级矩阵
- en: A **prioritization matrix** (also known as the **Eisenhower Matrix**) is a tool
    used in software refactoring to help developers prioritize their efforts and make
    informed decisions about which refactoring projects to tackle first. It typically
    involves a matrix with two axes, one representing the level of urgency given to
    a project and the other representing the potential impact on the system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级矩阵**（也称为**艾森豪威尔矩阵**）是软件重构中用于帮助开发者优先考虑他们的努力并就哪些重构项目优先处理做出明智决策的工具。它通常涉及一个矩阵，其中两个轴分别代表分配给项目的紧迫程度和潜在的系统影响。'
- en: Each project is evaluated based on these two factors and then plotted on the
    matrix accordingly. Projects that require the least effort and have the greatest
    potential impact are considered the highest priority, while those that require
    more effort and have a lower potential impact are considered lower priority.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都是基于这两个因素进行评估，然后相应地绘制在矩阵上。那些需要最少努力且具有最大潜在影响的项目被认为是最高优先级，而那些需要更多努力且潜在影响较低的项目被认为是低优先级。
- en: 'Using a prioritization matrix can help developers make strategic decisions
    about which projects to tackle first, based on the potential benefits and costs
    of each project. By focusing on the highest priority projects first, developers
    can make the most efficient use of their time and resources, and ensure that they
    are addressing the most critical issues in the code base:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用优先级矩阵可以帮助开发者根据每个项目的潜在利益和成本，做出关于先处理哪些项目的战略决策。通过首先关注最高优先级的项目，开发者可以最有效地利用他们的时间和资源，并确保他们正在解决代码库中最关键的问题：
- en: '![Figure 1.6 – You should put your activities in a prioritization matrix in
    order to choose the right priority for execution](img/B20912_01_6.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 你应该将你的活动放入优先级矩阵中，以选择正确的执行优先级](img/B20912_01_6.jpg)'
- en: Figure 1.6 – You should put your activities in a prioritization matrix in order
    to choose the right priority for execution
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 你应该将你的活动放入优先级矩阵中，以选择正确的执行优先级
- en: The higher priority should be assigned to activities that have high urgency
    and impact. Lower priority (or no importance at all) should be given to activities
    that are not urgent and will have no impact.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应将更高优先级分配给那些具有高紧迫性和影响的活动。对于那些不紧迫且不会产生影响的活动的优先级应较低（或完全没有重要性）。
- en: Further considerations
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步考虑
- en: There’s more to think about when it comes to refactoring. I’ll jot it down here
    just to cover all our bases, but honestly, it might be a bit beyond the scope
    of this chapter. Once you’ve figured out which parts of your code base to prioritize
    for refactoring, the next step is to create a detailed plan that includes the
    scope, goals, steps, and timeline for the project. It’s also crucial to communicate
    this plan to everyone involved, such as your team, manager, clients, and users.
    You need to explain why you’re refactoring, what you’ll be doing, how you’ll be
    doing it, and when it’ll be done. It’s important to set clear expectations and
    manage them throughout the refactoring process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行重构时，还有更多的事情需要考虑。我这里只是简单地记下来，以防万一，但说实话，这可能会超出本章的范围。一旦你确定了代码库中需要优先重构的部分，下一步就是制定一个详细计划，包括项目的范围、目标、步骤和时间表。向所有相关人员传达这个计划也很关键，比如你的团队、经理、客户和用户。你需要解释为什么你要重构，你将做什么，你将如何做，以及何时完成。在整个重构过程中设定明确的期望并管理它们是很重要的。
- en: The final step is to execute the plan with discipline and diligence. Stick to
    best practices such as making small and frequent changes, running tests before
    and after each change, committing and documenting each change, and reviewing and
    verifying each change. Keep an eye on how the refactoring is affecting things
    such as code quality, system performance, and user feedback. Measure the outcomes
    and compare them with your goals and expectations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是以纪律和勤奋执行计划。坚持最佳实践，如进行小而频繁的更改，在每个更改前后运行测试，提交并记录每个更改，以及审查和验证每个更改。关注重构如何影响代码质量、系统性能和用户反馈。衡量结果，并将它们与你的目标和期望进行比较。
- en: Refactor or rewrite?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构还是重写？
- en: There are various opinions on this matter, which I have observed to be a common
    source of disputes among teammates and colleagues. The truth is there is no simple
    answer. It’s just one of those things where there are a ton of conflicting opinions
    out there, and it’s tough to figure out what to believe. But I’ll do my best to
    share some of those opinions with you and offer up some advice, for whatever it’s
    worth.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题，有各种各样的观点，我观察到这是团队成员和同事之间发生争执的常见原因。事实是，没有简单的答案。这只是那些有很多相互矛盾观点的事情之一，很难确定该相信什么。但我会尽我所能与你分享一些这些观点，并给出一些建议，无论它们的价值如何。
- en: There are situations when it’s simply not justifiable to refactor your code.
    Perhaps it’s plagued with too many bugs, the design is overly complicated, and
    comprehending it is nearly impossible. Going through it’s like trying to solve
    the Rubik’s Cube blindfolded – or, quoting a former colleague of mine, like counting
    money with a fan blowing nearby. In such cases, rewriting it from the ground up
    may be the better option, and it’s something that many software developers find
    enjoyable. After all, it’s often more comfortable to create something new than
    to take small, incremental steps that are still tied to what was previously done.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，重构代码根本无法证明其合理性。可能是因为它充满了太多的错误，设计过于复杂，理解起来几乎是不可能的。处理它就像蒙着眼睛解决魔方——或者，引用我的一位前同事的话，就像在附近吹风扇时数钱。在这种情况下，从头开始重写可能是更好的选择，这也是许多软件开发者觉得很有趣的事情。毕竟，创造新事物通常比采取仍然与之前所做事情相关的小步骤更舒适。
- en: 'On the other hand, we often fall into the trap of wanting to rewrite everything,
    thinking that what’s already there is terrible, when in reality, we may not have
    put in the effort to fully understand it. It’s important to remember one of the
    fundamental rules of programming, according to American developer Joel Spolsky:
    *it’s harder to read code than to write it*. Let’s not immediately denigrate the
    legacy code we come across in our code bases, which typically wasn’t written by
    us (our own code is, of course, beautiful). Legacy code has a history; it has
    been thoroughly tested and integrated with all necessary use cases and has often
    demonstrated good performance. We should respect legacy code.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们常常陷入想要重写一切的陷阱，认为现有的东西都很糟糕，而实际上，我们可能并没有付出足够的努力去完全理解它。记住美国开发者乔尔·斯波尔斯基提出的编程基本规则之一是很重要的：*阅读代码比编写代码更难*。让我们不要立即贬低我们在代码库中遇到的遗留代码，这些代码通常不是我们写的（当然，我们自己的代码是漂亮的）。遗留代码有历史；它已经经过彻底测试，并与所有必要的用例集成，并且通常表现出良好的性能。我们应该尊重遗留代码。
- en: It’s a really complicated decision, and as I said, there’s no general rule.
    Perhaps, a very simple rule to adopt could be to try to evaluate the cost (both
    in terms of time and complexity) of rewriting and refactoring code and choose
    the option that seems best to you. Note that I didn’t say “the option that costs
    less,” because it’s often an investment. Another useful thing could be to break
    down the part under examination into smaller parts (the good old “divide and conquer”)
    and choose to refactor (or rewrite) only that part, so as not to be “stuck” for
    too long.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常复杂的决定，正如我所说的，没有普遍的规则。也许，可以采用的一个非常简单的规则是尝试评估重写和重构代码的成本（无论是时间还是复杂度），并选择对你来说看起来最好的选项。请注意，我并没有说“成本更低的选项”，因为这通常是一种投资。另一件有用的事情可能是将检查的部分分解成更小的部分（古老的“分而治之”方法），并选择只重构（或重写）那部分，以免“陷入困境”太长时间。
- en: 'If you decide to rewrite a piece of code, a module, or an entire component,
    let me give you a heartfelt piece of advice: don’t get too attached to what has
    already been done. Let me explain. Surely, it will be useful to try and understand
    what the code does and the individual steps that make up the logical flow. It
    will be equally useful to understand how users currently behave and which business
    cases are currently implemented. However, I have often found that what is currently
    present does not correspond to the real needs of users; perhaps it never did,
    or perhaps needs have changed over time. Perhaps half of that software is simply
    no longer needed. So, it’s fine to read what exists and try to rewrite it better
    or differently, but often this reverse-engineering process can be quite complicated,
    time-consuming, and, especially, error-prone. Instead, try to identify what users
    need, possibly with the help of the Product Owner (to know what a PO exactly is,
    you can refer to [https://www.scrum.org/resources/what-is-a-product-owner](https://www.scrum.org/resources/what-is-a-product-owner)).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定重写一段代码、一个模块或整个组件，让我给你一条衷心的建议：不要过于执着于已经完成的工作。让我解释一下。当然，尝试理解代码的功能和构成逻辑流程的各个步骤是有用的。同样有用的是了解用户当前的行为和当前实施的业务案例。然而，我经常发现当前存在的东西并不符合用户的真实需求；也许它从未符合过，或者随着时间的推移需求发生了变化。也许一半的软件现在根本不再需要。因此，阅读现有内容并尝试以更好的方式或不同的方式重写它是可以的，但通常这个逆向工程过程可能相当复杂、耗时，尤其是容易出错。相反，尝试确定用户的需求，可能需要产品负责人的帮助（要知道产品负责人是什么，你可以参考[https://www.scrum.org/resources/what-is-a-product-owner](https://www.scrum.org/resources/what-is-a-product-owner))。
- en: 'This may actually encounter some resistance, which depends on the mentality
    of the company you are working for. Many times, I have been told: It must have
    the same logic as before, but it must work better. This is obviously a great way
    to cover one’s back, but it almost never leads to effective results. It forces
    engineers to do huge reverse-engineering work, which in light of (often) changing
    user needs can be partially useless; it does not allow the team (both the so-called
    tech part and the so-called product part, assuming such differentiation makes
    sense) to focus on the importance of individual features, in order to prioritize
    activities and perhaps avoid unnecessary ones. So, I suggest you always start
    from the needs – from the why, before the how. Think about the goal before how
    to get there.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上可能会遇到一些阻力，这取决于你所工作的公司的心态。很多时候，我被告知：它必须和以前一样有相同的逻辑，但必须工作得更好。这显然是一种很好的保护自己的方式，但它几乎从未导致有效的结果。这迫使工程师进行大量的逆向工程工作，鉴于（通常是）不断变化的需求，这可能部分是无效的；它不允许团队（无论是所谓的科技部分还是所谓的产品部分，假设这种区分有意义）专注于单个功能的重要性，以便优先考虑活动并可能避免不必要的活动。因此，我建议你始终从需求开始——从为什么，而不是如何开始。在考虑如何到达那里之前，先考虑目标。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter delves into the concept of refactoring and its elusive nature.
    It examines the underlying motivations for refactoring and offers insights into
    organizing effective refactoring sessions, as well as prioritizing different areas
    requiring attention in your code. Furthermore, it emphasizes the significance
    of integrating refactoring seamlessly into your regular activities. In conclusion,
    the chapter provides a comprehensive summary and presents a range of techniques
    to successfully incorporate refactoring into your professional routine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了重构的概念及其难以捉摸的本质。它分析了重构的潜在动机，并提供了关于组织有效的重构会议以及优先考虑代码中需要关注的各个不同区域的见解。此外，它强调了将重构无缝集成到日常活动中的重要性。总之，本章提供了一个全面的总结，并介绍了一系列成功将重构融入专业日常工作的技术。
- en: In the upcoming chapter, we will discuss a set of recommended practices that
    are considered “good habits” for software professionals to adopt in their work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将讨论一系列被认为是软件专业人士在工作中应采纳的“良好习惯”的推荐实践。
- en: Further reading
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Martin Fowler*, *Refactoring*, *Addison-Wesley Professional*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*马丁·福勒*，《重构》，*Addison-Wesley Professional*'
- en: '**How do you prioritize which legacy code to refactor** **first?** [https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor](https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你应该如何优先考虑哪些遗留代码应该首先重构**？ [https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor](https://www.linkedin.com/advice/0/how-do-you-prioritize-which-legacy-code-refactor)'
- en: '**Refactor vs. rewrite: Deciding what to do with problem** **software**: [https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software](https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构与重写：决定如何处理问题软件** [https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software](https://www.techtarget.com/searchapparchitecture/tip/Refactor-vs-rewrite-Deciding-what-to-do-with-problem-software)'
- en: '**Things You Should Never Do, Part** **I**: [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《你永远不应该做的事情，第一部分》** [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)'
- en: '**Feature Toggles (aka Feature** **Flags)**: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能切换（又称功能** **标志**）** [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
- en: '**BranchByAbstraction**: [https://martinfowler.com/bliki/BranchByAbstraction.html](https://martinfowler.com/bliki/BranchByAbstraction.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BranchByAbstraction** [https://martinfowler.com/bliki/BranchByAbstraction.html](https://martinfowler.com/bliki/BranchByAbstraction.html)'
