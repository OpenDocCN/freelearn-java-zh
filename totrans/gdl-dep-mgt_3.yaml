- en: Chapter 3. Resolving Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, you learned how to add dependencies to your projects.
    We have seen different ways of specifying dependencies, such as module or project
    dependencies. In the previous chapter, we explored how to define the repositories
    that host our dependencies. Gradle will use this information to do the actual
    dependency resolution. In this chapter, we will see how Gradle resolves dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle has a different way of resolving version conflicts than other build tools,
    so we will take a good look at what happens when a dependency is resolved. We
    will see how we can customize the resolution process in Gradle so that we can
    have the exact dependencies we want and have reliable and repeatable builds.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradle will use the information in the `repositories` and `dependencies` configuration
    blocks to gather and download all dependencies. This process is also called **dependency
    resolution**. The following steps are taken by Gradle to resolve dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: The module descriptor file for a dependency is searched in the defined repositories.
    The order of the repository definitions is used for searching. So, repositories
    defined before other repositories are searched first, and so on. If a POM or Ivy
    descriptor file is found, it is used. If no descriptor file is found, then the
    artifact file for the dependency is searched. If either the descriptor file or
    the artifact file is found, then Gradle knows this repository can be used to download
    the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a POM descriptor file is found with a parent POM descriptor file, then the
    parent POM is resolved by Gradle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic version, like *4.1.+*, is resolved to the highest available static
    version in the repository. For example if the repository contains versions *4.1.0*
    and *4.1.1* then the *4.1.1* version is used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gradle will determine which repository is the best to use based on the following
    criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module descriptor files, like POM and Ivy descriptor files, are preferred over
    artifact file only.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies found in earlier repositories are preferred over later repositories.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a dynamic version like *2.+* is used, than a higher static version is preferred
    over a lower static version.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The artifacts for the module dependency are downloaded from the repository that
    is chosen by Gradle. This means that artifacts are not downloaded from a different
    repository than where the descriptor file or artifact file for the defined dependency
    are found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a dependency is defined with a static version, and Gradle finds a module
    descriptor file for this dependency in a repository, then the search for this
    dependency is complete, and other repositories will not be used for the search.
    The process cannot come up with a better repository candidate, so the dependency
    resolution is finished for the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring transitive dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time dependencies in our project are also dependent on other libraries.
    So, the dependencies have dependencies of their own. These are so-called transitive
    dependencies. Gradle must be able to resolve the transitive dependencies as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we define the `logback-classic` module
    dependency with the version `1.1.2` and the group name `ch.qos.logback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the Gradle `dependencies` task, we can see that our defined dependency
    for `logback-classic` depends on `ch.qos.logback:logback-core:1.1.2` and `org.slf4j:slf4j-api:1.7.6`.
    The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Disabling transitive dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we don't want to have transitive dependencies in our project, we must reconfigure
    the dependency or configuration. With Gradle, we have different ways to disable
    transitive behavior for dependencies. First, we can add a configuration closure
    to our dependency definition, use the `transitive` property, and set the value
    to `false`. By default, all dependencies are treated as transitive, as we saw
    in our example build file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we specify that we want to treat or use
    the `logback-classic` dependency as nontransitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `dependencies` task again, we can see in the output that the
    transitive dependencies are no longer resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also disable transitive dependencies for a dependency configuration
    as a whole. So, this means that any dependencies defined with the configuration
    will not have transitive dependencies. Single dependencies within the configuration
    can use the `transitive` property in the configuration closure to enable transitive
    behavior again for that dependency. To accomplish this, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will disable transitive dependencies for the `compile` configuration
    in the next example build file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will execute the `dependencies` task and see that transitive dependencies
    are no longer resolved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Excluding transitive dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also have more fine-grained control of transitive dependencies. We can
    exclude certain transitive dependencies in our dependency definition. This way,
    we can choose to use only certain transitive dependencies and leave others out.
    To define which transitive dependencies we want to exclude, we use the `exclude`
    method in the configuration closure of our dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can include the `logback-core` transitive dependency but
    remove the `slf4j-api` dependency. We use the `exclude` method in the configuration
    closure. The `exclude` method takes `Map` as an argument with one or both of the
    keys: `module` and `group`. In the following build file, we include the `logback-core`
    transitive dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We execute the `dependencies` task to see whether our configuration definition
    has the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the output, the transitive dependency, `org.slf4j:slf4j-api:1.7.6`,
    is no longer part of our transitive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set exclude rules on a configuration in addition to a single dependency.
    The exclude rule on a configuration will be used for all dependencies defined
    within the configuration. In the next example Gradle build file, we will exclude
    the `slf4j-api` module from all dependencies in the `compile` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Any exclude rule that we add to either the configuration or the dependency
    is accessible again via the `excludeRules` property of the corresponding objects.
    We can use this to find out the configuration or dependency that is responsible
    for excluding a certain dependency. In the following example build file, we create
    a new task, `showExcludeRules`, where we loop through all configurations and dependencies
    and collect exclude rules. At the end of the task, we print all the information
    to standard output. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the task, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using artifact-only dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can use the `ext` attribute for an external module dependency if
    we know we only want to include a single artifact from the dependency. With this
    attribute, no transitive dependencies are resolved because we specify that we
    specifically want the artifact specified by the `ext` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we can use the `ext` attribute with the `jar` value to resolve
    only the JAR artifact for the `logback-classic` dependency. In the next example
    build file, we will use the `ext` attribute for our `logback-classic` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Resolving version conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous examples were simple and only contained one dependency with some
    transitive dependencies. When we add more dependencies to our project, or have
    a multimodule project where each project has a lot of dependencies, then it can
    happen that the same dependency or transitive dependency is included multiple
    times. Gradle detects this and makes sure that the dependency is only downloaded
    once. We will see more about the advanced dependency cache management in Gradle
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trouble begins when the same dependency is included multiple times but
    with different versions. Which version of the dependency should be used? This
    is where Gradle''s resolution strategy comes into play. The next table shows the
    resolution strategies that Gradle has:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Newest | The newest version of a conflicting dependency is used. This is
    the default strategy used by Gradle. If the versions of the conflicting dependency
    are backward compatible, this works fine. |'
  prefs: []
  type: TYPE_TB
- en: '| Fail | The build process fails when there is a version conflict with dependencies.
    We must explicitly add code to our build file that will resolve the version conflict.
    We will see later in this chapter how we can customize the resolution strategy
    to solve version conflicts explicitly. |'
  prefs: []
  type: TYPE_TB
- en: Using the newest version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we have a version conflict and use the default resolution
    strategy of Gradle. Gradle will use the newest version of the dependency that
    has a version conflict. To accomplish this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next build file, we define a dependency on `slf4j-api` in the `compile`
    configuration and on `logback-classic` in the `runtime` configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We run the `dependencies` task to see which versions of the dependencies are
    used. The following output shows that the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency of `logback-classic` is changed, so the version `1.7.7` is used, which
    is defined in the `compile` configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the line `org.slf4j:slf4j-api:1.7.6 → 1.7.7`, where it visually shows
    that the version is increased for this dependency from `1.7.6` to `1.7.7`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `dependencies` task shows a hierarchical tree view of the dependencies and
    transitive dependencies. To get a view from a specific dependency, and to see
    how it got in the dependency graph, we use the `dependencyInsight` task. With
    this task, we can see how the dependency is resolved and whether any conflict
    resolution has happened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must use the following two options when we invoke the `dependencyInsight`
    task from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify the configuration of the dependency with the `--configuration` option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `--dependency` option to specify the name of the dependency.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the dependency doesn't have to be the full name; we can even use
    part of the name. For example, we can use `org.slf4j:slf4j-api`, `slf4j-api`,
    and `slf4j` to gain insight into a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We execute the `dependencyInsight` task to see more information about the `slf4j-api`
    dependency in our example build file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the output, we see that the `org.slf4j:slf4j-api:1.7.7` dependency is resolved
    for the `runtime` configuration and that conflict resolution has happened for
    the dependency. In the next lines, we will see that the `org.slf4j:slf4j-api:1.7.6`
    transitive dependency has its version increased from `1.7.6` to `1.7.7`. The `dependencyInsight`
    task already tells us more about the dependency resolution that is applied. We
    will probably start with a broad overview using the `dependencies` task, and if
    we want to get more information about a particular dependency, we will use the
    `dependencyInsight` task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is another task that we can use that will combine both the `dependencies`
    and `dependencyInsight` tasks. The `htmlDependencyReport` task is part of the
    `project-report` plugin. With this task, we get an HTML report showing all dependencies,
    and we can click on dependencies to get more insight. To use the task, we first
    add the `project-report` plugin to our example project file. The following code
    shows this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We execute the `htmlDependencyReport` task for this build file. The following
    code shows this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the task is executed, new files are created in `build/reports/project/dependencies/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we open the `index.html` file in a web browser, we can see the name of
    our project. If we had a multimodule project, we would see all project names here.
    We can click on the name and get an overview of all configurations. In the next
    screenshot, we see an overview of all the configuration in our project:![Using
    the newest version](img/image00128.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we click on the `runtime` configuration link, all dependencies are shown.
    We can see that there is a version conflict because the `org.sfl4j:slf4j-api:1.7.6`
    dependency is orange in color. This view is what we also see when the dependencies
    task from the command line is invoked:![Using the newest version](img/image00129.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the dependency insight view, we click on the `org.sfl4j:slf4j-api:1.7.6
    → 1.7.7` link. A pop-up window is opened in our web browser, and we see the following
    screenshot:![Using the newest version](img/image00130.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we see what we normally see if we run the `dependencyInsight` task from
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The `htmlDependencyReport` is very useful to get a graphical and interactive
    view of the dependencies in our project. It is also easy to get more details about
    a dependency by just clicking on it in the generated HTML reports.
  prefs: []
  type: TYPE_NORMAL
- en: Failing on version conflict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the default Gradle resolution strategy of using the newest version of a (transitive)
    dependency is not solving the problem, we can choose to let the build fail if
    there is a version conflict. To run the build successfully again, we must explicitly
    solve the version conflict in our build file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we configure the resolution strategy for
    the `runtime` configuration to fail if there is a version conflict. The `resolutionStrategy`
    method accepts a configuration closure where we invoke the `failOnVersionConflict`
    method. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The build is now configured to fail on a version conflict. We know from the
    previous examples in this chapter that there is a version conflict on `slf4j-api`.
    We now execute the `dependencies` task to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We see that the build has failed this time. In the output, we see why. There
    is a conflict between the `org.slf4j:slf4j-api:1.7.7` and `org.slf4j:slf4j-api:1.7.6`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing a version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can force Gradle to use a specific version for a dependency in our project.
    The dependency can also be transitive. We use the configuration closure for a
    dependency and set the `force` property with the value `true`. This instructs
    the Gradle dependency resolution process to always use the specified version for
    this dependency, even when the dependency is a transitive dependency in the dependency
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example build file, we have a version conflict. We can fix this by forcing
    Gradle to use the version `1.7.7` for the `org.slf4j:slf4j-api` dependency. The
    following example build file applies the `force` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `dependencies` task to see whether the version conflict is now
    resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have resolved the version conflict, and the build is now successful again.
    We can also see in the output that for the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency, the version is now the version `1.7.7`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of setting the `force` property in the dependency configuration, we
    can also force a version for a dependency as part of the `resolutionStrategy`
    method in the `configurations` configuration block. We use the `force` method
    to add a dependency with a forced version. Alternatively, we can use the `forcedModules`
    property to define all forced dependencies. This might be a better solution because
    we can have multiple dependencies with a forced version and put them all together
    in the `resolutionStrategy` configuration closure for a more readable and maintainable
    build file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we will force the version of the `org.slf4j:slf4j-api`
    dependency to be `1.7.7`, but this time as part of the `resolutionStrategy` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the `dependencies` task from the command line, we see that
    the version `1.7.7` is used for all `org.slf4j:slf4j-api` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Customizing dependency resolution rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each dependency we define in our build file, there is a dependency resolution
    rule. This rule is executed when the dependency needs to be resolved. We can customize
    this rule in our build file, so we can change certain parts of the rule before
    the dependency is actually resolved. Gradle allows us to change the dependency
    group, name, and version with a customized resolution rule. This way, we can even
    completely replace dependencies with other dependencies or force a particular
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency resolution rule details are implemented in the `org.gradle.api.artifacts.DependencyResolveDetails`
    class. Inside the `resolutionStrategy` configuration block, we use the `eachDependency`
    method to customize a resolution rule. This method accepts a closure, and the
    closure argument is an instance of `DependencyResolveDetails`. We use the `useVersion`
    and `useTarget` methods of `DependencyResolveDetails` to change either the version
    or the complete group, name, and version for a requested dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our previous example build file and define a customized resolution
    rule for the `org.slf4j:slf4j-api` dependency so that the version `1.7.7` is always
    used. In the next example build file, we will see how to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This mechanism is very powerful. Besides forcing a particular version, we can
    use the dependency resolution rules to replace a complete dependency with another.
    Let's suppose we have a dependency in our project and this dependency has a transitive
    dependency on the Log4j logging framework. We don't want this dependency, and
    instead want to use the log4j-over-slf4j bridge. This bridge contains alternative
    implementations for Log4j classes, so we can use an SLF4J API implementation.
    The log4j-over-slf4j bridge is defined by the `org.slf4j:log4j-over-slf4j:1.7.7`
    dependency. We use the `useTarget` method of the resolution rule details to set
    a new target. The method accepts both string notations and map notations for dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example build file contains the dependency resolution rule to
    replace a dependency on the `Log4j to the log4j-over-slf4j` bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the Log4j dependency is replaced with the `dependencies`
    task from the command line. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7` line, which
    visually shows the replacement of the dependency with a new dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Custom dependency resolution rules also allow us to define a custom version
    scheme. For example, in our organization, we can define that if the version of
    a dependency is set to the `fixed` value, the actual version is fetched from a
    central location on the corporate intranet. This way, all projects in the organization
    can share the same version for dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we will implement a custom version scheme.
    If the `version` attribute is omitted or has the `fixed` value, then the version
    information is fetched from a predefined list of versions. The following code
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting to see what the output of the `dependencies` task is when
    we run it from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we clearly see how the `org.slf4j:slf4j-api` dependency without
    a version is now using the version `1.7.7`. The `fixed` version of the `ch.qos.logback:logback-classic`
    dependency is resolved to the version `1.1.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Using client modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of relying on the module descriptor found in the repository for our
    external module dependency, we can define the metadata for the module in our build
    file as a client module. Remember from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining
    Dependencies"), *Defining Dependencies*, that with a client module, we define
    the module descriptor in our build file and still get the artifacts from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a client module in the following example build file. We redefine
    the transitive dependencies for the `logback-classic` dependency and use the version
    `1.7.7` for the `slf4j-api` dependency. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke the `dependencies` task from the command line to check whether the
    correct dependencies are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We see in the output that the dependency on `org.slf4j:slf4j-api` is now `1.7.7`
    and we don't have version conflict anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic versions and changing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, we already learned about dynamic versions. For example,
    we can use a range of versions such as `[4.0.1.RELEASE,4.0.4.RELEASE[`. When the
    dependency is resolved by Gradle, the latest available static version in the range
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: A changing module is different than a dynamic version. A changing module references
    a dependency with the same version but with changing artifacts. For example, in
    a Maven repository, a changing module is the snapshot module indicated by `-SNAPSHOT`
    in the `version` attribute. Gradle can resolve a changing module dependency and
    get the latest artifact for the given version. However, the next time, a new artifact
    might be downloaded because the content has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle caches dynamic versions and changing modules for 24 hours. We will see
    how we can customize this behavior in our Gradle build file and from the command
    line. However, before we take a look at the options, we will first see how Gradle
    caching works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dependency cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency cache of Gradle tries to minimize the number of remote requests
    and downloads so that builds can be fast and reliable. The cache has two parts
    to perform proper dependency caching:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it has a cache for dependency metadata (POM or Ivy descriptor files)
    for a dependency group, name, and version. Gradle keeps a separate cache for each
    repository. So, if the same dependency is found in multiple repositories, then
    the metadata information is cached in multiple dependency metadata caches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency cache also has a single cache with downloaded artifacts for the
    dependencies. The multiple metadata caches share the same cache for downloaded
    artifacts. The artifacts are stored by the SHA1 hash code of their contents and
    not by metadata, such as group, name, or version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of a metadata cache based on the repository and the artifact
    cache provides enough flexibility to perform repeatable and reliable dependency
    resolution. If the dependency metadata cannot be resolved by Gradle, then the
    dependency resolution will stop, even if the local cache has a copy of the artifact
    that was downloaded from a different repository (not defined in our build). This
    repository independence isolates builds from each other and prevents problems
    with dependency artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle first tries to determine the SHA1 checksum for an artifact file before
    downloading the artifact. If the checksum can be determined, the file will not
    be downloaded if it is already in the cache with the same checksum. Gradle also
    tries to reuse artifacts from the local Maven repository. If the checksum for
    an artifact in the local Maven repository matches the checksum for the artifact
    from the remote repository, then the artifact doesn't need to be downloaded and
    can be copied from the local Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: Because Gradle uses an SHA1 checksum for the artifact contents, different versions
    for the same artifact can be stored. For example, when an artifact is part of
    a changing module or the contents of the artifact have changed in the repository
    without a change in the version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the metadata cache and artifact cache are stored in the directory defined
    by the `GRADLE_USER_HOME` environment variable that is, by default, the `.gradle/caches`
    directory in the user home directory. Gradle uses a sophisticated locking mechanism
    for the caches, so multiple projects can use the cache directories and files simultaneously.
    In the next example build file, we create the `artifactsLocation` task to print
    out where the downloaded artifacts are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the `artifactsLocation` task, we see in the output that the
    files are stored in the `.gradle/caches` directory in the user home directory
    (`/Users/mrhaki`). We also see the SHA1 checksums with which the directory names
    are used. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Command-line options for caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `--offline` command-line option to skip any network requests.
    So, with this option, Gradle never tries to access remote repositories and all
    information is fetched from the Gradle dependency caches. If the information in
    the caches is not sufficient for a build, then the build fails.
  prefs: []
  type: TYPE_NORMAL
- en: With the `--refresh-dependencies` option, we can refresh the metadata caches.
    If, for some reason, we expect the metadata to be no longer correct, we can use
    this option. Gradle will then refresh all information in the metadata caches for
    each repository. Artifacts are only downloaded when the SHA1 checksum is different
    than the checksum for artifacts in the artifacts cache.
  prefs: []
  type: TYPE_NORMAL
- en: Changing cache expiration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dependency with a static version can be easily cached. The contents of the
    artifact has a checksum, and this can be used to either use the cache or download
    the artifact (and place it in the artifact cache). A dependency with a dynamic
    version or changing module can have a changing artifact, so we need to be able
    to customize the cache settings. We can change the expiration time for cached
    dependencies with a dynamic version and changing modules. The default expiration
    time is 24 hours. After the expiration time, Gradle will invalidate the cache
    and determine whether an artifact needs to be downloaded again.
  prefs: []
  type: TYPE_NORMAL
- en: We change the expiration time for dependencies with a dynamic version using
    the `cacheDynamicVersionsFor` method of the `resolutionStrategy` configuration
    closure. The method accepts a number and time unit to set the value for the cache
    expiration. The time unit can be either of the `java.util.concurrent.TimeUnit`
    type or a string that is converted to `TimeUnit`.
  prefs: []
  type: TYPE_NORMAL
- en: To change modules, we use the `cacheChangingModulesFor` method to change the
    expiration time. This method also accepts a number and time unit just as the `cacheDynamicVersionsFor`
    method does.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we change the cache expiration for both dynamic
    versions and changing modules for `runtime` configurations. We can also set it
    for all configurations with the `all` method and configuration block. The following
    code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Gradle knows about artifacts that are stored in a Maven repository, and that
    if the version attribute ends with `-SNAPSHOT`, the module is a changing module.
    We can also define in our build script whether a dependency is a changing module,
    for example, if this cannot be derived from the version attribute. We must set
    the `changing` property to the value `true` in the configuration closure for a
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we have the `com.vehicles:cars` dependency,
    which is a changing module, but we use the static version `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Gradle resolves dependencies and how to customize
    this. You saw how to reconfigure your build scripts to handle transitive dependencies
    and how to resolve version conflicts between dependencies in your builds. Gradle
    offers some fine-grained control on how we define dependencies and allows very
    explicit dependency definitions.
  prefs: []
  type: TYPE_NORMAL
- en: For transitive dependencies, we have several ways to redefine which dependencies
    need to be used by either disabling or excluding transitive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: When a version conflict arises between dependencies in our build, we can either
    rely on the default strategy of using the newest version or implement a custom
    strategy. Gradle has several ways to customize dependency resolution rules by
    redefining the resolution strategy. For example, we can override the version attribute
    for a dependency or even totally replace it with a compatible but different dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you saw how the dependency cache of Gradle works. It is designed to
    reduce network requests and provide reliable and repeatable builds that have dependencies.
    You learned how you can customize the expiration time for dependency modules that
    are changing or are defined with dynamic versions.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we saw how to include dependencies in our projects, but in the
    next chapter, we will see how we can publish artifacts that we created as dependencies
    for other projects.
  prefs: []
  type: TYPE_NORMAL
