- en: Chapter 3. Resolving Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, you learned how to add dependencies to your projects.
    We have seen different ways of specifying dependencies, such as module or project
    dependencies. In the previous chapter, we explored how to define the repositories
    that host our dependencies. Gradle will use this information to do the actual
    dependency resolution. In this chapter, we will see how Gradle resolves dependencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Gradle has a different way of resolving version conflicts than other build tools,
    so we will take a good look at what happens when a dependency is resolved. We
    will see how we can customize the resolution process in Gradle so that we can
    have the exact dependencies we want and have reliable and repeatable builds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency resolution
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradle will use the information in the `repositories` and `dependencies` configuration
    blocks to gather and download all dependencies. This process is also called **dependency
    resolution**. The following steps are taken by Gradle to resolve dependencies:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The module descriptor file for a dependency is searched in the defined repositories.
    The order of the repository definitions is used for searching. So, repositories
    defined before other repositories are searched first, and so on. If a POM or Ivy
    descriptor file is found, it is used. If no descriptor file is found, then the
    artifact file for the dependency is searched. If either the descriptor file or
    the artifact file is found, then Gradle knows this repository can be used to download
    the dependencies.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a POM descriptor file is found with a parent POM descriptor file, then the
    parent POM is resolved by Gradle.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic version, like *4.1.+*, is resolved to the highest available static
    version in the repository. For example if the repository contains versions *4.1.0*
    and *4.1.1* then the *4.1.1* version is used.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gradle will determine which repository is the best to use based on the following
    criteria:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module descriptor files, like POM and Ivy descriptor files, are preferred over
    artifact file only.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies found in earlier repositories are preferred over later repositories.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a dynamic version like *2.+* is used, than a higher static version is preferred
    over a lower static version.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The artifacts for the module dependency are downloaded from the repository that
    is chosen by Gradle. This means that artifacts are not downloaded from a different
    repository than where the descriptor file or artifact file for the defined dependency
    are found.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a dependency is defined with a static version, and Gradle finds a module
    descriptor file for this dependency in a repository, then the search for this
    dependency is complete, and other repositories will not be used for the search.
    The process cannot come up with a better repository candidate, so the dependency
    resolution is finished for the dependency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Configuring transitive dependencies
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time dependencies in our project are also dependent on other libraries.
    So, the dependencies have dependencies of their own. These are so-called transitive
    dependencies. Gradle must be able to resolve the transitive dependencies as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们项目中的依赖项也依赖于其他库。因此，这些依赖项有自己的依赖项。这些被称为传递依赖项。Gradle 必须能够解析传递依赖项。
- en: 'In the following example build file, we define the `logback-classic` module
    dependency with the version `1.1.2` and the group name `ch.qos.logback`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用版本 `1.1.2` 和组名 `ch.qos.logback` 定义了 `logback-classic` 模块依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run the Gradle `dependencies` task, we can see that our defined dependency
    for `logback-classic` depends on `ch.qos.logback:logback-core:1.1.2` and `org.slf4j:slf4j-api:1.7.6`.
    The following code shows this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 Gradle 的 `dependencies` 任务时，我们可以看到我们定义的 `logback-classic` 依赖项依赖于 `ch.qos.logback:logback-core:1.1.2`
    和 `org.slf4j:slf4j-api:1.7.6`。以下代码显示了这一点：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Disabling transitive dependencies
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用传递依赖项
- en: If we don't want to have transitive dependencies in our project, we must reconfigure
    the dependency or configuration. With Gradle, we have different ways to disable
    transitive behavior for dependencies. First, we can add a configuration closure
    to our dependency definition, use the `transitive` property, and set the value
    to `false`. By default, all dependencies are treated as transitive, as we saw
    in our example build file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在我们的项目中包含传递依赖项，我们必须重新配置依赖项或配置。使用 Gradle，我们有不同的方法来禁用依赖项的传递行为。首先，我们可以在依赖定义中添加一个配置闭包，使用
    `transitive` 属性，并将其值设置为 `false`。默认情况下，所有依赖项都被视为传递依赖项，正如我们在示例构建文件中看到的那样。
- en: 'In the following example build file, we specify that we want to treat or use
    the `logback-classic` dependency as nontransitive:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们指定我们想要将 `logback-classic` 依赖项视为非传递依赖项：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the `dependencies` task again, we can see in the output that the
    transitive dependencies are no longer resolved:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行 `dependencies` 任务，我们可以在输出中看到传递依赖项不再被解析：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also disable transitive dependencies for a dependency configuration
    as a whole. So, this means that any dependencies defined with the configuration
    will not have transitive dependencies. Single dependencies within the configuration
    can use the `transitive` property in the configuration closure to enable transitive
    behavior again for that dependency. To accomplish this, perform the following
    steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以完全禁用依赖项配置中的传递依赖项。这意味着使用该配置定义的任何依赖项都不会有传递依赖项。配置中的单个依赖项可以在配置闭包中使用 `transitive`
    属性来再次启用该依赖项的传递行为。要完成此操作，请执行以下步骤：
- en: 'First, we will disable transitive dependencies for the `compile` configuration
    in the next example build file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在下一个示例构建文件中禁用 `compile` 配置的传递依赖项：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will execute the `dependencies` task and see that transitive dependencies
    are no longer resolved:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行 `dependencies` 任务，并看到传递依赖项不再被解析：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Excluding transitive dependencies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除传递依赖项
- en: We can also have more fine-grained control of transitive dependencies. We can
    exclude certain transitive dependencies in our dependency definition. This way,
    we can choose to use only certain transitive dependencies and leave others out.
    To define which transitive dependencies we want to exclude, we use the `exclude`
    method in the configuration closure of our dependency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对传递依赖项有更精细的控制。我们可以在依赖定义中排除某些传递依赖项。这样，我们可以选择只使用某些传递依赖项，而排除其他依赖项。要定义我们想要排除的传递依赖项，我们使用依赖项配置闭包中的
    `exclude` 方法。
- en: 'Let''s see how we can include the `logback-core` transitive dependency but
    remove the `slf4j-api` dependency. We use the `exclude` method in the configuration
    closure. The `exclude` method takes `Map` as an argument with one or both of the
    keys: `module` and `group`. In the following build file, we include the `logback-core`
    transitive dependency:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何包含 `logback-core` 传递依赖项，但移除 `slf4j-api` 依赖项。我们在配置闭包中使用 `exclude` 方法。`exclude`
    方法接受一个 `Map` 作为参数，其中包含一个或两个键：`module` 和 `group`。在以下构建文件中，我们包含 `logback-core` 传递依赖项：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We execute the `dependencies` task to see whether our configuration definition
    has the desired effect:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行 `dependencies` 任务以查看我们的配置定义是否具有预期的效果：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in the output, the transitive dependency, `org.slf4j:slf4j-api:1.7.6`,
    is no longer part of our transitive dependencies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在输出中，传递依赖项 `org.slf4j:slf4j-api:1.7.6` 已不再是我们的传递依赖项的一部分。
- en: 'We can also set exclude rules on a configuration in addition to a single dependency.
    The exclude rule on a configuration will be used for all dependencies defined
    within the configuration. In the next example Gradle build file, we will exclude
    the `slf4j-api` module from all dependencies in the `compile` configuration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在单个依赖项之外对配置设置排除规则。配置上的排除规则将用于配置中定义的所有依赖项。在下一个示例 Gradle 构建文件中，我们将从 `compile`
    配置中排除 `slf4j-api` 模块：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Any exclude rule that we add to either the configuration or the dependency
    is accessible again via the `excludeRules` property of the corresponding objects.
    We can use this to find out the configuration or dependency that is responsible
    for excluding a certain dependency. In the following example build file, we create
    a new task, `showExcludeRules`, where we loop through all configurations and dependencies
    and collect exclude rules. At the end of the task, we print all the information
    to standard output. The following code shows this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到配置或依赖项中的任何排除规则都可以通过相应对象的 `excludeRules` 属性再次访问。我们可以使用此属性来找出负责排除特定依赖项的配置或依赖项。在以下示例构建文件中，我们创建了一个新的任务
    `showExcludeRules`，其中我们遍历所有配置和依赖项并收集排除规则。在任务的末尾，我们将所有信息打印到标准输出。以下代码显示了这一点：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the task, we get the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行任务时，我们得到以下输出：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using artifact-only dependencies
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用仅软件包依赖项
- en: Finally, we can use the `ext` attribute for an external module dependency if
    we know we only want to include a single artifact from the dependency. With this
    attribute, no transitive dependencies are resolved because we specify that we
    specifically want the artifact specified by the `ext` attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们知道我们只想包含依赖项中的一个软件包，我们可以使用 `ext` 属性来为外部模块依赖项。使用此属性，不会解决传递依赖项，因为我们指定了我们特别想要由
    `ext` 属性指定的软件包。
- en: 'In our example, we can use the `ext` attribute with the `jar` value to resolve
    only the JAR artifact for the `logback-classic` dependency. In the next example
    build file, we will use the `ext` attribute for our `logback-classic` dependency:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以使用具有 `jar` 值的 `ext` 属性来仅解决 `logback-classic` 依赖项的 JAR 软件包。在下一个示例构建文件中，我们将使用
    `ext` 属性为我们的 `logback-classic` 依赖项：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Resolving version conflicts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决版本冲突
- en: Our previous examples were simple and only contained one dependency with some
    transitive dependencies. When we add more dependencies to our project, or have
    a multimodule project where each project has a lot of dependencies, then it can
    happen that the same dependency or transitive dependency is included multiple
    times. Gradle detects this and makes sure that the dependency is only downloaded
    once. We will see more about the advanced dependency cache management in Gradle
    later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例很简单，只包含一个依赖项和一些传递依赖项。当我们向我们的项目添加更多依赖项，或者有一个多模块项目，其中每个项目都有很多依赖项时，可能会发生相同或传递依赖项被多次包含的情况。Gradle
    会检测到这一点，并确保依赖项只下载一次。我们将在 Gradle 中稍后看到关于高级依赖项缓存管理的更多内容。
- en: 'The trouble begins when the same dependency is included multiple times but
    with different versions. Which version of the dependency should be used? This
    is where Gradle''s resolution strategy comes into play. The next table shows the
    resolution strategies that Gradle has:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一个依赖被多次包含但版本不同时，问题就开始了。应该使用哪个版本的依赖？这正是 Gradle 的解析策略发挥作用的地方。下表显示了 Gradle 具有的解析策略：
- en: '| Name | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Newest | The newest version of a conflicting dependency is used. This is
    the default strategy used by Gradle. If the versions of the conflicting dependency
    are backward compatible, this works fine. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 最新版 | 使用冲突依赖项的最新版本。这是 Gradle 使用的默认策略。如果冲突依赖项的版本向后兼容，则此策略有效。|'
- en: '| Fail | The build process fails when there is a version conflict with dependencies.
    We must explicitly add code to our build file that will resolve the version conflict.
    We will see later in this chapter how we can customize the resolution strategy
    to solve version conflicts explicitly. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 失败 | 当依赖项存在版本冲突时，构建过程会失败。我们必须明确地在我们的构建文件中添加代码来解决版本冲突。我们将在本章后面看到如何自定义解析策略来显式解决版本冲突。|'
- en: Using the newest version
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最新版本
- en: 'Let''s see what happens if we have a version conflict and use the default resolution
    strategy of Gradle. Gradle will use the newest version of the dependency that
    has a version conflict. To accomplish this, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next build file, we define a dependency on `slf4j-api` in the `compile`
    configuration and on `logback-classic` in the `runtime` configuration:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We run the `dependencies` task to see which versions of the dependencies are
    used. The following output shows that the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency of `logback-classic` is changed, so the version `1.7.7` is used, which
    is defined in the `compile` configuration:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the line `org.slf4j:slf4j-api:1.7.6 → 1.7.7`, where it visually shows
    that the version is increased for this dependency from `1.7.6` to `1.7.7`.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `dependencies` task shows a hierarchical tree view of the dependencies and
    transitive dependencies. To get a view from a specific dependency, and to see
    how it got in the dependency graph, we use the `dependencyInsight` task. With
    this task, we can see how the dependency is resolved and whether any conflict
    resolution has happened.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must use the following two options when we invoke the `dependencyInsight`
    task from the command line:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify the configuration of the dependency with the `--configuration` option.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `--dependency` option to specify the name of the dependency.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the dependency doesn't have to be the full name; we can even use
    part of the name. For example, we can use `org.slf4j:slf4j-api`, `slf4j-api`,
    and `slf4j` to gain insight into a dependency.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We execute the `dependencyInsight` task to see more information about the `slf4j-api`
    dependency in our example build file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the output, we see that the `org.slf4j:slf4j-api:1.7.7` dependency is resolved
    for the `runtime` configuration and that conflict resolution has happened for
    the dependency. In the next lines, we will see that the `org.slf4j:slf4j-api:1.7.6`
    transitive dependency has its version increased from `1.7.6` to `1.7.7`. The `dependencyInsight`
    task already tells us more about the dependency resolution that is applied. We
    will probably start with a broad overview using the `dependencies` task, and if
    we want to get more information about a particular dependency, we will use the
    `dependencyInsight` task.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is another task that we can use that will combine both the `dependencies`
    and `dependencyInsight` tasks. The `htmlDependencyReport` task is part of the
    `project-report` plugin. With this task, we get an HTML report showing all dependencies,
    and we can click on dependencies to get more insight. To use the task, we first
    add the `project-report` plugin to our example project file. The following code
    shows this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We execute the `htmlDependencyReport` task for this build file. The following
    code shows this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After the task is executed, new files are created in `build/reports/project/dependencies/`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we open the `index.html` file in a web browser, we can see the name of
    our project. If we had a multimodule project, we would see all project names here.
    We can click on the name and get an overview of all configurations. In the next
    screenshot, we see an overview of all the configuration in our project:![Using
    the newest version](img/image00128.jpeg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we click on the `runtime` configuration link, all dependencies are shown.
    We can see that there is a version conflict because the `org.sfl4j:slf4j-api:1.7.6`
    dependency is orange in color. This view is what we also see when the dependencies
    task from the command line is invoked:![Using the newest version](img/image00129.jpeg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the dependency insight view, we click on the `org.sfl4j:slf4j-api:1.7.6
    → 1.7.7` link. A pop-up window is opened in our web browser, and we see the following
    screenshot:![Using the newest version](img/image00130.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we see what we normally see if we run the `dependencyInsight` task from
    the command line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `htmlDependencyReport` is very useful to get a graphical and interactive
    view of the dependencies in our project. It is also easy to get more details about
    a dependency by just clicking on it in the generated HTML reports.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Failing on version conflict
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the default Gradle resolution strategy of using the newest version of a (transitive)
    dependency is not solving the problem, we can choose to let the build fail if
    there is a version conflict. To run the build successfully again, we must explicitly
    solve the version conflict in our build file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we configure the resolution strategy for
    the `runtime` configuration to fail if there is a version conflict. The `resolutionStrategy`
    method accepts a configuration closure where we invoke the `failOnVersionConflict`
    method. The following code shows this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The build is now configured to fail on a version conflict. We know from the
    previous examples in this chapter that there is a version conflict on `slf4j-api`.
    We now execute the `dependencies` task to see what happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see that the build has failed this time. In the output, we see why. There
    is a conflict between the `org.slf4j:slf4j-api:1.7.7` and `org.slf4j:slf4j-api:1.7.6`
    modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Forcing a version
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can force Gradle to use a specific version for a dependency in our project.
    The dependency can also be transitive. We use the configuration closure for a
    dependency and set the `force` property with the value `true`. This instructs
    the Gradle dependency resolution process to always use the specified version for
    this dependency, even when the dependency is a transitive dependency in the dependency
    graph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example build file, we have a version conflict. We can fix this by forcing
    Gradle to use the version `1.7.7` for the `org.slf4j:slf4j-api` dependency. The
    following example build file applies the `force` property:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s run the `dependencies` task to see whether the version conflict is now
    resolved:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have resolved the version conflict, and the build is now successful again.
    We can also see in the output that for the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency, the version is now the version `1.7.7`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了版本冲突，构建现在再次成功。我们还可以在输出中看到，对于 `org.slf4j:slf4j-api:1.7.6` 传递依赖项，版本现在是
    `1.7.7`。
- en: Instead of setting the `force` property in the dependency configuration, we
    can also force a version for a dependency as part of the `resolutionStrategy`
    method in the `configurations` configuration block. We use the `force` method
    to add a dependency with a forced version. Alternatively, we can use the `forcedModules`
    property to define all forced dependencies. This might be a better solution because
    we can have multiple dependencies with a forced version and put them all together
    in the `resolutionStrategy` configuration closure for a more readable and maintainable
    build file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在依赖项配置中设置 `force` 属性外，我们还可以在 `configurations` 配置块的 `resolutionStrategy` 方法中作为依赖项的一部分强制设置版本。我们使用
    `force` 方法添加具有强制版本的依赖项。或者，我们可以使用 `forcedModules` 属性来定义所有强制依赖项。这可能是一个更好的解决方案，因为我们可以在
    `resolutionStrategy` 配置闭包中将具有强制版本的多个依赖项放在一起，从而使构建文件更易于阅读和维护。
- en: 'In the next example build file, we will force the version of the `org.slf4j:slf4j-api`
    dependency to be `1.7.7`, but this time as part of the `resolutionStrategy` configuration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将强制 `org.slf4j:slf4j-api` 依赖项的版本为 `1.7.7`，但这次作为 `resolutionStrategy`
    配置的一部分：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we execute the `dependencies` task from the command line, we see that
    the version `1.7.7` is used for all `org.slf4j:slf4j-api` dependencies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行执行 `dependencies` 任务时，我们看到所有 `org.slf4j:slf4j-api` 依赖项都使用了版本 `1.7.7`：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Customizing dependency resolution rules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义依赖项解析规则
- en: For each dependency we define in our build file, there is a dependency resolution
    rule. This rule is executed when the dependency needs to be resolved. We can customize
    this rule in our build file, so we can change certain parts of the rule before
    the dependency is actually resolved. Gradle allows us to change the dependency
    group, name, and version with a customized resolution rule. This way, we can even
    completely replace dependencies with other dependencies or force a particular
    version.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在构建文件中定义的每个依赖项，都有一个依赖项解析规则。当需要解析依赖项时，将执行此规则。我们可以在构建文件中自定义此规则，因此我们可以在依赖项实际解析之前更改规则的某些部分。Gradle
    允许我们通过自定义解析规则来更改依赖项组、名称和版本。这样，我们甚至可以用其他依赖项完全替换依赖项或强制使用特定版本。
- en: Dependency resolution rule details are implemented in the `org.gradle.api.artifacts.DependencyResolveDetails`
    class. Inside the `resolutionStrategy` configuration block, we use the `eachDependency`
    method to customize a resolution rule. This method accepts a closure, and the
    closure argument is an instance of `DependencyResolveDetails`. We use the `useVersion`
    and `useTarget` methods of `DependencyResolveDetails` to change either the version
    or the complete group, name, and version for a requested dependency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项解析规则细节在 `org.gradle.api.artifacts.DependencyResolveDetails` 类中实现。在 `resolutionStrategy`
    配置块内部，我们使用 `eachDependency` 方法来自定义解析规则。此方法接受一个闭包，闭包参数是 `DependencyResolveDetails`
    的一个实例。我们使用 `DependencyResolveDetails` 的 `useVersion` 和 `useTarget` 方法来更改请求的依赖项的版本或完整的组、名称和版本。
- en: 'Let''s change our previous example build file and define a customized resolution
    rule for the `org.slf4j:slf4j-api` dependency so that the version `1.7.7` is always
    used. In the next example build file, we will see how to achieve this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改之前的示例构建文件，并为 `org.slf4j:slf4j-api` 依赖项定义一个自定义解析规则，以便始终使用版本 `1.7.7`。在下一个示例构建文件中，我们将看到如何实现这一点：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This mechanism is very powerful. Besides forcing a particular version, we can
    use the dependency resolution rules to replace a complete dependency with another.
    Let's suppose we have a dependency in our project and this dependency has a transitive
    dependency on the Log4j logging framework. We don't want this dependency, and
    instead want to use the log4j-over-slf4j bridge. This bridge contains alternative
    implementations for Log4j classes, so we can use an SLF4J API implementation.
    The log4j-over-slf4j bridge is defined by the `org.slf4j:log4j-over-slf4j:1.7.7`
    dependency. We use the `useTarget` method of the resolution rule details to set
    a new target. The method accepts both string notations and map notations for dependencies.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制非常强大。除了强制指定特定版本外，我们还可以使用依赖项解析规则将完整的依赖项替换为另一个依赖项。假设我们项目中的一个依赖项有一个对Log4j日志框架的传递依赖。我们不希望这个依赖项，而是想使用log4j-over-slf4j桥接。这个桥接包含Log4j类的替代实现，因此我们可以使用SLF4J
    API实现。log4j-over-slf4j桥接由`org.slf4j:log4j-over-slf4j:1.7.7`依赖项定义。我们使用解析规则细节的`useTarget`方法设置新的目标。该方法接受依赖项的字符串表示法和映射表示法。
- en: 'The following example build file contains the dependency resolution rule to
    replace a dependency on the `Log4j to the log4j-over-slf4j` bridge:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例构建文件包含替换`Log4j`依赖项到`log4j-over-slf4j`桥接的依赖项解析规则：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can verify that the Log4j dependency is replaced with the `dependencies`
    task from the command line. This is shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令行验证Log4j依赖项是否被`dependencies`任务替换。以下代码显示了这一点：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the `log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7` line, which
    visually shows the replacement of the dependency with a new dependency.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7`这一行，它直观地显示了依赖项被新的依赖项替换。
- en: Custom dependency resolution rules also allow us to define a custom version
    scheme. For example, in our organization, we can define that if the version of
    a dependency is set to the `fixed` value, the actual version is fetched from a
    central location on the corporate intranet. This way, all projects in the organization
    can share the same version for dependencies.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义依赖项解析规则还允许我们定义自定义版本方案。例如，在我们的组织中，我们可以定义如果依赖项的版本设置为`fixed`值，则实际版本将从企业内部网络的中央位置获取。这样，组织中的所有项目都可以共享依赖项的相同版本。
- en: 'In the next example build file, we will implement a custom version scheme.
    If the `version` attribute is omitted or has the `fixed` value, then the version
    information is fetched from a predefined list of versions. The following code
    shows this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将实现自定义版本方案。如果省略了`version`属性或具有`fixed`值，则版本信息将从预定义的版本列表中获取。以下代码显示了这一点：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is interesting to see what the output of the `dependencies` task is when
    we run it from the command line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行`dependencies`任务时，看到其输出是很有趣的：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the output, we clearly see how the `org.slf4j:slf4j-api` dependency without
    a version is now using the version `1.7.7`. The `fixed` version of the `ch.qos.logback:logback-classic`
    dependency is resolved to the version `1.1.2`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以清楚地看到没有版本号的`org.slf4j:slf4j-api`依赖项现在使用的是版本`1.7.7`。`ch.qos.logback:logback-classic`依赖项的`fixed`版本解析为版本`1.1.2`。
- en: Using client modules
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端模块
- en: Instead of relying on the module descriptor found in the repository for our
    external module dependency, we can define the metadata for the module in our build
    file as a client module. Remember from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining
    Dependencies"), *Defining Dependencies*, that with a client module, we define
    the module descriptor in our build file and still get the artifacts from the repository.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不在存储库中找到的模块描述符上依赖外部模块依赖项，而是在我们的构建文件中将模块的元数据定义为客户端模块。记得从[第1章](part0014.xhtml#aid-DB7S1
    "第1章。定义依赖项")，*定义依赖项*，中提到的，使用客户端模块，我们在构建文件中定义模块描述符，并仍然从存储库获取工件。
- en: 'Let''s use a client module in the following example build file. We redefine
    the transitive dependencies for the `logback-classic` dependency and use the version
    `1.7.7` for the `slf4j-api` dependency. The following code shows this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下示例构建文件中使用客户端模块。我们重新定义了`logback-classic`依赖项的传递依赖，并使用`slf4j-api`依赖项的版本`1.7.7`。以下代码显示了这一点：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We invoke the `dependencies` task from the command line to check whether the
    correct dependencies are used:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从命令行调用`dependencies`任务来检查是否使用了正确的依赖项：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We see in the output that the dependency on `org.slf4j:slf4j-api` is now `1.7.7`
    and we don't have version conflict anymore.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic versions and changing modules
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, we already learned about dynamic versions. For example,
    we can use a range of versions such as `[4.0.1.RELEASE,4.0.4.RELEASE[`. When the
    dependency is resolved by Gradle, the latest available static version in the range
    is selected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: A changing module is different than a dynamic version. A changing module references
    a dependency with the same version but with changing artifacts. For example, in
    a Maven repository, a changing module is the snapshot module indicated by `-SNAPSHOT`
    in the `version` attribute. Gradle can resolve a changing module dependency and
    get the latest artifact for the given version. However, the next time, a new artifact
    might be downloaded because the content has changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Gradle caches dynamic versions and changing modules for 24 hours. We will see
    how we can customize this behavior in our Gradle build file and from the command
    line. However, before we take a look at the options, we will first see how Gradle
    caching works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dependency cache
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency cache of Gradle tries to minimize the number of remote requests
    and downloads so that builds can be fast and reliable. The cache has two parts
    to perform proper dependency caching:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: First, it has a cache for dependency metadata (POM or Ivy descriptor files)
    for a dependency group, name, and version. Gradle keeps a separate cache for each
    repository. So, if the same dependency is found in multiple repositories, then
    the metadata information is cached in multiple dependency metadata caches.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency cache also has a single cache with downloaded artifacts for the
    dependencies. The multiple metadata caches share the same cache for downloaded
    artifacts. The artifacts are stored by the SHA1 hash code of their contents and
    not by metadata, such as group, name, or version.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of a metadata cache based on the repository and the artifact
    cache provides enough flexibility to perform repeatable and reliable dependency
    resolution. If the dependency metadata cannot be resolved by Gradle, then the
    dependency resolution will stop, even if the local cache has a copy of the artifact
    that was downloaded from a different repository (not defined in our build). This
    repository independence isolates builds from each other and prevents problems
    with dependency artifacts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Gradle first tries to determine the SHA1 checksum for an artifact file before
    downloading the artifact. If the checksum can be determined, the file will not
    be downloaded if it is already in the cache with the same checksum. Gradle also
    tries to reuse artifacts from the local Maven repository. If the checksum for
    an artifact in the local Maven repository matches the checksum for the artifact
    from the remote repository, then the artifact doesn't need to be downloaded and
    can be copied from the local Maven repository.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Because Gradle uses an SHA1 checksum for the artifact contents, different versions
    for the same artifact can be stored. For example, when an artifact is part of
    a changing module or the contents of the artifact have changed in the repository
    without a change in the version number.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the metadata cache and artifact cache are stored in the directory defined
    by the `GRADLE_USER_HOME` environment variable that is, by default, the `.gradle/caches`
    directory in the user home directory. Gradle uses a sophisticated locking mechanism
    for the caches, so multiple projects can use the cache directories and files simultaneously.
    In the next example build file, we create the `artifactsLocation` task to print
    out where the downloaded artifacts are stored:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we execute the `artifactsLocation` task, we see in the output that the
    files are stored in the `.gradle/caches` directory in the user home directory
    (`/Users/mrhaki`). We also see the SHA1 checksums with which the directory names
    are used. The following code shows this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Command-line options for caching
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `--offline` command-line option to skip any network requests.
    So, with this option, Gradle never tries to access remote repositories and all
    information is fetched from the Gradle dependency caches. If the information in
    the caches is not sufficient for a build, then the build fails.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: With the `--refresh-dependencies` option, we can refresh the metadata caches.
    If, for some reason, we expect the metadata to be no longer correct, we can use
    this option. Gradle will then refresh all information in the metadata caches for
    each repository. Artifacts are only downloaded when the SHA1 checksum is different
    than the checksum for artifacts in the artifacts cache.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Changing cache expiration
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dependency with a static version can be easily cached. The contents of the
    artifact has a checksum, and this can be used to either use the cache or download
    the artifact (and place it in the artifact cache). A dependency with a dynamic
    version or changing module can have a changing artifact, so we need to be able
    to customize the cache settings. We can change the expiration time for cached
    dependencies with a dynamic version and changing modules. The default expiration
    time is 24 hours. After the expiration time, Gradle will invalidate the cache
    and determine whether an artifact needs to be downloaded again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We change the expiration time for dependencies with a dynamic version using
    the `cacheDynamicVersionsFor` method of the `resolutionStrategy` configuration
    closure. The method accepts a number and time unit to set the value for the cache
    expiration. The time unit can be either of the `java.util.concurrent.TimeUnit`
    type or a string that is converted to `TimeUnit`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To change modules, we use the `cacheChangingModulesFor` method to change the
    expiration time. This method also accepts a number and time unit just as the `cacheDynamicVersionsFor`
    method does.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we change the cache expiration for both dynamic
    versions and changing modules for `runtime` configurations. We can also set it
    for all configurations with the `all` method and configuration block. The following
    code shows this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Gradle knows about artifacts that are stored in a Maven repository, and that
    if the version attribute ends with `-SNAPSHOT`, the module is a changing module.
    We can also define in our build script whether a dependency is a changing module,
    for example, if this cannot be derived from the version attribute. We must set
    the `changing` property to the value `true` in the configuration closure for a
    dependency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we have the `com.vehicles:cars` dependency,
    which is a changing module, but we use the static version `1.0`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Gradle resolves dependencies and how to customize
    this. You saw how to reconfigure your build scripts to handle transitive dependencies
    and how to resolve version conflicts between dependencies in your builds. Gradle
    offers some fine-grained control on how we define dependencies and allows very
    explicit dependency definitions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: For transitive dependencies, we have several ways to redefine which dependencies
    need to be used by either disabling or excluding transitive dependencies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: When a version conflict arises between dependencies in our build, we can either
    rely on the default strategy of using the newest version or implement a custom
    strategy. Gradle has several ways to customize dependency resolution rules by
    redefining the resolution strategy. For example, we can override the version attribute
    for a dependency or even totally replace it with a compatible but different dependency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you saw how the dependency cache of Gradle works. It is designed to
    reduce network requests and provide reliable and repeatable builds that have dependencies.
    You learned how you can customize the expiration time for dependency modules that
    are changing or are defined with dynamic versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we saw how to include dependencies in our projects, but in the
    next chapter, we will see how we can publish artifacts that we created as dependencies
    for other projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
