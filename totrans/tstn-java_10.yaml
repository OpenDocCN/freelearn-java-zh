- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing Software Design Principles and Patterns in Java
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中实现软件设计原则和模式
- en: Software design principles provide guidance on how you construct your classes
    and how your objects should interact. They are not tied to a specific problem.
    For example, the **single responsibility** principle encourages us to write methods
    that perform a single task. Software design patterns are reusable concepts for
    solving common problems in software design. For example, should we need to have
    a single instance of an object in an application, you will want to use the **Singleton**
    pattern. This pattern has nothing to do with the language you are using, nor does
    it describe the required code for the pattern. What these principles and patterns
    do is describe a solution to common problems that you can then implement in the
    language you are using. Principles and patterns can be applied to any language,
    and I will assume that you have likely applied them in whatever language you are
    coming from.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计原则提供了如何构建你的类以及你的对象应该如何交互的指导。它们与特定问题无关。例如，**单一职责**原则鼓励我们编写执行单一任务的方法。软件设计模式是解决软件设计中常见问题的可重用概念。例如，如果我们需要在应用程序中有一个对象的单一实例，你将希望使用**单例**模式。这个模式与你所使用的语言无关，也不描述该模式的必需代码。这些原则和模式所做的是描述解决常见问题的方案，然后你可以将这些方案实现在你所使用的语言中。原则和模式可以应用于任何语言，并且我假设你很可能在你所使用的语言中已经应用了它们。
- en: 'The goal of this chapter is to look at a handful of the most commonly used
    principles and patterns and how they are coded in Java. They are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是查看一些最常用的原则和模式，以及它们如何在Java中编码。它们如下所示：
- en: SOLID software design principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID软件设计原则
- en: Software design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设计模式
- en: As a software developer, you are expected to write code that is reusable, understandable,
    flexible, and maintainable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，你被期望编写可重用、可理解、灵活且可维护的代码。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行本章示例所需的工具：
- en: Java 17 installed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Java 17
- en: Text editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Maven 3.8.6或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10)找到。
- en: SOLID software design principles
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID软件设计原则
- en: Software design principles, as applied to object-oriented programming, provide
    guidelines for how you construct your classes. Unlike patterns that are tied to
    specific coding requirements, principles should be considered for any code that
    you write every day. There are numerous principles, but we will look at five principles
    that fall under the acronym **SOLID**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计原则，应用于面向对象编程，提供了如何构建你的类的指导方针。与特定编码要求相关的模式不同，原则应该适用于你每天编写的任何代码。有许多原则，但我们将探讨五个属于缩写**SOLID**的原则。
- en: S – Separation of concerns/single responsibility
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: S – 关注点分离/单一职责
- en: 'In my opinion, `CompoundInterest05` program and organized the classes based
    on functionality:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`CompoundInterest05`程序根据功能组织了类：
- en: '![Figure 10.1 – Class organization for the separation of concerns principle](img/B19088_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 基于关注点分离原则的类组织](img/B19088_10_01.jpg)'
- en: Figure 10.1 – Class organization for the separation of concerns principle
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 基于关注点分离原则的类组织
- en: What we see in this figure are four packages that describe the required functionality
    of any classes in the package. The individual classes in each package contain
    any methods and data structures required to carry out their task. The business
    class is independent of the **user interface** (**UI**) class. We can change the
    UI class to employ a GUI rather than a text or console interface. We can do this
    without the need to make any changes to the business class. We will do just this
    in [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254), *Desktop Graphical User Interface
    Coding with Swing and JavaFX*, when we change the UI from text to GUI. We will
    even turn this application into a web app in [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301),
    *Jakarta Faces Application*, leaving the business and data classes untouched.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中我们看到四个包，它们描述了包中任何类所需的功能。每个包中的单个类包含执行其任务所需的所有方法和数据结构。业务类独立于**用户界面**（**UI**）类。我们可以将UI类改为使用GUI而不是文本或控制台界面。我们可以这样做而不需要对业务类进行任何修改。我们将在[*第13章*](B19088_13.xhtml#_idTextAnchor254)，*使用Swing和JavaFX进行桌面图形用户界面编码*中这样做，当我们从文本改为GUI时。我们甚至将在[*第15章*](B19088_15.xhtml#_idTextAnchor301)，*Jakarta
    Faces应用程序*中将这个应用程序转变为一个网络应用程序，而不会触及业务和数据类。
- en: The single responsibility principle is not technically part of SOLID but its
    close association with the separation of concerns merits including it here. This
    principle is applied to methods. A single method should be written to be responsible
    for a single concern. You would not write a single method that performs a calculation
    and then displays the result. These are two concerns, and each belongs to its
    own method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则虽然在技术上不是SOLID的一部分，但它与关注点分离的紧密关联使其值得在这里包括。这个原则应用于方法。应该编写一个方法来负责单一的关注点。你不会编写一个执行计算然后显示结果的单个方法。这些是两个关注点，每个都应属于其自己的方法。
- en: O – Open/closed
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: O – 开放/封闭
- en: This principle states that you should be able to add to or extend a class’s
    functionality, the open part, without changing or modifying any code in the class,
    the closed part. This can be accomplished using either inheritance or interface.
    Consider our `CompoundInterestCalculator05.java` example. It contains a single
    calculation for compound interest. What if I’d like to add another calculation?
    Should I just edit this file and add a new method for the new calculation? The
    answer is no.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，你应该能够在不更改或修改类的任何代码的情况下添加或扩展类的功能，即开放部分，而不改变或修改类的封闭部分。这可以通过继承或接口来实现。考虑我们的`CompoundInterestCalculator05.java`示例。它包含一个复利计算的单一计算。如果我想要添加另一个计算呢？我应该只是编辑这个文件并添加一个新的方法来处理新的计算吗？答案是：不。
- en: 'If I use inheritance, I will create a new class that extends the original single
    calculation and adds the new calculation. Here is a class that implements a method
    to calculate loan payments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用继承，我将创建一个新的类，它扩展了原始的单个计算并添加了新的计算。这里是一个实现计算贷款还款方法的类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You have thoroughly tested this calculation and you are confident that it is
    correct. Now, you are asked to add two more calculations, one for the savings
    goal and the other for the future value of regular savings. The open/closed principle
    tells us that we should not modify this class. Although it''s a simple example,
    there is still the possibility that you may inadvertently change something in
    this class when you add methods to it. The solution is inheritance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经彻底测试了这个计算，并且你确信它是正确的。现在，你被要求添加两个更多的计算，一个用于储蓄目标，另一个用于定期储蓄的未来价值。开放/封闭原则告诉我们不应该修改这个类。尽管这是一个简单的例子，但在添加方法时，你仍然有可能无意中在这个类中更改某些内容。解决方案是继承：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `Calculator2` class inherits the public `loanCalculator` method from the
    `Calculator` superclass and then adds the two new calculations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Calculator2`类从`Calculator`超类继承了公共的`loanCalculator`方法，然后添加了两个新的计算。
- en: 'The second approach, called the polymorphic open/closed principle, is to use
    an interface class. This is the closed class. All calculations must implement
    this interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，称为多态开放/封闭原则，是使用接口类。这是一个封闭类。所有计算都必须实现这个接口：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let us look at one of the three classes that will implement this interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将要实现这个接口的三个类中的一个：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can write a class that can call upon any of these operations. If we
    wish to add new financial calculations, we can without modifying this class, as
    it expects to receive a reference to an object that implements the `FinanceCalculate`
    interface:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个可以调用这些操作中的任何一个的类。如果我们希望添加新的财务计算，我们可以在不修改此类的情况下做到这一点，因为它期望接收一个实现`FinanceCalculate`接口的对象的引用：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As new features are added to an application, you want to accomplish this without
    modifying existing code. There is one exception, and that is to correct bugs.
    This will likely require modifications to the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新功能被添加到应用程序中，你希望在不修改现有代码的情况下完成这一点。有一个例外，那就是纠正错误。这可能会要求修改代码。
- en: L – Liskov substitution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: L – Liskov替换
- en: This principle describes how to use inheritance effectively. Put simply, when
    you create a new class that extends an existing class, you can override methods
    in the superclass. What you must not do is reuse a superclass method name and
    change its return type or the number or type of parameters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则描述了如何有效地使用继承。简单来说，当你创建一个新的类来扩展一个现有类时，你可以重写超类中的方法。你必须不做的事情是重用超类方法名并更改其返回类型或参数的数量或类型。
- en: 'Here is a very simple superclass that displays a message:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常简单的显示消息的超类：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let us create a subclass that displays a slightly different message:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个子类，它显示一条略有不同的消息：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we override the `display` method, we are not changing its return value
    or its parameters. This means that, in the following code, we can use either the
    superclass or the subclass, and the version matching the reference type passed
    to `doDisplay` will run:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写`display`方法时，我们并没有改变它的返回值或参数。这意味着在下面的代码中，我们可以使用超类或子类，并且与传递给`doDisplay`的引用类型匹配的版本将会运行：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The program’s output will be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let us pass a reference to `SubClass`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们传递一个`SubClass`的引用：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will now be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在将如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Changing the return type of `display` in the subclass is a compiler error.
    Leaving the return type as `void` but adding or removing parameters breaks the
    override. The superclass `display` method is the only one that can be called if
    the `display` method’s reference is to `SubClass`. Here is the new `SubClass`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中更改`display`的返回类型将导致编译错误。将返回类型保留为`void`但添加或删除参数会破坏重写。如果`display`方法的引用是`SubClass`，则只能调用超类`display`方法。以下是新的`SubClass`：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We cannot use the `@Override` annotation as this is considered overloading,
    keeping the same method name but changing parameters. Now, if we pass `SubClass`
    to `doDisplay`, the method chosen will always be the `SuperClass` version, thus
    breaking the Liskov principle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`@Override`注解，因为这被认为是重载，保持相同的方法名但更改参数。现在，如果我们传递`SubClass`给`doDisplay`，选择的方法将始终是`SuperClass`版本，从而破坏Liskov原则。
- en: I – Interface segregation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I – 接口分离
- en: 'This principle provides guidance on developing interfaces. Simply put, do not
    add new methods to an interface that not every implementation of an interface
    will require. Let us look at a simple interface for a delivery service. Keep in
    mind that, for brevity, this and many other examples are not complete but show
    what is relevant to the concept being explained:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则为开发接口提供了指导。简单来说，不要向接口添加不是每个接口实现都需要的新的方法。让我们看看一个简单的配送服务接口。记住，为了简洁，这个和许多其他示例都不是完整的，但展示了与所解释的概念相关的部分：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let us implement this interface:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个接口：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, imagine that we need to expand `Courier` to handle packages that will
    travel by air freight. We now must add methods just used for this type of transport.
    Do we add this to the existing interface? No, we do not. Interface segregation
    tells us to keep interfaces to the minimum number of methods required for a specific
    use. The new interface could look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要扩展`Courier`以处理将通过空运旅行的包裹。我们现在必须添加仅用于此类运输的方法。我们会将其添加到现有接口中吗？不，我们不会。接口分离原则告诉我们，为了特定的用途，应将接口保持为所需的最小方法数。新的接口可能看起来像这样：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are using interface inheritance here. With this interface, you will need
    to implement the methods from `Delivery` as well as the new method in `AirDelivery`.
    Now, if we implement a class with the `Delivery` interface, we only need to implement
    two methods. When we use `AirDelivery`, we need to implement three methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用接口继承。使用这个接口，你需要实现`Delivery`接口中的方法以及`AirDelivery`中的新方法。现在，如果我们实现一个具有`Delivery`接口的类，我们只需要实现两个方法。当我们使用`AirDelivery`时，我们需要实现三个方法。
- en: D – Dependency inversion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D – 依赖倒置
- en: 'This last principle in SOLID states that classes should not depend on a concrete
    class. Rather, classes should depend on abstraction. An abstraction can be an
    abstract class or, more commonly in Java, an interface. Imagine a program that
    deals with the inventory for a store. We would create a class for each item. We
    could have the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID中的最后一个原则指出，类不应该依赖于具体的类。相反，类应该依赖于抽象。抽象可以是一个抽象类，或者在Java中更常见的是接口。想象一个处理商店库存的程序。我们会为每个物品创建一个类。我们可能有以下情况：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For another item, such as `Milk`, we could have the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个物品，例如`牛奶`，我们可能有以下情况：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A program that uses either `Bread` or `Milk` is considered a high-level module,
    while `Bread` and `Milk` are considered concrete low-level modules. It also implies
    that the high-level module must depend on the concrete class. Imagine that we
    need a program to produce a report on items in inventory. Without following dependency
    inversion, we will need one report class for every item in the inventory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`面包`或`牛奶`的程序被认为是高级模块，而`面包`和`牛奶`被认为是具体的低级模块。这也意味着高级模块必须依赖于具体的类。想象一下，我们需要一个程序来生成库存物品的报告。如果不遵循依赖倒置原则，我们将需要为库存中的每个物品创建一个报告类：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will now need a second class for `BreadReport`. A store with 100 items for
    sale will need 100 classes, one for each item. The problem that dependency inversion
    resolves is the need for 100 report classes. We begin the solution using an interface:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为`BreadReport`创建第二个类。一个有100种商品出售的商店将需要100个类，每个商品一个。依赖倒置解决的问题是需要100个报告类。我们开始使用接口来解决这个问题：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, every item class will implement `Inventory`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个物品类都将实现`Inventory`：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There can now be just one report class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以只有一个报告类：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In using dependency inversion, your program can eliminate redundancy while still
    permitting your program to process any new items in the inventory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用依赖倒置时，你的程序可以消除冗余，同时仍然允许程序处理库存中的任何新物品。
- en: Software design principles will contribute to writing efficient and maintainable
    code. These principles, along with other principles, should be considered every
    time you write a line of code. You can read more about these principles and others
    from links in the *Further* *reading* section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计原则有助于编写高效且易于维护的代码。这些原则，以及其他原则，每次编写代码时都应予以考虑。您可以从*进一步阅读*部分中的链接了解更多关于这些原则和其他原则的信息。
- en: Principles should govern every line of code that you write. The upcoming patterns
    guide you in solving specific problems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 原则应该指导你写的每一行代码。即将到来的模式将指导你解决特定问题。
- en: Software design patterns
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计模式
- en: 'Software design patterns describe solutions to specific issues in software.
    This concept comes from architecture and engineering. Imagine that you need to
    design a bridge to cross a river. You will likely begin by choosing the bridge
    type or pattern. There are seven types of bridges:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计模式描述了软件中特定问题的解决方案。这个概念来自建筑和工程。想象一下，你需要设计一座桥梁来跨越一条河流。你可能会首先选择桥梁的类型或模式。有七种桥梁类型：
- en: Arch bridge
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拱桥
- en: Beam bridge
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梁桥
- en: Cantilever bridge
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬臂桥
- en: Suspension bridge
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬索桥
- en: Cable-stayed bridge
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钢索斜拉桥
- en: Tied-arch bridge
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系杆拱桥
- en: Truss bridge
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桁架桥
- en: These types, or patterns, describe how the bridge should span the river you
    wish to build your bridge over, but they do not provide detailed instructions
    or blueprints. They guide the architect in the design of the bridge. Software
    patterns work in a similar fashion. Let us look at four widely used patterns and
    how they could be implemented in Java.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型或模式描述了桥梁应该如何跨越你想要在其上建造桥梁的河流，但它们并不提供详细的说明或蓝图。它们指导建筑师进行桥梁设计。软件模式以类似的方式工作。让我们看看四种广泛使用的模式以及它们如何在Java中实现。
- en: Singleton
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: A singleton is a Java object that can only be instantiated once. It is a **creational**
    pattern. Wherever this object is used in an application, it is always the same
    object. In an application that requires exclusive access to resources by means
    of passing a token object, a singleton is one pattern you could follow. In [*Chapter
    11*](B19088_11.xhtml#_idTextAnchor232), *Documentation and Logging*, we will look
    at logging, and most logging frameworks use a singleton logger object. Otherwise,
    there would be a separate logger in every class that uses it. Objects that manage
    thread pools are also frequently written as singletons.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一个只能实例化一次的Java对象。它是一个**创建型**模式。无论这个对象在应用程序中的哪个地方被使用，它总是同一个对象。在一个需要通过传递令牌对象来独占访问资源的应用程序中，单例模式是你可能遵循的一种模式。在[*第11章*](B19088_11.xhtml#_idTextAnchor232)，“文档和日志”，我们将探讨日志记录，大多数日志框架都使用单例日志对象。否则，每个使用它的类都会有单独的日志记录器。管理线程池的对象也经常被写成单例。
- en: Implementing a singleton in Java can be quite easy. In the examples that follow,
    the singletons are doing nothing other than ensuring that there will be only one
    instance of them. I leave it to you to add the actual work that these singletons
    should perform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现单例模式可以相当简单。在接下来的示例中，这些单例除了确保只有一个实例之外，不做任何其他事情。我留给你们去添加这些单例应该执行的实际工作。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We use a static variable to represent this object when the `getInstance` method
    is called. As this method is static, it can only access static fields in the class.
    Static fields are also shared by all instances of an object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`getInstance`方法时，我们使用一个静态变量来表示这个对象。因为这个方法是静态的，所以它只能访问类中的静态字段。静态字段也是对象所有实例共享的。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Up until now, all constructors were `public`. Designating the constructor as
    `private` means that you cannot instantiate this object with `new`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有构造函数都是`public`的。将构造函数指定为`private`意味着你不能用`new`来实例化这个对象。
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this method, we test to see whether an instance already exists. If it does,
    then we return the instance. If it does not, then we instantiate the object with
    `new`. But wait, I just wrote that you cannot use `new` on a class with a `private`
    constructor. This is true if this object is instantiated in another object. Here,
    we are instantiating the object inside itself, and access control does not apply.
    Every method in a class can access any other method regardless of its access.
    So, while the constructor is `private` to the `getInstance` method, it can be
    run when the object is created with `new`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们测试是否已经存在一个实例。如果存在，则返回该实例。如果不存在，则使用`new`实例化对象。但是等等，我刚刚说过你不能在具有`private`构造函数的类上使用`new`。如果这个对象在另一个对象中实例化，这是正确的。在这里，我们是在对象内部实例化对象，访问控制不适用。类中的每个方法都可以访问任何其他方法，而不管其访问权限如何。所以，虽然构造函数对`getInstance`方法是`private`的，但它可以在对象用`new`创建时运行：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let us test whether this is working:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下这是否有效：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are instantiating two class fields by calling upon the `getInstance`
    method of `Singleton`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用`Singleton`的`getInstance`方法来实例化两个类字段：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If our `Singleton` class is working, the two instances of `Singleton` will
    be the same. When we compare object references, we are comparing the address in
    memory of these objects. If the address is the same, then we have the same object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`Singleton`类工作正常，两个`Singleton`实例将是相同的。当我们比较对象引用时，我们是在比较这些对象的内存地址。如果地址相同，那么我们就有了同一个对象：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is one problem with our `Singleton` class. It is not thread-safe. It
    is possible that `getInstance` could be interrupted by a thread or threads, and
    this could result in two or more instances of `Singleton`. We can make this class
    thread-safe by synchronizing the creation of the object. Here is the updated `getInstance`
    method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Singleton`类有一个问题。它不是线程安全的。可能`getInstance`方法会被线程中断，这可能导致出现两个或更多个`Singleton`实例。我们可以通过同步对象的创建来使这个类线程安全。以下是更新后的`getInstance`方法：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we create a synchronized block, we are guaranteeing that the instantiation
    of the `Singleton` class cannot be interrupted. This ensures that all threads
    get the same instance after the one time it is instantiated:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个同步块时，我们确保`Singleton`类的实例化不会被中断。这确保了在实例化一次之后，所有线程都将获得相同的实例：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this, we now have a thread-safe `Singleton` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在有一个线程安全的`Singleton`类。
- en: Factory
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂
- en: 'A factory, another creational pattern, is a class that instantiates a specific
    class from a family of classes that either share the same interface or are all
    subclasses of the same abstract class. It is a **creational** pattern. We will
    look at an example that uses an interface. Here is the shared interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂，另一种创建型模式，是一个类，它从一组共享相同接口或都是同一抽象类子类的类中实例化特定的类。它是一个**创建型**模式。我们将查看一个使用接口的示例。以下是共享接口：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let us create two classes that both implement the same interface. As mentioned
    previously, my examples only show the code that demonstrates the concept. You
    will add whatever code is necessary for the class to do its work:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个实现相同接口的类。如前所述，我的示例只展示了演示概念的代码。你将添加必要的代码，以便类能够执行其工作：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can look at the `Factory` class itself:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看`Factory`类本身：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Based on the string we pass to `getInstance`, we instantiate the appropriate
    object. Take note of `default` in the switch. It will return a `null` reference,
    a reference to nothing. You should test for this and take the appropriate action
    in the case where an invalid string is being used as `designator`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们传递给`getInstance`的字符串，我们将实例化相应的对象。注意`switch`中的`default`。它将返回一个`null`引用，即对无物的引用。你应该检查这一点，并在使用无效字符串作为`designator`的情况下采取适当的行动：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let us look at code that will use the `Factory` pattern to instantiate
    the classes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将使用`Factory`模式来实例化类的代码：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The objects we create will implement this interface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的对象将实现此接口：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we pass the string that the `Factory` pattern will use to determine which
    class to instantiate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递`Factory`模式将使用以确定要实例化哪个类的字符串：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the factory pattern can simplify the creation of families of classes that
    all share the same interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂模式可以简化创建具有相同接口的类族。
- en: Adapter
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: Imagine that you are working with existing code that uses a specific class with
    its own unique interface. One day, you come across another class that performs
    a similar task that meets the needs of a different client or is superior to what
    you have been using. The problem with the new class is that it does not have the
    same interface. Do you rewrite your code so that it will call upon the methods
    in the new class? You could, but the moment you start altering the existing code,
    there is the potential for unforeseen problems. The solution is to wrap the new
    class in an adapter class. The adapter presents the interface your code is already
    familiar with but then calls upon the appropriate method in the new class. This
    is where the adapter, a **structural** pattern, comes in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在使用具有自己独特接口的特定类的工作。有一天，你遇到了另一个执行类似任务但满足不同客户需求或优于你所使用的类的类。新类的问题在于它没有相同的接口。你是否重写代码以便调用新类的方法？你可以这样做，但当你开始修改现有代码时，就可能出现不可预见的问题。解决方案是将新类包装在一个适配器类中。适配器提供了你的代码已经熟悉的接口，但随后调用新类中的适当方法。这就是适配器，一个**结构型**模式，发挥作用的地方。
- en: 'Let us begin with a very simple application that calculates the fuel consumption
    of a vehicle and returns the result as miles per gallon. We begin with an interface
    for a class that will perform the calculation followed by its implementation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的应用程序开始，该应用程序计算车辆的燃油消耗量，并将结果作为每加仑英里数返回。我们从一个执行计算的类的接口开始，然后是其实现：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the code that will be used in this class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将在该类中使用的代码：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this program is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now imagine that a new client wants to use your system but needs the calculation
    done using metric measurement. For cars, this is described as liters per 100 kilometers.
    We have an interface and a class that will do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，一个新客户想要使用你的系统，但需要使用公制测量方法进行计算。对于汽车，这被描述为每100公里升数。我们有一个接口和一个将执行此操作的类：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To be able to use this new class, we need an adapter, which will implement
    the same interface but in the method call, will use the metric calculation class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这个新类，我们需要一个适配器，它将实现相同的接口，但在方法调用中，将使用度量计算类：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the method we are adapting. Rather than doing the calculation here,
    it will call upon the method of `MetricCar`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们正在适配的方法。而不是在这里进行计算，它将调用`MetricCar`的方法：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let us see how it will be used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它将如何被使用：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the only line we need to change. As the adapter shares the same interface,
    it can be used in place of `USCar`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要更改的唯一一行。由于适配器共享相同的接口，它可以替代`USCar`：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The program output is now as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出现在如下所示：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is a trivial example, but it is an example of code reuse. The adapter allows
    you to reuse code expecting a specific interface with new code. This new code
    has a different interface, and the adapter resolves this by presenting the original
    interface to your code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但它是一个代码重用的例子。适配器允许你使用具有特定接口的新代码重用代码。新代码具有不同的接口，适配器通过向你的代码呈现原始接口来解决这个问题。
- en: Observer
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者
- en: For this pattern, we are interested in when the state of an object changes.
    When a state change happens, a method in another class is called to carry out
    some tasks. These tasks could be to validate the state change, write the change
    to a database, or they could update the display. Java makes it easy to use this
    pattern by providing the `PropertyChangeListener` interface and the `PropertyChangeSupport`
    class. This is an example of a **behavioral** pattern.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此模式，我们感兴趣的是对象状态的变化。当状态发生变化时，将调用另一个类中的方法来执行一些任务。这些任务可以是验证状态更改、将更改写入数据库，或者更新显示。Java通过提供`PropertyChangeListener`接口和`PropertyChangeSupport`类，使使用此模式变得容易。这是一个**行为**模式的例子。
- en: 'We begin with a class that must notify other classes should the state of any
    or all of its fields change:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个必须通知其他类其任何或所有字段状态发生更改的类开始：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the field in this class that we are planning to listen for changes
    to its state:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此类中我们计划监听其状态变化的字段：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The constructor is instantiating an instance of the `PropertyChangeSupport`
    class. This object will allow us to add to or remove from a list of all the classes
    that implement the `PropertyChangeListener` listener for this class. It supports
    firing an event when a field changes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数正在实例化`PropertyChangeSupport`类的实例。此对象将允许我们向或从实现此类的`PropertyChangeListener`监听器的所有类的列表中添加或删除。它支持在字段更改时触发事件：
- en: '[PRE48]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This method lets us add to the list of listeners:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们将监听器列表添加到列表中：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This method allows the removal of a listener:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许移除一个监听器：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is the `set` method for the `observedValue` variable. When this method
    is called, `firePropertyMethod` will call `propertyChange` in every class that
    is in the list of listeners:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`observedValue`变量的`set`方法。当此方法被调用时，`firePropertyMethod`将在监听器列表中的每个类中调用`propertyChange`：
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`observedValue` is a `private` field, as it should be. We need methods such
    as the previous `set` method and this `get` method to read the value in the field:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`observedValue`是一个`private`字段，正如它应该的那样。我们需要像之前的`set`方法这样的方法和这个`get`方法来读取字段中的值：'
- en: '[PRE52]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we need a `listener` class. There can be just one or there can be many:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个`listener`类。可能只有一个或多个：
- en: '[PRE53]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the field that we wish to change if the field in `TheProperty` changes.
    While this is the usual way to use this pattern, the method that will be called
    when a change occurs is free to do whatever it wants and not just update a field
    in the listener:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`TheProperty`字段发生变化，我们希望更改的领域是此领域。虽然这是使用此模式的一种常见方式，但在发生更改时将被调用的方法可以自由地做任何它想做的事情，而不仅仅是更新监听器中的一个字段：
- en: '[PRE54]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the method that is called in every listener to `TheProperty`. While
    it is assigning the new value from `TheProperty` to its own `updatedValue`, you
    could do anything in this method, even write to a database as an example. Notice
    that the `PropertyChangeEvent` object has access to a name you gave to the property,
    usually the field name, along with the previous and new values. The name can be
    used to decide on different actions depending on which field was changed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调用每个监听器`TheProperty`的方法。当它将`TheProperty`的新值分配给其自己的`updatedValue`时，你可以在该方法中做任何事情，例如作为一个例子写入数据库。注意，`PropertyChangeEvent`对象可以访问你为属性给出的名称，通常是字段名称，以及旧值和新值。名称可以用来根据更改的字段决定不同的操作：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This class also has a set and get method for its private `updatedValue` field:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此类还有一个为其私有的`updatedValue`字段设置和获取方法：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we can test that if a change is made to the `TheProperty` object’s field,
    then `TheListener` is notified:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试如果对`TheProperty`对象的字段进行了更改，那么`TheListener`将收到通知：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We need at least one observable and any number of observers. They can be local
    variables like this or class fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要至少一个可观察对象和任意数量的观察者。它们可以是像这样的局部变量或类字段：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A listener is added to the observed object:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 向观察对象添加了一个监听器：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we update the observed field in the observable object. This will also
    result in the field in the observer object being updated:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更新可观察对象中的观察字段。这也会导致观察者对象中的字段被更新：
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this section, we looked at four of the many patterns. Patterns themselves
    are broken down into categories. Singleton and factory are creational patterns.
    Adapter is a structural pattern. Observer is a behavioral pattern. All the patterns
    can be applied to any language you use.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了众多模式中的四种。模式本身被划分为不同的类别。单例和工厂是创建型模式。适配器是结构型模式。观察者是行为型模式。所有这些模式都可以应用于你使用的任何语言。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we just touched upon SOLID software design principles and the
    singleton, factory, adapter, and observer design patterns. There are dozens of
    other principles and patterns. Design principles should guide your everyday coding,
    and design patterns offer solutions to design problems. Both are applicable to
    any language.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅简要介绍了SOLID软件设计原则以及单例、工厂、适配器和观察者设计模式。还有许多其他的原则和模式。设计原则应指导你的日常编码，而设计模式则提供了解决设计问题的方案。两者都适用于任何语言。
- en: Next up, we will be looking at documenting and testing the code that you write.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨编写代码的文档化和测试。
- en: Further reading
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Principles in* *Java*: [https://www.javatpoint.com/design-principles-in-java](https://www.javatpoint.com/design-principles-in-java)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java中的设计原则*：[https://www.javatpoint.com/design-principles-in-java](https://www.javatpoint.com/design-principles-in-java)'
- en: '*Object Oriented Design Principles in* *Java*: [https://stackabuse.com/object-oriented-design-principles-in-java/](https://stackabuse.com/object-oriented-design-principles-in-java/)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java中的面向对象设计原则*：[https://stackabuse.com/object-oriented-design-principles-in-java/](https://stackabuse.com/object-oriented-design-principles-in-java/)'
- en: '*What’s a Software Design Pattern? (+7 Most Popular* *Patterns)* [https://www.netsolutions.com/insights/software-design-pattern/](https://www.netsolutions.com/insights/software-design-pattern/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是软件设计模式？（+7种最受欢迎的模式）* [https://www.netsolutions.com/insights/software-design-pattern/](https://www.netsolutions.com/insights/software-design-pattern/)'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, by Erich
    Gamma, John Vlissides, Ralph Johnson, and Richard Helm, 0-201-63361-2, available
    in libraries or from online booksellers'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《可复用面向对象软件元素：设计模式》*，作者：Erich Gamma, John Vlissides, Ralph Johnson, 和 Richard
    Helm，ISBN 0-201-63361-2，可在图书馆或在线书店购买'
