- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Software Design Principles and Patterns in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software design principles provide guidance on how you construct your classes
    and how your objects should interact. They are not tied to a specific problem.
    For example, the **single responsibility** principle encourages us to write methods
    that perform a single task. Software design patterns are reusable concepts for
    solving common problems in software design. For example, should we need to have
    a single instance of an object in an application, you will want to use the **Singleton**
    pattern. This pattern has nothing to do with the language you are using, nor does
    it describe the required code for the pattern. What these principles and patterns
    do is describe a solution to common problems that you can then implement in the
    language you are using. Principles and patterns can be applied to any language,
    and I will assume that you have likely applied them in whatever language you are
    coming from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to look at a handful of the most commonly used
    principles and patterns and how they are coded in Java. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SOLID software design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a software developer, you are expected to write code that is reusable, understandable,
    flexible, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: SOLID software design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software design principles, as applied to object-oriented programming, provide
    guidelines for how you construct your classes. Unlike patterns that are tied to
    specific coding requirements, principles should be considered for any code that
    you write every day. There are numerous principles, but we will look at five principles
    that fall under the acronym **SOLID**.
  prefs: []
  type: TYPE_NORMAL
- en: S – Separation of concerns/single responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In my opinion, `CompoundInterest05` program and organized the classes based
    on functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Class organization for the separation of concerns principle](img/B19088_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Class organization for the separation of concerns principle
  prefs: []
  type: TYPE_NORMAL
- en: What we see in this figure are four packages that describe the required functionality
    of any classes in the package. The individual classes in each package contain
    any methods and data structures required to carry out their task. The business
    class is independent of the **user interface** (**UI**) class. We can change the
    UI class to employ a GUI rather than a text or console interface. We can do this
    without the need to make any changes to the business class. We will do just this
    in [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254), *Desktop Graphical User Interface
    Coding with Swing and JavaFX*, when we change the UI from text to GUI. We will
    even turn this application into a web app in [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301),
    *Jakarta Faces Application*, leaving the business and data classes untouched.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle is not technically part of SOLID but its
    close association with the separation of concerns merits including it here. This
    principle is applied to methods. A single method should be written to be responsible
    for a single concern. You would not write a single method that performs a calculation
    and then displays the result. These are two concerns, and each belongs to its
    own method.
  prefs: []
  type: TYPE_NORMAL
- en: O – Open/closed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle states that you should be able to add to or extend a class’s
    functionality, the open part, without changing or modifying any code in the class,
    the closed part. This can be accomplished using either inheritance or interface.
    Consider our `CompoundInterestCalculator05.java` example. It contains a single
    calculation for compound interest. What if I’d like to add another calculation?
    Should I just edit this file and add a new method for the new calculation? The
    answer is no.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I use inheritance, I will create a new class that extends the original single
    calculation and adds the new calculation. Here is a class that implements a method
    to calculate loan payments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You have thoroughly tested this calculation and you are confident that it is
    correct. Now, you are asked to add two more calculations, one for the savings
    goal and the other for the future value of regular savings. The open/closed principle
    tells us that we should not modify this class. Although it''s a simple example,
    there is still the possibility that you may inadvertently change something in
    this class when you add methods to it. The solution is inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `Calculator2` class inherits the public `loanCalculator` method from the
    `Calculator` superclass and then adds the two new calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach, called the polymorphic open/closed principle, is to use
    an interface class. This is the closed class. All calculations must implement
    this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us look at one of the three classes that will implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write a class that can call upon any of these operations. If we
    wish to add new financial calculations, we can without modifying this class, as
    it expects to receive a reference to an object that implements the `FinanceCalculate`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As new features are added to an application, you want to accomplish this without
    modifying existing code. There is one exception, and that is to correct bugs.
    This will likely require modifications to the code.
  prefs: []
  type: TYPE_NORMAL
- en: L – Liskov substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle describes how to use inheritance effectively. Put simply, when
    you create a new class that extends an existing class, you can override methods
    in the superclass. What you must not do is reuse a superclass method name and
    change its return type or the number or type of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple superclass that displays a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create a subclass that displays a slightly different message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we override the `display` method, we are not changing its return value
    or its parameters. This means that, in the following code, we can use either the
    superclass or the subclass, and the version matching the reference type passed
    to `doDisplay` will run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The program’s output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us pass a reference to `SubClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the return type of `display` in the subclass is a compiler error.
    Leaving the return type as `void` but adding or removing parameters breaks the
    override. The superclass `display` method is the only one that can be called if
    the `display` method’s reference is to `SubClass`. Here is the new `SubClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the `@Override` annotation as this is considered overloading,
    keeping the same method name but changing parameters. Now, if we pass `SubClass`
    to `doDisplay`, the method chosen will always be the `SuperClass` version, thus
    breaking the Liskov principle.
  prefs: []
  type: TYPE_NORMAL
- en: I – Interface segregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This principle provides guidance on developing interfaces. Simply put, do not
    add new methods to an interface that not every implementation of an interface
    will require. Let us look at a simple interface for a delivery service. Keep in
    mind that, for brevity, this and many other examples are not complete but show
    what is relevant to the concept being explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that we need to expand `Courier` to handle packages that will
    travel by air freight. We now must add methods just used for this type of transport.
    Do we add this to the existing interface? No, we do not. Interface segregation
    tells us to keep interfaces to the minimum number of methods required for a specific
    use. The new interface could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are using interface inheritance here. With this interface, you will need
    to implement the methods from `Delivery` as well as the new method in `AirDelivery`.
    Now, if we implement a class with the `Delivery` interface, we only need to implement
    two methods. When we use `AirDelivery`, we need to implement three methods.
  prefs: []
  type: TYPE_NORMAL
- en: D – Dependency inversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This last principle in SOLID states that classes should not depend on a concrete
    class. Rather, classes should depend on abstraction. An abstraction can be an
    abstract class or, more commonly in Java, an interface. Imagine a program that
    deals with the inventory for a store. We would create a class for each item. We
    could have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For another item, such as `Milk`, we could have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A program that uses either `Bread` or `Milk` is considered a high-level module,
    while `Bread` and `Milk` are considered concrete low-level modules. It also implies
    that the high-level module must depend on the concrete class. Imagine that we
    need a program to produce a report on items in inventory. Without following dependency
    inversion, we will need one report class for every item in the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now need a second class for `BreadReport`. A store with 100 items for
    sale will need 100 classes, one for each item. The problem that dependency inversion
    resolves is the need for 100 report classes. We begin the solution using an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every item class will implement `Inventory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There can now be just one report class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In using dependency inversion, your program can eliminate redundancy while still
    permitting your program to process any new items in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Software design principles will contribute to writing efficient and maintainable
    code. These principles, along with other principles, should be considered every
    time you write a line of code. You can read more about these principles and others
    from links in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Principles should govern every line of code that you write. The upcoming patterns
    guide you in solving specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: Software design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software design patterns describe solutions to specific issues in software.
    This concept comes from architecture and engineering. Imagine that you need to
    design a bridge to cross a river. You will likely begin by choosing the bridge
    type or pattern. There are seven types of bridges:'
  prefs: []
  type: TYPE_NORMAL
- en: Arch bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beam bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cantilever bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspension bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cable-stayed bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tied-arch bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truss bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types, or patterns, describe how the bridge should span the river you
    wish to build your bridge over, but they do not provide detailed instructions
    or blueprints. They guide the architect in the design of the bridge. Software
    patterns work in a similar fashion. Let us look at four widely used patterns and
    how they could be implemented in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A singleton is a Java object that can only be instantiated once. It is a **creational**
    pattern. Wherever this object is used in an application, it is always the same
    object. In an application that requires exclusive access to resources by means
    of passing a token object, a singleton is one pattern you could follow. In [*Chapter
    11*](B19088_11.xhtml#_idTextAnchor232), *Documentation and Logging*, we will look
    at logging, and most logging frameworks use a singleton logger object. Otherwise,
    there would be a separate logger in every class that uses it. Objects that manage
    thread pools are also frequently written as singletons.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a singleton in Java can be quite easy. In the examples that follow,
    the singletons are doing nothing other than ensuring that there will be only one
    instance of them. I leave it to you to add the actual work that these singletons
    should perform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We use a static variable to represent this object when the `getInstance` method
    is called. As this method is static, it can only access static fields in the class.
    Static fields are also shared by all instances of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, all constructors were `public`. Designating the constructor as
    `private` means that you cannot instantiate this object with `new`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we test to see whether an instance already exists. If it does,
    then we return the instance. If it does not, then we instantiate the object with
    `new`. But wait, I just wrote that you cannot use `new` on a class with a `private`
    constructor. This is true if this object is instantiated in another object. Here,
    we are instantiating the object inside itself, and access control does not apply.
    Every method in a class can access any other method regardless of its access.
    So, while the constructor is `private` to the `getInstance` method, it can be
    run when the object is created with `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us test whether this is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are instantiating two class fields by calling upon the `getInstance`
    method of `Singleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If our `Singleton` class is working, the two instances of `Singleton` will
    be the same. When we compare object references, we are comparing the address in
    memory of these objects. If the address is the same, then we have the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one problem with our `Singleton` class. It is not thread-safe. It
    is possible that `getInstance` could be interrupted by a thread or threads, and
    this could result in two or more instances of `Singleton`. We can make this class
    thread-safe by synchronizing the creation of the object. Here is the updated `getInstance`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a synchronized block, we are guaranteeing that the instantiation
    of the `Singleton` class cannot be interrupted. This ensures that all threads
    get the same instance after the one time it is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this, we now have a thread-safe `Singleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A factory, another creational pattern, is a class that instantiates a specific
    class from a family of classes that either share the same interface or are all
    subclasses of the same abstract class. It is a **creational** pattern. We will
    look at an example that uses an interface. Here is the shared interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create two classes that both implement the same interface. As mentioned
    previously, my examples only show the code that demonstrates the concept. You
    will add whatever code is necessary for the class to do its work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can look at the `Factory` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the string we pass to `getInstance`, we instantiate the appropriate
    object. Take note of `default` in the switch. It will return a `null` reference,
    a reference to nothing. You should test for this and take the appropriate action
    in the case where an invalid string is being used as `designator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us look at code that will use the `Factory` pattern to instantiate
    the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects we create will implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass the string that the `Factory` pattern will use to determine which
    class to instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the factory pattern can simplify the creation of families of classes that
    all share the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are working with existing code that uses a specific class with
    its own unique interface. One day, you come across another class that performs
    a similar task that meets the needs of a different client or is superior to what
    you have been using. The problem with the new class is that it does not have the
    same interface. Do you rewrite your code so that it will call upon the methods
    in the new class? You could, but the moment you start altering the existing code,
    there is the potential for unforeseen problems. The solution is to wrap the new
    class in an adapter class. The adapter presents the interface your code is already
    familiar with but then calls upon the appropriate method in the new class. This
    is where the adapter, a **structural** pattern, comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us begin with a very simple application that calculates the fuel consumption
    of a vehicle and returns the result as miles per gallon. We begin with an interface
    for a class that will perform the calculation followed by its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code that will be used in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now imagine that a new client wants to use your system but needs the calculation
    done using metric measurement. For cars, this is described as liters per 100 kilometers.
    We have an interface and a class that will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to use this new class, we need an adapter, which will implement
    the same interface but in the method call, will use the metric calculation class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the method we are adapting. Rather than doing the calculation here,
    it will call upon the method of `MetricCar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us see how it will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the only line we need to change. As the adapter shares the same interface,
    it can be used in place of `USCar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The program output is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial example, but it is an example of code reuse. The adapter allows
    you to reuse code expecting a specific interface with new code. This new code
    has a different interface, and the adapter resolves this by presenting the original
    interface to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this pattern, we are interested in when the state of an object changes.
    When a state change happens, a method in another class is called to carry out
    some tasks. These tasks could be to validate the state change, write the change
    to a database, or they could update the display. Java makes it easy to use this
    pattern by providing the `PropertyChangeListener` interface and the `PropertyChangeSupport`
    class. This is an example of a **behavioral** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a class that must notify other classes should the state of any
    or all of its fields change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the field in this class that we are planning to listen for changes
    to its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is instantiating an instance of the `PropertyChangeSupport`
    class. This object will allow us to add to or remove from a list of all the classes
    that implement the `PropertyChangeListener` listener for this class. It supports
    firing an event when a field changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This method lets us add to the list of listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This method allows the removal of a listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `set` method for the `observedValue` variable. When this method
    is called, `firePropertyMethod` will call `propertyChange` in every class that
    is in the list of listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`observedValue` is a `private` field, as it should be. We need methods such
    as the previous `set` method and this `get` method to read the value in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a `listener` class. There can be just one or there can be many:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the field that we wish to change if the field in `TheProperty` changes.
    While this is the usual way to use this pattern, the method that will be called
    when a change occurs is free to do whatever it wants and not just update a field
    in the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the method that is called in every listener to `TheProperty`. While
    it is assigning the new value from `TheProperty` to its own `updatedValue`, you
    could do anything in this method, even write to a database as an example. Notice
    that the `PropertyChangeEvent` object has access to a name you gave to the property,
    usually the field name, along with the previous and new values. The name can be
    used to decide on different actions depending on which field was changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This class also has a set and get method for its private `updatedValue` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test that if a change is made to the `TheProperty` object’s field,
    then `TheListener` is notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We need at least one observable and any number of observers. They can be local
    variables like this or class fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A listener is added to the observed object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we update the observed field in the observable object. This will also
    result in the field in the observer object being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at four of the many patterns. Patterns themselves
    are broken down into categories. Singleton and factory are creational patterns.
    Adapter is a structural pattern. Observer is a behavioral pattern. All the patterns
    can be applied to any language you use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we just touched upon SOLID software design principles and the
    singleton, factory, adapter, and observer design patterns. There are dozens of
    other principles and patterns. Design principles should guide your everyday coding,
    and design patterns offer solutions to design problems. Both are applicable to
    any language.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will be looking at documenting and testing the code that you write.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Principles in* *Java*: [https://www.javatpoint.com/design-principles-in-java](https://www.javatpoint.com/design-principles-in-java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object Oriented Design Principles in* *Java*: [https://stackabuse.com/object-oriented-design-principles-in-java/](https://stackabuse.com/object-oriented-design-principles-in-java/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What’s a Software Design Pattern? (+7 Most Popular* *Patterns)* [https://www.netsolutions.com/insights/software-design-pattern/](https://www.netsolutions.com/insights/software-design-pattern/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, by Erich
    Gamma, John Vlissides, Ralph Johnson, and Richard Helm, 0-201-63361-2, available
    in libraries or from online booksellers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
