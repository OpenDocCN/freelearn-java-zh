<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer105">
			</div>
		</div>
		<div class="Content" id="_idContainer106">
			<h1 id="_idParaDest-265"><a id="_idTextAnchor272"/>13. Functional Programming with Lambda Expressions</h1>
		</div>
		<div class="Content" id="_idContainer107">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter discusses how Java doubles up as a functional programming language. It also details the manner in which lambda expressions are used to perform pattern matching in Java. It accomplishes this, first, by explaining, in general terms, the difference between <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) and <strong class="bold">Functional Programming</strong> (<strong class="bold">FP</strong>). You will then learn the basic definition of a pure function, as well as the difference between functional and normal interfaces. And, finally, you practice employing lambda expressions as callbacks to events and using them to filter data.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor273"/>Introduction</h1>
			<p>While Java has been around for over 20 years now, and <strong class="bold">Functional Programming</strong> (<strong class="bold">FP</strong>) has been around for even longer than Java, it's not been until recently that the topic of FP has caught traction in the Java community. This is probably due to Java being an inherently imperative programming language; when learning Java, you learn OOP.</p>
			<p>However, the movements in the mainstream programming community have, in the past few years, shifted more toward FP. These days, you can see it on every platform—from the web to mobile to servers. FP concepts are everywhere.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor274"/>Background</h2>
			<p>FP has been around for a very long time even though it is a relatively new topic in Java. In fact, it has been around even longer than the first personal computer; it has its origins in the lambda calculus study that Alonzo Church created in the 1930s.</p>
			<p>The name "lambda" comes from the Greek symbol, which was the symbol Church decided to use when describing the rules and mathematical functions for his lambda calculus. </p>
			<p>The lambda identity function is, quite simply, a function returning the input parameter—that is, the identity. In a more normal mathematical script.</p>
			<p>As you can see, lambda calculus is a simple approach to use for expressing mathematical equations. However, it doesn't necessarily have to be mathematical. In its truest form, it's a function with one argument and a body where the arithmetic happens. In lambda calculus, the function is a first-class citizen – meaning it can be treated like any other variable. You can even combine multiple lambdas if you require multiple attributes in your function.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor275"/>Functional Programming</h1>
			<p>FP boils down to two things: side effects and determinism. These concepts form the basis of what we call FP, and they are also the easiest things for newcomers to grasp in this paradigm because they don't introduce new, complex patterns.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor276"/>Side Effects</h2>
			<p>When writing a program, we often strive to get some form of side effect – a program without side effects is a very dull program, as nothing would happen. However, side effects are also a common headache when trying to test a program reliably as its state may change unpredictably.</p>
			<p>A very useful class in Java is the <strong class="source-inline">Math</strong> class; it contains all sorts of mathematical helpers and is likely to be used in all Java applications, either directly or indirectly. Here is an example of printing a pseudo-random number to the console:</p>
			<p class="source-code">public static void main(String[] args) {</p>
			<p class="source-code">    System.out.println(Math.random());</p>
			<p class="source-code">}</p>
			<p>If we dig into the code of <strong class="source-inline">Math.java</strong> and review the details of the <strong class="source-inline">random()</strong> function, we will notice that it uses an object, <strong class="source-inline">randomNumberGenerator</strong>, that doesn't belong exclusively to the <strong class="source-inline">random()</strong> function:</p>
			<p class="source-code">public final class Math {</p>
			<p class="source-code">    public static double random() {</p>
			<p class="source-code">        return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>It also calls <strong class="source-inline">nextDouble()</strong> on the <strong class="source-inline">randomNumberGenerator</strong> object. This is what we refer to as a side effect; the <strong class="source-inline">random</strong> function reaches outside its own home, or body, and performs changes on other variables or classes. These variables, in turn, can be by other functions or objects that may or may not produce their own side effects. This behavior is a red flag when you are trying to implement a program in FP fashion because it's unpredictable. It can also be more difficult to make it safe to use in a multithreaded environment.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">Math.random()</strong> function, by design, delivers an unpredictable result. However, as an example, it serves us well to highlight the concept of side effects. The <strong class="source-inline">random</strong> function is also safe to use in multithreaded environments (for the most part)—Sun and Oracle have done their homework!</p>
			<p>As the <strong class="source-inline">Math.random()</strong> function produces different results for the same arguments, it's defined as a non-deterministic function.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor277"/>Deterministic Functions</h2>
			<p>A deterministic function is defined as a function that will always produce the same result for the same arguments, no matter how many times, or when, you execute the function:</p>
			<p class="source-code">public static void main(String[] args) {</p>
			<p class="source-code">    System.out.println(Math.random());</p>
			<p class="source-code">    System.out.println(Math.random());</p>
			<p class="source-code">}</p>
			<p>In this example, <strong class="source-inline">Math.random()</strong> is called twice, and will always print two different values to the terminal. No matter how many times you call <strong class="source-inline">Math.random()</strong>, it will always give different results – as, by design, it's not deterministic:</p>
			<p class="source-code">public static void main(String[] args) {</p>
			<p class="source-code">    System.out.println(Math.toRadians(180));</p>
			<p class="source-code">    System.out.println(Math.toRadians(180));</p>
			<p class="source-code">}</p>
			<p>Running this simple code, we can see that the <strong class="source-inline">Math.toRadians()</strong> function will give the same result for both functions, and doesn't seem to change anything else in the program. This is a hint that it is deterministic – let's dig into the function and review it:</p>
			<p class="source-code">public final class Math {</p>
			<p class="source-code">    private static final double DEGREES_TO_RADIANS = 0.017453292519943295;</p>
			<p class="source-code">      </p>
			<p class="source-code">    public static double toRadians(double angdeg) {</p>
			<p class="source-code">        return angdeg * DEGREES_TO_RADIANS;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The function, as expected, will not change anything from the outside world and will always produce the same result. This means that we can consider it as a deterministic function. However, it does read a constant that lives outside of the function's scope; this is something of an edge case of what we can call a <strong class="bold">pure function</strong>.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor278"/>Pure Functions</h1>
			<p>The purest of functions can be considered black boxes, meaning that what happens inside the function is not really of any interest to the programmer. They are only interested in what is put into the box, and what comes out of it as a result—that's because there will always be a result of a pure function.</p>
			<p>The pure function takes arguments and produces a result based on these arguments. The pure function will never change the state of the outside world or rely on it. Everything that is required by the function should be available inside it, or as an input to it.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor279"/>Exercise 1: Writing Pure Functions </h2>
			<p>A grocery store has a system for managing their stock; however, the company that built their software has gone bankrupt and has lost all the source code for their system. This is a system that only allows customers to buy one thing at a time. Because their customers want to buy two things at a time, never more or less, they have asked you to implement a function that takes the price of two products and returns the sum of those two prices. They want you to implement this without causing any side effects or incompatibilities with their current system. You'll implement this as a pure function:</p>
			<ol>
				<li>If IntelliJ is already started but no project is open, then select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project open, then select <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In <strong class="source-inline">New Project</strong> dialog, select the <strong class="source-inline">Java project</strong>. Then, click on <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>. Then, click on <strong class="source-inline">Next</strong>.</li>
				<li>Give the new project the name <strong class="source-inline">Exercise1</strong>.</li>
				<li>IntelliJ will give you a default project location; if you wish to select one, you can enter it here.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter13</strong>.</li>
				<li>Click on <strong class="source-inline">Finish</strong>. IntelliJ will create your project, called <strong class="source-inline">Exercise1</strong>, with the standard folder structure. IntelliJ will also create the main entry point for your application, called <strong class="source-inline">Main.java</strong>; it will look like the following code snippet:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Main {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Rename <strong class="source-inline">Main.java</strong> to <strong class="source-inline">Exercise1.java</strong>.</li>
				<li>Create a new function in the <strong class="source-inline">Main</strong> class, placing it under the <strong class="source-inline">main(String[] args)</strong> function. Call the new function <strong class="source-inline">sum</strong> and let it return an integer value. This function should take two integers as input. For the simplicity of the code, we'll make the function a <strong class="source-inline">static</strong> utility function:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">    static int sum(int price1, int price2) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>All this function should do is return the sum of the two arguments—<strong class="source-inline">price1</strong> and <strong class="source-inline">price2</strong>:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">    static int sum(int price1, int price2) {</p><p class="source-code">        return price1 + price2;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Call this new method a few times using the same parameters in your <strong class="source-inline">main</strong> function:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        System.out.println(sum(2, 3));</p><p class="source-code">        System.out.println(sum(2, 3));</p><p class="source-code">        System.out.println(sum(2, 3));</p><p class="source-code">    }</p><p class="source-code">    static int sum(int price1, int price2) {</p><p class="source-code">        return price1 + price2;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now run your program and observe the output.<p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">System.out.println()</strong> method is considered by many as an impure function because it manipulates the terminal – which is, of course, "the outside world" because, at some point in the call stack, the function will reach outside of its body to manipulate an <strong class="source-inline">OutputStream</strong> instance.</p></li>
			</ol>
			<p>The function you just wrote takes two arguments and produces a whole new output, without modifying anything outside the function's scope. With this, you've successfully taken the first step toward writing applications in a more functional way.</p>
			<p>Another important consideration when writing functional programs is how to handle the state in your application. In OOP, we attack the problem of handling state in large applications by using the divide-and-conquer strategy. Here, each object in the application contains a little piece of the state of the entire application.</p>
			<p>An implicit attribute of this type of state handling is the ownership and mutability of the state. Each object often has a private state that is accessible using a public interface—the object's method. If, for example, we review the <strong class="source-inline">ParseException.java</strong> class from the OpenJDK source code, we'll find this pattern as well:</p>
			<p class="source-code">package java.text;</p>
			<p class="source-code">public class ParseException extends Exception {</p>
			<p class="source-code">    private static final long serialVersionUID = 2703218443322787634L;</p>
			<p class="source-code">    public ParseException(String s, int errorOffset) {</p>
			<p class="source-code">        super(s);</p>
			<p class="source-code">        this.errorOffset = errorOffset;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public int getErrorOffset() {</p>
			<p class="source-code">        return errorOffset;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private int errorOffset;</p>
			<p class="source-code">}</p>
			<p>Here, we can see one private member variable called <strong class="source-inline">errorOffset</strong>. This member variable is writeable from the constructor and is accessible for other objects via the <strong class="source-inline">getErrorOffest()</strong> method. We can also imagine a class that has another method that changes the <strong class="source-inline">errorOffset</strong> value—that is, a setter.</p>
			<p>One possible problem with this approach to state handling is multithreaded applications. If two or more threads were to either read or write to this member variable, we would usually see unpredictable changes. These changes can, of course, be mended in Java by using synchronization. However, synchronization comes at a cost; it's complicated to plan access accurately and, often, we end up with race conditions. It's also quite an expensive procedure in any language that supports it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Using synchronization is quite popular and is a safe way to build multithreaded applications. However, one of the downsides of synchronization—apart from it being very expensive—is that it effectively makes our application behave as a single-threaded application, as all threads accessing the synchronized data must wait their turn to handle the data.</p>
			<p>In FP, we try to avoid using synchronization by instead saying that our state should always be immutable—effectively negating the need for synchronization.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor280"/>Immutability of State</h2>
			<p>When the state is immutable, it essentially means that it cannot change, ever. There is a common way of writing this rule in FP that goes something like this: replace your data rather than editing it in place.</p>
			<p>As we discussed in <em class="italic">Chapter 3</em>,<em class="italic"> Object-Oriented Programming</em>, one of the core concepts of OOP is inheritance; that is, the ability to create child classes that build upon, or inherit, the functionality already present in parent classes, but also add new functionality to the child classes. In FP, this becomes relatively tricky because we're targeting data that should never change.</p>
			<p>The easiest way of making data unchangeable in Java is by using the <strong class="source-inline">final</strong> keyword. There are three ways of using the <strong class="source-inline">final</strong> keyword in Java: locking variables for change, making methods impossible to override, and making classes impossible to extend. When building immutable data structures in Java, it's often not enough with just one of these methods; we need to use two or sometimes even all three.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor281"/>Exercise 2: Creating an Immutable Class</h2>
			<p>A local carpenter has set up shop on your street and has asked you to build the storage mechanism for a simple shopping cart application, which they will use internally for people ordering furniture. The application should be able to safely handle multiple people editing it at the same time from different threads. The salespeople will take orders on the phone and the carpenters will be editing the price in hours spent and material used. The shopping cart must be immutable. To do this, perform the following steps:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">Project</strong> pane in IntelliJ, right-click on the folder named <strong class="source-inline">src</strong>.</li>
				<li>Choose <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Java Class</strong> in the menu and enter <strong class="source-inline">Exercise2</strong>.</li>
				<li>Define the <strong class="source-inline">main</strong> method in your new class:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a new inner class called <strong class="source-inline">ShoppingCart</strong>, and then make it <strong class="source-inline">final</strong> to ensure that it cannot be extended or its behavior changed. Your code should now look something like this:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    public static final class ShoppingCart {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We also need items to put into this cart, so create a simple data object for <strong class="source-inline">ShoppingItem</strong>, give it a name and price attribute, and then make the class immutable. We'll later use this class to instantiate a few different objects to test the mutability of our <strong class="source-inline">ShoppingCart</strong> class:<p class="source-code">    public static final class ShoppingCart{</p><p class="source-code">    }</p><p class="source-code">    private static final class ShoppingItem {</p><p class="source-code">        private final String name;</p><p class="source-code">        private final int price;</p><p class="source-code">        public ShoppingItem(String name, int price) {</p><p class="source-code">            this.name = name;</p><p class="source-code">            this.price = price;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Add a list in which we will keep all the items for this immutable shopping cart. Make sure that you declare the list with the <strong class="source-inline">final</strong> keyword, keeping it unchangeable:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">       </p><p class="source-code">    public static final class ShoppingCart{</p><p class="source-code">        private final List&lt;ShoppingItem&gt; mShoppingList = new ArrayList&lt;&gt;();</p><p class="source-code">    }</p><p class="source-code">       </p><p class="source-code">}</p><p>Now we have a way to create items for our customers to purchase, and we also have a bag for our customers to put their selected items in. However, we lack a way for our customers to add items to the shopping cart. </p></li>
				<li>In the object-oriented approach to solving this problem, we could add a method called <strong class="source-inline">addItem(ShoppingItem shoppingItem)</strong>:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    private final class ShoppingCart{</p><p class="source-code">        private final List&lt;ShoppingItem&gt; mShoppingList = new ArrayList&lt;&gt;();</p><p class="source-code">        </p><p class="source-code">        public void addItem(ShoppingItem item) {</p><p class="source-code">            mShoppingList.add(item);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">       </p><p class="source-code">}</p><p>Looking at this solution from an FP approach, we can already see that it will modify the collection. This is something that we're desperately trying to avoid as multiple people will be working on this shopping cart at the same time. In this case, using the <strong class="source-inline">final</strong> keyword has no impact since the contents of a final list can still change. One basic approach to solving this in a functional way is to return a new <strong class="source-inline">ShoppingCart</strong> when adding an item.</p></li>
				<li>Add a new constructor to the <strong class="source-inline">ShoppingCart</strong> class and let it take a list as an argument. Then, pass this list to <strong class="source-inline">mShoppingList</strong> of the <strong class="source-inline">ShoppingCart</strong> class and make it unmodifiable with the <strong class="source-inline">Collections.unmodifiableList()</strong> method:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.Collections;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static final class ShoppingCart{</p><p class="source-code">        public final List&lt;ShoppingItem&gt; mShoppingList;</p><p class="source-code">        public ShoppingCart(List&lt;ShoppingItem&gt; list) {</p><p class="source-code">            mShoppingList = Collections.unmodifiableList(list);</p><p class="source-code">        }</p><p class="source-code">        public void addItem(ShoppingItem item) {</p><p class="source-code">            mShoppingList.add(item);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Rewrite the <strong class="source-inline">addItem(ShoppingItem item)</strong> method and let it return a new <strong class="source-inline">ShoppingCart</strong> item instead of <strong class="source-inline">void</strong>. Copy the list of the previous <strong class="source-inline">ShoppingCart</strong> items into a temporary list and add another item to it. Then, pass this temporary list to the constructor and return the newly created <strong class="source-inline">ShoppingCart</strong> object:<p class="source-code">    public static final class ShoppingCart{</p><p class="source-code">        public final List&lt;ShoppingItem&gt; mShoppingList;</p><p class="source-code">        public ShoppingCart(List&lt;ShoppingItem&gt; list) {</p><p class="source-code">            mShoppingList = Collections.unmodifiableList(list);</p><p class="source-code">        }</p><p class="source-code">        public ShoppingCart addItem(ShoppingItem item) {</p><p class="source-code">            List&lt;ShoppingItem&gt; newList = new ArrayList&lt;&gt;(mShoppingList);</p><p class="source-code">            newList.add(item);</p><p class="source-code">            return new ShoppingCart(newList);</p><p class="source-code">        }</p><p class="source-code">    }</p><p>In this code, we can see that the constructor now accepts a list of <strong class="source-inline">ShoppingItem</strong> classes; we can also see that the list is directly saved as an unmodifiable list. This is a special type of list in Java—one that throws an exception whenever you attempt to modify it in any way, either directly or through its iterator.</p><p>We can also see that the <strong class="source-inline">addItem(ShoppingItem item)</strong> function now returns a new <strong class="source-inline">ShoppingCart</strong>, with a whole new list, but with the items from the previous shopping list shared between the two <strong class="source-inline">ShoppingCart</strong> instances. This is an acceptable solution even for a multithreaded environment as the <strong class="source-inline">ShoppingItem</strong> classes are final and, therefore, may never change their state.</p><p class="callout-heading">Note</p><p class="callout">Java 8 introduced the Stream API, which was a whole new way of working with collections, that is, a more FP-based approach. You can read more about the Stream API in <em class="italic">Chapter 15</em>,<em class="italic"> Processing Data with Streams</em>. In this chapter, we'll focus on solutions that don't use the Stream API.</p></li>
				<li>Now you need to use this new <strong class="source-inline">ShoppingCart</strong> in a program. Edit your <strong class="source-inline">main</strong> method, and then let it create an empty <strong class="source-inline">ShoppingCart</strong> first. Then, add a new shopping item to that cart, storing the newly created <strong class="source-inline">ShoppingCart</strong> in another variable. Finally, add another <strong class="source-inline">ShoppingItem</strong> to the second <strong class="source-inline">ShoppingCart</strong>, again storing the new <strong class="source-inline">ShoppingCart</strong> in a new variable:<p class="source-code-heading">Exercise2.java</p><p class="source-code">7  public class Exercise2 {</p><p class="source-code">8  </p><p class="source-code">9      public static void main(String[] args) {</p><p class="source-code">10         ShoppingCart myFirstCart =             new ShoppingCart(new ArrayList&lt;ShoppingItem&gt;());</p><p class="source-code">11         ShoppingCart mySecondCart =             myFirstCart.addItem(new ShoppingItem("Chair", 150));</p><p class="source-code">12         ShoppingCart myThirdCart =             mySecondCart.addItem(new ShoppingItem("Table",350));</p><p class="source-code">13     }</p><p class="source-code-link"><a href="https://packt.live/2Jdr10l">https://packt.live/2Jdr10l</a></p></li>
				<li>Place a breakpoint on the last line and debug your code. You'll notice the carts that are created when calling <strong class="source-inline">addItem</strong> maintain their own unmodifiable list of <strong class="source-inline">ShoppingItem</strong>, but the immutable <strong class="source-inline">ShoppingItem</strong> are shared across the lists.</li>
			</ol>
			<p>The <strong class="source-inline">Collections.unmodifiableList()</strong> method and other similar methods (such as <strong class="source-inline">Set</strong>, <strong class="source-inline">Map</strong>, and <strong class="source-inline">SortedList</strong>) are not providing any immutability to the list itself. They produce a view of the list that prohibits any change. However, anyone with a reference to the actual list will still be able to change the data.</p>
			<p>In this exercise the lists are safe as the <strong class="source-inline">main</strong> method doesn't keep any reference to the lists, so no one outside can change it. However, this is not the recommended path when attempting to implement a program using a functional approach; don't trust anyone to follow rules unless they strictly must. Since Java 9, there are now real immutable collections that are available.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor282"/>Activity 1: Modifying Immutable Lists</h2>
			<p>Add a new behavior to your <strong class="source-inline">ShoppingCart</strong>:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">removeItem(ShoppingItem)</strong> function.</li>
				<li>Create a function that takes multiple <strong class="source-inline">ShoppingItem</strong> as arguments, either as a list or as variable arguments.</li>
				<li>Modify your <strong class="source-inline">ShoppingCart</strong> to take multiple items of each <strong class="source-inline">ShoppingItem</strong>—for example, four chairs and one table. Additionally, modify the <strong class="source-inline">addItem(ShoppingItem)</strong> and <strong class="source-inline">removeItem(ShoppingItem)</strong> functions.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 561.</p></li>
			</ol>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor283"/>Immutable Collections</h2>
			<p>Using <strong class="source-inline">Collections.unmodifiableList</strong> is a quick way to provide an unmodifiable version of an existing list. Another option available since Java 9 is to use the immutable collections with factory methods. These factory methods allow you to create three different immutable collection types: <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are a few libraries that provide more optimized immutable collections; one popular example is Guava with its <strong class="source-inline">ImmutableArrayList</strong> and other types.</p>
			<p>If we were to use the <strong class="source-inline">List</strong> factory methods instead of the <strong class="source-inline">Collections</strong> class in our shopping cart, it could look something like this:</p>
			<p class="source-code">public class Main {</p>
			<p class="source-code">    public static final class ShoppingCart {</p>
			<p class="source-code">        public final List&lt;ShoppingItem&gt; mShoppingList;</p>
			<p class="source-code">        public ShoppingCart(List&lt;ShoppingItem&gt; list) {</p>
			<p class="source-code">            mShoppingList = List.copyOf(list);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        public ShoppingCart addItem(ShoppingItem item) {</p>
			<p class="source-code">            List&lt;ShoppingItem&gt; newList = new ArrayList&lt;&gt;(mShoppingList);</p>
			<p class="source-code">            newList.add(item);</p>
			<p class="source-code">            return new ShoppingCart(newList);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we can see that there's very little difference to what we had before. Instead of using <strong class="source-inline">Collections.unmodifiableList()</strong> to create an unmodifiable view of the list, we create an immutable copy of this list with <strong class="source-inline">List.copyOf()</strong>. The difference in our example is invisible for the user. However, at the bottom, they're based on different implementations—the <strong class="source-inline">UnmodifiableCollection</strong> and <strong class="source-inline">ImmutableCollections</strong> classes, respectively.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor284"/>Exercise 3: Overriding the String Method</h2>
			<p>In this exercise, we'll make a small technical proof of the difference between <strong class="source-inline">UnmodifiableCollection</strong> and <strong class="source-inline">ImmutableCollection</strong> classes. For this example, we'll need to override the <strong class="source-inline">toString()</strong> method for the <strong class="source-inline">ShoppingItem</strong> and <strong class="source-inline">ShoppingCart</strong> classes: </p>
			<ol>
				<li value="1">Add the <strong class="source-inline">toString()</strong> method to the <strong class="source-inline">ShoppingItem</strong> class, and then let it return the name:<p class="source-code">    private static final class ShoppingItem {</p><p class="source-code">        @Override</p><p class="source-code">        public String toString() {</p><p class="source-code">            return name + ", " + price;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Add the <strong class="source-inline">toString()</strong> method to the <strong class="source-inline">ShoppingCart</strong> class. Then, let it return a concatenated string for all the <strong class="source-inline">ShoppingItem</strong> in the list:<p class="source-code">    public static final class ShoppingCart {</p><p class="source-code">        public String toString() {</p><p class="source-code">            StringBuilder sb = new StringBuilder("Cart: ");</p><p class="source-code">            for (int i = 0; i &lt; mShoppingList.size(); i++) {</p><p class="source-code">                sb.append(mShoppingList.get(i)).append(", ");</p><p class="source-code">            }</p><p class="source-code">            return sb.toString();</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Now we have a simple way of printing the contents of a <strong class="source-inline">ShoppingCart</strong> using the <strong class="source-inline">toString()</strong> method. To demonstrate the difference, replace the code in the <strong class="source-inline">main</strong> method. Add a few books to a standard list, and then copy this list into an unmodifiable version and an immutable version. Print the two copies:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;ShoppingItem&gt; books = new ArrayList&lt;&gt;();</p><p class="source-code">        books.add(new ShoppingItem("Java Fundamentals", 100));</p><p class="source-code">        books.add(new ShoppingItem("Java 11 Quick Start", 200));</p><p class="source-code">        List&lt;ShoppingItem&gt; immutableCopy = List.copyOf(books);</p><p class="source-code">        List&lt;ShoppingItem&gt; unmodifiableCopy =           Collections.unmodifiableList(books);</p><p class="source-code">        System.out.println(immutableCopy);</p><p class="source-code">        System.out.println(unmodifiableCopy);</p><p class="source-code">    }</p></li>
				<li>Now remove the first item, the <strong class="source-inline">Java Fundamentals</strong> book, from the original <strong class="source-inline">books</strong> list and print the two copies again:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;ShoppingItem&gt; books = new ArrayList&lt;&gt;();</p><p class="source-code">        books.add(new ShoppingItem("Java Fundamentals", 100));</p><p class="source-code">        books.add(new ShoppingItem("Java 11 Quick Start", 200));</p><p class="source-code">        List&lt;ShoppingItem&gt; immutableCopy = List.copyOf(books);</p><p class="source-code">        List&lt;ShoppingItem&gt; unmodifiableCopy =           Collections.unmodifiableList(books);</p><p class="source-code">        System.out.println(immutableCopy);</p><p class="source-code">        System.out.println(unmodifiableCopy);</p><p class="source-code">        books.remove(0);</p><p class="source-code">        System.out.println(immutableCopy);</p><p class="source-code">        System.out.println(unmodifiableCopy);</p><p class="source-code">    }</p></li>
			</ol>
			<p>This simple example provides proof of the difference between an unmodifiable view and an immutable copy. In the unmodifiable version, the list can still be changed, and the unmodifiable view will pick up on that change, whereas the immutable version will ignore that change because it contains a new list of items.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor285"/>Functional Interfaces</h2>
			<p>Functional interfaces are declared as standard Java interfaces, except they're only allowed to contain one abstract function, but can contain any number of default or static functions.</p>
			<p>The <strong class="source-inline">Comparator</strong> interface is one of the older interfaces of Java. It has been with us since version 1.2 and has seen many several over the years. However, the biggest change yet is probably the move to become a functional interface in Java 8.</p>
			<p>Reviewing the changes on the <strong class="source-inline">Comparator</strong> interface in Java 8, you'll notice some interesting changes. First, the interface has grown from 4 lines of code to 80 lines, excluding package declaration and comments. Then, you'll notice that there's a new annotation at the top:</p>
			<p class="source-code">@FunctionalInterface</p>
			<p>This annotation marks that this is now a functional interface. Its main purpose is to tell the reader that this interface is intended to follow the functional interfaces specification as defined in Java 8. If it fails to follow those guidelines, the Java compiler should print an error.</p>
			<p>After the two original abstract function declarations, you'll find no less than seven default functions. These default functions were introduced in Java 8 to add new functionality to interfaces without breaking backward compatibility. The default functions are always public and will always contain a code block. They can return a value, but this is not required by the specification.</p>
			<p>Finally, we'll find a total of nine <strong class="source-inline">static</strong> functions. Since Java 8, the functional interface can contain any number of <strong class="source-inline">static</strong> methods, they work very much like the static methods found in normal classes. You will explore more details about building and using functional interfaces in a later chapter in this book.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor286"/>Lambda Expressions</h1>
			<p>Along with the functional improvements in Java 8, there also came <strong class="source-inline">Lambda</strong> expressions. One of the primary improvements with lambdas is the code readability—most of the boilerplate code for interfaces is now gone.</p>
			<p>A very commonly used interface is the <strong class="bold">Runnable interface</strong>; it's used in multithreaded applications to perform any type of task in the background, such as downloading a large file from a network. In Java 7 and earlier versions, you'd often see the Runnable interface used as an anonymous instance:</p>
			<p class="source-code">new Thread(new Runnable() {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void run() {</p>
			<p class="source-code">    }</p>
			<p class="source-code">}).start();</p>
			<p>Since Java 8, the preceding five lines of code can now be simplified by using a lambda expression instead:</p>
			<p class="source-code">new Thread(() -&gt; {<a id="_idTextAnchor287"/>}).start();</p>
			<p>As you can see, the code becomes much more readable when we remove a lot of the boilerplate code.</p>
			<p>The lambda expression consists of two main components: the arguments and the body. Additionally, between these two components, there is always an arrow operator (which is also known as a lambda operator). The body also contains the optional return value. The parentheses contain the optional arguments for the lambda expression. Because it's an FP component, though, you'll want to use arguments:</p>
			<p class="source-code">(int arg1, int arg2) -&gt; { return arg1 + arg2; }</p>
			<p>You can also omit the type of the arguments as those will be inferred by the functional interface that the lambda expression implements:</p>
			<p class="source-code">(arg1, arg2) -&gt; { return arg1 + arg2; }</p>
			<p>If you have only one argument, you can omit the parentheses:</p>
			<p class="source-code">arg1 -&gt; { return arg1; }</p>
			<p>However, if you have no arguments in your lambda, then you must include the parentheses:</p>
			<p class="source-code">() -&gt; { return 5; }</p>
			<p>Then there is the function body; if you have many lines of code in your lambda logic, you must use the curly brackets to enclose the body:</p>
			<p class="source-code">(arg1, arg2) -&gt; { </p>
			<p class="source-code">    int sum = arg1 + arg2;</p>
			<p class="source-code">    return sum;</p>
			<p class="source-code">}</p>
			<p>However, if you only have one single line of code, you can omit the curly brackets and immediately return the value:</p>
			<p class="source-code">(arg1, arg2) -&gt; return arg1 + arg2;</p>
			<p>Finally, you can also omit the <strong class="source-inline">return</strong> keyword if all you have is a single line of code: </p>
			<p class="source-code">(arg1, arg2) -&gt; arg1 + arg2;</p>
			<p>If we were to write the lambda calculus identity function in Java, assuming we have a functional interface called <strong class="source-inline">Identity</strong>, it would look something like this:</p>
			<p class="source-code">Identity identity = x -&gt; x;</p>
			<p>One commonly used interface is the <strong class="source-inline">Comparator</strong> interface, which is used in almost any object you wish to order, specifically in a collection of some form.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor288"/>Exercise 4: Listing Spare Tires</h2>
			<p>A racing team has contacted you to organize their stock of spare tires because it's in a mess. They've asked you to write an application that will show the list of available tires in order of size, starting with the biggest tire.</p>
			<p>To do this, you'll build a lambda function that implements the <strong class="source-inline">Comparator</strong> functional interface. For reference, this is the base view of the <strong class="source-inline">Comparator</strong> interface, excluding the default and static functions:</p>
			<p class="source-code">@FunctionalInterface</p>
			<p class="source-code">public interface Comparator&lt;T&gt; {</p>
			<p class="source-code">    int compare(T o1, T o2);</p>
			<p class="source-code">}</p>
			<ol>
				<li value="1">In the <strong class="source-inline">Project</strong> pane in IntelliJ, right-click on the folder named <strong class="source-inline">src</strong>.</li>
				<li>Choose <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Java Class</strong> in the menu, and then enter <strong class="source-inline">Exercise4</strong>.</li>
				<li>Define the <strong class="source-inline">main</strong> method in your new class:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise4 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a new inner class called <strong class="source-inline">Tire</strong>. It should have a size variable that is the diameter of the tire in inches. Make sure that the class and size are declared as <strong class="source-inline">final</strong> to adhere to the FP guidelines:<p class="source-code">package com.packt.java.chapter13;</p><p class="source-code">public class Exercise4 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    public static final class Tire {</p><p class="source-code">        private final int size;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Tire</strong> constructor, taking one argument—the <strong class="source-inline">size</strong>—and passing that to the member variable. Additionally, override the <strong class="source-inline">toString()</strong> method to print the size of the tire:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    public static final class Tire {</p><p class="source-code">        private final int size;</p><p class="source-code">        public Tire(int size) {</p><p class="source-code">            this.size = size;</p><p class="source-code">        } </p><p class="source-code">        @Override</p><p class="source-code">        public String toString() {</p><p class="source-code">            return String.valueOf(size);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a list of tires that need to be sorted into your <strong class="source-inline">main</strong> method:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Tire&gt; tires = List.of(</p><p class="source-code">            new Tire(17),</p><p class="source-code">            new Tire(16),</p><p class="source-code">            new Tire(18),</p><p class="source-code">            new Tire(14),</p><p class="source-code">            new Tire(15),</p><p class="source-code">            new Tire(16));</p><p class="source-code">    }</p></li>
				<li>Create the actual lambda expression, using the <strong class="source-inline">Comparator</strong> functional interface, that you will use to sort the immutable list of tires. It should take two arguments, and return the difference in size. Remember that the lambda expression infers a lot of the structure; you won't need to specify the types or return a keyword in this simple example. The lambda expression is a first-class citizen, so it's fine to store it in a variable for later use:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Tire&gt; tires = List.of(</p><p class="source-code">            new Tire(17),</p><p class="source-code">            new Tire(16),</p><p class="source-code">            new Tire(18),</p><p class="source-code">            new Tire(14),</p><p class="source-code">            new Tire(15),</p><p class="source-code">            new Tire(16));</p><p class="source-code">        Comparator&lt;Tire&gt; sorter = (t1, t2) -&gt; t2.size - t1.size;</p><p class="source-code">    }</p><p class="callout-heading">Note</p><p class="callout">You can, of course, also apply the lambda expression as an anonymous instance—that way, you can save a few lines of code while keeping the code very readable.</p></li>
				<li>Apply the lambda expression in the <strong class="source-inline">sort</strong> method. The <strong class="source-inline">List.sort()</strong> method modifies the content of the list, so you need to copy your immutable list of tires before sorting it:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Tire&gt; tires = List.of(</p><p class="source-code">            new Tire(17),</p><p class="source-code">            new Tire(16),</p><p class="source-code">            new Tire(18),</p><p class="source-code">            new Tire(14),</p><p class="source-code">            new Tire(15),</p><p class="source-code">            new Tire(16));</p><p class="source-code">        Comparator&lt;Tire&gt; sorter = (t1, t2) -&gt; t2.size - t1.size;</p><p class="source-code">        List&lt;Tire&gt; sorted = new ArrayList&lt;&gt;(tires);</p><p class="source-code">        sorted.sort(sorter);</p><p class="source-code">    }</p></li>
				<li>Finally, print the result:<p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Tire&gt; tires = List.of(</p><p class="source-code">            new Tire(17),</p><p class="source-code">            new Tire(16),</p><p class="source-code">            new Tire(18),</p><p class="source-code">            new Tire(14),</p><p class="source-code">            new Tire(15),</p><p class="source-code">            new Tire(16));</p><p class="source-code">        Comparator&lt;Tire&gt; sorter = (t1, t2) -&gt; t2.size - t1.size;</p><p class="source-code">        List&lt;Tire&gt; sorted = new ArrayList&lt;&gt;(tires);</p><p class="source-code">        sorted.sort(sorter);</p><p class="source-code">        System.out.println(sorted);</p><p class="source-code">    }</p></li>
				<li>To make this program functional, you could move the sorting intelligence to a pure function that takes a list as an argument, then performs the sorting on a copy of that list and returns the immutable sorted list. This way, you will avoid keeping a reference of the mutable list in your main program:<p class="callout-heading">Note</p><p class="callout">The complete code snippet can be referred at: <a href="https://packt.live/35OxQiJ">https://packt.live/35OxQiJ</a>.</p></li>
			</ol>
			<p>You've just created your first lambda expression, based on an already present <strong class="source-inline">Functional</strong> interface, and you've then used it to sort a list of tires. There are lots of functional interfaces available since Java 8, and you've probably already been using most of them; we'll explore this in more detail later in the book.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor289"/>Summary</h1>
			<p>It shouldn't matter the order in which different threads act on your data, and you should be able to easily add functionality that doesn't affect older parts of your application. Following these FP concepts allows you to build code that can easily be used in multithreaded applications, as well as to build code that can be tested very easily for problems and regression bugs. It also often makes your code much more readable.</p>
			<p>Using the core concepts of FP that you've learned about in this chapter—pure functions and immutability—can lead to performance issues in some cases, specifically when modifying large datasets. There are ways to get around these, as we'll explore in later chapters.</p>
			<p>Because Java was designed for an OOP approach, it can be a bit daunting to get into FP at first, but if you "go functional" in only certain parts of your code, the transition from OOP may become easier.</p>
			<p>In the next chapter, we'll focus on how to navigate larger datasets and repeat code without using loops.</p>
		</div>
	</body></html>