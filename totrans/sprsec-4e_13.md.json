["```java\n@Component\npublic class AccessDecisionManagerAuthorizationManagerAdapter implements AuthorizationManager {\n    private final AccessDecisionManager accessDecisionManager;\n    private final SecurityMetadataSource securityMetadataSource;\n    @Override\n    public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) {\n       try {\n          Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n          this.accessDecisionManager.decide(authentication.get(), object, attributes);\n          return new AuthorizationDecision(true);\n       } catch (AccessDeniedException ex) {\n          return new AuthorizationDecision(false);\n       }\n    }\n    @Override\n    public void verify(Supplier<Authentication> authentication, Object object) {\n       Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n       this.accessDecisionManager.decide(authentication.get(), object, attributes);\n    }\n}\n```", "```java\n@Component\npublic class AccessDecisionVoterAuthorizationManagerAdapter implements AuthorizationManager {\n    private final AccessDecisionVoter accessDecisionVoter;\n    private final SecurityMetadataSource securityMetadataSource;\n    @Override\n    public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) {\n       Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n       int decision = this.accessDecisionVoter.vote(authentication.get(), object, attributes);\n       switch (decision) {\n          case ACCESS_GRANTED:\n             return new AuthorizationDecision(true);\n          case ACCESS_DENIED:\n             return new AuthorizationDecision(false);\n       }\n       return null;\n    }\n}\n```", "```java\nvoid decide(Authentication authentication, Object secureObject,\n       Collection<ConfigAttribute> attrs) throws AccessDeniedException;\nboolean supports(ConfigAttribute attribute);\nboolean supports(Class clazz);\n```", "```java\n//src/main/java/com/packtpub/springsecurity/web/access/intercept/JpaRequestConfigMappingService.java\n@Repository\npublic class JpaRequestConfigMappingService implements RequestConfigMappingService {\n    private final SecurityFilterMetadataRepository securityFilterMetadataRepository;\n    public JpaRequestConfigMappingService(final SecurityFilterMetadataRepository securityFilterMetadataRepository) {\n          this.securityFilterMetadataRepository = securityFilterMetadataRepository;\n    }\n    public List<RequestConfigMapping> getRequestConfigMappings() {\n          return securityFilterMetadataRepository\n                .findAll()\n                .stream()\n                .sorted(Comparator.comparingInt(SecurityFilterMetadata::getSortOrder))\n                .map(md -> new RequestConfigMapping(\n                      new AntPathRequestMatcher(md.getAntPattern()),\n                      new SecurityConfig(md.getExpression()))).toList();\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/domain/SecurityFilterMetadata.java\n@Entity\n@Table(name = \"security_filter_metadata\")\npublic class SecurityFilterMetadata implements Serializable {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Integer id;\n    private String antPattern;\n    private String expression;\n    private Integer sortOrder;\n... setters / getters ...\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/repository/ SecurityFilterMetadataRepository.java\npublic interface SecurityFilterMetadataRepository extends JpaRepository<SecurityFilterMetadata, Integer> {}\n```", "```java\n//src/main/resources/data.sql\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (115, '/','permitAll',15);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (120, '/login/*','permitAll',20);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (130, '/logout','permitAll',30);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (140, '/signup/*','permitAll',40);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (150, '/errors/**','permitAll',50);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','hasRole(\"ADMIN\")',60);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (170, '/events/','hasRole(\"ADMIN\")',70);\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (180, '/**','hasRole(\"USER\")',80);\n```", "```java\n//src/main/java/com/packtpub/springsecurity/web/access/intercept/FilterInvocationServiceSecurityMetadataSource.java\n@Component\npublic class FilterInvocationServiceSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {\n    private FilterInvocationSecurityMetadataSource delegate;\n    private final RequestConfigMappingService requestConfigMappingService;\n    public FilterInvocationServiceSecurityMetadataSource (RequestConfigMappingService filterInvocationService) {\n          this.requestConfigMappingService = filterInvocationService;\n    }\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\n          return this.delegate.getAllConfigAttributes();\n    }\n    public Collection<ConfigAttribute> getAttributes(Object object) {\n          if (delegate == null)\n             getDelegate();\n          return this.delegate.getAttributes(object);\n    }\n    public boolean supports(Class<?> clazz) {\n         return this.delegate.supports(clazz);\n    }\n    public void getDelegate() {\n          List<RequestConfigMapping> requestConfigMappings = requestConfigMappingService.getRequestConfigMappings();\n          LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>> requestMap = new LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>>(requestConfigMappings.size());\n          for (RequestConfigMapping requestConfigMapping : requestConfigMappings) {\n             RequestMatcher matcher = requestConfigMapping.getMatcher();\n             requestMap.put(matcher, requestConfigMapping.getAttributes());\n          }\n          this.delegate = new ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap, new DefaultWebSecurityExpressionHandler());\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity\npublic class SecurityConfig {\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http,\n       FilterInvocationServiceSecurityMetadataSource metadataSource,\n       AccessDecisionManager accessDecisionManager) throws Exception {\n    http.authorizeRequests().anyRequest().authenticated();\n    http.authorizeRequests().accessDecisionManager(accessDecisionManager);\n    http.authorizeRequests()\n          .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n             public <O extends FilterSecurityInterceptor> O postProcess(\n                   O fsi) {\n                fsi.setPublishAuthorizationSuccess(true);\n                fsi.setSecurityMetadataSource(metadataSource);\n                return fsi;\n             }\n          });\n...omitted for brevity\n    return http.build();\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/web/access/expression/ CustomWebSecurityExpressionRoot.java\npublic class CustomWebSecurityExpressionRoot extends WebSecurityExpressionRoot {\n    public CustomWebSecurityExpressionRoot(Authentication a, FilterInvocation fi) {\n       super(a, fi);\n    }\n    public boolean isLocal() {\n       return \"localhost\".equals(request.getServerName());\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/web/access/expression/ CustomWebSecurityExpressionHandler.java\n@Component\npublic class CustomWebSecurityExpressionHandler extends DefaultWebSecurityExpressionHandler {\n    private final AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();\n    @Override\n    protected SecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, FilterInvocation fi) {\n       WebSecurityExpressionRoot root = new CustomWebSecurityExpressionRoot(authentication, fi);\n       root.setPermissionEvaluator(getPermissionEvaluator());\n       root.setTrustResolver(trustResolver);\n       root.setRoleHierarchy(getRoleHierarchy());\n       return root;\n    }\n}\n```", "```java\n// Web Expression Handler:\nhttp.authorizeRequests()\n       .expressionHandler(customWebSecurityExpressionHandler);\n```", "```java\n//src/main/resources/data.sql\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','local and hasRole(\"ADMIN\")',60);\n```", "```java\n//src/main/java/com/packtpub/springsecurity/access/CalendarPermissionEvalua tor.java\npublic final class CalendarPermissionEvaluator implements PermissionEvaluator {\n    private final EventDao eventDao;\n    public CalendarPermissionEvaluator(EventDao eventDao) {\n        this.eventDao = eventDao;\n    }\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        if(targetDomainObject instanceof Event) {\n            return hasPermission(authentication, (Event) targetDomainObject, permission);\n        }\n        return targetDomainObject == null;\n    }\n    @Override\n    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType,\n                                 Object permission) {\n        if(!Event.class.getName().equals(targetType)) {\n            throw new IllegalArgumentException(\"targetType is not supported. Got \"+targetType);\n        }\n        if(!(targetId instanceof Integer)) {\n            throw new IllegalArgumentException(\"targetId type is not supported. Got \"+targetType);\n        }\n        Event event = eventDao.getEvent((Integer)targetId);\n        return hasPermission(authentication, event, permission);\n    }\n    private boolean hasPermission(Authentication authentication, Event event, Object permission) {\n        if(event == null) {\n            return true;\n        }\n        String currentUserEmail = authentication.getName();\n        String ownerEmail = extractEmail(event.getOwner());\n        if(\"write\".equals(permission)) {\n            return currentUserEmail.equals(ownerEmail);\n        } else if(\"read\".equals(permission)) {\n            String attendeeEmail = extractEmail(event.getAttendee());\n            return currentUserEmail.equals(attendeeEmail) || currentUserEmail.equals(ownerEmail);\n        }\n        throw new IllegalArgumentException(\"permission \"+permission+\" is not supported.\");\n    }\n    private String extractEmail(CalendarUser user) {\n        if(user == null) {\n            return null;\n        }\n        return user.getEmail();\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java\n@Bean\npublic DefaultMethodSecurityExpressionHandler defaultExpressionHandler(EventDao eventDao){\n    DefaultMethodSecurityExpressionHandler deh = new DefaultMethodSecurityExpressionHandler();\n    deh.setPermissionEvaluator(\n            new CalendarPermissionEvaluator(eventDao));\n    return deh;\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/service/CalendarService.java\n@PostAuthorize(\"hasPermission(returnObject,'read')\")\nEvent getEvent(int eventId);\n```", "```java\n  private boolean hasPermission(Authentication authentication, Event event, Object permission) {\n      if(event == null) {\n          return true;\n      }\n// Custom Role verification\nGrantedAuthority adminRole = new SimpleGrantedAuthority(\"ROLE_ADMIN\");\nif(authentication.getAuthorities().contains(adminRole)) {\n    return true;\n... omitted for brevity\n}\n  }\n```", "```java\n//src/main/java/com/packtpub/springsecurity/access/expression/ CustomWebExpression.java\n@Component\npublic class CustomWebExpression {\n    public boolean isLocalHost(final HttpServletRequest request) {\n       return \"localhost\".equals(request.getServerName());\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java\n@Bean\npublic DefaultWebSecurityExpressionHandler customWebSecurityExpressionHandler (){\n    return new DefaultWebSecurityExpressionHandler();\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java\n// Line of Expression Handler needs to be removed\nhttp.authorizeRequests()\n.expressionHandler(customWebSecurityExpressionHandler);\n```", "```java\n//src/main/resources/data.sql\ninsert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','@customWebExpression.isLocalHost(request) and hasRole(\"ADMIN\")',60);\n```", "```java\n//src/main/java/com/packtpub/springsecurity/access/ CustomAuthorizationManager.java\n@Component\npublic class CustomAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> {\n    private final SecurityExpressionHandler<RequestAuthorizationContext> expressionHandler;\n    private final RequestConfigMappingService requestConfigMappingService;\n    private static final Logger logger = LoggerFactory.getLogger(CustomAuthorizationManager.class);\n    public CustomAuthorizationManager(DefaultHttpSecurityExpressionHandler expressionHandler, RequestConfigMappingService requestConfigMappingService) {\n       this.expressionHandler = expressionHandler;\n       this.requestConfigMappingService = requestConfigMappingService;\n    }\n    @Override\n    public AuthorizationDecision check(Supplier<Authentication> authentication, RequestAuthorizationContext context) {\n       List<RequestConfigMapping> requestConfigMappings = requestConfigMappingService.getRequestConfigMappings();\n       LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>> requestMap = new LinkedHashMap<>(requestConfigMappings.size());\n       for (RequestConfigMapping requestConfigMapping : requestConfigMappings) {\n          RequestMatcher matcher = requestConfigMapping.getMatcher();\n          if (matcher.matches(context.getRequest())) {\n             requestMap.put(matcher, requestConfigMapping.getAttributes());\n             String expressionStr = requestConfigMapping.getAttributes().iterator().next().getAttribute();\n             Expression expression = this.expressionHandler.getExpressionParser().parseExpression(expressionStr);\n             try {\n                EvaluationContext evaluationContext = this.expressionHandler.createEvaluationContext(authentication, context);\n                boolean granted = ExpressionUtils.evaluateAsBoolean(expression, evaluationContext);\n                return new ExpressionAuthorizationDecision(granted, expression);\n             } catch (AccessDeniedException ex) {\n                logger.error(\"Access denied exception: {}\", ex.getMessage());\n                return new AuthorizationDecision(false);\n             }\n          }\n       }\n       return new AuthorizationDecision(false);\n    }\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http, AuthorizationManager<RequestAuthorizationContext> authorizationManager) throws Exception {\n    http\n          .authorizeHttpRequests(authorize -> authorize\n                .anyRequest()\n                .access(authorizationManager));\n...omitted for brevity\n    return http.build();\n}\n```", "```java\n//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java\n@Bean\npublic DefaultHttpSecurityExpressionHandler defaultHttpSecurityExpressionHandler(){\n    return new DefaultHttpSecurityExpressionHandler();\n}\n```"]