- en: Miscellaneous Improvements in JDK 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, new versions of Java were released every three years (on average).
    The release timeline changed with Java 9, with the adoption of a six-month release
    cadence. Java 10 was released just six months after the release of Java 9\. We
    already covered the major features of Java 10 in the first three chapters; [Chapter
    1](0ffcea11-5fd2-4b3a-a791-b5917061c1c7.xhtml), *Type Inference*, [Chapter 2](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml),
    *AppCDS*, and [Chapter 3](5dad8c1c-c2c4-4f32-8e5e-e39ce138d989.xhtml), *Garbage
    Collector Optimizations*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover the remaining additions or updates to Java 10,
    most of which are related to changes in the JDK or its implementation. We'll also
    cover a few additions and modifications to the Java API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local handshakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-based release versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consolidating the JDK forest into a single repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap allocation on alternative memory devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Unicode language-tag extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The experimental Java-based JIT compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the Native-Header Generation Tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will include an overview of the JDK 10 features that are related
    to the JDK or their implementation. This chapter will not include any code for
    you to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter covers multiple features in Java 10, let's quickly map the
    features with its **JDK Enhancement Proposal** (**JEP**) number and scope.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping JDK 10 features with scopes and JEPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table lists the JDK 10 features that will be covered in this
    chapter, the features'' corresponding JEP numbers, and their scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JEP No.** | **Scope** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 296 | Implementation | Consolidate the JDK forest into a single repository
    |'
  prefs: []
  type: TYPE_TB
- en: '| 312 | JDK | Thread-local handshakes |'
  prefs: []
  type: TYPE_TB
- en: '| 313 | JDK | Removal of the Native-Header Generation Tool (`javah`) |'
  prefs: []
  type: TYPE_TB
- en: '| 314 | SE | Additional Unicode language-tag extensions |'
  prefs: []
  type: TYPE_TB
- en: '| 316 | JDK | Heap allocation on alternative memory devices |'
  prefs: []
  type: TYPE_TB
- en: '| 317 | JDK | Experimental Java-based JIT compiler |'
  prefs: []
  type: TYPE_TB
- en: '| 319 | JDK | Root certificates |'
  prefs: []
  type: TYPE_TB
- en: '| 322 | SE | Time-based release versioning |'
  prefs: []
  type: TYPE_TB
- en: Let's get started with the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidating the JDK forest into a single repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to Java 9, JDK's code base used multiple repositories (there are eight repositories
    in Java 9—`root`, `corba`, `hotspot`, `jaxp`, `jaxws`, `jdk`, `langtools`, and
    `nashorn`). Consolidating the JDK forest aims to combine the multiple repositories
    used by the JDK into a single repository.
  prefs: []
  type: TYPE_NORMAL
- en: As JDK's code base grew over the years, it was stored in separate repositories
    on purpose, for a separation of concerns. However, as the JDK evolved, the code
    base also developed interdependencies across different repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages offered by these multiple repositories have outgrown the disadvantages
    with their maintenance. For interdependent changesets, you can't perform a single
    commit to a repository. There have been cases where the code for even a single
    (and simple) bug fix spanned multiple repositories. In such cases, the commit
    can't be performed atomically. A common approach is to use the same bug ID across
    multiple repositories. But this is not mandated, since using the same bug ID is
    not mandated, commits for same bug across different repositories could be made
    using different bug IDs. This can lead to difficulty in tracking bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the individual repositories don't have independent development tracks
    and release cycles. Java has one main release cycle, which includes changes in
    all of these repositories. Therefore, it was high time to integrate the JDK code
    base into one repository, to ease its maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: This is a housekeeping feature that won't affect how you write your code.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local handshakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that you need to pause a particular thread, executing a callback on
    it. Prior to thread-local handshakes, there wasn't any way to do that. The norm
    was to perform a global VM safepoint, which pauses all of the executing threads
    (and what a waste that is, if you meant to pause only one thread). With thread-local
    handshakes, it is possible to stop individual threads.
  prefs: []
  type: TYPE_NORMAL
- en: By aiming to reduce global VM safepoints, thread-local handshakes will reduce
    JVM latency and improve its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local handshakes are a JVM implementation feature that can't be used
    directly by developers.
  prefs: []
  type: TYPE_NORMAL
- en: Removal of the Native-Header Generation Tool (javah)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This version of JEP has removed the `javah` tool from the tools shipped with
    the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you need instances of your class to be referenced by native code
    in C. Developers have used the `javah` tool to generate the C header and source
    files from a Java class. The generated code is used to enable native code (say,
    written in C) to access the instances of your Java class. The `javah` tool creates
    a `.h` file, which defines `struct`, similar to the structure of your class. For
    multiple classes in a source file, the `javah` tool generates separate `.h` files.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of `javah` doesn't imply any decline in the usage of your Java classes
    by the native code.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 8, `javah` was enhanced to take on the responsibility of generating
    the C header and source code files. After testing over two versions, `javah` is
    being removed from Java SE 10.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of the `javah` tool is compensated by the advanced compilation options
    in `javac`, which can be used to generate the C header and source files.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Unicode language-tag extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature enhances `java.util.Locale` and its related API to implement an
    additional Unicode extension of the BCP 47 language tag. Support for the BCP 47
    language was added to JDK 7\. However, in JDK 7, support for the Unicode locale
    extension was limited to calendar and numbers. This feature allowed for the addition
    of an extension to a locale. JDK 9 added support for `ca` and `nu` tags, from
    BCP 47.
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK 10 added support for the following extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cu` (currency type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fw` (first day of the week)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rg` (region over)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you specify a locale extension, such as a number or currency type, it is
    not guaranteed that the underlying platform supports the requested extension.
    Unicode tag extensions are a language feature, and they can be used directly by
    the developers.
  prefs: []
  type: TYPE_NORMAL
- en: Heap allocation on alternative memory devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When JVM exhausts its heap memory, your application crashes with `OutOfMemoryException`.
    Imagine if you could configure your JVM to use an alternate memory device, like
    a **non-volatile dual in-line memory module** (**NV-DIMM**).
  prefs: []
  type: TYPE_NORMAL
- en: With the ever-increasing memory demands of applications that deal with large
    amounts of data, and with the availability of low-cost NV-DIMM memory, the ability
    to use alternate memory devices for heap allocations is bliss. It also leads to
    systems that work with heterogeneous memory architectures.
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement targets alternative memory devices that have the same semantics
    as **Dynamic Random Access Memory** (**DRAM**), so that they can be used instead
    of DRAM, without requiring any changes to the existing application code. All of
    the other memory structures, such as the stack, code heap, and so on, will continue
    to use DRAM.
  prefs: []
  type: TYPE_NORMAL
- en: A quick detail before we move forward—NV-DIMM has higher access latency compared
    to DRAM. But NV-DIMM has a larger capacity at a lower cost compared to DRAM. So,
    the low-priority processes can use NV-DIMM, whereas the high-priority processes
    can use DRAM memory.
  prefs: []
  type: TYPE_NORMAL
- en: Heap allocation is a JVM implementation detail that can't be used directly by
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: The experimental Java-based JIT compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java compilers that you worked with until now were usually written in C/C++.
    What would you think about a Java compiler written in Java?
  prefs: []
  type: TYPE_NORMAL
- en: Graal, a Java-based **just in-time** (**JIT**) compiler, was introduced in Java
    9\. Java 10 enables the use of Graal as an experimental JIT compiler on Linux/x64
    platforms. Eventually, Oracle will explore the possibility of using Graal as a
    Java-based JIT for the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Graal uses the JVM compiler interface, introduced in JDK 9\. The objective of
    Graal is not to compete with the existing JIT compilers. It is a part of the project
    Metropolis, which explores and incubates Java-on-Java implementation techniques
    for HotSpot, the open JDK implementation of the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Since Graal is written in Java, fears of using Graal are related to lower startup
    performance of applications and increased heap usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command-line compiler option can be used to enable Graal as your
    JIT compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Graal is an experimental JIT compiler that can be configured for use with command-line
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Root certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine configuring an account on a cloud storage service provider, using your
    system. The cloud interface can request a certificate and their values to be stored
    on your system. When reconnecting to the cloud service, your system automatically
    authenticates it using the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'With JDK, such certificates are stored in the `cacerts` keystore. The certificate
    file `cacerts` resides in the security directory of your JDK installation directory
    and represents **Certification Authority** (**CA**) certifications applicable
    to the system-wide key store, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `JAVA_HOME\lib\security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux, Solaris, and macOS X: `JAVA_HOME/lib/security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root certificates are used to establish trust in the certificate chains
    employed in the various security protocols. The problem is that the `cacerts`
    keystore doesn't have any certificates in the JDK source code, which is mandatory
    for the default functionality of security components, such as TLS, in OpenJDK
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: With root certificates, Oracle plans to bridge the gap between the OpenJDK build
    and OracleJDK builds. The users must populate their `cacerts` keystore with a
    set of root certificates to bridge this gap.
  prefs: []
  type: TYPE_NORMAL
- en: The plan is to provide a default set of rootCA certificates in JDK, and open
    source the root certificates in Oracle's Java SE Root CA program.
  prefs: []
  type: TYPE_NORMAL
- en: The root certificates can be issued by the CAs of Oracle's Java SE Root CA program.
  prefs: []
  type: TYPE_NORMAL
- en: Root certificates are a JDK feature.
  prefs: []
  type: TYPE_NORMAL
- en: Time-based release versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The feature of time-based release versioning revises the version-string scheme
    of JDK SE platform, for current and future time-based release versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the details of the elements used in the preceding string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$FEATURE`: With the new (and strict) six-month release cadence, this value
    is incremented every six months. The JDK version released on Mar 2018 was 10,
    the version released in Sep 2018 was JDK 11\. JDK 12 released in Mar 2019, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$INTERIM`: With the six-month release cadence, there aren''t any interim releases.
    However, this element is retained for potential future use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$UPDATE`: This element represents an update, incremented for compatible update
    releases that fix security issues, regressions, and bugs in newer features. This
    is incremented a month after the increment in `$FEATURE`, and every three months
    thereafter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$PATCH`: This element represents the emergency patch-release counter, for
    emergency releases for a critical bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you skimmed through the various additions and modifications
    to JDK 10, barring its main features of type inference, application class data
    sharing, and garbage collector optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the features covered in this chapter were related to the changes in
    JDK, including reducing global VM safepoints with thread-local handshakes, the
    removal of `javah`, using alternative memory devices for heap allocation, Graal,
    and root certificates. It includes fewer SE features—additional Unicode language-tag
    extensions and time-based release versioning. The consolidation of the JDK forest
    into a single repository is more of a housekeeping detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the new additions and modifications to JDK
    11\. I'm excited and hope you are, too!
  prefs: []
  type: TYPE_NORMAL
