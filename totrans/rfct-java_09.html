<html><head></head><body>
<div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-207"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-208"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.2.1">Beyond Code – Mastering Software Architecture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">At this point, everything should be crystal clear about why and how to constantly refactor your code; in general, why it’s important to have a clean, readable, and easily maintainable code base. </span><span class="koboSpan" id="kobo.3.2">But in today’s development world, it’s highly unlikely that we’ll have just one application, one component; it’s much more realistic to have various components interacting with each other. </span><span class="koboSpan" id="kobo.3.3">If it’s true, as it is, that according to Conway’s Law, a company is structured and organized in a way that mirrors its software systems, it’s crucial to have a cohesive yet scalable ecosystem – not just robust but resilient and, frequently mentioned, clean. </span><span class="koboSpan" id="kobo.3.4">Because even clean code can lead to epic disasters if interactions between various services are </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">poorly managed.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll tackle the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">an architecture?</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Architectural patterns</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Monolith </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">to microservices</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Bad smells in the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">microservices architecture</span></span></li>
</ul>
<h1 id="_idParaDest-209"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.14.1">What is an architecture?</span></h1>
<p><span class="koboSpan" id="kobo.15.1">Having come this far, we’ve realized that writing code is just a small part of our job. </span><span class="koboSpan" id="kobo.15.2">We need to focus on writing code that not only works but is also easy to read and maintain. </span><span class="koboSpan" id="kobo.15.3">We’ve learned </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.16.1">that there are many small adjustments we can make to make our work simpler and smoother. </span><span class="koboSpan" id="kobo.16.2">Now, let’s take a step back and think further: Is our job really only about code? </span><span class="koboSpan" id="kobo.16.3">Is writing good code (whatever that means) the only thing, even though it’s broad and complex, that we need to do well? </span><span class="koboSpan" id="kobo.16.4">If we’re asking this question, you can guess that the answer is: not at all! </span><span class="koboSpan" id="kobo.16.5">Just like in the movie </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Ratatouille</span></em><span class="koboSpan" id="kobo.18.1"> where Chef Gusteau says, “</span><em class="italic"><span class="koboSpan" id="kobo.19.1">Anyone can cook</span></em><span class="koboSpan" id="kobo.20.1">,” here, we can paraphrase his words and say that </span><em class="italic"><span class="koboSpan" id="kobo.21.1">anyone can code</span></em><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">It takes a little, in fact, to learn to write some lines of Java code or maybe even in some other simpler language. </span><span class="koboSpan" id="kobo.22.3">In recent months, technologies </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.23.1">related to </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.26.1">AI</span></strong><span class="koboSpan" id="kobo.27.1">) have exploded, which can literally write code for us. </span><span class="koboSpan" id="kobo.27.2">But what is really challenging is not just writing code or even pieces of software that work together but doing it well. </span><span class="koboSpan" id="kobo.27.3">As Robert C. </span><span class="koboSpan" id="kobo.27.4">Martin says, “</span><em class="italic"><span class="koboSpan" id="kobo.28.1">Getting software right </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">is hard.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Software architecture is like the blueprint for a software system. </span><span class="koboSpan" id="kobo.31.2">It’s the plan that outlines how different parts of the software work together. </span><span class="koboSpan" id="kobo.31.3">This involves making decisions about </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.32.1">how to design things to meet specific goals. </span><span class="koboSpan" id="kobo.32.2">It includes elements such as the different pieces of software, how they connect to each other, and the rules for organizing them. </span><span class="koboSpan" id="kobo.32.3">So, software architecture is basically the high-level design that guides the creation of a </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">software system.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The architecture of a software system is like the design or structure created by the people building it. </span><span class="koboSpan" id="kobo.34.2">It’s determined by how the system is divided into parts (components), how these parts are organized, and how they talk to each other. </span><span class="koboSpan" id="kobo.34.3">In simpler terms, it’s how the different pieces of the software are put together and work together. </span><span class="koboSpan" id="kobo.34.4">This is only one definition of architecture, shaped by the </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.36.1"> book by Robert C. </span><span class="koboSpan" id="kobo.36.2">Martin. </span><span class="koboSpan" id="kobo.36.3">Reading Martin Fowler’s works, instead, gives us another (funnier) definition of what architecture is: the collective knowledge that experienced developers have about the design of a system and the set of decisions you hope to make correctly at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">a project.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">We hope it’s a bit clearer what we mean by software architecture, but maybe it will be even clearer when we’ve explained its goals. </span><span class="koboSpan" id="kobo.38.2">On goals, the ideas seem quite clear in literature: good architecture makes things work better. </span><span class="koboSpan" id="kobo.38.3">The reason for creating a good architecture is to make it easier to develop, deploy, operate, and maintain the software system </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">it holds.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.40.1">Development</span></h2>
<p><span class="koboSpan" id="kobo.41.1">As long as there’s a small, single team handling the entire project, people may think that architecture </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.42.1">isn’t that important; in fact, it’s seen as almost an obstacle. </span><span class="koboSpan" id="kobo.42.2">This is why many projects, especially in the startup phase, often don’t have a proper architecture. </span><span class="koboSpan" id="kobo.42.3">However, as the project expands, rush to the rescue as soon as possible! </span><span class="koboSpan" id="kobo.42.4">In fact, it’s challenging to work with different teams on the same project, on the same module; it becomes necessary to divide the module itself into well-defined parts (“how” is a whole different story). </span><span class="koboSpan" id="kobo.42.5">Simply dividing the initial component into multiple components is not enough, though. </span><span class="koboSpan" id="kobo.42.6">It needs to be done carefully, understanding how these components will interact with each other. </span><span class="koboSpan" id="kobo.42.7">Otherwise, there’s a risk that from a single component, different ones may simply develop independently, each doing its own thing. </span><span class="koboSpan" id="kobo.42.8">And if everyone goes their own way, it’s difficult to </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.43.1">work on new features or fix existing problems. </span><span class="koboSpan" id="kobo.43.2">If a software system is difficult to develop, it’s unlikely to have a long and healthy lifespan. </span><span class="koboSpan" id="kobo.43.3">Therefore, the system’s architecture should be designed to make development easy for the team or teams working </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">on it.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.45.1">Deployment</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.46.1">Deployability</span></strong><span class="koboSpan" id="kobo.47.1"> means how easily and reliably software can be set up and run in a reasonable amount of time (ideally, with a single click). </span><span class="koboSpan" id="kobo.47.2">If there’s a problem with the new setup, it should </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.48.1">be possible to go back to the previous one without too much trouble. </span><span class="koboSpan" id="kobo.48.2">With the rise of virtualization and cloud systems, and as software systems get bigger, it’s the architect’s job to make sure setting up the software is done efficiently and predictably, reducing the overall risk for </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Unfortunately, many times, people don’t think about how to set up a system when they’re first building it. </span><span class="koboSpan" id="kobo.50.2">This can result in designs that make the system easy to create but really hard to get up </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">and running.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">For example, when starting to build a system, developers might opt for an architecture that includes a certain number of services and components. </span><span class="koboSpan" id="kobo.52.2">It might seem like a good idea for various reasons, such as smoother development and each piece working independently. </span><span class="koboSpan" id="kobo.52.3">However, during deployment, the team realizes that some of these services are interconnected and rely on each other to function properly. </span><span class="koboSpan" id="kobo.52.4">Deployment then becomes challenging, as you may need to deploy not only one service but also interconnected ones. </span><span class="koboSpan" id="kobo.52.5">If architects had considered the system setup from the beginning, they might have chosen fewer services, a combination of services and in-house components, and a more integrated approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">managing connections.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.54.1">System operation</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.55.1">System operation</span></strong><span class="koboSpan" id="kobo.56.1"> involves the </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.57.1">day-to-day management </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.58.1">and execution of a computer system or software application. </span><span class="koboSpan" id="kobo.58.2">It includes tasks such as running the software, keeping an eye on its performance, applying updates and fixes, ensuring security, handling backups, assisting users, and addressing issues as they arise. </span><span class="koboSpan" id="kobo.58.3">Essentially, it’s the ongoing effort to keep the system running smoothly and meeting </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">user needs.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The influence of architecture on system operation is generally considered not as significant as its impact on development, deployment, and maintenance. </span><span class="koboSpan" id="kobo.60.2">Most operational challenges can be addressed by increasing the system’s hardware resources without causing major changes to the software architecture; this scenario is quite common. </span><span class="koboSpan" id="kobo.60.3">Inefficient software architectures can often be made to function effectively by merely adding </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.61.1">more storage and servers. </span><span class="koboSpan" id="kobo.61.2">The affordability of hardware </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.62.1">compared to the cost of human resources means that architectures causing obstacles in operation are not as expensive as those hindering development, deployment, </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">and maintenance.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Just because the impact of bad architecture on operations is easily fixable doesn’t mean it’s not an important aspect. </span><span class="koboSpan" id="kobo.64.2">Even though the so-called “hardware” (which often translates </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.65.1">to buying cloud computing services from companies such as </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.68.1">AWS</span></strong><span class="koboSpan" id="kobo.69.1">), Google, or Microsoft) costs less than people and time, it doesn’t mean it’s inexpensive or an insignificant cost. </span><span class="koboSpan" id="kobo.69.2">An inefficient architecture that requires a disproportionate number of resources compared to the value it brings (whether economic or otherwise) should be </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">a concern.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.71.1">Maintenance</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.72.1">Software maintenance</span></strong><span class="koboSpan" id="kobo.73.1"> refers to the ongoing process of managing and updating software to </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.74.1">ensure it continues to meet the needs </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.75.1">of users and remains effective over time. </span><span class="koboSpan" id="kobo.75.2">It involves making modifications, fixing bugs, improving performance, and adapting the software to changes in the environment or </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">user requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">In this case, we could make a direct comparison with the architecture of buildings to understand how it impacts the manageability of a project. </span><span class="koboSpan" id="kobo.77.2">Imagine two buildings, two residences: one very complicated and sophisticated, unique in its kind; it has special aesthetic and technological features created specifically for the occasion, refined materials, and unique solutions. </span><span class="koboSpan" id="kobo.77.3">The other building is a classic European apartment complex, with straight facades and identical windows, common and sturdy materials, very similar to others encountered before. </span><span class="koboSpan" id="kobo.77.4">In the case that I have to make a change or solve a problem, in which building do you think it would be easier </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">to operate?</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Out of all the parts of a computer program, keeping it up and running is the most expensive. </span><span class="koboSpan" id="kobo.79.2">The constant need for new features and fixing mistakes takes a lot of time and effort from people. </span><span class="koboSpan" id="kobo.79.3">The main cost of keeping a program going comes from searching through </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.80.1">the existing code and dealing with risks. </span><span class="koboSpan" id="kobo.80.2">Searching through the code, called </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">spelunking</span></strong><span class="koboSpan" id="kobo.82.1"> by Robert C. </span><span class="koboSpan" id="kobo.82.2">Martin in his book </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.84.1">, takes time and money to figure out the best way to add something new or fix a mistake. </span><span class="koboSpan" id="kobo.84.2">When making these changes, there’s always a chance of accidentally causing new problems, which adds to the risk </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">and cost.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Having a well-thought-out plan for how the program is set up can really help cut down on these costs. </span><span class="koboSpan" id="kobo.86.2">If the program is split into different parts and each part is kept separate through </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.87.1">stable connections, it makes it much </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.88.1">easier to add new things without accidentally causing problems. </span><span class="koboSpan" id="kobo.88.2">This kind of planning reduces the risk of unintended issues and makes maintenance </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">less costly.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Now that we have seen what architecture is and why it’s important, let’s discover the main types of architecture we </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">can have.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.92.1">Architectural patterns</span></h1>
<p><span class="koboSpan" id="kobo.93.1">In software, we can organize things in different ways, and these organized structures are called </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">software architecture patterns</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">Many of them have been tried and proven to work well </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.96.1">for solving different problems. </span><span class="koboSpan" id="kobo.96.2">Each pattern arranges things in a specific way to fix particular issues </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">in software.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">But let’s keep it interesting and not dive into a super long list of these patterns. </span><span class="koboSpan" id="kobo.98.2">Instead, we’ll look at a few of the most important and commonly used ones. </span><span class="koboSpan" id="kobo.98.3">This way, we can understand the main ideas without getting overwhelmed by all </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the possibilities.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.100.1">Layered architecture</span></h2>
<p><span class="koboSpan" id="kobo.101.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">layered architecture pattern</span></strong><span class="koboSpan" id="kobo.103.1"> (also </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.104.1">called the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">n-tier architecture pattern</span></strong><span class="koboSpan" id="kobo.106.1">) is probably </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.107.1">the most widely </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.108.1">used design approach. </span><span class="koboSpan" id="kobo.108.2">It’s the </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.109.1">go-to standard for many Java </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Enterprise Edition</span></strong><span class="koboSpan" id="kobo.111.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.112.1">EE</span></strong><span class="koboSpan" id="kobo.113.1">) applications, and it’s well-known among architects, designers, and developers. </span><span class="koboSpan" id="kobo.113.2">This pattern closely aligns with typical communication and organizational setups in most companies, making it a logical and common choice for developing </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">business applications.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">In the layered architecture pattern, components are organized into horizontal layers, each with a specific role in the application (such as presentation or business logic). </span><span class="koboSpan" id="kobo.115.2">While the pattern doesn’t prescribe a fixed number of layers, common setups have four: </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">presentation</span></strong><span class="koboSpan" id="kobo.117.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">business</span></strong><span class="koboSpan" id="kobo.119.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">persistence</span></strong><span class="koboSpan" id="kobo.121.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">database</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Sometimes, the business and persistence layers are combined for simplicity. </span><span class="koboSpan" id="kobo.123.3">Smaller apps might have three layers, while larger ones could have five </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">or more.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Each layer </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.126.1">has a distinct responsibility. </span><span class="koboSpan" id="kobo.126.2">For instance, the presentation layer handles user interfaces and communication, while the </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.127.1">business layer executes business rules. </span><span class="koboSpan" id="kobo.127.2">Layers create abstractions, simplifying tasks. </span><span class="koboSpan" id="kobo.127.3">The presentation layer focuses on displaying information, not retrieving it. </span><span class="koboSpan" id="kobo.127.4">Similarly, the business layer concentrates on business logic, leaving data retrieval to the persistence layer, which then passes data to the business layer for processing and onward to the presentation layer </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">for display:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.129.1"><img alt="Figure 9.1 – Layered architecture" src="image/B20912_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 9.1 – Layered architecture</span></p>
<p><span class="koboSpan" id="kobo.131.1">The layered architecture pattern excels in separating concerns among components. </span><span class="koboSpan" id="kobo.131.2">Each layer focuses solely on its relevant logic—presentation in the presentation layer, business in the business layer, and so forth. </span><span class="koboSpan" id="kobo.131.3">This classification simplifies role and responsibility models, making development, testing, governance, and maintenance straightforward. </span><span class="koboSpan" id="kobo.131.4">Defined component interfaces and limited scope contribute to </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">this ease.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Notably, every layer in the architecture is marked as closed, a crucial concept in this pattern. </span><span class="koboSpan" id="kobo.133.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">closed layer</span></strong><span class="koboSpan" id="kobo.135.1"> means a </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.136.1">request must pass through the immediate </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.137.1">layer below it before reaching the </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.138.1">next one beneath. </span><span class="koboSpan" id="kobo.138.2">For instance, a request from the presentation layer travels through the business layer, then to the persistence layer, and finally reaches the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">database layer.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.140.1">Monolithic application architectures</span></p>
<p class="callout"><span class="koboSpan" id="kobo.141.1">In a </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.142.1">layered architecture, as we said, the concept involves organizing different components or functionalities of a system into distinct layers. </span><span class="koboSpan" id="kobo.142.2">But these layers can be interpreted in </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">two ways:</span></span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.144.1">Different applications/deployments</span></strong><span class="koboSpan" id="kobo.145.1">: In this interpretation, each layer is considered a separate application or deployment. </span><span class="koboSpan" id="kobo.145.2">Each layer represents a self-contained unit with specific responsibilities. </span><span class="koboSpan" id="kobo.145.3">For example, you might have a presentation layer, business logic layer, and data access layer deployed as separate applications. </span><span class="koboSpan" id="kobo.145.4">This approach promotes modularity and facilitates scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">and maintenance.</span></span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.147.1">Components inside the same application (monolith or N-tier)</span></strong><span class="koboSpan" id="kobo.148.1">: Alternatively, the layers can be viewed as components within the same application. </span><span class="koboSpan" id="kobo.148.2">In a monolithic architecture or an N-tier architecture, different layers exist within a single application’s codebase. </span><span class="koboSpan" id="kobo.148.3">For instance, you could have a presentation layer handling user interfaces, a business logic layer managing application rules, and a data access layer interacting with the database—all within the confines of a </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">single application.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.150.1">Both interpretations are valid, and the choice between them depends on the specific architectural design goals and requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the system.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.152.1">Microservices</span></h2>
<p><span class="koboSpan" id="kobo.153.1">There are </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.154.1">many lengthy books about </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">microservices</span></strong><span class="koboSpan" id="kobo.156.1">, and it </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.157.1">would be impossible to tell you everything here and now. </span><span class="koboSpan" id="kobo.157.2">However, we should at least give you a general overview of the topic because for years – and perhaps still today – they have been one of the main trends in </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">our industry.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.159.1">Microservices architecture</span></strong><span class="koboSpan" id="kobo.160.1">, commonly abbreviated as microservices, is a specific way of structuring </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.161.1">applications. </span><span class="koboSpan" id="kobo.161.2">In this architectural style, a large application is broken down into smaller, independent parts, each with its distinct set of responsibilities. </span><span class="koboSpan" id="kobo.161.3">This approach enables the creation of more modular and manageable components within the overall system. </span><span class="koboSpan" id="kobo.161.4">To represent this, we could put an example of a very common application, having a microservice dedicated to searching for items, another one handling the order, another one dealing with accounting issues, and a last one dealing with notifying users via email, push, and so on. </span><span class="koboSpan" id="kobo.161.5">Here is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">microservices architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 9.2 – An example of microservices architecture" src="image/B20912_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 9.2 – An example of microservices architecture</span></p>
<p><span class="koboSpan" id="kobo.165.1">In the context of microservices, an application can consist of numerous internal microservices, each handling a specific function. </span><span class="koboSpan" id="kobo.165.2">When a user makes a request, the microservices work together to compose and fulfill that request. </span><span class="koboSpan" id="kobo.165.3">This decentralized and modular nature of microservices offers flexibility, scalability, and easier maintenance compared to monolithic architectures where all functionalities are tightly integrated into a single, </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">large application.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Understanding </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.168.1">the concept of a service component is crucial within this pattern. </span><span class="koboSpan" id="kobo.168.2">Instead of viewing services in a microservices architecture, it’s more beneficial to consider service components. </span><span class="koboSpan" id="kobo.168.3">These components </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.169.1">can vary in size, ranging from a single module to a substantial part of the application. </span><span class="koboSpan" id="kobo.169.2">Service components house one or more modules (that is, Java classes) representing either a specialized function (such as providing traffic information for a specific location) or an autonomous section of a comprehensive business application. </span><span class="koboSpan" id="kobo.169.3">Determining the appropriate level of granularity for service components stands as a significant challenge in the context of microservices architecture. </span><span class="koboSpan" id="kobo.169.4">Nobody I know is completely satisfied </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">with that!</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Another essential idea in the microservices architecture pattern is its distributed nature. </span><span class="koboSpan" id="kobo.171.2">In this framework, all components within the architecture are completely independent of each </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.172.1">other and are accessed through various remote </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.173.1">access protocols (such as </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Java Message Service</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.176.1">JMS</span></strong><span class="koboSpan" id="kobo.177.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Advanced Message Queuing Protocol</span></strong><span class="koboSpan" id="kobo.179.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.180.1">AMQP</span></strong><span class="koboSpan" id="kobo.181.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.183.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.184.1">REST</span></strong><span class="koboSpan" id="kobo.185.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Simple Object Access Protocol</span></strong><span class="koboSpan" id="kobo.187.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.188.1">SOAP</span></strong><span class="koboSpan" id="kobo.189.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">Remote Method Invocation</span></strong><span class="koboSpan" id="kobo.191.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">RMI</span></strong><span class="koboSpan" id="kobo.193.1">), and so on). </span><span class="koboSpan" id="kobo.193.2">The distributed aspect of this </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.194.1">architecture pattern is instrumental in achieving </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.195.1">remarkable scalability and </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">deployment </span></span><span class="No-Break"><a id="_idIndexMarker877"/></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">characteristics.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">In a microservices architecture, finding the right granularity for service components is a significant challenge. </span><span class="koboSpan" id="kobo.198.2">If they are too coarse-grained, you might miss out on the benefits of this pattern (deployment, scalability, testability, and loose coupling). </span><span class="koboSpan" id="kobo.198.3">On the other hand, overly fine-grained components can lead to service orchestration demands, turning your </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.199.1">lean microservices architecture into a complex </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">service-oriented architecture</span></strong><span class="koboSpan" id="kobo.201.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.202.1">SOA</span></strong><span class="koboSpan" id="kobo.203.1">) with added complexity, confusion, </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">and cost.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Detecting the granularity challenge is possible by looking for signs such as orchestrating service </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.206.1">components from the user interface or </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">application programming interface</span></strong><span class="koboSpan" id="kobo.208.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.209.1">API</span></strong><span class="koboSpan" id="kobo.210.1">) layer, indicating components may be too fine-grained. </span><span class="koboSpan" id="kobo.210.2">Inter-service communication for a single request may also suggest incorrect granularity or improper partitioning based on </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">business functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">If service-component orchestration persists regardless of granularity, it might signal that a microservices </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.213.1">architecture may not be the ideal choice. </span><span class="koboSpan" id="kobo.213.2">The distributed nature of this pattern makes maintaining a single transactional </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.214.1">unit across components challenging, requiring complex transaction compensation frameworks for rollback, adding unnecessary complexity to this otherwise simple and </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">elegant architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">The microservices </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.217.1">architecture offers a myriad of advantages that significantly impact the development and operation of large, </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">complex applications:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Continuous delivery and deployment</span></strong><span class="koboSpan" id="kobo.220.1">: One of the key strengths of the microservices architecture is its facilitation of continuous delivery and deployment. </span><span class="koboSpan" id="kobo.220.2">This means that updates, enhancements, or new features can be seamlessly integrated into the application without disrupting its </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">overall functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.222.1">Modular and easily maintained</span></strong><span class="koboSpan" id="kobo.223.1">: Microservices are designed to be small and modular, allowing for easy maintenance. </span><span class="koboSpan" id="kobo.223.2">Each service is focused on a specific business capability, making it more straightforward to understand, update, </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">and troubleshoot.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.225.1">Independent deployability</span></strong><span class="koboSpan" id="kobo.226.1">: A notable feature is the ability to independently deploy services. </span><span class="koboSpan" id="kobo.226.2">This ensures that changes or updates to a particular service do not require a comprehensive redeployment of the entire application, leading to more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">development processes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.228.1">Scalability on a service level</span></strong><span class="koboSpan" id="kobo.229.1">: Microservices empower teams to independently scale services based on their specific demands. </span><span class="koboSpan" id="kobo.229.2">This granular scalability optimizes resource utilization and responsiveness, enhancing the overall performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.231.1">Autonomous teams</span></strong><span class="koboSpan" id="kobo.232.1">: The microservices architecture fosters team autonomy, enabling different teams to work independently on specific services. </span><span class="koboSpan" id="kobo.232.2">This autonomy streamlines development cycles, allowing teams to innovate and iterate at their </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">own pace.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.234.1">Experimentation with new technologies</span></strong><span class="koboSpan" id="kobo.235.1">: Embracing microservices allows for easy experimentation and adoption of new technologies. </span><span class="koboSpan" id="kobo.235.2">Since services can be built and </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.236.1">deployed independently, teams can explore and implement cutting-edge tools or frameworks without overhauling the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">entire system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.238.1">Enhanced fault isolation</span></strong><span class="koboSpan" id="kobo.239.1">: In the microservices model, faults are isolated to individual services, preventing a failure in one service from cascading and affecting the entire application. </span><span class="koboSpan" id="kobo.239.2">This improves the overall resilience and robustness of </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the system.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.241.1">Of course, no technology is perfect, and the microservices system has some problems and challenges. </span><span class="koboSpan" id="kobo.241.2">Let’s </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.242.1">delve into significant challenges and issues associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">microservices architecture:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Service identification</span></strong><span class="koboSpan" id="kobo.245.1">: Determining the optimal set of services can be a demanding task. </span><span class="koboSpan" id="kobo.245.2">Selecting the right services that effectively represent distinct business capabilities requires careful consideration </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">and planning.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.247.1">Complexity of distributed systems</span></strong><span class="koboSpan" id="kobo.248.1">: Microservices involve the creation of distributed systems, adding a layer of complexity. </span><span class="koboSpan" id="kobo.248.2">This complexity extends to the development, testing, and deployment phases, posing challenges in ensuring seamless integration </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">and operation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.250.1">Coordination for feature deployment</span></strong><span class="koboSpan" id="kobo.251.1">: Deploying features that span multiple services necessitates meticulous coordination. </span><span class="koboSpan" id="kobo.251.2">Ensuring that various services work harmoniously to deliver a unified functionality demands careful planning and execution to </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">avoid disruptions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.253.1">Decision-timing dilemma</span></strong><span class="koboSpan" id="kobo.254.1">: Determining the opportune moment to adopt the microservices architecture is a challenging decision. </span><span class="koboSpan" id="kobo.254.2">Knowing when the benefits outweigh the drawbacks and aligning the transition with organizational needs requires </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">thoughtful evaluation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.256.1">Addressing these challenges is crucial for successfully implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">microservices architecture.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.258.1">Event-driven architecture</span></h2>
<p><span class="koboSpan" id="kobo.259.1">This is another common type of architectural pattern that can also be seen as a nuance of microservices. </span><span class="koboSpan" id="kobo.259.2">To put it simply, it involves designing a structure that recognizes events happening in the system—something that occurs—and making it react by producing some </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.260.1">kind of result. </span><span class="koboSpan" id="kobo.260.2">The examples of “things that can happen” are potentially endless: a user signs up for the platform, a third-party system calls </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.261.1">one of our webhooks, and an error occurs during some kind of process. </span><span class="koboSpan" id="kobo.261.2">For each of these events, one or more components will be listening and responding to the event itself. </span><span class="koboSpan" id="kobo.261.3">But let’s try to be a bit more formal in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">our definition.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">event</span></strong><span class="koboSpan" id="kobo.265.1"> refers to a </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.266.1">change in state or, more expansively, any observable occurrence that can be detected and documented by an application or device. </span><span class="koboSpan" id="kobo.266.2">These events can then be communicated and exchanged with other applications and devices. </span><span class="koboSpan" id="kobo.266.3">Within your enterprise, every incident—be it customer requests, updates in inventory, sensor readings, and the like—constitutes </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">an event.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">event-driven architecture</span></strong><span class="koboSpan" id="kobo.270.1"> is a way for decoupled services to talk to each other using events, which are like little messages about changes or updates. </span><span class="koboSpan" id="kobo.270.2">This is a pretty common approach in modern apps </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">with microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">In this setup, there are three </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">main parts:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.274.1">Event producers</span></strong><span class="koboSpan" id="kobo.275.1">: These </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.276.1">are the creators of events and publish them to the router; for example, “a purchase </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">is completed.”</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.278.1">Event routers or event brokers</span></strong><span class="koboSpan" id="kobo.279.1">: These are the organizers who decide where </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.280.1">each event should go. </span><span class="koboSpan" id="kobo.280.2">For example, you can </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.281.1">imagine something like “a completed purchase should result in sending an email to </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">the customer.”</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.283.1">Event consumers</span></strong><span class="koboSpan" id="kobo.284.1">: These are the parts of the system that want to know about certain </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.285.1">events; for example, a component that receives some data about a completed purchase and reacts by sending an email to </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">the customer.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.287.1">The cool thing is these different parts don’t have to know too much about each other. </span><span class="koboSpan" id="kobo.287.2">They just send out these little event messages, and the other parts can choose to listen and react or not. </span><span class="koboSpan" id="kobo.287.3">In our examples, the component that completes the purchase doesn’t know a thing about what will happen next; it just publishes an event. </span><span class="koboSpan" id="kobo.287.4">The consumer, who is in charge </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.288.1">of sending an email, doesn’t have to know anything about the purchase completion process. </span><span class="koboSpan" id="kobo.288.2">This makes things flexible because, for instance, you can update how the payment system works without messing up how the </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.289.1">mailing system works. </span><span class="koboSpan" id="kobo.289.2">They are like separate teams that can do their own thing without always checking with each other. </span><span class="koboSpan" id="kobo.289.3">This can often translate into two actually different teams working more or </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">less separately.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Sometimes, an event can also be referred to as a message; the terms are often interchangeable. </span><span class="koboSpan" id="kobo.291.2">A bit more specific is the concept of a command: unlike an event that defines a change of state in some data or entity within the domain, a command explicitly requires something to be done. </span><span class="koboSpan" id="kobo.291.3">The implicit aspect is that in this case, the one carrying out the action and publishing the event is aware of something that is supposed to happen afterward. </span><span class="koboSpan" id="kobo.291.4">Technologically, however, almost nothing changes. </span><span class="koboSpan" id="kobo.291.5">Here is a diagram of </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">event-driven architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.293.1"><img alt="Figure 9.3 – Event-driven architecture" src="image/B20912_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.294.1">Figure 9.3 – Event-driven architecture</span></p>
<p><span class="koboSpan" id="kobo.295.1">There are </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.296.1">several advantages to embracing an </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">event-driven architecture:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.298.1">The first is probably </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">independent scaling and fault isolation</span></strong><span class="koboSpan" id="kobo.300.1">: by adopting an event-driven architecture, the ability to scale and manage failures independently becomes a key benefit. </span><span class="koboSpan" id="kobo.300.2">As already mentioned, these are also benefits of microservices. </span><span class="koboSpan" id="kobo.300.3">Through the decoupling of services, each service interacts solely with the event router, rendering them agnostic to the existence of other services. </span><span class="koboSpan" id="kobo.300.4">Consequently, in the event of a failure in one service, the rest can continue to function seamlessly. </span><span class="koboSpan" id="kobo.300.5">The event router serves as an elastic buffer, adept at handling surges in workloads and ensuring overall </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">system stability.</span></span></li>
<li><span class="koboSpan" id="kobo.302.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">development is more agile</span></strong><span class="koboSpan" id="kobo.304.1"> because the event-driven model eliminates the need for custom code to poll, filter, and route events. </span><span class="koboSpan" id="kobo.304.2">Instead, the event router autonomously manages these tasks, automatically filtering and pushing events to consumers. </span><span class="koboSpan" id="kobo.304.3">This streamlined process significantly accelerates development cycles by minimizing the heavy coordination traditionally required between producer and consumer services. </span><span class="koboSpan" id="kobo.304.4">Developers can focus more on implementing business logic rather than dealing with intricate </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">event-handling intricacies.</span></span></li>
<li><span class="koboSpan" id="kobo.306.1">When you have an event router acting as a centralized hub for auditing applications and establishing policies, you get </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">effortless auditing</span></strong><span class="koboSpan" id="kobo.308.1">. </span><span class="koboSpan" id="kobo.308.2">These policies can dictate access controls, limiting who can publish and subscribe to the router and specifying permissions for users and resources to access data. </span><span class="koboSpan" id="kobo.308.3">Additionally, the event router facilitates the encryption of events both during transit and while at rest, enhancing data </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">security measures.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">You usually </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.311.1">also have some </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">cost reductions</span></strong><span class="koboSpan" id="kobo.313.1">: event-driven architectures operate on a push-based model, triggering actions only when an event is present in the router. </span><span class="koboSpan" id="kobo.313.2">This contrasts with continuous polling, leading to reduced network bandwidth consumption, lower CPU utilization, decreased idle fleet capacity, and fewer SSL/TLS handshakes. </span><span class="koboSpan" id="kobo.313.3">The result is a more cost-effective system that maximizes resource efficiency by minimizing unnecessary operations, providing both economic and </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">operational benefits.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.315.1">In the world of event-driven setups, there are two main ways things work: the pub/sub model and the event </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">streaming model.</span></span></p>
<h3><span class="koboSpan" id="kobo.317.1">Pub/sub model</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.318.1">Pub/sub</span></strong><span class="koboSpan" id="kobo.319.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">publish/subscribe</span></strong><span class="koboSpan" id="kobo.321.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">publisher/subscriber</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">This system functions </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.324.1">using a messaging </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.325.1">framework built on event stream subscriptions. </span><span class="koboSpan" id="kobo.325.2">Once an event takes place or is published, it is sent to subscribers who have expressed interest in that particular information. </span><span class="koboSpan" id="kobo.325.3">This method guarantees timely notification of relevant parties regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">unfolding events.</span></span></p>
<h3><span class="koboSpan" id="kobo.327.1">Event streaming</span></h3>
<p><span class="koboSpan" id="kobo.328.1">Unlike the </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.329.1">pub/sub model, the event streaming model </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.330.1">involves the recording of events in a log. </span><span class="koboSpan" id="kobo.330.2">Here, event consumers do not subscribe to an event stream; instead, they have the flexibility to read from any segment of the stream and can join the stream at </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">their convenience.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">There are some different types of event streaming, the main </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">ones being:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.334.1">Event stream processing</span></strong><span class="koboSpan" id="kobo.335.1">: Leverages a data streaming platform such as Apache Kafka </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.336.1">to intake events and handle the processing or transformation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">event stream</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Simple event processing</span></strong><span class="koboSpan" id="kobo.339.1">: An action </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.340.1">is promptly triggered in the event consumer as soon as an </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">event occurs</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.342.1">Apache Kafka</span></p>
<p class="callout"><span class="koboSpan" id="kobo.343.1">The most </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.344.1">widely tool used for event streaming is Apache Kafka. </span><span class="koboSpan" id="kobo.344.2">Apache Kafka stands out as a powerful distributed data streaming platform, widely recognized as a top-tier solution for event processing. </span><span class="koboSpan" id="kobo.344.3">Renowned for its versatility, this platform excels in managing the seamless flow of event streams in real-time, encompassing tasks such as publishing, subscribing, storing, and processing data. </span><span class="koboSpan" id="kobo.344.4">Designed to meet the demands of diverse use cases, Apache Kafka particularly shines in scenarios where high throughput and scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">are paramount.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.346.1">One of the distinctive features of Apache Kafka is its ability to efficiently handle a spectrum of data-sharing tasks without the need for intricate point-to-point integrations. </span><span class="koboSpan" id="kobo.346.2">This characteristic not only streamlines the overall architecture but also plays a pivotal role in reducing latency to an impressive millisecond scale. </span><span class="koboSpan" id="kobo.346.3">By offering a robust foundation for real-time data processing, Apache Kafka empowers organizations to harness the potential of timely insights and </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">responsive analytics.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.348.1">In essence, Apache Kafka emerges as an indispensable tool for industries and applications where the rapid exchange of information is critical. </span><span class="koboSpan" id="kobo.348.2">Its architecture not only supports the simultaneous handling of numerous events but also ensures that the system can effortlessly scale to accommodate growing demands. </span><span class="koboSpan" id="kobo.348.3">This combination of flexibility, scalability, and low-latency processing positions Apache Kafka as a preferred choice for businesses seeking a reliable and efficient solution for their data streaming and event </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">processing needs.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">The natural evolution of an event-driven architecture, especially one that adopts the event streaming pattern, is </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">reactive architecture.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.352.1">Reactive architecture</span></h2>
<p><span class="koboSpan" id="kobo.353.1">In recent years, a new </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.354.1">way of doing things in the Java world has become </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.355.1">popular, and it is called the </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">reactive paradigm</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">Let us try to understand the basic ideas. </span><span class="koboSpan" id="kobo.357.3">As usual, we don’t expect you to fully grasp the reactive paradigm in just one part of a book. </span><span class="koboSpan" id="kobo.357.4">The </span><em class="italic"><span class="koboSpan" id="kobo.358.1">Further reading</span></em><span class="koboSpan" id="kobo.359.1"> section is there for you, so you can explore more </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">about it!</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.362.1">reactive</span></em><span class="koboSpan" id="kobo.363.1"> is employed </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.364.1">in the realm of reactive systems (not only in Java), and it was coined in the 2014 Reactive Manifesto, a collaborative effort by the community to develop responsive and distributed systems. </span><span class="koboSpan" id="kobo.364.2">The manifesto emphasizes the creation of systems that </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">must be:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.366.1">Responsive</span></strong><span class="koboSpan" id="kobo.367.1">: The system promptly responds with minimal and predictable delays to </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.368.1">inputs to enhance user experience. </span><span class="koboSpan" id="kobo.368.2">For example, in a web application following reactive principles, user interface components are designed to update quickly in response to user interactions. </span><span class="koboSpan" id="kobo.368.3">For instance, when a user clicks a button, the system responds immediately, providing feedback without </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">noticeable delays.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.370.1">Resilient</span></strong><span class="koboSpan" id="kobo.371.1">: In the face of a component failure, the system gracefully handles it, minimizing the </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.372.1">impact on overall system availability and responsiveness. </span><span class="koboSpan" id="kobo.372.2">For example, consider a microservices architecture where one service fails due to a temporary issue. </span><span class="koboSpan" id="kobo.372.3">A resilient system would handle this failure gracefully, perhaps by rerouting requests to an alternative instance of the service, ensuring that the overall system </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.373.1">remains operational (</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">Circuit </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.375.1">Breaker pattern</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">).</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.377.1">Circuit Breaker pattern</span></p>
<p class="callout"><span class="koboSpan" id="kobo.378.1">Connecting to the concept of resilience, it’s worth talking about the </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">Circuit Breaker</span></strong><span class="koboSpan" id="kobo.380.1"> pattern; it is a design pattern to improve the resilience of a system. </span><span class="koboSpan" id="kobo.380.2">It is used to handle faults and failures in a distributed or remote service by detecting and preventing repeated failures. </span><span class="koboSpan" id="kobo.380.3">The pattern is inspired by the electrical circuit breaker, which automatically interrupts the flow of electricity when a fault is detected to prevent damage to the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">electrical system.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.382.1">A circuit breaker </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.383.1">operates by wrapping a function call (such as a remote service call) and monitoring for failures. </span><span class="koboSpan" id="kobo.383.2">When a certain threshold of failures is reached, the circuit breaker “trips” and stops allowing calls to that function for a specified period. </span><span class="koboSpan" id="kobo.383.3">During this time, the system can take alternative actions, such as returning a fallback response or retrying the operation after a delay. </span><span class="koboSpan" id="kobo.383.4">This prevents the system from repeatedly trying to call a failing service, which could lead to degraded performance or complete </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">system failure.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.385.1">If you’d like to implement a circuit breaker in your Java application, the most used libraries are </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.386.1">probably </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Hystrix</span></strong><span class="koboSpan" id="kobo.388.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.389.1">Resilience4j</span></strong><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">Developed by Netflix, Hystrix is a widely </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.391.1">used library for implementing the Circuit Breaker </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.392.1">pattern in Java. </span><span class="koboSpan" id="kobo.392.2">It provides </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">fault tolerance</span></strong><span class="koboSpan" id="kobo.394.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.395.1">FT</span></strong><span class="koboSpan" id="kobo.396.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">latency tolerance</span></strong><span class="koboSpan" id="kobo.398.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.399.1">LT</span></strong><span class="koboSpan" id="kobo.400.1">) features </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.401.1">for distributed systems. </span><span class="koboSpan" id="kobo.401.2">Resilience4j is a lightweight, modular library for handling failures in Java 8+ and functional programming styles. </span><span class="koboSpan" id="kobo.401.3">It provides several resilience patterns, including Circuit Breaker, Rate Limiter, Retry, and Bulkhead. </span><span class="koboSpan" id="kobo.401.4">If you’re using Spring Boot, </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Spring Cloud Circuit Breaker</span></strong><span class="koboSpan" id="kobo.403.1"> offers </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.404.1">a unified abstraction layer for various circuit breaker implementations. </span><span class="koboSpan" id="kobo.404.2">This framework presents a uniform API that developers can use within their applications, granting the flexibility to select the circuit breaker implementation that aligns most effectively with their specific application requirements. </span><span class="koboSpan" id="kobo.404.3">The supported implementations at the moment of writing are Resilience4j and </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">Spring Retry.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.406.1">Elastic</span></strong><span class="koboSpan" id="kobo.407.1">: The system </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.408.1">can adapt to varying workloads, maintaining consistent response times. </span><span class="koboSpan" id="kobo.408.2">For example, an elastic system could automatically scale its resources up or down based on demand. </span><span class="koboSpan" id="kobo.408.3">During peak usage, additional server instances might be provisioned to handle the increased load, and they can be scaled down during periods of </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">lower demand.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.410.1">Message-driven</span></strong><span class="koboSpan" id="kobo.411.1">: Systems </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.412.1">aligned with the manifesto employ a message-driven communication model. </span><span class="koboSpan" id="kobo.412.2">For example, in a distributed application, components communicate through messages rather than direct method calls: instead of invoking a remote service synchronously, a system following the message-driven approach might send a message </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.413.1">asynchronously and continue processing other tasks while awaiting </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">a response.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.415.1">A reactive architecture follows all these indications, emphasizing the propagation of changes and the declarative specification of the system’s behavior in response to those changes. </span><span class="koboSpan" id="kobo.415.2">In reactive systems, an often-used paradigm is the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Actor Model.</span></span></p>
<h3><span class="koboSpan" id="kobo.417.1">The Actor Model</span></h3>
<p><span class="koboSpan" id="kobo.418.1">I think it’s worth </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.419.1">mentioning the </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Actor Model</span></strong><span class="koboSpan" id="kobo.421.1"> because it’s truly interesting, serving as the foundation for reactive systems. </span><span class="koboSpan" id="kobo.421.2">The Actor Model is nothing new: it was introduced by Carl Eddie Hewitt in 1973 as a theoretical model for managing concurrent computation. </span><span class="koboSpan" id="kobo.421.3">Its practical relevance became evident as the software industry recognized the challenges associated with implementing concurrent and distributed applications. </span><span class="koboSpan" id="kobo.421.4">In other words: managing threads is not suitable anymore and we do not have faster CPUs; we only have CPUs with </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">more cores!</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">An actor is a </span><em class="italic"><span class="koboSpan" id="kobo.424.1">self-contained computational unit</span></em><span class="koboSpan" id="kobo.425.1">, embodying several crucial characteristics that distinguish it within the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">Actor Model:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.427.1">Encapsulation of state and logic</span></strong><span class="koboSpan" id="kobo.428.1">: An actor encapsulates both its state and a portion of the application logic. </span><span class="koboSpan" id="kobo.428.2">This encapsulation ensures that an actor’s internal workings are shielded from direct external access, promoting modular and </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">maintainable code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.430.1">Asynchronous message interaction</span></strong><span class="koboSpan" id="kobo.431.1">: Actors communicate exclusively through asynchronous messages, avoiding direct method calls. </span><span class="koboSpan" id="kobo.431.2">This design choice enhances the responsiveness of the system, as actors can continue processing messages independently without waiting for </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">immediate responses.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.433.1">Unique address and mailbox</span></strong><span class="koboSpan" id="kobo.434.1">: Each actor possesses a unique address and maintains a mailbox for incoming messages. </span><span class="koboSpan" id="kobo.434.2">The address serves as a distinct identifier in the system, while the mailbox provides a mechanism for other actors to deliver </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">messages asynchronously.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.436.1">Sequential message processing</span></strong><span class="koboSpan" id="kobo.437.1">: Messages in an actor’s mailbox are processed sequentially in the order of their arrival. </span><span class="koboSpan" id="kobo.437.2">The default implementation of the mailbox </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.438.1">often adopts a </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">First-In-First-Out</span></strong><span class="koboSpan" id="kobo.440.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.441.1">FIFO</span></strong><span class="koboSpan" id="kobo.442.1">) queue, ensuring predictable and ordered execution </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">of messages.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.444.1">Tree-like hierarchy</span></strong><span class="koboSpan" id="kobo.445.1">: The actor system is organized in a hierarchical, tree-like structure. </span><span class="koboSpan" id="kobo.445.2">This hierarchy facilitates the organization of actors, with each actor having a specific place and role within the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">larger system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.447.1">Dynamic actor operations</span></strong><span class="koboSpan" id="kobo.448.1">: Actors can dynamically create other actors, send messages to any actor within the system, and initiate their own termination or that of actors they have spawned. </span><span class="koboSpan" id="kobo.448.2">This dynamic behavior allows for flexible and adaptive </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">system architectures.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.450.1">Making programs </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.451.1">that do many things at the same time is tricky because we have to make sure different parts of the program don’t interfere with each other. </span><span class="koboSpan" id="kobo.451.2">The Actor Model makes it easier by letting us write code that can run independently without getting tangled up in </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">these issues.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Instead of directly asking another part of the program to do something and waiting for it to finish, we can send a message and keep going. </span><span class="koboSpan" id="kobo.453.2">This means the part sending the message doesn’t </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.454.1">have to wait around for a reply. </span><span class="koboSpan" id="kobo.454.2">A system using this feature is usually referred to as a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.455.1">non-blocking system</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">Using messages also helps prevent problems that can happen when many parts of the program are working at the same time. </span><span class="koboSpan" id="kobo.457.2">Messages are like notes passed between different parts, and they get dealt with one after the other, so there’s </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">no confusion.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Another good thing about the Actor Model is that if something goes wrong, such as a part of the program not doing what it’s supposed to, the actors can tell their “boss” about it. </span><span class="koboSpan" id="kobo.459.2">The boss can then decide whether to fix the problem or just start over with a fresh attempt. </span><span class="koboSpan" id="kobo.459.3">This way, the whole program can keep running smoothly even if there are hiccups along </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">the way.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">In Java, you can leverage the Actor Model by using </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">Akka</span></strong><span class="koboSpan" id="kobo.463.1">, a toolkit and runtime for building highly concurrent, distributed, and fault-tolerant systems. </span><span class="koboSpan" id="kobo.463.2">It provides abstractions for managing concurrency, making it easier to develop scalable and resilient applications. </span><span class="koboSpan" id="kobo.463.3">In the </span><em class="italic"><span class="koboSpan" id="kobo.464.1">Further reading</span></em><span class="koboSpan" id="kobo.465.1"> section, there’s a simple tutorial </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">about it.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">We have quickly covered several broad and somewhat complex concepts; much of it relies on modern, non-monolithic architecture. </span><span class="koboSpan" id="kobo.467.2">Let’s now say a few words about one of the main trends of recent years: breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">the monolith!</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.469.1">Monolith to microservices</span></h1>
<p><span class="koboSpan" id="kobo.470.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">monolithic architecture</span></strong><span class="koboSpan" id="kobo.472.1"> refers to a traditional approach in software design where an entire application is built as a single, unified code base. </span><span class="koboSpan" id="kobo.472.2">In a monolithic architecture, all components </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.473.1">and modules of the application are interconnected and interdependent. </span><span class="koboSpan" id="kobo.473.2">This means that the code for the user interface, business logic, and data access layers, among others, is tightly integrated into a single executable or </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">deployment unit.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">In a monolithic architecture, the entire application is developed and maintained within a single code base, making it a cohesive unit. </span><span class="koboSpan" id="kobo.475.2">All modules and components within the application are closely connected and share the same resources, such as databases and servers; therefore, the entire application is deployed as a single unit, making updates and releases a coordinated process. </span><span class="koboSpan" id="kobo.475.3">One advantage of the monolithic architecture is that it often uses a uniform technology stack throughout the entire system; the main disadvantage is that scaling a monolithic application typically involves replicating the entire application, which can be less efficient than scaling individual </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">components independently.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">While monolithic architectures have been the standard for many years and have certain advantages, such as simplicity in development and deployment, they also pose challenges, especially as applications grow in size and complexity. </span><span class="koboSpan" id="kobo.477.2">The move away from monolithic architecture has led to the adoption of alternative architectural patterns, the most common being microservices. </span><span class="koboSpan" id="kobo.477.3">This has been quite a mantra for the last few years, and there are lots of books and articles about that. </span><span class="koboSpan" id="kobo.477.4">We’ll just say a few words so that you don’t feel </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">completely unprepared!</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">Our first piece of advice is: don’t treat a monolith like it was necessarily evil because, well, it depends. </span><span class="koboSpan" id="kobo.479.2">In some cases, the monolith is OK. </span><span class="koboSpan" id="kobo.479.3">For example, if you have a small-scale application with limited complexity and traffic, the overhead of managing a microservices architecture might outweigh the potential benefits, especially if requirements don’t change that much. </span><span class="koboSpan" id="kobo.479.4">A monolith can be simpler to develop and maintain in such cases. </span><span class="koboSpan" id="kobo.479.5">Also, you could have limited resources: microservices often require specialized knowledge and additional infrastructure, which might not be feasible for smaller teams. </span><span class="koboSpan" id="kobo.479.6">Transitioning from a monolith to microservices requires time, effort, and potentially additional resources. </span><span class="koboSpan" id="kobo.479.7">If your organization is constrained in terms of time, budget, or expertise, maintaining the monolith might be a pragmatic decision. </span><span class="koboSpan" id="kobo.479.8">But the main reason could be that your monolith </span><em class="italic"><span class="koboSpan" id="kobo.480.1">just works</span></em><span class="koboSpan" id="kobo.481.1">: if your monolithic application is stable, performs well, and meets the current and foreseeable future needs of the business, there might not be a compelling reason to undergo the complexity of transitioning </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">to microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">While the benefits of microservices are evident, the transition from monolith to microservices comes with its own set of challenges. </span><span class="koboSpan" id="kobo.483.2">Entire books have been written on the argument, so we’ll just give you a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">of hints:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.485.1">Data management</span></strong><span class="koboSpan" id="kobo.486.1">: The transition to microservices introduces a paradigm shift in data management. </span><span class="koboSpan" id="kobo.486.2">In a monolith, data is often stored and accessed within a </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.487.1">unified database. </span><span class="koboSpan" id="kobo.487.2">However, in a microservices architecture, data is distributed across multiple services. </span><span class="koboSpan" id="kobo.487.3">This decentralization of data can lead to challenges in ensuring consistency and maintaining transactional integrity. </span><span class="koboSpan" id="kobo.487.4">Organizations must grapple with issues such as data synchronization, versioning, and cross-service transactions to avoid data inconsistencies and ensure the reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">their applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.489.1">Service communication</span></strong><span class="koboSpan" id="kobo.490.1">: Efficient communication between microservices is paramount </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.491.1">for the success of the architecture. </span><span class="koboSpan" id="kobo.491.2">Unlike monolithic applications, where function calls can be internal, microservices communicate over a network. </span><span class="koboSpan" id="kobo.491.3">Choosing appropriate communication protocols and mechanisms becomes crucial to facilitate seamless interactions between services. </span><span class="koboSpan" id="kobo.491.4">Decisions regarding synchronous or asynchronous communication, API design, and message formats require careful consideration to optimize the performance and reliability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">entire system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.493.1">Operational complexity</span></strong><span class="koboSpan" id="kobo.494.1">: The move to microservices introduces a new level of </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.495.1">operational complexity. </span><span class="koboSpan" id="kobo.495.2">Managing a distributed system involves orchestrating the deployment and scaling of multiple services. </span><span class="koboSpan" id="kobo.495.3">Monitoring the health and performance of each service, logging relevant information for debugging purposes, and ensuring the overall reliability of the system become intricate tasks. </span><span class="koboSpan" id="kobo.495.4">Organizations need robust tools and practices for distributed tracing, logging </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.496.1">aggregation, and monitoring to effectively navigate the operational challenges posed </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">by microservices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.498.1">Cultural shift</span></strong><span class="koboSpan" id="kobo.499.1">: Beyond technical considerations, transitioning to microservices often necessitates </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.500.1">a cultural shift within development teams. </span><span class="koboSpan" id="kobo.500.2">Embracing a DevOps mindset, where development and operations </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.501.1">teams collaborate closely </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.502.1">throughout the </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">software development life cycle</span></strong><span class="koboSpan" id="kobo.504.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.505.1">SDLC</span></strong><span class="koboSpan" id="kobo.506.1">), becomes essential. </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">Continuous integration</span></strong><span class="koboSpan" id="kobo.508.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">continuous deployment</span></strong><span class="koboSpan" id="kobo.510.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.511.1">CI/CD</span></strong><span class="koboSpan" id="kobo.512.1">) practices need to be adopted to enable rapid and reliable releases. </span><span class="koboSpan" id="kobo.512.2">This cultural transformation requires a commitment to automation, collaboration, and a shared sense of responsibility among </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">team members.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.514.1">Each of the previous points hides a world of challenges behind them. </span><span class="koboSpan" id="kobo.514.2">These challenges, while surmountable, underscore the need for a thoughtful and </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">well-executed transition.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">It would be really difficult, naive, and maybe even arrogant to try to guide you in just a few words through the transition to adopting a microservices architecture. </span><span class="koboSpan" id="kobo.516.2">I have been involved several times in projects where this transition took years and sometimes wasn’t even fully completed. </span><span class="koboSpan" id="kobo.516.3">It’s a lengthy process that requires great attention, especially in deciding how big a microservice should be. </span><span class="koboSpan" id="kobo.516.4">However, we can offer you some insights to understand what to pay attention to if you find yourself involved in such a transition (and it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">quite likely!):</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">Incremental adoption</span></strong><span class="koboSpan" id="kobo.519.1">: One of the best practices for a successful transition to microservices </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.520.1">involves adopting a strategy of incremental changes rather than a sudden, big-bang overhaul. </span><span class="koboSpan" id="kobo.520.2">Organizations often find it prudent to start the migration process by identifying and transitioning non-critical services first. </span><span class="koboSpan" id="kobo.520.3">This phased approach allows teams to gain experience with microservices while minimizing the impact on the overall system. </span><span class="koboSpan" id="kobo.520.4">It also facilitates the identification and resolution of challenges on a smaller scale before tackling more </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">critical components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">Effective communication</span></strong><span class="koboSpan" id="kobo.523.1">: In a microservices architecture, where services communicate over a network, establishing clear and effective communication channels is paramount. </span><span class="koboSpan" id="kobo.523.2">Organizations should define and adhere to well-defined APIs to ensure </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.524.1">seamless interaction between services. </span><span class="koboSpan" id="kobo.524.2">This not only enhances the reliability of the system but also facilitates the independence of services, enabling teams to evolve and update services without disrupting the entire application. </span><span class="koboSpan" id="kobo.524.3">Effective communication is foundational to achieving the modularity and flexibility that </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">microservices promise.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.526.1">Automated testing</span></strong><span class="koboSpan" id="kobo.527.1">: Comprehensive automated testing is a linchpin of successful </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.528.1">microservices adoption. </span><span class="koboSpan" id="kobo.528.2">Given the distributed nature of microservices, thorough testing is essential to catch issues early in the development and deployment process. </span><span class="koboSpan" id="kobo.528.3">Test suites should cover unit testing, integration </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.529.1">testing, and </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">end-to-end</span></strong><span class="koboSpan" id="kobo.531.1"> testing for each microservice. </span><span class="koboSpan" id="kobo.531.2">Automation not only accelerates the testing process but also provides a safety net for frequent deployments, ensuring that changes to one service do not inadvertently break the functionality of others. </span><span class="koboSpan" id="kobo.531.3">Consider adopting </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">contract testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.533.1">Monitoring and logging</span></strong><span class="koboSpan" id="kobo.534.1">: Operational complexities introduced by microservices necessitate robust monitoring and logging solutions. </span><span class="koboSpan" id="kobo.534.2">Organizations </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.535.1">should invest in tools that enable real-time monitoring of service health, performance metrics, and potential issues. </span><span class="koboSpan" id="kobo.535.2">Centralized logging allows for efficient debugging and troubleshooting across distributed services. </span><span class="koboSpan" id="kobo.535.3">Proactive monitoring and logging not only aid in maintaining system reliability but also contribute to a proactive approach to system optimization and </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">performance enhancement.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.537.1">Cultural alignment</span></strong><span class="koboSpan" id="kobo.538.1">: Transitioning </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.539.1">to a microservices architecture is not only a technological shift but also a cultural one. </span><span class="koboSpan" id="kobo.539.2">Fostering a culture of collaboration, shared responsibility, and continuous learning is crucial for the success of the transition. </span><span class="koboSpan" id="kobo.539.3">Teams should embrace a DevOps mindset, where development and operations collaborate closely, and there is a shared sense of ownership for the entire system. </span><span class="koboSpan" id="kobo.539.4">Continuous learning and knowledge sharing ensure </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.540.1">that teams are equipped to adapt to the evolving landscape of microservices and embrace the agility it brings to </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">software development.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.542.1">These best practices try to provide a roadmap for teams and organizations navigating the complex terrain of transitioning from monolithic architectures </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">to microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">When you have some kind of microservice architecture in place or, better, while designing it, you’ll want to be aware of some bad smells you could spot </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">quite easily.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.546.1">Bad smells in the microservices architecture</span></h1>
<p><span class="koboSpan" id="kobo.547.1">Just as there are </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">bad smells</span></strong><span class="koboSpan" id="kobo.549.1"> in code – issues that hide between methods and classes – there are </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.550.1">also problems related to how software components work together in a software architecture. </span><span class="koboSpan" id="kobo.550.2">These are recurring patterns or, rather, anti-patterns, and when we see them, we should be suspicious and take action if needed. </span><span class="koboSpan" id="kobo.550.3">Let’s take a look at some of the most </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">common ones.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.552.1">Shared persistence</span></h2>
<p><span class="koboSpan" id="kobo.553.1">“</span><em class="italic"><span class="koboSpan" id="kobo.554.1">Don’t cross the streams</span></em><span class="koboSpan" id="kobo.555.1">,” as the </span><em class="italic"><span class="koboSpan" id="kobo.556.1">Ghostbusters</span></em><span class="koboSpan" id="kobo.557.1"> used to say. </span><span class="koboSpan" id="kobo.557.2">It’s a bit like what happens with shared persistence. </span><span class="koboSpan" id="kobo.557.3">We talk about shared persistence when two or more microservices </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.558.1">share the same persistent data, such </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.559.1">as a database, a </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">Redis</span></strong><span class="koboSpan" id="kobo.561.1"> instance, or a cache. </span><span class="koboSpan" id="kobo.561.2">This can cause a few problems. </span><span class="koboSpan" id="kobo.561.3">First, if services </span><em class="italic"><span class="koboSpan" id="kobo.562.1">A</span></em><span class="koboSpan" id="kobo.563.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.564.1">B</span></em><span class="koboSpan" id="kobo.565.1"> try to read and write to the same data layer at the same time, synchronization problems can occur. </span><span class="koboSpan" id="kobo.565.2">What one service reads might have been written by another, and </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">However, the most significant issue, in my opinion, is the interdependence that arises when you need to make changes to the data structure itself. </span><span class="koboSpan" id="kobo.567.2">For example, simply changing, adding, or removing a column from a database table could become a big problem and might require modifying both microservices, even if one of them isn’t affected by the change. </span><span class="koboSpan" id="kobo.567.3">If we wanted to represent this situation in a very simple yet effective way, we would have a diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.569.1"><img alt="Figure 9.4 – Two (micro) services rely on the same data storage" src="image/B20912_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.570.1">Figure 9.4 – Two (micro) services rely on the same data storage</span></p>
<p><span class="koboSpan" id="kobo.571.1">The most obvious solution is to maintain a separate data storage layer for each microservice. </span><span class="koboSpan" id="kobo.571.2">This means that each microservice owns its data, and it’s responsible for providing </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.572.1">functions to access that data. </span><span class="koboSpan" id="kobo.572.2">When someone needs to use that data, they’ll use the microservice as a kind of </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">data abstraction</span></strong><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">They won’t </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.575.1">need to know where or how the data is stored. </span><span class="koboSpan" id="kobo.575.2">Data owned by a specific microservice should not be </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">duplicated elsewhere.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">However, it’s essential to </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.578.1">note that having a non-shared data storage layer doesn’t necessarily mean having a separate database for each microservice. </span><span class="koboSpan" id="kobo.578.2">It depends on the granularity of the service. </span><span class="koboSpan" id="kobo.578.3">For example, if you have a microservice that handles customers and their shipping addresses (such as in an e-commerce platform), you might have a database specific to this service. </span><span class="koboSpan" id="kobo.578.4">Customers and addresses are likely interconnected, so you might have relational tables linked; for example, by a foreign key. </span><span class="koboSpan" id="kobo.578.5">If you want to make your microservices more granular, say, a customer service and an address service, you can’t have completely separate and unrelated databases. </span><span class="koboSpan" id="kobo.578.6">However, you can ensure that the customer service writes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">CUSTOMER</span></strong><span class="koboSpan" id="kobo.580.1"> table and </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.581.1">the address service writes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">ADDRESS</span></strong><span class="koboSpan" id="kobo.583.1"> table. </span><span class="koboSpan" id="kobo.583.2">These tables will be related by a foreign key but will remain distinct. </span><span class="koboSpan" id="kobo.583.3">Data integrity will be guaranteed (also) by the properties of the relational database (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.584.1">ACID properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.586.1"><img alt="Figure 9.5 – Two services use different tables of the same database, which are related by the id-customer_id foreign key relationship" src="image/B20912_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.587.1">Figure 9.5 – Two services use different tables of the same database, which are related by the id-customer_id foreign key relationship</span></p>
<p><span class="koboSpan" id="kobo.588.1">Now, we’ve told </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.589.1">you how it should be, but we also </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.590.1">need to tell you that this doesn’t always happen, especially during the transition from a monolithic system to microservices. </span><span class="koboSpan" id="kobo.590.2">You may have to share the data storage layer for a while. </span><span class="koboSpan" id="kobo.590.3">However, our advice is to avoid this situation as much as possible and resolve this issue as soon as </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">you can.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.592.1">Shared libraries</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.593.1">Sharing persistence</span></strong><span class="koboSpan" id="kobo.594.1"> (data storage) leads to coupling problems, and the same goes for sharing libraries. </span><span class="koboSpan" id="kobo.594.2">One of the first things we discussed in this book, and generally emphasized </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.595.1">in studies and work, is the principle of </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.597.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.598.1">DRY</span></strong><span class="koboSpan" id="kobo.599.1">). </span><span class="koboSpan" id="kobo.599.2">Do things once, do them well, and reuse your code as much as possible. </span><span class="koboSpan" id="kobo.599.3">This is certainly a mantra to follow, but in the case of architecture (especially a microservices architecture), one must be </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">very cautious.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">Let’s imagine </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.602.1">having two services – two components that use the same shared library, always written and managed by us. </span><span class="koboSpan" id="kobo.602.2">If we need to make a change to this library, we will not only have to handle the change in the library itself but also update the dependency in the microservices, and perhaps even change the code if needed (this depends on whether we change the method signatures </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">or not).</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">The example we are discussing involves only two microservices and one library. </span><span class="koboSpan" id="kobo.604.2">However, within an architecture, there can be many interrelated components: component </span><em class="italic"><span class="koboSpan" id="kobo.605.1">A</span></em><span class="koboSpan" id="kobo.606.1"> is connected to component </span><em class="italic"><span class="koboSpan" id="kobo.607.1">B</span></em><span class="koboSpan" id="kobo.608.1">, which is connected to component </span><em class="italic"><span class="koboSpan" id="kobo.609.1">C</span></em><span class="koboSpan" id="kobo.610.1">, and so on. </span><span class="koboSpan" id="kobo.610.2">Modifying a library can potentially lead to a difficult-to-control ripple effect, triggering a chain of retesting, rebuilding, and redeploying that can be </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">quite costly.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">I’m not saying here not to use shared libraries. </span><span class="koboSpan" id="kobo.612.2">Shared libraries are crucial for avoiding code duplication among software components. </span><span class="koboSpan" id="kobo.612.3">Take logging, for instance. </span><span class="koboSpan" id="kobo.612.4">Custom logic, such as formatting or concealing sensitive data such as customer details, is often required. </span><span class="koboSpan" id="kobo.612.5">Now, picture </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.613.1">each component with its unique implementation. </span><span class="koboSpan" id="kobo.613.2">Consider the wasted developer hours if it’s not identical </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.614.1">across components. </span><span class="koboSpan" id="kobo.614.2">Aggregating logs becomes challenging, and slight implementation differences can lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">inconsistent labeling.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">Something such as the recent </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">log4j</span></strong><span class="koboSpan" id="kobo.618.1"> vulnerability poses a significant challenge if this implementation is spread all around the code base. </span><span class="koboSpan" id="kobo.618.2">Fixing it per microservice or component demands substantial effort. </span><span class="koboSpan" id="kobo.618.3">Conversely, with a custom logging library using </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">log4j</span></strong><span class="koboSpan" id="kobo.620.1"> internally, addressing the vulnerability only would require action at a single point. </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">Logging</span></strong><span class="koboSpan" id="kobo.622.1"> is a universal </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.623.1">feature in microservices, making it an excellent candidate for a shared library. </span><span class="koboSpan" id="kobo.623.2">Other examples include security, monitoring, async communication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">handling exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">Also, adding a middle layer between the code and external tools is really helpful. </span><span class="koboSpan" id="kobo.625.2">It protects the main part of the program from changes in those tools. </span><span class="koboSpan" id="kobo.625.3">This makes it easier to put new features in or fix problems. </span><span class="koboSpan" id="kobo.625.4">It also makes the code easier to read and work on with a team. </span><span class="koboSpan" id="kobo.625.5">After a year of doing this, it’s clear that it makes our software stronger and </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">more flexible.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">I’m trying to say here that while good architecture implies decoupling the different parts of the application, shared libraries do exactly the opposite. </span><span class="koboSpan" id="kobo.627.2">On the other hand, they reduce repetition, and that’s good! </span><span class="koboSpan" id="kobo.627.3">We have to find a balance. </span><span class="koboSpan" id="kobo.627.4">There’s no one-size-fits-all rule for every situation. </span><span class="koboSpan" id="kobo.627.5">You need to consider each case individually. </span><span class="koboSpan" id="kobo.627.6">In general, it could be said that it’s worth creating a shared library whenever you need to write code that doesn’t depend on the specific subject of the module you’re working on. </span><span class="koboSpan" id="kobo.627.7">The examples mentioned earlier (logging, security, monitoring, and so on) are things that can be used in different situations, no matter what specific area you’re </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">working in.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">There are different ways to handle your shared libraries. </span><span class="koboSpan" id="kobo.629.2">You could either set up a distinct repository </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.630.1">for each needed library or use a single repository (referred to as a </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">monorepo</span></strong><span class="koboSpan" id="kobo.632.1">; more on this in the </span><em class="italic"><span class="koboSpan" id="kobo.633.1">Further reading</span></em><span class="koboSpan" id="kobo.634.1"> section) that houses multiple libraries. </span><span class="koboSpan" id="kobo.634.2">The crucial point is to have some form of separation. </span><span class="koboSpan" id="kobo.634.3">For instance, you could have a single repository covering monitoring, security, and logging projects. </span><span class="koboSpan" id="kobo.634.4">Each project would be self-contained, except for any </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">necessary dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">It’s really important to keep the user’s decisions and logic inside a kind of protective bubble; this is crucial in programming and when making shared libraries. </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">Encapsulation</span></strong><span class="koboSpan" id="kobo.638.1"> is like a </span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.639.1">shield that stops unwanted access and keeps data safe from being leaked. </span><span class="koboSpan" id="kobo.639.2">That’s why it’s a must when you’re building shared libraries. </span><span class="koboSpan" id="kobo.639.3">Let’s imagine you’re making a library with code specific to a certain company, such as a tool </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.640.1">to put files into storage. </span><span class="koboSpan" id="kobo.640.2">The parts </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.641.1">that the user works with need to be designed in a general way, avoiding names such as </span><em class="italic"><span class="koboSpan" id="kobo.642.1">S3FileUploader</span></em><span class="koboSpan" id="kobo.643.1"> (because S3 is Amazon’s storage service). </span><span class="koboSpan" id="kobo.643.2">But why avoid these names? </span><span class="koboSpan" id="kobo.643.3">Well, think about this: what if in the future you want to switch to Azure Blob (which is like Microsoft’s version of Amazon S3)? </span><span class="koboSpan" id="kobo.643.4">If you had named things specifically to Amazon, all your users would have to change their ways of doing things. </span><span class="koboSpan" id="kobo.643.5">So, it’s better to use more general names, such as </span><em class="italic"><span class="koboSpan" id="kobo.644.1">FileUploader</span></em><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">Believe me, it’ll save you a bunch of time and work in the </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">long haul.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">Keep your library code clean. </span><span class="koboSpan" id="kobo.647.2">Even though many people may contribute to the shared library, avoid turning it into a big, complicated thing! </span><span class="koboSpan" id="kobo.647.3">Before adding a new library, think about it a lot. </span><span class="koboSpan" id="kobo.647.4">When you do add one, think about how it might change and who will use it. </span><span class="koboSpan" id="kobo.647.5">Don’t just make it for your own needs; that makes it hard for others to use or </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">add to.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Don’t put domain-specific code in there! </span><span class="koboSpan" id="kobo.649.2">Even shared business code probably doesn’t belong there. </span><span class="koboSpan" id="kobo.649.3">Even if it means each component that uses it has to copy it, a user model that starts the same for all components is still business-related logic that shouldn’t be in the library. </span><span class="koboSpan" id="kobo.649.4">That’s because different services might need to change later to fit their specific business needs. </span><span class="koboSpan" id="kobo.649.5">It’s not good if they all use the same model because it might have things that don’t relate to other microservices or even break them if they want to rename or change some of the logic. </span><span class="koboSpan" id="kobo.649.6">So, when working with a single repository, it’s a great idea to use conventional commits to talk about changes in the code. </span><span class="koboSpan" id="kobo.649.7">Follow some commit conventions you’ll find among the team, such as starting each commit with </span><em class="italic"><span class="koboSpan" id="kobo.650.1">fix</span></em><span class="koboSpan" id="kobo.651.1"> when you’re fixing something. </span><span class="koboSpan" id="kobo.651.2">This is helpful when someone else is trying to understand the history of the repository, what was done, and where things are in </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">Last but not least, when you’re dealing with a shared library that is a client library to another service, you could think about generating it. </span><span class="koboSpan" id="kobo.653.2">Rather than writing a shared library to interact with APIs in a system, it’s more effective to create an API specification. </span><span class="koboSpan" id="kobo.653.3">This specification can then be used to automatically generate API clients for various languages and services. </span><span class="koboSpan" id="kobo.653.4">Something really cool we did once was to include and use a library called </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">Feign</span></strong><span class="koboSpan" id="kobo.655.1">, a Java-based </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.656.1">declarative web service client developed by Netflix. </span><span class="koboSpan" id="kobo.656.2">It simplifies the creation of HTTP clients for RESTful services by allowing developers to define requests using annotations and interface methods. </span><span class="koboSpan" id="kobo.656.3">Feign integrates with Netflix Ribbon for load balancing, supports various data formats, and provides fallback mechanisms for enhanced application robustness. </span><span class="koboSpan" id="kobo.656.4">It’s commonly used in microservices architectures for efficient communication </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">between services.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.658.1">Direct communication</span></h2>
<p><span class="koboSpan" id="kobo.659.1">One of the primary motivations behind designing good architecture is the desire for improved flexibility and easier maintenance of the overall system. </span><span class="koboSpan" id="kobo.659.2">This flexibility is crucial for </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.660.1">accommodating changes within the application, including modifications to the API of individual services or adjustments </span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.661.1">to the communication protocols </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">between services.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">However, a challenge arises when clients communicate directly with different services. </span><span class="koboSpan" id="kobo.663.2">This direct communication model diminishes some of the benefits of a good architectural design, particularly regarding flexibility. </span><span class="koboSpan" id="kobo.663.3">When clients are tightly coupled to the specific addresses of other services, the ability to relocate or split these services becomes problematic. </span><span class="koboSpan" id="kobo.663.4">In essence, the address of a service becomes a fixed point, making it difficult to make structural changes to the system without impacting its clients. </span><span class="koboSpan" id="kobo.663.5">Additionally, when a service is publicly exposed, there is a constant need to maintain backward compatibility in its API to avoid disrupting existing clients. </span><span class="koboSpan" id="kobo.663.6">This is usually considered an anti-pattern, and we’re going to represent it with the following diagram, where you can see different types of devices connecting directly to the </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">exposed services:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.665.1"><img alt="Figure 9.6 – Different clients for different devices directly call the services" src="image/B20912_09_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.666.1">Figure 9.6 – Different clients for different devices directly call the services</span></p>
<p><span class="koboSpan" id="kobo.667.1">There are </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.668.1">many possible solutions to avoid this anti-pattern. </span><span class="koboSpan" id="kobo.668.2">Let’s </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.669.1">see a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">of them.</span></span></p>
<h3><span class="koboSpan" id="kobo.671.1">API gateway</span></h3>
<p><span class="koboSpan" id="kobo.672.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">API gateway</span></strong><span class="koboSpan" id="kobo.674.1"> is a server </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.675.1">or service that acts as an </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.676.1">entry point for a collection of services. </span><span class="koboSpan" id="kobo.676.2">Its primary role is to provide a centralized and unified point of entry for clients (such as mobile apps, web applications, or other services) to interact with various components. </span><span class="koboSpan" id="kobo.676.3">It basically sits between the client and server, providing other essential functions. </span><span class="koboSpan" id="kobo.676.4">Here is a diagram of an </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">API gateway:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.678.1"><img alt="Figure 9.7 – All of the clients of the different devices pass through the same API gateway" src="image/B20912_09_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.679.1">Figure 9.7 – All of the clients of the different devices pass through the same API gateway</span></p>
<p><span class="koboSpan" id="kobo.680.1">For example, API gateways </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.681.1">usually </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.682.1">provide </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">request routing</span></strong><span class="koboSpan" id="kobo.684.1">: an API gateway </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.685.1">routes incoming requests from clients to the appropriate service(s). </span><span class="koboSpan" id="kobo.685.2">It acts as a traffic cop, directing requests to the relevant service based on factors such as the endpoint, version, or </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">other criteria.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">The API </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.688.1">gateway can </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">aggregate multiple requests</span></strong><span class="koboSpan" id="kobo.690.1"> from clients into a single request to reduce the number of round trips between the client and the services. </span><span class="koboSpan" id="kobo.690.2">This is beneficial for optimizing performance and reducing </span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.691.1">latency. </span><span class="koboSpan" id="kobo.691.2">Similarly, the API gateway can </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">aggregate responses</span></strong><span class="koboSpan" id="kobo.693.1"> from multiple services before sending them back to the client. </span><span class="koboSpan" id="kobo.693.2">This can reduce the number of requests needed from the client and enhance overall </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">system efficiency.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.695.1">Load balancing</span></strong><span class="koboSpan" id="kobo.696.1"> distributes </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.697.1">incoming requests across multiple instances of a service to ensure optimal resource utilization and prevent overload on any single instance. </span><span class="koboSpan" id="kobo.697.2">The API gateway can handle this load balancing to enhance the system’s scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">and reliability.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">The API </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.700.1">gateway usually centralizes </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">authentication and authorization</span></strong><span class="koboSpan" id="kobo.702.1"> processes. </span><span class="koboSpan" id="kobo.702.2">It can enforce security measures such as validating API keys, handling user authentication, and ensuring that only authorized clients can access </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">specific services.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">To improve performance, the API gateway </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.705.1">can implement </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">caching</span></strong><span class="koboSpan" id="kobo.707.1"> strategies. </span><span class="koboSpan" id="kobo.707.2">It can store and retrieve responses from services in a cache, reducing the need to recompute or fetch the same </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">data repeatedly.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">The API gateway </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.710.1">often includes </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">monitoring and analytics</span></strong><span class="koboSpan" id="kobo.712.1"> tools to track the performance and usage of microservices. </span><span class="koboSpan" id="kobo.712.2">This information can be valuable for identifying bottlenecks, optimizing resource allocation, and ensuring the overall health of </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">An API gateway </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.715.1">can enforce </span><strong class="bold"><span class="koboSpan" id="kobo.716.1">rate limits</span></strong><span class="koboSpan" id="kobo.717.1"> on incoming API requests to prevent abuse or overuse of resources. </span><span class="koboSpan" id="kobo.717.2">This involves setting a maximum number of requests a user or client can make within a specified </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">time frame.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">Throttling can also be implemented through </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">quotas</span></strong><span class="koboSpan" id="kobo.721.1">, where clients are allocated a certain number of resources or requests over a defined period. </span><span class="koboSpan" id="kobo.721.2">Somehow related to quotas is the </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.722.1">concept of </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">monetization</span></strong><span class="koboSpan" id="kobo.724.1">: API gateways can track the usage of APIs by clients and implement usage-based billing. </span><span class="koboSpan" id="kobo.724.2">This involves charging clients based on the number of requests, data transferred, or other </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">relevant metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">An alternative to the API gateway pattern is the </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">Backend for Frontend</span></strong><span class="koboSpan" id="kobo.728.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.729.1">BFF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">) pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.731.1">Backend For Frontend (BFF)</span></h3>
<p><span class="koboSpan" id="kobo.732.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.733.1">BFF</span></em><span class="koboSpan" id="kobo.734.1"> refers to a design pattern in software development where a separate backend is created </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.735.1">for each frontend application or user interface. </span><span class="koboSpan" id="kobo.735.2">This approach is particularly common in the context of microservices architectures and is aimed at optimizing the interaction between frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">backend components.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">In a traditional </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.738.1">web application, there is usually a single backend that serves data and functionality to various frontend clients. </span><span class="koboSpan" id="kobo.738.2">However, as applications become more complex and diverse, with different platforms (web, mobile, and so on) and user experiences, managing all these requirements within a single backend can </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">become challenging.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">The BFF pattern addresses this challenge by creating specialized backend services for each frontend or client type. </span><span class="koboSpan" id="kobo.740.2">Each BFF is tailored to the specific needs of the corresponding frontend, providing a more efficient and targeted interface between the two layers. </span><span class="koboSpan" id="kobo.740.3">This allows frontend developers to have more control over the data and services they need, without being constrained by a monolithic backend that serves multiple purposes. </span><span class="koboSpan" id="kobo.740.4">Please be mindful that the BFF functions as a “proxy,” filtering and adjusting requests from a shared set of backend (BE) services to a particular frontend (FE) client. </span><span class="koboSpan" id="kobo.740.5">It is </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.741.1">essential that the BFF </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.742.1">does not duplicate backend business functionalities in theory, as doing so would compromise the integrity of the application. </span><span class="koboSpan" id="kobo.742.2">Here is a diagram of the </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">BFF pattern:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.744.1"><img alt="Figure 9.8 – In BFF, we have a gateway for each type of client" src="image/B20912_09_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.745.1">Figure 9.8 – In BFF, we have a gateway for each type of client</span></p>
<p><span class="koboSpan" id="kobo.746.1">In contrast to the earlier diagram, in this setup, each device type links to its dedicated API gateway tailored to its requirements. </span><span class="koboSpan" id="kobo.746.2">These gateways act as a kind of cover, hiding the services in the background and decoupling the devices from direct connections to </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">these services.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">There are several advantages to using the </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">BFF pattern:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.750.1">Specialization</span></strong><span class="koboSpan" id="kobo.751.1">: Each BFF </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.752.1">can be optimized for the specific requirements of its associated frontend, leading to better performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">user experience</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.754.1">Autonomy</span></strong><span class="koboSpan" id="kobo.755.1">: Frontend and backend teams can work more independently, as changes to one do not necessarily affect the other, provided the API contracts </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">are maintained</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.757.1">Scalability</span></strong><span class="koboSpan" id="kobo.758.1">: Different </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.759.1">frontends may have varying scalability needs, and BFFs allow for more fine-grained scalability planning based on </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">individual requirements</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.761.1">Flexibility</span></strong><span class="koboSpan" id="kobo.762.1">: BFFs can adapt to the technology stack and architectural choices that are most suitable for the specific frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">they serve</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.764.1">It’s important </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.765.1">to note that while the </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.766.1">BFF pattern offers advantages, it also introduces some complexities, such as the need to manage multiple backend services. </span><span class="koboSpan" id="kobo.766.2">Proper communication and coordination between frontend and backend teams, as well as adherence to well-defined API contracts, are crucial for the success of </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">this pattern.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.768.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.769.1">In this chapter, we’ve dived into the meaning of the term </span><em class="italic"><span class="koboSpan" id="kobo.770.1">architecture</span></em><span class="koboSpan" id="kobo.771.1"> and checked out its main variations. </span><span class="koboSpan" id="kobo.771.2">We’ve seen why having a clean, maintainable, and scalable architecture is important, and we’ve got some hints on how to achieve it (make sure to dig deeper in the </span><em class="italic"><span class="koboSpan" id="kobo.772.1">Further reading</span></em><span class="koboSpan" id="kobo.773.1"> section). </span><span class="koboSpan" id="kobo.773.2">We’ve looked at the main architectural patterns, from the (relatively) simpler ones to the slightly more complex ones designed for larger systems. </span><span class="koboSpan" id="kobo.773.3">We’ve also discussed what to watch out for when trying to break the monolith – moving from a monolithic architecture to a microservices one. </span><span class="koboSpan" id="kobo.773.4">Speaking of the latter, we’ve taken a quick look at some of the most common bad smells you might encounter. </span><span class="koboSpan" id="kobo.773.5">Remember – always keep your spider </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">senses active!</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">As you close this book, remember that writing good code is not a one-time effort but a continuous commitment to excellence. </span><span class="koboSpan" id="kobo.775.2">Act like a craftsman, constantly refining your code to reflect your evolving understanding of best practices and </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">industry trends.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">The concepts you’ve acquired here will not only result in more readable and efficient Java code but will also empower you to collaborate seamlessly with fellow developers, ultimately contributing to the success of your projects. </span><span class="koboSpan" id="kobo.777.2">As you start your coding journey, let the principles of clean code and the art of refactoring be your guiding lights, illuminating a path toward </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">software excellence.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">May your code always be clean, your designs elegant, and your ride in the world of Java programming be both fulfilling </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">and rewarding.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.781.1">Happy coding!</span></span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.782.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.783.1">Giuseppe Bonocore, </span><em class="italic"><span class="koboSpan" id="kobo.784.1">Hands-On Software Architecture with Java</span></em><span class="koboSpan" id="kobo.785.1">, Packt </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">Publishing Ltd.</span></span></li>
<li><span class="koboSpan" id="kobo.787.1">Robert C. </span><span class="koboSpan" id="kobo.787.2">Martin, </span><em class="italic"><span class="koboSpan" id="kobo.788.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.789.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">Prentice Hall</span></span></li>
<li><span class="koboSpan" id="kobo.791.1">Mark Richards, </span><em class="italic"><span class="koboSpan" id="kobo.792.1">Software Architecture </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.793.1">Patterns</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">, O’Reilly</span></span></li>
<li><span class="koboSpan" id="kobo.795.1">Martin Fowler’s work on </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">architecture: </span></span><a href="https://martinfowler.com/architecture/"><span class="No-Break"><span class="koboSpan" id="kobo.797.1">https://martinfowler.com/architecture/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.798.1">Monorepo </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.799.1">Explained</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">: </span></span><a href="https://monorepo.tools/"><span class="No-Break"><span class="koboSpan" id="kobo.801.1">https://monorepo.tools/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.802.1">Intro to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.803.1">Feign</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">: </span></span><a href="https://www.baeldung.com/intro-to-feign"><span class="No-Break"><span class="koboSpan" id="kobo.805.1">https://www.baeldung.com/intro-to-feign</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.806.1">Intro to Apache </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.807.1">Kafka</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">: </span></span><a href="https://www.baeldung.com/apache-kafka"><span class="No-Break"><span class="koboSpan" id="kobo.809.1">https://www.baeldung.com/apache-kafka</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.810.1">Akka: </span></span><a href="https://www.baeldung.com/akka-actors-java"><span class="No-Break"><span class="koboSpan" id="kobo.811.1">https://www.baeldung.com/akka-actors-java</span></span></a></li>
<li><span class="koboSpan" id="kobo.812.1">Sam Newman, </span><em class="italic"><span class="koboSpan" id="kobo.813.1">Monolith to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.814.1">Microservices</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">, O’Reilly</span></span></li>
</ul>
</div>
</body></html>