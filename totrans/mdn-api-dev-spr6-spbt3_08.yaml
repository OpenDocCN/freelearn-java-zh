- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proper automated testing helps you to reduce regression bugs and keeps your
    application stable. It makes sure that every change you make will fail during
    the build or testing phase if the change has any side effects on existing code.
    Investing in a test automation suite can give you peace of mind and will prevent
    any surprises in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you learn about test automation by showing you how to
    implement unit and integration test automation. You will learn how to test APIs
    manually and automatically. First, you will learn about automating unit and integration
    tests. After learning about these forms of automation, you will be able to make
    both types of testing an integral part of any build. You will also learn how to
    set up the **Java Code Coverage** (**JaCoCo**) tool to calculate different code
    coverage metrics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs and code manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs and code manually
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a continuous process in software development and maintenance cycles.
    You need to do full testing that covers all possible use cases and the respective
    code for each change. Different types of testing can be performed for APIs, including
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing is performed by developers to test the smallest
    unit (such as a class method) of code.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Integration testing is performed by developers to
    test the integration of different layers of components.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract testing**: Contract testing is performed by developers to make sure
    any changes that are made to the API won’t break the consumer code. The consumer
    code should always comply with the producer’s contract (API). It is primarily
    required in microservices-based development.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end** (**E2E**) **testing**: E2E testing is performed by the **quality
    assurance** (**QA**) team to test end-to-end scenarios, such as from the UI (consumer)
    to the backend.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User acceptance testing** (**UAT**): UAT is performed by business users from
    a business perspective and may overlap with E2E testing.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You performed manual API testing by using the cURL and Postman tools earlier
    in this book. Every change requires the APIs to be completely tested – not only
    the impacted APIs. There is a reason for this. You may assume that it only impacts
    certain APIs, but what if your underlying assumptions are wrong? It may impact
    the other APIs that you skipped, which would lead to production issues. This can
    create panic and may require a release to be rolled over or a patch to be released
    with a fix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to be in such situations, so products have a separate QA team
    that ensures releases are delivered with the best possible quality. QA teams do
    the separate E2E and acceptance testing (along with business/domain users), apart
    from the testing that’s done by the development team.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望处于这种情况下，因此产品有一个单独的QA团队，确保以最佳可能的质量交付发布。QA团队执行单独的端到端和验收测试（包括业务/领域用户），除了开发团队进行的测试之外。
- en: This extra assurance for high-quality deliverables needs more time and effort.
    The time taken now is much shorter because of automated testing. It was longer
    previously because we performed manual testing; therefore, software development
    cycles used to be huge in comparison to today. **Time to market** (**TTM**) is
    a huge factor in today’s competitive software industry. Today, you need faster
    release cycles. Moreover, quality checks, also known as testing, are an important
    and major part of release cycles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对高质量交付成果的额外保证需要更多的时间和精力。由于自动化测试，现在所需的时间要短得多。之前因为进行了手动测试，所以时间更长；因此，与今天相比，软件开发周期曾经非常庞大。"上市时间"（**TTM**）是当今竞争激烈的软件行业中的一个重要因素。今天，您需要更快的发布周期。此外，质量检查，也称为测试，是发布周期中的重要和主要部分。
- en: You can reduce the testing time by automating the testing process and making
    it an integral part of the CI/CD pipeline. **CI** stands for **continuous integration**,
    which means *build > test > merge* in a code repository. **CD** stands for **continuous
    delivery** and/or **continuous deployment**, both of which may be used interchangeably.
    Continuous delivery is a process where code is automatically tested and released
    (read and uploaded) to an artifact repository or container registry. Then, it
    can be picked and deployed to a production environment after manual approval.
    Continuous deployment is one step ahead of continuous delivery and automates all
    the steps. Continuous deployment also performs the automatic deployment to production
    once all tests are passed. Products that don’t release their code for public access
    use this approach, such as Facebook and Twitter. On the other hand, products/services
    that are available publicly, such as the Spring Framework and Java, use continuous
    delivery pipelines.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过自动化测试流程并将其作为CI/CD管道的组成部分来减少测试时间。"CI"代表**持续集成**，意味着在代码仓库中的*构建 > 测试 > 合并*。**CD**代表**持续交付**和/或**持续部署**，两者可以互换使用。持续交付是一个过程，其中代码会自动测试并发布（读取和上传）到工件存储库或容器注册库。然后，在手动批准后，它可以被选中并部署到生产环境。持续部署比持续交付更进一步，并自动化所有步骤。持续部署在所有测试通过后也会执行自动部署到生产环境。不向公众开放代码的产品，如Facebook和Twitter，使用这种方法。另一方面，公开可用的产品/服务，如Spring框架和Java，使用持续交付管道。
- en: We’ll automate the manual testing we have done so far in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中自动化到目前为止所进行的手动测试。
- en: Testing automation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Whatever testing you are doing manually can be automated and made part of the
    build. This means that any change or code commit will run the test suite as a
    part of the build. A build will only be successful if all the tests are passed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您正在手动执行什么测试，都可以自动化并将其作为构建的一部分。这意味着任何更改或代码提交都将作为构建的一部分运行测试套件。只有当所有测试都通过时，构建才会成功。
- en: You can add automated integration tests for all the APIs. So, instead of firing
    each API manually using cURL or Insomnia, the build will fire them, and the test
    result will be available at the end of the build.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为所有API添加自动化集成测试。因此，您不需要使用cURL或Insomnia手动触发每个API，构建将触发它们，测试结果将在构建结束时可用。
- en: In this section, you are going to write an integration test that will replicate
    the REST client call and test all the application layers, starting from the controller,
    all the way down to the persistence layer, including the database (H2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将编写一个集成测试，该测试将复制REST客户端调用并测试所有应用程序层，从控制器开始，一直到底层的持久化层，包括数据库（H2）。
- en: But before that, you will add the necessary unit tests. Ideally, these unit
    tests should have been added alongside the development process, or before the
    development process in the case of **test-driven** **development** (**TDD**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前，您将添加必要的单元测试。理想情况下，这些单元测试应该在开发过程中添加，或者在**测试驱动开发**（**TDD**）的情况下在开发过程之前添加。
- en: Unit tests are tests that validate the expected results of small units of code,
    such as a class’s methods. You can avoid most bugs if you have proper tests in
    place with good code (90% or above) and branch coverage (80% and above). Code
    coverage refers to metrics such as the number of lines and branches (such as `if-else`),
    which are validated when the tests are executed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Some classes or methods have dependencies on other classes or infrastructure
    services. For example, controller classes have dependencies on service and assembler
    classes, while repository classes have dependencies on Hibernate APIs. You can
    create mocks to replicate dependency behaviors and assume these are working as
    expected or behave as per the defined tests. This approach will allow you to test
    the actual code unit (such as a method) and validate its behavior.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore how to add unit tests before writing the
    integration tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I advise you to go back to [*Chapter 6*](B19349_06.xhtml#_idTextAnchor148)
    as a base for this chapter’s code. You don’t have to add any additional dependencies
    for unit tests. You already have the following dependency in `build.gradle` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `spring-boot-starter-test` adds all the required test dependencies, not
    only for the unit tests but also for the integration tests. You are going to primarily
    use the following libraries for testing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`junit-platform-commons`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-jupiter-engine` that allows you to run Jupiter-based tests on the JUnit
    Platform. It also provides the `junit-jupiter`, `junit-jupiter-api`, and `junit-jupiter-params`
    libraries.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JUnit Vintage** supports older versions of JUnit, such as versions 3 and
    4\. You are going to use the latest version in this book, which is 5, so you don’t
    need this bundle.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about JUnit at [https://junit.org/](https://junit.org/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**AssertJ**: AssertJ is a test assertion library that simplifies assertion
    writing by providing fluent APIs. It is also extendable. You can write custom
    assertions for your domain objects. You can find more about it at [https://assertj.github.io/doc/](https://assertj.github.io/doc/).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamcrest**: Hamcrest is another assertion library that provides assertions
    based on matchers. It also allows you to write custom matchers. You’ll find an
    example of both in this chapter, though AssertJ is preferable because it has fluent
    APIs. Chained methods help IDEs to suggest appropriate assertions based on a given
    object. You can choose one of the assertion libraries or both based on your use
    cases and liking. You can find out more about it at [http://hamcrest.org/](http://hamcrest.org/).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mockito**: Mockito is a mocking framework that allows you to mock objects
    (read dependencies) and to stub method calls. You can find out more about it at
    [https://site.mockito.org/](https://site.mockito.org/).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You already know that unit tests test the smallest testable code unit. But how
    can we write a unit test for controller methods? The controller runs on web servers
    and has the Spring web application context. If you write a test that uses `WebApplicationContext`
    and is running on top of a web server, then you can call it an integration test
    rather than a unit test.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be lightweight and must be executed quickly. Therefore, you
    must use `MockMvc`, a special class provided by the Spring test library, to test
    the controllers. You can use the standalone setup for `MockMvc` for unit testing.
    You can also use `MockitoExtension` to run the unit test on the JUnit Platform
    (JUnit 5 provides an extension for runners), which supports object mocking and
    method stubbing. You will also use the Mockito library to mock the required dependencies.
    These tests are fast and help developers build faster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write our test using AssertJ assertions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Testing using AssertJ assertions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write our first unit test for `ShipmentController`. The following code
    can be found in `src/test/java/com/packt/modern/api/controller/ ShipmentControllerTest.java`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Here, our test is using a Jupiter-based annotation (`ExtendWith`) that registers
    the extension (`MockitoExtension`) for running tests and supporting Mockito-based
    mocks and stubbing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The Spring test library provides the `MockMvc` class, which allows you to mock
    the Spring MVC. As a result, you can execute the controller methods by calling
    the associated API endpoints’ URI. The dependencies of the `ShipmentController`
    controller class, such as the service and assembler, are marked with `@Mock` annotations
    to create the mock instances of its dependencies. You can also use `Mockito.mock(classOrInterface)`
    to create the mock objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Another noticeable annotation is `@InjectMocks` on the controller declaration.
    It finds out all the declared mocks that are required for a testing class and
    injects them automatically. `ShipmentController` uses the `ShipmentService` and
    `ShipmentRepresentation``     ModelAssembler` instances, which are injected using its constructor. The Mockito-based
    `InjectMocks` annotation finds the dependencies in the `ShipmentController` class
    (service and assembler). Then, it looks for mocks of the service and assembler
    in the test class. Once it finds them, it injects these mock objects into the
    `ShipmentController` class. If required, you can also create an instance of the
    testing class using a constructor instead of using `@InjectsMocks`, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A mock of `MessageSource` is created for `RestApiHandler`, which is being used
    in the setup method. You’ll explore it further in the following code block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the declaration is `JacksonTester`, which is part of the Spring
    testing library. `JacksonTester` is a custom JSON assertion class that’s created
    using the AssertJ and Jackson libraries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The JUnit Jupiter API provides the `@BeforeAll` and `@BeforeEach` method annotations,
    which can be used to set up the prerequisites. As their names suggest, `@BeforeAll`
    is run once per test class, while `@BeforeEach` gets executed before each test
    execution. `@BeforeEach` can be placed on public non-static methods, whereas `@BeforeAll`
    should be used to annotate public static methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, JUnit provides the `@AfterAll` and `@AfterEach` annotations, which
    execute the associated methods after each test is executed and after each test
    is executed, respectively.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `@BeforeEach` annotation to set up the prerequisites for the
    `ShipmentControll``     erTest` class, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we initialize the `JacksonTester` fields with the object mapper instance
    received from `AppConfig`. This creates a custom message converter instance (`MappingJackson2HttpMes``sageConverter`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can create a `mockMvc` instance using the standalone setup and initialize
    the controller advice using its setter method. The `RestApiErrorHandler` instance
    uses the mock object of the `MessageResource` class. You can also set the message
    converter to `mockMvc` before building it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you initialize the instances of `ShipmentEntity` and `Shipment` (model).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are going to write the test for the `GET /api/v1/shipping/{id}` call,
    which uses the `getShipmentByOrderI``d()` method of the `ShipmentController` class.
    Tests are marked with `@Test`. You can also use `@DisplayName` to customize a
    test’s name in the test reports:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you are using the `Given > When > Then` language ([https://cucumber.io/docs/gherkin/](https://cucumber.io/docs/gherkin/)),
    which can be defined as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: Context of the test'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: Test action'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: Test result, followed by validation'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s read this test from a BDD perspective:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: The service is available and returns the list of shipments based on
    the given order ID and an assembler, which converts the list of entities into
    a list of models. It also adds HATEOAS links.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: The user calls the API via `GET /``api/shipping/a1b9b31d-e73c- 4112-af7c-b68530f38222`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: The test validates the received shipments associated with the given
    order ID.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mockito’s `MockitoBDD` class provides the `given()` fluent API to stub the mock
    objects methods. When `mockMvc.perform()` is called, internally, it calls the
    respective service and assembler mocks, which, in turn, call the stubbed methods
    and return the values defined in the stub (using `given()`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The `andDo(MockMvcResultHandlers.print())` method logs the request and response
    trace, including the payload and response body. If you want to trace all the `mockMvc`
    logs inside a test class, then you can configure them directly while initializing
    `mockMvc` instead of defining them individually in `mockMvc.perform()` calls,
    as shown here (the highlighted code):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the end, you perform assertions (whether the status is `200 OK` or not and
    whether the returned JSON object matches the expected object or not) using AssertJ
    fluent APIs. First, you use the `Asserts.assertThat()` function, which takes the
    actual object and compares it with the expected object using the `isEqualTo()`
    method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have used AssertJ assertions. Similarly, you can also use Spring
    and Hamcrest assertions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Testing using Spring and Hamcrest assertions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you know how to write JUnit 5 tests using `MockitoExtension`.
    You’ll use the same approach to write a unit test, except with assertions. This
    time, you will write an assertion using Hamcrest assertions, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: You have captured the `MockHttpResponse` instance from the `mockMvc.perform()`
    call in the previous test example – that is, `testGetShipmentByOrderId()`. This
    time, you will directly use the returned value of the `mockMvc.perform()` call
    rather than calling an extra `andReturn().getResponse()` on it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResultAction` class provides the `andExpect()` assertion method, which
    takes `ResultMatcher` as an argument. The `StatusResultMatchers.status(). isOk()`
    result matcher evaluates the HTTP status returned by the `perform()` call. The
    `VerifyJson()` method evaluates the JSON response object, as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `MockMvcResultMatchers.jsonPath()` result matcher takes two arguments
    – a JSON path expression and a matcher. Therefore, first, you must pass the JSON
    field name and then the Hamcrest matcher known as `Is.is()`, which is a shortcut
    for `Is.is(equalsTo(entity.getCity()))`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Writing the unit test for a service is much easier compared to writing one for
    the controller because you don’t have to deal with `MockMvc`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to test private methods in the next subsection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Testing private methods
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unit testing a private method is a challenge. The Spring test library provides
    the `ReflectionTestUtils` class, which provides a method called `invokeMethod`.
    This method allows to you invoke private methods. The `invokeMethod` method takes
    three arguments – the target class, the method’s name, and the method’s arguments
    (using variable arguments). Let’s use it to test the `AddressServiceImpl.toEntity()`
    private method, as shown in the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you can see that when you call `ReflectionTestUtils.invokeMethod()`
    with the given arguments, it returns the `AddressEntity` instance, which has been
    converted using the given argument’s `AddAddressReq` model instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Here, you are using a third kind of assertion using AssertJ’s `BDDAssertions`
    class. The `BDDAssertions` class provides methods that resonate with the BDD style.
    `BDDAssertions.then()` takes the actual value that you want to verify. The `as()`
    method describes the assertion and should be added before you perform the assertion.
    Finally, you perform verification using AssertJ’s assertion methods, such as `isEqualTo()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to test void methods in the next subsection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Testing void methods
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method that returns a value can easily be stubbed, but how can we stub a method
    that returns nothing? Mockito provides the `doNothing()` method for this. It has
    a wrapper `willDoNothing()` method in the `BDDMockito` class that internally uses
    `doNothing()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very handy, especially when you want such methods to do nothing while
    you’re spying, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `linkedList` is a real object and not a mock. However, if you want to
    stub a specific method, then you can use `spy()`. Here, when the `clear()` method
    is called on `spyLinkedList`, it will do nothing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `willDoNothing` to stub the void method and see how it helps test
    void methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, `AddressRepository.deleteById()` is being stubbed using
    Mockito’s `willDoNothing()` method. Now, you can use the `verify()` method of
    Mockito, which takes two arguments – the mock object and its verification mode.
    Here, the `times()` verification mode is used, which determines how many times
    a method is invoked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how to unit-test exceptional scenarios in the next subsection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mockito provides `thenThrow()` for stubbing methods with exceptions. BDDMockito’s
    `willThrow()` is a wrapper that uses it internally. You can pass the `Throwable`
    argument and test it like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you basically catch the exception and perform assertions on it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have explored the unit tests that you can perform for both controllers
    and services. You can make use of these examples and write unit tests for the
    rest of the classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Executing unit tests
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the following command to execute unit tests:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate the unit test reports at `Chapter08/build/reports/tests/test/index.html`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A generated test report will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Unit test report](img/Figure_08.1_B19349.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Unit test report
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the links to drill down further. If the test fails, it also
    shows the cause of the error.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next section to learn how to configure code coverage for
    unit tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code coverage provides important metrics, including line and branch coverage.
    You are going to use the **JaCoCo** tool to perform and report your code coverage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add the `jacoco` Gradle plugin to the `build.gradle` file,
    as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the `jacoco` plugin by providing its version and reports directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, create a new task called `jacocoTestReport` that depends on the `test`
    task because code coverage can only be evaluated after test execution. You don’t
    want to calculate coverage for auto-generated code, so add the `exclude` block.
    Exclusion can be added by configuring `afterEvaluate`, as shown in the following
    code block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, you need to configure `jacocoTestCoverageVerification`, which defines
    the violation rules. We have added instructions to cover the ratio rule in the
    following code block. This will set the expected ratio to a minimum of 90%. If
    the ratio is below 0.9, then it will fail the build. You can find out more about
    such rules at https://docs.gradle.org/current/userguide/jacoco_plugin.html#sec:jacoco_report_violation_rules:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add `finalizedBy(jacocoTestReport)` to the test task, which ensures that
    the `jacocoTestReport` task will execute after performing the tests:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s run the following command to generate the code coverage report:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous command will not only run the test but also generate the code
    coverage report, along with the test reports. The code coverage report is available
    at `Chapter08/build/jacoco/test/html/index.html` and looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Code coverage report](img/Figure_08.2_B19349.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Code coverage report
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that our instruction coverage is only at 29%, while our branch
    coverage is only at 3%. You can add more tests and increase these percentages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about integration testing in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the automated integration tests in place, you can ensure that
    any changes you make won’t produce bugs, provided you cover all the testing scenarios.
    You don’t have to add any additional plugins or libraries to support integration
    testing in this chapter. The Spring test library provides all the libraries required
    to write and perform integration testing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the configuration for integration testing in the next subsection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Integration testing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you need a separate location for your integration tests. This can be
    configured in `build.gradle`, as shown in the following code block:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you add the integration tests and their resources to source sets. Gradle
    then picks the tests when a relevant Gradle command (`integrationTest`, `build`)
    gets executed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can configure the integration test’s implementation and runtime so
    that it’s extended from the test’s implementation and runtime, as shown in the
    following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, create a task called `integrationTest` that will not only use the JUnit
    Platform but also use our `classpath` and test `classpath` from `sourceSets.`
    `integrationTest`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, configure the check task so that it depends on the `integrationTest`
    task and run `integrationTest` after the test task. You can remove the last line
    in the following code block if you want to run `integrationTest` separately:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can start writing the integration tests. Before writing integration
    tests, first, let’s write the supporting Java classes in the next subsection.
    First, let’s create the `TestUtils` class. This will contain a method that returns
    an instance of `ObjectMapper`. It will contain a method to check whether the JWT
    has expired.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Writing supporting classes for integration tests
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ObjectMapper` instance was retrieved from the `AppConfig` class and added
    an extra configuration so that we can accept a single value as an array. For example,
    a JSON string field value might be `{[{…}, {…}]}`. If you take a closer look at
    it, you will see that it is an array wrapped as a single value. When you convert
    this value into an object, `ObjectMapper` treats it as an array. The complete
    code for this class is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need a client that lets you log in so that you can retrieve the JWT.
    `RestTemplate` is an HTTP client in Spring that provides support for making HTTP
    calls. The `AuthClient` class makes use of `TestRestTemplate`, which is a replica
    of `RestTemplate` from a testing perspective.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write this `AuthClient` class, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The Spring test library provides `MockMvc`, `WebTestClient`, and `TestRestTemplate`
    for performing integration testing. You have already used `MockMvc` in unit testing.
    The same approach can be used for integration testing as well. However, instead
    of using mocks, you can use the actual objects by adding the `@SpringBootTest`
    annotation to the test class. `@SpringBootTest`, along with `SpringExtension`,
    provides all the necessary Spring context, such as the actual application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`@TestPropertySource` provides the location of the test properties file.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTestClient` is used to test the reactive applications. However, to test
    REST services, you must use `TestRestTemplate`, which is a replica of `RestTemplate`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The integration test you are going to write is a fully fleshed-out test that
    doesn’t contain any mocks. It will use Flyway scripts, like the actual application,
    which we added to `src/integration/resources/db/migration`. The integration test
    will also have its own `application.properties` located in `src/integration/resources`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the integration test will be as good as if you are hitting the REST
    endpoints from REST clients such as cURL or Postman. These Flyway scripts create
    the tables and data required in the H2 memory database. This data will then be
    used by the RESTful web service. You can also use other databases, such as Postgres
    or MySQL, using their test containers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new integration test called `AddressControllerIT` in `src/ integration/java`
    in an appropriate package and add the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Here, `SpringExtension` is now being used to run the unit test on the JUnit
    Platform. The `SpringBootTest` annotation provides all the dependencies and context
    for the test class. A random port is being used to run the test server. You are
    also using `@TestMethodOrder`, along with the `@Order` annotation, to run the
    test in a particular order. You are going to execute the test in a particular
    order so that the `POST` HTTP method on the `addresses` resource is only called
    before the `DELETE` HTTP method on the `addresses` resource. This is because you
    are passing the newly created address ID in the `DELETE` call. Normally, tests
    run in a random order. If the `DELETE` call is made before the `POST` call, then
    the build will fail, without testing the proper scenarios.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '`@TestInstance` sets the life cycle of the test instance to per class (`TestInstance.Lifecycle.PER_CLASS`)
    because we want to clean and migrate the database before integration test execution.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The static `init()` method is annotated with `@BeforeAll` and will be run before
    all the tests. You are setting up `objectMapper` and the `address` model in this
    method. You are also making use of the Flyway instance for cleaning the database
    schema and recreating the schema using the `migrate` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The method’s setup will be run before each test is executed because it is marked
    with the `@BeforeEach` annotation. Here, you are making sure that the login call
    will only be made if `signedInUser` is null or the token has expired. The `TestInfo`
    instance helps us to assign different users – `scott2` (admin) and `scott` (non-admin)
    – for different tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an integration test that will verify the `GET /api/v1/addresses`
    REST endpoint, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: First, you must set the headers in the given section. Here, you are using the
    `signedInUser` instance to set the bearer token. Next, you must call the exchange
    method of `TestRestTemplate`, which takes four arguments – the URI, the `HTTP`
    method, `HttpEntity` (which contains the headers and payload if required), and
    the type of the returned value. You can also use optional fifth argument if the
    template is being used to set `urlVariables`, which expands the template.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Then, you must use the assertions to perform the verification process. Here,
    you can see that it replicates the actual calls.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After this, you can find the test report in `Chapter08/build/ reports/tests/integrationTest`.
    The test report should look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Integration test report](img/Figure_08.3_B19349.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Integration test report
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the test address resources in `AddressControllerIT.java`, which
    contains tests for success, errors, authentication, and authorization. It has
    tests for all types of operations, including `create`, `read`, and `delete` operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned how to write integration tests. You can make use of this
    skill to write integration tests for other REST resources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored both manual and automated testing. You learned
    how to write unit and integration tests using JUnit, the Spring test libraries,
    AssertJ, and Hamcrest. You also learned how to use the Gherkin `Given > When >
    Then` language to make tests more readable. You then learned how to separate unit
    and integration tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about various test automation skills by automating unit
    and integration tests. This will help you to automate your tests and catch bugs
    and gaps before you deliver the code to quality analysts or customers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to containerize an application and deploy
    it in Kubernetes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between unit testing and integration testing?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of having separate unit and integration tests?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between mocking and spying on an object?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is done to test the smallest code unit, such as a method, whereas
    integration testing is performed where either different layers or multiple modules
    are involved. In this chapter, integration testing has been performed for the
    entire application, which involves all the layers of the application, including
    the database, whereas unit testing has been performed class-wise for each of the
    methods. In the context of this chapter, unit testing is white-box testing, whereas
    API integration testing is a kind of black-box testing because you verify the
    API’s functional requirement.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having separate unit and integration tests (and including their source location)
    allows you to manage tests easily. You can also have a configurable build setup
    that will perform unit testing during development or on demand because unit tests
    are faster. You can run only unit tests by using the `gradlew clean build –x integrationTest`
    command, whereas on merge request builds, you can execute the integration tests
    to verify the merge request. The default build (`gradlew clean build`) will execute
    both unit and integration tests.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you use `Mockito.mock()` or `@Mock`, it creates a complete fake object
    of the given class, and then you can stub its method based on the test requirement,
    whereas `Mockito.spy()` or `@Spy` creates the real object, on which you can stub
    the required methods. If stubbing is not done on the `spy` object, then its real
    methods will be called during the test.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit: [https://junit.org/](https://junit.org/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AssertJ: [https://assertj.github.io/doc/](https://assertj.github.io/doc/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hamcrest: [http://hamcrest.org/](http://hamcrest.org/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mockito: [https://site.mockito.org/](https://site.mockito.org/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test Automation Engineering* *Handbook*: [https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492](https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
