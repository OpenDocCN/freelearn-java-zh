- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proper automated testing helps you to reduce regression bugs and keeps your
    application stable. It makes sure that every change you make will fail during
    the build or testing phase if the change has any side effects on existing code.
    Investing in a test automation suite can give you peace of mind and will prevent
    any surprises in production.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you learn about test automation by showing you how to
    implement unit and integration test automation. You will learn how to test APIs
    manually and automatically. First, you will learn about automating unit and integration
    tests. After learning about these forms of automation, you will be able to make
    both types of testing an integral part of any build. You will also learn how to
    set up the **Java Code Coverage** (**JaCoCo**) tool to calculate different code
    coverage metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs and code manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs and code manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a continuous process in software development and maintenance cycles.
    You need to do full testing that covers all possible use cases and the respective
    code for each change. Different types of testing can be performed for APIs, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing is performed by developers to test the smallest
    unit (such as a class method) of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Integration testing is performed by developers to
    test the integration of different layers of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract testing**: Contract testing is performed by developers to make sure
    any changes that are made to the API won’t break the consumer code. The consumer
    code should always comply with the producer’s contract (API). It is primarily
    required in microservices-based development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end** (**E2E**) **testing**: E2E testing is performed by the **quality
    assurance** (**QA**) team to test end-to-end scenarios, such as from the UI (consumer)
    to the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User acceptance testing** (**UAT**): UAT is performed by business users from
    a business perspective and may overlap with E2E testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You performed manual API testing by using the cURL and Postman tools earlier
    in this book. Every change requires the APIs to be completely tested – not only
    the impacted APIs. There is a reason for this. You may assume that it only impacts
    certain APIs, but what if your underlying assumptions are wrong? It may impact
    the other APIs that you skipped, which would lead to production issues. This can
    create panic and may require a release to be rolled over or a patch to be released
    with a fix.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to be in such situations, so products have a separate QA team
    that ensures releases are delivered with the best possible quality. QA teams do
    the separate E2E and acceptance testing (along with business/domain users), apart
    from the testing that’s done by the development team.
  prefs: []
  type: TYPE_NORMAL
- en: This extra assurance for high-quality deliverables needs more time and effort.
    The time taken now is much shorter because of automated testing. It was longer
    previously because we performed manual testing; therefore, software development
    cycles used to be huge in comparison to today. **Time to market** (**TTM**) is
    a huge factor in today’s competitive software industry. Today, you need faster
    release cycles. Moreover, quality checks, also known as testing, are an important
    and major part of release cycles.
  prefs: []
  type: TYPE_NORMAL
- en: You can reduce the testing time by automating the testing process and making
    it an integral part of the CI/CD pipeline. **CI** stands for **continuous integration**,
    which means *build > test > merge* in a code repository. **CD** stands for **continuous
    delivery** and/or **continuous deployment**, both of which may be used interchangeably.
    Continuous delivery is a process where code is automatically tested and released
    (read and uploaded) to an artifact repository or container registry. Then, it
    can be picked and deployed to a production environment after manual approval.
    Continuous deployment is one step ahead of continuous delivery and automates all
    the steps. Continuous deployment also performs the automatic deployment to production
    once all tests are passed. Products that don’t release their code for public access
    use this approach, such as Facebook and Twitter. On the other hand, products/services
    that are available publicly, such as the Spring Framework and Java, use continuous
    delivery pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll automate the manual testing we have done so far in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever testing you are doing manually can be automated and made part of the
    build. This means that any change or code commit will run the test suite as a
    part of the build. A build will only be successful if all the tests are passed.
  prefs: []
  type: TYPE_NORMAL
- en: You can add automated integration tests for all the APIs. So, instead of firing
    each API manually using cURL or Insomnia, the build will fire them, and the test
    result will be available at the end of the build.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you are going to write an integration test that will replicate
    the REST client call and test all the application layers, starting from the controller,
    all the way down to the persistence layer, including the database (H2).
  prefs: []
  type: TYPE_NORMAL
- en: But before that, you will add the necessary unit tests. Ideally, these unit
    tests should have been added alongside the development process, or before the
    development process in the case of **test-driven** **development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are tests that validate the expected results of small units of code,
    such as a class’s methods. You can avoid most bugs if you have proper tests in
    place with good code (90% or above) and branch coverage (80% and above). Code
    coverage refers to metrics such as the number of lines and branches (such as `if-else`),
    which are validated when the tests are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Some classes or methods have dependencies on other classes or infrastructure
    services. For example, controller classes have dependencies on service and assembler
    classes, while repository classes have dependencies on Hibernate APIs. You can
    create mocks to replicate dependency behaviors and assume these are working as
    expected or behave as per the defined tests. This approach will allow you to test
    the actual code unit (such as a method) and validate its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore how to add unit tests before writing the
    integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I advise you to go back to [*Chapter 6*](B19349_06.xhtml#_idTextAnchor148)
    as a base for this chapter’s code. You don’t have to add any additional dependencies
    for unit tests. You already have the following dependency in `build.gradle` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `spring-boot-starter-test` adds all the required test dependencies, not
    only for the unit tests but also for the integration tests. You are going to primarily
    use the following libraries for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`junit-platform-commons`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-jupiter-engine` that allows you to run Jupiter-based tests on the JUnit
    Platform. It also provides the `junit-jupiter`, `junit-jupiter-api`, and `junit-jupiter-params`
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JUnit Vintage** supports older versions of JUnit, such as versions 3 and
    4\. You are going to use the latest version in this book, which is 5, so you don’t
    need this bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about JUnit at [https://junit.org/](https://junit.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '**AssertJ**: AssertJ is a test assertion library that simplifies assertion
    writing by providing fluent APIs. It is also extendable. You can write custom
    assertions for your domain objects. You can find more about it at [https://assertj.github.io/doc/](https://assertj.github.io/doc/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamcrest**: Hamcrest is another assertion library that provides assertions
    based on matchers. It also allows you to write custom matchers. You’ll find an
    example of both in this chapter, though AssertJ is preferable because it has fluent
    APIs. Chained methods help IDEs to suggest appropriate assertions based on a given
    object. You can choose one of the assertion libraries or both based on your use
    cases and liking. You can find out more about it at [http://hamcrest.org/](http://hamcrest.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mockito**: Mockito is a mocking framework that allows you to mock objects
    (read dependencies) and to stub method calls. You can find out more about it at
    [https://site.mockito.org/](https://site.mockito.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You already know that unit tests test the smallest testable code unit. But how
    can we write a unit test for controller methods? The controller runs on web servers
    and has the Spring web application context. If you write a test that uses `WebApplicationContext`
    and is running on top of a web server, then you can call it an integration test
    rather than a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be lightweight and must be executed quickly. Therefore, you
    must use `MockMvc`, a special class provided by the Spring test library, to test
    the controllers. You can use the standalone setup for `MockMvc` for unit testing.
    You can also use `MockitoExtension` to run the unit test on the JUnit Platform
    (JUnit 5 provides an extension for runners), which supports object mocking and
    method stubbing. You will also use the Mockito library to mock the required dependencies.
    These tests are fast and help developers build faster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write our test using AssertJ assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing using AssertJ assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write our first unit test for `ShipmentController`. The following code
    can be found in `src/test/java/com/packt/modern/api/controller/ ShipmentControllerTest.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, our test is using a Jupiter-based annotation (`ExtendWith`) that registers
    the extension (`MockitoExtension`) for running tests and supporting Mockito-based
    mocks and stubbing.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring test library provides the `MockMvc` class, which allows you to mock
    the Spring MVC. As a result, you can execute the controller methods by calling
    the associated API endpoints’ URI. The dependencies of the `ShipmentController`
    controller class, such as the service and assembler, are marked with `@Mock` annotations
    to create the mock instances of its dependencies. You can also use `Mockito.mock(classOrInterface)`
    to create the mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another noticeable annotation is `@InjectMocks` on the controller declaration.
    It finds out all the declared mocks that are required for a testing class and
    injects them automatically. `ShipmentController` uses the `ShipmentService` and
    `ShipmentRepresentation``     ModelAssembler` instances, which are injected using its constructor. The Mockito-based
    `InjectMocks` annotation finds the dependencies in the `ShipmentController` class
    (service and assembler). Then, it looks for mocks of the service and assembler
    in the test class. Once it finds them, it injects these mock objects into the
    `ShipmentController` class. If required, you can also create an instance of the
    testing class using a constructor instead of using `@InjectsMocks`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A mock of `MessageSource` is created for `RestApiHandler`, which is being used
    in the setup method. You’ll explore it further in the following code block.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the declaration is `JacksonTester`, which is part of the Spring
    testing library. `JacksonTester` is a custom JSON assertion class that’s created
    using the AssertJ and Jackson libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The JUnit Jupiter API provides the `@BeforeAll` and `@BeforeEach` method annotations,
    which can be used to set up the prerequisites. As their names suggest, `@BeforeAll`
    is run once per test class, while `@BeforeEach` gets executed before each test
    execution. `@BeforeEach` can be placed on public non-static methods, whereas `@BeforeAll`
    should be used to annotate public static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, JUnit provides the `@AfterAll` and `@AfterEach` annotations, which
    execute the associated methods after each test is executed and after each test
    is executed, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the `@BeforeEach` annotation to set up the prerequisites for the
    `ShipmentControll``     erTest` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize the `JacksonTester` fields with the object mapper instance
    received from `AppConfig`. This creates a custom message converter instance (`MappingJackson2HttpMes``sageConverter`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can create a `mockMvc` instance using the standalone setup and initialize
    the controller advice using its setter method. The `RestApiErrorHandler` instance
    uses the mock object of the `MessageResource` class. You can also set the message
    converter to `mockMvc` before building it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you initialize the instances of `ShipmentEntity` and `Shipment` (model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are going to write the test for the `GET /api/v1/shipping/{id}` call,
    which uses the `getShipmentByOrderI``d()` method of the `ShipmentController` class.
    Tests are marked with `@Test`. You can also use `@DisplayName` to customize a
    test’s name in the test reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are using the `Given > When > Then` language ([https://cucumber.io/docs/gherkin/](https://cucumber.io/docs/gherkin/)),
    which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: Context of the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: Test action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: Test result, followed by validation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s read this test from a BDD perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: The service is available and returns the list of shipments based on
    the given order ID and an assembler, which converts the list of entities into
    a list of models. It also adds HATEOAS links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: The user calls the API via `GET /``api/shipping/a1b9b31d-e73c- 4112-af7c-b68530f38222`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: The test validates the received shipments associated with the given
    order ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mockito’s `MockitoBDD` class provides the `given()` fluent API to stub the mock
    objects methods. When `mockMvc.perform()` is called, internally, it calls the
    respective service and assembler mocks, which, in turn, call the stubbed methods
    and return the values defined in the stub (using `given()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `andDo(MockMvcResultHandlers.print())` method logs the request and response
    trace, including the payload and response body. If you want to trace all the `mockMvc`
    logs inside a test class, then you can configure them directly while initializing
    `mockMvc` instead of defining them individually in `mockMvc.perform()` calls,
    as shown here (the highlighted code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At the end, you perform assertions (whether the status is `200 OK` or not and
    whether the returned JSON object matches the expected object or not) using AssertJ
    fluent APIs. First, you use the `Asserts.assertThat()` function, which takes the
    actual object and compares it with the expected object using the `isEqualTo()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have used AssertJ assertions. Similarly, you can also use Spring
    and Hamcrest assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing using Spring and Hamcrest assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you know how to write JUnit 5 tests using `MockitoExtension`.
    You’ll use the same approach to write a unit test, except with assertions. This
    time, you will write an assertion using Hamcrest assertions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java)'
  prefs: []
  type: TYPE_NORMAL
- en: You have captured the `MockHttpResponse` instance from the `mockMvc.perform()`
    call in the previous test example – that is, `testGetShipmentByOrderId()`. This
    time, you will directly use the returned value of the `mockMvc.perform()` call
    rather than calling an extra `andReturn().getResponse()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResultAction` class provides the `andExpect()` assertion method, which
    takes `ResultMatcher` as an argument. The `StatusResultMatchers.status(). isOk()`
    result matcher evaluates the HTTP status returned by the `perform()` call. The
    `VerifyJson()` method evaluates the JSON response object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MockMvcResultMatchers.jsonPath()` result matcher takes two arguments
    – a JSON path expression and a matcher. Therefore, first, you must pass the JSON
    field name and then the Hamcrest matcher known as `Is.is()`, which is a shortcut
    for `Is.is(equalsTo(entity.getCity()))`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the unit test for a service is much easier compared to writing one for
    the controller because you don’t have to deal with `MockMvc`.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to test private methods in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing private methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unit testing a private method is a challenge. The Spring test library provides
    the `ReflectionTestUtils` class, which provides a method called `invokeMethod`.
    This method allows to you invoke private methods. The `invokeMethod` method takes
    three arguments – the target class, the method’s name, and the method’s arguments
    (using variable arguments). Let’s use it to test the `AddressServiceImpl.toEntity()`
    private method, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you can see that when you call `ReflectionTestUtils.invokeMethod()`
    with the given arguments, it returns the `AddressEntity` instance, which has been
    converted using the given argument’s `AddAddressReq` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you are using a third kind of assertion using AssertJ’s `BDDAssertions`
    class. The `BDDAssertions` class provides methods that resonate with the BDD style.
    `BDDAssertions.then()` takes the actual value that you want to verify. The `as()`
    method describes the assertion and should be added before you perform the assertion.
    Finally, you perform verification using AssertJ’s assertion methods, such as `isEqualTo()`.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to test void methods in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing void methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method that returns a value can easily be stubbed, but how can we stub a method
    that returns nothing? Mockito provides the `doNothing()` method for this. It has
    a wrapper `willDoNothing()` method in the `BDDMockito` class that internally uses
    `doNothing()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very handy, especially when you want such methods to do nothing while
    you’re spying, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `linkedList` is a real object and not a mock. However, if you want to
    stub a specific method, then you can use `spy()`. Here, when the `clear()` method
    is called on `spyLinkedList`, it will do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `willDoNothing` to stub the void method and see how it helps test
    void methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `AddressRepository.deleteById()` is being stubbed using
    Mockito’s `willDoNothing()` method. Now, you can use the `verify()` method of
    Mockito, which takes two arguments – the mock object and its verification mode.
    Here, the `times()` verification mode is used, which determines how many times
    a method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how to unit-test exceptional scenarios in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mockito provides `thenThrow()` for stubbing methods with exceptions. BDDMockito’s
    `willThrow()` is a wrapper that uses it internally. You can pass the `Throwable`
    argument and test it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you basically catch the exception and perform assertions on it.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have explored the unit tests that you can perform for both controllers
    and services. You can make use of these examples and write unit tests for the
    rest of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Executing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the following command to execute unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the unit test reports at `Chapter08/build/reports/tests/test/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generated test report will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Unit test report](img/Figure_08.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Unit test report
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the links to drill down further. If the test fails, it also
    shows the cause of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next section to learn how to configure code coverage for
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code coverage provides important metrics, including line and branch coverage.
    You are going to use the **JaCoCo** tool to perform and report your code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add the `jacoco` Gradle plugin to the `build.gradle` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the `jacoco` plugin by providing its version and reports directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new task called `jacocoTestReport` that depends on the `test`
    task because code coverage can only be evaluated after test execution. You don’t
    want to calculate coverage for auto-generated code, so add the `exclude` block.
    Exclusion can be added by configuring `afterEvaluate`, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to configure `jacocoTestCoverageVerification`, which defines
    the violation rules. We have added instructions to cover the ratio rule in the
    following code block. This will set the expected ratio to a minimum of 90%. If
    the ratio is below 0.9, then it will fail the build. You can find out more about
    such rules at https://docs.gradle.org/current/userguide/jacoco_plugin.html#sec:jacoco_report_violation_rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add `finalizedBy(jacocoTestReport)` to the test task, which ensures that
    the `jacocoTestReport` task will execute after performing the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run the following command to generate the code coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will not only run the test but also generate the code
    coverage report, along with the test reports. The code coverage report is available
    at `Chapter08/build/jacoco/test/html/index.html` and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Code coverage report](img/Figure_08.2_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Code coverage report
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that our instruction coverage is only at 29%, while our branch
    coverage is only at 3%. You can add more tests and increase these percentages.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about integration testing in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the automated integration tests in place, you can ensure that
    any changes you make won’t produce bugs, provided you cover all the testing scenarios.
    You don’t have to add any additional plugins or libraries to support integration
    testing in this chapter. The Spring test library provides all the libraries required
    to write and perform integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the configuration for integration testing in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Integration testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you need a separate location for your integration tests. This can be
    configured in `build.gradle`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, you add the integration tests and their resources to source sets. Gradle
    then picks the tests when a relevant Gradle command (`integrationTest`, `build`)
    gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can configure the integration test’s implementation and runtime so
    that it’s extended from the test’s implementation and runtime, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, create a task called `integrationTest` that will not only use the JUnit
    Platform but also use our `classpath` and test `classpath` from `sourceSets.`
    `integrationTest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, configure the check task so that it depends on the `integrationTest`
    task and run `integrationTest` after the test task. You can remove the last line
    in the following code block if you want to run `integrationTest` separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start writing the integration tests. Before writing integration
    tests, first, let’s write the supporting Java classes in the next subsection.
    First, let’s create the `TestUtils` class. This will contain a method that returns
    an instance of `ObjectMapper`. It will contain a method to check whether the JWT
    has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Writing supporting classes for integration tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ObjectMapper` instance was retrieved from the `AppConfig` class and added
    an extra configuration so that we can accept a single value as an array. For example,
    a JSON string field value might be `{[{…}, {…}]}`. If you take a closer look at
    it, you will see that it is an array wrapped as a single value. When you convert
    this value into an object, `ObjectMapper` treats it as an array. The complete
    code for this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need a client that lets you log in so that you can retrieve the JWT.
    `RestTemplate` is an HTTP client in Spring that provides support for making HTTP
    calls. The `AuthClient` class makes use of `TestRestTemplate`, which is a replica
    of `RestTemplate` from a testing perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write this `AuthClient` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring test library provides `MockMvc`, `WebTestClient`, and `TestRestTemplate`
    for performing integration testing. You have already used `MockMvc` in unit testing.
    The same approach can be used for integration testing as well. However, instead
    of using mocks, you can use the actual objects by adding the `@SpringBootTest`
    annotation to the test class. `@SpringBootTest`, along with `SpringExtension`,
    provides all the necessary Spring context, such as the actual application.
  prefs: []
  type: TYPE_NORMAL
- en: '`@TestPropertySource` provides the location of the test properties file.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTestClient` is used to test the reactive applications. However, to test
    REST services, you must use `TestRestTemplate`, which is a replica of `RestTemplate`.'
  prefs: []
  type: TYPE_NORMAL
- en: The integration test you are going to write is a fully fleshed-out test that
    doesn’t contain any mocks. It will use Flyway scripts, like the actual application,
    which we added to `src/integration/resources/db/migration`. The integration test
    will also have its own `application.properties` located in `src/integration/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the integration test will be as good as if you are hitting the REST
    endpoints from REST clients such as cURL or Postman. These Flyway scripts create
    the tables and data required in the H2 memory database. This data will then be
    used by the RESTful web service. You can also use other databases, such as Postgres
    or MySQL, using their test containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new integration test called `AddressControllerIT` in `src/ integration/java`
    in an appropriate package and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `SpringExtension` is now being used to run the unit test on the JUnit
    Platform. The `SpringBootTest` annotation provides all the dependencies and context
    for the test class. A random port is being used to run the test server. You are
    also using `@TestMethodOrder`, along with the `@Order` annotation, to run the
    test in a particular order. You are going to execute the test in a particular
    order so that the `POST` HTTP method on the `addresses` resource is only called
    before the `DELETE` HTTP method on the `addresses` resource. This is because you
    are passing the newly created address ID in the `DELETE` call. Normally, tests
    run in a random order. If the `DELETE` call is made before the `POST` call, then
    the build will fail, without testing the proper scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '`@TestInstance` sets the life cycle of the test instance to per class (`TestInstance.Lifecycle.PER_CLASS`)
    because we want to clean and migrate the database before integration test execution.'
  prefs: []
  type: TYPE_NORMAL
- en: The static `init()` method is annotated with `@BeforeAll` and will be run before
    all the tests. You are setting up `objectMapper` and the `address` model in this
    method. You are also making use of the Flyway instance for cleaning the database
    schema and recreating the schema using the `migrate` command.
  prefs: []
  type: TYPE_NORMAL
- en: The method’s setup will be run before each test is executed because it is marked
    with the `@BeforeEach` annotation. Here, you are making sure that the login call
    will only be made if `signedInUser` is null or the token has expired. The `TestInfo`
    instance helps us to assign different users – `scott2` (admin) and `scott` (non-admin)
    – for different tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an integration test that will verify the `GET /api/v1/addresses`
    REST endpoint, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  prefs: []
  type: TYPE_NORMAL
- en: First, you must set the headers in the given section. Here, you are using the
    `signedInUser` instance to set the bearer token. Next, you must call the exchange
    method of `TestRestTemplate`, which takes four arguments – the URI, the `HTTP`
    method, `HttpEntity` (which contains the headers and payload if required), and
    the type of the returned value. You can also use optional fifth argument if the
    template is being used to set `urlVariables`, which expands the template.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you must use the assertions to perform the verification process. Here,
    you can see that it replicates the actual calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can find the test report in `Chapter08/build/ reports/tests/integrationTest`.
    The test report should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Integration test report](img/Figure_08.3_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Integration test report
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the test address resources in `AddressControllerIT.java`, which
    contains tests for success, errors, authentication, and authorization. It has
    tests for all types of operations, including `create`, `read`, and `delete` operations.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned how to write integration tests. You can make use of this
    skill to write integration tests for other REST resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored both manual and automated testing. You learned
    how to write unit and integration tests using JUnit, the Spring test libraries,
    AssertJ, and Hamcrest. You also learned how to use the Gherkin `Given > When >
    Then` language to make tests more readable. You then learned how to separate unit
    and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about various test automation skills by automating unit
    and integration tests. This will help you to automate your tests and catch bugs
    and gaps before you deliver the code to quality analysts or customers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to containerize an application and deploy
    it in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between unit testing and integration testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of having separate unit and integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between mocking and spying on an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is done to test the smallest code unit, such as a method, whereas
    integration testing is performed where either different layers or multiple modules
    are involved. In this chapter, integration testing has been performed for the
    entire application, which involves all the layers of the application, including
    the database, whereas unit testing has been performed class-wise for each of the
    methods. In the context of this chapter, unit testing is white-box testing, whereas
    API integration testing is a kind of black-box testing because you verify the
    API’s functional requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having separate unit and integration tests (and including their source location)
    allows you to manage tests easily. You can also have a configurable build setup
    that will perform unit testing during development or on demand because unit tests
    are faster. You can run only unit tests by using the `gradlew clean build –x integrationTest`
    command, whereas on merge request builds, you can execute the integration tests
    to verify the merge request. The default build (`gradlew clean build`) will execute
    both unit and integration tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you use `Mockito.mock()` or `@Mock`, it creates a complete fake object
    of the given class, and then you can stub its method based on the test requirement,
    whereas `Mockito.spy()` or `@Spy` creates the real object, on which you can stub
    the required methods. If stubbing is not done on the `spy` object, then its real
    methods will be called during the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit: [https://junit.org/](https://junit.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AssertJ: [https://assertj.github.io/doc/](https://assertj.github.io/doc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hamcrest: [http://hamcrest.org/](http://hamcrest.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mockito: [https://site.mockito.org/](https://site.mockito.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test Automation Engineering* *Handbook*: [https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492](https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
