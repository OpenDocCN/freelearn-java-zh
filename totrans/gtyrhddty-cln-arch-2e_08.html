<html><head></head><body>
<div id="_idContainer068">
<h1 class="hapter-number" id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.2.1">Testing Architecture Elements</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In many projects I’ve witnessed, especially projects that have been around for a while and have rotated in and out many developers over time, automated testing is a mystery. </span><span class="koboSpan" id="kobo.3.2">Everyone writes tests as they see fit because it’s required by some dusty rule documented in a wiki, but no one can answer targeted questions about a team’s </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">testing strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter provides a testing strategy for a Hexagonal Architecture. </span><span class="koboSpan" id="kobo.5.2">For each element of our architecture, we’ll discuss the type of test to </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">cover it.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.7.1">The test pyramid</span></h1>
<p><span class="koboSpan" id="kobo.8.1">Let’s</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.9.1"> start the discussion about testing along the lines of the </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">test pyramid</span></strong><span id="footnote-031-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-031"><span class="koboSpan" id="kobo.11.1">1</span></a></span><span class="koboSpan" id="kobo.12.1"> in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.13.1">Figure 8</span></em></span><em class="itali"><span class="koboSpan" id="kobo.14.1">.1</span></em><span class="koboSpan" id="kobo.15.1">, which is a metaphor that helps us to decide on how many tests of which type we should </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">aim for.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-031">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-031-backlink"><span class="koboSpan" id="kobo.17.1">1</span></a><span class="koboSpan" id="kobo.18.1">	The test pyramid can be traced back to Mike Cohn’s book </span><em class="itali"><span class="koboSpan" id="kobo.19.1">Succeeding with Agile</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.20.1">from 2009</span></span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.22.1"><img alt="Figure 8.1 – According to the test pyramid, we should create many cheap tests and fewer expensive ones" src="image/Figure_08.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.23.1">Figure 8.1 – According to the test pyramid, we should create many cheap tests and fewer expensive ones</span></p>
<p><span class="koboSpan" id="kobo.24.1">The basic statement of the pyramid is that we should have high coverage of fine-grained tests that are cheap to build, easy to maintain, fast-running, and stable. </span><span class="koboSpan" id="kobo.24.2">These are unit tests that verify that a single unit (usually a class) works </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Once tests combine multiple units and go across unit boundaries, architectural boundaries, or even system boundaries, they tend to become more expensive to build, slower to run, and more brittle (failing due to some configuration error instead of a functional error). </span><span class="koboSpan" id="kobo.26.2">The pyramid tells us that the more expensive those tests become, the less we should aim for high coverage of these tests because, otherwise, we’ll spend too much time building tests instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">new functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Depending on the </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.29.1">context, the test pyramid is often shown with different layers. </span><span class="koboSpan" id="kobo.29.2">Let’s take a look at the layers I chose to discuss testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Hexagonal Architecture.</span></span></p>
<p class="allout-heading"><span class="koboSpan" id="kobo.31.1">Note</span></p>
<p class="allout"><span class="koboSpan" id="kobo.32.1">The definitions of </span><em class="itali"><span class="koboSpan" id="kobo.33.1">unit test</span></em><span class="koboSpan" id="kobo.34.1">, </span><em class="itali"><span class="koboSpan" id="kobo.35.1">integration test</span></em><span class="koboSpan" id="kobo.36.1">, and </span><em class="itali"><span class="koboSpan" id="kobo.37.1">system test</span></em><span class="koboSpan" id="kobo.38.1"> vary with context. </span><span class="koboSpan" id="kobo.38.2">In one project, they may mean a different thing than </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">in another.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The following are interpretations of different test types as we’ll use them in </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">this chapter:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Unit tests</span></strong><span class="koboSpan" id="kobo.43.1"> are the base of the</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.44.1"> pyramid. </span><span class="koboSpan" id="kobo.44.2">A unit test</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.45.1"> usually instantiates a single class and tests its functionality through its interface. </span><span class="koboSpan" id="kobo.45.2">If the class under test has non-trivial dependencies on other classes, we can replace those dependencies with mock objects that simulate the behavior of the real objects, as required by </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.47.1">Integration tests</span></strong><span class="koboSpan" id="kobo.48.1"> form</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.49.1"> the next layer of the pyramid. </span><span class="koboSpan" id="kobo.49.2">These tests instantiate a </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.50.1">network of multiple units and verify whether this network works as expected, by sending some data into it through the interface of an entry class. </span><span class="koboSpan" id="kobo.50.2">In our interpretation, integration tests will cross the boundary between two layers, so the network of objects is not complete or must work against mocks at </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">some point.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">System tests</span></strong><span class="koboSpan" id="kobo.53.1">, finally, spin</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.54.1"> up the whole network of objects that make up our </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.55.1">application and verify whether a certain use case works as expected through all the layers of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">Above the system tests, there might be a layer of end-to-end tests that include the UI of the application. </span><span class="koboSpan" id="kobo.57.2">We’ll not consider end-to-end tests here since we’re only discussing a backend architecture in </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">this book.</span></span></p>
<p class="allout-heading"><span class="koboSpan" id="kobo.59.1">Note</span></p>
<p class="allout"><span class="koboSpan" id="kobo.60.1">The test pyramid, like any other guidance, is not a silver bullet for your test strategy. </span><span class="koboSpan" id="kobo.60.2">It’s a good default, but if, in your context, you can create and maintain integration or system tests cheaply, you can and should create more of those tests, as they are less vulnerable to changes in implementation details than unit tests. </span><span class="koboSpan" id="kobo.60.3">This would make the sides of the pyramid steeper, or maybe even </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">invert them.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Now that we have defined some test types, let’s see which type of test fits best with each of the layers of our </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">Hexagonal Architecture.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.64.1">Testing a domain entity with unit tests</span></h1>
<p><span class="koboSpan" id="kobo.65.1">We will</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.66.1"> start by looking at a domain entity at the center of</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.67.1"> our architecture. </span><span class="koboSpan" id="kobo.67.2">Let’s recall the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.68.1">Account</span></strong><span class="koboSpan" id="kobo.69.1"> entity from </span><a href="B19916_05.xhtml#_idTextAnchor044"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.70.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.71.1">, </span><em class="itali"><span class="koboSpan" id="kobo.72.1">Implementing a Use Case</span></em><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">The state of </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.74.1">Account</span></strong><span class="koboSpan" id="kobo.75.1"> consists of a balance an account had at a certain point in the past (the baseline balance) and a list of deposits and withdrawals (activities) made </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">since then.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">We now want to verify that the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.78.1">withdraw()</span></strong><span class="koboSpan" id="kobo.79.1"> method works </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">as expected:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.81.1"><img alt="" src="image/code-8.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.82.1">The preceding test is a plain unit test that instantiates an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.83.1">Account</span></strong><span class="koboSpan" id="kobo.84.1"> in a specific state, calls its </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.85.1">withdraw()</span></strong><span class="koboSpan" id="kobo.86.1"> method, and verifies that the withdrawal was successful and had the expected side effects on the state of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.87.1">Account</span></strong><span class="koboSpan" id="kobo.88.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">The test is</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.91.1"> rather easy to set up, is easy to understand, and runs </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.92.1">very fast. </span><span class="koboSpan" id="kobo.92.2">Tests don’t come much simpler than this. </span><span class="koboSpan" id="kobo.92.3">Unit tests such as these are our best bet to verify the business rules encoded within our domain entities. </span><span class="koboSpan" id="kobo.92.4">We don’t need any other type of test since domain entity behavior has little to no dependencies on </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">other classes.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.94.1">Testing a use case with unit tests</span></h1>
<p><span class="koboSpan" id="kobo.95.1">Going a </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.96.1">layer outward, the next architecture element to test is the use cases implemented as domain services. </span><span class="koboSpan" id="kobo.96.2">Let’s look at a test for </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.97.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.98.1">, discussed in </span><a href="B19916_05.xhtml#_idTextAnchor044"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.99.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.100.1">, </span><em class="itali"><span class="koboSpan" id="kobo.101.1">Implementing a Use Case</span></em><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">The </span><em class="itali"><span class="koboSpan" id="kobo.103.1">Send money</span></em><span class="koboSpan" id="kobo.104.1"> use case withdraws money from the source account and deposits it into the target account. </span><span class="koboSpan" id="kobo.104.2">We want to verify that everything works as expected when the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">transaction succeeds:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.106.1"><img alt="" src="image/code-8.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.107.1">To make the test a</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.108.1"> little more readable, it’s structured into </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.109.1">given</span></strong><span class="koboSpan" id="kobo.110.1">/</span><strong class="sour e-inline"><span class="koboSpan" id="kobo.111.1">when</span></strong><span class="koboSpan" id="kobo.112.1">/</span><strong class="sour e-inline"><span class="koboSpan" id="kobo.113.1">then</span></strong><span class="koboSpan" id="kobo.114.1"> sections, which are commonly used in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.115.1">Behavior-Driven Development</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">In the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.118.1">given</span></strong><span class="koboSpan" id="kobo.119.1"> section, we create the source and target </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.120.1">Account</span></strong><span class="koboSpan" id="kobo.121.1"> objects and put them into the correct state with some methods whose names start with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.122.1">given...()</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">We also create a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.124.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.125.1"> object to act as input to the use case. </span><span class="koboSpan" id="kobo.125.2">In the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.126.1">when</span></strong><span class="koboSpan" id="kobo.127.1"> section, we simply call the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.128.1">sendMoney()</span></strong><span class="koboSpan" id="kobo.129.1"> method to invoke the use case. </span><span class="koboSpan" id="kobo.129.2">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.130.1">then</span></strong><span class="koboSpan" id="kobo.131.1"> section asserts that the transaction was successful and verifies that certain methods have been called on the source and target </span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.132.1">Account</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Under the hood, the test </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.135.1">makes use of the Mockito library to create </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">mock</span></strong><strong class="bold"><a id="_idIndexMarker168"/></strong><strong class="bold"><span class="koboSpan" id="kobo.137.1"> objects</span></strong><span class="koboSpan" id="kobo.138.1"> in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.139.1">given...()</span></strong><span class="koboSpan" id="kobo.140.1"> methods.</span><span id="footnote-030-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-030"><span class="koboSpan" id="kobo.141.1">2</span></a></span><span class="koboSpan" id="kobo.142.1"> Mockito also provides the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.143.1">then()</span></strong><span class="koboSpan" id="kobo.144.1"> method to verify whether a certain method has been called on a </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">mock object.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-030">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-030-backlink"><span class="koboSpan" id="kobo.146.1">2</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.147.1">Mockito: </span></span><a href="https://site.mockito.org/"><span class="No-Break"><span class="koboSpan" id="kobo.148.1">https://site.mockito.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.149.1">.</span></span></p>
</div>
<p class="allout-heading"><span class="koboSpan" id="kobo.150.1">Note</span></p>
<p class="allout"><span class="koboSpan" id="kobo.151.1">If used too much, mocking can give a false sense of security. </span><span class="koboSpan" id="kobo.151.2">Mocks may behave differently from the real thing, causing issues in production even though our tests are green. </span><span class="koboSpan" id="kobo.151.3">If you can use real objects instead of mocks without too much extra effort, you should probably do it. </span><span class="koboSpan" id="kobo.151.4">In the preceding example, we might choose to work with real </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">Account</span></strong><span class="koboSpan" id="kobo.153.1"> objects instead of mocks, for example. </span><span class="koboSpan" id="kobo.153.2">This shouldn’t prove much more effort because the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.154.1">Account</span></strong><span class="koboSpan" id="kobo.155.1"> class is a domain model class that doesn’t have any complicated dependencies on </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">other classes.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Since the use case service under test is stateless, we cannot verify a certain state in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.158.1">then</span></strong><span class="koboSpan" id="kobo.159.1"> section. </span><span class="koboSpan" id="kobo.159.2">Instead, the test verifies that the service has interacted with certain methods on its (mocked) dependencies. </span><span class="koboSpan" id="kobo.159.3">This means that the test is vulnerable to changes in the structure of the code under test and not only its behavior. </span><span class="koboSpan" id="kobo.159.4">This, in turn, means that there is a higher chance that the test has to be modified if the code under test </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">is refactored.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">With this in mind, we should think hard about which interactions we actually want to verify in the test. </span><span class="koboSpan" id="kobo.161.2">It might be a good idea not to verify all interactions as we did in the preceding test and instead focus on the most important ones. </span><span class="koboSpan" id="kobo.161.3">Otherwise, we have to change the test with every single change to the class under test, undermining the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">While this test is still a unit test, it borders on being an integration test because we test the interaction on dependencies. </span><span class="koboSpan" id="kobo.163.2">However, it’s easier to create and maintain than a full-blown integration test because </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.164.1">we’re working with mocks and don’t have to manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">real dependencies.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.166.1">Testing a web adapter with integration tests</span></h1>
<p><span class="koboSpan" id="kobo.167.1">Moving </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.168.1">outward another layer, we arrive at our</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.169.1"> adapters. </span><span class="koboSpan" id="kobo.169.2">Let’s discuss testing a </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">web adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Recall that a web adapter takes input, for example, in the form of JSON strings, via HTTP, might do some validation on it, maps the input to the format a use case expects, and then passes it to that use case. </span><span class="koboSpan" id="kobo.171.2">It then maps the result of the use case back to JSON and returns it to the client via an </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">HTTP response.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">In the test for a web adapter, we want to make certain that all those steps work </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">as expected:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.175.1"><img alt="" src="image/code-8.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.176.1">The preceding test</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.177.1"> is a standard integration test for a </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.178.1">web controller named </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.179.1">SendMoneyController</span></strong><span class="koboSpan" id="kobo.180.1">, built with the Spring Boot framework. </span><span class="koboSpan" id="kobo.180.2">In the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.181.1">testSendMoney()</span></strong><span class="koboSpan" id="kobo.182.1"> method, we send a mock HTTP request to the web controller to trigger a transaction from one account </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">With the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.185.1">isOk()</span></strong><span class="koboSpan" id="kobo.186.1"> method, we then verify that the status of the HTTP response is </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.187.1">200</span></strong><span class="koboSpan" id="kobo.188.1">, and we verify that the mocked use case class has </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">been called.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">Most responsibilities of a web adapter are covered by </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">this test.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">We’re not actually testing via the HTTP protocol since we’re mocking that away with the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.193.1">MockMvc</span></strong><span class="koboSpan" id="kobo.194.1"> object. </span><span class="koboSpan" id="kobo.194.2">We trust that the framework translates everything to and from HTTP properly. </span><span class="koboSpan" id="kobo.194.3">There’s no need to test </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the framework.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">However, the whole path from mapping the input from JSON into a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.197.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.198.1"> object is covered. </span><span class="koboSpan" id="kobo.198.2">If we build the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.199.1">SendMoneyCommand</span></strong><span class="koboSpan" id="kobo.200.1"> object as a self-validating command, as explained in </span><a href="B19916_05.xhtml#_idTextAnchor044"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.201.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.202.1">, </span><em class="itali"><span class="koboSpan" id="kobo.203.1">Implementing a Use Case</span></em><span class="koboSpan" id="kobo.204.1">, we even make sure that this mapping produces syntactically valid input to the use case. </span><span class="koboSpan" id="kobo.204.2">Also, we have verified that the use case is actually called and that the HTTP response has the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">expected status.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">So, why is this an integration test and not a unit test? </span><span class="koboSpan" id="kobo.206.2">Even though it seems that we only test a single web controller class in this test, there’s a lot more going on under the hood. </span><span class="koboSpan" id="kobo.206.3">With the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.207.1">@WebMvcTest</span></strong><span class="koboSpan" id="kobo.208.1"> annotation, we tell Spring to instantiate a whole network of objects that is responsible for responding to certain request paths, mapping between Java and JSON, validating HTTP input, and so on. </span><span class="koboSpan" id="kobo.208.2">And in this test, we verify that our web controller works as a part of </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">this network.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Since the web controller </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.211.1">is heavily coupled to the </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.212.1">Spring framework, it makes sense to test it when integrated into this framework instead of testing it in isolation. </span><span class="koboSpan" id="kobo.212.2">If we tested the web controller with a plain unit test, we’d lose coverage of all the mapping, validation, and HTTP stuff, and we could never be sure whether it actually worked in production, where it’s just a cog in the mechanics of </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the framework.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.214.1">Testing a persistence adapter with integration tests</span></h1>
<p><span class="koboSpan" id="kobo.215.1">For a similar</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.216.1"> reason, it makes sense to cover </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.217.1">persistence adapters with integration tests instead of unit tests since we not only want to verify the logic within the adapter but also the mapping into </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">We want to test the persistence adapter we built in </span><a href="B19916_07.xhtml#_idTextAnchor062"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.220.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.221.1">, </span><em class="itali"><span class="koboSpan" id="kobo.222.1">Implementing a Persistence Adapter</span></em><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">The adapter has two methods, one to load an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.224.1">Account</span></strong><span class="koboSpan" id="kobo.225.1"> entity from the database and another to save new account activities to </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the database:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.227.1"><img alt="" src="image/code-8.4.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.228.1">With </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.229.1">@DataJpaTest</span></strong><span class="koboSpan" id="kobo.230.1">, we tell Spring to instantiate the network of objects that are needed for database access, including our Spring Data repositories that connect to the database. </span><span class="koboSpan" id="kobo.230.2">We use the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.231.1">@Import</span></strong><span class="koboSpan" id="kobo.232.1"> annotation to import some additional configurations to make sure that certain objects are added to that network. </span><span class="koboSpan" id="kobo.232.2">These objects are needed by the adapter under test to map incoming domain objects into database objects, </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">for instance.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">In the test for the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.235.1">loadAccount()</span></strong><span class="koboSpan" id="kobo.236.1"> method, we put the database into a certain state using an SQL script with the name </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.237.1">AccountPersistenceAdapterTest.sql</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">Then, we simply load the account through the adapter API and verify that it has the state that we would expect it to have, given the database state in the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">SQL script.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">The test for </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.241.1">updateActivities()</span></strong><span class="koboSpan" id="kobo.242.1"> goes the other way around. </span><span class="koboSpan" id="kobo.242.2">We create an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.243.1">Account</span></strong><span class="koboSpan" id="kobo.244.1"> object with a new account activity and pass it to the adapter to persist. </span><span class="koboSpan" id="kobo.244.2">Then, we check whether the activity has been saved to the database through the API </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">of </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.246.1">ActivityRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">An important aspect of these tests is that we’re not mocking away the database. </span><span class="koboSpan" id="kobo.248.2">The tests actually hit the database. </span><span class="koboSpan" id="kobo.248.3">Had we mocked the database away, the tests would still cover the same lines of code, producing the same high coverage of lines of code. </span><span class="koboSpan" id="kobo.248.4">However, despite this high coverage, the tests would still have a rather high chance of failing in a setup with a real database, due to errors in SQL statements or unexpected mapping errors between database tables and </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">Java objects.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Note that, by default, Spring </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.251.1">will spin up an in-memory</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.252.1"> database to use during tests. </span><span class="koboSpan" id="kobo.252.2">This is very practical, as we don’t have to configure anything, and the tests will work out of the box. </span><span class="koboSpan" id="kobo.252.3">However, since this in-memory database is most probably not the database we use in production, there is still a significant chance of something going wrong with the real database even when the tests work perfectly against the in-memory database. </span><span class="koboSpan" id="kobo.252.4">Database vendors love to implement their own flavor of SQL, </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">for instance.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">For this reason, persistence adapter tests should run against the real database. </span><span class="koboSpan" id="kobo.254.2">Libraries such as </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Testcontainers</span></strong><span class="koboSpan" id="kobo.256.1"> are a</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.257.1"> great help in this regard, spinning up a Docker container with a database </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">on demand.</span></span><span class="No-Break"><span id="footnote-029-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-029"><span class="koboSpan" id="kobo.259.1">3</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-029">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-029-backlink"><span class="koboSpan" id="kobo.260.1">3</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.261.1">Testcontainers: </span></span><a href="https://www.testcontainers.org/"><span class="No-Break"><span class="koboSpan" id="kobo.262.1">https://www.testcontainers.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.263.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.264.1">Running against the real database has the added benefit that we don’t have to take care of two different database systems. </span><span class="koboSpan" id="kobo.264.2">If we use the in-memory database during tests, we might have to configure it in a certain way, or we might have to create separate versions of database migration </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.265.1">scripts for each database, which</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.266.1"> is a big hit on the maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">our tests.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.268.1">Testing main paths with system tests</span></h1>
<p><span class="koboSpan" id="kobo.269.1">At the top </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.270.1">of the pyramid are what I call </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">system tests</span></strong><span class="koboSpan" id="kobo.272.1">. </span><span class="koboSpan" id="kobo.272.2">A </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.273.1">system test starts up the whole application and runs requests against its API, verifying that all our layers work </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">in concert.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Hexagonal Architecture is all about creating a well-defined boundary between our application and the outside world. </span><span class="koboSpan" id="kobo.275.2">Doing so makes our application boundaries very testable by design. </span><span class="koboSpan" id="kobo.275.3">To test our application locally, we just need to swap out the adapters with mock adapters, as outlined in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.276.1">Figure 8</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.277.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 8.2 – By replacing the adapters with mocks, we can run and test our application without dependencies on the outside world" src="image/Figure_08.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 8.2 – By replacing the adapters with mocks, we can run and test our application without dependencies on the outside world</span></p>
<p><span class="koboSpan" id="kobo.281.1">On the left, we can replace the input adapters with a test driver that calls the application’s input ports to interact with it. </span><span class="koboSpan" id="kobo.281.2">The test driver can implement certain test scenarios that simulate user behavior during an </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">automated test.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">On the right, we can replace the output adapters with mock adapters that simulate the behavior of a real adapter and return previously </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">specified values.</span></span><span class="No-Break"><span id="footnote-028-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-028"><span class="koboSpan" id="kobo.285.1">4</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-028">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-028-backlink"><span class="koboSpan" id="kobo.286.1">4</span></a><span class="koboSpan" id="kobo.287.1">	Mocks: depending on who you ask and what you’re doing in your test, instead of calling it a “mock”, you should call it a “fake” or “stub”. </span><span class="koboSpan" id="kobo.287.2">Each term seems to have a slightly different semantic, but in the end, they all replace a “real” thing with a “mock” thing to be used in tests. </span><span class="koboSpan" id="kobo.287.3">I’m usually a fan of naming things just right, but in this case, I don’t see value in discussing the nuances between where a mock ends and a stub starts. </span><span class="koboSpan" id="kobo.287.4">Or is it the other </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">way around?</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.289.1">This way, we can create “application tests” that cover the “hexagon” of our application from the input ports, through our domain services and entities, to the </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">output ports.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">I would argue, however, that, instead of writing “application tests” that mock away the input and output adapters, we should aim to write “system tests” that cover the whole path from a real input adapter to a real output adapter. </span><span class="koboSpan" id="kobo.291.2">These tests uncover many subtle bugs that we wouldn’t catch if we mocked away the input and output adapters. </span><span class="koboSpan" id="kobo.291.3">These bugs include mapping errors between the layers, or simply wrong expectations between the application and the outside systems it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">talking to.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">A “system test” such as this requires that we can spin up the real external systems our application talks to in a </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">test setup.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">On the input side, we need to make sure that we can make real HTTP calls to our application, for example, so that the requests go through our real web adapter. </span><span class="koboSpan" id="kobo.295.2">That should be rather easy, however, since we just need to start our application locally and let it listen to HTTP calls like it would in a </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">production environment.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">On the output side, we</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.298.1"> need to spin up a real database, for example, so that our tests go through the real persistence adapter. </span><span class="koboSpan" id="kobo.298.2">Most databases make that easy today by providing a Docker image that we can spin up locally. </span><span class="koboSpan" id="kobo.298.3">If our application talks to a third-party system that is not a database, we should still try to find (or create) a</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.299.1"> Docker image that contains that system so we can test our application against it by spinning up a local </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">Docker container.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">If no Docker image is available for a given external system, we can write a custom mock output adapter that simulates the real thing. </span><span class="koboSpan" id="kobo.301.2">Hexagonal Architecture makes it easy for us to replace the real output adapter with this mock for the purpose of our tests. </span><span class="koboSpan" id="kobo.301.3">And if a Docker image becomes available, we can switch to the real output adapter without too </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">much effort.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">There are valid reasons to test against mock adapters instead of real adapters, of course. </span><span class="koboSpan" id="kobo.303.2">If our application runs in multiple profiles, for example, and each profile uses a different (real) input or output adapter implemented against the same input and output ports, we might want to have tests that isolate errors in the application from errors in the adapters. </span><span class="koboSpan" id="kobo.303.3">Application tests that cover only our hexagon are exactly the tool we want, then. </span><span class="koboSpan" id="kobo.303.4">However, for a standard web application with a database, where the input and output adapters are rather static, we probably want to focus on system </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">tests instead.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">What would a system test look like? </span><span class="koboSpan" id="kobo.305.2">In a system test for the </span><em class="itali"><span class="koboSpan" id="kobo.306.1">Send money</span></em><span class="koboSpan" id="kobo.307.1"> use case, we send an HTTP request to the application and validate the response as well as the new balance of </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the account.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">In the Java and</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.310.1"> Spring </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.311.1">world, this is what it might </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">look like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.313.1"><img alt="" src="image/code-8.5a.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.314.1"><img alt="" src="image/code-8.5b.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.315.1">With </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.316.1">@SpringBootTest</span></strong><span class="koboSpan" id="kobo.317.1">, we tell Spring to start up the whole network of objects that makes up the application. </span><span class="koboSpan" id="kobo.317.2">We also configure the application to expose itself on a </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">random port.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">In the test method, we simply create a request, send it to the application, and then check the response status and the new balance of </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">the accounts.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">We use a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.322.1">TestRestTemplate</span></strong><span class="koboSpan" id="kobo.323.1"> to send the request, and not </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.324.1">MockMvc</span></strong><span class="koboSpan" id="kobo.325.1">, as we did earlier in the web adapter test. </span><span class="koboSpan" id="kobo.325.2">This means that the test makes real HTTP calls, bringing the test a little closer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">production environment.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Just as we go</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.328.1"> over real HTTP, we go through the real </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.329.1">output adapters. </span><span class="koboSpan" id="kobo.329.2">In our case, this is only a persistence adapter that connects the application to a database. </span><span class="koboSpan" id="kobo.329.3">In an application that talks to other systems, we would have additional output adapters in place. </span><span class="koboSpan" id="kobo.329.4">It’s not always feasible to have all these third-party systems up and running, even for a system test, so we might mock them away, after all. </span><span class="koboSpan" id="kobo.329.5">Our Hexagonal Architecture makes this as easy as it can be for us since we only have to stub out a couple of output </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">port interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Note that I went out of my way to make the test as readable as possible. </span><span class="koboSpan" id="kobo.331.2">I hid every bit of ugly logic within helper methods. </span><span class="koboSpan" id="kobo.331.3">These methods now form a domain-specific language that we can use to verify the state </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">of things.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">While a domain-specific language such as this is a good idea in any type of test, it’s even more important in system tests. </span><span class="koboSpan" id="kobo.333.2">System tests simulate the real users of the application much better than unit or integration tests can, so we can use them to verify the application from the viewpoint of the user. </span><span class="koboSpan" id="kobo.333.3">This is much easier with a suitable vocabulary at hand. </span><span class="koboSpan" id="kobo.333.4">This vocabulary also enables domain experts, who are best suited to embody a user of the application and probably aren’t programmers, to reason about the tests and give feedback. </span><span class="koboSpan" id="kobo.333.5">There are whole libraries for behavior-driven development, such as JGiven</span><span id="footnote-027-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-027"><span class="koboSpan" id="kobo.334.1">5</span></a></span><span class="koboSpan" id="kobo.335.1">, that provide a framework to create a vocabulary for </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">your tests.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-027">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-027-backlink"><span class="koboSpan" id="kobo.337.1">5</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.338.1">JGiven: </span></span><a href="https://jgiven.org/"><span class="No-Break"><span class="koboSpan" id="kobo.339.1">https://jgiven.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.341.1">If we create unit and integration tests as described in the previous sections, the system tests will cover a lot of the same code. </span><span class="koboSpan" id="kobo.341.2">Do they even provide any additional benefits? </span><span class="koboSpan" id="kobo.341.3">Yes, they do. </span><span class="koboSpan" id="kobo.341.4">Usually, they flush out other types of bugs than the unit and integration tests do. </span><span class="koboSpan" id="kobo.341.5">Some mapping between the layers could be off, for instance, which we would not notice with the unit and integration </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">tests alone.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">System tests play out their strength best if they combine multiple use cases to create scenarios. </span><span class="koboSpan" id="kobo.343.2">Each scenario represents a certain path a user might typically take through the application. </span><span class="koboSpan" id="kobo.343.3">If the most important scenarios are covered by passing system tests, we can assume </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.344.1">that we haven’t broken them with our latest </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.345.1">modifications and are ready </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">to ship.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.347.1">How much testing is enough?</span></h1>
<p><span class="koboSpan" id="kobo.348.1">A question many project teams I’ve been part of couldn’t answer is how much testing we should do. </span><span class="koboSpan" id="kobo.348.2">Is it enough if our tests cover 80% of our lines of code? </span><span class="koboSpan" id="kobo.348.3">Should it be higher </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">than that?</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Line coverage is a bad metric to measure test success. </span><span class="koboSpan" id="kobo.350.2">Any goal other than 100% is completely meaningless because important parts of the code base might not be covered at all.</span><span id="footnote-026-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-026"><span class="koboSpan" id="kobo.351.1">6</span></a></span><span class="koboSpan" id="kobo.352.1"> And even at 100%, we still can’t be sure that every bug has </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">been squashed.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-026">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-026-backlink"><span class="koboSpan" id="kobo.354.1">6</span></a><span class="koboSpan" id="kobo.355.1">	Test coverage: if you want to read more about 100% test coverage, have a look at my article with the tongue-in-cheek title Why you should enforce 100% code coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">at </span></span><a href="https://reflectoring.io/100-percent-test-coverage/"><span class="No-Break"><span class="koboSpan" id="kobo.357.1">https://reflectoring.io/100-percent-test-coverage/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.358.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.359.1">I suggest measuring test success by how comfortable we feel shipping the software. </span><span class="koboSpan" id="kobo.359.2">If we trust the tests enough to ship after having executed them, we’re good. </span><span class="koboSpan" id="kobo.359.3">The more often we ship, the more trust we have in our tests. </span><span class="koboSpan" id="kobo.359.4">If we only ship twice a year, no one will trust the tests because they only prove themselves twice </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">a year.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">This requires a leap of faith the first couple of times we ship, but if we make it a priority to fix and learn from bugs in production, we’re on the right track. </span><span class="koboSpan" id="kobo.361.2">For each production bug, we should ask the question, </span><em class="itali"><span class="koboSpan" id="kobo.362.1">“Why didn’t our tests catch this bug?”</span></em><span class="koboSpan" id="kobo.363.1">, document the answer, and then add a test that covers it. </span><span class="koboSpan" id="kobo.363.2">Over time, this will make us comfortable with shipping, and the documentation will even provide a metric for gauging our improvement </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">It helps, however, to start with a strategy that defines the tests we should create. </span><span class="koboSpan" id="kobo.365.2">One such strategy for our Hexagonal Architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">is this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.367.1">While implementing a domain entity, cover it with a </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">unit test.</span></span></li>
<li><span class="koboSpan" id="kobo.369.1">While implementing a use case service, cover it with a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">unit test.</span></span></li>
<li><span class="koboSpan" id="kobo.371.1">While implementing an adapter, cover it with an </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">integration test.</span></span></li>
<li><span class="koboSpan" id="kobo.373.1">Cover the most important paths a user can take through the application with a </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">system test.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.375.1">Note the phrase </span><em class="itali"><span class="koboSpan" id="kobo.376.1">while implementing</span></em><span class="koboSpan" id="kobo.377.1"> – when tests are done during the development of a feature and not after, they become a development tool and no longer feel like </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">a chore.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">However, if we have to spend an hour fixing tests every time we add a new field, we’re doing something wrong. </span><span class="koboSpan" id="kobo.379.2">Probably, our tests are too vulnerable to structural changes in the code, and we should look at how to improve that. </span><span class="koboSpan" id="kobo.379.3">Tests lose their value if we have to modify them for </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">each refactoring.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.381.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.382.1">The Hexagonal Architecture style cleanly separates domain logic and outward-facing adapters. </span><span class="koboSpan" id="kobo.382.2">This helps us to define a clear testing strategy that covers the central domain logic with unit tests and the adapters with </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">The input and output ports provide very visible mocking points in tests. </span><span class="koboSpan" id="kobo.384.2">For each port, we can decide to mock it or use the real implementation. </span><span class="koboSpan" id="kobo.384.3">If the ports are each very small and focused, mocking them is a breeze instead of a chore. </span><span class="koboSpan" id="kobo.384.4">The fewer methods a port interface provides, the less confusion there is about which of the methods we have to mock in </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">a test.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">If it becomes too much of a burden to mock things away, or if we don’t know which kind of test we should use to cover a certain part of the code base, that's a warning sign. </span><span class="koboSpan" id="kobo.386.2">In this regard, our tests have the additional responsibility of being a canary – to warn us about flaws in the architecture and steer us back on the path to creating a maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">So far, we have talked about our use cases and our adapters mostly in isolation. </span><span class="koboSpan" id="kobo.388.2">How do they communicate with each other? </span><span class="koboSpan" id="kobo.388.3">In the next chapter, we’ll take a look at some strategies for how to design data models that make up the common language </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">between them.</span></span></p>
</div>
</body></html>