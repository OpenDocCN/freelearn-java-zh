- en: Loggers and Performances – A Trade-Off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logs are probably one of the most important parts of an application, whatever
    technology it uses. Why is that? Because without logs, you have no idea what your
    application is doing or why your application is behaving in a particular way.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we saw in [Chapter 3](c4d7d24f-3ce9-428c-915c-04296a2c3a85.xhtml), *Monitor
    Your Application*, how to instrument the application to get some monitoring information
    about the JVM and application, but it was very technical and mainly performance
    or tracking oriented. This is important but rarely enough and generally not helpful
    enough for operation and support teams who generally prefer a higher level view
    of application tracing. This is where logging enters into the game. However, it
    is important that you correctly use it and configure it, so that you do not impact
    your application performance.
  prefs: []
  type: TYPE_NORMAL
- en: You may think that Java EE and logging are not directly related, but actually
    it is probably way more important to ensure you understand what logging is doing
    in an EE context. The main things you get from an EE container are services. Services
    are code and therefore have the same kind of constraints as your own code. You
    can take any Java EE library, and most services, if not all, will use some logger
    to let you understand what happens without having to look into the code. There
    are even some coding practices of some vendors that require you to log each time
    a method starts and stops. Long story short, loggers and log statements are everywhere,
    whether you wrote it yourself in your codebase or not because they are present
    in a library codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: When to use logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The work implied by a logging statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some common and useful performance-related logging patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some well-known logging libraries and how to configure them in EE land
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I log, you log, they log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When do we use logging? This very technically-oriented question should be rephrased
    this way: *when do we provide information about what the application is doing?* This
    is exactly what logging is used for; it lets the user know what the application
    did at some point.
  prefs: []
  type: TYPE_NORMAL
- en: This is something we, as developers, often forget because we are focused on
    the feature we are implementing. But if the application intends to hit production,
    it is crucial to not forget to make sure the operation teams can work with it
    very efficiently as well. Don't forget that if the development takes six months,
    the production will probably last for some years and the cost of an incident is
    way higher than a small delay before the production is launched. Therefore, investing
    in a system communicating enough information is often worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, logging is not a trivial task to underestimate. All the difficulty
    is about:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing messages that are meaningful for someone with poor—or without—knowledge
    of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring the message is logged, whatever happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log error cases which can be *invisible* in the code by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s just take a moment on this last case to deal with a more and more common
    use case in EE applications, particularly in microservice environments—an HTTP
    client in a REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a very common pattern used in microservice infrastructure, a service
    calling another one. This particular implementation is a flat proxy (no additional
    logic), but it can be used to hide some machine to machine credential or security
    mechanisms, for instance. What is important to identify here is that a JAX-RS
    client is called in a JAX-RS endpoint (`getQuote`). Now, when you think about
    error handling, what can happen with such code?
  prefs: []
  type: TYPE_NORMAL
- en: If the client call fails because the server returns an error (let's consider
    an HTTP 404 as the ID is invalid), then the client `get()` invocation will throw
    a `javax.ws.rs.NotFoundException`. Since there is no exception handling around
    the client invocation, your endpoint will throw the same exception, which means
    an HTTP 404 for JAX-RS on the server side, and thus, your own endpoint will throw
    the same exception.
  prefs: []
  type: TYPE_NORMAL
- en: It can be what you want—in the case of a proxy, for instance—but it is not very
    good in terms of implementation because when you get HTTP 404 responses on the
    client side (final client, not the endpoint client), then how do you know whether
    your endpoint or the remote service is broken?
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to mitigate that side effect is to change the implementation of the endpoint
    a bit, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is not a perfect implementation, but at least now, in the server logs,
    you will be able to identify that the invocation failed due to an error on the
    remote service. And that is already better than being silent. In real life, you
    can notify the final client that the error is not your fault and either use another
    status code or add a header, allowing the client to identify it depending on the
    type of service you implement. However, what doesn't change is that, at least,
    logging the error is allowing your application to give enough information for
    you to investigate where the issue comes from. Then, all the enrichments you can
    do on top of it (logging format, MDC, and so on) are mainly about making the information
    easy to find and fast to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging is a simple way—probably the simplest—to communicate from the JVM to
    outside of it. This is also probably why it is so widely used in all layers of
    any application. You can be sure that most (if not all) libraries and containers
    rely on a logger, somewhere. Generally, this is also the first contact you get
    with your container. When you start it as *empty*, the first thing you see is
    this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What is important here is not really the content of the output, but more that
    you can control it from the logging configuration. Java EE containers are not
    uniform on the implementation they use, but most of them rely on **Java Util Logging**
    (**JUL**), which is the Java standard logging solution. We will get back to the
    logger implementations later. But just to continue giving you an idea of why it
    is not directly done with console output or file management, we will open the
    GlassFish configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'GlassFish, relying on JUL, uses a `logging.properties` configuration. If you
    use the default GlassFish domain, you will find it in the `glassfish/domains/domain1/config/logging.properties`
    file. If you open this file, you will see these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not enter into the way JUL is configured here, but what we can identify
    from this snippet is that the logging abstraction allows us to:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure where the logs (messages) are going. We can see that `GFFileHandler`
    is pointing to the `server.log` file for instance, but that the `ConsoleHandler`
    is also set, which is consistent with the fact that we see the logs in the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the log level, which is something we will detail a bit more later;
    very high level, it allows you to select the logs you want to keep or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the implementation didn't use a logger abstraction, you wouldn't have the
    choice of the output (handler) and the level selection would be per case (not
    standardized), which would make the work of the operation teams way harder.
  prefs: []
  type: TYPE_NORMAL
- en: Logging frameworks and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of logging frameworks and this is probably one challenge integrators
    have, since the more you integrate libraries, the more you will need to ensure
    loggers are consistent and potentially go to the same output. However, they all
    share the same basic concepts, which are important to understand to know how to
    properly use loggers and how they can impact the application performance in a
    bad way if you don't take care of their usages.
  prefs: []
  type: TYPE_NORMAL
- en: 'These concepts can be differently named depending on the framework, but to
    identify them, we will use the JUL names in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Logger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logger Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LogRecord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logger is the entry point of the logging framework. This is the instance
    you use to *write* messages. The API has, generally, a set of helper methods but
    the requisite API elements are:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow passing a level with the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow passing a precomputed message of what is needed to compute a message
    (it can be a pattern with some variables or a `Supplier<>` as of Java 8). In this
    last case, the goal is to not evaluate/interpolate the message if not needed and
    avoid paying the cost of that computation if the message is *hidden*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow association with an `Exception` (mainly for error cases) to the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most common example of a logger usage will probably be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This logger invocation is equivalent to the following line, but avoids the
    concatenation if not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, it will also trigger the sending of the message (`String`) to the final
    output (console, file, and so on). It may not look that important, but think how
    many logger invocations you can have in a single request with the multiple and
    complex layers we saw in [Chapter 2](f9d9ccb7-8c28-4f87-9642-8c62a05fa856.xhtml),
    *Looking Under the Cover – What is This EE Thing?*. It can be important to avoid
    all these small operations, particularly because in general, you don't have just
    a simple concatenation but multiple ones on complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: Logger Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Logger Factory is generally a utility method (`static`) giving you a logger
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Logger Factory is either a specific class or the `Logger` class itself depending
    on the logging framework, but in all cases, it gives you a `Logger` instance.
    The parameter of this factory method can change, but generally leads to a `String`
    (a lot of libraries allow a `Class` shortcut) which can be used to configure the
    log level as we saw earlier in the JUL configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do logger frameworks need a factory and why don''t they allow you to instantiate
    the logger yourself with a plain `new`? Because the way the logger instance is
    resolved can depend on the environment. Don''t forget that most of the logger
    consumers (the code using a logger) can be deployed in a lot of environments,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: A standalone application with a flat classpath
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaEE container with a hierarchic classloader (tree)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OSGI container with a graph classloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always possible, in all logging frameworks, to configure the way the configuration
    is resolved and thus how the loggers are instantiated. Specially, as soon as you
    have a container, you will want to handle a global—container—configuration and
    a *per application* configuration to be able to make one application configuration
    more specific than the default one. To do that, containers  (or logging frameworks
    when the implementation is generic enough) will implement a custom configuration
    resolution and let the logging framework instantiate a logger with this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, in an EE container, you will get a different logging configuration
    per application. And if the application doesn't provide any configuration, then
    the container configuration will be used. If you take Apache Tomcat implementation
    for instance, it will read `conf/logging.properties` by default, and for each
    application, it will try to read `WEB-INF/logging.properties` if the file exists.
  prefs: []
  type: TYPE_NORMAL
- en: LogRecord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LogRecord` is the logging message structure. It encapsulates more data
    than just the `String` message you passed, allowing you to get the information
    we often see in the log messages, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a log sequence number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message indeed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The thread (often identified by its identifier rather than its name but this
    last one is not always unique)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logger invocation date (often in milliseconds as of 1970)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, an exception associated with the logger invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logger name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a resource bundle if the logger supports internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a call context such as a set of contextual data based on custom
    values (MDC) or the current HTTP request, for instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this list, we find the information we see (such as the message) but also
    all the metadata associated with the logger call such as the caller of the logger
    (class and method), the call context (its date and thread for instance), and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is this *record* which is passed into the logging chain, as we will
    see next.
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes called `Appender`, the handlers are the output implementations. They
    are the ones receiving the `LogRecord` of the previous part and doing *something* with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common implementations are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileHandler` : Outputs the messages in a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `MailHandler` : Sends the messages by mail. This is a particular handler
    that should not be used for a high volume of messages but it can be used with
    a *particular* logger dedicated to sending some messages under specific circumstances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConsoleHandler` to output messages into the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more, such as `JMSHandler`, `ElasticsearchHandler`, `HTTPHandler`,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, the handlers are sending data to a *backend* which can be anything,
    and the logging framework always ensures you can plug in your own implementation
    if you need to extend the default handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Filter` is simply a class allowing you to let the `LogRecord` be passed or
    not. In the Java 8 ecosystem, it can be seen as a `Predicate<LogRecord>`; this
    class has been in Java since its 1.4 version, far before `Predicate` was created.
  prefs: []
  type: TYPE_NORMAL
- en: It is often bound to a particular `Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: Formatter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Formatter` is a class taking a `LogRecord` and converting it into a `String`.
    It is the one responsible for preparing the content to be sent to the backend.
    The idea is to separate the *writing* and *formatting* concerns, allowing you
    to reuse one part without having to create a new `Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it is often bound to a particular `Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Level` is a simple concept. It is the metadata of the log record but also
    most of the logging components we just looked at. The main idea is to be able
    to compare the log record level to the level of the component the record goes
    through to skip the message if it is not compatible. The common (sorted) logging
    levels are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OFF`: Not directly used by the log record, but generally used only by other
    components, it disables any log message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEVERE` (or `ERROR`): The highest log level. It is intended to be used when
    something bad occurs. A record is logged if the component level is not `OFF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING`: Generally used when something wrong happened (but is not preventing
    the application to work); a record is logged if the level of the components is
    not `OFF` or `SEVERE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`: The default logging level of a lot of applications, it is used to notify
    us that something normal but interesting happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG`: Not the most used level, it is intended to be used for messages related
    to the configuration. In practice, applications and libraries often use `INFO`
    or `FINE` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FINE`,`FINER`,`FINEST`,`DEBUG`: These levels are intended to give low granularity
    information about the application. The message computing can be costly and it
    is not intended to be turned on in production in general. However, it can be a
    very useful piece of information when investigating an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALL`: Not used for the log record itself but only for component levels, it
    lets any message be logged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log levels are sorted (associated with an integer) and a log record level
    is *active* if all the component levels are lower than the log record level. For
    instance, a `WARNING` message will be logged if the component levels are `INFO`
    or `FINE`.
  prefs: []
  type: TYPE_NORMAL
- en: Logging invocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before looking at how to properly integrate loggers into your application using
    some common patterns, let's see what a logger invocation will trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple logger invocation, like  `logger.info(message)` , can be inspected
    to be represented as equivalent to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the level of the logger is active; if not, exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a log record (set the message and level, initialize the source of the
    log, class, method, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the message is filtered with a `Filter`; if the filter filters it,
    then exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all handlers, publish the log record to the handler:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the level of the handler versus the log record level, if not compatible
    then exit (note: this check is often done multiple times; it is fast because it
    is just an integer comparison)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the log record (convert it to a `String`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the formatted message to the actual backend (file, console, and so on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This high-level drilling down of a single logger invocation shows many interesting
    things about the loggers. The first one is that using a logger and having levels
    in all logging components allows the logging framework to bypass a lot of logic
    if the levels are not compatible. This is true at the logger level, and potentially
    at the filter level, and finally at the handler level. Then, we can identify that
    there are two layers where the logic depends on the configuration, and the processing
    time will be the function of the complexity of these elements, the filtering and
    the formatting. Lastly, the actual work—and generally the slowest part of the
    chain—is the backend interaction. Concretely, writing a line in a file is slow
    compared to the rest of the chain as it interacts with some hardware (your hard
    disk).
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JUL, there is no default filter implementation. But some common filters
    you can find in other frameworks or JUL extensions are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A time-based filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the log message is outside a time range, then skip it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a log message is older than some configured duration, then skip it (can be
    useful depending on the work done before the filter in the chain and if the machine
    has a hot peak)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **Mapped Diagnostic Context** (**MDC**) based filter: Typically, if an MDC
    value is matched (for example if MDC[''tenant''] is *hidden_customer),* then skip
    the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throttling: If you know you use a handler that can''t support more than 1,000
    messages/seconds—or if the actual backend, such as a database, can''t support
    more—then you can use a filter to enforce that limitation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regex-based: If the message doesn''t (or does) match a regex, then it is skipped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples are just a short list of potential filters you can encounter,
    but it illustrates the fact that the complexity can be more or less important
    and thus the execution duration of the filter layer can be more or less fast.
  prefs: []
  type: TYPE_NORMAL
- en: Formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As for filters, there are several formatters, and since it is really about
    how to convert the log record—the logging API—to the backend representation (String),
    then it can be more or less pricey. To get a high-level idea about that, here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'XML: Convert the log record to an XML representation; it generally uses string
    concatenation and logs all the record information (logger, thread, message, class,
    and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple: Just the log level and the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pattern: Based on a configured pattern, the output is computed. Generally,
    the logging frameworks allows you to include, in this pattern, the thread identifier
    or name, the message, the log level, the class, the method, the exception if there
    is one, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default JUL pattern is `%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s:
    %5$s%6$s%n`. This pattern leads to this sort of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not detail the syntax here, but it reuses the Java `java.util.Formatter`
    syntax behind the `SimpleFormatter` which was used for that output. This implementation
    passes, to the formatter, the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Date of the log event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source of the log event (`class method`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logger name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is interesting with this last type of formatter is that it lets you customize
    the output and change its formatting depending on your needs. For instance, instead
    of using the default format on two lines, you could set the format to be `%1$tb
    %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s %4$s: %5$s%6$s%n`, then the output would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The big advantage is to really customize the output to your needs and potentially
    match a log forwarder like Splunk or Logstash.
  prefs: []
  type: TYPE_NORMAL
- en: To activate this pattern with JUL, you need to set the system property `"-Djava.util.logging.SimpleFormatter.format=<the
    pattern>"`.
  prefs: []
  type: TYPE_NORMAL
- en: Using handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with performance, it is important to define the trade-off you want
    in terms of logging. An interesting metric can be to compare the application without
    any active logging statement versus the ones you want to keep (for production).
    If you identify that the performance drastically decreases with logging activated,
    then you probably have a configuration issue, either in one of the logging layers
    or—more commonly—with the backend usage (such as overusing a remote database).
  prefs: []
  type: TYPE_NORMAL
- en: The handler, being the part *exiting* the application, is the one requiring
    most of the attention. This doesn't mean other layers are not important, but they
    are generally faster to check since they often lead to a constant evaluation time.
  prefs: []
  type: TYPE_NORMAL
- en: There are several implementations of handlers, but it is not rare to have specific
    ones in companies because you want to target a specific backend or you want custom
    integration. In these cases, you have to make sure it doesn't introduce some bottleneck
    or performance issues. To illustrate that statement, we will use a case where
    you want to send the log records to an HTTP server in JSON format. For each message,
    if you send a request, then you can send many requests as threads in parallel
    and you will pay the HTTP latency for each logger invocation. When you think that
    a method can have multiple logger invocations and that a logger can have multiple
    handlers (you can log the same messages in the console and a file and a server),
    then you quickly understand this synchronous *per message* first implementation
    will not scale for very long.
  prefs: []
  type: TYPE_NORMAL
- en: This is why all the backend integrations, which are implying remote operations,
    are using alternative implementations and generally support some bulking of the
    messages to send them in chunks (multiple messages at once). Then, the handler
    reception of the message just triggers an addition in a *stack*, and later, another
    condition will trigger the actual request (HTTP request in our previous case).
    In terms of performance, we converted a high latency implementation in a low latency
    operation, as the operation is as fast as adding an object to a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Logging components and Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be tempting to reuse Java EE to implement logging components. It is
    not impossible, but there are some points to consider before doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: JUL doesn't always support the loading of classes with the container or application
    classloader, so you may need a facade implementation that contextually loads the
    container or application classes. In other words, you will not always be able
    to programmatically depend on CDI, but you may need some reflection which has
    a cost you want to minimize. So, make sure to keep the results of your CDI lookup
    if you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first chapters, we looked at the Java EE layers. Make sure you don't
    rely on something too heavy for a logger implementation to avoid being impacted
    by all this work and to avoid hiding the fact that you have *an application under
    the application* through your loggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging context is not controlled. Generally, you don't know when a logger is
    used. So, if you implement a component using CDI, make sure you use features available
    only in all contexts. Concretely, don't use `@RequestScoped` if you don't use
    the `RequestContextController` to activate the scope yourself. Also, ensure you
    have configured the *EE* component on a logger only, used in an EE context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not impossible to do a logging-EE bridge, but for logging, we generally
    want to be very efficient and as raw as possible. See it more as a potential fallback
    if you can't modify the application than the opposite by default. In a realistic
    manner, it is better to send an EE event you observe and call a logger from an
    observer, than the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: Logging patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are but a few important logging patterns you can utilize to try to minimize
    the logging overhead implied, without any benefit from a functional point of view.
    Let's go through the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important thing about a log message is its level. It is the information
    allowing you to efficiently ignore the messages - and their formatting/templating
    - if they will be ignored later anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, take this method that relies on loggers at different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is mixing *debug* and *info* log messages. Nevertheless, it is very
    likely that the *debug* messages will not be activated in production, but *info *messages
    will be if you use the *info* level as optional messages, then do the same reasoning
    with the *warning* level. For that reason, it is pointless to log the *debug*
    messages in most cases. It is also useless to compute the concatenations of these
    messages as they will not be logged.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid these computations—and don''t forget a `toString()` can be complex
    in some cases or at least `long` to compute—a common pattern is to test the log
    level in the application yourself, instead of waiting for the logging framework
    to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Simply wrapping the rarely logged messages in a `isLoggable()` conditional block
    will do a quick test against the logger level and bypass the message computation,
    and all the logging chains most of the time, ensuring the performance is not too
    affected by debug statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 8, there has been an alternative to that pattern which is quite
    interesting: using `Supplier<>` to create the message. It provides a way to compute
    the message rather than the message itself. This way, the code is more condensed
    thanks to the lambda which is compatible with the related signatures. But the
    cost of the string evaluation is not paid anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed a lambda computing the actual message only if the log statement
    passed the first test, which is about the log level of the logger. This is really
    close to the previous pattern but still a bit more costly than an integer test
    which is generally the `isLoggable()` implementation. Yet, the overhead is not
    that significant and the code is less verbose, but generally efficient enough.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the same log level multiple times, it can be worth factorizing the
    log level check a single time at the beginning of the method, instead of calling
    it multiple times in the same methods. The more you use a logger abstraction,
    and therefore go through layers, the more it will be true. Since it is a very
    simple optimization—your IDE can even suggest you to do it for you—you shouldn't
    hesitate to do it. Though, don't do it at class level (such as storing the loggable
    test in a `@PostConstruct`; since most logger implementations support dynamic
    levels; you could break that feature).
  prefs: []
  type: TYPE_NORMAL
- en: Using templates in your messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at how to bypass the logging of a message.
    With JUL, it is often done with the methods called log levels, but there is a
    more generic log method  called `log`, which can take the level, the message (or
    a key in a resource bundle if you internationalize the messages), and an object
    array parameter. This type of method exists in all frameworks and most of them
    will also provide some particular signatures with one, two, or more parameters
    to make it smoother to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, the idea is to use the message as a pattern and the parameters
    to valorize some variables of the message. This is the feature this log pattern
    uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This log statement will replace the `{i}` templates with the i^(th) value in
    the `Object[]` array.
  prefs: []
  type: TYPE_NORMAL
- en: Using this pattern is interesting as it avoids computing the actual string value
    if not needed. This solution seems better than the previous `isLoggable()` check
    in terms of code impact, right? It actually depends on the logger implementation.
    JUL doesn't support it. But for the frameworks supporting parameters without arrays,
    they can have some optimization, which would make this assumption right. However,
    for JUL or all the cases where you have enough parameters to require an array
    creation, it is not right. The fact that you have to create an array is impactful
    and therefore it is better to skip it if you don't need it, which means to fallback
    on the previous pattern or the `Supplier<>` based API.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous or not?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to modern requirements in terms of scaling, the loggers needed to be enhanced
    to support a higher message rate, but still needed to be less impactful on the
    application performance itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to reduce the latency of a logger is to make the handlers asynchronous.
    This is not yet standard with JUL but you can find some libraries providing that
    feature—some containers like Apache TomEE even provide it out of the box. The
    idea is exactly the one we described in the section about handlers, compute the
    minimum context for the log record and push the record in a *queue* in the caller
    thread, then actually *store*/publish the message in another thread (or threads
    depending on the backend).
  prefs: []
  type: TYPE_NORMAL
- en: This pattern already solves most of the logger impact in terms of performance,
    but some logging frameworks (such as Log4j2) go further, making the loggers themselves
    asynchronous. Since the filtering (and sometimes formatting) is now fully asynchronously
    done, then the caller duration is way smaller and the performance impact is reduced
    a lot (still, considering, you have enough CPU to handle this additional work
    as you execute more code in parallel).
  prefs: []
  type: TYPE_NORMAL
- en: If you add some modern implementation to the asynchronous handling, based on
    the ring buffer pattern, as Log4j2 did using the disruptor ([https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/))
    library, then you have a solution scaling very well. More you will have threads,
    more the impact of such an implementation will be significative, even compared
    to an asynchronous handler (appender for log4j2).
  prefs: []
  type: TYPE_NORMAL
- en: Logging implementations – which one to pick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is one of the oldest topics you can encounter in computer science, but
    it is also one that has been solved many times. Understand that you will find
    lots of frameworks about logging. Let's have a quick look at them and see how
    they can sometimes relate.
  prefs: []
  type: TYPE_NORMAL
- en: Logging facade – the good bad idea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging facades are frameworks such as SLF4J ([https://www.slf4j.org/](https://www.slf4j.org/)),
    commons-logging, jboss-logging, or more recently, the log4j2 API ([https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/)).
    They intend to provide a uniform API usable with any sort of logging implementation.
    You must really see it as an API (as Java EE is an API), and the logging frameworks
    as implementations (as GlassFish, WildFly, or TomEE are Java EE implementations).
  prefs: []
  type: TYPE_NORMAL
- en: 'These facades need a way to find the implementation they have to use. You can
    encounter several strategies, such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: SLF4J, for instance, will look up a particular class all implementations provide
    in their distribution (called *bindings* for SLF4J), and once instantiated it
    will give SLF4J API the link with the final implementation (JUL, Log4J, Logback,
    and so on). The issue here is that you cannot have multiple implementations in
    the same classloader and you cannot just configure the one you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commons-logging will read a configuration file to know which implementation
    to pick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A global system property-based configuration with a hardcoded default allowing
    to select the implementation to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a logging facade is generally a good idea as it allows your code, or the
    code of the libraries you use, to be decoupled from the logging implementation,
    delegating the choice of that implementation to the application packager or the
    deployer. It allows you to run it in all circumstances without you having to care
    about it during development.
  prefs: []
  type: TYPE_NORMAL
- en: Even ignoring the fact that there are multiple implementations of such an API,
    which makes things complicated already, their usage is not that elegant depending
    on the implementation you use. Several implementations will need to fill some
    parameters that are costly to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: The best example is the computation of the source class and method. In several
    implementations, it will be done by creating an `Exception` to get its associated
    stack trace and, after having dropped the known caller of the logging framework,
    will deduce the business caller. In a Java EE environment, and due to the stacks
    it uses to provide a simple programming model, the exception stack can be huge
    and *slow* to compute and fill (allocate the array). This means that each log
    message will be slowed down a bit to implement the bridge between this facade
    API and the actual logger implementation you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it can be worth checking the implementation you use with such
    a facade. For the most common one, SLF4J, there are two well-known implementations
    very well integrated with the API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logback: A native implementation of the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log4j2: Has got an SLF4J direct implementation (binding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, there are several logging frameworks you can encounter. The most
    famous, and the ones you have probably already heard about, are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log4j1: The historical standard de facto, slowly replaced by log4j2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log4j2: Probably one of the most advanced implementations today. Supports asynchronous
    loggers and has a ring buffer integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logback: The native SLF4J implementation. It was probably the best choice before
    log4j2 was done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Util Logging: The JVM standard logging API. Not the most evolved API,
    but it works and doesn''t require any dependency, though, you may need some custom
    integrations (handlers) for production. Check out your server which can already
    provide some solutions here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these share the concepts we just went through, but may have some small
    differences. To let you work faster with them, we will quickly go through these
    implementations to define the semantics used by the framework and show you how
    to configure each of them. When you do some benchmarks, it is very important to
    know how to configure the logging and guarantee it doesn't slow down your performance
    due to a bad configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Log4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logj4 (1.x) uses the `org.apache.log4j` base package. Here are the logging
    concepts we talked about adapted to log4j1 semantic:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Name** |'
  prefs: []
  type: TYPE_TB
- en: '| Logger | Logger |'
  prefs: []
  type: TYPE_TB
- en: '| Logger Factory | Logger |'
  prefs: []
  type: TYPE_TB
- en: '| Handler | Appender |'
  prefs: []
  type: TYPE_TB
- en: '| Filter | Filter |'
  prefs: []
  type: TYPE_TB
- en: '| Formatter | Layout |'
  prefs: []
  type: TYPE_TB
- en: '| Level | Level |'
  prefs: []
  type: TYPE_TB
- en: Most of the concepts are the same as in JUL, but with a few different names.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of usage, it is the same as in JUL, except it uses another package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What is a bit different is the configuration. It uses a `log4j.properties`
    or `log4j.xml` in the classpath (by default) which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this sample configuration the root logger (default) level is `DEBUG` and
    it will use a `stdout` appender. The appender is using `ConsoleAppender`; it will
    log the messages on the `System.out` and uses a pattern layout with a custom pattern
    (`ConversionPattern`). The package `com.packt.quote` log level is set to `WARN`.
    So, loggers using this name or a sub-name of this package will only log `WARN`
    and `ERROR` messages.
  prefs: []
  type: TYPE_NORMAL
- en: Log4j2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log4j2 was obviously inspired by Log4j1 but was completely rewritten. It still
    has some differences and it is completely different in terms of behavior and performance.
    Here is the concept mapping for log4j2:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Name** |'
  prefs: []
  type: TYPE_TB
- en: '| Logger | Logger |'
  prefs: []
  type: TYPE_TB
- en: '| Logger Factory | LoggerManager |'
  prefs: []
  type: TYPE_TB
- en: '| Handler | Appender |'
  prefs: []
  type: TYPE_TB
- en: '| Filter | Filter |'
  prefs: []
  type: TYPE_TB
- en: '| Formatter | Layout |'
  prefs: []
  type: TYPE_TB
- en: '| Level | Level |'
  prefs: []
  type: TYPE_TB
- en: 'The configuration has some fallbacks, but the default file is looked up in
    the classpath and is called `log4j2.xml`. It uses a different syntax than the
    XML version of Log4j1, based on the new plugin system of Log4j2, to have a nicer
    syntax (less technical):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the same sort of configuration as the one in the previous section, but
    it uses this new syntax that relies on the plugin names (`Console` is the name
    of the console appender in log4j2 for instance). Nevertheless, we still have the
    same structure where loggers are defined in a loggers block with the specific
    root logger, and where appenders have their own block linked to the loggers through
    a reference/idenfitier (`ref`).
  prefs: []
  type: TYPE_NORMAL
- en: Log4j2 has other nice features such as the hot reloading of the configuration,
    JMX extensions, and so on, which can be worth a look. It can help you change the
    logging configuration without restarting the application during your benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Logback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logback is a native implementation of SLF4J and an advanced logging implementation.
    Here is its mapping with the concepts we talked about:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concept** | **Name** |'
  prefs: []
  type: TYPE_TB
- en: '| Logger | Logger (from SLF4J) |'
  prefs: []
  type: TYPE_TB
- en: '| Logger Factory | LoggerFactory (from SLF4J) |'
  prefs: []
  type: TYPE_TB
- en: '| Handler | Appender |'
  prefs: []
  type: TYPE_TB
- en: '| Filter | Filter |'
  prefs: []
  type: TYPE_TB
- en: '| Formatter | Encoder/Layout |'
  prefs: []
  type: TYPE_TB
- en: '| Level | Level |'
  prefs: []
  type: TYPE_TB
- en: Note that logback also has the concept of `Encoder` to link the messages to
    `byte[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration relies, by default, on a `logback.xml` file in the classpath,
    looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a configuration close to the previous one (log4j1, log4j2) and recognizes
    the same kind of configuration, except the `encoder` layer wrapping the `pattern`.
    This is mainly because the encoder will pass a `byte[]` value to the appender
    and the pattern will pass a `String` to the encoder, allowing the implementation
    to be more easily composed, even if rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: JUL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used JUL to name the concepts we talked about, so we don't need a mapping
    table for the concept. Yet, it is interesting to see how JUL is configured since
    it is used in lots of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Very high-level JUL uses a `LogManager`, which is the Logger Factory (hidden
    behind the `Logger.getLogger(...)`Logger Factory).
  prefs: []
  type: TYPE_NORMAL
- en: The `LogManager` is instantiated from the class passed to the `java.util.logging.config.class` system
    property. If not set, the default implementation will be used, but note that most
    EE containers will override it to support additional features such as a configuration
    per application, for instance, or a custom configuration, generally dynamic and
    managed through a nice UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration is located with the system property `java.util.logging.config.file`
    or falls back on `${java.jre.home}/lib/logging.properties`—note that Java 9 used
    the folder `conf` instead of `lib`. The syntax of this properties file is the
    same as we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the snippet, we identify how to set a level to a package (the
    key is just suffixed by `.level` and the value is the level name). The same sort
    of logic applies to the default logger, which has an empty name, so its level
    is set using the `.level` key directly. The `handlers` key gets a list of handlers
    to configure (comma separated). It is generally a fully qualified name of a handler.
    Then, the two blocks in the middle, starting with handler names, are the handler
    configurations. It generally uses a dotted notation (`<handler class>.<configuration>
    = <value>`), but there is no obligation since the handler has access to all the
    properties through the `LogManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Tomcat/TomEE `ClassLoaderLogManager` allows you to prefix the handler
    with a custom prefix value starting with a number. It enables you to define N
    times the same handler with different configuration, which is not supported out
    of the box by JUL, which can only define a handler once.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can choose your implementation, you should check where you want to send
    your logs and pick the implementation already doing what you need, or the implementation
    which has a very close feature. Then, if multiple implementations fit your requirements,
    you need to check which one is the fastest.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from log4j2 or logback is generally a good choice. Yet, in practice,
    you rarely have the choice and part of your stack is imposed by your environment
    (dependencies and containers). Thus, it is highly probable you will need to configure
    JUL as well. In such a case, a good option is to check if you can reuse your container
    backbone without being dependent on your container in terms of code (that is,
    you can use the JUL API and delegate, to your container, the JUL configuration
    for instance). Then, you need to evaluate if JUL will fit your runtime needs in
    terms of performance. JUL gets lots of bad reviews on the internet, but it is
    more than sufficient for a lot of applications asynchronously logging into a file.
    Don't disregard it without evaluating it against your concrete needs. It can avoid
    configuration headaches and dependencies in a lot of cases.
  prefs: []
  type: TYPE_NORMAL
- en: Another criteria can be the easiness to redirect all logs to the same logging
    stack. One of the best ones in that area is log4j2, which supports pretty much
    all integrations (SLF4J, commons-logging, log4j1, log4j2, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use file-based handlers/appenders, probably the most common use case,
    you should also have a look at the rotation policies. It is generally configurable
    and the most common strategies are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Per day: Each day, you get a new log file for the handler (mylog.2017-11-14.log, mylog.2017-11-15.log,
    and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At restart: Each time the server is restarted, a new log file is created. Note
    this strategy doesn''t work well except for batch instances or no long running
    instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per size: If the log file size exceeds some disk space, then create a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that all these strategies can often be mixed or accumulated. Only JUL will
    not support it out of the box, but containers often try to fill that gap. It is
    not because your container uses JUL that you don't have this feature. Don't hesitate
    to have a look at your container logging configuration and investigate it before
    rejecting JUL as an API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at why logging is important to get a good and easy
    monitoring level. We also saw that a logging statement must be as minimally impactful
    on performance as possible so as not to defeat the optimization and coding you
    may have done elsewhere in your application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave you some common and simple patterns that can help you to rely,
    as much as possible, on the logging framework to make sure you maintain good performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw that several implementations may need to be configured in your
    applications, but that they will all share the same concepts, and that it is possible
    to rely on a single API, or even a single implementation from multiple APIs.
  prefs: []
  type: TYPE_NORMAL
- en: At this point of the book, you know what Java EE does and how to code and monitor
    an application. Now it is time to look at how you should approach a benchmark.
    This will be the topic of our next chapter.
  prefs: []
  type: TYPE_NORMAL
