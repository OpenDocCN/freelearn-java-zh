<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-84"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.2.1">Writing Our First Test</span></h1>
<p><span class="koboSpan" id="kobo.3.1">It’s time for us to dive in and write our first TDD unit test in this chapter. </span><span class="koboSpan" id="kobo.3.2">To help us do this, we will learn about a simple template that helps us organize each test into a logical, readable piece of code. </span><span class="koboSpan" id="kobo.3.3">Along the way, we will learn some key principles we can use to make our tests effective. </span><span class="koboSpan" id="kobo.3.4">We will see how writing the test first forces us to make decisions about the design of our code and its ease of use, before needing to think about </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">implementation details.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">After some examples covering those techniques, we will make a start on our Wordz application, writing a test first before adding production code to make that test pass. </span><span class="koboSpan" id="kobo.5.2">We will use the popular Java unit testing libraries JUnit5 and AssertJ to help us write </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">easy-to-read tests.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the following main principles behind writing effective </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">unit tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Starting </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">TDD: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">Arrange-Act-Assert</span></strong></span></li>
<li><span class="koboSpan" id="kobo.12.1">Defining a </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">good test</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Catching </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">common errors</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Asserting exceptions</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Only testing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">public methods</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Learning from </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">our tests</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Beginning Wordz – our </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">first test</span></span></li>
</ul>
<h1 id="_idParaDest-85"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">The final code in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.28.1">Starting TDD: Arrange-Act-Assert</span></h1>
<p><span class="koboSpan" id="kobo.29.1">Unit tests are nothing mysterious. </span><span class="koboSpan" id="kobo.29.2">They’re just code, executable code written in the same language that you write your application in. </span><span class="koboSpan" id="kobo.29.3">Each unit test forms the first use of the code you want to write. </span><span class="koboSpan" id="kobo.29.4">It calls the code just as it will be called in the real application. </span><span class="koboSpan" id="kobo.29.5">The test executes that code, captures all the outputs that we care about, and checks that they are what we expected them to be. </span><span class="koboSpan" id="kobo.29.6">Because the test uses our code in the exact same way that the</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.30.1"> real application will, we get instant feedback on how easy or difficult our code is to use. </span><span class="koboSpan" id="kobo.30.2">This might sound obvious, and it is, but it is a powerful tool to help us write clean and correct code. </span><span class="koboSpan" id="kobo.30.3">Let’s take a look at an example of a unit test and learn how to define </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">its structure.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.32.1">Defining the test structure</span></h2>
<p><span class="koboSpan" id="kobo.33.1">It’s always helpful to</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.34.1"> have templates to follow when we do things and unit tests are no exception. </span><span class="koboSpan" id="kobo.34.2">Based on commercial work done on the Chrysler Comprehensive Compensation Project, TDD inventor Kent Beck found that unit tests had certain features in common. </span><span class="koboSpan" id="kobo.34.3">This </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.35.1">became summarized as a recommended structure for test code, called </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Arrange-Act-Assert</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.37.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.38.1">AAA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.40.1">The original definition of AAA</span></p>
<p class="callout"><span class="koboSpan" id="kobo.41.1">The original description of AAA can be found here, in the C2 </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">wiki: </span></span><a href="http://wiki.c2.com/?ArrangeActAssert"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">http://wiki.c2.com/?ArrangeActAssert</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.44.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">To explain what each section does, let’s walk through a completed unit test for a piece of code where we want to ensure that a username is displayed </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">in lowercase:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.*;
public class UsernameTest {
    @Test
    public void convertsToLowerCase() {
        var username = new Username("SirJakington35179");
        String actual = username.asLowerCase();
        assertThat(actual).isEqualTo("sirjakington35179");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.48.1">The first thing to notice is the class name for our test: </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">UsernameTest</span></strong><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">This is the first piece of storytelling for readers</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.51.1"> of our code. </span><span class="koboSpan" id="kobo.51.2">We are describing the behavioral area we are testing, in this case, usernames. </span><span class="koboSpan" id="kobo.51.3">All our tests, and indeed all our code, should follow this storytelling approach: what do we want the readers of our code to understand? </span><span class="koboSpan" id="kobo.51.4">We want them to clearly see what the problem that we are solving is and how the code that solves it should be used. </span><span class="koboSpan" id="kobo.51.5">We want to demonstrate to them that the code </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">works correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The unit test itself is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">convertsToLowerCase()</span></strong><span class="koboSpan" id="kobo.55.1"> method. </span><span class="koboSpan" id="kobo.55.2">Again, the name describes what we expect to happen. </span><span class="koboSpan" id="kobo.55.3">When the code runs successfully, the username will be converted to lowercase. </span><span class="koboSpan" id="kobo.55.4">The names are intentionally simple, clear, and descriptive. </span><span class="koboSpan" id="kobo.55.5">This method has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">@Test</span></strong><span class="koboSpan" id="kobo.57.1"> annotation from the </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">JUnit5</span></strong><span class="koboSpan" id="kobo.59.1"> test framework. </span><span class="koboSpan" id="kobo.59.2">The annotation tells JUnit that this is a test that it can run </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">@Test</span></strong><span class="koboSpan" id="kobo.63.1"> method, we can see our </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Arrange-Act-Assert</span></em><span class="koboSpan" id="kobo.65.1"> structure. </span><span class="koboSpan" id="kobo.65.2">We first </span><em class="italic"><span class="koboSpan" id="kobo.66.1">arrange</span></em><span class="koboSpan" id="kobo.67.1"> for our code to be able to run. </span><span class="koboSpan" id="kobo.67.2">This involves creating any objects required, supplying any configuration needed, and connecting any dependent objects and functions. </span><span class="koboSpan" id="kobo.67.3">Sometimes, we do not need this step, for example, if we are testing a simple standalone function. </span><span class="koboSpan" id="kobo.67.4">In our example code, the </span><em class="italic"><span class="koboSpan" id="kobo.68.1">Arrange</span></em><span class="koboSpan" id="kobo.69.1"> step is the line that creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">username</span></strong><span class="koboSpan" id="kobo.71.1"> object and supplies a name to the constructor. </span><span class="koboSpan" id="kobo.71.2">It then stores that object ready to use in the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">username</span></strong><span class="koboSpan" id="kobo.73.1"> variable. </span><span class="koboSpan" id="kobo.73.2">It is the first line of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">var username = new Username("SirJakington35179");</span></strong><span class="koboSpan" id="kobo.75.1"> test </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">method body.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">The </span><em class="italic"><span class="koboSpan" id="kobo.78.1">Act</span></em><span class="koboSpan" id="kobo.79.1"> step follows. </span><span class="koboSpan" id="kobo.79.2">This is the part where we cause our code under test to act – we run that code. </span><span class="koboSpan" id="kobo.79.3">This is always a call to the code under test, supplying any necessary parameters, and arranging to capture the results. </span><span class="koboSpan" id="kobo.79.4">In the example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">String actual = username.asLowerCase();</span></strong><span class="koboSpan" id="kobo.81.1"> line is the </span><em class="italic"><span class="koboSpan" id="kobo.82.1">Act</span></em><span class="koboSpan" id="kobo.83.1"> step. </span><span class="koboSpan" id="kobo.83.2">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">asLowerCase()</span></strong><span class="koboSpan" id="kobo.85.1"> method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">username</span></strong><span class="koboSpan" id="kobo.87.1"> object. </span><span class="koboSpan" id="kobo.87.2">It takes no parameters and returns a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">String</span></strong><span class="koboSpan" id="kobo.89.1"> object containing the lowercase text </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">sirjakington35179</span></strong><span class="koboSpan" id="kobo.91.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">a result.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Completing our test is the final </span><em class="italic"><span class="koboSpan" id="kobo.94.1">Assert</span></em><span class="koboSpan" id="kobo.95.1"> step. </span><span class="koboSpan" id="kobo.95.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">assertThat(actual).isEqualTo("sirjakington35179");</span></strong><span class="koboSpan" id="kobo.97.1"> line is our </span><em class="italic"><span class="koboSpan" id="kobo.98.1">Assert</span></em><span class="koboSpan" id="kobo.99.1"> step here. </span><span class="koboSpan" id="kobo.99.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">assertThat()</span></strong><span class="koboSpan" id="kobo.101.1"> method and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">isEqualTo()</span></strong><span class="koboSpan" id="kobo.103.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">AssertJ</span></strong><span class="koboSpan" id="kobo.105.1"> fluent assertions library. </span><span class="koboSpan" id="kobo.105.2">Its job is to check whether the result we returned from the </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Act</span></em><span class="koboSpan" id="kobo.107.1"> step matches our expectations or not. </span><span class="koboSpan" id="kobo.107.2">Here, we are testing whether all the uppercase letters in</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.108.1"> the original name have been converted </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">to lowercase.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Unit tests like this are easy to write, easy to read, and they run very quickly. </span><span class="koboSpan" id="kobo.110.2">Many such tests can run in under </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">1 second.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">JUnit</span></strong><span class="koboSpan" id="kobo.114.1"> library is the industry-standard unit test framework for Java. </span><span class="koboSpan" id="kobo.114.2">It provides us with a means to annotate Java methods as unit tests, lets us run all our tests, and visually displays the results, as shown here in the </span><em class="italic"><span class="koboSpan" id="kobo.115.1">IntelliJ</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.116.1">IDE window:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.117.1"><img alt="Figure 5.1 – Output from the JUnit test runner" src="image/Figure_5.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.118.1">Figure 5.1 – Output from the JUnit test runner</span></p>
<p><span class="koboSpan" id="kobo.119.1">We see here that the unit test failed. </span><span class="koboSpan" id="kobo.119.2">The test expected the result to be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">sirjakington35179 </span></strong><span class="koboSpan" id="kobo.121.1">text string but instead, we received </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">null</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Using TDD, we would complete just enough code to make that </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">test pass:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.125.1"><img alt="Figure 5.2 – A JUnit test pass" src="image/Figure_5.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.126.1">Figure 5.2 – A JUnit test pass</span></p>
<p><span class="koboSpan" id="kobo.127.1">We can see that our change to the production code has made this test pass. </span><span class="koboSpan" id="kobo.127.2">It has </span><em class="italic"><span class="koboSpan" id="kobo.128.1">gone green</span></em><span class="koboSpan" id="kobo.129.1">, to use the popular term. </span><span class="koboSpan" id="kobo.129.2">Tests that fail are described as red tests and those that pass are green. </span><span class="koboSpan" id="kobo.129.3">This is </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.130.1">based on the colors shown in popular IDEs, which are based on traffic signals in turn. </span><span class="koboSpan" id="kobo.130.2">Seeing all these short iterations of red tests turning to green is surprisingly satisfying, as well as building confidence in our work. </span><span class="koboSpan" id="kobo.130.3">The tests help us focus on the design of our code by forcing us to work backward from outcomes. </span><span class="koboSpan" id="kobo.130.4">Let’s look at what </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">this means.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.132.1">Working backward from outcomes</span></h2>
<p><span class="koboSpan" id="kobo.133.1">One thing we </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.134.1">notice right away is just how unimportant the actual code that makes this test pass is. </span><span class="koboSpan" id="kobo.134.2">Everything in this test is about defining the expectations of that code. </span><span class="koboSpan" id="kobo.134.3">We are setting boundaries around </span><em class="italic"><span class="koboSpan" id="kobo.135.1">why</span></em><span class="koboSpan" id="kobo.136.1"> our code is useful and </span><em class="italic"><span class="koboSpan" id="kobo.137.1">what</span></em><span class="koboSpan" id="kobo.138.1"> we expect it to do. </span><span class="koboSpan" id="kobo.138.2">We are not constraining </span><em class="italic"><span class="koboSpan" id="kobo.139.1">how</span></em><span class="koboSpan" id="kobo.140.1"> it does it in any way. </span><span class="koboSpan" id="kobo.140.2">We are taking an </span><em class="italic"><span class="koboSpan" id="kobo.141.1">outside-in</span></em><span class="koboSpan" id="kobo.142.1"> view of code. </span><span class="koboSpan" id="kobo.142.2">Any implementation that makes our test pass </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">is acceptable.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">This seems to be a transition point in learning to use TDD. </span><span class="koboSpan" id="kobo.144.2">Many of us learned to program by writing implementations first. </span><span class="koboSpan" id="kobo.144.3">We thought about how the code would work. </span><span class="koboSpan" id="kobo.144.4">We went deep into the algorithms and data structures behind a specific implementation. </span><span class="koboSpan" id="kobo.144.5">Then, as a last thought, we wrapped it all up in some kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">callable interface.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">TDD turns this on its head. </span><span class="koboSpan" id="kobo.146.2">We intentionally design our callable interface first, as this is what the users of that code will see. </span><span class="koboSpan" id="kobo.146.3">We use the test to precisely describe how the code will be set up, how it will be called, and what we can expect it to do for us. </span><span class="koboSpan" id="kobo.146.4">Once we get used to doing this outside-in design first, TDD follows very naturally and improves our workflow efficiency in several important ways. </span><span class="koboSpan" id="kobo.146.5">Let’s review what these </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">improvements are.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.148.1">Increasing workflow efficiency</span></h2>
<p><span class="koboSpan" id="kobo.149.1">Unit tests like these increase our </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.150.1">efficiency as developers in several ways. </span><span class="koboSpan" id="kobo.150.2">The most obvious is that the code we write has passed a test: we know it works. </span><span class="koboSpan" id="kobo.150.3">We are not waiting around for a manual QA process to find a defect and then raise a bug report for rework in the future. </span><span class="koboSpan" id="kobo.150.4">We find and fix bugs </span><em class="italic"><span class="koboSpan" id="kobo.151.1">now</span></em><span class="koboSpan" id="kobo.152.1">, before ever releasing them into the main source trunk, let alone to users. </span><span class="koboSpan" id="kobo.152.2">We have documented our intentions for our colleagues. </span><span class="koboSpan" id="kobo.152.3">If anyone wants to know how our </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Username</span></strong><span class="koboSpan" id="kobo.154.1"> class works, it is right there in the test – how you create the object, which methods you can call, and what we expect the outcomes </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Unit tests give us a way to run code in isolation. </span><span class="koboSpan" id="kobo.156.2">We are no longer forced to rebuild a whole application, run it, set up test data entries in our database, log in to the user interface, navigate to the correct screen, and then visually inspect the output of our code. </span><span class="koboSpan" id="kobo.156.3">We run the test. </span><span class="koboSpan" id="kobo.156.4">That’s it. </span><span class="koboSpan" id="kobo.156.5">This allows us to execute code that is not yet fully integrated into our application’s main trunk. </span><span class="koboSpan" id="kobo.156.6">This speeds up our work. </span><span class="koboSpan" id="kobo.156.7">We can get started more quickly, spend more time on developing the code at hand, and spend less time on cumbersome manual testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">deployment processes.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">A further benefit is that this act of design improves the modularity of our code. </span><span class="koboSpan" id="kobo.158.2">By designing code that can be tested in small pieces, we remind ourselves to write code that can execute in small pieces. </span><span class="koboSpan" id="kobo.158.3">That has been the basic approach to design since the 1960s and remains as effective today as it </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">ever was.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">This section has covered the standard structure that we use to organize every unit test but it doesn’t guarantee that we will write a good test. </span><span class="koboSpan" id="kobo.160.2">To achieve this, each test needs to have particular properties. </span><span class="koboSpan" id="kobo.160.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">FIRST</span></strong><span class="koboSpan" id="kobo.162.1"> principles describe the properties of a good test. </span><span class="koboSpan" id="kobo.162.2">Let’s learn how to apply </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">these next.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.164.1">Defining a good test</span></h1>
<p><span class="koboSpan" id="kobo.165.1">Like all code, unit test </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.166.1">code can be written in better or worse ways. </span><span class="koboSpan" id="kobo.166.2">We’ve seen how AAA helps us structure a test correctly and how accurate, descriptive names tell the story of what we intend our code to do. </span><span class="koboSpan" id="kobo.166.3">The most useful tests also follow the FIRST principles and use one assert </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">per test.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.168.1">Applying the FIRST principles</span></h2>
<p><span class="koboSpan" id="kobo.169.1">These are a set</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.170.1"> of five principles that make tests </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">more effective:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.172.1">Fast</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.173.1">Isolated</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.174.1">Repeatable</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.175.1">Self-verifying</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.176.1">Timely</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.177.1">Unit tests need to be </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">fast</span></strong><span class="koboSpan" id="kobo.179.1">, just as our earlier example was. </span><span class="koboSpan" id="kobo.179.2">This is especially important for test-first TDD, as we want that immediate feedback while we explore our design and implementation. </span><span class="koboSpan" id="kobo.179.3">If we run a unit test, and it takes even as little as 15 seconds to complete, we will soon stop</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.180.1"> running tests as often. </span><span class="koboSpan" id="kobo.180.2">We will degenerate into writing big chunks of production code without tests so that we spend less time waiting for slow tests to finish. </span><span class="koboSpan" id="kobo.180.3">This is the exact opposite of what we want from TDD, so we work hard to keep tests fast. </span><span class="koboSpan" id="kobo.180.4">We need unit tests to run in 2 seconds or less, ideally milliseconds. </span><span class="koboSpan" id="kobo.180.5">Even two seconds is really quite a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">high number.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Tests need to be </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">isolated</span></strong><span class="koboSpan" id="kobo.184.1"> from one</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.185.1"> another. </span><span class="koboSpan" id="kobo.185.2">This means that we can pick any test or any combination of tests and run them in any order we like and always get the same result. </span><span class="koboSpan" id="kobo.185.3">One test must not depend on another test having been run before it. </span><span class="koboSpan" id="kobo.185.4">This is often a symptom of failing to write fast tests, so we compensate by caching results or arranging step setups. </span><span class="koboSpan" id="kobo.185.5">This is a mistake, as it slows down development, especially for our colleagues. </span><span class="koboSpan" id="kobo.185.6">The reason is that we don’t know the special order in which the tests must run. </span><span class="koboSpan" id="kobo.185.7">When we run any test on its own, and if it has not been properly isolated, it will fail as a false negative. </span><span class="koboSpan" id="kobo.185.8">That test no longer tells us anything about our code under test. </span><span class="koboSpan" id="kobo.185.9">It only tells us that we have not run some other test before it, without telling us which test that might be. </span><span class="koboSpan" id="kobo.185.10">Isolation is critical to a healthy </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">TDD workflow.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.187.1">Repeatable</span></strong><span class="koboSpan" id="kobo.188.1"> tests are vital to TDD. </span><span class="koboSpan" id="kobo.188.2">Whenever we run a test with the same production code, that test must always return the same</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.189.1"> pass or fail result. </span><span class="koboSpan" id="kobo.189.2">This might sound obvious but care needs to be taken to achieve this. </span><span class="koboSpan" id="kobo.189.3">Think about a test that checks a function that returns a random number between 1 and 10. </span><span class="koboSpan" id="kobo.189.4">If we assert that the number seven is returned, this test will only pass occasionally, even if we have correctly coded the function. </span><span class="koboSpan" id="kobo.189.5">In this regard, three popular sources of misery are tests involving the database, tests against time, and tests through the user interface. </span><span class="koboSpan" id="kobo.189.6">We will explore techniques to handle these situations in </span><a href="B18384_08.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.190.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.191.1">, </span><em class="italic"><span class="koboSpan" id="kobo.192.1">Test Doubles –Stubs </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.193.1">and Mocks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">All tests must be </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">self-verifying</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This means we</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.198.1"> need executable code to run and check whether the outputs are as expected. </span><em class="italic"><span class="koboSpan" id="kobo.199.1">This step must be automated</span></em><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">We must not leave this check to manual inspection, perhaps by writing the output to a console and having a human check it against a test plan. </span><span class="koboSpan" id="kobo.200.3">Unit tests derive huge value from being automated. </span><span class="koboSpan" id="kobo.200.4">The computer checks the production code, freeing us from the tedium of following a test plan, the slowness of human activities, and the likelihood of </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">human error.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.202.1">Timely</span></strong><span class="koboSpan" id="kobo.203.1"> tests are tests </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.204.1">written at just the right time to be most useful. </span><span class="koboSpan" id="kobo.204.2">The ideal time to write a test is just before writing the code that makes that test pass. </span><span class="koboSpan" id="kobo.204.3">It’s not unusual to see teams use less beneficial approaches. </span><span class="koboSpan" id="kobo.204.4">The worst one, of course, is to never write any unit tests and rely on manual</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.205.1"> QA to find bugs. </span><span class="koboSpan" id="kobo.205.2">With this approach, we get none of the design feedback available. </span><span class="koboSpan" id="kobo.205.3">The other extreme is to have an analyst write every test for the component – or even the whole system – upfront, leaving the coding as a mechanical exercise. </span><span class="koboSpan" id="kobo.205.4">This also fails to learn from design feedback. </span><span class="koboSpan" id="kobo.205.5">It can also result in overspecified tests that </span><em class="italic"><span class="koboSpan" id="kobo.206.1">lock in</span></em><span class="koboSpan" id="kobo.207.1"> poor design and implementation choices. </span><span class="koboSpan" id="kobo.207.2">Many teams start by writing some code and then go on to write a unit test, thereby missing out on an opportunity for early design feedback. </span><span class="koboSpan" id="kobo.207.3">It can also lead to untested code and faulty edge </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">case handling.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">We’ve seen how the FIRST principles help us focus on crafting a good test. </span><span class="koboSpan" id="kobo.209.2">Another important principle is not to try to test too much all at once. </span><span class="koboSpan" id="kobo.209.3">If we do, the test becomes very difficult to understand. </span><span class="koboSpan" id="kobo.209.4">A simple solution to this is to write a single assert per test, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">cover next.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.211.1">Using one assert per test</span></h2>
<p><span class="koboSpan" id="kobo.212.1">Tests provide the </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.213.1">most useful feedback when they are short and specific. </span><span class="koboSpan" id="kobo.213.2">They act as a microscope working on the code, each test highlighting one small aspect of our code. </span><span class="koboSpan" id="kobo.213.3">The best way to ensure this happens is by writing one assertion per test. </span><span class="koboSpan" id="kobo.213.4">This prevents us from tackling too much in one test. </span><span class="koboSpan" id="kobo.213.5">This focuses on the error messages we get during test failures and helps us control the complexity of our code. </span><span class="koboSpan" id="kobo.213.6">It forces us to break things down a </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">little further.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.215.1">Deciding on the scope of a unit test</span></h2>
<p><span class="koboSpan" id="kobo.216.1">Another common </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.217.1">misunderstanding is what a </span><em class="italic"><span class="koboSpan" id="kobo.218.1">unit</span></em><span class="koboSpan" id="kobo.219.1"> means in a unit test. </span><span class="koboSpan" id="kobo.219.2">The unit refers to the test isolation itself – each test can be considered a standalone unit. </span><span class="koboSpan" id="kobo.219.3">As a result, the size of the code under test can vary a lot, as long as that test can run </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">in isolation.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Thinking of the test itself as the unit unifies several popular opinions about what the scope of a unit test should be. </span><span class="koboSpan" id="kobo.221.2">Often, it is said that the unit is the smallest piece of testable code – a function, method, class, or package. </span><span class="koboSpan" id="kobo.221.3">All of these are valid options. </span><span class="koboSpan" id="kobo.221.4">Another common argument is that a unit test should be a class test – one unit test class per production code class, with one unit test method per production method. </span><span class="koboSpan" id="kobo.221.5">While common, this isn’t usually the best approach. </span><span class="koboSpan" id="kobo.221.6">It unnecessarily couples the structure of the test to the structure of the implementation, making the code </span><em class="italic"><span class="koboSpan" id="kobo.222.1">harder</span></em><span class="koboSpan" id="kobo.223.1"> to change in the future, </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">not easier.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">The ideal goal of a unit test is to cover one </span><em class="italic"><span class="koboSpan" id="kobo.226.1">externally visible behavior</span></em><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">This applies at several different scales in the code base. </span><span class="koboSpan" id="kobo.227.3">We can unit test an entire user story across multiple packages of classes, provided we can avoid manipulating external systems such as a database or the user interface. </span><span class="koboSpan" id="kobo.227.4">We’ll look into techniques for doing that in </span><a href="B18384_09.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.229.1">, </span><em class="italic"><span class="koboSpan" id="kobo.230.1">Hexagonal Architecture – Decoupling External Systems</span></em><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">We often also use unit tests that are </span><em class="italic"><span class="koboSpan" id="kobo.232.1">closer</span></em><span class="koboSpan" id="kobo.233.1"> to the details of the code, testing only the public methods of a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">single class.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Once we have written our test based on the design that we would like our code to have, we can concentrate on the more obvious aspect of testing: verifying that our code </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">is correct.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.237.1">Catching common errors</span></h1>
<p><span class="koboSpan" id="kobo.238.1">The traditional view of testing is</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.239.1"> of it as a process to check that code works as it is intended to work. </span><span class="koboSpan" id="kobo.239.2">Unit tests excel at this and automate the process of running the code with known inputs and checking for expected outputs. </span><span class="koboSpan" id="kobo.239.3">As we are human, all of us make mistakes from time to time as we write code and some of these can have significant impacts. </span><span class="koboSpan" id="kobo.239.4">There are several common simple mistakes we can make and unit tests excel at catching them all. </span><span class="koboSpan" id="kobo.239.5">The most likely errors are </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.241.1">Off-by-one errors</span></span></li>
<li><span class="koboSpan" id="kobo.242.1">Inverted </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">conditional logic</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Missing conditions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.245.1">Uninitialized data</span></span></li>
<li><span class="koboSpan" id="kobo.246.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">wrong algorithm</span></span></li>
<li><span class="koboSpan" id="kobo.248.1">Broken </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">equality checks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">As an example, going back to our earlier test for a lowercase username, suppose we decided not to implement</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.251.1"> this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">String</span></strong><span class="koboSpan" id="kobo.253.1"> built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">.toLowerCase()</span></strong><span class="koboSpan" id="kobo.255.1"> method, but instead tried to roll our own loop code, </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
public class Username {
    private final String name;
    public Username(String username) {
        name = username;
    }
    public String asLowerCase() {
        var result = new StringBuilder();
</span><strong class="bold"><span class="koboSpan" id="kobo.258.1">        for (int i=1; i &lt; name.length(); i++) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.259.1">            char current = name.charAt(i);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.260.1">            if (current &gt; 'A' &amp;&amp; current &lt; 'Z') {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.261.1">                result.append(current + 'a' - 'A');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.262.1">            } else {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.263.1">                result.append( current );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.264.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.265.1">        }</span></strong><span class="koboSpan" id="kobo.266.1">
        return result.toString() ;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.267.1">We would see right away </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.268.1">that this code isn’t correct. </span><span class="koboSpan" id="kobo.268.2">The test fails, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.270.1"><img alt="Figure 5.3 – A common coding error" src="image/Figure_5.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Figure 5.3 – A common coding error</span></p>
<p><span class="koboSpan" id="kobo.272.1">The first error in this code is a simple off-by-one error – the first letter is missing from the output. </span><span class="koboSpan" id="kobo.272.2">That points to an error in initializing our loop index but there are other errors in this code as well. </span><span class="koboSpan" id="kobo.272.3">This test reveals two defects. </span><span class="koboSpan" id="kobo.272.4">Further tests would reveal two more. </span><span class="koboSpan" id="kobo.272.5">Can you see what they are by visual inspection alone? </span><span class="koboSpan" id="kobo.272.6">How much more time and effort is it to analyze code like this in our heads, rather than using </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">automated tests?</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.274.1">Asserting exceptions</span></h1>
<p><span class="koboSpan" id="kobo.275.1">One area where unit tests excel is in</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.276.1"> testing error handling code. </span><span class="koboSpan" id="kobo.276.2">As an example of testing </span><em class="italic"><span class="koboSpan" id="kobo.277.1">exception throwing</span></em><span class="koboSpan" id="kobo.278.1">, let’s add a business requirement that our usernames must be at least four characters long. </span><span class="koboSpan" id="kobo.278.2">We think about the design we want and decide to throw a custom exception if the name is too short. </span><span class="koboSpan" id="kobo.278.3">We decide to represent this custom exception as </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">class InvalidNameException</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">Here’s what the test looks like, </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">using AssertJ:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
@Test
public void rejectsShortName() {
    assertThatExceptionOfType(InvalidNameException.class)
            .isThrownBy(()-&gt;new Username("Abc"));
}</span></pre>
<p><span class="koboSpan" id="kobo.283.1">We can consider adding another test specifically aimed at proving that a name of four characters is accepted and no exception </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">is thrown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
@Test
public void acceptsMinimumLengthName() {
    assertThatNoException()
            .isThrownBy(()-&gt;new Username("Abcd"));
}</span></pre>
<p><span class="koboSpan" id="kobo.286.1">Alternatively, we may simply decide that this explicit test is not needed. </span><span class="koboSpan" id="kobo.286.2">We may cover it implicitly with other tests. </span><span class="koboSpan" id="kobo.286.3">It is a good practice to add both tests to make our </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">intentions clear.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">The test names are fairly general, starting with either </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">rejects</span></strong><span class="koboSpan" id="kobo.290.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">accepts</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">They describe the outcome </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.293.1">that the code is being tested for. </span><span class="koboSpan" id="kobo.293.2">This allows us to change our minds about the error handling mechanics later, perhaps switching to something other than exceptions to signal </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Unit tests can catch common programming errors and verify error handling logic. </span><span class="koboSpan" id="kobo.295.2">Let’s look at a major principle of writing our unit tests to give us maximum flexibility when implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">our methods.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.297.1">Only testing public methods</span></h1>
<p><span class="koboSpan" id="kobo.298.1">TDD is all about testing </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.299.1">the behaviors of components, not their implementations. </span><span class="koboSpan" id="kobo.299.2">As we have seen in our test in the previous section, having a test for the behavior we want enables us to choose any implementation that will do the job. </span><span class="koboSpan" id="kobo.299.3">We focus on what’s important – </span><em class="italic"><span class="koboSpan" id="kobo.300.1">what</span></em><span class="koboSpan" id="kobo.301.1"> a component does – not on the less important details – </span><em class="italic"><span class="koboSpan" id="kobo.302.1">how</span></em><span class="koboSpan" id="kobo.303.1"> it </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">does it.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Inside a test, this appears as calling public methods or functions on public classes and packages. </span><span class="koboSpan" id="kobo.305.2">The public methods are the behaviors we choose to expose to the wider application. </span><span class="koboSpan" id="kobo.305.3">Any private data or supporting code in classes, methods, or functions </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">remain hidden.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">A common mistake that developers make when learning TDD is that they make things public just to simplify testing. </span><span class="koboSpan" id="kobo.307.2">Resist the temptation. </span><span class="koboSpan" id="kobo.307.3">A typical mistake here is to take a private data field and</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.308.1"> expose it for testing using a public getter method. </span><span class="koboSpan" id="kobo.308.2">This weakens the encapsulation of that class. </span><span class="koboSpan" id="kobo.308.3">It is now more likely that the getter will be misused. </span><span class="koboSpan" id="kobo.308.4">Future developers may add methods to other classes that really belong in this one. </span><span class="koboSpan" id="kobo.308.5">The design of our production code is important. </span><span class="koboSpan" id="kobo.308.6">Fortunately, there is a simple way of preserving encapsulation without </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">compromising testing.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.310.1">Preserving encapsulation</span></h2>
<p><span class="koboSpan" id="kobo.311.1">If we feel we need to</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.312.1"> add getters to all our private data so that the test can check that each one is as expected, it is often better to treat this as a </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">value object</span></strong><span class="koboSpan" id="kobo.314.1">. </span><span class="koboSpan" id="kobo.314.2">A value</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.315.1"> object is an object that lacks identity. </span><span class="koboSpan" id="kobo.315.2">Any two value objects that contain the same data are considered to be equal. </span><span class="koboSpan" id="kobo.315.3">Using value objects, we can make another object containing the same private data and then test that the two objects </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">are equal.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">In Java, this requires us to code a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">equals()</span></strong><span class="koboSpan" id="kobo.319.1"> method for our class. </span><span class="koboSpan" id="kobo.319.2">If we do this, we should also code a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">hashcode()</span></strong><span class="koboSpan" id="kobo.321.1"> method, as the two go hand in hand. </span><span class="koboSpan" id="kobo.321.2">Any implementation that works will do. </span><span class="koboSpan" id="kobo.321.3">I recommend using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Apache commons3</span></strong><span class="koboSpan" id="kobo.323.1"> library, which uses Java reflection capabilities to </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
@Override
public boolean equals(Object other) {
    return EqualsBuilder.reflectionEquals(this, other);
}
@Override
public int hashCode() {
    return HashCodeBuilder.reflectionHashCode(this);
}</span></pre>
<p><span class="koboSpan" id="kobo.326.1">You can find out more about these library methods </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">at </span></span><a href="https://commons.apache.org/proper/commons-lang/"><span class="No-Break"><span class="koboSpan" id="kobo.328.1">https://commons.apache.org/proper/commons-lang/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.329.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Simply adding those two methods (and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Apache commons3</span></strong><span class="koboSpan" id="kobo.332.1"> library) to our class means that we can keep all our data fields private and still check that all the fields have the expected data in</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.333.1"> them. </span><span class="koboSpan" id="kobo.333.2">We simply create a new object with all the expected fields, then assert that it is equal to the object we </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">are testing.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">As we write each test, we are using the code under test for the first time. </span><span class="koboSpan" id="kobo.335.2">This allows us to learn a lot about how easy our code is to use, allowing us to make changes if we </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">need to.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.337.1">Learning from our tests</span></h1>
<p><span class="koboSpan" id="kobo.338.1">Our tests are a rich source of </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.339.1">feedback on our design. </span><span class="koboSpan" id="kobo.339.2">As we make decisions, we write them as test code. </span><span class="koboSpan" id="kobo.339.3">Seeing this code – the first usage of our production code – brings into sharp focus how good our proposed design is. </span><span class="koboSpan" id="kobo.339.4">When our design isn’t good, the AAA sections of our test will reveal those design issues as code smells in the test. </span><span class="koboSpan" id="kobo.339.5">Let’s try to understand in detail how each of these can help identify a </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">faulty design.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.341.1">A messy Arrange step</span></h2>
<p><span class="koboSpan" id="kobo.342.1">If the code in our Arrange step is </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.343.1">messy, our object may be difficult to create and configure. </span><span class="koboSpan" id="kobo.343.2">It may need too many parameters in a constructor or too many optional parameters left as </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">null</span></strong><span class="koboSpan" id="kobo.345.1"> in the test. </span><span class="koboSpan" id="kobo.345.2">It may be that the object needs too many dependencies injected, indicating that it has too many responsibilities or it might need too many primitive data parameters to pass in a lot of configuration items. </span><span class="koboSpan" id="kobo.345.3">These are signals that the way we create our object might benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">a redesign.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.347.1">A messy Act step</span></h2>
<p><span class="koboSpan" id="kobo.348.1">Calling the main part</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.349.1"> of the code in the Act step is usually straightforward but it can reveal some basic design errors. </span><span class="koboSpan" id="kobo.349.2">For example, we might have unclear parameters that we pass in, signatures such as a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Boolean</span></strong><span class="koboSpan" id="kobo.351.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">String</span></strong><span class="koboSpan" id="kobo.353.1"> objects. </span><span class="koboSpan" id="kobo.353.2">It is very hard to know what each one means. </span><span class="koboSpan" id="kobo.353.3">We could redesign this by wrapping those difficult parameters in an easy-to-understand new class, called a </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">configuration object</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">Another</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.356.1"> possible problem is if the Act step requires multiple calls to be made in a specific order. </span><span class="koboSpan" id="kobo.356.2">That is error-prone. </span><span class="koboSpan" id="kobo.356.3">It is easy to call them in the wrong order or forget one of the calls. </span><span class="koboSpan" id="kobo.356.4">We could redesign to use a single method that wraps all of </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">this detail.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.358.1">A messy Assert step</span></h2>
<p><span class="koboSpan" id="kobo.359.1">The Assert step will reveal whether the results of our code are difficult to use. </span><span class="koboSpan" id="kobo.359.2">Problem areas might include having to</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.360.1"> call accessors in a specific order or perhaps returning some conventional code smells, such as an array of results where every index has a different meaning. </span><span class="koboSpan" id="kobo.360.2">We can redesign to use safer constructs in </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">either case.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">In each of these cases, one of the sections of code in our unit test looks wrong – it has a code smell. </span><span class="koboSpan" id="kobo.362.2">That is because the design of the code we are testing has the same code smell. </span><span class="koboSpan" id="kobo.362.3">This is what is meant by unit tests giving fast feedback on design. </span><span class="koboSpan" id="kobo.362.4">They are the first user of the code we are writing, so we can identify problem areas </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">early on.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">We now have all the techniques we need to start writing our first test for our example application. </span><span class="koboSpan" id="kobo.364.2">Let’s make </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">a start.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.366.1">Limitations of unit tests</span></h2>
<p><span class="koboSpan" id="kobo.367.1">One very important idea is</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.368.1"> that an automated test can only prove the presence of a defect, not the absence. </span><span class="koboSpan" id="kobo.368.2">What this means is that if we think of a boundary condition, write a test for that, and the test fails, we know we have a defect in our logic. </span><span class="koboSpan" id="kobo.368.3">However, if all our tests pass, that </span><em class="italic"><span class="koboSpan" id="kobo.369.1">does not and cannot</span></em><span class="koboSpan" id="kobo.370.1"> mean our code is free of defects. </span><span class="koboSpan" id="kobo.370.2">It only means that our code is free of all the defects that we have thought to test for. </span><span class="koboSpan" id="kobo.370.3">There simply is no magic solution that can ensure our code is defect-free. </span><span class="koboSpan" id="kobo.370.4">TDD gives us a significant boost in that direction but we must never claim our code is defect-free just because all our tests pass. </span><span class="koboSpan" id="kobo.370.5">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">simply untrue.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">One important consequence of this is that our QA engineering colleagues remain as important as they ever were,  although we now help them start from an easier standing point. </span><span class="koboSpan" id="kobo.372.2">We can deliver TDD-tested code to our manual QA colleagues, and they can be assured that many defects have been prevented and proven to be absent. </span><span class="koboSpan" id="kobo.372.3">This means that they can start work on manual exploratory testing, finding all the things we never thought to test. </span><span class="koboSpan" id="kobo.372.4">Working together, we can use their defect reports to write further unit tests to rectify what they find. </span><span class="koboSpan" id="kobo.372.5">The contribution of QA engineers remains vital, even with TDD. </span><span class="koboSpan" id="kobo.372.6">We need all the help our team can get in our efforts to write </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">high-quality software.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.374.1">Code coverage – an often-meaningless metric</span></h2>
<p><span class="koboSpan" id="kobo.375.1">Code coverage is a </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.376.1">measure of how many lines of code have been executed in a given run. </span><span class="koboSpan" id="kobo.376.2">It is measured by instrumenting the code and this is something that a code coverage tool will do for us. </span><span class="koboSpan" id="kobo.376.3">It is often used in conjunction with unit testing to measure how many lines of code were executed while running the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">test suite.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">In theory, you can see how this might mean that missing tests can be discovered in a scientific way. </span><span class="koboSpan" id="kobo.378.2">If we see that a line of code was not run, we must have a missing test somewhere. </span><span class="koboSpan" id="kobo.378.3">That is both true and helpful but the converse is not true. </span><span class="koboSpan" id="kobo.378.4">Suppose we get 100% code coverage during our test run. </span><span class="koboSpan" id="kobo.378.5">Does that mean the software is now completely tested and </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">correct? </span><span class="koboSpan" id="kobo.379.2">No.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Consider having a single test for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">if (x &lt; 2)</span></strong><span class="koboSpan" id="kobo.382.1"> statement. </span><span class="koboSpan" id="kobo.382.2">We can write a test that will cause this line to execute and be included in code coverage reports. </span><span class="koboSpan" id="kobo.382.3">However, a single test is not enough to cover all the possibilities of behavior. </span><span class="koboSpan" id="kobo.382.4">The conditional statement might have the wrong operator – less than instead of less than or equal to. </span><span class="koboSpan" id="kobo.382.5">It might have the incorrect limit of 2 when it should be 20. </span><span class="koboSpan" id="kobo.382.6">Any single test cannot fully explore the combinations of behavior in that statement. </span><span class="koboSpan" id="kobo.382.7">We can have code coverage tell us that the line has been run and that our single test passed but we can still have several logic errors remaining. </span><span class="koboSpan" id="kobo.382.8">We can have 100% code coverage and still have </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">missing tests.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.384.1">Writing the wrong tests</span></h2>
<p><span class="koboSpan" id="kobo.385.1">Time for a short </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.386.1">personal story about how my best attempt at TDD went spectacularly wrong. </span><span class="koboSpan" id="kobo.386.2">In a mobile application that calculated personal tax reports, there was a particular yes/no checkbox in the app to indicate whether you had a student loan or not, since this affects the tax you pay. </span><span class="koboSpan" id="kobo.386.3">It had six consequences in our application and I thoroughly TDD tested each one, carefully writing my </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">tests first.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Sadly, I had misread the user story. </span><span class="koboSpan" id="kobo.388.2">I had inverted every single test. </span><span class="koboSpan" id="kobo.388.3">Where the checkbox should apply the relevant tax, it now did not apply it, and </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">This was thankfully picked up by our QA engineer. </span><span class="koboSpan" id="kobo.390.2">Her only comment was that she could find absolutely no workaround in the system for this defect. </span><span class="koboSpan" id="kobo.390.3">We concluded that TDD had done an excellent job of making the code do what I wanted it to do but I had done a rather less excellent job of figuring out what that should be. </span><span class="koboSpan" id="kobo.390.4">At least it was a very quick fix </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">and retest.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.392.1">Beginning Wordz</span></h1>
<p><span class="koboSpan" id="kobo.393.1">Let’s apply these ideas to </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.394.1">our Wordz application. </span><span class="koboSpan" id="kobo.394.2">We’re going to start with a class that will contain the core of our application logic, one that represents a word to guess and that can work out the score for </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">a guess.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">We begin by creating a unit test class and this immediately puts us into software design mode: what should we call the test? </span><span class="koboSpan" id="kobo.396.2">We’ll go with </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">WordTest</span></strong><span class="koboSpan" id="kobo.398.1">, as that outlines the area we want to cover – the word to </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">be guessed.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Typical Java project structures are divided into packages. </span><span class="koboSpan" id="kobo.400.2">The production code lives under </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">src/main/java</span></strong><span class="koboSpan" id="kobo.402.1"> and the test code is located under </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">src/test/java</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">This structure describes how production and test code are equally important parts of the source code, while giving us a way to compile and deploy only the production code. </span><span class="koboSpan" id="kobo.404.3">We always ship test code with the production code when we are dealing with source code, but for deployed executables, we only omit the tests. </span><span class="koboSpan" id="kobo.404.4">We will also follow the basic Java package convention of having a unique name for our company or project at the top level. </span><span class="koboSpan" id="kobo.404.5">This helps avoid clashes with library code. </span><span class="koboSpan" id="kobo.404.6">We’ll call ours </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">com.wordz</span></strong><span class="koboSpan" id="kobo.406.1">, named after </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">The next design step is to decide which behavior to drive out and test first. </span><span class="koboSpan" id="kobo.408.2">We always want a simple version of a happy path, something that will help drive out the normal logic that will most commonly execute. </span><span class="koboSpan" id="kobo.408.3">We can cover edge cases and error conditions later. </span><span class="koboSpan" id="kobo.408.4">To begin with, let’s write a test that will return the score for a single letter that </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">is incorrect:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.410.1">Write the following code to begin </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">our test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
public class WordTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.413.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
    public void oneIncorrectLetter() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.417.1">The name of the test gives us an overview of what the test </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">is doing.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.419.1">To start our design, we decide to use a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Word</span></strong><span class="koboSpan" id="kobo.421.1"> to represent our word. </span><span class="koboSpan" id="kobo.421.2">We also decide to supply the word to guess as a constructor parameter to our object instance of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Word</span></strong><span class="koboSpan" id="kobo.423.1"> we want to create. </span><span class="koboSpan" id="kobo.423.2">We code these design decisions into </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.425.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.426.1">
public void oneIncorrectLetter () {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.427.1">
    new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.429.1">We use</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.430.1"> autocomplete at this point to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Word</span></strong><span class="koboSpan" id="kobo.432.1"> class in its own file. </span><span class="koboSpan" id="kobo.432.2">Double-check in </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">src/main folder tree</span></strong><span class="koboSpan" id="kobo.434.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">src/test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.438.1"><img alt="Figure 5.4 – Creating a class dialog" src="image/Figure_5.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.439.1">Figure 5.4 – Creating a class dialog</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.440.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">OK</span></strong><span class="koboSpan" id="kobo.442.1"> to create the file in the source tree inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">right package.</span></span></li>
<li><span class="koboSpan" id="kobo.444.1">Now, we rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Word</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.446.1">constructor parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
public class Word {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
    public Word(String correctWord) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.449.1">
  // No Action</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.452.1">Next, we return to the test. </span><span class="koboSpan" id="kobo.452.2">We capture the new object as a local variable so that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">test it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.454.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
public void oneIncorrectLetter () {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
    var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.458.1">The next design step is to think of a way to pass a guess into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Word</span></strong><span class="koboSpan" id="kobo.460.1"> class and return </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">a score.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.462.1">Passing the </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.463.1">guess in is an easy decision – we’ll use a method that we’ll call </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">guess()</span></strong><span class="koboSpan" id="kobo.465.1">. </span><span class="koboSpan" id="kobo.465.2">We can code these decisions into </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.468.1">
public void oneIncorrectLetter () {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
    var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    word.guess("Z");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.472.1">Use autocomplete to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">guess()</span></strong><span class="koboSpan" id="kobo.474.1"> method to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Word</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.476.1"> class:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.477.1"><img alt="Figure 5.5 – Creating the Word class" src="image/Figure_5.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.478.1">Figure 5.5 – Creating the Word class</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.479.1">Click </span><em class="italic"><span class="koboSpan" id="kobo.480.1">Enter</span></em><span class="koboSpan" id="kobo.481.1"> to add the</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.482.1"> method, then change the parameter name to a </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">descriptive name:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
public void guess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.485.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.486.1">Next, let’s add a way to get the resulting score from that guess. </span><span class="koboSpan" id="kobo.486.2">Start with </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">the test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.488.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
public void oneIncorrectLetter () {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.490.1">
    var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
    var score = word.guess("Z");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.493.1">Then, we need a little think about what to return from the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">production code.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">We probably want an object of some sort. </span><span class="koboSpan" id="kobo.495.2">This object must represent the score from that guess. </span><span class="koboSpan" id="kobo.495.3">Because our current user story is about the scores for a five-letter word and the details of each letter, we must return one of </span><em class="italic"><span class="koboSpan" id="kobo.496.1">exactly right</span></em><span class="koboSpan" id="kobo.497.1">, </span><em class="italic"><span class="koboSpan" id="kobo.498.1">right letter</span></em><span class="koboSpan" id="kobo.499.1">, </span><em class="italic"><span class="koboSpan" id="kobo.500.1">wrong place</span></em><span class="koboSpan" id="kobo.501.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.502.1">letter </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.503.1">not present</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">There are several ways to do this </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.506.1">and now is the time to stop and think about them. </span><span class="koboSpan" id="kobo.506.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">viable approaches:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.508.1">A class with five getters, each one returning </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">enum</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.512.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Java 17</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.514.1">record</span></strong><span class="koboSpan" id="kobo.515.1"> type with the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">same getters.</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">A class with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">iterator</span></strong><span class="koboSpan" id="kobo.519.1"> method, which iterates over five </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">enum</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1"> constants.</span></span></li>
<li><span class="koboSpan" id="kobo.522.1">A class with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">iterator</span></strong><span class="koboSpan" id="kobo.524.1"> method that returns one interface for each letter score. </span><span class="koboSpan" id="kobo.524.2">The scoring code would implement a concrete class for each type of score. </span><span class="koboSpan" id="kobo.524.3">This would be a purely object-oriented way of adding a </span><em class="italic"><span class="koboSpan" id="kobo.525.1">callback</span></em><span class="koboSpan" id="kobo.526.1"> for each </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">possible outcome.</span></span></li>
<li><span class="koboSpan" id="kobo.528.1">A class that iterated over results for each letter and you passed in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Java 8 lambda</span></strong><span class="koboSpan" id="kobo.530.1"> function for each of the outcomes. </span><span class="koboSpan" id="kobo.530.2">The correct one would be called as a callback for </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">each letter.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.532.1">That’s already a lot of design options. </span><span class="koboSpan" id="kobo.532.2">The key part of TDD is that we are considering this </span><em class="italic"><span class="koboSpan" id="kobo.533.1">now</span></em><span class="koboSpan" id="kobo.534.1"> before we write any production code. </span><span class="koboSpan" id="kobo.534.2">To help us decide, let’s sketch out what the calling code will look like. </span><span class="koboSpan" id="kobo.534.3">We need to consider plausible extensions to the code – will we need more or fewer than five letters in a word? </span><span class="koboSpan" id="kobo.534.4">Would the scoring rules ever change? </span><span class="koboSpan" id="kobo.534.5">Should we care about any of those things </span><em class="italic"><span class="koboSpan" id="kobo.535.1">right now</span></em><span class="koboSpan" id="kobo.536.1">? </span><span class="koboSpan" id="kobo.536.2">Would the people reading this code in the future more easily grasp any one of these ideas than the others? </span><span class="koboSpan" id="kobo.536.3">TDD gives us fast feedback on our design decisions and that forces us to take a design workout </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">right now.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">One overriding decision is that we will not return the colors that each letter should have. </span><span class="koboSpan" id="kobo.538.2">That will be a UI code decision. </span><span class="koboSpan" id="kobo.538.3">For this core domain logic, we will return only the fact that the letter is </span><em class="italic"><span class="koboSpan" id="kobo.539.1">correct</span></em><span class="koboSpan" id="kobo.540.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.541.1">wrong position</span></em><span class="koboSpan" id="kobo.542.1">, or </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.543.1">not present</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">It’s easy enough with TDD to sketch out the calling code because it </span><em class="italic"><span class="koboSpan" id="kobo.546.1">is</span></em><span class="koboSpan" id="kobo.547.1"> the test code itself. </span><span class="koboSpan" id="kobo.547.2">After about 15 minutes of pondering what to do, here are the three design decisions we will use in </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">this code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.549.1">Supporting a variable number of letters in </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">a word</span></span></li>
<li><span class="koboSpan" id="kobo.551.1">Representing the score using a simple enum of </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">INCORRECT</span></strong><span class="koboSpan" id="kobo.553.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">PART_CORRECT</span></strong><span class="koboSpan" id="kobo.555.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">CORRECT</span></strong></span></li>
<li><span class="koboSpan" id="kobo.558.1">Accessing each score by its position in the </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">word, zero-based</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.560.1">These decisions </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.561.1">support the </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">KISS</span></strong><span class="koboSpan" id="kobo.563.1"> principle, usually termed </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">keep it simple, stupid</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">The decision to support a variable number of letters does make me wonder whether I’ve overstepped another principle – </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">YAGNI</span></strong><span class="koboSpan" id="kobo.567.1"> – or </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">you ain’t gonna need it</span></strong><span class="koboSpan" id="kobo.569.1">. </span><span class="koboSpan" id="kobo.569.2">In this case, I’m convincing myself that it’s not too much of a speculative design and that the</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.570.1"> readability of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">score</span></strong><span class="koboSpan" id="kobo.572.1"> object will </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.573.1">make up for that. </span><span class="koboSpan" id="kobo.573.2">Let’s move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">the design:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.575.1">Capture these decisions in </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">the test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.578.1">
public void oneIncorrectLetter() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
    var word = new Word("A");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
    var score = word.guess("Z");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
    var result = score.letter(0);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
    assertThat(result).isEqualTo(Letter.INCORRECT);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.584.1">We can see how this test has locked in those design decisions about how we will use our objects. </span><span class="koboSpan" id="kobo.584.2">It says </span><em class="italic"><span class="koboSpan" id="kobo.585.1">nothing at all</span></em><span class="koboSpan" id="kobo.586.1"> about how we will implement those methods internally. </span><em class="italic"><span class="koboSpan" id="kobo.587.1">This is critical to effective TDD</span></em><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">We have also captured and documented all the design decisions in this test. </span><span class="koboSpan" id="kobo.588.3">Creating an </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">executable specification</span></strong><span class="koboSpan" id="kobo.590.1"> such as this is an important benefit </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">of TDD.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.592.1">Now, run this test. </span><span class="koboSpan" id="kobo.592.2">Watch it fail. </span><span class="koboSpan" id="kobo.592.3">This is a surprisingly </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">important step.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.594.1">We might think at first that we only ever want to see passing tests. </span><span class="koboSpan" id="kobo.594.2">This is not totally true. </span><span class="koboSpan" id="kobo.594.3">Part of the work in TDD is having confidence that your tests are working. </span><span class="koboSpan" id="kobo.594.4">Seeing a test fail when we know we have not written the code to make it pass yet gives us confidence that our test is probably checking the </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">right things.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.596.1">Let’s make that test pass, by </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.597.1">adding code to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">class Word</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
public class Word {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
    public Word(String correctWord) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
        // Not Implemented</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.603.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
    public Score guess(String attempt) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.605.1">
        var score = new Score();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
        return score;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.607.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.609.1">Next, create </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">class Score</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.612.1">
public class Score {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.613.1">
    public Letter letter(int position) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.614.1">
        return Letter.INCORRECT;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.616.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.617.1">Again, we used IDE shortcuts to do most of the work in writing that code for us. </span><span class="koboSpan" id="kobo.617.2">The </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">test passes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.619.1"><img alt="Figure 5.6 – A test passing in IntelliJ" src="image/Figure_5.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.620.1">Figure 5.6 – A test passing in IntelliJ</span></p>
<p><span class="koboSpan" id="kobo.621.1">We can see that the test passed and that it took 0.139 seconds to run. </span><span class="koboSpan" id="kobo.621.2">That certainly beats any </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">manual test.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">We also have a repeatable </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.624.1">test, which we can run for the remainder of the project life cycle. </span><span class="koboSpan" id="kobo.624.2">The time saving compared to manual testing will add up every time we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">test suite.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">You will notice that although the test passes, the code seems like it is cheating. </span><span class="koboSpan" id="kobo.626.2">The test only ever expects </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Letter.INCORRECT</span></strong><span class="koboSpan" id="kobo.628.1"> and the code is hardcoded to always return that. </span><span class="koboSpan" id="kobo.628.2">It clearly could never possibly work for any other values! </span><span class="koboSpan" id="kobo.628.3">This is expected at this stage. </span><span class="koboSpan" id="kobo.628.4">Our first test has set out a rough design for the interface of our code. </span><span class="koboSpan" id="kobo.628.5">It has not yet begun to drive out the full implementation. </span><span class="koboSpan" id="kobo.628.6">We will do that with our subsequent tests. </span><span class="koboSpan" id="kobo.628.7">This process is called </span><em class="italic"><span class="koboSpan" id="kobo.629.1">triangulation</span></em><span class="koboSpan" id="kobo.630.1">, where we</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.631.1"> rely on adding tests to drive out the missing implementation details. </span><span class="koboSpan" id="kobo.631.2">By doing this, all our code is covered by tests. </span><span class="koboSpan" id="kobo.631.3">We get 100% </span><em class="italic"><span class="koboSpan" id="kobo.632.1">meaningful</span></em><span class="koboSpan" id="kobo.633.1"> code coverage for free. </span><span class="koboSpan" id="kobo.633.2">More importantly, it breaks our work down into smaller chunks, creates progress with frequent deliverables, and can lead to some </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">interesting solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Another thing to notice is that our one test led us to create two classes, covered by that one test. </span><span class="koboSpan" id="kobo.635.2">This is highly recommended. </span><span class="koboSpan" id="kobo.635.3">Remember that our unit test covers a behavior, not any specific implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">that behavior.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.637.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.638.1">We’ve taken our first steps into TDD and learned about the AAA structure of each test. </span><span class="koboSpan" id="kobo.638.2">We’ve seen how it is possible to design our software and write our test before our production code and get cleaner, more modular designs as a result. </span><span class="koboSpan" id="kobo.638.3">We learned what makes for a good test and learned some common techniques used to catch common programming errors and test code that </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">throws exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">It is important to understand the flow of using AAA sections inside our FIRST tests, as this gives us a template we can reliably follow. </span><span class="koboSpan" id="kobo.640.2">It is also important to understand the flow of design ideas, as used in the previous Wordz example. </span><span class="koboSpan" id="kobo.640.3">Writing our tests is literally taking the design decisions we make and capturing them in unit test code. </span><span class="koboSpan" id="kobo.640.4">This provides fast feedback on how clean our design is, as well as providing an executable specification for future readers of </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">In the next chapter, we will add tests and drive out a complete implementation for our word-scoring object. </span><span class="koboSpan" id="kobo.642.2">We will see how TDD has a rhythm that drives work forward. </span><span class="koboSpan" id="kobo.642.3">We will use the </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Red, Green, Refactor</span></strong><span class="koboSpan" id="kobo.644.1"> approach to keep refining our code and keep both code and tests clean without </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">overengineering them.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.646.1">Questions and answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.647.1">How do we know what test to write if we have no code </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">to test?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.649.1">We reframe this thinking. </span><span class="koboSpan" id="kobo.649.2">Tests help us design a small section of code upfront. </span><span class="koboSpan" id="kobo.649.3">We decide what interface we want for this code and then capture these decisions in the AAA steps of a unit test. </span><span class="koboSpan" id="kobo.649.4">We write just enough code to make the test compile, and then just enough to make the test run and fail. </span><span class="koboSpan" id="kobo.649.5">At this point, we have an executable specification for our code to guide us as we go on to write the </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">production code.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.651.1">Must we stick to one test class per </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">production class?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.653.1">No, and this is a common misunderstanding when using unit tests. </span><span class="koboSpan" id="kobo.653.2">The goal of each test is to specify and run a behavior. </span><span class="koboSpan" id="kobo.653.3">This behavior will be implemented in some way using code – functions, classes, objects, library calls, and the like – but this test in no way constrains how the behavior is implemented. </span><span class="koboSpan" id="kobo.653.4">Some unit tests test only one function. </span><span class="koboSpan" id="kobo.653.5">Some have one test per public method per class. </span><span class="koboSpan" id="kobo.653.6">Others, like in our worked example, give rise to more than one class to satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the test.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.655.1">Do we always use the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">AAA structure?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.657.1">It’s a useful recommendation to start out that way but we sometimes find that we can omit or collapse a step and improve the readability of a test. </span><span class="koboSpan" id="kobo.657.2">We might omit the Arrange step, if we had nothing to create for, say, a static method. </span><span class="koboSpan" id="kobo.657.3">We may collapse the Act step into the Assert step for a simple method call to make the test more readable. </span><span class="koboSpan" id="kobo.657.4">We can factor our common Arrange step code into a </span><em class="italic"><span class="koboSpan" id="kobo.658.1">JUnit</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.659.1">@BeforeEach</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.660.1">annotate method.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.661.1">Are tests </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">throwaway code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.663.1">No. </span><span class="koboSpan" id="kobo.663.2">They are treated with the same importance and care as production code. </span><span class="koboSpan" id="kobo.663.3">The test code is kept clean just as the production code is kept clean. </span><span class="koboSpan" id="kobo.663.4">The readability of our test code is paramount. </span><span class="koboSpan" id="kobo.663.5">We must be able to skim-read a test and quickly see why it exists and what it does. </span><span class="koboSpan" id="kobo.663.6">The test code is not deployed in production but that does not make it any </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">less important.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer038">
</div>
</div>
</body></html>