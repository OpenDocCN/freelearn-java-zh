- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records and Record Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 19 problems that cover, in detail, the Java records introduced
    in JDK 16 (JEP 395), and record patterns introduced as a preview feature in JDK
    19 (JEP 405), as a second preview feature in JDK 20 (JEP 432), and as a final
    feature in JDK 21 (JEP 440).
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a simple Java record. We continue by analyzing a record’s
    internals, what it can and cannot contain, how to use records in streams, how
    they improve serialization, and so on. We are also interested in how we can use
    records in Spring Boot applications, including JPA and jOOQ technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we focus on record patterns for `instanceof` and `switch`. We will talk
    about nested record patterns, guarded record patterns, handling `null` values
    in record patterns, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll have mastered Java records. This is great
    because records are a must-have for any Java developer who wants to adopt the
    coolest Java features.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your programming prowess on Java records.
    I strongly encourage you to give each problem a try before you turn to the solutions
    and download the example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring a Java record**: Write an application that exemplifies the creation
    of a Java record. Moreover, provide a short description of the artifacts generated
    by the compiler for a record behind the scenes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the canonical and compact constructors for records**: Explain
    the role of the built-in record’s canonical and compact constructors. Provide
    examples of when it makes sense to provide such explicit constructors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding more artifacts in a record**: Provide a meaningful list of examples
    about adding explicit artifacts in Java records (for instance, adding instance
    methods, static artifacts, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterating what we cannot have in a record**: Exemplify what we cannot have
    in a record (for instance, we cannot have explicit `private` fields) and explain
    why.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Defining multiple constructors in a record**: Exemplify several approaches
    for declaring multiple constructors in a record.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing interfaces in records**: Write a program that shows how to implement
    interfaces in records.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Understanding record serialization**: Explain in detail and exemplify how
    record serialization works behind the scenes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoking the canonical constructor via reflection**: Write a program that
    exemplifies how to invoke, via reflection, the canonical constructor of a record.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using records in streams**: Write several examples to highlight the usage
    of records for simplifying functional expressions relying on the Stream API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing record patterns for instanceof**: Write a bunch of examples that
    introduce *record patterns* for `instanceof`, including *nested record patterns*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing record patterns for switch**: Write a bunch of examples that
    introduce *record patterns* for `switch`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling guarded record patterns**: Write several snippets of code to exemplify
    *guarded record patterns* (guarded conditions based on the binding variables).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using generic records in record patterns**: Write an application that highlights
    the declaration and usage of generic records.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling nulls in nested record patterns**: Explain and exemplify how to
    deal with `null` values in record patterns (explain the edge case of `null` values
    in nested record patterns as well).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simplifying expressions via record patterns**: Imagine that you have an expression
    (arithmetic, string-based, Abstract Syntax Tree (AST), and so on). Write a program
    that uses record patterns to simplify the code for evaluating/transforming this
    expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hooking unnamed patterns and variables:** Explain and exemplify the JDK 21
    preview feature covering unnamed patterns and variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling records in Spring Boot**: Write several applications for exemplifying
    different use cases of records in Spring Boot (for instance, using records in
    templates, using records for configurations, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling records in JPA**: Write several applications for exemplifying different
    use cases of records in JPA (for instance, using records and constructor expressions,
    using records and result transformers, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tacking records in jOOQ**: Write several applications for exemplifying different
    use cases of records in jOOQ (for instance, using records and the `MULTISET` operator).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 88\. Declaring a Java record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into Java records, let’s think a little bit about how we commonly
    hold data within a Java application. You’re right … we define simple classes containing
    the needed instance fields populated with our data via the constructors of these
    classes. We also expose some specific getters, and the popular `equals()`, `hashCode()`,
    and `toString()` methods. Further, we create instances of these classes that wrap
    our precious data and we pass them around to solve our tasks all over our application.
    For instance, the following class carries data about melons like the melon types
    and their weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be pretty familiar with this kind of traditional Java class and
    this tedious ceremony, so there is no need to go over this code in detail. Now,
    let’s see how we can accomplish the exact same thing but using Java record syntactical
    sugar that drastically reduces the previous ceremony:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Java records were delivered as a feature preview starting with JDK 14, and
    it was released and closed in JDK 16 as JEP 395\. This single line of code gives
    us the same behavior as the previous one, the `Melon` class. Behind the scenes,
    the compiler provides all the artifacts, including two `private` `final` fields
    (`type` and `weight`), a constructor, two accessor methods having the same names
    as the fields (`type()` and `weight()`), and the trilogy containing `hashCode()`,
    `equals()`, and `toString()`. We can easily see the code generated by the compiler
    by calling the `javap` tool on the `MelonRecord` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1.png](img/B19665_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The code of a Java record'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention that these accessor’s names don’t follow the Java Bean convention,
    so there is no `getType()` or `getWeight()`. There is `type()` and `weight()`.
    However, you can explicitly write these accessors or explicitly add the `getType()`/`getWeight()`
    getters – for instance, for exposing defensive copies of fields.
  prefs: []
  type: TYPE_NORMAL
- en: All these things are built based on the parameters given when we declare a record
    (`type` and `weight`). These parameters are also known as the components of the
    record and we say that a record is built on the given components.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler recognizes a Java record via the `record` keyword. This is a special
    type of class (exactly like `enum` is a special type of Java class) declared as
    `final` and automatically extending `java.lang.Record`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating `MelonRecord` is the same as instantiating the `Melon` class.
    The following code creates a `Melon` instance and a `MelonRecord` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Java records are not an alternative to mutable Java Bean classes. Moreover,
    you may think that a Java record is just a plain transparent approach for carrying
    immutable data or an immutable state (we say “transparent” because it fully exposes
    its state, and we say “immutable” because the class is `final`, it has only `private`
    `final` fields, and no setters). In this context, we may think that Java records
    are not quite useful because they just overlap the functionality that we can obtain
    via Lombok or Kotlin. But as you’ll see in this chapter, a Java record is more
    than that, and it provides several features that are not available in Lombok or
    Kotlin. Moreover, if you benchmark, you’ll notice that using records has significant
    advantages in the performance context.
  prefs: []
  type: TYPE_NORMAL
- en: 89\. Introducing the canonical and compact constructors for records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous problem, we created the `MelonRecord` Java record and we instantiated
    it via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How is this possible (since we didn’t write any parameterized constructor in
    `MelonRecord`)? The compiler just followed its internal protocol for Java records
    and created a default constructor based on the components that we provided in
    the record declaration (in this case, there are two components, `type` and `weight`).
  prefs: []
  type: TYPE_NORMAL
- en: This constructor is known as the *canonical constructor* and it is always aligned
    with the given components. Every record has a canonical constructor that represents
    the only way to create instances of that record.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we can redefine the canonical constructor. Here is an explicit canonical
    constructor similar to the default one – as you can see, the canonical constructor
    simply takes all the given components and sets the corresponding instance fields
    (also generated by the compiler as `private` `final` fields):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the instance is created, it cannot be changed (it is immutable). It will
    only serve the purpose of carrying this data around your program. This explicit
    canonical constructor has a shortcut known as the *compact constructor* – this
    is specific to Java records. Since the compiler knows the list of given components,
    it can accomplish its job from this compact constructor, which is equivalent to
    the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to not confuse this compact constructor with the one without
    arguments. The following snippets are not equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it doesn’t make sense to write an explicit canonical constructor
    just to mimic what the default one does. So, let’s examine several scenarios when
    redefining the canonical constructor makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Handling validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this moment, when we create a `MelonRecord`, we can pass the type as `null`,
    or the melon’s weight as a negative number. This leads to corrupted records containing
    non-valid data. Validating the record components can be handled in an explicit
    canonical constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, via the compact constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Validation handling is the most common use case for explicit canonical/compact
    constructors. Next, let’s see two more lesser-known use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Reassigning components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Via an explicit canonical/compact constructor, we can reassign components.
    For instance, when we create a `MelonRecord`, we provide its type (for instance,
    Cantaloupe) and its weight in grams (for instance, 2600 grams). But, if we want
    to use weight in kilograms (2600 g = 2.6 kg), then we can provide this conversion
    in an explicit canonical constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `weight` component is available and reassigned before the
    `weight` field is initialized with the new reassigned value. In the end, the `weight`
    component and the `weight` field have the same value (2.6 kg). How about this
    snippet of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, in this case, in the end, the `weight` field and the `weight` component
    will have different values. The `weight` field is 2.6 kg, while the `weight` component
    is 2600 g. Pay attention that most probably this is not what you want. Let’s check
    another snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, in the end, the `weight` field and the `weight` component will have different
    values. The `weight` field is 2600 g, while the `weight` component is 2.6 kg.
    And again, pay attention—most probably this is not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the cleanest and most simple approach relies on the compact constructor.
    This time, we cannot sneak in any accidental reassignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s tackle the third scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive copies of the given components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that a Java record is immutable. But this doesn’t mean that its components
    are immutable as well. Think of components such as arrays, lists, maps, dates,
    and so on. All these components are mutable. In order to restore total immutability,
    you’ll prefer to work on copies of these components rather than modify the given
    components. And, as you may have already intuited, this can be done via the explicit
    canonical constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s consider the following record that gets a single component
    representing the retail prices for a set of items as a `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This record shouldn’t modify this `Map`, so it relies on an explicit canonical
    constructor for creating a defensive copy that will be used in subsequent tasks
    without any risks of modification (`Map.copyOf()` returns an unmodifiable copy
    of the given `Map`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this is just a flavor of component reassignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we can return defensive copies via the accessor methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 90\. Adding more artifacts in a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we know how to add an explicit canonical/compact constructor into a
    Java record. What else can we add? Well, for example, we can add instance methods
    as in any typical class. In the following code, we add an instance method that
    returns the `weight` converted from grams to kilograms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call `weightToKg()` exactly as you call any other instance method of
    your classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides instance methods, we can add `static` fields and methods as well. Check
    out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `getDefaultMelon()` is done as usual via class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding nested classes is also possible. For example, here we add a `static`
    nested class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And, calling `Slicer` can be done as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But, even if it is allowed to add all these artifacts in a Java record, I strongly
    suggest you think twice before doing this. The main reason is that Java records
    should be about data and only data, so it is kind of weird to pollute a record
    with artifacts that involve additional behavior. If you hit such a scenario, then
    you probably need a Java class, not a Java record.
  prefs: []
  type: TYPE_NORMAL
- en: In the next problem, we will see what we cannot add to a Java record.
  prefs: []
  type: TYPE_NORMAL
- en: 91\. Iterating what we cannot have in a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several artifacts that we cannot have in a Java record. Let’s tackle
    the top 5 one by one.
  prefs: []
  type: TYPE_NORMAL
- en: A record cannot extend another class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since a record already extends `java.lang.Record` and Java doesn’t support
    multiple inheritances, we cannot write a record that extends another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This snippet doesn’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: A record cannot be extended
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java records are `final` classes, so they cannot be extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This snippet doesn’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: A record cannot be enriched with instance fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we declare a record, we also provide the components that become the instance
    fields of the record. Later, we cannot add more instance fields as we could in
    a typical class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding `color` as a `final` or non-`final` separate field doesn’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: A record cannot have private canonical constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we create classes with `private` constructors that expose `static`
    factories for creating instances. Basically, we call the constructor indirectly
    via a `static` factory method. This practice is not available in a Java record
    because `private` canonical/compact constructors are not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A record cannot have setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw, a Java record exposes a getter (accessor method) for each of its
    components. These getters have the same names as components (for `type` we have
    `type()`, not `getType()`). On the other hand, we cannot have setters since the
    fields corresponding to the given components are `final`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 92\. Defining multiple constructors in a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, when we declare a Java record, the compiler uses the given components
    to create a default constructor known as the canonical constructor. We can also
    provide an explicit canonical/compact constructor, as you saw in *Problem 89*.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we can go even further and declare more constructors with a different
    list of arguments. For example, we can have a constructor with no arguments for
    returning a default instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can write a constructor that gets only the melon’s type or the melon’s
    weight as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we can add arguments that don’t fit any component (here, `country`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What do all these constructors have in common? They all call the canonical constructor
    via the `this` keyword. Remember that the only way to instantiate a Java record
    is via its canonical constructor, which can be called directly or, as you saw
    in the previous examples, indirectly. So, keep in mind that all explicit constructors
    that you add to a Java record must first call the canonical constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 93\. Implementing interfaces in records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java records cannot extend another class but they can implement any interface
    exactly like a typical class. Let’s consider the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet of code is a straightforward usage of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code overrides the `abstract` method `exterminatePest()` and
    calls the `default` method `detectPest()`.
  prefs: []
  type: TYPE_NORMAL
- en: 94\. Understanding record serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how Java records are serialized/deserialized, let’s have
    a parallel between classical code based on plain Java classes and the same code
    but expressed via the Java record’s syntactical sugar.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s consider the following two plain Java classes (we have to explicitly
    implement the `Serializable` interface because, in the second part of this problem,
    we want to serialize/deserialize these classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the `MelonContainer` class that uses the previous `Melon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we express this code via Java records, then we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have explicitly implemented the `Serializable` interface since,
    by default, Java records are not serializable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a `MelonContainer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And, a `MelonContainerRecord` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To serialize these objects (`gacContainer` and `gacContainerR`), we can use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the deserialization can be accomplished via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Before exploiting these snippets of code for a practical examination of serialization/deserialization,
    let’s try a theoretical approach meant to provide some hints for these operations.
  prefs: []
  type: TYPE_NORMAL
- en: How serialization/deserialization works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The serialization/deserialization operations are represented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2.png](img/B19665_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Java serialization/deserialization operations'
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, *serialization* (or serializing an object) is the operation of
    extracting the state of an object as a byte stream and representing it as a persistent
    format (a file, a database, in memory, over the network, and so on). The reverse
    operation is called *deserialization* (or deserializing an object) and represents
    the steps of reconstructing the object state from the persistent format.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, an object is serializable if it implements the `Serializable` interface.
    This is an empty interface with no state or behavior that acts as a marker for
    the compiler. In the absence of this interface, the compiler assumes that the
    object is not serializable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler uses its internal algorithm for the serialization of objects.
    This algorithm relies on every trick in the book, like special privileges (ignoring
    accessibility rules) to access objects, malicious reflection, constructors bypassing,
    and so on. It is beyond our purpose to bring light to this dark magic, so as a
    developer, it is enough to know that:'
  prefs: []
  type: TYPE_NORMAL
- en: If a part of an object is not serializable then you’ll get a runtime error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can alter the serialization/ deserialization operations via the `writeObject()`/`readObject()`
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ok, now let’s see what’s going on when an object is serialized.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing/deserializing gacContainer (a typical Java class)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `gacContainer` object is an instance of `MelonContainer`, which is a plain
    Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After serializing it in a file called *object.data*, we obtain the byte stream
    representing the `gacContainer` state. While you can inspect this file in the
    bundled code (use a hex editor such as [https://hexed.it/](https://hexed.it/)),
    here is a human-readable interpretation of its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3.png](img/B19665_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Human-readable interpretation of gacContainer serialization'
  prefs: []
  type: TYPE_NORMAL
- en: The deserialization operation takes place by building the object graph from
    the top down. When the class name is known, the compiler creates an object by
    calling the non-arguments constructor of the first superclass of `MelonContainer`
    that is non-serializable. In this case, that is the non-argument constructor of
    `java.lang.Object`. So, the compiler is not calling the constructor of `MelonContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the fields are created and set to the default values, so the created
    object has `expiration`, `batch`, and `melon` as `null`. Of course, this is not
    the correct state of our object, so we continue processing the serialization stream
    to extract and populate the fields with the correct values. This can be seen in
    the following diagram (on the left side, the created object has default values;
    on the right side, the fields have been populated with the correct state):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4.png](img/B19665_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Populating the created object with the correct state'
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler hits the `melon` field, it must perform the same steps to
    obtain the `Melon` instance. It sets the fields (`type` and `weight` to `null`,
    respectively, `0.0f`). Further, it reads the real values from the stream and sets
    the correct state for the `melon` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after the entire stream is read, the compiler will link the objects
    accordingly. This is shown in the following figure (1, 2, and 3 represent the
    steps of the deserialization operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5.png](img/B19665_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Linking the objects to obtain the final state'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the deserialization operation has been done and we can use the
    resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing a malicious stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Providing a malicious stream means altering the object state before deserialization.
    This can be done in many ways. For instance, we can manually modify the *object.data*
    instance in an editor (this is like an untrusted source) as in the following figure
    where we replaced the valid batch `ML9000SQA0` with the invalid batch `0000000000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6.png](img/B19665_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Modify the original stream to obtain a malicious stream'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we deserialize the malicious stream (in the bundle code, you can find it
    as the `object_malicious.data` file) then you can see that the corrupted data
    has “successfully” landed in our object (a simple call of `toString()` reveals
    that batch is `0000000000`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The guarding conditions from `Melon`/`MelonContainer` constructors are useless
    since the deserialization doesn’t call these constructors.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we summarize the shortcomings of serializing/deserializing a Java class,
    we must highlight the presence of the window of time that occurs when the objects
    are in an improper state (waiting for the compiler to populate fields with the
    correct data and to link them in the final graph) and the risk of dealing with
    malicious states. Now, let’s pass a Java record through this process.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing/deserializing gacContainerR (a Java record)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, the minimalist design of declaring Java records and their semantic
    constraints allows the serialization/deserialization operations to act differently
    from a typical Java class. And when I say “differently,” I should actually say
    much better and more robust. How so? Well, the serialization of a Java record
    is based only on its component’s state, while deserialization relies on the single
    point of entry for a Java record, its canonical constructor. Remember that the
    only way to create a Java record is to directly/indirectly call its canonical
    constructor? This applies to deserialization as well, so this operation can no
    longer bypass the canonical constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, the `gacContainerR` object is a `MelonContainerRecord` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After serializing it in a file called `object_record.data`, we obtain the byte
    stream representing the `gacContainerR` state. While you can inspect this file
    in the bundled code (use a hex editor such as [https://hexed.it/](https://hexed.it/)),
    here is a human-readable interpretation of its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7.png](img/B19665_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Human-readable interpretation of MelonContainerRecord serialization'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you’re right—with the exception of the class name (`MelonContainerRecord`),
    the rest is the same as in *Figure 4.3*. This sustains the migration from ordinary/regular
    Java classes to Java records. This time, the compiler can use the accessors exposed
    by the record, so no dark magic is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, so nothing got our attention here, so let’s examine the deserialization
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that for regular Java classes, the deserialization builds the object
    graph from the top down. In the case of Java records, this operation takes place
    from the bottom up, so in reverse order. In other words, this time, the compiler
    reads first the fields (primitives and reconstructed objects) from the stream
    and stores them in memory. Next, having all the fields in its hands, the compiler
    tries to match these fields (their names and values) against the components of
    the record. Any field from the stream that doesn’t match a component (name and
    value) is dropped from the deserialization operation. Finally, after the match
    is successfully performed, the compiler calls the canonical constructor to reconstruct
    the record object state.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing a malicious stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the bundled code, you can find a file named `object_record_malicious.data`
    where we replaced the valid batch `ML9000SQA0` with the invalid batch `0000000000`.
    This time, deserializing this malicious stream will result in the exception from
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9.png](img/B19665_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Deserializing a malicious stream causing an exception'
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, this exception originates in our guarding condition added
    in the explicit canonical constructor of our Java record.
  prefs: []
  type: TYPE_NORMAL
- en: It is obvious that Java records significantly improve serialization/deserialization
    operations. This time, there is no moment when the reconstructed objects are in
    a corrupted state, and the malicious streams can be intercepted by guarding conditions
    placed in the canonical/compact constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the record’s semantic constraints, their minimalist design,
    the state accessible only via the accessor methods, and the object creation only
    via the canonical constructors sustain the serialization/deserialization as a
    trusted process.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring legacy serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serialization/deserialization via Java records is awesome, but what can we do
    in the case of legacy code, such as `MelonContainer`? We cannot take all our legacy
    classes that act as carriers of data and rewrite them as Java records. It will
    consume a lot of work and time.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there is a solution backed in the serialization mechanism that requires
    us to add two methods named `writeReplace()` and `readResolve()`. By following
    this reasonable refactoring step, we can serialize legacy code as records and
    deserialize it back into legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this refactoring step to `MelonContainer`, then we start by adding
    the `writeReplace()` method in this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `writeReplace()` method must throw an `ObjectStreamException` and return
    an instance of `MelonContainerRecord`. The compiler will use this method for serializing
    `MelonContainer` instances as long as we mark it with the `@Serial` annotation.
    Now, the serialization of a `MelonContainer` instance will produce the *object.data*
    file containing the byte stream corresponding to a `MelonContainerRecord` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `readResolve()` method must be added to the `MelonContainerRecord`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `readResolve()` method must throw an `ObjectStreamException` and return
    an instance of `MelonContainer`. Again, the compiler will use this method for
    deserializing `MelonContainerRecord` instances as long as we mark it with the
    `@Serial` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler deserializes an instance of `MelonContainerRecord`, it will
    call the canonical constructor of this record, so it will pass through our guarding
    conditions. This means that a malicious stream will not pass the guarding conditions,
    so we avoid creating corrupted objects. If the stream contains valid values, then
    the `readResolve()` method will use them to reconstruct the legacy `MelonContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: Hey, Kotlin/Lombok, can you do this? No, you can’t!
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can find a file named `object_malicious.data` that
    you can use to practice the previous statement.
  prefs: []
  type: TYPE_NORMAL
- en: 95\. Invoking the canonical constructor via reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not a daily task to invoke the canonical constructor of a Java record
    via reflection. However, this can be accomplished quite easily starting with JDK
    16, which provides in `java.lang.Class` the `RecordComponent[] getRecordComponents()`
    method. As its name and signature suggest, this method returns an array of `java.lang.reflect.RecordComponent`
    representing the components of the current Java record.
  prefs: []
  type: TYPE_NORMAL
- en: Having this array of components, we can call the well-known `getDeclaredConstructor()`
    method to identify the constructor that gets as arguments exactly this array of
    components. And that is the canonical constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that puts these statements into practice is provided by the Java documentation
    itself, so there is no need to reinvent it. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding and calling the canonical constructors for these records via the previous
    solution can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you need deep coverage of Java reflection principles, then consider *Java
    Coding Problems*, *First Edition*, *Chapter 7*.
  prefs: []
  type: TYPE_NORMAL
- en: 96\. Using records in streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the `MelonRecord` that we have used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And a list of melons as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to iterate this list of melons and extract the total weight and
    the list of weights. This data can be carried by a regular Java class or by another
    record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Populating this record with data can be done in several ways, but if we prefer
    the Stream API then most probably we will go for the `Collectors.teeing()` collector.
    We won’t go into too much detail here, but we’ll quickly show that it is useful
    for merging the results of two downstream collectors. (If you’re interested, you
    can find more details about this particular collector in *Java Coding Problems,
    First Edition, Chapter 9, Problem 192*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `summingDouble()` collector, which computes the total weight,
    and the `mapping()` collector, which maps the weights in a list. The results of
    these two downstream collectors are merged in `WeightsAndTotalRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Stream API and records represent a very nice combo. Let’s
    have another example starting from this functional code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This code starts from a list of elevations given in centimeters (based on sea
    level being 0). First, we want to keep only the positive elevations (so, we apply
    `filter()`). Next, these will be converted to inches (via `map()`) and counted
    (via the `groupingBy()` and `counting()` collectors).
  prefs: []
  type: TYPE_NORMAL
- en: The resulting data is carried by `Map<Double, Long>`, which is not very expressive.
    If we pull this map out of the context (for instance, we pass it as an argument
    into a method), it is hard to say what `Double` and `Long` represent. It would
    be more expressive to have something such as `Map<Elevation, ElevationCount>`,
    which clearly describes its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `Elevation` and `ElevationCount` can be two records as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the functional code a little bit, we also moved to convert from
    centimeters to inches in the `Elevation` record, inside its explicit canonical
    constructor. This time, the functional code can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, passing `Map<Elevation, ElevationCount>` to a method dispels any doubt
    about its content. Any team member can inspect these records in the blink of an
    eye without losing time reading our functional implementation in order to deduce
    what `Double` and `Long` represent. We can be even more expressive and rename
    the `Elevation` record as `PositiveElevation`.
  prefs: []
  type: TYPE_NORMAL
- en: 97\. Introducing record patterns for instanceof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to introduce *record patterns*, we need a more complex record than
    the one we’ve used so far, so here’s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This record implements the `Staff` interface as any other employee of our hospital.
    Now, we can identify a certain doctor in the old-fashioned style via `instanceof`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But, as we know from *Chapter* 2, *Problems* *58-67*, JDK has introduced *type
    patterns* that can be used for `instanceof` and `switch`. So, in this particular
    case, we can rewrite the previous code via type patterns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Nothing is new so far! The binding variable `dr` can be used to call the record
    accessor’s `specialty()` and `name()`, to add checks, computations, and so on.
    But, the compiler knows very well that the `Doctor` record was built based on
    two components (`name` and `specialty`) so the compiler should be able to deconstruct
    this object and give us these components directly as binding variables instead
    of accessing them via `dr`.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what *record pattern matching* is all about. Record pattern
    matching appeared as a preview feature in JDK 19 (JEP 405), as a second preview
    feature in JDK 20 (JEP 432), and as a final release in JDK 21 (JEP 440).
  prefs: []
  type: TYPE_NORMAL
- en: 'Record pattern matching is exactly the syntax of declaring `name` and `specialty`
    as binding variables by following the same declaration syntax as in the record
    itself (or like in the canonical constructor). Here is the previous code written
    via record patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Very simple, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Now, `name` and `specialty` are the binding variables that can be used directly.
    We simply put this syntax in place of the type pattern. In other words, we replaced
    the type pattern with a record pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler exposes the record’s components via the corresponding binding variables.
    This is accomplished by deconstructing records in pattern matching, which is referred
    to as *record patterns*. In other words, the deconstruction patterns allow us
    to access the components of an object in a very handy, intuitive, and readable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In record patterns, it is the compiler’s responsibility to initialize binding
    variables such as `name` and `specialty`. In order to accomplish this, the compiler
    calls the accessors of the corresponding components. This means that if you have
    some extra code in these accessors (for example, return defensive copies, perform
    validations or apply constraints, and so on), then this code is properly executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go further and work with some nested records.
  prefs: []
  type: TYPE_NORMAL
- en: Nested records and record patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume that besides the `Doctor` record, we also have the following record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Each resident has a coordinator, which is a doctor, so a `Resident` nests a
    `Doctor`. This time, we have to nest the record patterns accordingly as in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Both the resident and the doctor, have a `name` component. But we cannot use
    the binding variable `name` twice in this context since it will cause a conflict.
    This is why we have `rsname` and `drname`. Notice that the names of the binding
    variables don’t have to mirror the names of the components. This is possible because
    the compiler identifies components by position not by their names. But, of course,
    when it is possible, mirroring the name reduces the confusion and keeps the readability
    of the code high.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no need to deconstruct the `Doctor` record, then we can write it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding more nested records follows the same principle. For instance, let’s
    add the `Patient` and `Appointment` records as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the following beauty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we don’t want to deconstruct `Appointment` and use `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, this time, we have used `var` instead of explicit types. Feel free
    to do the same since `var` fits very well in this case. If you are not familiar
    with type inference, then consider *Java Coding Problems*, *First Edition*, *Chapter
    4*, which contains detailed explanations and best practices. More details about
    argument type inference in record patterns are available later in this chapter
    in *Problem 100*.
  prefs: []
  type: TYPE_NORMAL
- en: I think you got the idea!
  prefs: []
  type: TYPE_NORMAL
- en: 98\. Introducing record patterns for switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You already know that type patterns can be used for `instanceof` and `switch`
    expressions. This statement is true for record patterns as well. For instance,
    let’s reiterate the `Doctor` and `Resident` records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily use these two records via record patterns in a `switch` expression
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding more nested records follows the same principle. For instance, let’s
    add the `Patient` and `Appointment` records as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the following beauty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, without deconstructing `Appointment` and using `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the topics covered in *Chapter 2*, such as dominance, completeness,
    and unconditional patterns, remain valid for record patterns with `switch` as
    well. Actually, there are some important things to highlight about unconditional
    patterns, but that is covered later, in *Problem 101*.
  prefs: []
  type: TYPE_NORMAL
- en: 99\. Tackling guarded record patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exactly as in the case of type patterns, we can add guarding conditions based
    on the binding variables. For instance, the following code uses guarding conditions
    with `instanceof` for determining if the Allergy cabinet is open or closed (you
    should be familiar with the `Doctor` record from the previous two problems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add into the equation the `Resident` record as well, then we can write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And, if we add the `Patient` and `Appointment` records as well, then we can
    check if a certain patient has an appointment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are using record patterns with guarded conditions in `switch` expressions,
    things are straightforward. The mention consists of using the `when` keyword (not
    the `&&` operator) as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And, if we add the `Patient` and `Appointment` records as well, then we can
    check if a certain patient has an appointment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The JDK 19+ context-specific keyword `when` is added between the pattern label
    and the checks (the boolean expressions representing the guarding conditions)
    this avoids the confusion of using the `&&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 100\. Using generic records in record patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declaring a generic record for mapping fruit data can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s assume a `MelonRecord`, which is a fruit (actually, there is some
    controversy over whether a melon is a fruit or a vegetable, but let’s say that
    it is a fruit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare a `FruitRecord<MelonRecord>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This `FruitRecord<MelonRecord>` can be used in record patterns with `instanceof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in `switch` statements/expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can use type argument inference.
  prefs: []
  type: TYPE_NORMAL
- en: Type argument inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java supports inference of type arguments for record patterns, so we can re-write
    the previous examples as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want more concise code, then we can drop the type arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The same works for `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Here, the type for `melon` is inferred as `MelonRecord`, and the type for `country`
    as `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume the following generic record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The generics `X`, `Y`, and `Z` can be anything. For instance, we can define
    an engine by its type, horsepower, and cooling system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `engine` variable and `instanceof` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And, with `switch` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, we rely on inferred types for arguments. The type inferred
    for the `type` argument is `String`, for `power` is `Integer`, and for `cooling`
    is `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Type argument inference and nested records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume the following record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following nested `container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use `container` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `type` argument for the nested pattern `ContainerRecord(var c)` is
    inferred to be `String`, so the pattern itself is inferred to be `ContainerRecord<String>(var
    c)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'More concise code can be obtained if we drop the type arguments in the outer
    record pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here, the compiler will infer that the entire `instanceof` pattern is `ContainerRecord<ContainerRecord<String>>(ContainerRecord<String>(var
    c))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, if we want the outer container, then we write the following record pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can find these examples for `switch` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention that type patterns don’t support the implicit inference of type
    arguments (for instance, the type pattern `List list` is always treated as a raw
    type pattern).
  prefs: []
  type: TYPE_NORMAL
- en: So, Java Generics can be used in records exactly as in regular Java classes.
    Moreover, we can use them in conjunction with record patterns and `instanceof`/`switch`.
  prefs: []
  type: TYPE_NORMAL
- en: 101\. Handling nulls in nested record patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From *Chapter 2*, *Problem 54*, *Tackling the case null clause in switch,*
    we know that starting with JDK 17 (JEP 406), we can treat a `null` case in `switch`
    as any other common case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement partially works for record patterns as well. For instance, let’s
    consider the following records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And, let’s consider the following `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If we call `buyFruit(null)`, then we will get the message *Ops!*. The compiler
    is aware that the selector expression is `null` and that there is a `case null`,
    therefore it will execute that branch. If we remove that `case null`, then we
    immediately get a `NullPointerException`. The compiler will not evaluate the record
    patterns; it will simply throw a `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create an eggplant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This time, if we call `buyFruit(seed)`, we get the message *This is a seed of
    Fairytale from India.* The call matches the `case SeedRecord(String type, String
    country)` branch. And, if we call `buyFruit(eggplant)`, then we get the message
    *This is a Fairytale eggplant*. The call matches the `case EggplantRecord(SeedRecord
    seed, float weight)` branch. There are no surprises so far!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s have an edge case. We assume that `SeedRecord` is `null` and we
    create the following “bad” eggplant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buyFruit(badEggplant)` call will return a `NullPointerException` containing
    the following crystal clear message: *java.lang.NullPointerException: Cannot invoke
    “modern.challenge.SeedRecord.type()” because “seed” is null*. As you can see,
    in the case of nested `null`, the compiler cannot prevent the execution of the
    corresponding branch. The nested `null` doesn’t short-circuit the code and hits
    the code of our branch (`case EggplantRecord(SeedRecord seed, float weight)`)
    where we call `seed.type()`. Since `seed` is `null`, we get a `NullPointerException`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot cover this edge case via a case such as `case EggplantRecord(null,
    float weight)`. This will not compile. Obviously, a deeper or wider nesting will
    complicate these edge cases even more. However, we can add a guard to prevent
    the issue and cover this case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens in the case of using `instanceof` instead of `switch`.
    So, the code becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `instanceof`, there is no need to add explicit `null` checks.
    A call such as `buyFruit(null)` will return the message *This is an unknown fruit*.
    This happens since no `if` statement will match the given `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if we call `buyFruit(seed)`, we get the message *This is a seed of Fairytale
    from India*. The call matches the `if (fruit instanceof SeedRecord(String type,
    String country))` branch. And, if we call `buyFruit(eggplant)`, then we get the
    message *This is a Fairytale eggplant*. The call matches the case `if (fruit instanceof
    EggplantRecord(SeedRecord seed, float weight))` branch. Again, there are no surprises
    so far!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s bring in front the `badEggplant` via the `buyFruit(badEggplant)`
    call. Exactly as in the case of the `switch` example, the result will consist
    of an NPE: *Cannot invoke “modern.challenge.SeedRecord.type()” because “seed”
    is null*. Again, the nested `null` cannot be intercepted by the compiler and the
    `if (fruit instanceof EggplantRecord(SeedRecord seed, float weight))` branch is
    executed leading to a `NullPointerException` because we call `seed.type()` while
    `seed` is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to cover this edge case via the following snippet of code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can add a guard to cover this case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: So, pay attention that nested patterns don’t take advantage of `case null` or
    of the JDK 19+ behavior that throws an NPE without even inspecting the patterns.
    This means that `null` values can pass through a `case` (or `instanceof` check)
    and execute that branch leading to NPEs. So, avoiding `null` values or adding
    extra checks (guards) as much as possible should be the way to a smooth road ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 102\. Simplifying expressions via record patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java records can help us to simplify snippets of code meant to handle/evaluate
    different expressions (mathematical, statistical, string-based, **Abstract Syntax
    Tree** (**AST**), and so on) a lot. Typically, evaluating such expressions implies
    a lot of conditions and checks that can be implemented via `if` and/or `switch`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s consider the following records meant to shape string-based
    expressions that can be concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Some parts of the string expression are literals (`Literal`) while others are
    provided as variables (`Variable`). For brevity, we can evaluate these expressions
    only via the concatenation operation (`Concat`), but feel free to add more operations.
  prefs: []
  type: TYPE_NORMAL
- en: During the evaluation, we have an intermediary step for simplifying the expression
    by removing/replacing irrelevant parts. For example, we can consider that the
    terms of the expression that are empty strings can be safely removed from the
    concatenation process. In other words, a string expression such as `t + " "` can
    be simplified as `t`, since the second term of our expression is a blank string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code meant to perform this kind of simplification can rely on type patterns
    and `instanceof` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will become quite verbose if we continue to add more rules for simplifying
    the given `str`. Fortunately, we can increase the readability of this code by
    using record patterns and `switch`. This way, the code becomes more compact and
    expressive. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How cool is this?
  prefs: []
  type: TYPE_NORMAL
- en: 103\. Hooking unnamed patterns and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most remarkable preview features of JDK 21 is JEP 443 or *unnamed
    patterns and variables*. In other words, via unnamed patterns and variables, JDK
    21 provides support for representing record components and local variables that
    we are not using in our code (we don’t care about them) as an underscore character
    (_).
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deconstructing a record allows us to express record patterns, but we do not
    always use all the resulting components. Unnamed patterns are useful for indicating
    the record components that we don’t use but we have to declare for the sake of
    syntax. For instance, let’s have the following example (the `Doctor`, `Resident`,
    `Patient`, and `Appointment` records were introduced earlier, in *Problem 97*
    and *98*, so, for brevity, I’ll skip their declarations here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `Doctor` record was deconstructed as `Doctor(String name,
    String specialty)` but we are using only the `specialty` component while we don’t
    need the `name` component. However, we cannot write `Doctor(String specialty)`
    since this doesn’t respect the `Doctor` record signature. Alternatively, we can
    simply replace the `String name` with an underscore as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The unnamed pattern is shorthand for the type pattern `var _`, so we can write
    `if (staff instanceof Doctor(var _, String specialty))` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we use the `name` of the `Resident` but we don’t care about the
    `Doctor`, so we can simply use an underscore as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that ignores the specialty of the doctor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add the `Patient` and `Appointment` records as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we don’t need the `npi` component and the `Doctor` component
    so we can replace them with an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is a case that needs only the patient’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, in such cases, you may prefer to rely on type pattern matching and
    express the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: I think you got the idea! When you don’t need a record component and you want
    to clearly communicate this aspect while typing your code faster, just replace
    that component with an underscore (_).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unnamed patterns can be used with `switch` as well. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested records and unnamed patterns can significantly reduce the code length.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s focus on another use case of unnamed variables, and let’s assume
    the following starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have a sealed class (`EngineType`) extended by three final classes (`ESSEngine`,
    `DSLEngine`, and `LPGEngine`), and a record (`Car`). Next, we want to write the
    following `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the first `case` label. We have grouped the first two patterns in
    one `case` label since the DSL and ESS cars can have the same type of carburetor.
    However, this will not compile and will result in an error: *illegal fall-through
    from a pattern*. Since both patterns can match is erroneous to name the components.
    In such cases, we can elide the components via unnamed variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This compiles and works fine. Moreover, the second `case` label can be written
    as `case` `Car(LPGEngine _)` as well since we don’t use the `lpg` name on the
    right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to add a *guard* to a case label with multiple patterns, then keep
    in mind that the guard applies to the multiple patterns as a whole not to each
    individual pattern. For instance, the following code is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s tackle unnamed variables.
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with **unnamed patterns** (specific to the deconstruction of record components),
    JDK 21 introduces *unnamed variables*. An unnamed variable is also represented
    by an underscore (_) and is useful to highlight which variables we don’t need/use.
    Such variables can occur in one of the following contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In a catch block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The same technique can be applied to multi-catch cases.
  prefs: []
  type: TYPE_NORMAL
- en: In a for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here, we don’t care about the cards’ values, so instead of writing `for
    (String card : cards) {…}`, we simply write `for (String _ : cards) {…}`.'
  prefs: []
  type: TYPE_NORMAL
- en: In an assignment that ignores the result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deleteIfExists()` method returns a boolean result indicating if the given
    file was successfully deleted or not. But, in this code, we didn’t capture that
    result, so it is not clear if we want to ignore the result or if we just forgot
    about it. If we assume that we forgot about it, then most probably we wanted to
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we just wanted to ignore it, then we can clearly communicate it via
    an unnamed variable (this signals that we are aware of the result but we don’t
    want to take further actions based on its value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The same technique applies every time you want to ignore the result of the expression
    on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: In try-with-resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we don’t use the resource opened in a *try-with-resources* block.
    We just need the context of this resource and we want to benefit from the fact
    that it is `AutoCloseable`. For instance, when we call `Arena.ofConfined()`, we
    may need the `Arena` context without explicitly using it. In such cases, unnamed
    variables can help us as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The `Arena` API is part of the Foreign (Function) Memory API introduced in *Chapter
    7*.
  prefs: []
  type: TYPE_NORMAL
- en: In lambda expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a lambda parameter is not relevant for our lambda expression, we can simply
    replace it with an underscore. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Done! Don’t forget that this is a preview feature in JDK 21, so use `--enable-preview`.
  prefs: []
  type: TYPE_NORMAL
- en: 104\. Tackling records in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java records fit perfectly in Spring Boot applications. Let’s have several scenarios
    where Java records can help us increase readability and expressiveness by squeezing
    the homologous code.
  prefs: []
  type: TYPE_NORMAL
- en: Using records in controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, a Spring Boot controller operates with simple POJO classes that
    carry our data back over the wire to the client. For instance, check out this
    simple controller endpoint returning a list of authors, including their books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Author` (and `Book`) can be simple carriers of data written as POJOs.
    But, they can be replaced by records as well. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: That’s all! The Jackson library (which is the default JSON library in Spring
    Boot) will automatically marshal instances of type `Author`/`Book` into JSON.
    In the bundled code, you can practice the complete example via the `localhost:8080/authors`
    endpoint address.
  prefs: []
  type: TYPE_NORMAL
- en: Using records with templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thymeleaf ([https://www.thymeleaf.org/](https://www.thymeleaf.org/)) is probably
    the most used templating engine in Spring Boot applications. Thymeleaf pages (HTML
    pages) are typically populated with data carried by POJO classes, which means
    that Java records should work as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the previous `Author` and `Book` records, and the following
    controller endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `List<Author>` returned via `fetchAuthors()` is stored in the model under
    a variable named `authors`. This variable is used to populate `bookstore.html`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: Using records for configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume that in `application.properties` we have the following two properties
    (they could be expressed in YAML as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Boot maps such properties to POJO via `@ConfigurationProperties`. But,
    a record can be used as well. For instance, these properties can be mapped to
    the `BestSellerConfig` record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `BookstoreService` (a typical Spring Boot service), we can inject
    `BestSellerConfig` and call its accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, we have added a controller that uses this service as well.
  prefs: []
  type: TYPE_NORMAL
- en: Record and dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we have injected the `BookstoreService` service into
    `BookstoreController` using the typical mechanism provided by SpringBoot – dependency
    injection via constructor (it can be done via `@Autowired` as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'But, we can compact this class by re-writing it as a record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The canonical constructor of this record will be the same as our explicit constructor.
    Feel free to challenge yourself to find more use cases of Java records in Spring
    Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: 105\. Tackling records in JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a fan of JPA (I cannot see why, but who am I to judge), then you’ll
    be more than happy to find out that Java records can be helpful in JPA. Typically,
    Java records can be used as DTOs. Next, let’s see several scenarios when records
    and JPA make a delightful combo.
  prefs: []
  type: TYPE_NORMAL
- en: DTO via record constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that we have a JPA typical `Author` entity that maps author data
    such as `id`, `name`, `age`, and `genre`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to write a query that fetches the authors of a certain `genre`.
    But, we don’t need to fetch authors as entities because we don’t plan to modify
    this data. This is a read-only query returning only the `name` and `age` of each
    author of the given `genre`. So, we need a DTO that can be expressed via records
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a typical Spring Data JPA, `AuthorRepository` powered by the Spring Data
    Query Builder mechanism, can take advantage of this record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Now, the generated query fetches the data and Spring Boot will map it accordingly
    to be carried around by the `AuthorDto`.
  prefs: []
  type: TYPE_NORMAL
- en: DTO via record and JPA constructor expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another flavor of the previous scenario can rely on a JPA query that uses a
    constructor expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The `AuthorDto` is the same record listed in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: DTO via record and result transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If working with Hibernate 6.0+ result transformers is not on your “to-do” list,
    then you can simply jump to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following two records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have to fetch a hierarchical DTO represented by `AuthorDto` and
    `BookDto`. Since an author can have several books written, we have to provide,
    in `AuthorDto`, a component of the type `List<BookDto>` and a helper method for
    collecting the books of the current author.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to populate this hierarchical DTO, we can rely on an implementation
    of `TupleTransformer`, `ResultListTransformer` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete application in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: DTO via record and JdbcTemplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If working with SpringBoot `JdbcTemplate` is not on your “to-do” list, then
    you can simply jump to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: The `JdbcTemplate` API has been a huge success among those who love to work
    with JDBC. So, if you are familiar with this API, then you’ll be very happy to
    find out that it can be combined with Java records quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, having the same `AuthorDto` and `BookDto` as in the previous
    scenario, we can rely on `JdbcTemplate` to populate this hierarchical DTO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete application in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Team up Java records and @Embeddable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hibernate 6.2+ allows us to define Java records as embeddable. Practically,
    we start with an embeddable class defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use this embeddable in our `Author` entity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in our `AuthorDto` DTO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a classical Spring Data JPA `AuthorRepository` powered by the Spring
    Data Query Builder mechanism can take advantage of this record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the generated query fetches the data and Spring Boot will map it accordingly
    to be carried around by the `AuthorDto`. If we print one of the fetched authors
    to the console, we will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part represents our embeddable.
  prefs: []
  type: TYPE_NORMAL
- en: 106\. Tackling records in jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more you learn about JPA, the more you’ll love jOOQ. Why? Because jOOQ represents
    the best way to write SQL in Java. Flexibility, versatility, dialect agnostic,
    rock-solid SQL support, a small learning curve, and high performance are just
    a few of the attributes that make jOOQ the most appealing persistence technology
    for modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: Being part of the modern technology stack, jOOQ is the new persistence trend
    that respects all standards of a mature, robust, and well-documented technology.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with jOOQ, then please consider my book *jOOQ Masterclass*.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, let’s assume that we have a database schema consisting of
    two tables, `Productline` and `Product`. A product line contains multiple products,
    so we can shape this one-to-many relationship via two records as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'In jOOQ, we can populate this model via a simple query based on the `MULTISET`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: How cool is this? jOOQ can produce any nested collection value of jOOQ Records
    or DTOs (POJO/Java records) in a fully type-safe manner, with zero reflections,
    no N+1 risks, no de-duplications, and no accidental Cartesian products. This allows
    the database to perform nesting and optimize the query execution plan.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can see another example that fetches a many-to-many
    relationship in a record model. Moreover, in the bundled code, you can find an
    example that relies on the jOOQ `MULTISET_AGG()` function. This is a synthetic
    aggregate function that can be used as an alternative to `MULTISET`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to deeply cover Java records and record patterns.
    We have assigned the same importance to both the theoretical and the practical
    parts so that, in the end, there are no secrets regarding the use of these two
    topics. And, just in case you wonder why we didn’t cover the topic regarding record
    patterns appearing in the header of an enhanced `for` statement, then please notice
    that this was added as a preview in JDK 20 but it was removed in JDK 21\. This
    feature may be re-proposed in a future JEP.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_Reivew_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
