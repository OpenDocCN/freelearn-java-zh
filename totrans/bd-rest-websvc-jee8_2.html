<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building Synchronous Web Services and Clients</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, we will go into the details of building synchronous microservices with Java EE 8. We will learn how to implement server-side REST APIs using basic JAX-RS annotations, implement sub-resource locators for nested REST APIs, and use HTTP status codes and exception mappers for exception handling. You will also learn how to implement the client side using JAX-RS client APIs, and finally, we will have a look at different test strategies for Java EE web services.</p>
<p class="calibre6">We'll cover the following sections in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Implementing basic REST APIs with JAX-RS</li>
<li class="calibre15">Using sub-resources</li>
<li class="calibre15">Error handling in JAX-RS</li>
<li class="calibre15">Implementing web service clients with Java EE 8</li>
<li class="calibre15">Testing Java EE 8 web services</li>
</ul>
<p class="calibre6">By the end of this chapter, we'll have implemented a small library microservice that offers a REST API for books, authors, and loans. We'll implement the library client as a standalone application and use the Jersey Test Framework and the Test Containers framework to test our REST API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing basic REST APIs with JAX-RS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at how to implement a REST resource using basic JAX-RS annotations. I'll show you how you can inject and use CDI beans in your JAX-RS resource implementation and show you how to properly use HTTP methods to model CRUD semantics, and of course we'll be running the web service within a Docker container:</p>
<p class="cdpaligncenter"><img src="Images/d327924a-14b1-46b9-93c6-fc5c1be9382d.png" width="1180" height="326" class="calibre31"/></p>
<div class="mce-root">Conceptual view of this section</div>
<p class="calibre6">We'll implement a REST API to get a list of books so that we'll be able to create new books, get a book by ISBN, update books, and delete a book.</p>
<p class="calibre6">We will create a basic project skeleton and prepare a simple class, which is called <kbd class="calibre17">BookResource</kbd>, and we will use this to implement the CRUD REST API for our books. So first up, we need to annotate <span class="calibre10"><span class="calibre10">our class</span></span> using the proper annotations. We will use the <kbd class="calibre17">@Path</kbd> annotation to specify the path for our books API, which is <kbd class="calibre17">"books"</kbd>, and we make a <kbd class="calibre17">@RequestScoped</kbd> CDI bean. Now, to implement our business logic, we want to use another CDI bean, thus we need to get it injected into this one. This other CDI bean is called <kbd class="calibre17">bookshelf</kbd>, and we'll use the usual CDI <kbd class="calibre17">@Inject</kbd> annotation to get a reference to our <kbd class="calibre17">bookshelf</kbd>. Next up, we want to implement a method to get hold of a list of all books, so let's do that. What you see here is we have a <kbd class="calibre17">books</kbd> method, which is <kbd class="calibre17">@GET</kbd> annotated, and it produces <kbd class="calibre17">MediaType.APPLICATION_JSON</kbd> and returns a JAX-RS response. You can see that we construct a response of <kbd class="calibre17">ok</kbd>, which is HTTP 200; as the body, we use <kbd class="calibre17">bookshelf.findAll</kbd>, which is a collection of books, and then we build the response. The <kbd class="calibre17">BookResource.java</kbd> file should look as follows:</p>
<pre class="calibre22">@Path("books")<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class BookResource {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private Bookshelf bookshelf;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response books() {<br class="calibre2"/>        return Response.ok(bookshelf.findAll()).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Next up, we want to implement a <kbd class="calibre17">GET</kbd> message to get a specific book. To do that, again we have a <kbd class="calibre17">@GET</kbd> annotated method, but this time we have the <kbd class="calibre17">@Path</kbd> annotation with the <kbd class="calibre17">"/{isbn}"</kbd> parameter. To get hold of this parameter, which is called the <kbd class="calibre17">isbn</kbd>, we use the <kbd class="calibre17">@PathParam</kbd> annotation to pass the value. We use <kbd class="calibre17">bookshelf</kbd> to find our book by ISBN and return the book <span class="calibre10">found</span><span class="calibre10"> </span><span class="calibre10">using the HTTP status code 200,</span> that is, <kbd class="calibre17"><span class="calibre4">ok</span></kbd><span class="calibre10">:</span></p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/{isbn}")<br class="calibre2"/>    public Response get(@PathParam("isbn") String isbn) {<br class="calibre2"/>        Book book = bookshelf.findByISBN(isbn);<br class="calibre2"/>        return Response.ok(book).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Next up, we want to create books. In order to create something, it's a convention to use HTTP <kbd class="calibre17">POST</kbd> as a method. We consume the application JSON and we expect the JSON structure of a book, we call <kbd class="calibre17">bookshelf.create</kbd> with the <kbd class="calibre17">book</kbd> parameter, and then we use <kbd class="calibre17">UriBuilder</kbd> to construct the URI for the just-created <kbd class="calibre17">book</kbd>; this is also a convention. We then return this URI using <kbd class="calibre17">Response.created</kbd>, which matches the HTTP status code <kbd class="calibre17">201</kbd>, and we'll call <kbd class="calibre17">build()</kbd> to build the final response:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response create(Book book) {<br class="calibre2"/>        if (bookshelf.exists(book.getIsbn())) {<br class="calibre2"/>            return Response.status(Response.Status.CONFLICT).build();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        bookshelf.create(book);<br class="calibre2"/>        URI location = UriBuilder.fromResource(BookResource.class)<br class="calibre2"/>                .path("/{isbn}")<br class="calibre2"/>                .resolveTemplate("isbn", book.getIsbn())<br class="calibre2"/>                .build();<br class="calibre2"/>        return Response.created(location).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Next up, we'll implement the update method for an existing book. To update things, again it's a convention to use the HTTP method <kbd class="calibre17">PUT</kbd>. We update this by putting in a specific location. Again, we use the <kbd class="calibre17">@Path</kbd> parameter with a value of <kbd class="calibre17">"/{isbn}"</kbd>. We give a reference to this <kbd class="calibre17">isbn</kbd> here in the <kbd class="calibre17">update</kbd> method parameter, and we have the JSON structure of our book ready. We use <kbd class="calibre17">bookshelf.update</kbd> to update the book and in the end we return the status code <kbd class="calibre17">ok</kbd>:</p>
<pre class="calibre22"><br class="calibre2"/>    @PUT<br class="calibre2"/>    @Path("/{isbn}")<br class="calibre2"/>    public Response update(@PathParam("isbn") String isbn, Book book) {<br class="calibre2"/>        bookshelf.update(isbn, book);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Finally, we're going to implement the delete message, and as you might expect, we use the HTTP method <kbd class="calibre17">DELETE</kbd> on the path of an identified ISBN. Again, we use the <kbd class="calibre17">@PathParam</kbd> annotation here, we call <kbd class="calibre17">bookshelf.delete</kbd>, and we return <kbd class="calibre17">ok</kbd> if everything went well:</p>
<pre class="calibre22">    @DELETE<br class="calibre2"/>    @Path("/{isbn}")<br class="calibre2"/>    public Response delete(@PathParam("isbn") String isbn) {<br class="calibre2"/>        bookshelf.delete(isbn);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<p class="calibre6">This is our CRUD implementation for our book resource. I told you that we're going to use a Docker container and the Payara Server micro edition<span class="calibre10"> to run everything</span>. We will copy our WAR file to the <kbd class="calibre17">deployments</kbd> directory and then we're up and running:</p>
<pre class="calibre22">FROM payara/micro:5-SNAPSHOT<br class="calibre2"/><br class="calibre2"/>COPY target/library-service.war /opt/payara/deployments</pre>
<p class="calibre6">Let's see if everything's running on our REST client (Postman).</p>
<p class="calibre6">F<span class="calibre10">irst up, we get a list of books. As you can see here, this works as expected:</span></p>
<p class="cdpaligncenter"><img src="Images/136d39f9-cffc-40cf-aa86-5b211adf0848.png" width="845" height="531" class="calibre32"/></p>
<p class="calibre6">If we want to create a new book, we issue the <span class="calibre10">POST and create new book</span> request, and you'll see a status code of <span class="calibre10">OK </span><span class="calibre10">200</span>. We get the new book by using <span class="calibre10">GET new book</span>; this is the book we just created, <span class="calibre10">as shown in the following screenshot:</span></p>
<p class="cdpaligncenter"><img src="Images/6f746e17-512d-40e8-b2d9-ef155128560e.png" width="713" height="373" class="calibre33"/></p>
<p class="calibre6">We can update the book by using <span class="calibre10">Update new book</span>, and we'll get a status code of <span class="calibre10">OK <span class="calibre10">200</span></span>. We can get the updated book again by using <span class="calibre10">GET new book</span>; we get the updated title, <span class="calibre10">as shown in the following screenshot:</span></p>
<p class="cdpaligncenter"><img src="Images/30531a36-50a6-4e53-9307-1fb7cd51bdfd.png" width="771" height="400" class="calibre34"/></p>
<p class="calibre6">Finally, we can delete the book. When we get the list of books again, our newly created book is not part of the list of books anymore.</p>
<p class="calibre6">In the next section, we're going to have a look at how we can use sub-resources and sub-resource locators.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using sub-resources</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at how to implement simple sub-resource locator methods. We'll have a look at how you can obtain CDI sub-resource instances from the root resource, and we're going to have a look at how you can pass context information from the root to the sub-resources:</p>
<p class="cdpaligncenter"><img src="Images/55eb5884-74ac-4817-9914-30374d7d095f.png" width="1225" height="318" class="calibre35"/></p>
<div class="mce-root">Conceptual view of this section</div>
<p class="calibre6">Books have authors, and they can be lent out. In this section, what we'll do is provide specific REST endpoints to obtain the author of a book and the loan details of the books. We have prepared the skeleton of the project, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/580bceab-1bdd-44cf-a517-6391b6244a7c.png" width="290" height="593" class="calibre36"/></p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Let's start with the authors. In <kbd class="calibre17">BookResource.java</kbd>, add a resource locator method. A resource locator method is a simple method that is only annotated using the <kbd class="calibre17">@Path</kbd> annotation. In this case, we use <kbd class="calibre17">@Path("/{isbn}/author")</kbd>. The <kbd class="calibre17">return</kbd> type of a resource locator method is another resource. In this case, it's the <kbd class="calibre17">AuthorResource</kbd> locator method. <span class="calibre10">Thus, we create the </span><kbd class="calibre17">AuthorResource</kbd> locator:</p>
<pre class="calibre22">    @Path("/{isbn}/author")<br class="calibre2"/>    public AuthorResource author(@PathParam("isbn") String isbn) {<br class="calibre2"/>        Book book = bookshelf.findByISBN(isbn);<br class="calibre2"/>        return new AuthorResource(book);<br class="calibre2"/>    }</pre>
<p class="calibre6">It produces <kbd class="calibre17">APPLICATION_JSON</kbd>. We get a reference to our book in the constructor. Next up in this sub-resource, we can add the usual <kbd class="calibre17">GET</kbd>, <kbd class="calibre17">POST</kbd>, or <kbd class="calibre17">PUT</kbd> annotated HTTP methods again. In this case, we have one <kbd class="calibre17">GET</kbd> method annotated, which gets the author of our book:</p>
<pre class="calibre22">@Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>public class AuthorResource {<br class="calibre2"/>    private final Book book;<br class="calibre2"/><br class="calibre2"/>    AuthorResource(Book book) {<br class="calibre2"/>        this.book = book;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public Author get() {<br class="calibre2"/>        return book.getAuthor();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">This is really straightforward for simple resources, but what if we want to use CDI injection? If we want to do that, we need to take a different approach. First, we need to get a reference to <kbd class="calibre17">ResourceContext</kbd>; make sure you use the right one. By using this <kbd class="calibre17">ResourceContext</kbd>, we can get hold of a reference that is fully CDI injected. Again, we annotated using <kbd class="calibre17">@Path</kbd>, returned <kbd class="calibre17">loanResource</kbd>, and this time we used <kbd class="calibre17">context.getResource</kbd> from <kbd class="calibre17">LoanResource.class</kbd>. This returns a fully injected <kbd class="calibre17">loanResource</kbd> instance:</p>
<pre class="calibre22">@RequestScoped<br class="calibre2"/>public class BookResource {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private Bookshelf bookshelf;<br class="calibre2"/>    @Context<br class="calibre2"/>    private ResourceContext context;<br class="calibre2"/>    <br class="calibre2"/>    @Path("/{isbn}/loans")<br class="calibre2"/>    public LoanResource loans(@PathParam("isbn") String isbn) {<br class="calibre2"/>        LoanResource loanResource =     <br class="calibre2"/>        context.getResource(LoanResource.class);<br class="calibre2"/>        loanResource.setIsbn(isbn);<br class="calibre2"/><br class="calibre2"/>        return loanResource;<br class="calibre2"/>    }<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/></pre>
<p class="calibre6">We then populate <kbd class="calibre17">LoanResource</kbd> using the <kbd class="calibre17">@Path("/{isbn}")</kbd> parameter. Now, the important bit: because we did this, you really need to make sure that this instance is <kbd class="calibre17">@RequestScoped</kbd>. This is because we pass in the <kbd class="calibre17">isbn</kbd> and here you can implement the usual REST resource methods we need for <kbd class="calibre17">LoanResource</kbd>.</p>
<p class="calibre6">In this case, for example, we will get the specific loan, and we can return a book, we can lend a book to create a loan.</p>
<p class="calibre6">If we switch to a REST client (Postman) and we want to obtain the book author by using the <span class="calibre10">GET book author</span> request, and click on <span class="calibre10">Send</span> and only the author is returned, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/220852b3-021f-4360-8342-3f978160282b.png" width="540" height="242" class="calibre37"/></p>
<p class="calibre6"/>
<p class="calibre6">We can obtain a list of loans, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/36e2300c-9343-417e-9751-c9b3e3db0c99.png" width="731" height="327" class="calibre38"/></p>
<p class="calibre6">We can delete a loan, which means that the book has been returned, we can add new loans, and so on and so forth.</p>
<p class="calibre6">In the next section, we're going to cover how to perform error handling in JAX-RS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Error handling in JAX-RS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at handling user and server-side errors in a RESTful way by using an appropriate HTTP status code, for example, HTTP status code 400 Bad Request for invalid and malformed requests, status 404 Not Found if something could not be found, and HTTP status code 500 Internal Server Error if something happens unexpectedly. We'll also see how to use <kbd class="calibre17">WebApplicationException</kbd> and its subclasses to model error handling, and finally we'll be implementing a custom <kbd class="calibre17">ExceptionMappers</kbd> to handle runtime exceptions and return custom error responses:</p>
<p class="cdpaligncenter"><img src="Images/a789dad9-5c0c-415e-928c-f7da91abc4bd.png" width="1229" height="327" class="calibre39"/></p>
<div class="mce-root">Conceptual view of this section</div>
<p class="calibre6">This is what we'll do conceptually in this section: we'll again extend our library microservice by several HTTP status codes , for example, HTTP <span class="calibre10">400 </span>if you issue an invalid book update, 409 for creating an already existing book, 404 for unknown books and loans, and HTTP status code 500 for general errors with a custom response.</p>
<p class="calibre6">Let's switch to our IDE and return to <kbd class="calibre17">BookResource</kbd> again. Here, we haven't taken much care of proper error handling so far. As you can see in <kbd class="calibre17">bookshelf.create(book)</kbd>, for example, we create the book without checking whether the book already exists. The simplest way is to perform the checking before you do any work. To do that, we use our <kbd class="calibre17">bookshelf</kbd> to check whether the book—or to be more precise, the ISBN of the book—already exists, and if it does, we return a custom status code and we set the status to <kbd class="calibre17">CONFLICT</kbd>, which is 409, and the error response will be returned immediately. This is the most basic form of error handling, by returning a response with the appropriate status code:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response create(Book book) {<br class="calibre2"/>        if (bookshelf.exists(book.getIsbn())) {<br class="calibre2"/>            return Response.status(Response.Status.CONFLICT).build();<br class="calibre2"/>        }</pre>
<p class="calibre6">The same goes for <kbd class="calibre17">update</kbd>; we should check that the updated ISBN matches the ISBN of the book. What we could do here is again set the appropriate status code, which in this case is <kbd class="calibre17">BAD_REQUEST</kbd>, with a status code of 400:</p>
<pre class="calibre22"> @PUT<br class="calibre2"/> @Path("/{isbn}")<br class="calibre2"/> public Response update(@PathParam("isbn") String isbn, Book book) {<br class="calibre2"/> if (!Objects.equals(isbn, book.getIsbn())) {<br class="calibre2"/>            // return    <br class="calibre2"/>            Response.status(Response.Status.BAD_REQUEST).build();</pre>
<p class="calibre6">There are other ways of doing this as well. A different approach you could choose is to throw a <kbd class="calibre17">WebApplicationException</kbd>, which is part of JAX-RS. You give it a reason and you give it a status code which is <kbd class="calibre17"><span class="calibre4">BAD_REQUEST</span></kbd> again. <span class="calibre10">For the most common types of </span><kbd class="calibre17"><span class="calibre4">WebApplicationException</span></kbd><span class="calibre10">, there are predefined subclasses; in this </span><kbd class="calibre17"><span class="calibre4">WebApplicationException</span></kbd><span class="calibre10">, you can see there are several subclasses available and there's already a </span><kbd class="calibre17">BadRequestException</kbd><span class="calibre10">.</span></p>
<p class="calibre6"><span class="calibre10">Let's use </span><kbd class="calibre17"><span class="calibre4">BadRequestException</span></kbd><span class="calibre10"> instead, and we're done. This </span><kbd class="calibre17"><span class="calibre4">BadRequestException</span></kbd><span class="calibre10"> automatically sets the status code to 400 for us:</span></p>
<pre class="calibre22">    @PUT<br class="calibre2"/>    @Path("/{isbn}")<br class="calibre2"/>    public Response update(@PathParam("isbn") String isbn, Book book) {<br class="calibre2"/>        if (!Objects.equals(isbn, book.getIsbn())) {<br class="calibre2"/>            // throw new WebApplicationException(<br class="calibre2"/>            "ISBN must match path parameter.", <br class="calibre2"/>            Response.Status.BAD_REQUEST);<br class="calibre2"/>            throw new BadRequestException(<br class="calibre2"/>            "ISBN must match path parameter.");<br class="calibre2"/>        }</pre>
<p class="calibre6">Now that's done, of course there are a lot of other exceptions that can happen, such as custom runtime exceptions and persistence exceptions, that might throw our JPA provider. So, how do we handle those? The most convenient way is to have a <kbd class="calibre17">PersistenceExceptionMapper</kbd> implementation. Create a class and implement <kbd class="calibre17"><span class="calibre4">ExceptionMapper</span></kbd>, and use the exception you want to be handled as a generic type. In this case, it's <kbd class="calibre17">PersistenceException</kbd>.</p>
<p class="calibre6">The first thing you need to do is annotate it using the <kbd class="calibre17">@Provider</kbd> annotation. Do that, and then you can implement the custom transformation logic that maps <kbd class="calibre17"><span class="calibre4">PersistenceException</span></kbd> to the actual <kbd class="calibre17">Response</kbd> and the HTTP status code you're expecting. For example, if the exception is an instance of <kbd class="calibre17">EntityNotFoundException</kbd>, we will return 404, which is <kbd class="calibre17">NOT_FOUND</kbd>. In case anything else happens, we want to return a custom error response structure. In this case, we use a plain <kbd class="calibre17">Map</kbd>, a <kbd class="calibre17">HashMap</kbd>, and maybe set a <kbd class="calibre17">code</kbd> and a <kbd class="calibre17">type</kbd>. We include the <kbd class="calibre17">message</kbd> and as a <kbd class="calibre17">Response</kbd>, we return to <kbd class="calibre17">INTERNAL_SERVER_ERROR</kbd>, which is status code 500, and we use <kbd class="calibre17">type</kbd> as <kbd class="calibre17">MediaType.APPLICATION_JSON</kbd>: </p>
<pre class="calibre22">@Provider<br class="calibre2"/>public class PersistenceExceptionMapper implements ExceptionMapper&lt;PersistenceException&gt; {<br class="calibre2"/>    @Override<br class="calibre2"/>    public Response toResponse(PersistenceException exception) {<br class="calibre2"/>        if (exception instanceof EntityNotFoundException) {<br class="calibre2"/>            return Response.status(Status.NOT_FOUND).build();<br class="calibre2"/>        } else {</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<pre class="calibre22">            Map&lt;String, String&gt; response = new HashMap&lt;&gt;();<br class="calibre2"/>            response.put("code", "ERR-4711");<br class="calibre2"/>            response.put("type", "DATABASE");<br class="calibre2"/>            response.put("message", exception.getMessage());<br class="calibre2"/><br class="calibre2"/>            return Response.status(Status.INTERNAL_SERVER_ERROR)<br class="calibre2"/>                    .entity(response)<br class="calibre2"/>                    .type(MediaType.APPLICATION_JSON).build();<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">If we switch to our REST client, we can see those things in action. In case we get an unknown book which should trigger the entity 404 <kbd class="calibre17">NOT_FOUND</kbd> exception, this is what we expect. For example, if we issue a wrong update request for a book, we expect HTTP status code <span class="calibre10">400 Bad Request</span>, as seen in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/50c97a5d-877b-478a-9929-7c334a311ea0.png" class="calibre40"/></p>
<p class="calibre6">This is it on error handling.</p>
<p class="calibre6">In the next section, we will talk about implementing web service clients with Java EE 8.</p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing web service clients with Java EE 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at the JAX-RS client APIs and how to implement web service clients. I'm going to show you how you can set up and configure a JAX-RS client instance. We'll use <kbd class="calibre17">WebTarget</kbd> and its builder to specify request behavior, resolve URI template parameters, do invocation in response handling, and use <kbd class="calibre17">GenericType</kbd> implementations to get unmarshalled typed collections:</p>
<p class="cdpaligncenter"><img src="Images/7663c3c8-e806-4b67-b39a-b5770170889c.png" width="1018" height="473" class="calibre41"/></p>
<div class="mce-root">Conceptual view of this section</div>
<p class="calibre6">So far, we've implemented our small library service, which supports books, authors, and loans, via a REST API. We'll then implement a library client which is a standalone client to get a list of books, unknown books, to create books, to get books with the returned URI, and so forth.</p>
<p class="calibre6">Let's switch to our IDE. We will create a small class called <kbd class="calibre17">LibraryServiceClient</kbd>, which is our standalone application. The first thing we need to do is activate a few dependencies. Most importantly, we want to use the <kbd class="calibre17">jersey-client</kbd> dependency and we'll also <span class="calibre10">be</span><span class="calibre10"> </span><span class="calibre10">using the</span> <kbd class="calibre17">jersey-media-json-binding</kbd> <span class="calibre10">dependency. This is required to implement our standalone application:</span></p>
<pre class="calibre22">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;${jersey.version}&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;${jersey.version}&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;${jersey.version}&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6">The first thing we need to do is construct a JAX-RS client instance, and we use <kbd class="calibre17">ClientBuilder</kbd> to do that. Here, when we use <kbd class="calibre17">ClientBuilder.newBuilder</kbd>, we specify parameters such as <kbd class="calibre17">connectTimeout</kbd> and <kbd class="calibre17">readTimeout</kbd>, we also register <kbd class="calibre17">JsonBindingFeature</kbd>, and then finally we call the <kbd class="calibre17">build()</kbd> method on the builder. Once we have our <kbd class="calibre17">client</kbd>, we can use it to construct what is called a <kbd class="calibre17">WebTarget</kbd>. <kbd class="calibre17">WebTarget</kbd> is basically the endpoint we're going to talk to. We use <kbd class="calibre17">client.target</kbd> and mention <kbd class="calibre17">localhost:8080</kbd> because our service is running locally on <kbd class="calibre17">localhost:8080</kbd>. We give <kbd class="calibre17">path("/library-service/api")</kbd>, which is the root of our REST API:</p>
<pre class="calibre22">public class LibraryServiceClient {<br class="calibre2"/><br class="calibre2"/>    private static final Logger LOGGER = Logger.getAnonymousLogger();<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        // construct a JAX-RS client using the builder<br class="calibre2"/>        Client client = ClientBuilder.newBuilder()<br class="calibre2"/>                .connectTimeout(5, TimeUnit.SECONDS)<br class="calibre2"/>                .readTimeout(5, TimeUnit.SECONDS)<br class="calibre2"/>                .register(JsonBindingFeature.class)<br class="calibre2"/>                .build();<br class="calibre2"/><br class="calibre2"/>        // construct a web target for the library service<br class="calibre2"/>        WebTarget api = client<br class="calibre2"/>          .target("http://localhost:8080")<br class="calibre2"/>          .path("/library-service/api");</pre>
<p class="calibre6">To obtain a list of books, we can use this <kbd class="calibre17">WebTarget</kbd> for the invocation by importing a few things here. What we do is we use <kbd class="calibre17">api.path("/books").request</kbd>, accept <kbd class="calibre17">MediaType.APPLICATION_JSON</kbd>, and then we get a list of books. Because this is a generically typed list, we need to use the <kbd class="calibre17">GenericType</kbd> construct.</p>
<p class="calibre6">We then create a <kbd class="calibre17">GenericType</kbd> subclass and specify <kbd class="calibre17">List&lt;Book&gt;</kbd> as the <kbd class="calibre17">GenericType</kbd> parameter. What if we want to get a book, maybe an unknown book? If we get an unknown book, we expect a status code of 404. Again, we use <kbd class="calibre17">api.path("/books").path("/{isbn}")</kbd>; which is a <kbd class="calibre17">path</kbd> parameter. Therefore we resolve the template using a specific parameter and value. We use <kbd class="calibre17">request</kbd>, <kbd class="calibre17">accept</kbd>, and <kbd class="calibre17">get()</kbd>. By calling <kbd class="calibre17">get()</kbd>, we only get the actual <kbd class="calibre17">response</kbd>, and in that <kbd class="calibre17">response</kbd>, we use <kbd class="calibre17">getStatus()</kbd>, which is <kbd class="calibre17">404</kbd>:</p>
<pre class="calibre22">        LOGGER.log(Level.INFO, "Get list of books.");<br class="calibre2"/>        List&lt;Book&gt; books =  api.path("/books").request()<br class="calibre2"/>          .accept(MediaType.APPLICATION_JSON).get(bookList());<br class="calibre2"/>        books.forEach(book -&gt; LOGGER.log(Level.INFO, "{0}", book));<br class="calibre2"/><br class="calibre2"/>        LOGGER.log(Level.INFO, "Get unknown book by ISBN.");<br class="calibre2"/>        Response response = api.path("/books")<br class="calibre2"/>          .path("/{isbn}").resolveTemplate("isbn", "1234567890")<br class="calibre2"/>          .request().accept(MediaType.APPLICATION_JSON).get();<br class="calibre2"/>        assert response.getStatus() == 404;<br class="calibre2"/>    private static GenericType&lt;List&lt;Book&gt;&gt; bookList() {<br class="calibre2"/>        return new GenericType&lt;List&lt;Book&gt;&gt;() {<br class="calibre2"/>        };<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">If we want to create books, we can do that in a similar way. Again, we create a new book and in here we use <kbd class="calibre17">api.path("/books").requestMediaType.APPLICATION_JSON</kbd>, which specifies the content type of our payload. We use <kbd class="calibre17">post(Entity.json(book))</kbd> and expect a status code of 201. If you want to get hold of the just-created book, what we can do is obtain the <kbd class="calibre17">URI</kbd> of the <kbd class="calibre17">response</kbd>. We get the location and then we use the client again for the target URI, we <kbd class="calibre17">request()</kbd>, we accept <kbd class="calibre17"><span class="calibre4">MediaType.APPLICATION_JSON</span></kbd>, and we get a POJO of the <kbd class="calibre17">Book</kbd> class. In such a case, we automatically get the unmarshalled book back:</p>
<pre class="calibre22">        LOGGER.log(Level.INFO, "Creating new {0}.", book);<br class="calibre2"/>        response = api.path("/books")<br class="calibre2"/>          .request(MediaType.APPLICATION_JSON)<br class="calibre2"/>          .post(Entity.json(book));<br class="calibre2"/>        assert response.getStatus() == 201;<br class="calibre2"/><br class="calibre2"/></pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<pre class="calibre22">        URI bookUri = response.getLocation();<br class="calibre2"/>        LOGGER.log(Level.INFO, "Get created book with URI {0}.", <br class="calibre2"/>          bookUri);<br class="calibre2"/>        Book createdBook = client.target(bookUri)<br class="calibre2"/>          .request().accept(MediaType.APPLICATION_JSON)<br class="calibre2"/>          .get(Book.class);<br class="calibre2"/>        assert book.equals(createdBook);</pre>
<p class="calibre6">This is the basic workings of the JAX-RS client APIs. Last but not least, you should not forget to close the client (<kbd class="calibre17">client.close()</kbd>) to free up any resources. If you want, you can do some cleanup. Maybe we want to delete the book we created previously. We need the following code to delete the book:</p>
<pre class="calibre22">        LOGGER.log(Level.INFO, "Delete book with URI {0}.", bookUri);<br class="calibre2"/>        response = client.target(bookUri).request().delete();<br class="calibre2"/>        assert response.getStatus() == 200;<br class="calibre2"/><br class="calibre2"/>        client.close();<br class="calibre2"/>    }</pre>
<p class="calibre6">This is all there is to it for this section. In the next section, we'll talk about testing Java EE 8 web services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Testing Java EE 8 web services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at different test strategies for Java EE 8 web services. We'll talk about testing simple CDI components with plain unit tests and mocks, testing REST resources using the Jersey Test Framework, and we'll see how to do black box integration testing using the Test Containers framework.</p>
<p class="calibre6">So far, we've implemented our library service by offering a REST API for books, authors, and loans. We also implemented the library client. In this section, we'll talk about testing. You can see the test pyramid in the following diagram. At the bottom, there are unit tests. The middle layer is the service layer tests.</p>
<p class="calibre6"/>
<p class="calibre6">At the top level, you have UI layer tests. Unit testing in Java EE is really simple; you can use your standard test frameworks such as JUnit testing, and you may use Mojito or other mocking frameworks to mock any dependencies:</p>
<p class="cdpaligncenter"><img src="Images/e984dea2-c791-46b4-9c52-7906f5de1470.png" width="1159" height="477" class="calibre42"/></p>
<div class="mce-root">Conceptual view on this section</div>
<p class="calibre6"><span class="calibre10">We won't focus on unit tests here.</span> What's really nice in Java EE is how we can do service level testing. There are two frameworks:</p>
<ul class="calibre14">
<li class="calibre15"> Jersey Test Framework</li>
<li class="calibre15">Test Containers framework</li>
</ul>
<p class="calibre6">Let's use them both.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Jersey Test Framework</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's start with the <strong class="calibre8">Jersey Test Framework</strong>. We will switch to our IDE and in order to use the Jersey Test Framework, you need to add one simple dependency, as follows:</p>
<pre class="calibre22">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.glassfish.jersey.test-  <br class="calibre2"/>          framework.providers&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jersey-test-framework-provider-<br class="calibre2"/>          grizzly2&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;${jersey.version}&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Jersey offers several test providers; in this case, we will be using the <kbd class="calibre17">grizzly2</kbd> provider. What do you need to do to use this test framework? First of all, you need to implement a test class, say <kbd class="calibre17">VersionResourceTest</kbd>, and you need to make it extend the <kbd class="calibre17">JerseyTest</kbd> superclass. Next thing you need to do is override the <kbd class="calibre17">configure</kbd> method, and what you do here is construct a <kbd class="calibre17">ResourceConfig</kbd> and pass the resource you want to test. In our case, we want to test <kbd class="calibre17">VersionResource</kbd>:</p>
<pre class="calibre22">public class VersionResourceTest extends JerseyTest {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected Application configure() {<br class="calibre2"/>        ResourceConfig config = new  <br class="calibre2"/>          ResourceConfig(VersionResource.class);</pre>
<p class="calibre6">The next thing you can do is configure the client that is used to test against our resource. The client here is actually the same one we were using in the previous section, that is, <kbd class="calibre17">JsonBindingFeature</kbd>, and once you've done that, you can implement the actual tests:</p>
<pre class="calibre22">    @Override<br class="calibre2"/>    protected void configureClient(ClientConfig config) {<br class="calibre2"/>        // for JSON-B marshalling<br class="calibre2"/>        config.register(JsonBindingFeature.class);<br class="calibre2"/>    }</pre>
<p class="calibre6">If we want to test the <kbd class="calibre17">v1</kbd> resource, what we can do is specify the target version as <kbd class="calibre17">v1</kbd>. We use <kbd class="calibre17">request</kbd> and <kbd class="calibre17">target</kbd>, and on the <kbd class="calibre17">response</kbd> returned, we can then specify our usual assertions. Then, assert that the response status code is 200 and that the entity of type string contains the string <kbd class="calibre17">"v1.0"</kbd>:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void v1() {<br class="calibre2"/>        Response response = target("/version/v1").request().get();<br class="calibre2"/>        assertThat(response.getStatus(), is(200));<br class="calibre2"/>        assertThat(response.readEntity(String.class), is("v1.0"));<br class="calibre2"/>    }</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Now, let's run our test. You can see here that the test is actually firing up a small <kbd class="calibre17">grizzly</kbd> server that is deploying our resource, and then it's actually firing HTTP calls against our resource. These are the proper integration tests:</p>
<p class="cdpaligncenter"><img src="Images/d97d2b38-fee3-49b2-810c-8ba37e24e5d1.png" width="578" height="363" class="calibre43"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Test Containers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's look at the next test framework, which is called <strong class="calibre8">Test Containers</strong>. We need to add the following two dependencies to activate the Test Containers framework:</p>
<pre class="calibre22">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;testcontainers&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;1.5.1&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;1.7.25&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>
<p class="calibre6"/>
<p class="calibre6">The idea behind Test Containers is really simple. Since we're going to deploy our web service in a Docker container anyway, why not use a Docker container during our test as well? All you need to add is a <kbd class="calibre17">@ClassRule</kbd>. We create <kbd class="calibre17">GenericContainer</kbd>, we pass it to a <kbd class="calibre17">Dockerfile</kbd>, we pass it to the WAR file (<kbd class="calibre17">library-service.war</kbd>) we want to package, we can specify a <kbd class="calibre17">Wait</kbd> strategy, a <kbd class="calibre17">LogConsumer</kbd>, and we expose ports. All this code does is fire up a Docker container when this test starts:</p>
<pre class="calibre22">    @ClassRule<br class="calibre2"/>    public static GenericContainer container = <br class="calibre2"/>      new GenericContainer(new ImageFromDockerfile()<br class="calibre2"/>            .withFileFromFile("Dockerfile", <br class="calibre2"/>              new File(basePath(), "Dockerfile"))<br class="calibre2"/>            .withFileFromFile("target/library-service.war", <br class="calibre2"/>              new File(basePath(), <br class="calibre2"/>              "target/library-service.war")))<br class="calibre2"/>            .waitingFor(Wait.forHttp("<br class="calibre2"/>              /library-service/api/application.wadl")<br class="calibre2"/>                    .withStartupTimeout(Duration.ofSeconds(90)))<br class="calibre2"/>            .withLogConsumer(new Slf4jLogConsumer(<br class="calibre2"/>              LoggerFactory.getLogger(<br class="calibre2"/>              LibraryServiceContainerTest.class)))<br class="calibre2"/>            .withExposedPorts(8080)<br class="calibre2"/>            .withExtraHost("localhost", "127.0.0.1");</pre>
<p class="calibre6">In the <kbd class="calibre17">setUp</kbd> phase, what we can do is we can set up a JAX-RS client instance as we've done previously, and once we have the client, we can set up a web target against the container URI. We can ask for the container IP address and the map port of our service, and once we have the web <kbd class="calibre17">target</kbd>, we can use the JAX-RS client API to interact with our microservice:</p>
<pre class="calibre22">    @Before<br class="calibre2"/>    public void setUp() {<br class="calibre2"/>        client = ClientBuilder.newBuilder()<br class="calibre2"/>                .connectTimeout(5, TimeUnit.SECONDS)<br class="calibre2"/>                .readTimeout(5, TimeUnit.SECONDS)<br class="calibre2"/>                .register(JsonBindingFeature.class)<br class="calibre2"/>                .build();<br class="calibre2"/><br class="calibre2"/>        String uri = String.format("http://%s:%s/library-service/api",<br class="calibre2"/>                container.getContainerIpAddress(),   <br class="calibre2"/>                  container.getMappedPort(8080));<br class="calibre2"/>        api = client.target(uri);<br class="calibre2"/>    }</pre>
<p class="calibre6">Now, run the following command from your console:</p>
<pre class="calibre22"><strong class="calibre3">&gt;mvn integration-test</strong></pre>
<p class="calibre6">What this does is basically run unit tests and integration tests. First up, the Surefire Plugin tests our version resource, we see everything firing up, it runs the other unit tests, packaging the WAR file. The Failsafe Plugin will run our container integration tests. It'll create and start the container; this might take quite a long time. You can see that the tests completed successfully in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/92f8007a-bdcd-4370-8199-0130dc3e09f0.png" width="672" height="318" class="calibre44"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's summarize what we learned in this chapter. We had a look at basic JAX-RS annotations in order to implement a REST API with CRUD functionality. We used top resource locators to nicely model nested REST APIs. We used HTTP status codes and exception mappers for error handling. We implemented web service clients using the JAX-RS service client API. Finally, we had a look at testing Java EE 8-based web services using several approaches. I hope you enjoyed this chapter. In the next chapter, we will talk about content marshaling with JSON-B and JSON-P.</p>


            </article>

            
        </section>
    </div>



  </body></html>