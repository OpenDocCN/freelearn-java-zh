<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Processors</h1>
                </header>
            
            <article>
                
<p>So far in this book, we have been covering the building blocks of Reactive Streams. The publisher, subscriber, and operators represent data manipulation components. Processors, on the other hand, represent the plumbing required to join these components into a single stream of data. In this chapter, we will discuss the types and requirements of processors in detail.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>An introduction to processors</li>
<li>Understanding processor types </li>
<li>Hot versus cold publishers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE, 2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter04</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to processors</h1>
                </header>
            
            <article>
                
<p><span>A processor represents a state of data processing. It is therefore presented as both a publisher and a subscriber. Since it is a publisher, we can create a processor and <kbd>Subscribe</kbd> to it. Most of the functions of a publisher can be performed using a processor; it can inject custom data, as well as generate errors and completion events. We can also interface all operators on it.</span></p>
<p>Consider the following code:</p>
<pre>DirectProcessor&lt;Long&gt; data = DirectProcessor.<span>create</span>();<br/>data.take(<span>2</span>).subscribe(t -&gt; System.<span>out</span>.println(t));<br/>data.onNext(<span>10L</span>);<br/>data.onNext(<span>11L</span>);<br/>data.onNext(<span>12L</span>);</pre>
<p><span>In the preceding code, we did the following things:</span></p>
<ol>
<li>We added an instance of <kbd>DirectProcessor</kbd></li>
<li>In the second line, we added the<span> </span><kbd>take</kbd><span> </span>operator, to select two elements</li>
<li>We also subscribed and printed the data on the console</li>
<li>In the last three lines, we published three data elements</li>
</ol>
<p>Let's take a look at the output, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c4a45beb-9327-456f-9a8a-0c7a1e31c393.png"/></div>
<p>Here, it looks like we can replace the publisher with processors. But if this is the case, why did the Reactive Stream specification ask for two interfaces for the same function? Well, the publisher and processor are not actually the same. Processors are special class publishers that have limited capabilities. They represent a stage of data processing. We will familiarize ourselves with these limitations when we discuss the different types of <span>available p</span><span>rocessors.</span></p>
<p>As a general rule, we should try to refrain from <span>using processors directly. Instead, we should try to look for the following alternatives:</span></p>
<ul>
<li>First, determine an existing operator that can provide the intended functions. Operators should be the first choice for carrying out data manipulation.</li>
<li>If there is no operator available, we should try to adapt the <kbd>Flux.generate</kbd> API and generate a custom stream of data.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding processor types</h1>
                </header>
            
            <article>
                
<p>There are different types of processors available in Reactor. These processors differ in various features, such as backpressure capability, the number of clients they can handle, synchronous invocation, and so on. Let's look at the types of processor available in Reactor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DirectProcessor type</h1>
                </header>
            
            <article>
                
<p><kbd>DirectProcessor</kbd> is the simplest of the processors. This processor connects a processor to a s<span>ubscriber</span>, and then directly invokes the <kbd>Subscriber.onNext</kbd> method. The processor does not offer any backpressure handling.</p>
<p><span>An instance of <kbd>DirectProcessor</kbd> can be created by invoking the <kbd>create()</kbd> method. Any number of subscribers can subscribe to the processor. It must be noted that once the processor has published the complete event, it will reject subsequent data events.</span></p>
<p><span>Consider the following code:</span></p>
<pre>DirectProcessor&lt;Long&gt; data = DirectProcessor.<span>create</span>();<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t),<br/>        e -&gt; e.printStackTrace(),<br/>        () -&gt; System.<span>out</span>.println(<span>"Finished 1"</span>));<br/>data.onNext(<span>10L</span>);<br/>data.onComplete();<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t),<br/>        e -&gt; e.printStackTrace(),<br/>        () -&gt; System.<span>out</span>.println(<span>"Finished 2"</span>));<br/>data.onNext(<span>12L</span>);<br/> </pre>
<p><span>The preceding code does the following:</span></p>
<ol>
<li>Creates an instance of <kbd>Directprocessor</kbd></li>
<li>Adds a subscriber that can print all events (data/error/completion) to the console</li>
<li>Publishes a data event, followed by a completion event</li>
<li>Adds another subscriber, which can print all events (data/error/completion) to the console</li>
<li> Publishes a data event.</li>
</ol>
<p>When we look at the following output screenshot, we can see that all subscribers get the completion event. The data event for the value of <kbd>12</kbd> then gets dropped:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b9103f1-f5ac-4baf-b064-3b5c0a89b8bd.png"/></div>
<p>With respect to the handling of backpressure, <span><kbd>DirectProcessor</kbd> has a</span>nother important limitation. We mentioned previously that it does not have backpressure capability at all. This means that if we push events more than what is asked by the subscriber, it leads to an <kbd>Overflow</kbd> exception.</p>
<p>Let's look at the following code:</p>
<pre>DirectProcessor&lt;Long&gt; data = DirectProcessor.<span>create</span>();<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t),<br/>        e -&gt; e.printStackTrace(),<br/>        () -&gt; System.<span>out</span>.println(<span>"Finished"</span>),<br/>        s -&gt; s.request(<span>1</span>));<br/>data.onNext(<span>10L</span>);<br/>data.onNext(<span>11L</span>);<br/>data.onNext(<span>12L</span>);</pre>
<p><span>The preceding code does the following things:</span></p>
<ol>
<li>Created an instance of<span> </span><kbd>Directprocessor</kbd></li>
<li>Added a subscriber that can print all events (data/error/completion) to the console</li>
<li>The<span> s</span><span>ubscriber </span>also listened to the subscription event and raised a demand of <kbd>1</kbd> data event</li>
<li>Finally, a couple of data events were published</li>
</ol>
<p>The preceding code failed, displaying the following error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61db4c2b-c7c7-4744-b697-796f90ccbabe.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UnicastProcessor type</h1>
                </header>
            
            <article>
                
<p>The <kbd>UnicastProcessor</kbd> type is like the <kbd>DirectProcessor</kbd>, in terms of invocations of the <span><kbd>Subscriber.onNext</kbd> method. It invokes the subscriber method directly. However, unlike the <kbd>DirectProcessor</kbd>, the <kbd>UnicastProcessor</kbd> is capable of backpressure. Internally, it creates a queue to hold undelivered events. We can also provide an optional external queue to buffer the events. After the buffer is full, the processor starts to reject elements. The processor also makes it possible to perform cleanup for every rejected element.</span></p>
<p>The <span><kbd>UnicastProcessor</kbd> provides <kbd>create</kbd> methods to build an instance</span><span> of the processor. Let's take a look at the following code to </span><span>see how this is used:</span></p>
<pre>UnicastProcessor&lt;Long&gt; data = UnicastProcessor.<span>create</span>();<br/>data.subscribe(t -&gt; {<br/>    System.<span>out</span>.println(t);<br/>});<br/>data.sink().next(<span>10L</span>);</pre>
<p>The preceding code did the following things:</p>
<ol>
<li>Created an instance of <span><kbd>UnicastProcessor</kbd></span></li>
<li>Added a subscriber, which can print data events  to the console</li>
<li>Created a <kbd>sink</kbd> to push a couple of elements</li>
</ol>
<p><span>While <kbd>UnicastProcessor</kbd> provides backpressure capability, a major limitation is that only a single </span>subscriber can be worked with. If we add one more subscriber to the preceding code, it will fail with the following error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0876b593-dfd5-4634-93ed-7c9407e942c8.png"/></div>
<div class="packt_tip">Each processor provides a <kbd>Sink</kbd> method. A <kbd>Sink</kbd> is the preferred way of publishing events to the subscriber. It provides methods to publish next, error, and complete events. <kbd>Sink</kbd> provides a thread-safe manner of handling these events, instead of directly publishing them by using the <kbd>Subsciber.OnNext</kbd> method calls.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EmitterProcessor type</h1>
                </header>
            
            <article>
                
<p><kbd>EmitterProcessor</kbd> is a processor that can be used with several subscribers. Multiple subscribers can ask for the next value event, based on their individual rate of consumption. The processor provides the necessary backpressure support for each subscriber. This is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/147b6011-88f2-4f61-ab83-6cdc54361133.png" style=""/></div>
<p>The processor is also capable of publishing events from an external publisher. It consumes an event from the injected publisher and synchronously passes it to the <span>subscribers.</span></p>
<p><span>Let's look at the following code:</span></p>
<pre>EmitterProcessor&lt;Long&gt; data = EmitterProcessor.<span>create</span>(<span>1</span>);<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));<br/>FluxSink&lt;Long&gt; sink = data.sink();<br/>sink.next(<span>10L</span>);<br/>sink.next(<span>11L</span>);<br/>sink.next(<span>12L</span>);<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));<br/>sink.next(<span>13L</span>);<br/>sink.next(<span>14L</span>);<br/>sink.next(<span>15L</span>);</pre>
<p>The preceding code did the following:</p>
<ol>
<li>Created an instance of<span> </span><kbd><span>EmitterProcessor</span></kbd></li>
<li>Added a subscriber, which can print data events to the console</li>
<li>Created a <kbd>sink</kbd> to push a couple of elements</li>
<li>Added another subscriber, which can print data events to the console</li>
<li>Pushed more events by using the Sink API</li>
</ol>
<p><span>The preceding code builds the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0f6e072-5d27-46a8-ad37-c4e14c598eda.png"/></div>
<p><span>The preceding code also made the following clear:</span></p>
<ul>
<li>Both subscribers print items to the console.</li>
<li>The processor delivers events to a subscriber after its subscription. This is different from Flux, which delivers all items to all subscribers, irrespective of the time of subscription.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ReplayProcessor type</h1>
                </header>
            
            <article>
                
<p><kbd>ReplayProcessor</kbd> is a special-purpose processor, capable of caching and replaying events to its subscribers. <span>The processor also has the capability of publishing events from an external publisher. It consumes an event from the injected publisher and synchronously passes it to the </span><span>subscribers.</span></p>
<p><kbd>ReplayProcessor</kbd> can cache events for the following scenarios:</p>
<ul>
<li>All events</li>
<li>A limited count of events</li>
<li>Events bounded by a specified time period</li>
<li>Events bounded by a count and a specified time period</li>
<li>The last event only</li>
</ul>
<div class="cdp-book-comment-container CDPAlignCenter CDPAlign">
<p> Once cached, all events are replayed when a subscriber is added:</p>
<img src="assets/cac7358b-5570-4c04-8cc8-0fb7c370985b.png" style="width:28.75em;height:17.83em;"/></div>
<p> </p>
<p><span>Let's look at the following code:</span></p>
<pre><span>ReplayProcessor</span>&lt;Long&gt; data = <span>ReplayProcessor</span>.<span>create</span>(<span>3</span>);<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));<br/>FluxSink&lt;Long&gt; sink = data.sink();<br/>sink.next(<span>10L</span>);<br/>sink.next(<span>11L</span>);<br/>sink.next(<span>12L</span>);<br/>sink.next(<span>13L</span>);<br/>sink.next(<span>14L</span>);<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));</pre>
<p class="mce-root"/>
<p><span>The preceding code did the following things:</span></p>
<ol>
<li>Created an instance of <kbd>ReplayProcessor</kbd>, <span>with a cache of three events</span></li>
<li>Added a subscriber, which can print data events to the console</li>
<li>Created a <kbd>sink</kbd> to push a couple of elements</li>
<li>Added another subscriber, which can print data events to the console</li>
</ol>
<p><span>The preceding code builds the following output:</span></p>
<ul>
<li>The processor caches the last three events, namely, <kbd>12</kbd>, <kbd>13</kbd>, and <kbd>14</kbd></li>
<li>When the second subscriber connects, it prints the cached events on the console</li>
</ul>
<p>A screenshot of the output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/79180414-aa8b-4ce8-935f-bc97aa3fc610.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The TopicProcessor type</h1>
                </header>
            
            <article>
                
<p><kbd>TopicProcessor</kbd> is a processor capable of working with multiple subscribers, using an event loop architecture. The processor delivers events from a publisher to the attached subscribers in an <span>asynchronous manner, and</span> honors backpressure for each subscriber by using the <kbd>RingBuffer</kbd> data structure. The processor is also capable of listening to events from multiple publishers. This is illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ebb5070b-070d-4c61-a738-26f692eb3d4d.png" style=""/></div>
<p>Unlike the processors that deliver events in an ordered manner, <kbd>TopicProcessor</kbd> is capable of delivering events to subscribers in a concurrent manner. This is governed by the number of threads created in the processor.</p>
<p>Let's look at the following code:</p>
<pre><span>TopicProcessor</span>&lt;Long&gt; data = <span>TopicProcessor</span>.&lt;Long&gt;<span>builder</span>()<br/>        .executor(Executors.<span>newFixedThreadPool</span>(<span>2</span>)).build();<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));<br/>data.subscribe(t -&gt; System.<span>out</span>.println(t));<br/>FluxSink&lt;Long&gt; sink= data.sink();<br/>sink.next(<span>10L</span>);<br/>sink.next(<span>11L</span>);<br/>sink.next(<span>12L</span>);</pre>
<p><span>The preceding code did the following things:</span></p>
<ol>
<li>Created an instance of <kbd>TopicProcessor</kbd> by <span>using the provided builder</span></li>
<li>Provided a <kbd>ThreadPool</kbd> of size <kbd>2</kbd>, in order to connect two subscribers to it</li>
<li>Added two subscriber instances, which can print data events to the console</li>
<li>Created a <kbd>sink</kbd> to push a couple of elements</li>
</ol>
<p><span>The preceding code builds the following output, and t</span><span><span>he processor delivers events to both</span> subscribers concurrently:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/35a1aceb-d476-4f13-aff2-fab38fbe203a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WorkQueueProcessor type</h1>
                </header>
            
            <article>
                
<p>The <kbd>WorkQueueProcessor</kbd> type is similar to the <kbd>TopicProcessor</kbd>, in that it can connect to multiple subscribers. However, it does not deliver all events to each subscriber. The demand from every subscriber is added to a queue, and events from a publisher are sent to any of the subscribers. The model is more like having listeners on a JMS queue; each listener consumes a message when finished. The processor delivers messages to each of the subscribers in a round-robin manner. <span>The processor is also capable of listening to events from multiple publishers. This is depicted in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c294fc3-4c0f-4507-9691-422d02ab49c6.png" style=""/></div>
<div class="packt_tip">The processor is better in terms of resource requirements, as it does not build a thread pool for its subscribers.</div>
<p>Let's look at the following code:</p>
<pre><span>WorkQueueProcessor</span>&lt;Long&gt; data = <span>WorkQueueProcessor</span>.&lt;Long&gt;<span>builder</span>().build();<br/>data.subscribe(t -&gt; System.<span>out</span>.println(<span>"1. "</span>+t));<br/>data.subscribe(t -&gt; System.<span>out</span>.println(<span>"2. "</span>+t));<br/>FluxSink&lt;Long&gt; sink= data.sink();<br/>sink.next(<span>10L</span>);<br/>sink.next(<span>11L</span>);<br/>sink.next(<span>12L</span>);</pre>
<p><span>The preceding code did the following things:</span></p>
<ol>
<li>Created an instance of <kbd>WorkQueueProcessor</kbd><span> by using the provided builder.</span></li>
<li>Added two subscriber instances, which can print data events to the console. Each subscriber prints its ID, as well.</li>
<li>Created a <kbd>sink</kbd> to push a couple of elements.</li>
</ol>
<p><span>The preceding code builds the following output. T</span><span>he processor delivers a few events to the first subscriber, with the rest being delivered to the second subscriber:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d5b1025-d2e0-40e5-9e42-9e5e0f5444c2.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot versus Cold publishers</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we built publishers that would start publishing data to each of the subscriber instances after subscription. The Fibonacci publisher that we created in <a href="2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml" target="_blank">Chapter 2</a>, <em>The Publisher and Subscriber APIs in a Reactor</em>, <a href="2886252b-5c5e-4b42-ab25-dd1145fe9d60.xhtml" target="_blank"/>would publish the complete Fibonacci series to each of its subscribers.</p>
<p>Consider the following Fibonacci code as a cold publisher:</p>
<pre style="padding-left: 30px">Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(<br/>        () -&gt; Tuples.&lt;Long, Long&gt;of(0L, 1L),<br/>        (state, sink) -&gt; {<br/>            sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/><br/>fibonacciGenerator.take(5).subscribe(t -&gt; System.out.println("1. "+t));<br/>fibonacciGenerator.take(5).subscribe(t -&gt; System.out.println("2. "+t));</pre>
<p>Publishers that start publishing data to the subscriber after subscription are known as <strong>cold publishers</strong>. It is important to understand that the data should be generated post-subscription. If there is no subscriber, then the publisher will not generate any data.</p>
<p>Let's take a look at the output of the preceding cold publisher. Here, both subscribers print the complete set of Fibonacci numbers:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3396009c-c160-435c-b4a4-73f5259deb3c.png"/></div>
<p>In the current chapter, we have used the processors as publishers, which do not depend on the subscriber. These publishers keep emitting data, and, when a new subscriber arrives, it receives only newly emitted data. This is different from cold publisher behavior, which also publishes old data for every new subscriber. These publishers are known as <strong>hot publishers</strong>.</p>
<p>In the following code, we have converted a Fibonacci publisher into a hot publisher:</p>
<pre><span>final </span>UnicastProcessor&lt;Long&gt; hotSource = UnicastProcessor.<span>create</span>();<br/><span>final </span>Flux&lt;Long&gt; hotFlux = hotSource.publish().autoConnect();<br/>hotFlux.take(<span>5</span>).subscribe(t -&gt; System.<span>out</span>.println(<span>"1. " </span>+ t));<br/>CountDownLatch latch = <span>new </span>CountDownLatch(<span>2</span>);<br/><span>new </span>Thread(() -&gt; {<br/>    <span>int </span>c1 = <span>0</span>, c2 = <span>1</span>;<br/>    <span>while </span>(c1 &lt; <span>1000</span>) {<br/>        <span>hotSource</span>.onNext(Long.<span>valueOf</span>(c1));<br/>        <span>int </span>sum = c1 + c2;<br/>        c1 = c2;<br/>        c2 = sum;<br/>        <span>if</span>(c1 == <span>144</span>) {<br/>            <span>hotFlux</span>.subscribe(t -&gt; System.<span>out</span>.println(<span>"2. " </span>+ t));<br/>        }<br/>    }<br/>    <span>hotSource</span>.onComplete();<br/>    <span>latch</span>.countDown();<br/>}).start();<br/>latch.await();</pre>
<p><span>The preceding code illustrates the following:</span></p>
<ol>
<li>We built a <kbd>UnicastProcessor</kbd> and converted it to a <kbd>Flux</kbd> by using the <kbd>publish</kbd> method</li>
<li>We then added a subscriber to it</li>
<li>Next, we created a <kbd>Thread</kbd> and used the <kbd>UnicastProcessor</kbd> instance (created previously) to generate the Fibonacci series</li>
<li>Another subscriber is added when the series value is <kbd>144</kbd></li>
</ol>
<p>Let's take a look at the output of the hot publisher:</p>
<ul>
<li>The first subscriber prints the initial values. </li>
<li>The second subscriber prints values that are greater than <kbd>143</kbd>. This is shown in the following screenshot:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/45d41277-e172-46db-8d1e-929209f4bf9a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored the various kinds of processors that are available in Reactor. You learned that the <kbd>DirectProcessor</kbd> is the simplest processor, but it does not offer backpressure. We then discussed the functions and abilities of <kbd>UnicastProcessor</kbd>, <kbd>EmmiterProcessor</kbd>, <kbd>ReplayProcessor</kbd>, <kbd>TopicProcessor</kbd>, and <kbd>WorkQueueProcessor</kbd>. In the end, we familiarized ourselves with hot and cold publishers, ultimately using <kbd>UnicastProcessor</kbd> to convert a Fibonacci generator into a hot publisher.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the limitations of <kbd>DirectProcessor</kbd>?</li>
<li>What are the limitations of <kbd>UnicastProcessor</kbd>?</li>
<li>What are the capabilities of <kbd>EmitterProcessor</kbd>?</li>
<li>What are the <span>capabilities </span>of <kbd>ReplayProcessor</kbd>?</li>
<li>What are the <span>capabilities</span><span> </span>of <kbd>TopicProcessor</kbd>?</li>
<li>What are the <span>capabilities</span><span> </span>of <kbd>WorkQueueProcessor</kbd>?</li>
<li>What is the difference between a hot publisher and a cold publisher?</li>
</ol>


            </article>

            
        </section>
    </body></html>