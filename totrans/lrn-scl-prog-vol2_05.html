<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Object-Oriented Scala Basics</h1>
                
            
            <article>
                
<div class="packt_quote">"There is a central quality which is the root criterion of life and spirit of a man, a town, a building, or a wilderness. This quality is subjective and precise."</div>
<div class="packt_quote1">- The Timeless Way of Building</div>
<p class="calibre2">Scala is an obvious choice for many programmers because of the goodies it contains. It's a language that's functional as well as object-oriented, which means a lot to programmers. It gives us a way of building our applications in a modular and meaningful fashion. It's important to know that Scala's functional concepts are essential, powerful, and at the core of our programs. There is no doubt that algebraic data types have provided the essential abstractions and immutable data structures that have allowed the code to work in a concurrent environment. But real-world applications could need much more than that. Often, the amount of code we write makes it essential to have a way of managing it. That's where object-oriented abstractions come to the rescue. It's great to learn that we now have classes and objects that provide a way to create manageable code. In the next few chapters, we'll equip ourselves with these object-oriented concepts in Scala, and they will help us later when we'll start to use functional concepts and abstractions <span>more and more</span>.</p>
<p class="calibre2">You're probably familiar with object-oriented basics if you're coming from Java or any other object-oriented language background. If not, we'll discuss the concepts as we go along. Mainly, when we discuss object-oriented principles, we come up with four core principles, namely: <em class="calibre18">abstraction</em>, <em class="calibre18">encapsulation</em>, <em class="calibre18">inheritance</em>, and <em class="calibre18">polymorphism</em>. They work as their names suggest. For example, <em class="calibre18">abstraction</em> is basically hiding the concrete or internal processing of a task or process, in simpler words, making something abstract. In Scala, we have abstract classes, traits, and a few other concepts, which provide abstraction. <em class="calibre18">Classes</em> and <em class="calibre18">objects</em> are a way to provide <em class="calibre18">encapsulation,</em> basically encapsulating a meaningful piece of code in a unit.</p>
<p class="calibre2">There's a way we can inherit members and their behaviors from parent classes and put them into other classes known as child classes. This property is known as <em class="calibre18">inheritance</em>. Finally, <em class="calibre18">polymorphism</em>, as the name suggests, means different ways to define and perform one operation. One of the examples of polymorphism is method overriding.</p>
<p class="calibre2">This chapter is a basic introduction to classes and objects in Scala. To make our agenda clear, we'll mainly go through three topics in this chapter:</p>
<ul class="calibre7">
<li class="calibre8">Classes</li>
<li class="calibre8">Objects</li>
<li class="calibre8">Case classes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classes</h1>
                
            
            <article>
                
<p class="calibre2">To understand classes in Scala, let's make it clear that classes don't just do one thing for us. Classes work as a container for members in our programs, and as in any other object-oriented language, we can create instances of our class constructs and reuse them. By members we mean the variables and methods defined within. Why not take a look at a simple Scala class?</p>
<pre class="calibre19">class Country(var name: String, var capital: String) </pre>
<p class="calibre2">Yes, the preceding code is a class that we defined named <kbd class="calibre11">Country</kbd><em class="calibre18">.</em> It has two members named <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd><em class="calibre18">.</em> Let's create a new country instance and print its values:</p>
<pre class="calibre19">object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  println(s"Country Name: ${country.name} and Capital: ${country.capital}") 
} </pre>
<p class="calibre2">On running the preceding code, we get the following result:</p>
<pre class="calibre19">Country Name: France and Capital: Paris </pre>
<p class="calibre2">Now, believe me, it's going to be hard to resist Scala once I tell you that a class in Java with the same capabilities would need a few more lines. Take a look at the following code:</p>
<pre class="calibre19">public class CountryJava { 
    private String name; 
    private String capital; 
 
    public CountryJava(String name, String capital){ 
        this.name = name; 
        this.capital = capital; 
    } 
 
    public void setName(String name){this.name = name;} 
    public String getName(){return this.name;} 
 
    public void setCapital(String capital){this.capital = capital;} 
    public String getCapital(){return this.capital;}<br class="title-page-name"/> } </pre>
<p class="calibre2">This still isn't finished. We'll now create an instance and print the country object:</p>
<pre class="calibre19">class CountryJavaApp { 
    public static void main(String[] args) { 
        CountryJava country = new CountryJava("France", "Paris"); 
        System.out.println("Country Name: "+ country.getName() + " and Capital: "+ country.getCapital()); 
    } 
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Country Name: France and Capital: Paris </pre>
<p class="calibre2">The reason why we're differentiating based on the way we define classes is to see the conciseness. A lot of unnecessary or boilerplate code has been omitted. Accessors for our members such as <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd> are still there due to the <kbd class="calibre11">var</kbd> <span>keyword </span>we added while defining our class.</p>
<p class="calibre2">Let's try to omit the <kbd class="calibre11">var</kbd> or <kbd class="calibre11">val</kbd> keyword as part of the class constructor:</p>
<pre class="calibre19">class Country(name: String, capital: String) </pre>
<p class="calibre2">These two, <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd>, will remain as class constructor arguments. Their scope will be limited; it won't be possible to use these arguments outside the class scope. To understand better, think of a class constructor as a method with some parameters. While calling the method, we pass a certain number of arguments and their scope is limited to the definition of the function. The same happens with Scala classes. You can think of some use cases when it comes to using class constructor arguments:</p>
<pre class="calibre19">println(s"Country Name: ${country.name} and Capital: ${country.capital}") </pre>
<p class="calibre2">The compiler will not let you access <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd> members.</p>
<p class="calibre2">When we use the <kbd class="calibre11">var</kbd> keyword as a modifier of our constructor arguments, we get access to these arguments. So, if you instantiate your <kbd class="calibre11">Country</kbd> object outside this class, you'll get a reference to these two fields and you can access them. Adding <kbd class="calibre11">var</kbd> as a prefix lets you reassign the parameter's value; that's not a good idea though. The following code snippet does the same:</p>
<pre class="calibre19">object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  country.name = "Germany" 
  country.capital = "Berlin" 
  println(s"Country Name: ${country.name} and Capital: ${country.capital}") 
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Country Name: Germany and Capital: Berlin </pre>
<p class="calibre2">The same happens with the <kbd class="calibre11">val</kbd> keyword. The only difference is that <kbd class="calibre11">val</kbd> parameters can only be read and not mutated. So in other words, your members become immutable:</p>
<pre class="calibre19">class Country(val name: String, val capital: String) </pre>
<p class="calibre2">The preceding definition lets you access the members named <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd> but it won't let you change the value of <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd> once an instance is instantiated:</p>
<pre class="calibre19">country.name = "Germany" 
country.capital = "Berlin" </pre>
<p class="calibre2">If you try to do this, the compiler will come up with an error stating, <kbd class="calibre11">reassignment to val</kbd>. There's another construct that lets you do this, which means you don't actually put <kbd class="calibre11">val</kbd> in constructor arguments, but use a <kbd class="calibre11">case</kbd> class instead. Defining a <kbd class="calibre11">case</kbd> class is as easy as defining any other class:</p>
<pre class="calibre19">case class Country(name: String, capital: String) </pre>
<p class="calibre2">Writing a <kbd class="calibre11">case</kbd> class with arguments by default means it takes them as immutable parameters; there is no need to explicitly make them a <kbd class="calibre11">val</kbd>. We'll learn more about case classes in subsequent topics. We can also declare some methods in our classes, and those methods are going to be specific to the instance of our classes. For example, let's add a method that gives the population for a given year. To make it work, we'll add a map with the year and population in millions. The following is just for illustration purposes:</p>
<pre class="calibre19">class Country(val name: String, val capital: String){ 
  var populationMap = scala.collection.mutable.Map[String, Double]() 
   
  def getPopulation(year: String): Double = populationMap(year) //In Million 
} 
 
object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  country.populationMap += ("2015" -&gt; 64.39) += ("2016" -&gt; 64.67) += ("2017" -&gt; 64.93) 
  println(s"Country Name: ${country.name} and Population 2017: ${country.getPopulation("2017")} million") 
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Country Name: France and Population 2017: 64.93 million </pre>
<p class="calibre2">In the preceding class definition, we have defined a mutable map for <kbd class="calibre11">population</kbd> that stores the population of a country based on the year as a key. Passing a year will return the population in millions for that year. Now, every instance of the <kbd class="calibre11">country</kbd> class is going to contain a separate reference to these members. You can picture it as a separate <kbd class="calibre11">name</kbd><em class="calibre18">,</em> <kbd class="calibre11">capital</kbd><em class="calibre18">,</em> <kbd class="calibre11">populationMap</kbd>, and <kbd class="calibre11">getPopulation</kbd> method for each instance that we create. Then, values that we give to these members are also separate from each other. It's possible, though, that we have two separate references pointing to the same value in cases where we have different values for our instance members pointing to different value objects. Let's take a look at the following figure to make it clearer:</p>
<div class="cdpaligncenter"><img src="../images/00026.jpeg" class="calibre35"/></div>
<div class="cdpaligncenter1">Class instances</div>
<p class="calibre2">It's important to know that when we compile our classes, they get converted to their Java equivalent code. A class with <kbd class="calibre11">var</kbd> constructor parameters when converted to the Java equivalent looks as follows:</p>
<pre class="calibre19">public class chapter6.Country { 
     public java.lang.String name(); 
     public void name_$eq(java.lang.String); 
     public java.lang.String capital(); 
     public void capital_$eq(java.lang.String); 
     public chapter6.Country(java.lang.String, java.lang.String); 
} </pre>
<p class="calibre2">The preceding methods, <kbd class="calibre11">name()</kbd> and <kbd class="calibre11">capital()</kbd><em class="calibre18">,</em> work as <em class="calibre18">getters</em> and return the values for these two fields. The other two are methods named <kbd class="calibre11">name_$eq</kbd> and <kbd class="calibre11">capital_$eq</kbd><em class="calibre18">.</em> We can use these methods to assign values:</p>
<pre class="calibre19">object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  country.name_=("Germany") 
  country.capital_=("Berlin") 
  println(s"Country Name: ${country.name} and <br class="title-page-name"/>                    capital: ${country.capital}") 
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Country Name: Germany and capital: Berlin </pre>
<p class="calibre2">It shows that we don't explicitly create these mutator methods, but the Scala compiler does this job for us. Note, <kbd class="calibre11">name_$eq</kbd> represents <kbd class="calibre11">name_=</kbd> and nothing more. Finally, the last method represented in the compiled form is actually a constructor for our <kbd class="calibre11">Country</kbd><em class="calibre18"> </em><span>class</span>.</p>
<p class="calibre2">Class constructors where we use <kbd class="calibre11">val</kbd> don't get access to mutator methods. It means that the compiled form of the class does not contain mutator methods: </p>
<pre class="calibre19">public class chapter6.Country { 
    public java.lang.String name(); 
    public java.lang.String capital(); 
    public chapter6.Country(java.lang.String, java.lang.String); 
} </pre>
<p class="calibre2">The preceding code is the compiled form of our <kbd class="calibre11">Country</kbd> class with <kbd class="calibre11">val</kbd> arguments. Here, we have access to only accessor methods and not mutators.</p>
<p class="calibre2">By default, all the members that we define work as public members. This means it's possible to access them outside the class. We can make them private just by adding a <kbd class="calibre11">private</kbd> modifier:</p>
<pre class="calibre19">private def getPopulation(year: String): Double = populationMap(year) <br class="title-page-name"/>//In Million </pre>
<p class="calibre2">To illustrate this, let's make our <kbd class="calibre11">getPopulation(year: String)</kbd> <span>method </span>private. After that, we won't be able to perform this operation outside this class, even with an instance of the <kbd class="calibre11">Country</kbd> class:</p>
<pre class="calibre19">println(s"Country Name: ${country.name} and Population 2017: ${country.getPopulation("2017")} million")</pre>
<p class="calibre2">The Scala compiler won't let you perform this operation. Another thing to note about classes in Scala is that you have to define <kbd class="calibre11">toString</kbd>, <kbd class="calibre11">equals</kbd>, and <kbd class="calibre11">hashCode</kbd> implementation for your classes. These methods are essential if you want Scala to print your class instance in some particular format or perform equality operations. To remove this boilerplate, it's recommended to use case classes. Without defining these methods, try running the following:</p>
<pre class="calibre19">val country = new Country("France", "Paris") 
println(country) </pre>
<p class="calibre2">Scala will print the runtime instance as it is, that is, <kbd class="calibre11">Country@2d209079</kbd><em class="calibre18">.</em> To make this meaningful, we can override the <kbd class="calibre11">toString</kbd> method and give its definition:</p>
<pre class="calibre19">class Country(val name: String, val capital: String){ 
  override def toString: String = s"Country($name, $capital)" 
} </pre>
<p class="calibre2">Now, if you try printing an instance of <kbd class="calibre11">Country</kbd><em class="calibre18">,</em> it will print in the preceding format:</p>
<pre class="calibre19">val country = new Country("France", "Paris") 
println(country) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Country(France, Paris) </pre>
<p class="calibre2">Sometimes we want to create classes that are abstract, contain nothing but the class name, and indicate a type that some subsequent classes do want to inherit. We declare these as abstract classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract classes</h1>
                
            
            <article>
                
<p class="calibre2">We can define abstract classes using the <kbd class="calibre11">abstract</kbd><em class="calibre18"> </em>keyword<em class="calibre18">:</em></p>
<pre class="calibre19">abstract class Person 
class Customer extends Person 
class Employee extends Person </pre>
<p class="calibre2">Here, what we wanted was two subclasses that can also be treated as instances of a superclass, in our case, <kbd class="calibre11">Person</kbd><em class="calibre18">.</em> For now, we have not shown any behavior in our abstract class. But, there are times when we want to imply some behaviors in our abstract classes that subsequent subclasses can inherit and define for themselves:</p>
<pre class="calibre19">abstract class Person(category: String) { 
  val idPrefix: String 
} 
 
class Customer extends Person("External") { 
  override val idPrefix: String = "CUST" 
} 
 
class Employee extends Person("Internal") { 
  override val idPrefix: String = "EMP" 
} </pre>
<p class="calibre2">Our intention to use abstract classes is clearer now. We may want a set of classes that inherit methods or values from a particular class. When we extend classes, we can use the <kbd class="calibre11">override</kbd> modifier in our definition. This kind of behavior is likely to present itself in one more concept we have in Scala, that is, a trait<em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract classes and traits</h1>
                
            
            <article>
                
<p class="calibre2">It's possible for you to declare things like the following:</p>
<pre class="calibre19">trait Person { 
  val category: String 
  val idPrefix: String 
} 
 
class Customer extends Person { 
  override val category: String = "External" 
  override val idPrefix: String = "CUST" 
} 
 
class Employee extends Person { 
  override val category: String = "Internal" 
  override val idPrefix: String = "EMP" 
} </pre>
<p class="calibre2">Here, we used a trait<em class="calibre18">.</em> We'll learn more about traits in the next chapter. For now, let's see how they are different to abstract classes. We may be able to see that we've provided constructor parameters in abstract classes; this is not possible with traits:</p>
<pre class="calibre19">abstract class Person(category: String) //can give cons params 
 
trait Person(category: String) //can't give cons params  </pre>
<p class="calibre2">We cannot give constructor parameters for traits. However, we can, give a definition of methods in both abstract classes and traits. This is not the only way we may want to use classes. It's also possible that you don't want any other class to inherit from your classes. In those scenarios, we may declare the class using the <kbd class="calibre11">final</kbd> keyword.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The final classes</h1>
                
            
            <article>
                
<p class="calibre2">If you're coming from a Java background, you may have this idea of a <kbd class="calibre11">String</kbd> class:</p>
<pre class="calibre19">public final class String extends Object </pre>
<p class="calibre2">The <kbd class="calibre11">final</kbd> <span>keyword</span><span> </span><span>tells you that you can't inherit from the</span> <kbd class="calibre11">String</kbd><em class="calibre18"> </em><span>class</span><em class="calibre18">.</em><span> In the same way, we can also use this</span> <kbd class="calibre11">final</kbd> <span>keyword to make classes with behaviors that can't be modified or inherited by any other classes. You've got the idea. If you make our</span> <kbd class="calibre11">Person</kbd> <span>class final then you won't be able to inherit it. It's weird though, in Scala you can declare a class as</span> final <span>as well as</span> <kbd class="calibre11">abstract</kbd><em class="calibre18">.</em> <span>Yes, it's possible in the following way:</span></p>
<pre class="calibre19">scala&gt; abstract final class Person 
defined class Person 
 
scala&gt; class Employee extends Person 
&lt;console&gt;:12: error: illegal inheritance from final class Person 
       class Employee extends Person </pre>
<p class="calibre2">Thankfully, the compiler doesn't let us inherit from abstract final classes. It would be great if you could find use cases though. For instant gratification, you may want to search for phantom types in Scala and think of use cases for our, can't instantiate or inherit abstract classes.</p>
<p class="calibre2">Also, if you're coming from an object-oriented programming background, or have an idea about <kbd class="calibre11">static</kbd> members in Java, you may be thinking, how do we achieve that in Scala? The basic usage of a static class or static member is that, for those that have only one instance, that particular member will be the same for all instances of a particular class. If you change the value of a static member, it'll be changed for all instances. You'll be getting more of an idea of what we're talking about in the next topic that we're going to discuss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Objects as singletons</h1>
                
            
            <article>
                
<p class="calibre2">There are no static members or classes in Scala. Once you feel the need to create a static member, for example a static method or a class that is going to have only one instance, you should create an object. Yes, up until now, almost all the time we have been creating an object that extends the <kbd class="calibre11">App</kbd> trait so that we don't have to define the <kbd class="calibre11">main</kbd> method. This is the entry point to our application. So, it's also obvious that when we mention <kbd class="calibre11">object</kbd><em class="calibre18">,</em> we don't mean an instance of any class; rather, an <kbd class="calibre11">object</kbd> in Scala has a different meaning.</p>
<p class="calibre2">An object<em class="calibre18">,</em> just like classes, is a container for functions and values. The reason why we may want to declare an object is so we can define utility methods for any particular type, or sometimes define JSON formatters and similar use cases. Let's take another look at how we can define an object<em class="calibre18">:</em></p>
<pre class="calibre19">object CountryUtil { 
   
} </pre>
<p class="calibre2">Looks like we just created an object. Nothing fancy, just an <kbd class="calibre11">object</kbd> <span>keyword </span>along with the name of the object. We know that objects are singletons, hence it does not make any sense to pass arguments in the constructor and therefore, Scala doesn't allow you to do so. That's it. Why not use your <kbd class="calibre11">CountryUtil</kbd> object to define some utility methods such as a method that takes a sequence of populations and returns the average of them? Let's try that in the following code:</p>
<pre class="calibre19">object CountryUtil { 
  /* 
  * Function takes a sequence of population per million and returns average. 
  * */ 
  def populationAverage(pops: Seq[Double]) = pops.sum / pops.length 
} 
 
object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  country.populationMap += ("2015" -&gt; 64.39) += ("2016" -&gt; 64.67) += ("2017" -&gt; 64.93) 
 
  println(s"Country Name: ${country.name} and Population 2017: ${country.getPopulation("2017")} million") 
 
  println(s"${country.name}'s average population: ${CountryUtil.populationAverage(country.populationMap.values.toSeq)}") 
   
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Country Name: France and Population 2017: 64.93 million 
France's average population: 64.66333333333334 </pre>
<p class="calibre2">And here we are, with the average population of France for the years we wanted. We achieved this by passing the map to our utility function named <kbd class="calibre11">populationAverage</kbd> that takes a sequence of population values in millions. The idea here was to present a container that can contain utility methods for a class, and that's why we have objects.</p>
<p class="calibre2">In case you're wondering, if it's possible to extend from an object:</p>
<pre class="calibre19">class WeCant extends CountryUtil { 
} <br class="title-page-name"/>// Sorry we can't extend from an object </pre>
<p class="calibre2">No, we cannot. The first reason is that it's unintended. Secondly, the Scala compiler creates a compiled Java version of our objects, which is a <kbd class="calibre11">final</kbd> class. What happens when we create an <em class="calibre18">object</em> and it gets compiled? Scala creates a few class files based on the modifiers you choose. In our case, if you compile the <kbd class="calibre11">CountryUtil</kbd> object, the compiler creates <kbd class="calibre11">CountryUtil.class</kbd> and <kbd class="calibre11">CountryUtil$.class</kbd><em class="calibre18">,</em> and these are final by nature. Let's take a look at these.</p>
<p class="calibre2">The following is an implementation of the <kbd class="calibre11">CountryUtil.class</kbd> class:</p>
<pre class="calibre19">public final class chapter6.CountryUtil { 
  public static double populationAverage(scala.collection.Seq&lt;java.lang.Object&gt;); 
} </pre>
<p class="calibre2"><span>The following is an implementation of the </span><kbd class="calibre11">CountryUtil$.class</kbd> class:</p>
<pre class="calibre19">public final class chapter6.CountryUtil$ { 
  public static chapter6.CountryUtil$ MODULE$; 
  public static {}; 
  public double populationAverage(scala.collection.Seq&lt;java.lang.Object&gt;); 
} </pre>
<p class="calibre2">Yes, this is quite some Java code. You may not be very interested in the details right now, but two things to look out for are the keywords <kbd class="calibre11">static</kbd> and <kbd class="calibre11">final</kbd><em class="calibre18">.</em> First, these two classes are <kbd class="calibre11">final</kbd>, as we discussed, and the utility method is <kbd class="calibre11">static</kbd>. Thus, you may get an idea of what <span>the Scala compiler</span> is cooking in the background. Great. Also, this does not stop you from extending a class or trait from an object. Hence, writing something like the following is possible:</p>
<p class="calibre2"> </p>
<pre class="calibre19">class Continent 
 
object CountryUtil extends Continent { 
      //some code here 
} </pre>
<p class="calibre2">Well, that said, let's discuss more use cases of objects in Scala. We all know that we can define utility methods for a particular class in Scala objects. Using them is also easy, plus these utility methods can be used from anywhere. All you need to do is to add an <kbd class="calibre11">import</kbd> statement:</p>
<p class="calibre2"> </p>
<pre class="calibre19">import java.time.LocalDate 
import java.time.format.{DateTimeFormatter, TextStyle} 
import java.util.Locale 
import scala.util.{Failure, Success, Try} 
 
object DateUtil { 
  /* 
  * Just pass a date with format DD/MM/YYYY, get back DAY_OF_WEEK 
  * */ 
  def dayOfWeek(date: String): Option[String] = Try{ 
      LocalDate.parse(date, DateTimeFormatter.ofPattern("dd/MM/yyyy")).getDayOfWeek 
    } match { 
      case Success(dayOfWeek) =&gt; Some(dayOfWeek.getDisplayName(TextStyle.FULL, Locale.ENGLISH)) 
      case Failure(exp) =&gt; exp.printStackTrace; None 
    } 
} 
 
object TestDateUtil extends App { 
  import DateUtil._ 
 
  val date = "01/01/1992" 
 
  dayOfWeek(date) match { 
      case Some(dow) =&gt; println(s"It was $dow on $date") 
      case None =&gt; println(s"Something went wrong!") 
  } 
 
} </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">It was Wednesday on 01/01/1992 </pre>
<p class="calibre2">We defined a <kbd class="calibre11">DateUtil</kbd> object with a utility <kbd class="calibre11">dayOfWeek(date: String)</kbd><em class="calibre18"> </em>function. This tells us the day of the week when we pass a date to it in a certain format. We also created an app which imports this <kbd class="calibre11">DateUtilobject</kbd> and from that, we get access to all functions inside that object. With this, we were able to directly make a call to our function and get the result.</p>
<p class="calibre2">This is a fair pattern where we define a class and then create some functions that are not instance-specific but can be used from instances, such as the example we had for the <kbd class="calibre11">Country</kbd> class and its utility object named <kbd class="calibre11">CountryUtil</kbd><em class="calibre18">.</em> The language creators knew it well, and introduced the concept of what we call companion objects. That's what we're going to learn about next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Companion objects</h1>
                
            
            <article>
                
<p class="calibre2">Companion objects are not very different to what we have already seen when we discussed objects. One specific difference is that we name those the same as our class names. It means that instead of defining <kbd class="calibre11">CountryUtil</kbd><em class="calibre18">,</em> we can give this object the same name as our <kbd class="calibre11">Country</kbd> class and call it our companion object:</p>
<pre class="calibre19">class Country(val name: String, val capital: String){ 
  var populationMap = scala.collection.mutable.Map[String, Double]() 
  def getPopulation(year: String): Double = populationMap(year) //In Million 
 
  override def toString: String = s"Country($name,$capital)" 
} 
 
object Country { 
  /* 
  * Function takes a sequence of population per million and returns average. 
  * */ 
  def populationAverage(pops: Seq[Double]) = pops.sum / pops.length 
} 
 
object CountryApp extends App { 
  val country = new Country("France", "Paris") 
  country.populationMap += ("2015" -&gt; 64.39) += ("2016" -&gt; 64.67) += ("2017" -&gt; 64.93) 
 
  println(s"Country Name: ${country.name} and Population 2017: ${country.getPopulation("2017")} million") 
 
  println(s"${country.name}'s average population: ${Country.populationAverage(country.populationMap.values.toSeq)}") 
} </pre>
<p class="calibre2">The preceding code does what we had said earlier. We named our object the same as our <kbd class="calibre11">Country</kbd><em class="calibre18"> </em>class<em class="calibre18">.</em> This is how we define companion objects. This structures your code in a nice manner as well, as it provides you with the ability to make your types do something. It's handy to know that, to make your objects a <em class="calibre18">companion</em> you must define them in the same source file.</p>
<p class="calibre2">If, by chance, you find yourself trying that in the Scala REPL it should be done in paste mode (<kbd class="calibre11">:paste</kbd>). Let's see what we mean by that. So, open the Scala REPL and try creating a class and its companion object. The REPL will show a warning:<span> <em class="calibre18">previously defined class is not a companion to object. </em></span><em class="calibre18">Companions must be defined together; you may wish to use :paste mode for this.</em></p>
<p class="calibre2">So we do as suggested. We give the <kbd class="calibre11">:paste</kbd> command in the REPL, which will enable paste mode, and then write our class with companion mode. Then everything seems good.</p>
<p class="calibre2">These are useful constructs that we've used in various places already. When we use <kbd class="calibre11">case</kbd> <em class="calibre18">classes</em> or typeclass (we'll learn about typeclasses in <a href="part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 10</a>, <em class="calibre18">Advanced Functional Programming</em>) implementation, we'll be searching for companion objects for them. In fact, whenever we see our class has a particular thing to do, we have this nice way of building its companion object with the <kbd class="calibre11">apply</kbd> method. Take a look at the following example:</p>
<pre class="calibre19">import java.time.LocalDate 
import java.time.format.DateTimeFormatter 
 
class Date(val dateStr: String) { 
  override def toString: String = s"Date(${this.dateStr})" 
} 
 
object Date{ 
  def apply(str: String): Date = { 
    val dater = LocalDate.parse(str, DateTimeFormatter.ofPattern("dd/MM/yyyy")) 
    new Date(s"${dater.getDayOfWeek} ${dater.getDayOfMonth}-${dater.getMonth}-${dater.getYear}") 
  } 
} 
 
object DateApp extends App { 
  val date = Date("01/01/1992") 
  println(date)<br class="title-page-name"/> } </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Date(WEDNESDAY 1-JANUARY-1992) </pre>
<p class="calibre2">This example is for illustration purposes. There were different ways we could have achieved what we did here, but to understand <em class="calibre18">companion objects</em> with <kbd class="calibre11">apply</kbd> methods is simpler this way. So, what's different in the preceding example? Is it the way we used our <kbd class="calibre11">DateApp</kbd> application? Yes, when we define the <kbd class="calibre11">apply</kbd> method in the companion object the Scala compiler lets us use it without an explicit call to itself. That's what we did here:</p>
<pre class="calibre19">val date = Date("01/01/1992") </pre>
<p class="calibre2">We defined a class named <kbd class="calibre11">Date</kbd><em class="calibre18">,</em> and along with that we created its companion with the <kbd class="calibre11">apply</kbd> method. It gives us the advantage of manipulating the instance into giving us something back. In our case, we retrieved some more information to make the instances of <kbd class="calibre11">Date</kbd> more meaningful, and instantiated <kbd class="calibre11">Date</kbd> with more information. Users of <kbd class="calibre11">Date</kbd> will get more information than we give. This seems interesting. However, the actual implementation needs to take care of exceptional scenarios as well. For example, what if, while parsing the date, we encounter an exception? We won't go into detail right now, as our motto was to understand this pattern and find uses for it.</p>
<p class="calibre2">Think of simpler scenarios where we want to omit the unnecessary boilerplate code that we have to write when we create a simple class, such as this:</p>
<pre class="calibre19">class Country(val name: String, val capital: String) { 
 
  override def toString: String = s"Country($name,$capital)" 
 
  override def equals(obj: scala.Any): Boolean = ??? 
 
  override def hashCode(): Int = ??? 
 
} </pre>
<p class="calibre2">Here, we have our simple <kbd class="calibre11">Country</kbd> class where, thanks to Scala, we don't have to define accessors and mutators for our class. However, this is not so great. We still have to define methods such as <kbd class="calibre11">toString</kbd><em class="calibre18">,</em> <kbd class="calibre11">equals</kbd>, or <kbd class="calibre11">hashCode</kbd><em class="calibre18">.</em> What if Scala could does it for you, along with the removal of extra keywords that we have to write such as <kbd class="calibre11">new</kbd><em class="calibre18">,</em> <kbd class="calibre11">val</kbd>, and so on?</p>
<p class="calibre2">And yes, the entire point of mentioning all these is to affirm that we can do a lot in Scala using case classes, which we are going to discuss in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Case classes</h1>
                
            
            <article>
                
<p class="calibre2">What are case classes, why do we have them, and how do we use them? These are a few questions you may want an answer to. So, in simpler words, a case class can omit the amount of code we may have to write to achieve this:</p>
<pre class="calibre19">class Country(val name: String, val capital: String) { 
 
  override def toString: String = s"Country($name,$capital)" 
 
  override def equals(obj: scala.Any): Boolean = ??? 
 
  override def hashCode(): Int = ??? 
 
} </pre>
<p class="calibre2">Instead of declaring <kbd class="calibre11">Country</kbd> as we do in the preceding code, we would prefer to do the following:</p>
<pre class="calibre19">case class Country(name: String, capital: String) </pre>
<p class="calibre2">And our case class <kbd class="calibre11">Country</kbd> definition takes care of the rest. We have accessor methods for our <kbd class="calibre11">name</kbd> and <kbd class="calibre11">capital</kbd> members. We have our <kbd class="calibre11">toString</kbd> and <kbd class="calibre11">equals</kbd> methods defined by the Scala compiler, or let's say, auto-generated for us:</p>
<pre class="calibre19">case class Country(name: String, capital: String) 
 
object CountryUtil extends App { 
  val country = Country("France", "Paris") 
  println(s"Our country is: $country") 
 
  println(s"Equality =&gt; ${country == country}") 
 
  println(s"HashCode for country instance: ${country.hashCode()}") 
}  </pre>
<p class="calibre2">The following is the output:</p>
<pre class="calibre19">Our country is: Country(France,Paris) 
Equality =&gt; true 
HashCode for country instance: -66065175 </pre>
<p class="calibre2">Now, the preceding code snippet shows what we mentioned. We did not explicitly define <kbd class="calibre11">toString</kbd><em class="calibre18">,</em> <kbd class="calibre11">equals</kbd>, or <kbd class="calibre11">hashCode</kbd> methods for the <kbd class="calibre11">Country</kbd> class. Still, we were able to perform these operations for the case class instance of the Country class. Why so? This happens because when we define a case class in Scala, the compiler automatically creates its companion object with a few methods, such as apply, unapply, and so on. During compilation, whenever the Scala compiler finds a case class, it converts the class files from Scala to Java; in our case, we'll get Country$.class and Country.class. The body of these files tells you a lot about what's happening in the background:</p>
<p class="calibre2">The following is an instance of the <kbd class="calibre11">Country$.class</kbd> class:</p>
<pre class="calibre19">public final class chapter6.Country$ extends scala.runtime.AbstractFunction2&lt;java.lang.String, java.lang.String, chapter6.Country&gt; implements scala.Serializable { 
  public static chapter6.Country$ MODULE$; 
  public static {}; 
  public final java.lang.String toString(); 
  public chapter6.Country apply(java.lang.String, java.lang.String); 
  public scala.Option&lt;scala.Tuple2&lt;java.lang.String, java.lang.String&gt;&gt; unapply(chapter6.Country); 
  public java.lang.Object apply(java.lang.Object, java.lang.Object); 
} </pre>
<p class="calibre2">The following is an instance of the <kbd class="calibre11">Country.class</kbd> class:</p>
<pre class="calibre19">public class chapter6.Country implements scala.Product,scala.Serializable { 
  public static scala.Option&lt;scala.Tuple2&lt;java.lang.String, java.lang.String&gt;&gt; unapply(chapter6.Country); 
  public static chapter6.Country apply(java.lang.String, java.lang.String); 
  public static scala.Function1&lt;scala.Tuple2&lt;java.lang.String, java.lang.String&gt;, chapter6.Country&gt; tupled(); 
  public static scala.Function1&lt;java.lang.String, scala.Function1&lt;java.lang.String, chapter6.Country&gt;&gt; curried(); 
  public java.lang.String name(); 
  public java.lang.String capital(); 
  public chapter6.Country copy(java.lang.String, java.lang.String); 
  public java.lang.String copy$default$1(); 
  public java.lang.String copy$default$2(); 
  public java.lang.String productPrefix(); 
  public int productArity(); 
  public java.lang.Object productElement(int); 
  public scala.collection.Iterator&lt;java.lang.Object&gt; productIterator(); 
  public boolean canEqual(java.lang.Object); 
  public int hashCode(); 
  public java.lang.String toString(); 
  public boolean equals(java.lang.Object); 
  public chapter6.Country(java.lang.String, java.lang.String); 
} </pre>
<p class="calibre2">A lot of interesting things are going on in the background. The Scala compiler creates and defines all the necessary methods for our case class and making our life easy. All these conciseness is because of the compiler's ability to remove all the boilerplate that we may have to write. A few important methods that the compiler defines for us are:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">apply</kbd></li>
<li class="calibre8"><kbd class="calibre11">unapply</kbd></li>
<li class="calibre8"><kbd class="calibre11">copy</kbd></li>
<li class="calibre8"><kbd class="calibre11">canEqual</kbd></li>
<li class="calibre8"><kbd class="calibre11">hashCode</kbd></li>
<li class="calibre8"><kbd class="calibre11">equals</kbd></li>
<li class="calibre8"><kbd class="calibre11">toString</kbd></li>
</ul>
<p class="calibre2">Along with these, the compiler also creates the constructor along with immutable fields, as well as accessors for those fields and a few utility methods such as <kbd class="calibre11">productArity</kbd>, <kbd class="calibre11">productPrefix</kbd>, and <kbd class="calibre11">productElement</kbd><em class="calibre18">.</em> It's worth noting that a few methods such as the <kbd class="calibre11">apply</kbd> and <kbd class="calibre11">unapply</kbd> methods are declared <kbd class="calibre11">static</kbd> in compiled form. It means that these can be called in the form of <kbd class="calibre11">Country.apply(...)</kbd> or <kbd class="calibre11">Country.unapply(...)</kbd><em class="calibre18">,</em> but others can be called upon instances of the case class. It won't be possible to call <kbd class="calibre11">Country.copy(...)</kbd>, as the compiler will not allow us to perform this operation. Speaking of all these, let's try them for our example <kbd class="calibre11">Country</kbd><em class="calibre18"> </em>case class:</p>
<pre class="calibre19">package chapter6 
 
object CountryUtil extends App { 
  case class Country(name: String, capital: String) 
  val country = Country("France", "Paris") 
  println(s"Country: =&gt; $country") 
  println(s"Equality: =&gt; ${country == country}") 
  println(s"HashCode: =&gt; ${country.hashCode()}") 
 
  println(s"Unapply: =&gt; ${Country.unapply(country)}") 
  println(s"apply: =&gt; ${Country.apply("Germany","Berlin")}") 
 
  println(s"copy: =&gt; ${country.copy("Germany","Berlin")}") 
  println(s"copyName: =&gt; ${country.copy(name="Germany")}") 
  println(s"copyCapital: =&gt; ${country.copy(capital="Berlin")}") 
 
  println(s"productArity: =&gt; ${country.productArity}") 
  println(s"productPrefix: =&gt; ${country.productPrefix}") 
  println(s"productElement(0): =&gt; ${country.productElement(0)}") 
  println(s"productElement(1): =&gt; ${country.productElement(1)}") 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Country: =&gt; Country(France,Paris) 
Equality: =&gt; true 
HashCode: =&gt; -66065175 
Unapply: =&gt; Some((France,Paris)) 
apply: =&gt; Country(Germany,Berlin) 
copy: =&gt; Country(Germany,Berlin) 
copyName: =&gt; Country(Germany,Paris) 
copyCapital: =&gt; Country(France,Berlin) 
productArity: =&gt; 2 
productPrefix: =&gt; Country 
productElement(0): =&gt; France 
productElement(1): =&gt; Paris </pre>
<p class="calibre2">We saw all the methods applied in the preceding code. It's worth noting that these methods are useful and provide more information about the class instance along with the basic behavior. That was our intention of creating a companion object. Remember, we created our <kbd class="calibre11">Date</kbd> class with a companion object, whose instance happened to be more meaningful than the information provided at declaration time.</p>
<p class="calibre2">There are more than one reason to prefer using case classes over usual classes in Scala. It's obvious that case classes are concise and yet give us more than we may get by writing our own. Due to that reason, we have more information about these case classes and their members. For example, the unapply method gives us information that you may need when inspecting an instance. We can use these in pattern matching and it's also recommended to do so:</p>
<pre class="calibre19">case class Country(name: String, capital: String) 
val country = Country("France", "Paris") 
 
country match { 
  case Country("Germany", _) =&gt; println(s"It's Germany") 
  case Country("France", _) =&gt; println(s"It's France") 
  case Country(_, _) =&gt; println(s"It's some country") 
} </pre>
<p class="calibre2">This may look simple, but it's a powerful construct and used heavily. No wonder you also find yourself matching case class instances more often. It's simple to do so and, according to our snippet, it'll print the following:</p>
<pre class="calibre19">It's France  </pre>
<p class="calibre2">It does this as expected due to the <kbd class="calibre11">unapply</kbd> method; pattern matching worked on our case class instance. It is also worth knowing that you can't declare a case class along with a class with the same name. Scala won't allow you to declare a class and case class with the same name in the same scope. By same scope, what we mean is that if you declare a case class, let's say country with the same name as a Country class in the same compilation unit, it's fair enough, because those belong to different scopes. To make the statement clear, look at an example:</p>
<pre class="calibre19">package chapter6 
 
object CountryUtil extends App { 
  case class Country(name: String, capital: String) 
  val country = Country("France", "Paris") 
} 
 
class Country(name: String, capital: String) </pre>
<p class="calibre2">The preceding code is totally fine to declare, but if we try to put our class inside <kbd class="calibre11">CountryUtil</kbd> or take our case class outside of <kbd class="calibre11">CountryUtil</kbd>, the compiler will not let us do this:</p>
<pre class="calibre19">package chapter6 
case class Country(name: String, capital: String) 
 
object CountryUtil extends App {  
  val country = Country("France", "Paris") 
} 
 
class Country(name: String, capital: String) </pre>
<p class="calibre2">The Scala compiler will not let you do so, saying the following:</p>
<pre class="calibre19">Country is already defined in scope </pre>
<p class="calibre2">Well, you may not want to do such a thing anyway. In case you're wondering whether it's possible to extend from a case class or not, it's possible to do the following with case classes:</p>
<pre class="calibre19">abstract class Continent 
case class Country(name: String, capital: String) extends Continent </pre>
<p class="calibre2">We'll learn more about inheritance in the next chapter. For now, we've seen enough to be prepared for what comes next. It's time to summarize what we've learned in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was interesting because we learned the details of Scala classes and object implementation. We started with what classes means in Scala, how we can declare them, and use them. Then we talked about objects as singleton instances in Scala. We then talked about interesting companion objects, which led us to case classes. We learned that case classes not only give us the conciseness we want but can also be very useful in scenarios where we may want to do pattern matching over instances. Finally, we discussed all the methods and goodies that case classes provide.</p>
<p class="calibre2">In the next chapter, we'll take our knowledge of object-oriented Scala to the next level and talk more about traits, inheritance, and a lot more.</p>


            </article>

            
        </section>
    </body></html>