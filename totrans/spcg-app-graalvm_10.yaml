- en: '*Chapter 7*: GraalVM Polyglot – JavaScript and Node.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how Truffle provides a layer to integrate
    other language programs to run on GraalVM. In this chapter, we will focus on JavaScript
    and Node.js interpreters, and in the next chapter, we will cover other runtimes,
    such as Java/Truffle, Python, R, and WebAssembly. We will be covering aspects
    of the polyglot interoperability features of Truffle and exploring the JavaScript
    interpreter. We will be exploring these features hands-on by writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to run non-JVM language applications on Graal, specifically
    JavaScript and Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to pass objects/values between applications written in different
    languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use optimization techniques to fine-tune the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a very clear understanding of how
    to build a polyglot application on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be doing a lot of hands-on coding, to explore the
    various guest languages that GraalVM supports. To try the code, you will need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Various language Graal runtimes: We will cover in the chapter how to install
    and run these runtimes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to GitHub: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from the following link. You will
    find the chapter-specific code under the `chapter7` directory: [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3yqu4ui](https://bit.ly/3yqu4ui).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the JavaScript (including Node.js) Truffle interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GraalVM version of JavaScript is an ECMAScript-compliant runtime for both
    JavaScript, `js`, and Node.js, `node`. It supports all the features of ECMAScript
    2021, at the time of writing this book. It is also Nashorn- and Rhino-compatible
    and provides complete support for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM Node.js uses the original Node.js source code and replaces the V8 JavaScript
    engine with the GraalVM JavaScript engine. The replacement is seamless, and the
    application developers don't have to modify any significant amount of code or
    configuration to run existing Node.js applications with GraalVM Node.js. GraalVM
    Node.js provides more features for embedding code from other languages, and accessing
    data and code, and interoperating code in other language. `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, apart from using JavaScript and Node as an alternate runtime
    for running applications, we will also explore their polyglot interoperability
    features. We will be walking through a lot of JavaScript and Node.js sample code
    to explore the polyglot capabilities of the GraalVM JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying JavaScript, Node, and npm installation and versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript and Node.js come along with the GraalVM installation; you will find
    them in the `<GraalHome>/bin` directory. We can check if the JavaScript runtime
    is properly configured by checking the version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the version, execute the `js --version` command. At the time of writing
    this book, GraalVM JavaScript 21.0.0.2 was the latest. The following is the output
    (note that it is GraalVM JavaScript):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ensure that we are running the right version of Node.js by calling
    a specific node.js version by executing the `node --version` command. In the following
    command, we are explicitly calling the right version. Note that the GraalVM home
    location might be different for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also make sure NPM is working by executing the `npm --version` command.
    The following is the command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have verified the JavaScript, Node.js, and npm installations, let's
    create a simple Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to an application folder, and execute `npm init`. This will set up the boilerplate
    configuration for the Node.js application. We will name the application `graal-node-app`.
    The following shows the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a Node.js application and a `package.json` file with a boilerplate
    configuration, based on the options we selected. Let''s install the `express`
    package by executing `npm install --save express`. This installs the `express`
    package in the application folder and also updates the `package.json` file (because
    of the `--save` argument). Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the `node_modules` directory, which contains all the packages
    that are required to run our application. Let''s create an `index.js` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's a very simple application, which responds with an HTML
    `Hello Graal Node` as a header 1, when invoked at the root. The application will
    listen at port number `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can see the output, we know that the application is listening at
    `8080`. Let''s try to call this from the web browser at http://localhost:8080/.
    The following is the screenshot of the application response on the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Hello Graal Node screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Hello Graal Node screenshot
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that the Node.js on GraalVM is working fine, let's understand
    the polyglot interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle –
    An Overview*, we went into a lot of details about how Truffle enables polyglot
    support and provides an infrastructure for polyglot interoperability and polyglot
    embedding. In this section, we will explore these features with sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the Node.js application that we created in the previous section,
    and add an endpoint, `/poly`, in our `index.js` file. Let's create a simple Python
    array object, and store some numbers in the object. We will then iterate through
    this Python object in Node.js, to list these numbers. This shows how we can embed
    Python code snippets within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source code shows this new endpoint, `/poly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have the code to listen at port `8080` and call the preceding function
    when we receive a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the code, we are using the `Polyglot.eval()` method to run
    Python code. To let the polyglot object know that it''s Python code, we are passing
    `python` as a parameter, and passing the Python representation of the array. Let''s
    now run this code with `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have to pass `--jvm` and `--polyglot` arguments to node. It's very
    important to pass these parameters. `--jvm` tells node to run on `--polyglot`,
    as the name suggests, tells node to support `polyglot`. Since Truffle and Graal
    run on JVM, it's important to use the `jvm` argument, even though we may not be
    directly using Java in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now access this new endpoint from the browser. The following screenshot
    shows the output as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – /poly endpoint result screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – /poly endpoint result screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have noticed, the first time we called, it took time to load the
    page, but the subsequent calls are instantaneous. Let''s just time that with curl
    (curl is a command-line utility to call any URLs. Please refer to [https://curl.se/](https://curl.se/)
    for more details on curl and how to install curl on your machine). The following
    is a screenshot of a sequence of curl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Performance of Node.js after subsequent calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Performance of Node.js after subsequent calls
  prefs: []
  type: TYPE_NORMAL
- en: We can see the initial load on the CPU, but subsequent calls are quick with
    no additional load on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore more advanced features of polyglot interoperability. JavaScript
    and Java interoperability is very sophisticated. Let's explore the concepts with
    more complex implementations than lists.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript embedded code in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's recall the `FibonaaciCalculator.java` file that we used in previous chapters.
    Let's modify that `FibonacciCalculator.java` to use a JavaScript snippet and execute
    that JavaScript snippet within Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified version of the `FibonacciCalculator` with an embedded
    JavaScript snippet. The Java file is called `FibonacciCalculatorPolyglot.java`.
    You can find the full code in the Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to import the `polyglot` classes. This implements the Truffle interoperability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the `main()` function, which will invoke `findFibonacci()`
    several times to reach the compiler threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore this code. We have defined a static `String` variable that holds
    the JavaScript snippet, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a static `String` with a simple JavaScript function that prints
    whatever is the parameter that is passed to it. To invoke this JavaScript code
    within Java, we need to first import the `Polyglot` libraries by importing the
    following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To invoke the JavaScript code, we first need to create an instance of the `org.graalvm.polyglot.Context`
    class. The `Context` object provides the polyglot context to allow the guest language
    code to run in the host language. A polyglot context represents the global runtime
    state of all installed and permitted languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to use the `Context` object is to create the `Context` object
    and use the `eval()` function in the `Context` object, to execute other language
    code. The following is a code snippet where we are executing a JavaScript code
    snippet within Java. In this case, the guest language is JavaScript, which is
    passed as a parameter, `"js"`, in the `eval` method in the host language, Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s execute this code. Following is the screenshot of the output, after
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript
    outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript
    outputs
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the output, we have two totals printed, one is printed with
    Java code and the other one is printed from the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: This opens up a lot of possibilities – imagine running machine learning code
    written in Python or R in Node.js web applications. We are bringing the best features
    of individual languages together in one VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Context` object has `ContextBuilder`, which can be used to set specific
    environment properties. The following are some of the properties that it can set,
    and the relevant `Context` creates code. This can be used to control the access
    the guest language has to the host. The code to control the access is `Context.newBuilder().allowXXX().build()`.
    The following are various `allowXXX` methods that can be used for finer access
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allowAllAccess(boolean)`: This is the default. It provides all access to the
    guest language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowCreateProcess(boolean)`: Provides control access for the guest language
    to create a new process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowCreateThread(boolean)`: Provides control access for the guest language
    to create a new thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowEnvironmentAccess(EnvironmentAccess)`: Allows control access to the environment
    using the provided policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowHostClassLoading(boolean)`: This allows the guest languages to load new
    host classes via a JAR or a class file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowIO(boolean)`: Controls access to perform I/O operations. If true, the
    guest language can perform unrestricted I/O operations on the host system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowNativeAccess(boolean)`: Controls guest languages to access the native
    interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowPolyglotAccess(PolyglotAccess)`: Controls polyglot access using the provided
    policy. `PolyglotAccess` can be used to define custom polyglot access policies
    on how the data, bindings, and code execution can be the controlled at a finer
    level. This is a custom implementation, which the guest languages can build using
    the `PolyglotAccess` builder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the Javadoc ([https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html](https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html))
    for more details about other methods. It is risky to give the guest language all
    the access; it's always better to provide fine and specific access based on the
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how we can build a `Context` object with specific access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also load an external file using the following code snippet, which is
    a recommended way of embedding code. It is not a good practice to copy-paste the
    other language code as a string into the host language. It's a configuration management
    nightmare to keep the code up to date and bug-free, as the code in other languages
    might be developed by different developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a code snippet that shows how to load the source code as a file,
    rather than embedding the guest language code in the host source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we saw how we can invoke JavaScript code from Java. Now let's
    try to call a Java class from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a Java class from JavaScript/Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have seen how Java code can run JavaScript code, let''s try to
    call Java code from JavaScript. Here is a very simple Java application, which
    prints the argument that is passed to it on a console. The name of the Java file
    is `HelloGraalPolyglot.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile this application with `javac HelloGraalPolyglot.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to call this application from the JavaScript. The following
    is the JavaScript code `hellograalpolyglot.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple JavaScript code. We are loading the Java class using the `Java.type()`
    method in JavaScript, and calling the `main()` method with a `String` parameter,
    and passing the string `"Hello from JavaScript"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this JavaScript, we will have to pass the `--jvm` argument and `--vm.cp`
    to set the classpath. Here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the output of executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This was a very simple example. To understand how parameters are passed and
    how the method return data is captured and used in JavaScript, let's try to call
    the `findFibonacci()` method defined in the `FibonacciCalculator.java` code, from
    a Node.js application. We will pass a parameter and get an array out of the method,
    which we will render as a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify `index.js` and add another endpoint, `/fibonacci`. Here is the
    complete source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this `node.js` code, we are first loading the Java class `FibonacciCalculatorPolyglot`
    using the `Java.Type()` method. Then we are creating an instance of this class
    and calling the method directly. The output, we know, is an array. We are iterating
    through the array and printing the result as an HTML list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go to http://localhost:8080/fibonacci. Here is the screenshot of
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator
    method screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator
    method screenshot
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the Node.js/Fibonacci endpoint working, where
    it is listing the first 10 Fibonacci numbers as an HTML list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we looked at how to run a JavaScript snippet within Java,
    invoke Java from JavaScript and invoke a Java method, pass parameters, and get
    results from a Java method from a Node.js application. Let''s very quickly summarize
    the various JavaScript interoperability features:'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to call Java code from JavaScript, we pass the `--jvm` argument
    and set `CLASSPATH` to load the right class using `--vm.cp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the polyglot `Context` object in Java to run other language code. There
    is a special `ScriptEngine` object for running JavaScript in Java. The `Context`
    object wraps this and is the recommended way to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `Java.type()` to load a Java class from JavaScript/Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `new` to create the instances of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion is taken care of by GraalVM between Java and JavaScript. In
    cases where there could be a loss of data (for example, converting from `long`
    to `int`) a `TypeError` is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java package resolution can be done by providing the full package path while
    calling `Java.type()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling can be done naturally using `try{}catch` blocks both in Java
    and JavaScript. GraalVM takes care of converting the exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding example, we looked at how Java arrays can be iterated by JavaScript.
    Similarly, `Hashmap` can also be used natively using the `put()` and `get()` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript objects can be accessed by Java code as instances of the `com.oracle.truffle.api.interop.java.TruffleMap`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at how we can interoperate between Java and JavaScript.
    Let's now explore how to build polyglot native images.
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot native images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graal also supports creating native images of polyglot applications. To create
    a native image of this Java class, we have to use the `--language` argument to
    build the native image. The following are the various language flags we can pass
    to `native-image` (the Native Image builder). In [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Graal Ahead-of-Time Compiler and Native Image*, we covered the Native Image builder
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we have to pass `--language:js` to let the Native Image builder
    know that we are using JavaScript within our Java code. So, we need to execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the screenshot of the output after executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Polyglot Native Image build output screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Polyglot Native Image build output screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'The Native Image builder performs a static code analysis and builds the optimum
    image of our polyglot application. We should be able to find the executable `fibonaccicalculatorpolyglot`
    file in the directory. Let''s execute the native image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the screenshot of the output when we run the native
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Polyglot Native Image execution results screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Polyglot Native Image execution results screenshot
  prefs: []
  type: TYPE_NORMAL
- en: (In this example, you might find the code is performing more slowly than in
    JIT mode. Please refer to [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*, for more details on why this is happening.)
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The binding object acts as an intermediate layer between Java and JavaScript
    to access methods, variables, and objects between the languages. To understand
    how bindings work, let''s write a very simple JavaScript file that has three methods
    – `add()`, `subtract()`, and `multiply()`. All three methods access two numbers
    and return a number. We also have a variable that holds a simple string. Here
    is the JavaScript code, `Math.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript code is very simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now write a simple Java class that loads this JavaScript file and calls
    the methods by passing integer parameters, and prints the result returned by JavaScript
    methods. This class also accesses the variable `helloMathMessage` and prints it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the code to understand how this works. Here is the code,
    `MathJSCaller.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing all the polyglot classes that implement the Truffle interoperability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are creating the `Context` object and loading the
    JavaScript file and building it. Once the JavaScript is loaded, then to access
    the method members and variable member from the JavaScript file, we are using
    `Context.getBindings()`. Bindings provide a layer that allows polyglot languages
    to access the data and method members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are just printing the binding keys to see what all members are exposed to.
    Now, let''s access the members, by calling the methods and accessing the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are printing all the results. The complete source code is available
    at the Git repository link provided in the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this application. The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 MathJSCaller execution results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16878_Figure_7.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 MathJSCaller execution results
  prefs: []
  type: TYPE_NORMAL
- en: We can see that our program is working. It can load the JavaScript `math.js`
    file and call all the methods. We also see the list of binding keys, which we
    printed by calling `System.out.println("Binding Keys :" + ctx.getBindings("js").getMemberKeys());`.
    We can see the list has four keys, and they match what we have in the `math.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we saw how a binding object acts as an interface to access
    JavaScript members from Java.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript on GraalVM supports multithreading. In this section, we will explore
    various patterns that are supported in the context of polyglot between Java and
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript object that is created in a thread can only be used within that
    thread, it cannot be accessed from another thread. For example, in our example,
    `Value` objects such as `addFunction`, `subtractFunction`, and so on can only
    be used with that thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our `MathJSCaller` class'' `runMathJS()` method to run a thread
    indefinitely, to simulate a concurrent access situation. Let''s modify the preceding
    code and call the member functions in a separate thread. Here is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We copied the accessing of the member methods in a separate thread. Now let''s
    call this in a loop, to simulate concurrent access, using the same `Context` object
    within the threads and outside the thread. The following code snippet shows calls
    outside the thread using the same `Context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, at some point, when the objects are simultaneously accessed
    by the two threads, we should get the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome this issue, it is recommended to use isolated runtimes. We can
    create separate `Context` objects per thread and create new instances of these
    objects and use them in that thread. Here is the fixed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the thread, we are creating a separate `Context` object. The following
    code snippet shows the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in this code, we are creating a separate `context` object within
    the thread, which is local to the thread. This does not create an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other solution to this is to access the `context` object in proper `synchronized`
    blocks or methods, so that the runtimes are not accessed at the same time. Here
    is the updated code, with a `synchronized` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also include the whole block as a synchronized block, still using the
    same `Context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will also run fine but might run slower than the previous solution, as
    there could be a lot of locks on the `Context` object.
  prefs: []
  type: TYPE_NORMAL
- en: Java objects are thread-safe, so Java objects can be accessed between JavaScript
    runtimes running different threads.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming – Promise and await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asynchronous programming is very prominent in modern distributed applications.
    JavaScript uses `Promise`. The `Promise` object represents the completion of an
    asynchronous activity, along with the final value. The `Promise` object has three
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: This state is the initial state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled**: This state indicates that the operation successfully executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: This state indicates that the operation failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we may have to have JavaScript creating a promise and the logic might
    be running in Java code, and when the Java code is done, it may have to fulfill
    or reject the promise. To handle that, Graal provides a `PromiseExecuter` interface.
    A Java class has to implement this interface method, `void onPromiseCreation(Value
    onResolve, Value onReject);`. A Java class that implements this interface can
    be used by JavaScript to create a `Promise` object. JavaScript can call `await`
    on a Java object that implements void then `(Value onResolve`, `Value onReject);`
    to implement asynchronous programming between JavaScript and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the various polyglot interoperability and embedding
    features of GraalVM/Truffle for JavaScript and Node.js in detail. We explored
    all the key concepts with some real code examples, to gain a clear understanding
    of how JavaScript and Node.js can call, pass data, and interoperate with other
    language code. This is one of the salient features of GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: The examples given in this chapter will help you to build and run polyglot applications
    that are written using the Java and JavaScript languages on the same runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to explore R, Python, and the latest Java
    on Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What JavaScript object and method is used to run other language code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `Context` object in Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you control the access a guest language gets to the host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you build a native image of a polyglot application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a binding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM Enterprise Edition ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript and Node.js reference ([https://www.graalvm.org/reference-manual/js/](https://www.graalvm.org/reference-manual/js/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Truffle: A Self-Optimizing Runtime System* ([https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf](https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An Object Storage Model for the Truffle Language Implementation Framework*
    ([https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf](https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
