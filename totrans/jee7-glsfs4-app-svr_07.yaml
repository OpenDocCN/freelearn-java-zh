- en: Chapter 7. WebSockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：WebSocket
- en: Traditionally, web applications have been developed using the request/response
    model followed by the HTTP protocol. In this model, the request is always initiated
    by the client and then the server returns a response back to the client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Web 应用程序是使用 HTTP 协议之后的请求/响应模型开发的。在这个模型中，请求始终由客户端发起，然后服务器将响应返回给客户端。
- en: There has never been any way for the server to send data to the client independently
    (without having to wait for a request from the browser) until now. The WebSocket
    protocol allows full-duplex, two-way communication between the client (browser)
    and the server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从未有过独立向客户端发送数据的方式（无需等待浏览器请求），直到现在。WebSocket 协议允许客户端（浏览器）和服务器之间全双工、双向通信。
- en: Java EE 7 introduces the Java API for WebSocket, which allows us to develop
    WebSocket endpoints in Java. The Java API for WebSocket is a brand-new technology
    in the Java EE Standard.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7 引入了 Java API for WebSocket，允许我们在 Java 中开发 WebSocket 端点。Java API for
    WebSocket 是 Java EE 标准中的全新技术。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A socket is a two-way pipe that stays alive longer than a single request. Applied
    to an HTML5-compliant browser, this would allow for continuous communication to
    or from a web server without the need to load a new page (similar to AJAX).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一个双向管道，其存活时间比单个请求长。应用于符合 HTML5 规范的浏览器，这将允许与 Web 服务器进行连续通信，而无需加载新页面（类似于 AJAX）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing WebSocket server endpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 WebSocket 服务器端点
- en: Developing WebSocket clients in JavaScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中开发 WebSocket 客户端
- en: Developing WebSocket clients in Java
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 中开发 WebSocket 客户端
- en: Developing a WebSocket server endpoint
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 WebSocket 服务器端点
- en: A WebSocket server endpoint is a Java class deployed to the application server
    that handles WebSocket requests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 服务器端点是一个部署到应用服务器的 Java 类，用于处理 WebSocket 请求。
- en: 'There are two ways in which we can implement a WebSocket server endpoint via
    the Java API for WebSocket: either by developing an endpoint programmatically,
    in which case we need to extend the `javax.websocket.Endpoint` class, or by decorating
    **Plain Old Java Objects** (**POJOs**) with WebSocket-specific annotations. The
    two approaches are very similar; therefore, we will be discussing only the annotation
    approach in detail and briefly explaining the second approach, that is, developing
    WebSocket server endpoints programmatically, later in this section.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式使用 Java API for WebSocket 实现WebSocket 服务器端点：要么通过编程开发端点，在这种情况下，我们需要扩展
    `javax.websocket.Endpoint` 类，要么通过使用 WebSocket 特定的注解装饰 **Plain Old Java Objects**（**POJOs**）。这两种方法非常相似；因此，我们将详细讨论注解方法，并在本节稍后简要解释第二种方法，即通过编程开发
    WebSocket 服务器端点。
- en: In this chapter, we will develop a simple web-based chat application, taking
    full advantage of the Java API for WebSocket.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的基于 Web 的聊天应用程序，充分利用 Java API for WebSocket。
- en: Developing an annotated WebSocket server endpoint
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发注解 WebSocket 服务器端点
- en: 'The following Java class code illustrates how to develop a WebSocket server
    endpoint by annotating a Java class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Java 类代码演示了如何通过注解 Java 类来开发 WebSocket 服务器端点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class-level `@ServerEndpoint` annotation indicates that the class is a WebSocket
    server endpoint. The **URI** (**Uniform Resource Identifier**) of the server endpoint
    is the value specified within the parentheses following the annotation (which
    is `"/websocketchat"` in this example)—WebSocket clients will use this URI to
    communicate with our endpoint.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的 `@ServerEndpoint` 注解表示该类是一个 WebSocket 服务器端点。服务器端点的 **URI**（**统一资源标识符**）是注解后面的括号中指定的值（在这个例子中是
    `"/websocketchat"`）——WebSocket 客户端将使用此 URI 与我们的端点进行通信。
- en: The `@OnOpen` annotation is used to decorate a method that needs to be executed
    whenever a WebSocket connection is opened by any of the clients. In our example,
    we are simply sending some output to the server log, but of course, any valid
    server-side Java code can be placed here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnOpen` 注解用于装饰一个方法，每当任何客户端打开 WebSocket 连接时，都需要执行此方法。在我们的示例中，我们只是向服务器日志发送一些输出，但当然，任何有效的服务器端
    Java 代码都可以放在这里。'
- en: Any method annotated with the `@OnMessage` annotation will be invoked whenever
    our server endpoint receives a message from a client. Since we are developing
    a chat application, our code simply broadcasts the message it receives to all
    connected clients.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被`@OnMessage`注解的方法都会在我们服务器端点从客户端接收到消息时被调用。由于我们正在开发一个聊天应用，我们的代码只是简单地将接收到的消息广播给所有已连接的客户端。
- en: 'In our example, the `processMessage()` method is annotated with `@OnMessage`,
    and takes two parameters: an instance of a class implementing the `javax.websocket.Session`
    interface and a `String` parameter containing the message that was received. Since
    we are developing a chat application, our WebSocket server endpoint simply broadcasts
    the received message to all connected clients.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`processMessage()`方法被`@OnMessage`注解，并接受两个参数：一个实现了`javax.websocket.Session`接口的类的实例，以及一个包含接收到的消息的`String`参数。由于我们正在开发一个聊天应用，我们的WebSocket服务器端点简单地广播接收到的消息给所有已连接的客户端。
- en: The `getOpenSessions()` method of the `Session` interface returns a set of session
    objects representing all open sessions. We iterate through this set to broadcast
    the received message to all connected clients by invoking the `getBasicRemote()`
    method on each session instance and then invoking the `sendText()` method on the
    resulting `RemoteEndpoint.Basic` implementation returned by calling the previous
    method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口上的`getOpenSessions()`方法返回一个表示所有打开会话的会话对象集合。我们遍历这个集合，通过在每个会话实例上调用`getBasicRemote()`方法，然后调用前一个方法返回的`RemoteEndpoint.Basic`实现上的`sendText()`方法，将接收到的消息广播给所有已连接的客户端。'
- en: The `getOpenSessions()` method on the `Session` interface returns all the open
    sessions at the time it was invoked. It is possible for one or more of the sessions
    to have closed after the method was invoked; therefore, it is recommended to invoke
    the `isOpen()` method on a `Session` implementation before attempting to return
    data back to the client. An exception may be thrown if we attempt to access a
    closed session.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口上的`getOpenSessions()`方法在调用时返回所有打开的会话。在方法调用后，可能有一个或多个会话已经关闭；因此，在尝试向客户端返回数据之前，建议在`Session`实现上调用`isOpen()`方法。如果我们尝试访问已关闭的会话，可能会抛出异常。'
- en: Finally, we need to decorate a method with the `@OnClose` annotation in case
    we need to handle the event when a client disconnects from the server endpoint.
    In our example, we simply log a message into the server log.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`@OnClose`注解来装饰一个方法，以防我们需要处理客户端从服务器端点断开连接的事件。在我们的示例中，我们只是简单地将一条消息记录到服务器日志中。
- en: There is one additional annotation that we didn't use in our example—the `@OnError`
    annotation; it is used to decorate a method that needs to be invoked in case there's
    an error while sending or receiving data to or from the client.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，还有一个我们没有使用的额外注解——`@OnError`注解；它用于装饰一个在发送或接收客户端数据时出现错误时需要调用的方法。
- en: As we can see, developing an annotated WebSocket server endpoint is straightforward.
    We simply need to add a few annotations, and the application server will invoke
    our annotated methods as necessary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，开发注解WebSocket服务器端点很简单。我们只需要添加一些注解，应用程序服务器就会根据需要调用我们的注解方法。
- en: If we wish to develop a WebSocket server endpoint programmatically, we need
    to write a Java class that extends `javax.websocket.Endpoint`. This class has
    the `onOpen()`, `onClose()`, and `onError()` methods that are called at appropriate
    times during the endpoint's life cycle. There is no method equivalent to the `@OnMessage`
    annotation to handle incoming messages from clients. The `addMessageHandler()`
    method needs to be invoked in the session, passing an instance of a class implementing
    the `javax.websocket.MessageHandler` interface (or one of its subinterfaces) as
    its sole parameter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望以编程方式开发WebSocket服务器端点，我们需要编写一个扩展`javax.websocket.Endpoint`的Java类。这个类有`onOpen()`、`onClose()`和`onError()`方法，这些方法在端点生命周期中的适当时间被调用。没有与`@OnMessage`注解等效的方法来处理来自客户端的消息。需要在会话中调用`addMessageHandler()`方法，传递一个实现了`javax.websocket.MessageHandler`接口（或其子接口）的类的实例作为其唯一参数。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In general, it is easier and more straightforward to develop annotated WebSocket
    endpoints compared to their programmatic counterparts. Therefore, we recommend
    that you use the annotated approach whenever possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与它们的编程对应物相比，开发注解WebSocket端点更容易、更直接。因此，我们建议尽可能使用注解方法。
- en: Developing WebSocket clients
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发WebSocket客户端
- en: Most WebSocket clients are implemented as HTML5 web pages, taking advantage
    of the JavaScript WebSocket API. As such, they must be accessed using an HTML5-compliant
    web browser (most modern web browsers are HTML5 compliant).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数WebSocket客户端都是作为HTML5网页实现的，利用JavaScript WebSocket API。因此，它们必须使用HTML5兼容的网页浏览器（大多数现代网页浏览器都是HTML5兼容的）。
- en: The Java API for WebSocket provides a client API that allows us to develop WebSocket
    clients as standalone Java applications. We will cover how to do this in a later
    section, *Developing WebSocket clients in Java*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java WebSocket API提供了客户端API，允许我们开发作为独立Java应用程序的WebSocket客户端。我们将在后面的部分介绍如何做到这一点，*在Java中开发WebSocket客户端*。
- en: Developing JavaScript client-side WebSocket code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发JavaScript客户端WebSocket代码
- en: In this section, we will cover how to develop client-side JavaScript code to
    interact with the WebSocket endpoint we developed in the previous section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何开发客户端JavaScript代码来与我们在上一节中开发的WebSocket端点进行交互。
- en: The client page for our WebSocket example is implemented as a JSF page using
    HTML5-friendly markup (as explained in [Chapter 2](ch02.html "Chapter 2. JavaServer
    Faces"), *JavaServer Faces*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的WebSocket示例客户端页面是使用HTML5友好标记实现的JSF页面（如第2章[第2章。JavaServer Faces](ch02.html
    "Chapter 2. JavaServer Faces")中所述）。
- en: 'Our client page consists of a text area where we can see what the users of
    our application are saying (it is, after all, a chat application) and an input
    text we can use to send a message to the other users, as shown in the following
    screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端页面包括一个文本区域，我们可以看到我们应用程序的用户在说什么（毕竟，这是一个聊天应用程序），以及一个输入文本，我们可以用它向其他用户发送消息，如下面的截图所示：
- en: '![Developing JavaScript client-side WebSocket code](img/6886EN_07_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![开发JavaScript客户端WebSocket代码](img/6886EN_07_01.jpg)'
- en: 'The markup for our client page looks like the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端页面的标记如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last line of our JavaScript code (`window.addEventListener("load", init);`)
    sets our JavaScript `init()` function to be executed as soon as the page loads.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们JavaScript代码的最后一行（`window.addEventListener("load", init);`）将我们的JavaScript
    `init()`函数设置为在页面加载时执行。
- en: Within the `init()` method, we initialize a new JavaScript `websocket` object,
    passing the URI of our server endpoint as a parameter. This tells our JavaScript
    code the location of our server endpoint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`方法中，我们初始化一个新的JavaScript `websocket`对象，将我们的服务器端点URI作为参数传递。这告诉我们的JavaScript代码服务器端点的位置。
- en: The JavaScript `websocket` object has a number of function types used to handle
    different events, such as opening the connection, receiving a message, and handling
    errors. We need to set these types to our own JavaScript functions so that we
    can handle these events, which is what we do in our `init()` method right after
    invoking the constructor for the JavaScript `websocket` object. In our example,
    the functions we assigned to the `websocket` object simply delegate their functionality
    to standalone JavaScript functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`websocket`对象具有多种函数类型，用于处理不同的事件，例如打开连接、接收消息和处理错误。我们需要将这些类型设置为我们自己的JavaScript函数，以便我们可以处理这些事件，这正是我们在调用JavaScript
    `websocket`对象构造函数后立即在`init()`方法中做的。在我们的例子中，我们分配给`websocket`对象的函数只是将它们的功能委托给独立的JavaScript函数。
- en: Our `websocketOpen()` function is called every time the WebSocket connection
    is opened. In our example, we simply send a message to the browser's JavaScript
    console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每次WebSocket连接打开时，都会调用我们的`websocketOpen()`函数。在我们的例子中，我们只是向浏览器JavaScript控制台发送一条消息。
- en: The `webSocketMessage()` function is invoked every time the browser receives
    a WebSocket message from our WebSocket endpoint. In our example, we updated the
    contents of the text area whose `id` is `chatWindow` and the contents of the message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每次浏览器从我们的WebSocket端点接收到WebSocket消息时，都会调用`webSocketMessage()`函数。在我们的例子中，我们更新了`id`为`chatWindow`的文本区域内容和消息内容。
- en: The `websocketError()` function is called every time there is a WebSocket-related
    error. In our example, we simply send a message to the browser's JavaScript console.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发生与WebSocket相关的错误时，都会调用`websocketError()`函数。在我们的例子中，我们只是向浏览器JavaScript控制台发送一条消息。
- en: The JavaScript `sendMessage()` function sends a message to the WebSocket server
    endpoint, containing both the username and the contents of the text input whose
    `id` is `chatinput`. This function is called when the user clicks on the button
    whose `id` is `sendBtn`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`sendMessage()`函数将消息发送到WebSocket服务器端点，包含用户名和文本输入的`id`为`chatinput`的内容。当用户点击`id`为`sendBtn`的按钮时，会调用此函数。
- en: The `closeConnection()` JavaScript function closes the connection to our WebSocket
    server endpoint. This function is called when the user clicks on the button whose
    `id` is `exitBtn`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`closeConnection()` JavaScript 函数关闭与我们的 WebSocket 服务器端点的连接。当用户点击具有 `id` 为 `exitBtn`
    的按钮时，会调用此函数。'
- en: As we can see from this example, writing client-side JavaScript code to interact
    with WebSocket endpoints is fairly straightforward.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，编写客户端 JavaScript 代码与 WebSocket 端点交互相当简单。
- en: Developing WebSocket clients in Java
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Java 开发 WebSocket 客户端
- en: Although developing web-based WebSocket clients is currently the most common
    way of developing WebSocket clients, the Java API for WebSocket provides a client
    API that we can use to develop WebSocket clients in Java.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前开发基于 Web 的 WebSocket 客户端是最常见的方式，但 Java API for WebSocket 提供了一个客户端 API，我们可以使用它来在
    Java 中开发 WebSocket 客户端。
- en: 'In this section, we will be developing a simple WebSocket client using the
    client API of the Java API for WebSocket. The final product looks as shown in
    the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Java API for WebSocket 的客户端 API 来开发一个简单的 WebSocket 客户端。最终产品如图所示：
- en: '![Developing WebSocket clients in Java](img/6886EN_07_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Java 开发 WebSocket 客户端](img/6886EN_07_02.jpg)'
- en: However, we won't be covering the GUI code in this section (developed using
    the Swing framework), since it is not relevant to this discussion. The complete
    code for the example, including the GUI code, can be downloaded from the Packt
    Publishing website at [www.packtpub.com](http://www.packtpub.com).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会在本节中介绍 GUI 代码（使用 Swing 框架开发），因为它与本次讨论无关。示例的完整代码（包括 GUI 代码）可以从 Packt Publishing
    网站下载，网址为 [www.packtpub.com](http://www.packtpub.com)。
- en: 'Just as with WebSocket server endpoints, Java WebSocket clients can be developed
    either programmatically or using annotations. Once again, we will cover only the
    annotation approach: developing a programmatic client is very similar to the way
    programmatic server endpoints are developed, that is, programmatic clients must
    extend `javax.websocket.Endpoint` and override the appropriate methods.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 WebSocket 服务器端点一样，Java WebSocket 客户端可以以编程方式或使用注解的方式开发。再次强调，我们只会介绍注解方法：编程客户端的开发方式与编程服务器端点非常相似，即编程客户端必须扩展
    `javax.websocket.Endpoint` 并重写适当的方法。
- en: 'Without further ado, the following is the code for our Java WebSocket client:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，以下是我们 Java WebSocket 客户端的代码：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class-level `@ClientEndPoint` annotation denotes that our class is a WebSocket
    client—all Java WebSocket clients must be annotated with this annotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的 `@ClientEndPoint` 注解表示我们的类是一个 WebSocket 客户端——所有 Java WebSocket 客户端都必须使用此注解。
- en: The code to establish a connection to the WebSocket server endpoint is in our
    class constructor. First, we need to invoke `ContainerProvider.getWebSocketContainer()`
    to obtain an instance of `javax.websocket.WebSocketContainer`. We then establish
    a connection by invoking the `connectToServer()` method on our `WebSocketContainer`
    instance; then we pass a class annotated with `@ClientEndpoint` as the first parameter
    (we use `this` in our example since the connection code is within our WebSocket
    Java client code); and then we pass a URI object containing the WebSocket server
    endpoint URI as the second parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 建立与 WebSocket 服务器端点连接的代码位于我们的类构造函数中。首先，我们需要调用 `ContainerProvider.getWebSocketContainer()`
    来获取 `javax.websocket.WebSocketContainer` 的一个实例。然后，通过在 `WebSocketContainer` 实例上调用
    `connectToServer()` 方法来建立连接；然后我们将一个带有 `@ClientEndpoint` 注解的类作为第一个参数传递（在我们的例子中，由于连接代码位于我们的
    WebSocket Java 客户端代码中，我们使用 `this`）；然后我们传递一个包含 WebSocket 服务器端点 URI 的 URI 对象作为第二个参数。
- en: After the connection is established, we are ready to respond to WebSocket events.
    Alert readers may have noticed that the exact same annotations we used to develop
    our server endpoint are used again in our client code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们就可以准备响应 WebSocket 事件了。细心的读者可能已经注意到，我们用来开发服务器端点的确切相同的注解再次在我们的客户端代码中使用。
- en: Any method annotated with the `@OnOpen` annotation will be invoked automatically
    when the connection to the WebSocket server endpoint is established. The method
    must return void and can have an optional parameter of the type `javax.websocket.Session`.
    In our example, we send some output to the console and initialize a class variable
    with the `Session` instance, which we received as a parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `@OnOpen` 注解的任何方法都会在连接到 WebSocket 服务器端点时自动调用。该方法必须返回 void，并且可以有一个可选的 `javax.websocket.Session`
    类型的参数。在我们的例子中，我们向控制台发送一些输出，并用接收到的 `Session` 实例初始化一个类变量。
- en: Methods annotated with the `@OnClose` annotation are invoked whenever the WebSocket
    session is closed. The annotated method can have optional parameters of the types
    `javax.websocket.Session` and `CloseReason`. In our example, we chose to use only
    the `CloseReason` optional parameter since its class has a handy `getReasonPhrase()`
    method that provides a short explanation of why the session was closed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@OnClose`注解的方法会在WebSocket会话关闭时被调用。被注解的方法可以包含可选的`javax.websocket.Session`和`CloseReason`类型的参数。在我们的示例中，我们选择只使用`CloseReason`可选参数，因为它的类有一个方便的`getReasonPhrase()`方法，可以提供会话关闭的简要解释。
- en: The `@OnError` annotation is used to decorate any methods that are called when
    an error occurs. Methods annotated with `@OnError` must have a parameter of type
    `java.lang.Throwable` (the parent class of `java.lang.Exception`), and can have
    an optional parameter of type `Session`. In our example, we simply send the stack
    trace of the `Throwable` parameter to `stderr`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnError`注解用于装饰在发生错误时被调用的任何方法。带有`@OnError`注解的方法必须有一个类型为`java.lang.Throwable`（`java.lang.Exception`的父类）的参数，并且可以有一个可选的类型为`Session`的参数。在我们的示例中，我们只是将`Throwable`参数的堆栈跟踪发送到`stderr`。'
- en: 'Methods annotated with `@OnMessage` are invoked every time an incoming WebSocket
    message is received. The `@OnMessage` methods can have different parameters depending
    on the type of message received and how we wish to handle it. In our example,
    we used the most common case: receiving a text message. In this particular case,
    we need a `String` parameter that will hold the contents of the message, and an
    optional `Session` parameter.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@OnMessage`注解的方法会在接收到传入的WebSocket消息时被调用。`@OnMessage`方法可以根据接收到的消息类型以及我们希望如何处理它来具有不同的参数。在我们的示例中，我们使用了最常见的情况：接收文本消息。在这种情况下，我们需要一个`String`参数来保存消息的内容，以及一个可选的`Session`参数。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the JavaDoc documentation for `@OnMessage`, available at [http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html](http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html)
    for information on how to handle other types of messages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何处理其他类型消息的信息，请参阅`@OnMessage`的JavaDoc文档，网址为[http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html](http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html)。
- en: In our example, we simply update the **Chat Window** text area, appending the
    received message to its contents.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们简单地更新了**聊天窗口**文本区域，将接收到的消息追加到其内容中。
- en: To send a WebSocket message, we invoke the `getBasicRemote()` method on our
    `Session` instance, then invoke the `sendText()` method on the resulting `RemoteEndpoint.Basic`
    implementation returned by this call (if this looks familiar, it is because we
    did the exact same thing in the WebSocket server endpoint code). In our example,
    we do this in the `sendMessage()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送WebSocket消息，我们在`Session`实例上调用`getBasicRemote()`方法，然后在这个调用返回的`RemoteEndpoint.Basic`实现上调用`sendText()`方法（如果这看起来很熟悉，那是因为我们在WebSocket服务器端点代码中做了完全相同的事情）。在我们的示例中，我们在`sendMessage()`方法中这样做。
- en: Additional information about the Java API for WebSocket
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Java API for WebSocket的更多信息
- en: In this chapter, we covered the bulk of the functionality provided by the Java
    API for WebSocket. For additional information, refer to the user guide for Tyrus,
    the Java API for WebSocket reference implementation, at [https://tyrus.java.net/documentation/1.3.1/user-guide.html](https://tyrus.java.net/documentation/1.3.1/user-guide.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java API for WebSocket提供的功能的大部分。有关更多信息，请参阅Tyrus用户指南，它是Java API for
    WebSocket的参考实现，网址为[https://tyrus.java.net/documentation/1.3.1/user-guide.html](https://tyrus.java.net/documentation/1.3.1/user-guide.html)。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Java API for WebSocket, which is a new Java
    EE API to develop WebSocket server endpoints and clients.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java API for WebSocket，这是一个新的Java EE API，用于开发WebSocket服务器端点和客户端。
- en: We first saw how to develop WebSocket server endpoints by taking advantage of
    the Java API for WebSockets. We focused on developing annotation-based WebSocket
    endpoints.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到了如何通过利用Java API for WebSockets来开发WebSocket服务器端点。我们专注于开发基于注解的WebSocket端点。
- en: Then, we covered how to develop web-based WebSocket clients using JavaScript
    and the JavaScript built-in WebSocket API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了如何使用JavaScript和JavaScript内置的WebSocket API开发基于Web的WebSocket客户端。
- en: Finally, we explained how to develop WebSocket client applications in Java via
    the `@ClientEndpoint` annotation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解释了如何通过`@ClientEndpoint`注解在Java中开发WebSocket客户端应用程序。
- en: In the next chapter, we will cover the **Java Message Service** (**JMS**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍**Java消息服务**（**JMS**）。
