["```java\nobject ThreadsMain extends App { \n  val t: Thread = Thread.currentThread \n  val name = t.getName \n  println(s\"I am the thread $name\") \n} \n\n```", "```java\n[info] I am the thread run-main-0\n\n```", "```java\n> set fork := true\n\n```", "```java\n[info] I am the thread main\n\n```", "```java\nobject ThreadsCreation extends App { \n  class MyThread extends Thread { \n    override def run(): Unit = { \n      println(\"New thread running.\") \n    } \n  } \n  val t = new MyThread \n  t.start() \n  t.join() \n  println(\"New thread joined.\") \n} \n\n```", "```java\ndef thread(body: =>Unit): Thread = { \n  val t = new Thread { \n    override def run() = body \n  } \n  t.start() \n  t \n} \n\n```", "```java\nobject ThreadsSleep extends App { \n  val t = thread { \n    Thread.sleep(1000) \n    log(\"New thread running.\") \n    Thread.sleep(1000) \n    log(\"Still running.\") \n    Thread.sleep(1000) \n    log(\"Completed.\") \n  } \n  t.join() \n  log(\"New thread joined.\") \n} \n\n```", "```java\nobject ThreadsNondeterminism extends App { \n  val t = thread { log(\"New thread running.\") } \n  log(\"...\") \n  log(\"...\") \n  t.join() \n  log(\"New thread joined.\") \n} \n\n```", "```java\nrun-main-46: ...\nThread-80: New thread running.\nrun-main-46: ...\nrun-main-46: New thread joined.\n\n```", "```java\nThread-81: New thread running.\nrun-main-47: ...\nrun-main-47: ...\nrun-main-47: New thread joined.\n\n```", "```java\nobject ThreadsCommunicate extends App { \n  var result: String = null \n  val t = thread { result = \"\\nTitle\\n\" + \"=\" * 5 } \n  t.join() \n  log(result) \n} \n\n```", "```java\nobject ThreadsUnprotectedUid extends App { \n  var uidCount = 0L \n  def getUniqueId() = { \n    val freshUid = uidCount + 1 \n    uidCount = freshUid \n    freshUid \n  } \n\n```", "```java\n  def printUniqueIds(n: Int): Unit = { \n    val uids = for (i<- 0 until n) yield getUniqueId() \n    log(s\"Generated uids: $uids\") \n  } \n  val t = thread { printUniqueIds(5) } \n  printUniqueIds(5) \n  t.join() \n} \n\n```", "```java\ndef getUniqueId() = this.synchronized { \n  val freshUid = uidCount + 1 \n  uidCount = freshUid \n  freshUid \n} \n\n```", "```java\nobject ThreadSharedStateAccessReordering extends App { \n  for (i <- 0 until 100000) { \n    var a = false \n    var b = false \n    var x = -1 \n    var y = -1 \n    val t1 = thread { \n      a = true \n      y = if (b) 0 else 1 \n    } \n    val t2 = thread { \n      b = true \n      x = if (a) 0 else 1 \n    } \n    t1.join() \n    t2.join() \n    assert(!(x == 1 && y == 1), s\"x = $x, y = $y\") \n  } \n} \n\n```", "```java\n[error] Exception in thread \"main\": assertion failed: x = 1, y = 1\n\n```", "```java\nobject SynchronizedNesting extends App { \n  import scala.collection._ \n  private val transfers = mutable.ArrayBuffer[String]() \n  def logTransfer(name: String, n: Int) = transfers.synchronized { \n    transfers += s\"transfer to account '$name' = $n\" \n  } \n\n```", "```java\n  class Account(val name: String, var money: Int) \n  def add(account: Account, n: Int) = account.synchronized { \n    account.money += n \n    if (n > 10) logTransfer(account.name, n) \n  } \n\n```", "```java\n  // Continuation of the bank account example. \n  val jane = new Account(\"Jane\", 100) \n  val john = new Account(\"John\", 200) \n  val t1 = thread { add(jane, 5) } \n  val t2 = thread { add(john, 50) } \n  val t3 = thread { add(jane, 70) } \n  t1.join(); t2.join(); t3.join() \n  log(s\"--- transfers ---\\n$transfers\") \n} \n\n```", "```java\nobject SynchronizedDeadlock extends App { \n  import SynchronizedNesting.Account \n  def send(a: Account, b: Account, n: Int) = a.synchronized { \n    b.synchronized { \n      a.money -= n \n      b.money += n \n    } \n  } \n\n```", "```java\n  val a = new Account(\"Jack\", 1000) \n  val b = new Account(\"Jill\", 2000) \n  val t1 = thread { for (i<- 0 until 100) send(a, b, 1) } \n  val t2 = thread { for (i<- 0 until 100) send(b, a, 1) } \n  t1.join(); t2.join() \n  log(s\"a = ${a.money}, b = ${b.money}\") \n} \n\n```", "```java\nimport SynchronizedProtectedUid.getUniqueId \nclass Account(val name: String, var money: Int) { \n  val uid = getUniqueId() \n} \n\n```", "```java\ndef send(a1: Account, a2: Account, n: Int) { \n  def adjust() { \n    a1.money -= n \n    a2.money += n \n  } \n  if (a1.uid < a2.uid) \n    a1.synchronized { a2.synchronized { adjust() } } \n  else a2.synchronized { a1.synchronized { adjust() } } \n} \n\n```", "```java\nimport scala.collection._ \nobject SynchronizedBadPool extends App { \n  private val tasks = mutable.Queue[() => Unit]() \n\n```", "```java\n  val worker = new Thread { \n    def poll(): Option[() => Unit] = tasks.synchronized { \n      if (tasks.nonEmpty) Some(tasks.dequeue()) else None \n    } \n    override def run() = while (true) poll() match { \n      case Some(task) => task() \n      case None => \n    } \n  } \n  worker.setName(\"Worker\") \n  worker.setDaemon(true) \n  worker.start() \n\n```", "```java\n  def asynchronous(body: =>Unit) = tasks.synchronized { \n    tasks.enqueue(() => body) \n  } \n  asynchronous { log(\"Hello\") } \n  asynchronous { log(\" world!\")} \n  Thread.sleep(5000) \n} \n\n```", "```java\nset fork := true \n\n```", "```java\nobject SynchronizedGuardedBlocks extends App { \n  val lock = new AnyRef \n  var message: Option[String] = None \n  val greeter = thread { \n    lock.synchronized { \n      while (message == None) lock.wait() \n      log(message.get) \n    } \n  } \n  lock.synchronized { \n    message = Some(\"Hello!\") \n    lock.notify() \n  } \n  greeter.join() \n} \n\n```", "```java\nobject SynchronizedPool extends App { \n  private val tasks = mutable.Queue[() => Unit]() \n  object Worker extends Thread { \n    setDaemon(true) \n    def poll() = tasks.synchronized { \n      while (tasks.isEmpty) tasks.wait() \n      tasks.dequeue() \n    } \n    override def run() = while (true) { \n      val task = poll() \n      task() \n    } \n  } \n  Worker.start() \n  def asynchronous(body: =>Unit) = tasks.synchronized { \n    tasks.enqueue(() => body) \n    tasks.notify() \n  } \n  asynchronous { log(\"Hello \") } \n  asynchronous { log(\"World!\") } \n  Thread.sleep(500) \n} \n\n```", "```java\nWorker.interrupt() \n\n```", "```java\nobject Worker extends Thread { \n  var terminated = false \n  def poll(): Option[() => Unit] = tasks.synchronized { \n    while (tasks.isEmpty && !terminated) tasks.wait() \n    if (!terminated) Some(tasks.dequeue()) else None \n  } \n\n```", "```java\n  import scala.annotation.tailrec \n  @tailrec override def run() = poll() match { \n    case Some(task) => task(); run() \n    case None => \n  } \n  def shutdown() = tasks.synchronized { \n    terminated = true \n    tasks.notify() \n  } \n} \n\n```", "```java\nclass Page(val txt: String, var position: Int) \nobject Volatile extends App { \n  val pages = for (i<- 1 to 5) yield \n    new Page(\"Na\" * (100 - 20 * i) + \" Batman!\", -1) \n  @volatile var found = false \n  for (p <- pages) yield thread { \n    var i = 0 \n    while (i < p.txt.length && !found) \n      if (p.txt(i) == '!') { \n        p.position = i \n        found = true \n      } else i += 1 \n  } \n  while (!found) {} \n  log(s\"results: ${pages.map(_.position)}\") \n} \n\n```", "```java\nclass Foo(final val a: Int, val b: Int) \n\n```", "```java\nclass Foo { // Java code below \n  final private int a$; \n  final private int b$; \n  final public int a() { return a$; } \n  public int b() { return b$; } \n  public Foo(int a, int b) { \n    a$ = a; \n    b$ = b; \n  } \n} \n\n```", "```java\nvar inc: () => Unit = null \nval t = thread { if (inc != null) inc() } \nprivate var number = 1 \ninc = () => { number += 1 } \n\n```", "```java\nnumber = new IntRef(1) // captured local variables become objects \ninc = new Function0 { \n  val $number = number // recall - vals are final! \n  def apply() = $number.elem += 1 \n} \n\n```", "```java\n                def parallel[A, B](a: =>A, b: =>B): (A, B) \n\n    ```", "```java\n                def periodically(duration: Long)(b: =>Unit): Unit \n\n    ```", "```java\n                    class SyncVar[T] { \n                      def get(): T = ??? \n                      def put(x: T): Unit = ??? \n                    } \n\n    ```", "```java\n                def getWait(): T \n                def putWait(x: T): Unit \n\n    ```", "```java\n                def sendAll(accounts: Set[Account], target: Account): Unit \n\n    ```", "```java\n                def asynchronous(priority: Int)(task: =>Unit): Unit \n\n    ```", "```java\n                def shutdown(): Unit \n\n    ```", "```java\n                class ConcurrentBiMap[K, V] { \n                  def put(k: K, v: V): Option[(K, V) \n                  def removeKey(k: K): Option[V] \n                  def removeValue(v: V): Option[K] \n                  def getValue(k: K): Option[V] \n                  def getKey(v: V): Option[K] \n                  def size: Int \n                  def iterator: Iterator[(K, V)] \n                } \n\n    ```", "```java\n                def replace(k1: K, v1: V, k2: K, v2: V): Unit \n\n    ```", "```java\n                def cache[K, V](f: K => V): K => V \n\n    ```"]