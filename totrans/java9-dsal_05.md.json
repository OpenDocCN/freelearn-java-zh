["```java\n    public static <E, F extends E> int linearSearch(E[] values, \n    valueToLookup) { \n        for (int i = 0; i < values.length; i++) { \n            if (values[i].equals(valueToLookup)) { \n                return i; \n            } \n        } \n        return -1; \n    }\n```", "```java\n        Integer[] integers = new Integer[]{232,54,1,213,654,23,6,72,21}; \n        System.out.println(ArraySearcher.linearSearch(integers,5)); \n        System.out.println(ArraySearcher.linearSearch(integers,23));\n```", "```java\n    static String[] students = new String[]{\"Tom\",\"Harry\",\"Merry\",\"Aisha\", \"Abdullah\"}; \n    static int[] marks = new int[]{63,70, 65, 85, 72}; \n```", "```java\n    public static Integer marksForName(String name){ \n        int index = linearSearch(students, name); \n        if(index>=0){ \n            return marks[index]; \n        }else{ \n            return null; \n        } \n    }\n```", "```java\n        System.out.println(marksForName(\"Merry\"));\n```", "```java\npackage java.lang; \npublic interface Comparable<T> { \n    public int compareTo(T o); \n} \n```", "```java\npublic class Integer implements Comparable<Integer>{\n    public int compareTo(Integer o){\n        …\n    } \n}\n```", "```java\n    private static <E extends Comparable<E>, \n      F extends E> int binarySearch( E[] sortedValues, \n      F valueToSearch, int start, int end) { \n        if(start>=end){ \n            return -1; \n        } \n        int midIndex = (end+start)/2; \n        int comparison = sortedValues[midIndex].compareTo(valueToSearch); \n        if(comparison==0){ \n            return midIndex; \n        }else if(comparison>0){ \n            return binarySearch(sortedValues, valueToSearch, start, midIndex); \n        }else{ \n            return binarySearch(sortedValues, valueToSearch, midIndex+1, end); \n        } \n    }\n```", "```java\n    public static <E extends Comparable<E>, F extends E> int binarySearch( \n            E[] sortedValues, F valueToSearch) { \n        return binarySearch(sortedValues, valueToSearch, 0, sortedValues.length); \n    }\n```", "```java\nT(n) = T((n-1)/2) + C, where C is a constant.\n```", "```java\nT(n) = T(n/2) + C\n```", "```java\nT(2m) = T(2m-1) + C\n```", "```java\nS(m) = S(m-1) + C\n```", "```java\nS(m) = mC + D, where D is also a constant.\n=> T(2m) = mC + D\n=> T(n) = C lg(n) + D\n```", "```java\nT(n) = O(lg(n))\n```", "```java\n        int arraySize = 100000000; \n        Long array[] = new Long[arraySize]; \n        array[0] = (long)(Math.random()*100); \n        for(int i=1;i<array.length;i++){ \n            array[i] = array[i-1] + (long)(Math.random()*100); \n        } \n\n        //let us look for an element using linear and binary search \n        long start = System.currentTimeMillis(); \n        linearSearch(array, 31232L); \n        long linEnd = System.currentTimeMillis(); \n        binarySearch(array, 31232L); \n        long binEnd = System.currentTimeMillis(); \n\n        System.out.println(\"linear search time :=\" + (linEnd -start)); \n        System.out.println(\"binary search time :=\" + (binEnd -linEnd));\n```", "```java\n    public static <E extends Comparable<E>> int findMin(E[] array, int start){ \n```", "```java\n        if(start==array.length-1){ \n            return start; \n        } \n```", "```java\n        int restMinIndex = findMin(array, start+1); \n        E restMin = array[restMinIndex]; \n        if(restMin.compareTo(array[start])<0){ \n            return restMinIndex; \n        }else { \n            return start; \n        } \n    }\n```", "```java\n    public static <E> void swap(E[] array, int i, int j){ \n        if(i==j) \n            return; \n        E temp = array[i]; \n        array[i]=array[j]; \n        array[j] = temp; \n    }\n```", "```java\n    public static <E extends Comparable<E>> void selectionSort(\n    E[] array, int start){ \n```", "```java\n        if(start>=array.length){ \n            return; \n        } \n```", "```java\n        int minElement = findMin(array, start); \n        swap(array,start, minElement); \n```", "```java\n        selectionSort(array, start+1); \n    }\n```", "```java\n    public static <E extends Comparable<E>> void selectionSort( \n    E[] array) { \n        selectionSort(array, 0); \n    }\n```", "```java\n        Integer[] array = new Integer[]{10, 5, 2, 3, 78, 53, 3}; \n        selectionSort(array); \n        System.out.println(Arrays.toString(array));\n```", "```java\n[2, 3, 3, 5, 10, 53, 78]\n```", "```java\nT(n) = T(n-1) + A where A is a constants\n=> T(n) – T(n-1) = A, so it is an arithmetic progression\n=> T(n) = An + B where B is a constant\n=> T(n) = θ(n)\n```", "```java\nT(n) = T(n-1) + θ(n) + θ(1)\n```", "```java\nT(n) = T(n-1) + Cn + D\n=> T(n) – T(n-1) = Cn + D\n```", "```java\nT(n) – T(n-1) = Cn + D\n T(n-1) – T(n-2) = C(n-1) + D\n T(n-2) – T(n-3) = C(n-2) + D\n T(n-3) – T(n-4) = C(n-3) + D\n…\n T(1) – T(0) = C(1) + D\n```", "```java\n    public static <E extends Comparable<E>> void insertElementSorted( \n    E[] array, int valueIndex) { \n\n        if (valueIndex > 0 && array[valueIndex].compareTo(array[valueIndex - 1]) < 0) { \n            swap(array, valueIndex, valueIndex - 1); \n            insertElementSorted(array, valueIndex - 1); \n        } \n\n    }\n```", "```java\n    public static <E extends Comparable<E>> void insertionSort( \n    E[] array, int boundary) { \n        if(boundary==0){ \n            return; \n        } \n        insertionSort(array, boundary-1); \n        insertElementSorted(array, boundary); \n    }\n```", "```java\nT(n) = T(n-1) + C where C is a constant \n=> T(n) = θ(n)\n```", "```java\nS(n) = S(n-1) + T(n) + D where D is a constant.\n```", "```java\nS(n)  = S(n-1) + An + D\n=> S(n) – S(n-1) = An + D,\n```", "```java\n S(n) – S(n-1) = An + D\n S(n-1) – S(n-2) = A(n-1) + D\n S(n-2) – S(n-3) = A(n-2) + D\n…\n S(1) – S(0) = A + D\n```", "```java\n    public static <E extends Comparable<E>> void bubbleSort( \n    E[] array) { \n        boolean sorted = false; \n        while (!sorted) { \n            sorted = true; \n            for (int i = 0; i < array.length - 1; i++) { \n                if (array[i].compareTo(array[i + 1]) > 0) { \n                    swap(array, i, i + 1); \n                    sorted = false; \n                } \n            } \n        } \n    }\n```", "```java\nInteger[] array = new Integer[]{10, 5, 2, 3, 78, 53, 3};\n```", "```java\n10>5, 10>2, 10>3, 10<78,  10<53, 10>3\n            5>2,    5>3,     5<78,    5<53,   5>3\n                  ,    2<3,     2<78,    2<53,   2<3\n                             ,        3<78,    3<53,   3=3\n                                               , 78>53,  78>3\n                                                          53>3\n```", "```java\n …......., j, j+1, …....\n```", "```java\n   private static <E extends Comparable<E>, F extends E> int binarySearch( \n        E[] sortedValues, F valueToSearch, int start, int end) { \n        if(start>=end){ \n            return -1; \n        } \n        int midIndex = (end+start)/2; \n        int comparison = sortedValues[midIndex].compareTo(valueToSearch); \n        if(comparison==0){ \n            return midIndex; \n        }else if(comparison>0){ \n            return binarySearch(sortedValues, valueToSearch, start, midIndex); \n        }else{ \n            return binarySearch(sortedValues, valueToSearch, midIndex+1, end); \n        } \n    }\n```", "```java\n    private static <E extends Comparable<E>, F extends E> int binarySearchNonRecursive( \n        E[] sortedValues, F valueToSearch, int start, int end) { \n        while(true) { \n            if (start >= end) { \n                return -1; \n            } \n            int midIndex = (end + start) / 2; \n            int comparison = sortedValues[midIndex]\n                               .compareTo(valueToSearch); \n            if (comparison == 0) { \n                return midIndex; \n            } else if (comparison > 0) { \n                end = midIndex; \n            } else { \n                start = midIndex + 1; \n            } \n       } \n    }\n```", "```java\n          public static <E extends Comparable<E>> void insertElementSorted( \n            E[] array, int valueIndex) { \n\n              if (valueIndex > 0 && array[valueIndex].compareTo(array[valueIndex - 1]) < 0) { \n                swap(array, valueIndex, valueIndex - 1); \n                insertElementSorted(array, valueIndex - 1); \n        } \n\n    }\n```", "```java\n     public static <E extends Comparable<E>> void insertElementSorted( \n     E[] array, int valueIndex) { \n\n        if (valueIndex > 0 && array[valueIndex].compareTo(array[valueIndex - 1]) < 0) { \n            swap(array, valueIndex, valueIndex - 1); \n            insertElementSorted(array, valueIndex - 1); \n        } else{\n return;\n } \n     }\n```", "```java\n   public static <E extends Comparable<E>> void insertElementSortedNonRecursive( \n        E[] array, int valueIndex) { \n        while(true) { \n            if (valueIndex > 0 && array[valueIndex].compareTo(array[valueIndex - 1]) < 0) { \n                swap(array, valueIndex, valueIndex - 1); \n                valueIndex =  valueIndex – 1; \n            }else{ \n                return; \n            } \n        } \n\n    }\n```", "```java\n   public static <E extends Comparable<E>> void insertionSort( \n        E[] array, int boundary) { \n        if(boundary==0){ \n            return; \n        } \n        insertionSort(array, boundary-1); \n        insertElementSorted(array, boundary); \n    }\n```", "```java\n    public static BigInteger factorialRecursive(int x){ \n        if(x==0){ \n            return BigInteger.ONE; \n        }else{ \n            return factorialRecursive(x-1).multiply(BigInteger.valueOf(x)); \n        } \n    }\n```", "```java\n   public static BigInteger factorialRecursiveNonRecursive(int x){ \n        BigInteger prod = BigInteger.ONE; \n        for(int i=1;i<=x;i++){ \n            prod = prod.multiply(BigInteger.valueOf(x)); \n        } \n        return prod; \n    }\n```", "```java\n    public static <E extends Comparable<E>> void insertionSortNonRecursive( \n        E[] array) { \n        for(int boundary = 0;boundary<array.length;boundary++) { \n            insertElementSortedNonRecursive(array, boundary); \n        } \n    } \n```"]