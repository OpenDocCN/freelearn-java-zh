<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;User Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. User Interfaces</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"If you can dream it, you can do it."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Walt Disney</em></span></span></td></tr></table></div><p>Aside from user controls for games and simulations, you will, at times, want your user to click buttons, view text, and select items from menus. Imagine that you are creating a physics simulation and want to have your user set certain simulation parameters or that you have a store in your game where players can purchase upgrades. Or perhaps you want to create a dialogue between two actors in your scenario. In this chapter, we are going to explore techniques to provide various types of <a id="id507" class="indexterm"/><span class="strong"><strong>user interfaces</strong></span> (<span class="strong"><strong>UIs</strong></span>). Specifically, we will look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Buttons and labels</li><li class="listitem">Menus</li><li class="listitem">Heads-up display (HUD)</li></ul></div><p>Greenfoot provides little direct support to create user interfaces. There are only a few classes, such as <code class="literal">Label</code> and <code class="literal">Counter</code>, packaged with Greenfoot to help in this regard. So, we will have to build our own support. We will use Greenfoot <code class="literal">Actors</code> and the <code class="literal">GreenfootImage</code> class to create user interfaces and classes that will support the creation of user interfaces. Luckily, Greenfoot allows us to build just about anything we can dream up, including user interfaces.</p><div class="section" title="UIWorld"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>UIWorld</h1></div></div></div><p>In this section, we<a id="id508" class="indexterm"/> will explain how to write the following user interface<a id="id509" class="indexterm"/> elements: buttons, textboxes, menus, and <a id="id510" class="indexterm"/><span class="strong"><strong>heads-up displays</strong></span> (<span class="strong"><strong>HUDs</strong></span>). We are going to work through a Greenfoot scenario (shown in <span class="emphasis"><em>Figure 1</em></span>) that only contains user interface elements, so we can discuss each element independently.</p><p>Some of the code we write will be general and able to be applied to many different scenarios. In other cases, we will write user interface code that will only need minor modification to be used across scenarios. In the next section, we will add these elements to the <code class="literal">MazeWorld</code> scenario that we wrote in the previous <a id="id511" class="indexterm"/>chapter, to make it a more polished and playable game.</p><div class="mediaobject"><img src="../Images/image00318.jpeg" alt="UIWorld"/><div class="caption"><p>Figure 1: This shows UI MainWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>To work through this scenario, start with a new Greenfoot scenario named <code class="literal">UIMainWorld</code>, create a subclass of <code class="literal">World</code> named <code class="literal">UIMainWorld</code>, and then associate a plain background to it. The background I chose was <code class="literal">bluerock.jpg</code>. Here is the code for <code class="literal">UIMainWorld</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class UIMainWorld extends World {
  
  public UIMainWorld() {
    super(600, 400, 1);
    testActors();
  }
  
  private void testActors() {
    /*   Begin comment
    TextBox t1 = new TextBox(
    " This is a question?\n Yes, it is! ",
    24, true, Color.BLUE, Color.YELLOW);
    addObject(t1, 150, 50);
    TextBox t2 = new TextBox("This is one line",
    18, false, Color.BLACK, Color.WHITE);
    addObject(t2, 150, 120);
    Button b1 = new Button("button-blue.png",
    "button-green.png");
    addObject(b1, 450, 50);
    Menu m1 = new Menu(" Destroy Everything? ",
    "Are you sure?", 18,
    Color.BLUE, Color.WHITE
    Color.BLACK, Color.WHITE,
    new DestroyCommands());
    addObject(m1, 450, 120);
    Menu m2 = new Menu(" File ",
    "New\nOpen\nSave\nClose\nExit", 18,
    Color.BLACK, Color.lightGray,
    Color.WHITE, Color.BLUE,
    new FileCommands());
    addObject(m2, 450, 180);
    HUD h = new HUD();
    addObject(h, 300, 310);
    Label l = new Label("This is a label", 18);
    addObject(l, 150, 180);
    End Comment  */
  }
}</pre></div><p>For now, the<a id="id512" class="indexterm"/> lines of code in the <code class="literal">testActors()</code> method are commented out. Uncomment them as we implement the associated actor, so that you can test and play with each one in turn. If you prefer, you can download the complete UI scenario from <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p><div class="section" title="The Button class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec73"/>The Button class</h2></div></div></div><p>Is there<a id="id513" class="indexterm"/> a more prolific UI element than the humble button? It is hard to imagine any interface that does not contain several of these buttons. Luckily for us, they are very easy to implement in Greenfoot. In your UI scenario, subclass the <code class="literal">Actor</code> class and call this new subclass <code class="literal">Button</code>. Choose <span class="strong"><strong>No Image</strong></span> for the image of <code class="literal">Button</code>. We<a id="id514" class="indexterm"/> will dynamically add the images necessary for this actor. Here is the code for the <code class="literal">Actor</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Button extends Actor {
  protected String first;
  protected String second;
  
  public Button(String f, String s) {
    first = f;
    second = s;
    setImage(f);
  }
  
  public void act() {
    handleMouseClicks();
  }
  
  private void handleMouseClicks() {
    if( Greenfoot.mousePressed(this) ) {
      setImage(second);
    } else if( Greenfoot.mouseClicked(this) ) {
      setImage(first);
      clickedAction();
    }
  }
  
  protected void clickedAction() {
    // Can either fill this in or have subclasses override.
  }
}</pre></div><p>For a button, you need to have one image for the normal state and one image for the pressed state. The <code class="literal">first</code> and <code class="literal">second</code> instance variables store the names of these images. Their values are provided to the class's constructor as input parameters. The constructor sets the initial image to the <code class="literal">first</code> image.</p><p>The <code class="literal">act()</code> method only contains one method call to handle mouse events for this actor—<code class="literal">handleMouseClicks()</code>. This method displays the <code class="literal">second</code> image when the mouse is pressed and then goes back to displaying the <code class="literal">first</code> image when the click completes. In Greenfoot, the <code class="literal">Greenfoot.mousePressed()</code> method returns <code class="literal">true</code> when the left mouse button is held down on the given object. The <code class="literal">Greenfoot.mouseClicked()</code> method returns <code class="literal">true</code> when the left mouse button is pressed down and released on the given object. <span class="emphasis"><em>Figure 2</em></span> demonstrates<a id="id515" class="indexterm"/> these two mouse events. When we detect that the mouse is pressed, we simply change the image to the <code class="literal">second</code> image. When the mouse is released, a full click has occurred, and we do two things. First, we set the image back to normal, and then we perform an action by calling the <code class="literal">clickedAction()</code> method. This method is currently empty and serves as a placeholder where you could put the code for your own custom action. Another option, would be to subclass this class and override the <code class="literal">clickedAction()</code> method in your new subclass.</p><div class="mediaobject"><img src="../Images/image00319.jpeg" alt="The Button class"/><div class="caption"><p>Figure 2: In Greenfoot, a mouse is considered clicked when the left mouse button is both pressed and released</p></div></div><p style="clear:both; height: 1em;"> </p><p>The button was added to the screen in the <code class="literal">UIMainWorld</code> subclass of <code class="literal">World</code> with the following two lines of code:</p><div class="informalexample"><pre class="programlisting">Button b1 = new Button("button-blue.png", "button-green.png");
addObject(b1, 450, 50);</pre></div><p>The <code class="literal">button-blue.png</code> and <code class="literal">button-green.png</code> images are the images that come with the default installation of Greenfoot (not available in version 2.2). You can quickly get these images into your project by creating temporary actors that have them as their default image or by copying them from the installation of Greenfoot. Uncomment the two lines shown in the <code class="literal">testActors()</code> method in <code class="literal">UIMainWorld</code>, compile your scenario, and test out your new button.</p></div><div class="section" title="The TextBox class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/>The TextBox class</h2></div></div></div><p>The<a id="id516" class="indexterm"/> functionality of <code class="literal">TextBox</code> is very similar in functionality to the <code class="literal">Label</code> class that is supplied with Greenfoot. Note that in <code class="literal">UIMainWorld</code>, we added one instance of the <code class="literal">Label</code> class to our scenario for demonstration and comparison purposes. To add the <code class="literal">Label</code> class to your UI scenario, click on <span class="strong"><strong>Edit</strong></span> in Greenfoot's main menu and then click on <span class="strong"><strong>Import Class…</strong></span>. Click on <span class="strong"><strong>Label</strong></span> on the left-hand side of the pop-up window that appears, read the documentation on the <code class="literal">Label</code> class (if you are interested), and then click on the <span class="strong"><strong>Import</strong></span> button. We will implement our own version of <code class="literal">Label</code> and call it <code class="literal">TextBox</code>. The <code class="literal">Textbox</code> class we will write is a bit more concise and provides us with a reason to discuss how to work with text in Greenfoot.</p><p>In <span class="emphasis"><em>Figure 1</em></span>, we can see two examples of the <code class="literal">TextBox</code> class. This class allows us to display text on the screen with a custom font, color, background color, and optional border. Here is the code for <code class="literal">TextBox</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class TextBox extends Actor {
  private GreenfootImage img;
  private boolean border = false;
  private int fontSize;
  private Color foreground;
  private Color background;
  
  public TextBox(String s, int fs, boolean b,
  Color fg, java.awt.Color bg) {
    super();
    fontSize = fs;
    foreground = fg;
    background = bg;
    img = new GreenfootImage(s, fontSize,
    foreground, background);
    border = b;
    display();
  }
  
  public void setText(String s) {
    img = new GreenfootImage(s, fontSize,
    foreground, background);
    display();
  }
  
  private void display() {
    setImage(img);
    if( border ) {
      img.setColor(Color.BLACK);
      img.drawRect(0, 0, img.getWidth()-1,
      img.getHeight()-1);
      setImage(img);
    }
  }
}</pre></div><p>In <code class="literal">TextBox</code>, we <a id="id517" class="indexterm"/>can configure the foreground color, background color, font size, and whether or not to draw a border around the textbox. In addition to the actual text to display, the constructor accepts and stores these values. The <code class="literal">display()</code> method is responsible for actually creating our new textbox. First, it creates a new image based on the earlier configuration information using Greenfoot's <code class="literal">GreenfootImage()</code> method.</p><p>When you supply text as the first parameter to <code class="literal">GreenfootImage()</code>, it will create an image of that text. Then, we can just use <code class="literal">setImage()</code> to display that text. The <code class="literal">display()</code> method checks the <code class="literal">border</code> instance variable and draws a border in the new image we created, if needed. We also supplied a <code class="literal">setText()</code> method, in case we need to dynamically change the text. This method creates a new <code class="literal">GreenfootImage</code> based on the new text and then uses the <code class="literal">display()</code> method to properly set the image of the textbox to the new image created.</p><p>To test our new <code class="literal">TextBox</code> class, uncomment all the lines in <code class="literal">testActors()</code> in <code class="literal">UIMainWorld</code> that deal with adding instances of <code class="literal">TextBox</code>, compile the scenario, and run it.</p></div><div class="section" title="The Menu class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/>The Menu class</h2></div></div></div><p>Menus <a id="id518" class="indexterm"/>are amazing at accepting user commands. I am sure you have had plenty of experience using them and understand their utility. Our implementation of a menu involves using the <code class="literal">TextBox</code> class we just created and a new Java interface named <code class="literal">MenuCommands</code> that we will implement soon. The <code class="literal">TextBox</code> instances display the text, and the actions of the menu choice are performed by classes that implement the <code class="literal">MenuCommands</code> interface. We will explain that more thoroughly soon.</p><p><span class="emphasis"><em>Figure 3</em></span> provides an overview of the functionality of our <code class="literal">Menu</code> class. Our menu initially looks like <code class="literal">TextBox</code>, as shown in <span class="emphasis"><em>Figure 3(a)</em></span>. When the user clicks on the menu, a pop-up menu appears with a set <a id="id519" class="indexterm"/>of actions the user can choose from. The pop-up menu is shown in <span class="emphasis"><em>Figure 3(b)</em></span>. Both the menu title and set of commands are configurable.</p><div class="mediaobject"><img src="../Images/image00320.jpeg" alt="The Menu class"/><div class="caption"><p>Figure 3: Initially, menu objects look like TextBox (see (a)). When the user clicks on the text, a drop-down menu appears, giving the user multiple items to choose from (see (b))</p></div></div><p style="clear:both; height: 1em;"> </p><p>Here is the code for <code class="literal">Menu</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class Menu extends Actor
{
  private TextBox titleBar;
  private TextBox menuItems;
  private MenuCommands menuCommands;
  private int fontSize = 24;
  private boolean visible = false;
  private Color mainFG;
  private Color mainBG;
  private Color secondFG;
  private Color secondBG;
  int th, mh;  /* title and menu height */
  
  public Menu(String tb, String i, int fs,
  Color fg1, Color bg1, Color fg2, Color bg2,
  MenuCommands mc) {
    mainFG = fg1;
    mainBG = bg1;
    secondFG = fg2;
    secondBG = bg2;
    titleBar = new TextBox(tb, fs, true, mainFG, mainBG);
    menuItems = new TextBox(i, fs, true, secondFG, secondBG);
    menuCommands = mc;
    fontSize = fs;
  }
  
  public Menu() {
    this("not initialized", "none", 24,
    Color.BLACK, Color.lightGray, Color.BLACK,
    Color.WHITE, null);
  }
  
  protected void addedToWorld(World w) {
    w.addObject(titleBar, getX(), getY());
    th = titleBar.getImage().getHeight();
    mh = menuItems.getImage().getHeight();
  }
  
  public void act() {
    handleMouse();
  }
  
  private void handleMouse() {
    if( Greenfoot.mouseClicked(titleBar) ) {
      if( !visible ) {
        getWorld().addObject(menuItems,
        getX(), getY()+(th+mh)/2);
      } else {
        getWorld().removeObject(menuItems);
      }
      visible = !visible;
    }
    
    if( Greenfoot.mouseClicked(menuItems)) {
      MouseInfo mi = Greenfoot.getMouseInfo();
      int menuIndex =
      ((mi.getY()-menuItems.getY()+mh/2)-1)/fontSize;
      menuCommands.execute(menuIndex, getWorld());
      visible = !visible;
      getWorld().removeObject(menuItems);
    }
  }
}</pre></div><p>An instance of <code class="literal">Menu</code> is <a id="id520" class="indexterm"/>composed of two <code class="literal">TextBox</code> instances and one implementation of the <code class="literal">MenuCommands</code> interface. The first <code class="literal">TextBox</code> instance represents the menu title (shown in <span class="emphasis"><em>Figure 3(a)</em></span>), and the second <code class="literal">TextBox</code> instance represents the collection of commands (shown in <span class="emphasis"><em>Figure3(b)</em></span>). The Menu constructor creates both <code class="literal">TextBox</code> instances and stores the supplied <code class="literal">MenuCommands</code> object for later use.</p><p>When <code class="literal">Menu</code> is added to <code class="literal">World</code>, we use the <code class="literal">addedToWorld()</code>method to place the menu title bar in the scenario and collect height information needed to properly place the pop-up window later.</p><p>The <code class="literal">act()</code> method calls one method, <code class="literal">handleMouse()</code>, that places the menu item popup when the title text is clicked on. For the menu item popup, the method <code class="literal">handleMouse()</code> determines whether it was clicked on and where it was clicked and then calls the appropriate command. The following code determines the click location:</p><div class="informalexample"><pre class="programlisting">((mi.getY()-menuItems.getY()+mh/2)-1)/fontSize</pre></div><p>This is based on the current font size and the height of the <code class="literal">TextBox</code> menu item. <span class="emphasis"><em>Figure 4</em></span> shows the calculation pictorially.</p><div class="mediaobject"><img src="../Images/image00321.jpeg" alt="The Menu class"/><div class="caption"><p>Figure 4: To determine which menu item was clicked on, use this formula: ((a)-(b)+(c))/(d). This formula determines the distance between the center of the image (b) and the click location (a), adjusts the value so that it is relative to the top of the figure by adding half the height (c) and then dividing by the font size (d) to get the actual index of the item</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we know the<a id="id521" class="indexterm"/> index of the menu item clicked on by the user, we need to run the command associated with it. To do this, we simply call the <code class="literal">execute()</code> method on the <code class="literal">MenuCommands</code> object that was passed to us via the constructor. <code class="literal">MenuCommands</code> is a Java interface that guarantees that any Java class that implements this interface will have the <code class="literal">execute()</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="tip24"/>Tip</h3><p>We first encountered Java interfaces in <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>. Remember that a class that implements a Java interface is promising to provide an implementation of every method defined in that interface. For more information, review <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>.</p></div><p>Here is the code for <code class="literal">MenuCommands</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public interface MenuCommands {
  public void execute(int idx, World w);
}</pre></div><p>As we can see, this interface only defines one method, <code class="literal">execute()</code>, that must accept an integer parameter (representing the index of the menu item) and a reference to the current <code class="literal">World</code> instance.</p><p>In our UI scenario, we provide two examples of using the <code class="literal">Menu</code> class. The first is the one that has the menu title bar text, <span class="strong"><strong>Destroy Everything?</strong></span>. The menu that pops up only has one option, <span class="strong"><strong>Are you sure?</strong></span>. Here is the code for the <code class="literal">DestroyCommands</code> class, which implements the <code class="literal">MenuCommands</code> interface:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class DestroyCommands implements MenuCommands {
  public void execute(int idx, World w) {
    System.out.println("Boooom!!!!");
  }
}</pre></div><p>Because the pop-up menu<a id="id522" class="indexterm"/> only has one choice, we do not need to use the supplied <code class="literal">idx</code> value. We implement the <code class="literal">execute()</code> method by simply printing <span class="strong"><strong>Boooom!!!!</strong></span> to the console window.</p><p>The second <code class="literal">Menu</code> class example mimics the types of commands you would see in an application that works with files. This example is shown in <span class="emphasis"><em>Figure 3</em></span>. Here is the code for <code class="literal">FileCommands</code>, which implements the <code class="literal">MenuCommands</code> interface:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class FileCommands implements MenuCommands {
  public void execute(int idx, World w) {
    switch(idx) {
      case 0:
      System.out.println("Running New command");
      break;
      case 1:
      System.out.println("Running Open command");
      break;
      case 2:
      System.out.println("Running Save command");
      break;
      case 3:
      System.out.println("Running Close command");
      break;
      case 4:
      System.out.println("Running Exit command");
      break;
    }
  }
}</pre></div><p>This code uses the <code class="literal">idx</code> value to run one of several available options. For simplicity, we simply print messages to the console window to demonstrate that the code is working properly. In your own applications, you would substitute the print messages with actual relevant code.</p><p>In <a class="link" title="Chapter 3. Collision Detection" href="part0024.xhtml">Chapter 3</a>, <span class="emphasis"><em>Collision Detection</em></span>, we used interfaces because we needed to conform to the Greenfoot API. In <a id="id523" class="indexterm"/>this case, we choose to use interfaces because they provided a clean and simple way to provide many different types of menu actions without having to change the <code class="literal">Menu</code> class. We have effectively abstracted the need to know about the contents of the custom menus and made our <code class="literal">Menu</code> class applicable to a wide variety of uses.</p><p>Now, uncomment the <code class="literal">Menu</code> actors in the <code class="literal">testActors()</code> method in <code class="literal">UIMainWorld</code> and test out the menus we created previously.</p><div class="note" title="Note"><h3 class="title"><a id="tip25"/>Tip</h3><p>The <code class="literal">Menu</code> <a id="id524" class="indexterm"/>class is fairly complicated as it involves managing two <code class="literal">TextBox</code> classes and implementing a <code class="literal">MenuCommands</code> interface. To improve your understanding of it, try creating your own menu and adding it to the UI scenario now.</p></div></div><div class="section" title="Heads-up display"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/>Heads-up display</h2></div></div></div><p>Often, you<a id="id525" class="indexterm"/> want to create a completely custom UI that involves various shapes and graphics. In this section, we will learn how to do exactly that. The title of this section is heads-up display (HUD) because games often have custom interfaces (called HUDs) that provide critical information and controls to their players. However, the methodology discussed here applies to any custom UI. For our example, we will create the custom user interface element shown in <span class="emphasis"><em>Figure 5</em></span>. In our HUD, the user will be able to click the home, favorite, print, and cart icons to perform actions of our choosing.</p><div class="mediaobject"><img src="../Images/image00322.jpeg" alt="Heads-up display"/><div class="caption"><p>Figure 5: This shows a custom user interface element</p></div></div><p style="clear:both; height: 1em;"> </p><p>The graphic shown<a id="id526" class="indexterm"/> in <span class="emphasis"><em>Figure 5</em></span> was created in Adobe Illustrator. Use any graphic editor to create something that looks similar. In the UI scenario, create a new <code class="literal">HUD</code> actor and associate the image you created with it. In general, you can create any graphic you want in any editor you want. Our method of creating a custom interface involves us overlaying invisible Greenfoot actors over the custom graphic, and the graphic is not required to be any certain shape or size.</p><p>Here is the code for the <code class="literal">HUD</code> class in our UI scenario:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class HUD extends Actor {
  private TransparentRectangle home;
  private TransparentRectangle favorite;
  private TransparentRectangle print;
  private TransparentRectangle cart;
  private static final int W = 70;
  private static final int H = 70;
  
  protected void addedToWorld(World w) {
    home = new TransparentRectangle(W,H);
    w.addObject(home,
    getX()-getImage().getWidth()/2+W/2,
    getY());
    favorite = new TransparentRectangle(W,H);
    w.addObject(favorite, getX()-W+20, getY());
    print = new TransparentRectangle(W,H);
    w.addObject(print, getX()+W-10, getY());
    cart = new TransparentRectangle(W,H);
    w.addObject(cart,
    getX()+getImage().getWidth()/2-W/2,
    getY());
  }
  
  private class TransparentRectangle extends Actor {
    public TransparentRectangle(int w, int h) {
      GreenfootImage img = new GreenfootImage(w,h);
      setImage(img);
    }
  }
  
  public void act() {
    handleMouseClicks();
  }
  
  private void handleMouseClicks() {
    if( Greenfoot.mouseClicked(home) ) {
      System.out.println("Clicked Home");
    }
    if( Greenfoot.mouseClicked(favorite) ) {
      System.out.println("Clicked Favorite");
    }
    if( Greenfoot.mouseClicked(print) ) {
      System.out.println("Clicked Print");
    }
    if( Greenfoot.mouseClicked(cart) ) {
      System.out.println("Clicked Cart");
    }
  }
}</pre></div><p>As illustrated in<a id="id527" class="indexterm"/> the preceding snippet, there is not a lot of code associated with this class. The code creates four new invisible actors and places them over objects we want the user to be able to click on in our custom UI. In the <code class="literal">addedToWorld()</code> method, we create home, favorite, print, and cart actors to cover the home, favorite, print, and cart icons shown in <span class="emphasis"><em>Figure 5</em></span>. The part of this method that is specific to the graphic shown in <span class="emphasis"><em>Figure 5</em></span> is the placement of the invisible actors. If you created a different graphic than the one I have shown, then you will need to determine the correct locations to place the new actors yourself.</p><p>You have probably <a id="id528" class="indexterm"/>noticed that the invisible actors we created were instances of an inner class named <code class="literal">TransparentRectangle</code>. This is the first time we have used an inner class in this book, and they warrant some discussion. At the simplest level, an inner class is just a class that was defined inside another class and, thus, not generally accessible to other classes in the project. The following information box contains additional information about inner classes.</p><div class="note" title="Note"><h3 class="title"><a id="note24"/>Note</h3><p><span class="strong"><strong>More about inner classes</strong></span></p><p>In object-oriented design, you solve a problem by breaking it up into smaller objects and then carefully constructing how those objects communicate or cooperate. This is an example of top-down design (discussed in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>) where we break a problem up into smaller and smaller subproblems. Sometimes, a class's internal state may be quite complex and using inner classes may help manage that internal complexity. In essence, this is a form of hierarchical object-oriented design.</p><p>Another use of inner classes is encapsulating classes that only have a very specific use for only one class in the project. For example, our <code class="literal">HUD</code> class is the only class in our scenario that uses the <code class="literal">TransparentRectangle</code> class. By hiding <code class="literal">TransparentRectangle</code> within <code class="literal">HUD</code>, no other class is exposed to <code class="literal">TransparentRectangle</code>. You will notice that in Greenfoot, <code class="literal">TransparentRectangle</code> does not appear in the <span class="strong"><strong>Actor classes…</strong></span> section of the main scenario window.</p><p>For more information on inner classes (and nested classes), refer to the article at: <a class="ulink" href="http://www.javaworld.com/article/2077411/core-java/inner-classes.html">http://www.javaworld.com/article/2077411/core-java/inner-classes.html</a></p></div><p>The last two methods, <code class="literal">act()</code> and <code class="literal">handleMouseClicks()</code>, follow a common pattern to handle mouse clicks on actors, which we have seen several times in this book and discuss again here. As with the <code class="literal">Menu</code> actors we created in this scenario, we print a message to the console when the user clicks on one of the icons.</p><p>Let us test the whole scenario now. Remember to uncomment the <code class="literal">HUD</code> actor created and added to the scenario in the <code class="literal">testActors()</code> method in <code class="literal">UIMainWorld</code>. Compile and ensure that messages are being sent to the console when you click on the various icons.</p></div></div></div>
<div class="section" title="Adding a UI to MazeWorld"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Adding a UI to MazeWorld</h1></div></div></div><p>Now that <a id="id529" class="indexterm"/>we have some experience in creating various UI elements, we <a id="id530" class="indexterm"/>are going to enhance the MazeWorld scenario from the previous chapter. This will give us the opportunity to practice what we have learned in a more realistic context.</p><p>Specifically, we will add:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A start screen with a button to start the game and a menu the player can use to indicate the difficulty mode of the game</li><li class="listitem">A game over screen with a button the player can use to restart the game</li><li class="listitem">A HUD the player can use to temporarily stun the enemies, slow them, or make the snake enemies say, "sssssssss"</li></ul></div><p>Start with the code for MazeWorld you ended with in the previous chapter, or download it from <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p></div>
<div class="section" title="Adding menus and buttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Adding menus and buttons</h1></div></div></div><p>In this<a id="id531" class="indexterm"/> section, we will add an introduction screen and game over screen to <code class="literal">MazeWorld</code>. We will add a button, textbox, and menu to the introduction screen (shown in <span class="emphasis"><em>Figure 6</em></span>) and just a<a id="id532" class="indexterm"/> button to the game over screen (shown in <span class="emphasis"><em>Figure 7</em></span>).</p><div class="mediaobject"><img src="../Images/image00323.jpeg" alt="Adding menus and buttons"/><div class="caption"><p>Figure 6: This is the new introduction screen we are adding to MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>This is how the game over screen will look.</p><div class="mediaobject"><img src="../Images/image00324.jpeg" alt="Adding menus and buttons"/><div class="caption"><p>Figure 7: This is the new game over screen we are adding to MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>We created <a id="id533" class="indexterm"/>an introduction screen and game over screen in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span> and augmented the game over screen in <a class="link" title="Chapter 5. Interactive Application Design and Theory" href="part0034.xhtml">Chapter 5</a>, <span class="emphasis"><em>Interactive Application Design and Theory</em></span> for Avoider Game, so the addition of these screens to MazeWorld will only be quickly covered here.</p><p>To start with, we are <a id="id534" class="indexterm"/>going to create a new class that both screens will inherit from. Create a new subclass of the <code class="literal">World</code> class and name it, <code class="literal">MazeWorldScreens</code>; don't associate an image with this class, and add the following code to it:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class MazeWorldScreens extends World
{
  int playMode = 0;
  
  public MazeWorldScreens() {
    super(600, 400, 1);
  }
  
  public void startGame() {
    MazeWorld mw = new MazeWorld(playMode);
    Greenfoot.setWorld(mw);
  }
  
}</pre></div><p>Both the introduction <a id="id535" class="indexterm"/>screen and the game over screen will need to store the difficulty level the user selects (in the <code class="literal">playMode</code> instance variable) and implement a method to start the game, as both have a <span class="strong"><strong>Play MazeWorld</strong></span> button on them. That commonality is captured in the <code class="literal">MazeWorldScreens</code> class. The <code class="literal">startGame()</code> method passes the mode of play to a new instance of MazeWorld and then <a id="id536" class="indexterm"/>switches the scenario to that world.</p><p>Create the <code class="literal">MazeWorldIntro</code> and <code class="literal">MazeWorldGameOver</code> classes as subclasses of <code class="literal">MazeWorldScreens</code>. Make sure to create an image (minus the UI elements) for the introduction screen that looks like <span class="emphasis"><em>Figure 6</em></span> and an image (minus the UI elements) for the game over screen that looks like <span class="emphasis"><em>Figure 7</em></span>, and select them as the images for your new classes. Our images do not need to contain the UI elements as we will be adding them to these screens dynamically.</p><p>Once you have created these <code class="literal">World</code> classes, you should see what is shown in <span class="emphasis"><em>Figure 8</em></span> in the <span class="strong"><strong>World classes</strong></span> area of your main Greenfoot scenario screen.</p><div class="mediaobject"><img src="../Images/image00325.jpeg" alt="Adding menus and buttons"/><div class="caption"><p>Figure 8: This shows the class hierarchy for World classes in MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>Here is the code you need to add to the <code class="literal">MazeWorldIntro</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;

public class MazeWorldIntro extends MazeWorldScreens {
  TextBox mode;
  
  public MazeWorldIntro() {
    super();
    prepare();
  }
  
  public void setMode(String s, int i) {
    mode.setText(s);
    playMode = i;
  }
  
  private void prepare() {
    PlayButton pb = new PlayButton(
    "playButton1.png", "playButton2.png");
    addObject(pb, 200, 250);
    Menu m = new Menu(" Choose game difficulty...",
    "Easy\nMedium\nHard ", 18,
    Color.BLUE, Color.WHITE,
    Color.BLACK, Color.WHITE,
    new GameDifficultyCommands());
    addObject(m, 400, 250);
    mode = new TextBox(" Play the game in Easy Mode ",
    28, true, Color.BLUE, Color.WHITE);
    addObject(mode, 300, 300);
  }
  
}</pre></div><p>The <code class="literal">prepare()</code> method <a id="id537" class="indexterm"/>adds the UI elements to the introduction screen. For clarity, <span class="emphasis"><em>Figure 9</em></span> shows a close-up view of the specific elements added. The<a id="id538" class="indexterm"/> play button uses two images I created (one for the pressed state and the other for the normal state of the button). You will need to create your own images or use two of the default ones provided with Greenfoot. An instance of the <code class="literal">Menu</code> class is placed next to the button. This menu will allow the user to specify whether they want to play in easy, medium, or hard mode (later, we will change the <code class="literal">MazeWorld</code> class to honor these selections). To complete the functionality of the menu, we need to provide a class that implements the <code class="literal">MenuCommands</code> interface. In this case, we pass a <code class="literal">GameDifficultyCommands</code> object. Lastly, we add an instance of <code class="literal">TextBox</code> to display the current difficulty level of the game. The message changes if the user selects a different difficulty level.</p><div class="mediaobject"><img src="../Images/image00326.jpeg" alt="Adding menus and buttons"/><div class="caption"><p>Figure 9: This is a close-up view of the UI elements on the introduction screen in MazeWorld.</p></div></div><p style="clear:both; height: 1em;"> </p><p>As with the <a id="id539" class="indexterm"/>UI example scenario, you will need to add <a id="id540" class="indexterm"/>the <code class="literal">MenuCommands</code> interface to your scenario. For convenience, I have replicated the code for the <code class="literal">MenuCommands</code> interface here:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public interface MenuCommands {
  public void execute(int idx, World w);
}</pre></div><p>The <code class="literal">GameDifficultyCommands</code> class implements the <code class="literal">MenuCommands</code> interface and provides the appropriate commands for the menu choices provided in the popup. Here is the code for <code class="literal">GameDifficultyCommands</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class GameDifficultyCommands implements MenuCommands {
  public void execute(int idx, World w) {
    MazeWorldIntro mwi = (MazeWorldIntro) w;
    switch(idx) {
      case 0:
      mwi.setMode(" Play the game in Easy Mode ", idx);
      break;
      case 1:
      mwi.setMode(" Play the game in Medium Mode ",
      idx);
      break;
      case 2:
      mwi.setMode(" Play the game in Hard Mode ", idx);
      break;
    }
  }
}</pre></div><p>For each menu <a id="id541" class="indexterm"/>choice, the <code class="literal">execute()</code> method in the <code class="literal">GameDifficultyCommands</code> class calls the <code class="literal">setMode()</code> method that we defined in the <code class="literal">MazeWorldIntro</code> class. This method changes the message of <code class="literal">TextBox</code> in the introductory screen, as well as stores the difficulty mode for later use.</p><p>The <code class="literal">MazeWorldGameOver</code> class <a id="id542" class="indexterm"/>is simpler, as it only needs to add a play button. Here is the code for the <code class="literal">MazeWorldGameOver</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
public class MazeWorldGameOver extends MazeWorldScreens {
  
  public MazeWorldGameOver(int pm) {
    super();
    prepare();
    playMode = pm;
  }
  
  private void prepare() {
    PlayButton pb = new PlayButton("playButton1.png",
    "playButton2.png");
    addObject(pb, 420, 330);
  }
}</pre></div><p>The game over screen needs the difficulty level passed to it in its constructor via the <code class="literal">pm</code> parameter variable, so that it can pass it to <code class="literal">MazeWorld</code> when the player hits the <span class="strong"><strong>Play MazeWorld</strong></span> button to play again.</p><p>Of course, this will not work as we have not added the <code class="literal">Menu</code>, <code class="literal">TextBox</code>, and <code class="literal">Button</code> classes we created in <code class="literal">UIWorldScenario</code>. These classes will be identical or very similar to the ones we already discussed earlier in the chapter. We will look at the code here now and only discuss the differences.</p><p>First, to easily group the UI classes together, let's create an empty class, named <code class="literal">UI</code>, they all can inherit from. This is a useful organizational technique in Greenfoot where you may have projects with hundreds of actors in them. As we progress through this section and the next section, we will be creating the class hierarchy shown in <span class="emphasis"><em>Figure 10</em></span>.</p><div class="mediaobject"><img src="../Images/image00327.jpeg" alt="Adding menus and buttons"/><div class="caption"><p>Figure 10: This shows the class structure of the UI elements in MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>Here is the code for <code class="literal">UI</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class UI extends Actor {  
}</pre></div><p>The code for <code class="literal">TextBox</code>, <code class="literal">Button</code>, and <code class="literal">Menu</code> <a id="id543" class="indexterm"/>are exactly the same as they were in the UI example scenario we worked on at the beginning of this chapter. Add them now to the <code class="literal">MazeWorld</code> scenario in exactly the same way you added them to the <a id="id544" class="indexterm"/>UI scenario except for one small change. These classes will subclass <code class="literal">UI</code> instead of <code class="literal">Actor</code>.</p><p>Last, we need to create the <code class="literal">PlayButton</code> class. This class extends the <code class="literal">Button</code> class (as shown in <span class="emphasis"><em>Figure 9</em></span>) and contains the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class PlayButton extends Button {
  
  public PlayButton(String f, String s) {
    super(f,s);
  }
  
  protected void clickedAction() {
    MazeWorldScreens mws = (MazeWorldScreens) getWorld();
    mws.startGame();
  }
}</pre></div><p>This class overrides the empty <code class="literal">clickedAction()</code> method found in the <code class="literal">Button</code> class. When the user clicks on an instance of <code class="literal">PlayButton</code>, the <code class="literal">startGame()</code> method is called. This is the method we implemented in <code class="literal">MazeWorldScreens</code> earlier.</p><p>We just added a <a id="id545" class="indexterm"/>ton of code. We <a id="id546" class="indexterm"/>went through it fairly quickly as most of the code we added was explained in the first part of this chapter and in earlier chapters. We have a few more things to add to complete this new version of MazeWorld. We need to add a heads-up display and then augment the <code class="literal">MazeWorld</code> class to allow the game to be played according to the difficulty mode selected by the user.</p><div class="note" title="Note"><h3 class="title"><a id="tip26"/>Tip</h3><p>You should always test your code as often as you can. Sometimes, you will need to make small, simple/temporary changes to your code to be able to test it. For example, if we change the constructor of the <code class="literal">MazeWorld</code> class to accept an integer parameter, then we can compile and run the code at this point in time.</p></div></div>
<div class="section" title="Adding a HUD"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Adding a HUD</h1></div></div></div><p>We are<a id="id547" class="indexterm"/> going to add a simple set of actions for the main character in the game. <span class="emphasis"><em>Figure 11</em></span> shows the three controls we are adding. If the user clicks on the first icon, then the enemies will be temporarily stunned. If the user clicks on the second icon, then the enemies will move slower for a short period of time. If the user clicks on the last icon, then the snake enemies say, "sssssssss". Having the snakes hiss does not really help the player beat the game. I just thought it was something fun we could add.</p><div class="mediaobject"><img src="../Images/image00328.jpeg" alt="Adding a HUD"/><div class="caption"><p>Figure 11: This shows a set of controls we are adding to MazeWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p><span class="emphasis"><em>Figure 12</em></span> is a close-up view of the controls when placed in the game; we are adding them to the bottom-middle of the screen.</p><div class="mediaobject"><img src="../Images/image00329.jpeg" alt="Adding a HUD"/><div class="caption"><p>Figure 12: This shows the HUD in the game</p></div></div><p style="clear:both; height: 1em;"> </p><p>Using your<a id="id548" class="indexterm"/> favorite graphics editor, create something similar to the picture shown in <span class="emphasis"><em>Figure 12</em></span>. I made my graphic fairly small so that it would be fully contained in the bottom black border of the game.</p><p>Once you have an appropriate graphic, create the <code class="literal">MazeWorldHUD</code> class as a subclass of <code class="literal">UI</code>. Associate the graphic you just made with it and add the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class MazeWorldHUD extends UI {
  private TransparentRectangle stun;
  private TransparentRectangle slow;
  private TransparentRectangle talk;
  private static final int W = 29;
  private static final int H = 22;
  
  protected void addedToWorld(World w) {
    stun = new TransparentRectangle(W,H);
    w.addObject(stun, getX()-W, getY());
    slow = new TransparentRectangle(W,H);
    w.addObject(slow, getX(), getY());
    talk = new TransparentRectangle(W,H);
    w.addObject(talk, getX()+W, getY());
    
  }
  
  private class TransparentRectangle extends Actor {
    public TransparentRectangle(int w, int h) {
      GreenfootImage img = new GreenfootImage(w,h);
      setImage(img);
    }
  }
  
  public void act() {
    handleMouseClicks();
  }
  
  private void handleMouseClicks() {
    MazeWorld mw = (MazeWorld) getWorld();
    if( Greenfoot.mouseClicked(stun) ) {
      mw.stunAllEnemies();
    }
    if( Greenfoot.mouseClicked(slow) ) {
      mw.slowAllEnemies();
    }
    if( Greenfoot.mouseClicked(talk) ) {
      mw.makeSnakesTalk();
    }
  }
}</pre></div><p>The code differs<a id="id549" class="indexterm"/> from the HUD we added in the UI example scenario, in that we now have three controls instead of four and the <code class="literal">handleMouseClicks()</code> method performs the appropriate actions for this scenario. In <code class="literal">addedToWorlds()</code>, we create three <code class="literal">TransparentRectangle</code> objects and place them over the three icons (stun, slow, and talk) in our image. In <code class="literal">handleMouseClicks()</code>, we obtain a reference to the current <code class="literal">World</code> object and call one of the following three methods on it: <code class="literal">stunAllEnemies()</code>, <code class="literal">slowAllEnemies()</code>, and <code class="literal">makeSnakesTalk()</code>.</p><p>This concludes adding a HUD to MazeWorld. Next, we need to modify the <code class="literal">MazeWorld</code> class to change the game, based on the play mode selected by the player and implement the <code class="literal">stunAllEnemies()</code>, <code class="literal">slowAllEnemies()</code>, and <code class="literal">makeSnakesTalk()</code> methods.</p></div>
<div class="section" title="Implementing game difficulty settings and HUD controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Implementing game difficulty settings and HUD controls</h1></div></div></div><p>We have a few things to<a id="id550" class="indexterm"/> take<a id="id551" class="indexterm"/> care of before our new version of MazeWorld is ready. First, we need to incorporate the difficulty level chosen by the player on the introduction screen, and we need to implement the <a id="id552" class="indexterm"/>functionality of the HUD we added to the game. These changes involve <a id="id553" class="indexterm"/>three classes: <code class="literal">MazeWorld</code>, <code class="literal">ScrollingEnemy</code>, and <code class="literal">Snake</code>.</p><p>Here is the code for <code class="literal">MazeWorld</code> where<a id="id554" class="indexterm"/> the changes needed are highlighted:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;
import java.util.ListIterator;
import java.util.Stack;

public class MazeWorld extends World {
  private int xOffset = 0;
  private Hiker hiker;
  private final static int SWIDTH = 600;
  private final static int SHEIGHT = 400;
  private final static int WWIDTH = 1200;
  private final static int TWIDTH = 25;
  private final static int THEIGHT = TWIDTH;
  private final static int TILEOFFSET = TWIDTH/2;
  private final static String validSpaces = "WG";
  <span class="strong"><strong>private int playMode = 0;</strong></span>
  
  private final static String[] WORLD = {
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB",
    "BWWWWWWWWWWWWWUUWWWWWWWWUUUUUUUWWWWWWWWWWWUWWWWB",
    "BWWWWWUUUUUWWWUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB",
    "BWWWWWUUUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWUUUWWWB",
    "BWWWWWWWWWWWWWWWWWUUUUUWWWWWWWWUUUUUUWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWUUUUWWWWWWWWWUUUUUUUUWWWWWWWWB",
    "BWWWWUUUUUUUWWWUWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWB",
    "BWWWWWWWUUUWWWWUWWWWWWWWWWUWWWWUWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWWWUWWB",
    "BWWWWWWWWWWWWWWWWWWWUUUUUUUWWWWWWWWWUUUUWWWWUWWB",
    "BWWWWWWWWWWWWWUUWWWWUWWWWWWWWWWWWWWWUUUUWWWWUWWB",
    "BWWWWWWWUUUUUUUUUWWWWWWWWWWWWWWWWWWWUUUUUUWWUWWB",
    "BWWWWWWWUUUUUUUUUWWWWWWWWWUUWWWWWWWWWWWWWWWWUWWB",
    "BWWWWWWWUWWWWWWWWWWWWWWWWWUUWWWWWWWWWWWWWWWWUWGB",
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
  };
  
  /* constructors */
<span class="strong"><strong>  public MazeWorld() {</strong></span>
<span class="strong"><strong>    this(0);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public MazeWorld(int pm) {</strong></span>
<span class="strong"><strong>    super(SWIDTH, SHEIGHT, 1, false);</strong></span>
<span class="strong"><strong>    playMode = pm;</strong></span>
<span class="strong"><strong>    createWorldFromTiles();</strong></span>
<span class="strong"><strong>    shiftWorld(0);</strong></span>
<span class="strong"><strong>    prepare();</strong></span>
<span class="strong"><strong>  }</strong></span>
  
  /* ability methods */
  public void shiftWorld(int dx) {
    if( (xOffset + dx) &lt;= 0
    &amp;&amp; (xOffset + dx) &gt;= SWIDTH - WWIDTH) {
      xOffset = xOffset+dx;
      shiftWorldActors(dx);
    }
  }
  
  /* accessor methods */
  public int getTileWidth() {
    return TWIDTH;
  }
  
  public int getTileHeight() {
    return THEIGHT;
  }
  
  public int getTileOffset() {
    return TILEOFFSET;
  }
  
  public String[] getStringWorld() {
    return WORLD;
  }
  
  public int getXHiker() {
    return hiker.getX()-xOffset;
  }
  
  public int getYHiker() {
    return hiker.getY();
  }
  
  public String getValidSpaces() {
    return validSpaces;
  }
  
  <span class="strong"><strong>public void stunAllEnemies() {</strong></span>
<span class="strong"><strong>    List&lt;ScrollingEnemy&gt; le =</strong></span>
<span class="strong"><strong>    getObjects(ScrollingEnemy.class);</strong></span>
<span class="strong"><strong>    ListIterator&lt;ScrollingEnemy&gt; listItr = le.listIterator();</strong></span>
<span class="strong"><strong>    while( listItr.hasNext() ) {</strong></span>
<span class="strong"><strong>      ScrollingEnemy se = listItr.next();</strong></span>
<span class="strong"><strong>      se.stun();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public void slowAllEnemies() {</strong></span>
<span class="strong"><strong>    List&lt;ScrollingEnemy&gt; le =</strong></span>
<span class="strong"><strong>    getObjects(ScrollingEnemy.class);</strong></span>
<span class="strong"><strong>    ListIterator&lt;ScrollingEnemy&gt; listItr = le.listIterator();</strong></span>
<span class="strong"><strong>    while( listItr.hasNext() ) {</strong></span>
<span class="strong"><strong>      ScrollingEnemy se = listItr.next();</strong></span>
<span class="strong"><strong>      se.slow();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public void makeSnakesTalk() {</strong></span>
<span class="strong"><strong>    List&lt;Snake&gt; le = getObjects(Snake.class);</strong></span>
<span class="strong"><strong>    ListIterator&lt;Snake&gt; listItr = le.listIterator();</strong></span>
<span class="strong"><strong>    while( listItr.hasNext() ) {</strong></span>
<span class="strong"><strong>      Snake s = listItr.next();</strong></span>
<span class="strong"><strong>      s.talk();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public void gameOver() {</strong></span>
<span class="strong"><strong>    MazeWorldGameOver mwgo = new MazeWorldGameOver(playMode);</strong></span>
<span class="strong"><strong>    Greenfoot.setWorld(mwgo);</strong></span>
<span class="strong"><strong>  }</strong></span>
  
  /* private methods */
  private void shiftWorldActors(int dx) {
    List&lt;ScrollingActor&gt; saList =
    getObjects(ScrollingActor.class);
    for( ScrollingActor a : saList ) {
      a.setAbsoluteLocation(dx);
    }
  }
  
  private void createWorldFromTiles() {
    for( int i=0; i &lt; WORLD.length; i++ ) {
      for( int j=0; j &lt; WORLD[i].length(); j++ ) {
        addActorAtTileLocation(WORLD[i].charAt(j), j, i);
      }
    }
  }
  
  private void addActorAtTileLocation(char c, int x, int y) {
    Actor tile = null;
    switch(c) {
      case 'W':
      tile = new WhiteBlock();
      break;
      case 'B':
      tile = new BlackBlock();
      break;
      case 'U':
      tile = new BlueBlock();
      break;
      case 'G':
      tile = new GoldBlock();
      break;
    }
    if( tile != null) addObject(tile, TILEOFFSET+x*TWIDTH,
    TILEOFFSET+y*THEIGHT);
    
  }
  
  private void prepare()
  {
    hiker = new Hiker();
    addObject(hiker, 80, 200);
    addObject(new MazeWorldHUD(), 300, 387);
    addObject(new Mouse(), 60,40);
    addObject(new Spider(), 1000,40);
    addObject(new Spider(), 120,340);
    addObject(new Spider(), 1050,250);
    addObject(new Snake(), 1050,250);
    addObject(new Mouse(), 1000,200);
    addObject(new Snake(), 400,260);
    <span class="strong"><strong>if( playMode &gt;= 1 ) {</strong></span>
<span class="strong"><strong>      addObject(new Snake(), 80,40);</strong></span>
<span class="strong"><strong>      if( playMode == 2 ) {</strong></span>
<span class="strong"><strong>        addObject(new Mouse(), 50,350);</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    }</strong></span>
  }
}</pre></div><p>We are going to<a id="id555" class="indexterm"/> implement the different difficulty levels by changing the number of enemies you have to avoid in<a id="id556" class="indexterm"/> the maze. First, we create the <code class="literal">playMode</code> instance variable to store the difficulty level. Next, we need to <a id="id557" class="indexterm"/>add another constructor that accepts an integer parameter. To do this, we need to change the old constructor that had no parameters to have one and add one line of code that sets the <code class="literal">playMode</code> instance variable to that parameter—everything<a id="id558" class="indexterm"/> else remains the same. We can then add a new constructor that has no parameters and simply calls the other constructor method passing in a value of <code class="literal">0</code> (which corresponds to the easy mode). Finally, in the <code class="literal">prepare()</code> method, we add code at the end of the method to check whether to add more actors to the game depending on the value of <code class="literal">playMode</code>. If <code class="literal">playMode</code> is <code class="literal">1</code>, then we add an additional snake. If it is <code class="literal">2</code>, then we add an additional snake and mouse to the game.</p><p>Next, we need to add the <code class="literal">stunAllEnemies()</code>, <code class="literal">slowAllEnemies()</code>, and <code class="literal">makeSnakesTalk()</code> methods to <code class="literal">MazeWorld</code>. Each method uses the Greenfoot <code class="literal">World</code> method <code class="literal">getObjects()</code> to get a list of all the objects of the supplied type. When <code class="literal">ScrollingEnemy.class</code> is supplied to <code class="literal">getObjects()</code>, we get a list of all current enemies. When <code class="literal">Snake.class</code> is passed as a parameter to the <code class="literal">getObjects()</code> method, we get a list of all the <code class="literal">Snake</code> objects currently<a id="id559" class="indexterm"/> in the scenario. We then loop through the list of objects and call <code class="literal">stun()</code>, <code class="literal">slow()</code>, and <code class="literal">talk()</code>, respectively, on the objects.</p><p>Because all of the <a id="id560" class="indexterm"/>enemies inherit from <code class="literal">ScrollingEnemy</code>, we can implement both <code class="literal">stun()</code> and <code class="literal">slow()</code> in that class.</p><p>Here is the <a id="id561" class="indexterm"/>code for <code class="literal">ScrollingEnemy</code> with the <a id="id562" class="indexterm"/>required changes highlighted:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

abstract public class ScrollingEnemy extends ScrollingActor {
  protected static final int SPEED = 1;
  private static final int BOUNDARY = 40;
  protected int speedX = SPEED;
  protected int speedY = SPEED;
  <span class="strong"><strong>private int stunTime = 0;</strong></span>
<span class="strong"><strong>  private int slowTime = 0;</strong></span>
<span class="strong"><strong>  private boolean stunned = false;</strong></span>
<span class="strong"><strong>  private boolean slowed = false;</strong></span>
  
  /* initialization */
  protected void addedToWorld(World w) {
    MazeWorld mw = (MazeWorld) w;
    GreenfootImage img = getImage();
    img.scale(mw.getTileWidth(),mw.getTileHeight());
    setImage(img);
  }
  
  <span class="strong"><strong>public void stun() {</strong></span>
<span class="strong"><strong>    if( stunned == false ) {</strong></span>
<span class="strong"><strong>      stunned = true;</strong></span>
<span class="strong"><strong>      stunTime = 100;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  public void slow() {</strong></span>
<span class="strong"><strong>    if( slowed == false ) {</strong></span>
<span class="strong"><strong>      slowed = true;</strong></span>
<span class="strong"><strong>      slowTime = 400;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
  
  /* ability methods */
  public void act() {
    <span class="strong"><strong>if( !stunned ) {</strong></span>
<span class="strong"><strong>      if( slowTime &gt; 0 ) {</strong></span>
<span class="strong"><strong>        slowed = (slowTime-- % 2) == 0;</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>      if( !slowed ) {</strong></span>
        sense();
        reaction();
        boundedMove();
      <span class="strong"><strong>}</strong></span>
<span class="strong"><strong>    } else {</strong></span>
<span class="strong"><strong>      if( stunTime-- &lt; 0 ) {</strong></span>
<span class="strong"><strong>        stunTime = 0;</strong></span>
<span class="strong"><strong>        stunned = false;</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    }</strong></span>
  }
  
  protected void sense() {
    // No smarts
  }
  
  protected void reaction() {
    // No reaction
  }
  
  protected void boundedMove() {
    setLocation(getX()+speedX, getY()+speedY);
    if( isTouching(ScrollingObstacle.class) ) {
      setLocation(getX()-speedX, getY()-speedY);
    }
  }
}</pre></div><p>At the beginning of the <a id="id563" class="indexterm"/><code class="literal">Snake</code> class, we<a id="id564" class="indexterm"/> add four instance variables. Two of <a id="id565" class="indexterm"/>the variables store information about how long the <a id="id566" class="indexterm"/>enemies are stunned (<code class="literal">stunTime</code>) and slowed (<code class="literal">slowTime</code>) and the other two variables track whether or not we are presently in a stunned (<code class="literal">stunned</code>) or slowed (<code class="literal">slowed</code>) state.</p><p>When a <code class="literal">ScrollingEnemy</code> object is stunned by the player, the <code class="literal">stun()</code> method is invoked on that object (as we saw in our discussion on <code class="literal">MazeWorld</code>). The <code class="literal">stun()</code> method will do nothing if the object is presently stunned. If not, the method will set <code class="literal">stunned</code> to <code class="literal">true</code> and set <code class="literal">stunTime</code> to <code class="literal">100</code>. These <a id="id567" class="indexterm"/>values are used in the <code class="literal">act()</code> method to implement stunning the object. The <code class="literal">slow()</code> method is nearly identical to the <code class="literal">stun()</code> method, except that <code class="literal">slowTime</code> is set to <code class="literal">400</code>. This equates to the slowing of an object lasting longer than a stun.</p><p>In <code class="literal">act()</code>, we <a id="id568" class="indexterm"/>check the <a id="id569" class="indexterm"/>values of the <code class="literal">stunned</code> Boolean variable and skip calling the <code class="literal">sense()</code>, <code class="literal">reaction()</code>, and <code class="literal">boundedMove()</code>methods <a id="id570" class="indexterm"/>if <code class="literal">stunned</code> is <code class="literal">true</code>. The <code class="literal">stunTime</code> variable serves as a delay variable (covered in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>). If we are not stunned, then the <code class="literal">act()</code> method proceeds to check the <code class="literal">slowed</code> variable. If not slowed, we proceed as normal. The <code class="literal">slowTime</code> variable serves as a delay variable; however, as it is counting down, it toggles the values of <code class="literal">slowed</code>. This toggling will constrain the <code class="literal">sense()</code>, <code class="literal">reaction()</code>, and <code class="literal">boundedMove()</code> methods to only be invoked on every other call of the <code class="literal">act()</code> method. This makes the enemies move at half speed when slowed.</p><p>Since snakes are the only ones that need to talk, we put the implementation of the <code class="literal">talk()</code> method directly into the <code class="literal">Snake</code> class.</p><p>Here is the code for <code class="literal">Snake</code> with the required changes highlighted:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;
import java.awt.Color;

public class Snake extends ScrollingEnemy {
  private static final int PATHLENGTH = 200;
  private static final int INRANGE = 100;
  private int pathCounter = PATHLENGTH;
  private boolean pathing = false;
  private int rememberSpeedX = 0;
  private List&lt;Hiker&gt; lse;
  <span class="strong"><strong>private boolean talking = false;</strong></span>
<span class="strong"><strong>  private int talkTime = 0;</strong></span>
<span class="strong"><strong>  private TextBox sss;</strong></span>
  
  /* constructors */
  public Snake() {
    speedX = rememberSpeedX = SPEED;
    speedY = 0;
  }
  
  <span class="strong"><strong>public void talk() {</strong></span>
<span class="strong"><strong>    if( talking == false ) {</strong></span>
<span class="strong"><strong>      talking = true;</strong></span>
<span class="strong"><strong>      talkTime = 100;</strong></span>
<span class="strong"><strong>      sss = new TextBox(" sssssss ", 14, true,</strong></span>
<span class="strong"><strong>      Color.BLACK, Color.WHITE);</strong></span>
<span class="strong"><strong>      getWorld().addObject(sss, getX()-20, getY()-20);</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
  
  /* ability methods */
  protected void sense() {
    // If near, move towards enemy
    lse = getObjectsInRange(INRANGE,Hiker.class);
    pathing = lse.isEmpty();
  }
  
  protected void reaction() {
    if( pathing ) {
      speedX = rememberSpeedX;
      speedY = 0;
      if( --pathCounter == 0 ) {
        pathCounter = PATHLENGTH;
        speedX = rememberSpeedX = -speedX;
      }
    } else {
      speedX = lse.get(0).getX() &gt; getX() ? 1 : -1;
      speedY = lse.get(0).getY() &gt; getY() ? 1 : -1;
    }
    
    <span class="strong"><strong>if( talking ) {</strong></span>
<span class="strong"><strong>      sss.setLocation(getX()-20, getY()-20);</strong></span>
<span class="strong"><strong>      if( talkTime-- &lt; 0 ) {</strong></span>
<span class="strong"><strong>        talking = false;</strong></span>
<span class="strong"><strong>        talkTime = 0;</strong></span>
<span class="strong"><strong>        getWorld().removeObject(sss);</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>      }</strong></span>
    }
  }
}</pre></div><p>Like the implementation of <code class="literal">stun()</code> and <code class="literal">slow()</code> in the <code class="literal">ScrollingEnemy</code> class, we need a delay variable (<code class="literal">talkTime</code>) and Boolean (<code class="literal">talking</code>) to implement the <code class="literal">talk()</code> method. In addition, we need a variable to store—<code class="literal">TextBox</code> (<code class="literal">sss</code>)—that will contain the <code class="literal">sssssss</code> text. The <code class="literal">talk()</code> method is structured in the same way as <code class="literal">stun()</code> and <code class="literal">slow()</code>. However, <code class="literal">talk()</code> must also create <code class="literal">TextBox</code> and add it to the world.</p><p>We can see in <code class="literal">reaction()</code> that <a id="id571" class="indexterm"/>if the <code class="literal">Snake</code> object<a id="id572" class="indexterm"/> is in a talking state then the <code class="literal">sss TextBox</code> will be displayed offset from the <a id="id573" class="indexterm"/>location of the object for a time specified by the <code class="literal">talkTime</code> instance variable. Once <code class="literal">talkTime</code> expires, it must also remove the <code class="literal">sss TextBox</code> variable<a id="id574" class="indexterm"/> from the world.</p><p>Congratulations! You have finished our new version of MazeWorld. Compile it and try it out. Click the stun, slow, and talk actions in the game. If you have any issues or errors in your game and are having a tough time solving them, compare your version to the completed version at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p><div class="note" title="Note"><h3 class="title"><a id="tip27"/>Tip</h3><p>The MazeWorld scenario was constructed solely to help demonstrate the concepts covered in <a class="link" title="Chapter 7. Artificial Intelligence" href="part0047.xhtml">Chapter 7</a>, <span class="emphasis"><em>Artificial Intelligence</em></span>, and the current chapter. Therefore, it is not actually great fun to play, but it does have a lot of potential. Using the game design knowledge you acquired in <a class="link" title="Chapter 5. Interactive Application Design and Theory" href="part0034.xhtml">Chapter 5</a>, <span class="emphasis"><em>Interactive Application Design and Theory</em></span>, try making changes to MazeWorld that will enhance its playability.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Summary</h1></div></div></div><p>You are now officially a Greenfoot programming ninja. You know how to create Greenfoot games and simulations that contain lively and intelligent actors with various methods that allow user/player interaction. You can implement keyboard/mouse controls, buttons, menus, and customized interfaces.</p><p>In the next chapter, we are going to add a gamepad controller support to our Greenfoot scenarios. Gamepads are a great way to capture user inputs, especially for games.</p></div></body></html>