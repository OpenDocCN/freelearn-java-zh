<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Integration Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we are going to explain some integration patterns and look at how they work on the integration tier of Java EE. After reading this chapter, you will be able to implement these patterns and use them to solve integration problems between <span class="calibre10">resources or systems. You will also be able to work on the integration tier and become familiar with the concepts associated with integration patterns. The topics in this chapter are as follows: </span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Explaining the concept of the integration tier</span></li>
<li class="calibre16">Explaining the concept of the data-access object pattern</li>
<li class="calibre16">Implementing the <span class="calibre5">data-access object pattern</span></li>
<li class="calibre16">Explaining the concept of the domain-store pattern</li>
<li class="calibre16">Implementing the domain-store pattern</li>
<li class="calibre16">Explaining the concept of the service-activator pattern</li>
<li class="calibre16">Implementing the service-activator pattern</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of the integration tier</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As discussed in previous chapters, Java EE is divided into three well-known tiers—the presentation tier, the business tier, and the <span class="calibre10">integration tier.</span> These tiers work together to promote solutions with a high level of decoupling.</p>
<p class="mce-root">In a business environment, software development is very difficult as we need to think about the whole ecosystem of the enterprise. <span class="calibre10"><span class="calibre10">An </span></span>ecosystem includes its data source, software, data politics, security, and devices. Consequently, the developer needs to think about how to read and write data in these data sources, how the software communicates between with each other, how the data policies are implemented on the systems, how the security works on the business environment, and so on. In this case, it would be beneficial to create a tier to resolve all integration and communication problems, because their <span class="calibre10">solutions</span><span class="calibre10"> </span><span class="calibre10">will be decoupled from business logic. This is the thought process that gave birth to the integration tier.</span></p>
<p class="mce-root"/>
<p class="mce-root">The integration tier is the tier responsible for decoupling the business logic from the integration logic throughout the whole application. This tier has the logic of communication with an external resource or system, and this stays separate from the business logic. This tier will make it possible to read and write data from external sources, making communication between applications and components of the business ecosystem feasible. Furthermore, this tier will hide all communication complexity from the business tier. The business tier will then receive the data without knowing the complexity of the communication between the components and how they are <span class="calibre10">structured</span>.</p>
<p class="mce-root">Nowadays, it is extremely rare to develop an application with integration but without some kind of integration with an external resource. This is because the application always needs to read data from a source, and this source is <span class="calibre10">generally</span><span class="calibre10"> </span><span class="calibre10">outside of the application in databases or filesystems</span><span class="calibre10">. If the application has an external data source as its dependency,</span> then this application needs to be integrated to access the data from the external data source. <span class="calibre10">The simpler application will then have an integration tier.</span></p>
<p class="mce-root">Over time, the complexity of integration between resources or systems grew, because more and more business logic needs to be integrated to promote a good response to businesses. With this, there emerged a necessity to create a common solution to integration problems that occur over and over, and with this, the integration patterns were created.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of the data-access object pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the business world, the application always needs to be integrated with the data source in order to read, write, delete, or update data. This data source could be a relational database, NoSQL database, <strong class="calibre8">LDAP</strong> (<strong class="calibre8">Lightweight Directory Access Protocol</strong>), or filesystem, for example. Each type of data source has its structure and has a complexity to connect to, read, and write data. These complexities shouldn't be exposed to business logic and instead should be decoupled from it.</p>
<p class="mce-root">The <span class="calibre10">data-access object pattern</span> is a pattern used to abstract and hides all access to data sources from the business tier. This pattern encapsulates all data-source access logic and its complexities from the business tier, decoupling all data-source access logic from it. If we then want to substitute the data source with another, we will only need to modify the code of the <span class="calibre10">data-access object pattern</span>, and this modification will not be visible on the business tier. The following diagram displays the <span class="calibre10">data-access object pattern</span> <span class="calibre10">model:</span></p>
<div class="cdpaligncenter"><img src="Images/2ca072fb-cb1b-463e-9c5c-661952bda28a.png" width="619" height="260" class="calibre57"/></div>
<p class="mce-root"/>
<p class="mce-root">In the preceding diagram, we have <strong class="calibre8">BusinessObject</strong>, which has the business logic; DAO, which has the data access logic; <strong class="calibre8">TransferObject</strong>, which is the object used to transfer; and data source, which is the external local where the data resides. When <strong class="calibre8">BusinessObject</strong> needs to access the data, it requests data from DAO. The DAO accesses the data source and reads the data, then returns the data to <strong class="calibre8">BusinessObject</strong> as <strong class="calibre8">TransferObject</strong>. Some developers and professionals think this pattern is only supposed to be used with relational databases and <kbd class="calibre18">NoSql</kbd>, but when our data source is a filesystem or another type of data persistence, we should also use DAO in order to promote the decoupling between business logic and persistence logic as well as to organize our code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the data-access object pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To implement this pattern using the best practices of Java EE 8, we will use a relational database and implement the data read and write using a JPA specification. In this example, we will have one table named <em class="calibre12">employee</em>, which contains the employee data. We will also create a class called <kbd class="calibre18">EmployeeDao</kbd> which will have four methods <span class="calibre10">–</span> <kbd class="calibre18">save(employee)</kbd>, <kbd class="calibre18">findByName(name)</kbd>, <kbd class="calibre18">findAll()</kbd>, and <kbd class="calibre18">delete(employee)</kbd>. The <kbd class="calibre18">save</kbd> <span class="calibre10">method</span><span class="calibre10"> </span><span class="calibre10">will receive one employee and save them on the database,</span> <kbd class="calibre18">findByName</kbd> <span class="calibre10">will receive the name as a parameter and will find the employee by name on the database, and</span> <kbd class="calibre18">delete</kbd> <span class="calibre10">will receive an employee and delete them from the database. Also, we are going to create a transfer object called</span> <kbd class="calibre18">Employee</kbd><span class="calibre10">, a class that is a JPA entity and has the mapping to a database table. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the entity with JPA</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JPA entity is a class that represents some table or view of a database. The entity needs to have an attribute that identifies only one entity, needs to have a constructor with non-arguments and each object of a class that is a JPA entity identify only one row of table or view.</p>
<p class="mce-root">In the following code<span class="calibre10">, </span>we have an interface, called <kbd class="calibre18">Entity</kbd>, that all JPA entities will implement according to the following method:</p>
<pre class="mce-root2"><span class="calibre5">public interface </span>Entity &lt; <span class="calibre5">T </span>&gt; {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span><span class="calibre5">T </span><span class="calibre5">getId</span>()<span class="calibre5">;<br class="calibre2"/></span>}  </pre>
<p class="mce-root"><span class="calibre10">In the following code, we have the transfer object, called </span><kbd class="calibre18">Employee</kbd><span class="calibre10">, which is a JPA entity. This class has the </span>mapping table,<span class="calibre10"> called </span><kbd class="calibre18">Employee</kbd><span class="calibre10">, as well as its column used by applications. The business tier only needs to know the transfer objects, the DAOs, and the parameters to send to the DAOs:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.persistence.*<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.validation.constraints.<span class="calibre5">NotNull</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Objects<span class="calibre5">;<br class="calibre2"/></span><br class="calibre2"/><span class="calibre5">@javax.persistence.Entity</span>(<span class="calibre5">name </span>= <span class="calibre5">"Employee"</span>)<br class="calibre2"/><span class="calibre5">public class </span>Employee <span class="calibre5">implements </span>Entity&lt;Long&gt; {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Id<br class="calibre2"/></span><span class="calibre5">    @GeneratedValue<br class="calibre2"/></span><span class="calibre5">    @Column</span>(<span class="calibre5">name </span>= <span class="calibre5">"id"</span>)<br class="calibre2"/>    <span class="calibre5">private </span>Long <span class="calibre5">id</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@NotNull<br class="calibre2"/></span><span class="calibre5">    @Column</span>(<span class="calibre5">name</span>=<span class="calibre5">"name"</span>)<br class="calibre2"/>    <span class="calibre5">private </span>String <span class="calibre5">name</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@Column</span>(<span class="calibre5">name</span>=<span class="calibre5">"address"</span>)<br class="calibre2"/>    <span class="calibre5">private </span>String <span class="calibre5">address</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@NotNull<br class="calibre2"/></span><span class="calibre5">    @Column</span>(<span class="calibre5">name</span>=<span class="calibre5">"salary"</span>)<br class="calibre2"/>    <span class="calibre5">private </span>Double <span class="calibre5">salary</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span><span class="calibre5">Employee</span>(){}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span><span class="calibre5">Employee</span>( String name<span class="calibre5">, </span>String address<span class="calibre5">, </span>Double salary){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">name </span>= name<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">address </span>= address<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        this</span>.<span class="calibre5">salary </span>= salary<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">setId</span>(Long id) {<br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">id </span>= id<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>String <span class="calibre5">getName</span>() {<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">name</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">setName</span>(String name) {<br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">name </span>= name<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>String <span class="calibre5">getAddress</span>() {<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">address</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">setAddress</span>(String address) {<br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">address </span>= address<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Double <span class="calibre5">getSalary</span>() {<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">salary</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">setSalary</span>(Double salary) {<br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">salary </span>= salary<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public </span>Long <span class="calibre5">getId</span>() {<br class="calibre2"/>        <span class="calibre5">return this</span>.<span class="calibre5">id</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public boolean </span><span class="calibre5">equals</span>(Object o) {<br class="calibre2"/>        <span class="calibre5">if </span>(<span class="calibre5">this </span>== o) <span class="calibre5">return true;<br class="calibre2"/></span><span class="calibre5">        if </span>(o == <span class="calibre5">null </span>|| getClass() != o.getClass()) <span class="calibre5">return false;<br class="calibre2"/></span><span class="calibre5">        </span>Employee employee = (Employee) o<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        return </span>Objects.<span class="calibre5">equals</span>(<span class="calibre5">id</span><span class="calibre5">, </span>employee.<span class="calibre5">id</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Override<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public int </span><span class="calibre5">hashCode</span>() {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span>Objects.<span class="calibre5">hash</span>(<span class="calibre5">id</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}        <br class="calibre2"/>    </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing DAO</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In order to reuse a lot of code and promote best practices to implement DAO, we will create an abstract DAO, called <kbd class="calibre18">AbstractDao</kbd>, which is the superclass of all DAOs, that has methods with the generic logic that can be used by all DAOs:</p>
<pre class="calibre23"><span class="calibre5">import </span>javax.persistence.EntityManager<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.persistence.<span class="calibre5">PersistenceContext</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.persistence.TypedQuery<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.lang.reflect.ParameterizedType<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.List<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Map<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Optional<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public abstract class </span>AbstractDao &lt;<span class="calibre5">T </span><span class="calibre5">extends </span>Entity&gt;{<br class="calibre2"/><br class="calibre2"/>    //EntityManager that provide JPA functionalities<br class="calibre2"/>    <span class="calibre5">@PersistenceContext<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">protected </span>EntityManager <span class="calibre5">em</span><span class="calibre5">;</span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/>    //Get the type of Subclass that implements Entity interface<br class="calibre2"/></span><span class="calibre5">    protected </span>Class&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">getType</span>() {<br class="calibre2"/>        ParameterizedType genericType = (ParameterizedType) <br class="calibre2"/><span class="calibre5">        this</span>.getClass().getGenericSuperclass()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        return </span>(Class&lt;<span class="calibre5">T</span>&gt;) genericType.getActualTypeArguments()[<span class="calibre5">0</span>]<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    //Find entity filtering by id.<br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">findById </span>( <span class="calibre5">T </span>entity ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span>Optional.<span class="calibre5">ofNullable</span>( <span class="calibre5">em</span>.find( (Class&lt;<span class="calibre5">T</span>&gt;) <br class="calibre2"/>        entity.getClass()<span class="calibre5">, </span>entity.getId() ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">persist </span>(<span class="calibre5">T </span>entity ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">em</span>.persist( entity )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        return </span>Optional.<span class="calibre5">of</span>( entity )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">update </span>( <span class="calibre5">T </span>entity ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span>Optional.<span class="calibre5">ofNullable</span>( <span class="calibre5">em</span>.merge( entity ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">delete </span>( <span class="calibre5">T </span>entity ){<br class="calibre2"/>        <span class="calibre5">em</span>.remove( entity )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>   <br class="calibre2"/>    <span class="calibre5">protected </span>List&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">listWithNamedQuery</span>(String namedQuery<span class="calibre5">, </span>Map&lt;String<span class="calibre5">, <br class="calibre2"/></span>    Object&gt; parameters){<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>        TypedQuery&lt;<span class="calibre5">T</span>&gt; query = <span class="calibre5">em</span>.createNamedQuery( namedQuery<span class="calibre5">, <br class="calibre2"/></span>        getType() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>parameters.keySet().stream().forEach( key-&gt; <span class="calibre5">query</span>.setParameter( <br class="calibre2"/>        key<span class="calibre5">, </span><span class="calibre5">parameters</span>.get( key ) ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        return </span>query.getResultList()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">protected </span>Optional&lt;<span class="calibre5">T</span>&gt; <span class="calibre5">findWithNamedQuery</span>(String namedQuery<span class="calibre5">, <br class="calibre2"/></span>    Map&lt;String<span class="calibre5">, </span>Object&gt; parameters){<br class="calibre2"/><br class="calibre2"/>        TypedQuery&lt;<span class="calibre5">T</span>&gt; query = <span class="calibre5">em</span>.createNamedQuery( namedQuery<span class="calibre5">, <br class="calibre2"/></span>        getType() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>parameters.keySet().stream().forEach( key-&gt; <span class="calibre5">query</span>.setParameter( <br class="calibre2"/>        key<span class="calibre5">, </span><span class="calibre5">parameters</span>.get( key ) ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        return </span>Optional.<span class="calibre5">ofNullable</span>(query.getSingleResult())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">To prevent the user from instantiating <kbd class="calibre18">AbstractDao</kbd>, we created the class in the preceding code as an abstract class. Another <kbd class="calibre18">AbstractDao</kbd> characteristic is the return of methods, which <span class="calibre10">only</span><span class="calibre10"> </span><span class="calibre10">return</span> <kbd class="calibre18">Entity</kbd> <span class="calibre10">or a list of</span> <kbd class="calibre18">Entity</kbd><span class="calibre10">. This is a good practice, because we know the object type that is returned by this method and it organizes our code, because we know what type of value our method could return:</span></p>
<pre class="calibre23"><span class="calibre5">import </span>javax.ejb.<span class="calibre5">Stateless</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Collections<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.List<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Stateless<br class="calibre2"/></span><span class="calibre5">public class </span>EmployeeDao <span class="calibre5">extends </span>AbstractDao &lt;Employee&gt; {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>List&lt;Employee&gt; <span class="calibre5">findByName</span>(String name ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return this</span>.listWithNamedQuery(<span class="calibre5">"Employee.findByName"</span><span class="calibre5">,<br class="calibre2"/></span><span class="calibre5">                                       </span>Collections.<span class="calibre5">singletonMap</span>( <br class="calibre2"/><span class="calibre5">                                       "name"</span><span class="calibre5">, </span>name ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>List&lt;Employee&gt; <span class="calibre5">findAll</span>(){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return this</span>.listWithNamedQuery(<span class="calibre5">"Employee.findAll"</span><span class="calibre5">,<br class="calibre2"/></span><span class="calibre5">                                        </span>Collections.<span class="calibre5">emptyMap</span>())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">We can see that we have the <kbd class="calibre18">EmployeeDao</kbd> class, which is the DAO that reads and writes data about <kbd class="calibre18">Employee</kbd>. This class is an EJB, meaning that it can control all transactions with the JTA specification—assuming that transactions are managed by the Java EE container—and make the transaction control transparent to the application. To read employee data, we can call the <kbd class="calibre18">findAll</kbd>, <kbd class="calibre18">findByName</kbd>, and <kbd class="calibre18">findById</kbd> methods; to write employee data, we can call the <kbd class="calibre18">persist</kbd> and <kbd class="calibre18">update</kbd> methods; and to remove (delete) employee data, we can call the <kbd class="calibre18">delete</kbd> method. Note that the business class—<span class="calibre10">a class that acts on the business tier—</span>doesn't know about the process of reading and writing data; it only knows the parameters of the method to call as well as its returns. Therefore, we can substitute the data source without impacting the business logic. We have <kbd class="calibre18">EmployeeBusiness</kbd> using the DAO to read and write data, which we will see here:</p>
<pre class="calibre23"><span class="calibre5">import </span>com.packt.javaee8.dao.EmployeeDao<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>com.packt.javaee8.entity.Employee<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.ejb.<span class="calibre5">Stateless</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.inject.<span class="calibre5">Inject</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.List<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Optional<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Stateless<br class="calibre2"/></span><span class="calibre5">public class </span>EmployeeBusiness{<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">@Inject<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">protected </span>EmployeeDao <span class="calibre5">employeeDao</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span>List&lt;Employee&gt; <span class="calibre5">listByName</span>( String name ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">employeeDao</span>.findByName( name )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public boolean </span><span class="calibre5">save </span>( Employee employee ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">employeeDao</span>.persist( employee ).isPresent()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>List&lt;Employee&gt; <span class="calibre5">listAll</span>(){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">employeeDao</span>.findAll()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;Employee&gt; <span class="calibre5">findById</span>(Employee employee ){<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">employeeDao</span>.findById(employee)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">This is a good pattern; its use is very broad and most applications implement it. When implementing this pattern, be careful <span class="calibre10">not</span><span class="calibre10"> </span><span class="calibre10">to expose data-source characteristics, for example, by sending a SQL query as a parameter to DAO's execution or by sending a path of the file system as a parameter to DAO's execution.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of the domain-store pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We covered the <span class="calibre10">data-access object pattern</span> in the <span class="calibre10"><span class="calibre10">previous section and looked at how this pattern makes an abstraction of the data access logic from the business tier. However, the <span class="calibre10">data-access object pattern</span> is a stateless pattern that does not save states and intelligence inside them. Some problems have a complex relationship between data, and the data persistence needs to be done through an intelligent process. To promote this feature, the <span class="calibre10">data-access object pattern</span> does not attend. This is because DAO shouldn't maintain states, shouldn't contain any intelligent processes, and need only contain a process for saving or updating. To solve this problem, the domain-store pattern </span></span><span class="calibre10">was created—a </span><span class="calibre10">pattern that can add functionalities to DAO.</span></p>
<p class="mce-root"/>
<p class="mce-root">The domain-store pattern is a pattern that makes the object-model persistence transparent, separating the persistence logic from the object model, m<span class="calibre10">aking it possible for the application to select the persistence logic</span> according to the object state. Inside this pattern exists a DAO, designed to communicate and manipulate data with the data source, but this DAO is hidden from the application. This pattern is rarely implemented by developers because JPA already works as a domain-store pattern. This is because the JPA implements some intelligent processes to define when and how to save the data and its intelligent processes are oriented by the mapping made on JPA entities. However, when we decide to implement persistence in another type of data source, we may want to implement this pattern and use it in our application. In the following diagram, we can see the domain-store pattern <span class="calibre10">model:</span></p>
<div class="cdpaligncenter"><img src="Images/4e624879-dbda-4431-a000-abb42017c613.png" class="calibre58"/></div>
<p class="mce-root">Many developers believe that the DAO is dead after JPA. This is because the JPA works with the domain store pattern and already has an internal DAO. However, to us, the DAO is a good pattern to use on Java EE projects. This is because JPA has a stronger relationship with relational databases, and if we substitute the relational database for another type of data source, we will possibly need to remove the JPA and use another mechanism instead. If all JPA calls are inside DAO, the application will only see DAO, and the JPA implementation will be hidden from the application. This makes the business tier more decoupled from the integration tier and the persistence logic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the domain-store pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This is a very long pattern. To implement and facilitate this implementation, we will save all the data on HashMap. This is an important step, because the focus of this subsection is to demonstrate how to implement domain-store patterns. To facilitate our understanding, we will look at the same scenario covered in the <em class="calibre12">Implementing the data-access object pattern</em> subsection. Here, we have the transfer object, called <kbd class="calibre18">Employee</kbd>, and we will also read and write data on the data source. However, persistence will be oriented by object state and will have an intelligence in its logic.. In this implementation, we have the following classes, interfaces, and annotations:</p>
<ul class="calibre15">
<li class="calibre16"><kbd class="calibre18">PersistenceManagerFactory</kbd>: This works as a factory pattern and is responsible for creating instances of the <kbd class="calibre18">PersistenceManager</kbd> class. <kbd class="calibre18">PersistenceManagerFactory</kbd> is a singleton and has only one instance on the entire application.</li>
<li class="calibre16"><kbd class="calibre18">PersistenceManager</kbd>: This manages the persistence and queries the data. This data is an object model that works as a <em class="calibre19">Unit of Work. </em></li>
<li class="calibre16"><kbd class="calibre18">Persistence</kbd>: This is an annotation used as the <em class="calibre19">qualify</em><span class="calibre5"> </span>of CDI. This qualify is used to define a method of <kbd class="calibre18">PersistenceManagerFactory</kbd>, which is responsible for creating a <kbd class="calibre18">PersistenceManager</kbd> instance.</li>
<li class="calibre16"><kbd class="calibre18">EmployeeStoreManager</kbd>: This w<span class="calibre5">orks as a </span><span class="calibre5"><strong class="calibre3">Data-Access Object</strong> (<strong class="calibre3">DAO</strong>)</span><span class="calibre5">, interacting with the data source and encapsulating all the data source complexity. </span>DAO is responsible for reading and writing employee data on the data source.</li>
<li class="calibre16"><kbd class="calibre18">StageManager</kbd>: This is an interface used to create all the <kbd class="calibre18">StageManager</kbd> implementations.</li>
<li class="calibre16"><kbd class="calibre18">EmployeeStageManager</kbd>: This coordinates the read and writes operations of data according to its states and rules.</li>
<li class="calibre16"><kbd class="calibre18">TransactionFactory</kbd><strong class="calibre3">:</strong><span class="calibre5"> This works as a factory pattern and is responsible for creating <kbd class="calibre18">Transaction</kbd></span> <span class="calibre5">instances. <kbd class="calibre18">TransactionFactory</kbd> is a singleton and has only one instance in the entire application.</span></li>
<li class="calibre16"><kbd class="calibre18">Transaction</kbd><strong class="calibre3">:</strong><span class="calibre5"> This is used to create transaction-oriented policies. This class controls the life cycle of transactions and defines the transaction limits.</span></li>
<li class="calibre16"><kbd class="calibre18">Transaction</kbd> (annotation): <span class="calibre5">Annotation used as the <em class="calibre19">q</em></span><em class="calibre19">ualify</em><span class="calibre5"> of CDI. This <em class="calibre19">qualify</em> is used to define a method of <kbd class="calibre18">TransactionFactory</kbd> that is responsible for creating a <kbd class="calibre18">Transaction</kbd> instance.</span></li>
</ul>
<p class="mce-root">To implement this pattern, we will begin with the <kbd class="calibre18">PesistenceManagerFactory</kbd> class, which is a factory of <kbd class="calibre18">PersistenceManager</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the PersistenceManagerFactory class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">In the following code, we have the qualify used to inject the <kbd class="calibre18">PersistenceManager</kbd> class</span><span class="calibre10">:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.inject.<span class="calibre5">Qualifier</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.ElementType.<span class="calibre5">FIELD</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.ElementType.<span class="calibre5">METHOD</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.ElementType.<span class="calibre5">PARAMETER</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.ElementType.<span class="calibre5">TYPE</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.RetentionPolicy.<span class="calibre5">RUNTIME</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>java.lang.annotation.<span class="calibre5">Retention</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.lang.annotation.<span class="calibre5">Target</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Qualifier<br class="calibre2"/></span><span class="calibre5">@Retention</span>(<span class="calibre5">RUNTIME</span>)<br class="calibre2"/><span class="calibre5">@Target</span>({<span class="calibre5">TYPE</span><span class="calibre5">, </span><span class="calibre5">METHOD</span><span class="calibre5">, </span><span class="calibre5">FIELD</span><span class="calibre5">, </span><span class="calibre5">PARAMETER</span>})<br class="calibre2"/><br class="calibre2"/><span class="calibre5">public </span>@<span class="calibre5">interface </span><span class="calibre5">Persistence </span>{<br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">Looking at the following code, we can see that we have the </span><kbd class="calibre18">PersistenceManagerFactory</kbd><span class="calibre10"> class, which is responsible for creating new instances of </span><kbd class="calibre18">PersistenceManager</kbd><span class="calibre10">. This class uses the </span><kbd class="calibre18">@Singleton</kbd><span class="calibre10"> annotation, which is an EJB annotation used to create a singleton pattern with the Java EE mechanism. The </span><kbd class="calibre18">getPersistenceManager</kbd><span class="calibre10"> </span><span class="calibre10">method</span><span class="calibre10"> </span><span class="calibre10">has the</span><span class="calibre10"> </span><kbd class="calibre18">@Produces</kbd><span class="calibre10"> </span><span class="calibre10">annotation, which is used to define a method responsible for creating a new instance. It also has the</span><span class="calibre10"> </span><kbd class="calibre18">@Persistence</kbd><span class="calibre10"> </span><span class="calibre10">annotation, which is used as a <em class="calibre12">qualify</em>:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.ejb.<span class="calibre5">Singleton</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.enterprise.inject.<span class="calibre5">Produces</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.HashSet<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Set<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Singleton<br class="calibre2"/></span><span class="calibre5">public class </span>PersistenceManagerFactory {<br class="calibre2"/><br class="calibre2"/>    Set&lt;StageManager&gt;  <span class="calibre5">stateManagers </span>= <span class="calibre5">new </span>HashSet&lt;StageManager&gt;()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span><span class="calibre5">@Produces @Persistence </span>PersistenceManager <br class="calibre2"/><span class="calibre5">    getPersistenceManager</span>(){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">//Logic to build PersistenceManager<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">return new </span>PersistenceManager()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the PersistenceManager class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need to manage all processes of persistence and query data. For this, we need to create a class. </p>
<p class="mce-root"><span class="calibre10">The </span><kbd class="calibre18">PersistenceManager</kbd><span class="calibre10"> class is responsible for managing all persistence processes and query processes:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.annotation.<span class="calibre5">PostConstruct</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.inject.<span class="calibre5">Inject</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.LinkedHashSet<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Optional<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Set<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.stream.Collectors<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>PersistenceManager {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private </span>Set&lt;StageManager&gt; <span class="calibre5">stateManagers</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@Inject @Transactional </span>Transaction <span class="calibre5">transaction</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@PostConstruct<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public void </span><span class="calibre5">init</span>(){<br class="calibre2"/>        <span class="calibre5">stateManagers </span>= <span class="calibre5">new </span>LinkedHashSet&lt;StageManager&gt;()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;Entity&gt; <span class="calibre5">persist </span>( Entity entity ) {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if </span>( entity <span class="calibre5">instanceof </span>Employee ){<br class="calibre2"/>            <span class="calibre5">stateManagers</span>.add( <span class="calibre5">new </span>EmployeeStageManager(<span class="calibre5"> </span>(Employee) <br class="calibre2"/>            entity ) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span>Optional.<span class="calibre5">ofNullable</span>(entity)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">begin</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( !<span class="calibre5">transaction</span>.isOpened() ){<br class="calibre2"/>            <span class="calibre5">transaction</span>.begin()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>        <span class="calibre5">else</span>{<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Transaction already is opened" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Optional&lt;Entity&gt; <span class="calibre5">load</span>(Object id){<br class="calibre2"/><br class="calibre2"/>        Entity  entity = <span class="calibre5">stateManagers</span>.stream()<br class="calibre2"/>                .filter( e-&gt; e.getEntity().getId().equals( <span class="calibre5">id </span>) )<br class="calibre2"/>                .map( s-&gt;s.getEntity() )<br class="calibre2"/>                .findFirst()<br class="calibre2"/>                .orElseGet( ()-&gt; <span class="calibre5">new </span>EmployeeStoreManager().load( <span class="calibre5">id </span>) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        if</span>( Optional.<span class="calibre5">ofNullable</span>(entity).isPresent()<br class="calibre2"/>                &amp;&amp; <span class="calibre5">stateManagers</span>.stream().map( s-&gt;s.getEntity() <br class="calibre2"/>          ).collect( Collectors.<span class="calibre5">toList</span>() ).contains( entity ) )<br class="calibre2"/>                <span class="calibre5">stateManagers</span>.add( <span class="calibre5">new </span>EmployeeStageManager( (Employee) <br class="calibre2"/>                entity) )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        return </span>Optional.<span class="calibre5">ofNullable</span>(entity)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">commit</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( <span class="calibre5">transaction</span>.isOpened() ){<br class="calibre2"/>            <span class="calibre5">stateManagers</span>.stream().forEach( s-&gt; s.flush() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">transaction</span>.commit()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>        <span class="calibre5">else</span>{<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Transaction is not opened" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">rollback</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( <span class="calibre5">transaction</span>.isOpened() ) {<br class="calibre2"/>            <span class="calibre5">stateManagers </span>= <span class="calibre5">new </span>LinkedHashSet&lt;StageManager&gt;()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span><span class="calibre5">transaction</span>.rollback()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">else </span>{<br class="calibre2"/><br class="calibre2"/>            <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Transaction is not opened" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding code, we have the <kbd class="calibre18">PersistenceManager</kbd> class. This class has the <kbd class="calibre18">stateManagers</kbd> attribute, which is<span class="calibre10"> a set of <kbd class="calibre18">StateManager</kbd> used to control the read and write of each object model. It also has the <kbd class="calibre18">Transaction</kbd> attribute, which is used to control the </span><span class="calibre10">transaction </span>lifecycle<span class="calibre10">. This class also has the</span> <kbd class="calibre18">persist</kbd> <span class="calibre10">method, which is used to write the data represented by the object model; the </span><kbd class="calibre18">begin</kbd> <span class="calibre10">method, used to begin the transaction; the </span><kbd class="calibre18">load</kbd> <span class="calibre10">method, used to read an object model's data; the </span><kbd class="calibre18">commit</kbd> <span class="calibre10">method, used to commit the transaction; and finally, the </span><kbd class="calibre18">rollback</kbd> <span class="calibre10">method, which is used to roll back the transaction.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the EmployeeStoreManager class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">The <kbd class="calibre18">EmployeeStoreManager</kbd></span> <span class="calibre10">class is responsible for connecting with the data source as well as reading and writing employee data:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>com.packt.javaee8.entity.Employee<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>java.util.HashMap<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Map<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>EmployeeStoreManager {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private </span>Map&lt;Object<span class="calibre5">, </span>Employee&gt; <span class="calibre5">dataSource </span>= <span class="calibre5">new </span>HashMap&lt;&gt;()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public void </span><span class="calibre5">storeNew </span>( Employee employee ) <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( <span class="calibre5">dataSource</span>.containsKey( employee.getId() ) ) <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Data already exist" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">dataSource</span>.put( employee.getId()<span class="calibre5">, </span>employee )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">update </span>( Employee employee ) <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( !<span class="calibre5">dataSource</span>.containsKey( employee.getId() ) ) <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Data not exist" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">dataSource</span>.put( employee.getId()<span class="calibre5">, </span>employee )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">delete </span>( Employee employee ) <span class="calibre5">throws </span>Exception {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">if</span>( !<span class="calibre5">dataSource</span>.containsKey( employee.getId() ) ) <span class="calibre5">throw new </span>Exception( <span class="calibre5">"Data not exist" </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">dataSource</span>.remove( employee.getId() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Employee <span class="calibre5">load</span>(Object key){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">dataSource</span>.get( key )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre10">In the preceding code block, we have the </span><kbd class="calibre18">EmployeeStoreManager</kbd> class, which is responsible for connecting with the data source and reading and writing employee data. This class works as a DAO and encapsulates all the data source complexity. It also has the <kbd class="calibre18">dataSource</kbd> attribute, which is a map that represents a data source. Furthermore, this class has the <kbd class="calibre18">storeNew</kbd> method, which is used to write new employee data represented by the object model. It also has the <kbd class="calibre18">update</kbd> method, used to write existing employee data represented by an object model. This method is used to update stored data. The <kbd class="calibre18">delete</kbd> method is also used to delete existing employee data, and the load method is used to read employee data in an object model.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the StageManager interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><kbd class="calibre18">StageManager</kbd> is an interface that is implemented by <kbd class="calibre18">EmployeeStageManager</kbd></span>:</p>
<pre class="mce-root2"><span class="calibre5">public interface </span>StageManager {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">flush</span>()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public void </span><span class="calibre5">load</span>()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span>Entity <span class="calibre5">getEntity</span>()<span class="calibre5">;<br class="calibre2"/></span>}</pre>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">StageManager</kbd> interface. This interface is implemented by <kbd class="calibre18">EmployeeStageManager</kbd>:</p>
<pre class="mce-root2"><span class="calibre5">public class </span>EmployeeStageManager <span class="calibre5">implements </span>StageManager {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private boolean </span><span class="calibre5">isNew</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    private </span>Employee <span class="calibre5">employee</span><span class="calibre5">;</span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    public </span><span class="calibre5">EmployeeStageManager </span>( Employee employee ){<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">employee </span>= employee;<span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">flush</span>(){<br class="calibre2"/><br class="calibre2"/>        EmployeeStoreManager employeeStoreManager = <span class="calibre5">new </span>EmployeeStoreManager()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        if</span>( <span class="calibre5">isNew </span>){<br class="calibre2"/>            <span class="calibre5">try </span>{<br class="calibre2"/>                employeeStoreManager.storeNew( <span class="calibre5">employee </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>} <span class="calibre5">catch </span>( Exception e ) {<br class="calibre2"/>                e.printStackTrace()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>}<br class="calibre2"/>            <span class="calibre5">isNew </span>= <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5">        </span>}<br class="calibre2"/>        <span class="calibre5">else </span>{<br class="calibre2"/>            <span class="calibre5">try </span>{<br class="calibre2"/>                employeeStoreManager.update( <span class="calibre5">employee </span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>} <span class="calibre5">catch </span>( Exception e ) {<br class="calibre2"/>                e.printStackTrace()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">            </span>}<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">load</span>() {<br class="calibre2"/>        EmployeeStoreManager storeManager =<br class="calibre2"/>                <span class="calibre5">new </span>EmployeeStoreManager()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>Employee empl = storeManager.load( <span class="calibre5">employee</span>.getId() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span>updateEmployee( empl )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private void </span><span class="calibre5">updateEmployee</span>( Employee empl ) {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">employee</span>.setId( empl.getId() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">employee</span>.setAddress( empl.getAddress() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">employee</span>.setName( empl.getName() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">employee</span>.setSalary( empl.getSalary() )<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">isNew </span>= <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span>Entity <span class="calibre5">getEntity</span>() {<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">employee</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">isNew</kbd> attribute, which is<span class="calibre10"> used to define whether or not the object model is a new write (new data will be created on data source). The code also contains the <kbd class="calibre18">employee</kbd> attribute, which is the object model used to represent employee data. We can also see the <kbd class="calibre18">flush</kbd> method, used to execute the process for writing data on the data source; the <kbd class="calibre18">load</kbd> method, used to read data from the data source; the <kbd class="calibre18">updateEmployee</kbd> method, which is the private method used to update the <kbd class="calibre18">employee</kbd> attribute; and the <kbd class="calibre18">getEntity</kbd> method, which is used to return the <kbd class="calibre18">employee</kbd> attribute. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the TransactionFactory class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the following code, we have the <kbd class="calibre18">Transactional</kbd> annotation, which is a <kbd class="calibre18">Qualifier</kbd> used to inject the <kbd class="calibre18">Transaction</kbd> class:</p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.inject.<span class="calibre5">Qualifier</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.lang.annotation.<span class="calibre5">Retention</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.lang.annotation.<span class="calibre5">Target</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.ElementType.*<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import static </span>java.lang.annotation.RetentionPolicy.<span class="calibre5">RUNTIME</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Qualifier<br class="calibre2"/></span><span class="calibre5">@Retention</span>(<span class="calibre5">RUNTIME</span>)<br class="calibre2"/><span class="calibre5">@Target</span>({<span class="calibre5">TYPE</span><span class="calibre5">, </span><span class="calibre5">METHOD</span><span class="calibre5">, </span><span class="calibre5">FIELD</span><span class="calibre5">, </span><span class="calibre5">PARAMETER</span>})<br class="calibre2"/><span class="calibre5">public </span>@<span class="calibre5">interface </span><span class="calibre5">Transactional </span>{<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre10">In the preceding code block, we have the </span><kbd class="calibre18">TransactionFactory</kbd><span class="calibre10"> class, which is responsible for creating new instances of the </span><kbd class="calibre18">Transaction</kbd><span class="calibre10"> class. This class uses the</span><span class="calibre10"> </span><kbd class="calibre18">@Singleton</kbd><span class="calibre10"> </span><span class="calibre10">annotation, which is an EJB annotation used to create a singleton pattern with the Java EE mechanism. The </span><kbd class="calibre18">getTransaction</kbd><span class="calibre10"> method has the</span><span class="calibre10"> </span><kbd class="calibre18">@Produces</kbd><span class="calibre10"> </span><span class="calibre10">annotation, used to define a method responsible for creating a new instance, and the </span><kbd class="calibre18">@Transactional</kbd><span class="calibre10"> annotation, used as a </span>qualify:</p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.ejb.<span class="calibre5">Singleton</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.enterprise.inject.<span class="calibre5">Produces</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Singleton<br class="calibre2"/></span><span class="calibre5">public class </span>TransactionFactory {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public </span><span class="calibre5">@Produces @Transactional </span>Transaction <span class="calibre5">getTransaction</span>(){<br class="calibre2"/>        <span class="calibre5">//Logic to create Transations.<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">return new </span>Transaction()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Transaction class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">The </span><kbd class="calibre18">Transaction</kbd><span class="calibre10"> class is responsible for controlling the transaction lifecycle and defining the transaction delimit:</span></p>
<pre class="mce-root2"><span class="calibre5">package </span>com.packt.javaee8.domainstore<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">import </span>javax.annotation.<span class="calibre5">PostConstruct</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">public class </span>Transaction {<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">private boolean </span><span class="calibre5">opened</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">@PostConstruct<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">public void </span><span class="calibre5">init</span>(){<br class="calibre2"/>        <span class="calibre5">this</span>.<span class="calibre5">opened </span>= <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">commit</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/>        <span class="calibre5">if</span>( !<span class="calibre5">opened </span>) <span class="calibre5">throw new </span>Exception(<span class="calibre5">"Transaction is not opened"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">opened </span>= <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">rollback</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/>        <span class="calibre5">if</span>( !<span class="calibre5">opened </span>) <span class="calibre5">throw new </span>Exception(<span class="calibre5">"Transaction is not opened"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">opened </span>= <span class="calibre5">false;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public void </span><span class="calibre5">begin</span>() <span class="calibre5">throws </span>Exception {<br class="calibre2"/>        <span class="calibre5">if</span>( <span class="calibre5">opened </span>) <span class="calibre5">throw new </span>Exception(<span class="calibre5">"Transaction already is opened"</span>)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">opened </span>= <span class="calibre5">true;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">public boolean </span><span class="calibre5">isOpened</span>(){<br class="calibre2"/>        <span class="calibre5">return </span><span class="calibre5">opened</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/>}</pre>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">Transaction</kbd> class, which is responsible for controlling the transaction lifecycle and defining the transaction delimit. This class has the <kbd class="calibre18">init()</kbd> <span class="calibre10">method</span><span class="calibre10">, annotated with</span> <kbd class="calibre18">@PostConstruct</kbd><span class="calibre10">, which configures this method to be called after the constructor is executed. Furthermore, this class has the</span> <kbd class="calibre18">commit</kbd> <span class="calibre10">method, which is</span><span class="calibre10"> used when the user needs to confirm the transaction; the</span> <kbd class="calibre18">rollback</kbd> <span class="calibre10">method, </span><span class="calibre10">used to undo all transactions; the</span> <kbd class="calibre18">begin</kbd><span class="calibre10"> </span><span class="calibre10">method, </span><span class="calibre10">used to open a transaction; and the</span> <kbd class="calibre18">isOpened</kbd><span class="calibre10"> </span><span class="calibre10">method, which is </span><span class="calibre10">used to verify whether a transaction is open or not.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">The transaction is closed if the</span> <kbd class="calibre18">begin</kbd> <span class="calibre10">method was not called or if the</span> <kbd class="calibre18">commit</kbd> <span class="calibre10">or</span> <kbd class="calibre18">rollback</kbd> <span class="calibre10">methods were called and a new call to the</span> <kbd class="calibre18">begin</kbd> <span class="calibre10">method was not made. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the EmployeeBusiness class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">The </span><kbd class="calibre18">EmployeeBusiness</kbd><span class="calibre10"> class has the employee business logic:</span></p>
<pre class="mce-root2"><span class="calibre5">import </span>javax.ejb.<span class="calibre5">Stateless</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>javax.inject.<span class="calibre5">Inject</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">import </span>java.util.Optional<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">@Stateless<br class="calibre2"/></span><span class="calibre5">public class </span>EmployeeBusiness{<br class="calibre2"/><br class="calibre2"/>   <span class="calibre5">@Inject @Persistence<br class="calibre2"/></span><span class="calibre5">   </span><span class="calibre5">protected </span>PersistenceManager <span class="calibre5">persistenceManager</span><span class="calibre5">;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">   public boolean </span><span class="calibre5">save </span>( Employee employee ) <span class="calibre5">throws </span>Exception {<br class="calibre2"/>        <br class="calibre2"/>       //Begin Transaction <br class="calibre2"/>       <span class="calibre5">persistenceManager</span>.begin()<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">       </span><span class="calibre5">persistenceManager</span>.persist(employee)<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">       //End Transaction<br class="calibre2"/>       </span><span class="calibre5">persistenceManager</span>.commit()<span class="calibre5">;       <br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">       return true;<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5">   </span>}<br class="calibre2"/><br class="calibre2"/>   <span class="calibre5">public </span>Optional&lt;Employee&gt; <span class="calibre5">findById</span>(Employee employee ){<br class="calibre2"/>        <span class="calibre5">return </span>Optional.<span class="calibre5">ofNullable</span>( (Employee) <span class="calibre5">persistenceManager</span>.load(employee.getId()).get())<span class="calibre5">;<br class="calibre2"/></span><span class="calibre5">    </span>}<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In the preceding code block, we have the <kbd class="calibre18">EmployeeBusiness</kbd> class, which has the employee business logic. This class has the <kbd class="calibre18">save(Employee)</kbd> <span class="calibre10">method, which is</span><span class="calibre10"> used to save employee data, and</span> <kbd class="calibre18">findById(Employee )</kbd><span class="calibre10">, which is used to find an employee according to their ID. Note that, on the </span><kbd class="calibre18"><span class="calibre5">save</span></kbd><span class="calibre10"> </span><span class="calibre10">method, we call the</span> <kbd class="calibre18">begin()</kbd><span class="calibre10"> method</span><span class="calibre10"> as well as </span><kbd class="calibre18">commit()</kbd><span class="calibre10"> from the </span><kbd class="calibre18">PersistenceManager</kbd> <span class="calibre10">class. These calls define the delimiting of a transaction and </span><span class="calibre10">only</span><span class="calibre10"> </span><span class="calibre10">the data is saved at the data source when the</span> <kbd class="calibre18">commit()</kbd> <span class="calibre10">method is called.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of the service-activator pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Suppose a client needs to request a business service, which is a process that takes a long time. In this case, the client should not wait in a synchronous way <span class="calibre10">until the end of the process</span>. Instead, there must be a way to make an asynchronous service call that does not block the client or user. This service can then be activated at some point in the future. There may be several reasons for the delay of a process. For example, there may be a database query that consumes a lot of time, or an access to a legacy system that is beyond the control of the current application. <span class="calibre10">The pattern of </span>asynchronously performing <span class="calibre10">the required task is known as the service activator.</span></p>
<p class="mce-root">So, the service activator pattern is always used when the client needs to call a service asynchronously. This means that the client makes the request and does not wait for the response.</p>
<p class="mce-root">We can imagine some alternative solutions to this problem. One method would be to send the request to a queue, while another service would read the request from this queue and execute the task within it. Alternatively, when the client requests a service, this service could be placed in a database, and there could be a listener or a job that would check the tasks that had not <span class="calibre10">yet </span><span class="calibre10">been performed. If a task had not yet been performed, it would be executed. </span></p>
<p class="mce-root">In fact, the JEE specification gives us very good solutions that are used to implement the <span class="calibre10">service-activator pattern</span>. These solutions are described as follows:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5"><strong class="calibre3">Java Message Service</strong> (<strong class="calibre3">JMS</strong>)</span></li>
<li class="calibre16"><span class="calibre5">EJB asynchronous methods</span></li>
<li class="calibre16"><span class="calibre5">Asynchronous events: producers and observers</span></li>
</ul>
<p class="mce-root">These three solutions were offered in the given order within the evolution of the JEE specification. We'll look at each of these solutions in more detail in the following sections. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java Message Service (JMS)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A <strong class="calibre8">message-driven middleware</strong> (<strong class="calibre8">MOM</strong>) is an architecture <span class="calibre10">that uses message exchanges, which refers to sending and receiving messages, between the modules of an application or between distributed systems. The MOM provides some good services, such as message persistence or message-delivery guarantees. A message broker is based on a MOM, for instance.</span></p>
<p class="mce-root">Java Message Service (JMS) is an application programming interface (API) that <span class="calibre10">provides a MOM interface for clients who want an asynchronous process</span>. JMS became part of the EJB technology in the EJB 2.0 specification and a new session bean was then introduced: the message-driven bean (MDB).</p>
<p class="mce-root">An MDB bean is a stateless session bean that is used to listen to requests or objects arriving in a JMS queue. It is important to note that an MDB can implement any type of message, but it is more commonly used to handle JMS messages. </p>
<p class="mce-root">A message-driven bean listens to messages that have been sent to a queue or to a topic. However, we will only see the example of messages sent to a queue. Messages can be sent by any JEE component or by another application outside the JEE context.</p>
<p class="mce-root">The following diagram shows the trajectory of a message, from being sent to being received by an MDB:</p>
<div class="cdpaligncenter"><img src="Images/9efb5305-626c-4b53-bc16-2c914ac468b4.png" class="calibre59"/></div>
<p class="mce-root">Later in this chapter, we'll see an example of the implementation of message producers and a message receiver. The receiver of the message will be implemented with an MDB. For now, we will quote some important items about the MDB. The MDB implementation has the following structure:</p>
<pre class="mce-root2">@MessageDriven (mappedName = "myQueue")<br class="calibre2"/>public class BeanMessage implements MessageListener {<br class="calibre2"/>   @Override<br class="calibre2"/>   public void onMessage (Message message) {<br class="calibre2"/>      try {<br class="calibre2"/>         // message process<br class="calibre2"/>      }catch (JMSException ex) {<br class="calibre2"/>         // handle exception<br class="calibre2"/>      }<br class="calibre2"/>   }<br class="calibre2"/>}</pre>
<p class="mce-root">The <kbd class="calibre18">@MessageDriven</kbd> <span class="calibre10">annotation</span><span class="calibre10"> sets the bean to be message-driven. In addition, the bean class must be public but cannot be abstract or final, and the class must contain a public constructor with no arguments.</span></p>
<p class="mce-root">The <kbd class="calibre18">mappedName</kbd> attribute specifies the JNDI name of the JMS that will receive the message to be consumed. There are other attributes in the <kbd class="calibre18">@MessageDriven</kbd> annotation that are used to configure the bean. For example, the <kbd class="calibre18">activationConfig</kbd> attribute may contain an <kbd class="calibre18">@ActivationConfigProperty</kbd> annotation array that contains a key/value pair used to improve the bean's configuration. </p>
<p class="mce-root"><span class="calibre10">The bean must implement the <kbd class="calibre18">MessageListener</kbd> interface, which has only one method, known as <kbd class="calibre18">onMessage</kbd></span>. <span class="calibre10">This method is called by the container whenever the message is consumed by the MDB.</span></p>
<p class="mce-root">We can identify the following characteristics of an MDB:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">It is not in the same transaction context as the message sender</span></li>
<li class="calibre16"><span class="calibre5">It is not called directly by another session bean</span></li>
<li class="calibre16">It <span class="calibre5">can invoke other session beans</span></li>
<li class="calibre16">It <span class="calibre5">can send JMS messages</span></li>
<li class="calibre16"><span class="calibre5">It does not have remote or local interfaces related to client access</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">EJB asynchronous methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The EJB 3.1 specification incorporated asynchronous methods to session beans with the use of an <kbd class="calibre18">@<span class="calibre5">javax.ejb.</span>Asynchronous</kbd> annotation. Consequently, we can have asynchronous processing from a simple call to an EJB method.</p>
<p class="mce-root">The <kbd class="calibre18">@javax.ejb.Asynchronous</kbd> annotation can be applied to a class of a session bean or applied to individual methods of this class. If applied to the entire class, all business methods of this bean are called asynchronously. Otherwise, only the methods with the annotation will be called asynchronously:</p>
<pre class="calibre23">@Stateless <br class="calibre2"/>public class MyBean<br class="calibre2"/>    @Asynchronous<br class="calibre2"/>    public void veryTimeConsumingProcess1 (SomeFilterBean filter) {<br class="calibre2"/>        //código para cadastrar um pedido<br class="calibre2"/>    }<br class="calibre2"/>    @Asynchronous<br class="calibre2"/>    public Future veryTimeConsumingProcess2 (SomeFilterBean filter) {<br class="calibre2"/>        //autoriza demora .....<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">The second method returns an instance of <kbd class="calibre18">java.util.concurrent.Future</kbd>. With this object, the client can check whether the result has already arrived, or can even abort the task. However, the method returns immediately to the client thread and does not block the process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Asynchronous events – producers and observers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Another alternative that appeared on the evolutionary scale of the JEE platform was the event mechanism that is a part of the CDI specification. The mechanism is composed of producers and consumers of events, meaning that one component fires an event and another component of the application receives the event, acting as a listener or observer.</p>
<p class="mce-root">Up to the JEE8 specification, this event mechanism was done synchronously. With the introduction of CDI 2.0 in the JEE8 specification, the events API included improvements such as asynchronous use.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The following diagram shows the asynchronous mechanism for sending and receiving events:</p>
<div class="cdpaligncenter"><img src="Images/d21d7a33-a943-4dbe-8ff5-11dd5852efde.png" class="calibre60"/></div>
<p class="mce-root">Now, we will see the <span class="calibre10">basics of </span>how to implement the codes of a <em class="calibre12">producer</em> and an <em class="calibre12">observer</em> of an asynchronous event:</p>
<pre class="mce-root2">public class SomeProducer {<br class="calibre2"/> <br class="calibre2"/> @Inject private Event&lt;BeanTO&gt; someEvent;<br class="calibre2"/> <br class="calibre2"/> public void finalizaCompra() {<br class="calibre2"/> BeanTO bean = new BeanTO(...);<br class="calibre2"/> someEvent.fireAsync(bean);<br class="calibre2"/> }<br class="calibre2"/>}</pre>
<pre class="mce-root2">public class SomeObserver {<br class="calibre2"/> <br class="calibre2"/> public void doSomething (@ObservesAsync BeanTO bean) {<br class="calibre2"/> // do some task with bean (like send email, calling another business process, etc.<br class="calibre2"/> }<br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The <kbd class="calibre18">someEvent</kbd> event is injected into the <kbd class="calibre18">SomeProducer</kbd> class, and the <kbd class="calibre18">Event.fireAsync()</kbd> method is responsible for the asynchronous event-firing. After some time, observers <span class="calibre10">also</span><span class="calibre10"> </span><span class="calibre10">receive the event asynchronously. The observer methods have parameters annotated with <kbd class="calibre18">@ObservesAsync</kbd>.</span></p>
<p class="mce-root">Asynchronous observers are called in a new transaction context. However, they belong to the same security context as the invocation of <kbd class="calibre18">Event.fireAsync</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the service-activator pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We are now going to show code examples of the three solutions offered by the Java EE platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing sending and receiving messages with JMS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The following is an example of a <span class="calibre10">JMS message </span>sender. This is a CDI bean that is responsible for sending messages:</p>
<pre class="mce-root2">public class MessageSender {<br class="calibre2"/>   @Inject<br class="calibre2"/>   @JMSConnectionFactory("jms/connectionFactory")<br class="calibre2"/>   JMSContext context;<br class="calibre2"/> <br class="calibre2"/>   @Resource(mappedName = "jms/myQueue")<br class="calibre2"/>   Destination queue;<br class="calibre2"/> <br class="calibre2"/>   public void sendSomeMessage (String message) {<br class="calibre2"/>      context.createProducer().send(queue, message);<br class="calibre2"/>   }<br class="calibre2"/>}</pre>
<p class="mce-root">The <kbd class="calibre18">@JMSConnectionFactory</kbd> annotation indicates which <kbd class="calibre18">ConnectionFactory</kbd> should be used to create the <kbd class="calibre18">JMSContext</kbd>. The following code block shows an MDB that receives the message generated by the producer described earlier:</p>
<pre class="mce-root2">@MessageDriven(<br class="calibre2"/> activationConfig = { @ActivationConfigProperty(<br class="calibre2"/> propertyName = "destinationType", propertyValue = "javax.jms.Queue")<br class="calibre2"/> })<br class="calibre2"/>public class EmailService implements MessageListener {<br class="calibre2"/>    @Resource<br class="calibre2"/>    private MessageDrivenContext mdc;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">    public void onMessage (Message message) {</span><br class="calibre2"/><span class="calibre5">    try {</span><br class="calibre2"/><span class="calibre5">        String str = message.getBody (String.class);</span><br class="calibre2"/><span class="calibre5">    }</span> <br class="calibre2"/><span class="calibre5">    catch (JMSException ex){</span><br class="calibre2"/><span class="calibre5">        // handling exception ...<br class="calibre2"/>        mdc.setRollbackOnly();<br class="calibre2"/></span><span class="calibre5">    }</span>   <br class="calibre2"/>}</pre>
<p class="mce-root">As previously mentioned, the <kbd class="calibre18">@MessageDriven</kbd> annotation converts a simple bean into an MDB. This annotation has many activation configuration properties, defined by the JMS specification. The two important properties shown in the example are as follows:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5"><kbd class="calibre18">destinationLookup</kbd>: The JNDI lookup name of the queue or topic</span></li>
<li class="calibre16"><kbd class="calibre18">destinationType</kbd>: The queue type, <kbd class="calibre18">javax.jms.Queue</kbd> or <kbd class="calibre18">javax.jms.Topic</kbd></li>
</ul>
<p class="mce-root">Similar to a stateless session bean, the container can make an instance pool to handle multiple messages. The <kbd class="calibre18">onMessage</kbd> method belongs to a single transaction context, and this context is propagated to the other methods invoked within <kbd class="calibre18">onMessage</kbd>.</p>
<p class="mce-root">A <kbd class="calibre18">MessageDrivenContext</kbd> object can be injected into an MDB. This object provides access to the MDB context at runtime. We can, for example, roll back a transaction using the <kbd class="calibre18">setRollbackOnly()</kbd> method shown in the earlier mentioned example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the EJB asynchronous methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The following code shows an example of a stateless EJB asynchronous method. Suppose there is a method responsible for approving and scheduling student test reviews and we want to call this method in an asynchronous way:</p>
<pre class="mce-root2">@javax.ejb.Stateless<br class="calibre2"/>public AcademicServiceBean {<br class="calibre2"/> @javax.ejb.Asynchronous <br class="calibre2"/> public Future requestTestReview( Test test) { <br class="calibre2"/> // ...<br class="calibre2"/> } <br class="calibre2"/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"> We will look at a bean client that requests a test review service, as follows:</p>
<pre class="mce-root2">@Named <br class="calibre2"/>@SessionScope<br class="calibre2"/>public TestController { <br class="calibre2"/>    @Inject<br class="calibre2"/>    private AcademicServiceBean academicBean; <br class="calibre2"/>    private Future statusTestReview;<br class="calibre2"/>    <br class="calibre2"/>    public void requestTestReview(){ <br class="calibre2"/>/* get Test object which has the test data,    like: test date; student who made the test; discipline, etc.*/<br class="calibre2"/>        Test testToBeReviewed = ...;<br class="calibre2"/>        this.statusTestReview = academicBean.requestTestReview (testToBeReviewed); <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public Future&lt;TestReview&gt; checkTestReviewStatus()<br class="calibre2"/>     { <br class="calibre2"/>         // ...<br class="calibre2"/>     }<br class="calibre2"/>}</pre>
<p class="mce-root">Asynchronous methods can return <kbd class="calibre18">void</kbd>, or as an instance of <kbd class="calibre18">java.util.concurrent.Future &lt;T&gt;</kbd>. In the preceding example, the return is an instance of <kbd class="calibre18">Future &lt;TestReview&gt;</kbd>. The result of invoking the asynchronous method is returned immediately and there is no lock on the client thread. However, the client can consult this instance of <kbd class="calibre18">Future</kbd> at any time in order to check the result. The <kbd class="calibre18">TestReview</kbd> object contains information such as the Boolean type, whether or not the test review was approved, and the test review schedule date.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing asynchronous events – producers and observers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Suppose a client wants to send emails to college students, inviting them to a science and technology seminar. And suppose that the emails that were sent generate statistical information for later analysis. In this case, the client does not need to wait for the answer <span class="calibre10">immediately</span><span class="calibre10">. We can make an event producer and two event observers: an observer responsible for sending the email itself and an observer responsible for statistical control. The two processes are independent of each other. The following code shows the producer and the two observers.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">This is the <kbd class="calibre18">SeminarProducer</kbd> class:</p>
<pre class="mce-root2">public class SeminarProducer {<br class="calibre2"/>    @Inject private Event&lt;Seminar&gt; seminarEvent;<br class="calibre2"/>    public void sendEmailProcess(Date date, String title, String description) {<br class="calibre2"/>        Seminar seminar = new Seminar(date, title, description);<br class="calibre2"/>        seminarEvent.fireAsync(seminar);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">These are the two observers:</p>
<pre class="mce-root2">public class SeminarServiceBean {<br class="calibre2"/> <br class="calibre2"/> public void inviteToSeminar (@ObservesAsync Seminar seminar) {<br class="calibre2"/> // sen email for the college students inviting for the seminar<br class="calibre2"/> }<br class="calibre2"/>}</pre>
<pre class="mce-root2">public class StatisticControlingBean {<br class="calibre2"/> <br class="calibre2"/> public void generateStatistic (@ObservesAsync Seminar seminar) {<br class="calibre2"/> // create some statistic data<br class="calibre2"/> }<br class="calibre2"/>} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, you learned about the integration tier, as well as integration patterns and how they are implemented. The integration patterns that we learned about included the <span class="calibre10">data-access object pattern</span>, the domain-store pattern, and the service-activator pattern. We also learned about the implementations of these patterns. Furthermore, we learned about the concept of the <span class="calibre10">data-access object pattern</span>, as well as when and how to implement it using the best practices of Java EE 8. We also learned about domain-store pattern concepts, the differences between the domain-store pattern and the <span class="calibre10">data-access object pattern</span>, and when and how to implement domain-store patterns. Finally, we learned about service-activator pattern concepts and when and how to implement this using JMS, EJB asynchronous methods, asynchronous event mechanisms, and the best practices of Java EE 8.</p>
<p class="mce-root">In the next chapter, we will cover reactive patterns, focusing on when to use them and how to implement them using best practices of Java EE 8. </p>


            </article>

            
        </section>
    </div>



  </body></html>