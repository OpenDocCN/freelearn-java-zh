["```java\nscala> 2 :: 1 :: \"bar\" :: \"foo\" :: Nil\nres0: List[Any] = List(2, 1, bar, foo)\n```", "```java\nscala> res0.head\nres1: Any = 2\n```", "```java\nscala> def drop1[A](l: List[A]) = l.tail\ndrop1: [A](l: List[A])List[A]\n\nscala> drop1(List(1, 2, 3))\nres1: List[Int] = List(2, 3)\n```", "```java\nval x = 3 + 4 * 5         // the type of x is Int\nval y = x.toString()      // the type of y is String\ndef succ(x: Int) = x + 2  // method succ returns Int values\n```", "```java\ndef fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)\n```", "```java\n<console>:11: error: recursive method fac needs result type\n       def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)\n```", "```java\nclass Stack[T] {\n  var elems: List[T] = Nil\n  def push(x: T) { elems = x :: elems }\n  def top: T = elems.head\n  def pop() {elems = elems.tail }\n}\n```", "```java\nscala> def drop1[A <: AnyRef](l: List[A]) = l.tail\ndrop1: [A <: AnyRef](l: List[A])List[A]\n```", "```java\nscala> drop1(List(1, 2, 3))\n<console>:13: error: inferred type arguments [Int] do not conform to method drop1's type parameter bounds [A <: AnyRef]\n       drop1(List(1, 2, 3))\n       ^\n<console>:13: error: type mismatch;\n found   : List[Int]\n required: List[A]\n       drop1(List(1, 2, 3))\n```", "```java\nFoo[T] forSome { type T }\n```", "```java\nscala> def foo(x: Array[Any]) = x.length\nfoo: (x: Array[Any])Int\n```", "```java\nscala> val a = Array(\"foo\", \"bar\", \"baz\")\na: Array[String] = Array(foo, bar, baz)\n\nscala> foo(a)\n<console>:14: error: type mismatch;\n found   : Array[String]\n required: Array[Any]\nWe can fix this by adding a type parameter:\nscala> def foo[T](x: Array[T]) = x.length\nfoo: [T](x: Array[T])Int\nscala> foo(a)\nres0: Int = 3\n```", "```java\nscala> def foo(x: Array[T] forSome { type T }) = x.length\nfoo: (x: Array[_])Int\n\nscala> foo(a)\nres0: Int = 3\n```", "```java\nscala> def foo(x: Array[_]) = x.length\nfoo: (x: Array[_])Int\n\nscala> foo(a)\nres0: Int = 3\n```", "```java\ntrait IntTree\ncase class IntNode(value: Int, left: IntTree, right: IntTree) extends IntTree\ncase object IntEmpty extends IntTree\n```", "```java\ndef insert(value: Int, tree: IntTree): IntTree =\n  tree match {\n    case IntEmpty => IntNode(value, IntEmpty, IntEmpty)\n    case IntNode(currentValue, left, right) =>\n      if (value < currentValue)\n        IntNode(currentValue, insert(value, left), right)\n      else\n        IntNode(currentValue, left, insert(value, right))\n  }\n\ndef search(value: Int, tree: IntTree): Boolean =\n  tree match {\n    case IntEmpty => false\n    case IntNode(currentValue, left, right) =>\n      value == currentValue ||\n        (value < currentValue && search(value, left)) ||\n       (value >= currentValue && search(value, right))\n  }\n```", "```java\n    insert[A](value: A, tree: Tree[A], comp: (A, A) => Boolean).\n    ```", "```java\n    search[A](value: A, tree: Tree[A], comp: (A, A) => Boolean)\n    ```", "```java\nclass Tool\nclass HandTool extends Tool\nclass PowerTool extends Tool\nclass Hammer extends HandTool\nclass Screwdriver extends HandTool\nclass Driller extends PowerTool\nIf we define a generic box:\ntrait Box[T] {\n  def get: T\n}\n```", "```java\ndef isSuitable(box: Box[HandTool]) = ???\n```", "```java\n<console>:14: error: type mismatch;\n found   : Box[Hammer]\n required: Box[HandTool]\n```", "```java\ntrait Box[+T] {\n  def get: T\n}\n```", "```java\ntrait Operator[A] {\n  def operate(t: A)\n}\n```", "```java\ndef fix(operator: Operator[Hammer]) = ???\n```", "```java\n<console>:14: error: type mismatch;\n found   : Operator[HandTool]\n required: Operator[Hammer]\n```", "```java\ntrait Operator[-A] {\n  def operate(t: A)\n}\n```", "```java\nscala> trait Operator[+A] { def operate(t: A) }\n<console>:11: error: covariant type A occurs in contravariant position in type A of value t\n       trait Operator[+A] { def operate(t: A) }\n```", "```java\nString[] strings = new String[1];\nObject[] objects = strings;\nobjects[0] = new Integer(1); // RUN-TIME FAILURE\n```", "```java\ntrait List[+A] {\n  def ::(a: A): List[A]\n}\n```", "```java\ndef ::[B >: A](a: B): List[B]\n```", "```java\nscala> val l = List(new Hammer {}, new Hammer {}, new Hammer {})\nl: List[Hammer] = List($anon$1@79dd6dfe, $anon$2@2f478dcf, $anon$3@3b88adb0)\n\nscala> val l2 = new Screwdriver {} :: l\nl2: List[HandTool] = List($anon$1@7065daac, $anon$1@79dd6dfe, $anon$2@2f478dcf, $anon$3@3b88adb0)\n```", "```java\ntrait Tool {\n  def weight: Long\n  def price: Long\n}\n\ntrait HandTool extends Tool\ntrait PowerTool extends Tool\ncase class Hammer(weight: Long, price: Long) extends HandTool\ncase class Screwdriver(weight: Long, price: Long) extends HandTool\ncase class Driller(weight: Long, price: Long) extends PowerTool\n```", "```java\nclass Operator {\n  type ToolOfChoice\n}\n\nclass Susan extends Operator {\n  type ToolOfChoice = Hammer\n}\n\nclass Operator[ToolOfChoice]\nclass Susan extends Operator[ToolOfChoice]\n```", "```java\nscala> val tool: Susan#ToolOfChoice = new Hammer\ntool: Hammer = Hammer@d8756ac\n```", "```java\ndef quacker(duck: { def quack(value: String): String }) {\n  println(duck.quack(\"Quack\"))\n}\n\nobject BigDuck {\n  def quack(value: String) = value.toUpperCase\n}\n\nobject SmallDuck {\n  def quack(value: String) = value.toLowerCase\n}\n…\n…\n required: AnyRef{def quack(value: String): String}\n       quacker(NotADuck)\n```", "```java\nval intOption1: Option[Int] = Some(2)\nval intOption2: Option[Int] = None\nval strOption: Option[String] = Option(null)\n```", "```java\ndef foo(v: Option[Int]) = v match {\n  case Some(value) => println(s\"I have a value and it's $value.\")\n  case None => println(\"I have no value.\")\n}\n```", "```java\ntrait Container[M[_]] {\n  def put[A](x: A): M[A]\n  def get[A](m: M[A]): A\n}\n\nval listContainer = new Container[List] {\n  def put[A](x: A) = List(x)\n  def get[A](m: List[A]) = m.head\n}\n\nscala> listContainer.put(\"str\")\nres0: List[String] = List(str)\n\nscala> listContainer.put(123)\nres1: List[Int] = List(123)\n```", "```java\ndef optMatch[A](opt: Any) = opt match {\n  case opt: Option[Int] => println(s\"Got Option[Int]: $opt.\")\n  case opt: Option[String] => println(s\"Got Option[String]: $opt.\")\n  case other => println(s\"Got something else: $other.\")\n}\n\nscala> optMatch(Some(123))\nGot Option[Int]: Some(123).\n\nscala> optMatch(Some(\"str\"))\nGot Option[Int]: Some(str).\n```", "```java\ncase class IntOption(v: Option[Int])\ncase class StringOption(v: Option[String])\n```"]