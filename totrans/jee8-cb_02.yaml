- en: Server-Side Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE can be seen as being **made for server-side development**. Most of the
    APIs are powerful for server-side processing and managing.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide you with some common and useful scenarios that you
    may face as a Java EE developer and will show you how you should deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CDI to inject context and dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bean Validation for data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using servlet for request and response management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Server Push to make objects available beforehand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB and JTA for transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB to deal with concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JPA for smart data persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB and JPA for data caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using batch processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CDI to inject context and dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context and Dependency Injection for Java EE (CDI) is one of the most important
    APIs under the Java EE umbrella. Introduced in Java EE 6, it now has a big influence
    over many other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, you will learn how to use CDI in a couple of different ways and
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add the required dependency needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a JAX-RS based application, so we will start by preparing
    the application to perform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `User` application as our main object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `User` class doesn''t have a default constructor, so CDI doesn''t know
    how to construct the class when it tries to inject it. So, we create a factory
    class and use the `@Produces` annotation over its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an enumeration to list our profile types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a custom annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add them to an interface to prototype the user profile behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined the profile list and its behavior with respect to
    the user, we can give it a proper implementation for an admin profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the same can be done for an operator profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a REST endpoint by injecting all the objects that we are going
    to use into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This method gets the user injected by CDI and sends it to the result page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This one does the same with an admin profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And this one does the same with an operator profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we send the default profile to the result page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `fireUserEvents` method to fire an event and async events over a previously
    injected `User` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we build a page to call each endpoint method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we use an expression language to print the result at the result
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, there''s a lot happening in the previous section! We should first have
    a look at the `@Produces` annotation. It is a CDI annotation that says to the
    server: "*Hey! This method knows how to construct a User object.*"'
  prefs: []
  type: TYPE_NORMAL
- en: As we didn't create a default constructor for the `User` class, the `getUser`
    method from our factory will be injected into our context as one.
  prefs: []
  type: TYPE_NORMAL
- en: The second annotation is our custom annotation `@Profile` that has our enumeration
    `ProfileType` as a parameter. It is the qualifier of our `UserProfile` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at these declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will *teach* CDI how to inject a `UserProfile` object:'
  prefs: []
  type: TYPE_NORMAL
- en: If the object is annotated as `@Profile(ProfileType.ADMIN)`, use `ImplAdmin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is annotated as `@Profile(ProfileType.OPERATOR)`, use `ImplOperator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is not annotated, use `ImplOperator`, as it has the `@Default`
    annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see them in action in our endpoint declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So CDI is helping us to use the context to inject the right implementation of
    our `UserProfile` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the endpoint methods, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we included `HttpServletRequest` and `HttpServletResponse` as parameters
    for our method, but annotated them as `@Context`. So even though this is not a
    servlet context (when we have easy access to request and response references),
    we can ask CDI to give us a proper reference to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we have our user event engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we are using the `@Observes` and `@ObserversAsync` annotations to say to
    CDI: "*Hey CDI! Watch over User object... when somebody fires an event over it,
    I want you to do something.*"'
  prefs: []
  type: TYPE_NORMAL
- en: And for "something," CDI understands this as calling the `sendUserNotification`
    and `sendUserNotificationAsync` methods. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, `@Observers` will be executed synchronously and `@ObservesAsync`
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a GlassFish 5 to run this recipe. You can do it with whatever Java EE
    8 compatible server you want, and you can even use CDI with Java SE without any
    server. Have a look at the CDI recipe from [Chapter 1](86071f26-42aa-43e2-8409-6feaed4759e0.xhtml),
    *New Features and Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can see the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bean Validation for data validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use Bean Validation to constrain your data in many different ways. In
    this recipe, we are going to use it to validate a JSF form, so we can validate
    it as soon as the user tries to submit it, and avoid any invalid data right away.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we add our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `User` object that will be attached to our JSF page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the method that will be fired once all data is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now our JSF page references each `User` class fields declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run this code, you will get all fields validated once you click
    the Submit button. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check each declared constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@NotBlank` annotation will deny not only null values, but also white spaces
    values, and `@Size` speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Email` constraint will check the email string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`@PastOrPresent` will constrain `LocalDate` to be in the past or until the
    present date. It can''t be in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we can''t use `@NotBlank`, as there is no blank date, only null, so we
    avoid it using `@NotNull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as the last one, but constraints for a future date.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our UI, there are two places worth a careful look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using `convertDateTime` to automatically convert the data inputted into
    `inputText` according to the `dd/MM/uuuu` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using servlet for request and response management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Servlet API was created even before Java EE exists—actually before J2EE
    existed! It became part of EE in J2EE 1.2 (Servlet 2.2) in 1999.
  prefs: []
  type: TYPE_NORMAL
- en: This is a powerful tool to deal with a request/response context and this recipe
    will show you an example of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `User` class for our recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then our servlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the `@PostConstruct` annotation over the `instantiateUser()` method.
    It says to the server that whenever this servlet is constructed (a new instance
    is up), it can run this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also implement the `init()` and `destroy()` super methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And we also implemented `doGet()` and `doPost()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `doGet()` and `doPost()` will call our custom method `doRequest()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And we finally have a web page to call our servlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE server itself will call `doGet()` or `doPost()` methods, depending
    on the HTTP method used by the caller. In our recipe, we are redirecting them
    both to the same `doRequest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `init()` method belongs to the servlet life cycle managed by the server
    and is executed as a first method after the servlet instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: The `destroy()` method also belongs to the servlet life cycle and it's executed
    as the last method before the instance deallocation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `init()` behavior seems like `@PostConstruct`, but this last one is executed
    before `init()`, so keep it in mind when using both.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PostConstruct` is executed right after the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when using the `destroy()` method and avoid holding any memory reference; otherwise,
    you can mess up with the servlet life cycle and run into memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Server Push to make objects available beforehand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important new features of Servlet 4.0 is the HTTP/2.0 support.
    It brings another cool and reliable feature—the Server Push.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use Server Push in a filter and push the resources
    needed in every request that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should first add the dependencies needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first create `UserServlet` that calls `user.jsp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And we do the same with `ProfileServlet`, but by calling `profile.jsp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we create a filter that will be executed on every request (`urlPatterns
    = {"/*"}`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create a page to call our servlets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the pages called by the servlets. First is the `user.jsp` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the `profile.jsp` page is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application running under HTTP/1.0 sends a request to the server when
    it finds references for an image file, CSS file, and any other resources needed
    to render a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'With HTTP/2.0 you still can do it, but now you can do better: the server can
    now push the resources beforehand, avoiding unnecessary new requests, decreasing
    the server load, and improving performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, our resources are represented by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And the push happens at this part of our filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So when the browser needs those resources to render the web page, they are already
    available.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that your browser needs to support the Server Push feature; otherwise,
    your page will work as usual. So make sure you check if `PushBuilder` is null
    before using it and ensure all users will have the working application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that JSF 2.3 is built over the Server Push feature, so if you just migrate
    your JSF application to a Java EE 8 compatible server, you get its performance
    boost for free!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB and JTA for transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Transaction API, or JTA, is an API that enables distributed transactions
    over the Java EE environment. It is most powerful when you delegate the transaction
    management to the server.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to do it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, add the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create our persistence unit (at `persistence.xml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a `User` class as an entity (`@Entity`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need an EJB to perform the operations over the `User` entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we create our unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key code line in this recipe for JTA is right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `transaction-type=''JTA''`, you are saying to the server that
    it should take care of all transactions made under this context. If you use `RESOURCE-LOCAL`
    instead, you are saying that you are taking care of the transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each called method of `UserBean` starts a transaction to be completed and would
    run into a rollback if there's any issue while the transaction is alive would
    commit to the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important piece of code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, here we are defining our `PersistenceContext` as `EXTENDED`. It means that
    this persistence context is bound to the `@Stateful` bean until it is removed
    from the container.
  prefs: []
  type: TYPE_NORMAL
- en: The other option is `TRANSACTION`, which means the persistence context would
    live only by the time of transaction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB to deal with concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency management is one of the biggest advantages supplied by a Java EE
    server. You can rely on a ready environment to deal with this tricky topic.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how you can set up your beans to use it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just add a Java EE dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe will show you three scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first scenario, `LockType` is defined at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second scenario, `LockType` is defined at the method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The third scenario is a self-managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to have a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is completely redundant! Singleton beans are container-managed by default,
    so you don't need to specify them.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons are designed for concurrent access, so they are the perfect use case
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check the `LockType` defined at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When we use the `@Lock` annotation at the class level, the informed `LockType` will
    be used for all class methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `LockType.READ` means that many clients can access a resource
    at the same time. It is usual for reading data.
  prefs: []
  type: TYPE_NORMAL
- en: In case of some kind of locking, `LockType` will use the `@AccessTimeout` annotation
    time defined to run into a timeout or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check `LockType` defined at the method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So, here we are basically saying that `getUserCount()` can be accessed by many
    users at once (`LockType.READ`), but `addUser()` will be accessed just by one
    user at a time (`LockType.WRITE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last case is the self-managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you have to manage all the concurrency issues for your bean in
    your code. We used a synchronized qualifier as an example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you really *really* need to, don't use self-managed beans. The Java EE
    container is (well) designed to do it in a very efficient and elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JPA for smart data persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Persistence API is a specification that describes an interface for
    managing relational databases using Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: It eases data manipulation and reduces a lot of the code written for it, especially
    if you are used to SQL ANSI.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use it to persist your data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add the dependencies needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating an entity (you can see it as a table):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we declare our persistence unit (at `persistence.xml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a session bean to manage our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we use a unit test to try it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break down our **persistence unit** (**pu**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This line defines the pu name and the transaction type used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows the provider the JPA implementation used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the datasource name that will be accessed through JNDI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This line lets all your entities be available for this pu, so you don''t need
    to declare each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This block allows the database objects to be created if they don''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s have a look at `UserBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`EntityManager` is the object responsible for the interface between the bean
    and the datasource. It''s bound to the context by the `@PersistenceContext` annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we check the `EntityManager` operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `persist()` method is used to add new data to the datasource. At the end
    of the execution, the object is attached to the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge()` method is used to update existing data on the datasource. The
    object is first found at the context, then updated at the database and attached
    to the context with the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `remove()` method, guess what is it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: And finally the `find()` method uses the `id` parameter to search a database
    object with the same ID. That's why JPA demands your entities have an ID declared
    with the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EJB and JPA for data caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to build a simple and local cache for your application is an important
    skill. It may have a big impact on some data access performance and it is quite
    easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply add a Java EE dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `User` class to be our cached object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And then create a singleton to hold our user list cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first understand our bean declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We are using a singleton because it has one and only one instance in the application
    context. And that's the way we want a data cache because we don't want to allow
    the possibility of different data being shared.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we used the `@Startup` annotation. It says to the server that
    this bean should be *executed* once it is loaded and the method annotated with
    `@PostConstruct` is used for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we take the startup time to load our cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check the object holding our cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`ConcurrentLinkedQueue` is a list built with one main purpose—being accessed
    by multiple processes in a thread-safe environment. That''s exactly what we need
    and also it offers great performance on accessing its members.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, let''s check the access to our data cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We annotated the `get()` method with `LockType.READ`, so it says to the concurrency
    manager that it can be accessed by multiple processes at once in a thread-safe
    way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need big and complex caches in your application, you should use some
    enterprise cache solutions for better results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using batch processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batch processing is the last recipe of this chapter. Running background tasks
    is a useful and important skill in an enterprise context.
  prefs: []
  type: TYPE_NORMAL
- en: You could use it to process data in bulk or just to separate it from the UI
    processes. This recipe will show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first define our persistence unit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we declare a `User` entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create a job reader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a job processor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we create a job writer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The processor, reader, and writer are referenced by the `acess-user.xml` file
    located at `META-INF.batch-jobs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create a bean to interact with the batch engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of this example, we are going to use a JSF page to run the
    job and load the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Run it on a Java EE server, click on the Run button and then the Reload button.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserReader` extends the `AbstractItemReader` class that has two key methods:
    `open()` and `readItem()`. In our case, the first one opens the `META-INF/user.txt`
    and the second one reads each line of the file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UserProcessor` class extends the `ItemProcessor` class that has a `processItem()`
    method. It gets the item read by `readItem()` (from `UserReader`) to generate
    the `User` object that we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all items are processed and available in a list (in memory) we use the
    `UserWriter` class; that extends the `AbstractItemWriter` class and has the `writeItems`
    method. We use it, in our case, to persist the data read from the `user.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All set so, we just use `UserBean` to run the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `job.start()` method is referencing the `acess-user.xml` file, enabling
    our reader, processor, and writer to work together.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
