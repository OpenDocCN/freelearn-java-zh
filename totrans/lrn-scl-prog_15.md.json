["```java\nslasch@void:~$ mkdir bakery\nslasch@void:~$ cd bakery\nslasch@void:~$ echo 'addSbtPlugin(\"com.lightbend.lagom\" % \"lagom-sbt-plugin\" % \"1.4.7\")' > plugins.sbt\nslasch@void:~$ echo 'sbt.version=1.1.5' > build.properties\nslasch@void:~$ cd ..\nslasch@void:~$ echo '-J-Xms1024M\n> -J-Xmx4096M\n> -J-Xss2M\n> -J-XX:MaxMetaspaceSize=1024M' > .sbtopts\n```", "```java\norganization in ThisBuild := \"packt\"\nversion in ThisBuild := \"1.0-SNAPSHOT\"\n\nscalaVersion in ThisBuild := \"2.12.6\"\n\nval macwire = \"com.softwaremill.macwire\" %% \"macros\" % \"2.3.0\" % Provided\nval scalaTest = \"org.scalatest\" %% \"scalatest\" % \"3.0.5\" % Test\nval defaultDependencies = Seq(lagomScaladslTestKit, macwire, scalaTest)\n\nlazy val `shared-model` = (project in file(\"shared-model\"))\n  .settings(libraryDependencies += lagomScaladslApi)\n\nlazy val bakery = (project in file(\".\"))\n  .aggregate(\n    `boy-api`, `boy-impl`, \n    `chef-api`, `chef-impl`, \n    `cook-api`, `cook-impl`, \n    `baker-api`, `baker-impl`, \n    `manager-api`, `manager-impl`)\n\nlazy val `boy-api` = (project in file(\"boy-api\"))\n  .settings(libraryDependencies += lagomScaladslApi)\n\n// other APIs defined the same way\n\nlazy val `boy-impl` = (project in file(\"boy-impl\"))\n  .enablePlugins(LagomScala)\n  .settings(libraryDependencies ++= defaultDependencies)\n  .dependsOn(`boy-api`)\n\n// other implementations defined the same way\n\nlazy val `chef-impl` = (project in file(\"chef-impl\"))\n  .enablePlugins(LagomScala)\n  .settings(\n    libraryDependencies ++= Seq(\n      lagomScaladslPersistenceCassandra,\n      lagomScaladslKafkaBroker,\n      lagomScaladslTestKit,\n      lagomScaladslPubSub,\n      macwire\n    )\n  )\n  .settings(lagomForkedTestSettings: _*)\n  .dependsOn(`chef-api`)\n\nlazy val `manager-impl` = (project in file(\"manager-impl\"))\n  .enablePlugins(LagomScala)\n  .settings(libraryDependencies ++= defaultDependencies)\n  .dependsOn(`manager-api`, `boy-api`, `chef-api`, `cook-api`, `baker-api`)\n```", "```java\nslasch@void:~/ch15 [ch15-lagom]$ tree --dirsfirst\n.\n├── baker-api\n├── baker-impl\n├── boy-api\n├── boy-impl\n├── chef-api\n├── chef-impl\n├── cook-api\n├── cook-impl\n├── manager-api\n├── manager-impl\n├── project\n│   ├── build.properties\n│   └── plugins.sbt\n└── build.sbt\n```", "```java\nslasch@void:~/ch15/cook-api [ch15-lagom]$ tree\n.\n└── src\n ├── main\n │   ├── resources\n │   └── scala\n └── test\n ├── resources\n └── scala\n```", "```java\npackage ch15\n\nobject model {\n  final case class ShoppingList(eggs: Int, flour: Int, sugar: Int, chocolate: Int)\n  final case class Groceries(eggs: Int, flour: Int, sugar: Int, chocolate: Int)\n  final case class Dough(weight: Int)\n  final case class RawCookies(count: Int)\n  final case class ReadyCookies(count: Int)\n}\n```", "```java\nimport play.api.libs.json._\n\nimplicit val dough: Format[Dough] = Json.format\nimplicit val rawCookies: Format[RawCookies] = Json.format\nimplicit val readyCookies: Format[ReadyCookies] = Json.format\nimplicit val groceries: Format[Groceries] = Json.format\nimplicit val shoppingList: Format[ShoppingList] = Json.format\n\n```", "```java\nimport com.lightbend.lagom.scaladsl.api._\nimport ch15.model._\n\ntrait CookService extends Service {\n  def cook: ServiceCall[Dough, RawCookies]\n\n  override def descriptor: Descriptor = {\n    import Service._\n    named(\"CookService\").withCalls(call(cook))\n  }\n}\n```", "```java\ntrait ServiceCall[Request, Response] {\n  def invoke(request: Request): Future[Response]\n}\n```", "```java\npackage ch15\n\nimport ch15.model._\nimport com.lightbend.lagom.scaladsl.api._\n\nimport scala.concurrent.Future\n\nclass CookServiceImpl extends CookService {\n  override def cook = ServiceCall { dough =>\n    Future.successful(RawCookies(makeCookies(dough.weight)))\n  }\n  private val cookieWeight = 60\n  private def makeCookies(weight: Int): Int = weight / cookieWeight\n}\n```", "```java\n def apply[Request, Response](call: Request => Future[Response]): ServiceCall[Request, Response]\n```", "```java\nabstract class CookApplication(context: LagomApplicationContext)\n  extends LagomApplication(context) {\n  override lazy val lagomServer: LagomServer = serverFor[CookService](wire[CookServiceImpl])\n}\n```", "```java\nclass CookLoader extends LagomApplicationLoader {\n\n  override def load(context: LagomApplicationContext) =\n    new CookApplication(context) with AhcWSComponents {\n      override def serviceLocator: ServiceLocator = NoServiceLocator\n    }\n\n  override def loadDevMode(context: LagomApplicationContext) =\n    new CookApplication(context) with AhcWSComponents with LagomDevModeComponents\n}\n```", "```java\nplay.application.loader = ch15.CookLoader\n```", "```java\nsbt:bakery> runAll\n[info] Starting Kafka\n[info] Starting Cassandra\n[info] Cassandra server running at 127.0.0.1:4000\n[info] Service locator is running at http://localhost:9008\n[info] Service gateway is running at http://localhost:9000\n[info] Service cook-impl listening for HTTP on localhost:57733\n[info] Service baker-impl listening for HTTP on localhost:50764\n[info] Service manager-impl listening for HTTP on localhost:63552\n[info] Service chef-impl listening for HTTP on localhost:56263\n[info] Service boy-impl listening for HTTP on localhost:64127\n```", "```java\nslasch@void:~$ curl -X POST http://localhost:57733/cook -d '{ \"weight\": 100 }'\n{\"count\":1}\n```", "```java\ntrait BoyService extends Service {\n  def shop: ServiceCall[ShoppingList, Groceries]\n\n  override def descriptor: Descriptor =\n    named(\"BoyService\").withCalls(namedCall(\"go-shopping\", shop))\n}\n```", "```java\nclass BoyServiceImpl extends BoyService {\n  override def shop = ServiceCall(callExternalApi)\n  private val callExternalApi: ShoppingList => Future[Groceries] = ???\n}\n```", "```java\nlagomUnmanagedServices in ThisBuild := Map(\"GroceryShop\" -> \"http://localhost:8080\")\n```", "```java\ntrait ShopService extends Service {\n  def order: ServiceCall[Order, Purchase]\n  override def descriptor: Descriptor = {\n    named(\"GroceryShop\").withCalls(restCall(Method.POST, \"/purchase\", order))\n  }\n}\n```", "```java\nobject ShopService {\n  final case class Order(order: ShoppingList)\n  final case class Purchase(order: Groceries)\n  implicit val purchase: Format[Purchase] = Json.format\n  implicit val order: Format[Order] = Json.format\n}\n```", "```java\nclass BoyServiceImpl(shopService: ShopService)                    \n               (implicit ec: ExecutionContext) extends BoyService {\n  override def shop: ServiceCall[ShoppingList, Groceries] = ServiceCall(callExtApi)\n\n  private val callExtApi: ShoppingList => Future[Groceries] = list =>\n    shopService.order.invoke(Order(list)).map(_.order).recover {\n      case _ => Groceries(0, 0, 0, 0)\n    }\n}\n```", "```java\nimport akka.NotUsed\nimport akka.stream.scaladsl.Source\n\ntrait BakerService extends Service {\n  def bake: ServiceCall[Source[RawCookies, NotUsed],\n                        Source[ReadyCookies, NotUsed]]\n\n  override def descriptor: Descriptor = named(\"BakerService\").withCalls(call(bake))\n}\n```", "```java\nimport play.api.Logger\n\nclass BakerServiceImpl extends BakerService {\n\n  private val logger = Logger(\"Baker\")\n\n  override def bake: ServiceCall[Source[RawCookies, NotUsed],\n                     Source[ReadyCookies, NotUsed]] = \n      ServiceCall { dough =>\n         logger.info(s\"Baking: $dough\")\n         Future.successful(dough.via(bakerFlow))\n      }\n\n  private val bakerFlow: Flow[RawCookies, ReadyCookies, NotUsed] =\n    Baker.bakeFlow.join(Oven.bakeFlow)\n}\n```", "```java\nimport ch15.model._\nimport java.util.UUID\nimport akka.Done\nimport com.lightbend.lagom.scaladsl.persistence._\nimport PersistentEntity.ReplyType\nimport com.lightbend.lagom.scaladsl.playjson.JsonSerializer\nimport play.api.libs.json._\n```", "```java\nsealed trait ChefCommand\nfinal case class MixCommand(groceries: Groceries) extends ChefCommand with ReplyType[Done]\nfinal case class DoneCommand(id: UUID) extends ChefCommand with ReplyType[Done]\n```", "```java\nsealed trait ChefEvent\nfinal case class Mixing(id: UUID, groceries: Groceries) extends ChefEvent\nfinal case class MixingDone(id: UUID, dough: Dough) extends \n  ChefEvent with AggregateEvent[MixingDone] {\n    override def aggregateTag: AggregateEventTag[MixingDone] = ChefModel.EventTag\n  }\n```", "```java\nsealed trait ChefState {\n  def batches: List[Mixing]\n}\nfinal case class MixingState(batches: List[Mixing]) extends ChefState\n```", "```java\nobject ChefModel {\n  import play.api.libs.json._\n  implicit val mixingFormat = Json.format[Mixing]\n\n  val serializers = List(\n    JsonSerializer(mixingFormat),\n    JsonSerializer(Json.format[MixingDone]),\n    JsonSerializer(Json.format[MixingState]))\n\n  val EventTag: AggregateEventTag[MixingDone] = AggregateEventTag[MixingDone](\"MixingDone\")\n}\n```", "```java\nuser.cassandra.keyspace = chefprogress\n\ncassandra-journal.keyspace = ${user.cassandra.keyspace}\ncassandra-snapshot-store.keyspace = ${user.cassandra.keyspace}\nlagom.persistence.read-side.cassandra.keyspace =\n ${user.cassandra.keyspace}\n```", "```java\ntrait ChefService extends Service {\n  def mix: ServiceCall[Groceries, Done]\n\n  def resultsTopic: Topic[Dough]\n\n  override def descriptor: Descriptor = {\n    named(\"ChefService\")\n      .withCalls(call(mix))\n      .withTopics(topic(ChefService.ResultsTopic, resultsTopic))\n      .withAutoAcl(true)\n  }\n}\nobject ChefService {\n  val ResultsTopic = \"MixedResults\"\n}\n```", "```java\nclass ChefServiceImpl(persistentEntities: PersistentEntityRegistry,\n                      as: ActorSystem) extends ChefService {\n\n  private lazy val entity = wire[ChefPersistentEntity]\n  persistentEntities.register(entity)\n\n  override def mix: ServiceCall[Groceries, Done] = ServiceCall { groceries =>\n      val ref = persistentEntities.refFor[ChefPersistentEntity](\"Chef\")\n      ref.ask(MixCommand(groceries))\n  }\n\n  override def resultsTopic: Topic[Dough] = ???\n}\n```", "```java\nfinal class ChefPersistentEntity(\n    persistentEntities: PersistentEntityRegistry, as: ActorSystem\n  ) extends PersistentEntity { ... }\n```", "```java\noverride type Command = ChefCommand\noverride type Event = ChefEvent\noverride type State = ChefState\noverride def initialState: ChefState = MixingState(Nil)\n```", "```java\nprivate def dough(g: Groceries) = {\n  import g._\n  Dough(eggs * 50 + flour + sugar + chocolate)\n}\n```", "```java\nActions()\n  .onCommand[MixCommand, Done] {\n    case (MixCommand(groceries), ctx, _) if groceries.eggs <= 0 =>\n      ctx.invalidCommand(s\"Need at least one egg but got: $groceries\")\n      ctx.done\n\n    case (MixCommand(groceries), ctx, _) =>\n      val id = UUID.randomUUID()\n      ctx.thenPersist(Mixing(id, groceries)) { evt =>\n        as.scheduler.scheduleOnce(mixingTime)(\n          thisEntity.ask(DoneCommand(id)))\n        ctx.reply(Done)\n      }\n  }\n```", "```java\nlazy val thisEntity = persistentEntities.refFor[ChefPersistentEntity](this.entityId)\n```", "```java\nActions()\n  .onCommand[MixCommand, Done] { ... }\n  .onEvent {\n    case (m: Mixing, state) =>\n      MixingState(state.batches :+ m)\n\n    case (MixingDone(id, _), state) =>\n      MixingState(state.batches.filterNot(_.id == id))\n  }\n```", "```java\nActions()\n  .onCommand[MixCommand, Done] { ... }\n  .onEvent { ... }\n  .onCommand[DoneCommand, Done] {\n    case (DoneCommand(id), ctx, state) =>\n      state.batches\n        .find(_.id == id)\n        .map { g =>\n          ctx.thenPersist(MixingDone(id, dough(g.groceries))) { \n             _ => ctx.reply(Done)\n          }\n        }\n        .getOrElse(ctx.done)\n  }\n\n```", "```java\nabstract class ChefApplication(context: LagomApplicationContext)\n  extends LagomApplication(context) with CassandraPersistenceComponents with LagomKafkaComponents {\n  override lazy val lagomServer: LagomServer = serverFor[ChefService](wire[ChefServiceImpl])\n  override lazy val jsonSerializerRegistry = new JsonSerializerRegistry {\n      override def serializers = ChefModel.serializers\n  }\n}\n```", "```java\nclass ChefServiceImpl(...) extends ChefService {\n\n  ...\n\n  override def resultsTopic: Topic[Dough] =\n    TopicProducer.singleStreamWithOffset { fromOffset =>\n      persistentEntities\n        .eventStream(ChefModel.EventTag, fromOffset)\n        .map { ev => (convertEvent(ev), ev.offset) }\n    }\n\n  private def convertEvent(chefEvent: EventStreamElement[ChefEvent]): Dough = {\n    chefEvent.event match {\n      case MixingDone(_, dough) => dough\n    }\n  }\n}\n```", "```java\nval sub: Future[Done] = chefService.resultsTopic.subscribe.atLeastOnce(cookChefFlow)\n```", "```java\ntrait ManagerService extends Service {\n  def bake(count: Int): ServiceCall[NotUsed, Done]\n  def sell(count: Int): ServiceCall[NotUsed, Int]\n  def report: ServiceCall[NotUsed, Int]\n\n  override def descriptor: Descriptor = {\n    import Service._\n    named(\"Bakery\").withCalls(\n      restCall(Method.POST, \"/bake/:count\", bake _),\n      restCall(Method.POST, \"/sell?count\", sell _),\n      pathCall(\"/report\", report)\n    )\n  }\n}\n```", "```java\nclass ManagerServiceImpl(boyService: BoyService,\n                         chefService: ChefService,\n                         cookService: CookService,\n                         bakerService: BakerService,\n                         as: ActorSystem)\n    extends ManagerService {\n\n  private val count: AtomicInteger = new AtomicInteger(0)\n\n  private val logger = Logger(\"Manager\")\n\n  ...\n}\n```", "```java\noverride def sell(cnt: Int): ServiceCall[NotUsed, Int] =\n  ServiceCall { _ =>\n   if (cnt > count.get()) {\n     Future.failed(new IllegalStateException(s\"Only $count cookies on sale\"))\n  } else {\n    count.addAndGet(-1 * cnt)\n    Future.successful(cnt)\n  }\n}\n\noverride def report: ServiceCall[NotUsed, Int] = ServiceCall { _ =>\n  Future.successful(count.get())\n}\n```", "```java\noverride def bake(count: Int): ServiceCall[NotUsed, Done] = ServiceCall { _ =>\n  val sl = shoppingList(count)\n  logger.info(s\"Shopping list: $sl\")\n  for {\n    groceries <- boyService.shop.invoke(sl)\n    done <- chefService.mix.invoke(groceries)\n  } yield {\n    logger.info(s\"Sent $groceries to Chef\")\n    done\n  }\n}\n```", "```java\nprivate lazy val chefFlow: Flow[Dough, Done, NotUsed] = Flow[Dough]\n  .map { dough: Dough =>\n    val fut = cookService.cook.invoke(dough)\n    val src = Source.fromFuture(fut)\n    val ready: Future[Source[ReadyCookies, NotUsed]] =\n      bakerService.bake.invoke(src)\n    Source.fromFutureSource(ready)\n  }\n  .flatMapConcat(identity)\n  .map(count.addAndGet(cookies.count))\n  .map(_ => Done)\n```", "```java\nabstract class ManagerApplication(context: LagomApplicationContext)\n    extends LagomApplication(context) with LagomKafkaClientComponents {\n  lazy val boyService: BoyService = serviceClient.implement[BoyService]\n  lazy val chefService: ChefService = serviceClient.implement[ChefService]\n  lazy val cookService: CookService = serviceClient.implement[CookService]\n  lazy val bakerService: BakerService = serviceClient.implement[BakerService]\n  override lazy val lagomServer: LagomServer =\n    serverFor[ManagerService](wire[ManagerServiceImpl])\n}\n```", "```java\ncurl -X \"POST\" \"http://localhost:58866/bake/10\"\n```", "```java\nimport ch15.model.Dough\nimport com.lightbend.lagom.scaladsl.server.LocalServiceLocator\nimport com.lightbend.lagom.scaladsl.testkit.ServiceTest\nimport org.scalatest.{AsyncWordSpec, Matchers}\nimport play.api.libs.ws.ahc.AhcWSComponents\n\nclass CookServiceSpec extends AsyncWordSpec with Matchers {\n\n  \"The CookService\" should {\n    \"make cookies from Dough\" in ServiceTest.withServer(ServiceTest.defaultSetup) { ctx =>\n      new CookApplication(ctx) with LocalServiceLocator with AhcWSComponents\n    } { server =>\n      val client = server.serviceClient.implement[CookService]\n      client.cook.invoke(Dough(200)).map { cookies =>\n        cookies.count should ===(3)\n      }\n    }\n  }\n}\n```", "```java\nclass BakerServiceSpec extends AsyncWordSpec with Matchers {\n\n  \"The BakerService\" should {\n    \"bake cookies\" in ServiceTest.withServer(ServiceTest.defaultSetup) { ctx =>\n      new BakerApplication(ctx) with LocalServiceLocator\n    } { server =>\n      val client = server.serviceClient.implement[BakerService]\n      implicit val as: Materializer = server.materializer\n      val input: Source[RawCookies, NotUsed] =\n        Source(List(RawCookies(10), RawCookies(10), RawCookies(10)))\n          .concat(Source.maybe)\n\n      client.bake.invoke(input).map { output =>\n        val probe = output.runWith(TestSink.probe(server.actorSystem))\n        probe.request(10)\n        probe.expectNext(ReadyCookies(12))\n        probe.expectNext(ReadyCookies(12))\n        // because the oven is not full for the 6 other\n        probe.cancel\n        succeed\n      }\n    }\n  }\n}\n```"]