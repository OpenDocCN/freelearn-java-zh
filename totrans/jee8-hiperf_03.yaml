- en: Monitor Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控您的应用程序
- en: When it comes to an application's performance, you will quickly need to know
    what your application does and get the metrics of performance. In this chapter,
    we will identify a few ways to get insights on applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到应用程序的性能时，您很快就需要知道应用程序在做什么，并获取性能指标。在本章中，我们将介绍几种获取应用程序洞察的方法。
- en: 'Thus, in this chapter, we will learn how to monitor our application''s behavior
    in order to be able to compare it with the response times and execution times
    we observe. This will therefore show you the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习如何监控应用程序的行为，以便能够将其与我们观察到的响应时间和执行时间进行比较。因此，这将向您展示以下内容：
- en: How to add monitoring or profiling to an existing application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向现有应用程序添加监控或分析
- en: How to read important figures corresponding to the monitoring of an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取与应用程序监控相对应的重要数据
- en: How to ensure that the application performance is monitored and that any unexpected
    changes are visible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保应用程序性能得到监控，并且任何意外变化都是可见的
- en: Java tools to know what my application is doing
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java工具，了解我的应用程序在做什么
- en: 'Two critical factors are directly linked to performance when you take an application
    as a black box:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将应用程序视为黑盒时，有两个关键因素与性能直接相关：
- en: '**Memory usage**: If too much memory is consumed, it can slow down the application
    or even make it dysfunctional'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用**：如果消耗了过多的内存，它可能会减慢应用程序的速度，甚至使其无法正常工作'
- en: '**CPU time**: If an operation is too slow, it will consume a lot of CPU cycles
    and impact the overall performance'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU时间**：如果操作太慢，它将消耗大量的CPU周期，并影响整体性能'
- en: Without too much external tooling (except the **Java Development Kit** (**JDK**)
    and/or operating system tools), you can easily extract a lot of information and
    start working on the performance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用太多外部工具（除了**Java开发工具包**（**JDK**）和/或操作系统工具）的情况下，您可以轻松地提取大量信息并开始性能分析工作。
- en: The jcmd command – the small command line utility that does a lot
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jcmd命令——这个小巧的命令行实用工具功能强大
- en: Since Java 8, the JDK has been coming with the `jcmd` command, which allows
    you to execute commands on a local Java instance using the same user/group as
    the instance you want to check.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，JDK已经附带`jcmd`命令，该命令允许您使用与您要检查的实例相同的用户/组在本地Java实例上执行命令。
- en: 'The usage of `jcmd`, although command-based, is quite simple. To understand
    it, we will first start our quote manager application with the command we saw
    in [Chapter 1](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml), *Money – The Quote
    Manager Application*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`jcmd`的使用，尽管基于命令，但相当简单。为了理解它，我们首先将使用我们在[第1章](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml)中看到的命令启动我们的报价管理器应用程序，*Money
    – The Quote Manager Application*：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now in another console, just execute `jcmd`. On my system, it will dump what
    follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个控制台中，只需执行`jcmd`。在我的系统中，它将输出以下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first column is the **process ID** (**PID**) of the program and what follows
    is the launching command (main and parameters). Since we launched our server with
    maven, we can identify it with the maven main (`org.codehaus.plexus.classworlds.launcher.Launcher`)
    or with the parameters that exactly match the command we launched (`clean package
    embedded-glassfish:run`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是程序的**进程ID**（**PID**），接下来是启动命令（主命令和参数）。由于我们使用maven启动了服务器，我们可以通过maven主命令（`org.codehaus.plexus.classworlds.launcher.Launcher`）或与我们所启动的命令完全匹配的参数（`clean
    package embedded-glassfish:run`）来识别它。
- en: 'If you launch a standalone GlassFish, you will probably have a line like the
    following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启动一个独立的GlassFish，您可能会看到以下类似的行：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This one is pretty verbose but you can identify that the main (first string)
    references `glassfish` and you can find the domains directory to distinguish between
    multiple instances.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出相当详细，但您可以识别出主要（第一个字符串）引用了`glassfish`，并且您可以找到domains目录来区分多个实例。
- en: 'To just give you another idea, if you use Apache Tomcat or TomEE, you will
    identify it with this line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了给您另一个想法，如果您使用Apache Tomcat或TomEE，您将使用以下行来识别它：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we have the PID of our Java process; we can pass it to `jcmd`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了我们的Java进程的PID；我们可以将其传递给`jcmd`：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, for our previous maven GlassFish instance, it will look like the
    following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们之前的maven GlassFish实例，它看起来如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should look like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来如下所示：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the output is basically a list of commands that you can invoke
    using `jcmd`. A lot of these commands are informative, such as `VM.version` (which
    will just log which JVM you are using), but some commands are actual actions,
    such as `GC.run` (which will call `System.gc()`). Concerning the performance,
    we are interested in `Thread.print`, which is a replacement of `jstack`. GC data
    commands, such as `GC.class_histogram`, are related to the garbage collection
    data, while the `JFR` commands are related to **Java Flight Recorder**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出基本上是一个你可以使用`jcmd`调用的命令列表。其中许多命令是信息性的，例如`VM.version`（这将仅记录你正在使用的JVM），但有些命令是实际的操作，例如`GC.run`（这将调用`System.gc()`）。关于性能，我们感兴趣的是`Thread.print`，这是`jstack`的替代品。GC数据命令，如`GC.class_histogram`，与垃圾收集数据相关，而`JFR`命令与**Java飞行记录器**相关。
- en: Let's start with the most basic but also probably the most important command: `Thread.print`.
    This will allow us to see what our application is doing by digging into the *current* thread
    stack of our application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本但也许也是最重要的命令开始：`Thread.print`。这将允许我们通过挖掘应用程序的*当前*线程堆栈来了解应用程序正在做什么。
- en: Thread.print
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thread.print
- en: 'If you execute the `Thread.print` command, the output will look like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`Thread.print`命令，输出将看起来像以下内容：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since reproducing the full output of this command will take the entire chapter,
    it has been replaced by a skeleton of sorts of the thread stacks. What is important
    here is to identify that each block starting with a line that has quotes is a
    thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重现这个命令的完整输出将占用整个章节，它已经被某种形式的线程堆栈的骨架所取代。这里重要的是要识别出每个以引号开头的行开始的块是一个线程。
- en: 'Therefore, the dump repeats this pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，转储重复了这个模式：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the server is idle—that is, when it is not serving any request or executing
    any scheduled tasks—we can identify that most of the threads are just waiting
    for a task (in thread pools):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器空闲时——也就是说，当它没有处理任何请求或执行任何计划中的任务时——我们可以确定大多数线程只是在等待一个任务（在线程池中）：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To understand this dump, you will need to know how `ExecutorService` works.
    It basically creates threads with tasks called *Workers*, and each work can take
    some tasks from a queue (to simplify things). Here we can see the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个转储，你需要了解`ExecutorService`是如何工作的。它基本上是通过创建带有任务称为*Workers*的线程来实现的，每个工作可以从队列中获取一些任务（为了简化问题）。在这里我们可以看到以下内容：
- en: '`ThreadPoolExecutor$Work`, which means that we are in a thread pool task handler'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor$Work`，这意味着我们处于线程池任务处理器中'
- en: '`LinkedBlockingQueue.take`, which means that the thread is waiting for a new
    task'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingQueue.take`，这意味着线程正在等待一个新任务'
- en: 'We can also identify in this dump some incoming requests in the I/O layer,
    such as waiting for a socket to connect to an NIO `Selector`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这个转储中识别到I/O层的一些传入请求，例如等待一个套接字连接到NIO `Selector`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An important line here is either `epollWait` (if you are familiar with OS natives)
    or `Selector*.select` (if you are more familiar with the Java side of the code,
    which means it is waiting for a connection).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的一行是`epollWait`（如果你熟悉操作系统原生）或者`Selector*.select`（如果你更熟悉Java代码的Java端，这意味着它在等待一个连接）。
- en: 'Now, if we inject some requests into our application (let''s just use Apache
    Bench or **AB** to undertake some `GET` requests on our `findById` endpoint),
    we can see some threads that are actually working. (Note that because of its length
    and to avoid having several pages of thread stacktrace, the `[...]` have been
    shortened):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们向我们的应用程序注入一些请求（让我们使用Apache Bench或**AB**来对我们的`findById`端点执行一些`GET`请求），我们可以看到一些实际上正在工作的线程。（注意，由于长度较长，为了避免有多个页面的线程堆栈跟踪，`[...]`已被缩短）：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are other kinds of thread stacks but this one is particularly interesting,
    as we can identify most of our endpoint stacks. Keep in mind that we are calling
    a JAX-RS endpoint that calls JPA to find a quote that will rely on `DataSource`
    to connect to the current database. We can identify the JAX-RS layer with `org.glassfish.jersey
    lines`, the JPA layer with the `org.eclipse.persistence` lines, our application
    with our own package (`com.github.rmannibucau`, in this example), and the datasource
    connection retrieval with the `ConnectionManager` lines. We can also identify
    that Jersey (JAX-RS implementation of GlassFish) is deployed over Tomcat, thanks
    to the `org.apache.catalina` packages (but only for the application pipeline management)
    and Grizzly for I/O handling (`org.glassfish.grizzly` packages).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他类型的线程堆栈，但这个尤其有趣，因为我们能识别出我们的大多数端点堆栈。记住，我们正在调用一个 JAX-RS 端点，该端点调用 JPA 以查找一个将依赖于
    `DataSource` 连接到当前数据库的报价。我们可以用 `org.glassfish.jersey lines` 识别 JAX-RS 层，用 `org.eclipse.persistence`
    lines 识别 JPA 层，用我们自己的包（在这个例子中是 `com.github.rmannibucau`）识别我们的应用程序，以及用 `ConnectionManager`
    lines 识别数据源连接检索。我们还可以确定 Jersey（GlassFish 的 JAX-RS 实现）部署在 Tomcat 上，这要归功于 `org.apache.catalina`
    包（但仅限于应用程序管道管理）和 Grizzly 用于 I/O 处理（`org.glassfish.grizzly` 包）。
- en: 'This analysis is interesting as it shows something you need to take care of
    in Java EE: Java EE defines APIs but the runtime actually runs implementations.
    You rarely see `javax.*` entries in thread dumps, so you may need to check which
    implementations your server uses to make your analysis easier and faster.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这项分析很有趣，因为它显示了你在 Java EE 中需要注意的事情：Java EE 定义了 API，但运行时实际上运行的是实现。你很少在线程转储中看到
    `javax.*` 条目，所以你可能需要检查你的服务器使用的是哪个实现，以便使你的分析更容易、更快。
- en: Now the question is, can we conclude anything about this stack? Yes, of course!
    We can conclude that our application goes through the stack we expected. However,
    in terms of the performance, it doesn't mean anything. What will be impacting
    is how often you see the same stack being called. Concretely, if you see 30 threads
    over 100 waiting in a particular call, it may mean that this is a good place to
    optimize. If the stack even adds BLOCKED next to the line, it means that you need
    to ensure it is normal for the application to lock here and, maybe, change something
    (either the code or the configuration).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们能从这个堆栈中得出什么结论吗？是的，当然可以！我们可以得出结论，我们的应用程序通过了我们预期的堆栈。然而，从性能的角度来看，这并不意味着什么。影响的是你看到相同堆栈被调用的频率。具体来说，如果你看到在特定调用中有
    30 个线程在 100 个线程中等待，这可能意味着这是一个优化的好地方。如果堆栈甚至在该行旁边添加了 BLOCKED，这意味着你需要确保应用程序在这里锁定是正常的，也许需要改变一些东西（无论是代码还是配置）。
- en: 'Before going on to the next section, keep in mind that you can get the same
    kind of output in multiple ways. The `jstack` tool is another Java tool that you
    can use for doing more or less the same thing, but an interesting tip is to use
    Linux (or Windows) native tools to get exactly the same information. If you have
    JRE (Java without the development tools) instead of JDK, here is how to do it
    on Linux:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，请记住，你可以用多种方式获得相同类型的输出。`jstack` 工具是另一个你可以用来做更多或更少相同事情的 Java 工具，但一个有趣的提示是使用
    Linux（或 Windows）的本地工具来获取确切的信息。如果你有 JRE（没有开发工具的 Java）而不是 JDK，以下是如何在 Linux 上操作的：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Memory
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: The `GC.class_histogram` command allows you to get a heap histogram. We will
    deal with this in the coming sections. But just to sum up very quickly, the heap
    is where most of your Java objects will go. Therefore, it is important to see
    how it is used.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC.class_histogram` 命令允许你获取堆直方图。我们将在接下来的章节中处理这个问题。但为了快速总结，堆是大多数 Java 对象将去的地方。因此，了解它是如何被使用的是很重要的。'
- en: 'If we execute the `GC.class_histogram` command in our process, the output will
    look as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们的进程中执行 `GC.class_histogram` 命令，输出将如下所示：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here again, it is a partial output (truncated in multiple places) since it
    is too verbose for this book. If we find most of the environments we know, it
    is important to notice the following things:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它是一个部分输出（在多个地方被截断），因为对于这本书来说太冗长了。如果我们发现我们了解的大多数环境，那么注意以下事项是很重要的：
- en: '`com.mysql` for the JDBC driver our application uses'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.mysql` 是我们应用程序使用的 JDBC 驱动程序'
- en: '`com.github.rmannibucau` for our application (the quote entity in particular)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.github.rmannibucau` 是我们的应用程序（特别是报价实体）'
- en: '`com.sun.enterprise` for the GlassFish server'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.enterprise` 是用于 GlassFish 服务器的'
- en: '`org.jboss.weld` for the CDI container of GlassFish'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.jboss.weld` 是 GlassFish 的 CDI 容器'
- en: '`org.hibernate.validator` for the GlassFish bean validation implementation'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.hibernate.validator` 是用于 GlassFish 实现的 Bean 验证'
- en: '`sun`, `com.sun`, `java`, and so on for the JVM'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun`、`com.sun`、`java`等JVM相关'
- en: Now, an important thing is to be able to interpret these figures. The first
    column is not very important but the next two are. As written in the table header,
    they represent the number of instances and their size in bytes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个重要的事情是能够解释这些数据。第一列不是很重要，但接下来的两列是。如表格标题所述，它们代表实例的数量及其字节大小。
- en: 'If you run several concurrent requests on your server and filter the output
    for your quote entity, you can see the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时在你的服务器上运行多个并发请求，并过滤输出以查看你的引用实体，你可以看到以下内容：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This line means that the heap currently has 591 instances of `Quote` and it
    takes 42,552 bytes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这行意味着当前堆中有591个`Quote`实例，占用42,552字节。
- en: This means that it is a statistic you can check in real time while the server
    is running. But as it is written in the command help, it impacts the server (slows
    it down), so you need to use it for tuning purposes only.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这是一个可以在服务器运行时实时检查的统计信息。但正如命令帮助中所述，它会影响服务器（减慢其速度），因此你只能用于调整目的。
- en: The last interesting figure of the `GC.class_histogram` command is the total
    size of the heap, which is the last number printed. In our previous output, it
    was 61,027,800 bytes (about 61 MB).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC.class_histogram`命令的最后有趣的数字是堆的总大小，这是最后打印的数字。在我们的前一个输出中，它是61,027,800字节（大约61
    MB）。'
- en: JVisualVM – the UI for JVM monitoring
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVisualVM – JVM监控的UI界面
- en: The `jcmd` command is a great command-line tool but is a bit raw. However, the
    JVM provides additional tooling to yield metrics linked to performance and, in
    particular, the CPU and memory. `JVisualVM` and `JConsole` are two such tools
    packaged with the JDK (not the JRE). Since both are pretty similar, we will only
    deal with `JVisualVM` in this section, but most of the information and tools can
    be used with `JConsole` as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`jcmd`命令是一个优秀的命令行工具，但有点原始。然而，JVM提供了额外的工具来提供与性能相关的度量，特别是CPU和内存。`JVisualVM`和`JConsole`是两个包含在JDK（不是JRE）中的工具。由于两者非常相似，我们本节只处理`JVisualVM`，但大部分信息和工具也可以与`JConsole`一起使用。'
- en: 'To launch `JVisualVM`, you just have to execute a command of the same name:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`JVisualVM`，你只需要执行同名的命令：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once launched, you will see the welcome screen of `jvisualvm`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，你将看到`jvisualvm`的欢迎屏幕：
- en: '![](img/d7a26942-48ca-4a2f-b280-6b95d6291fae.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7a26942-48ca-4a2f-b280-6b95d6291fae.png)'
- en: 'To start using `jvisualvm`, you will need to select a JVM. This is done through
    the tree on the left-hand side of the screen. The two options are Local and Remote.
    In this case, we''ll run the server on our local machine, so it is automatically
    detected by `jvisualvm` (just ensure to start it from the same JDK as the one
    the server is using). In the previous screenshot, you can see three processes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`jvisualvm`，你需要选择一个JVM。这是通过屏幕左侧的树来完成的。有两个选项：本地和远程。在这种情况下，我们将在本地机器上运行服务器，因此它会被`jvisualvm`自动检测（只需确保从与服务器使用相同JDK的JDK启动它）。在前一个屏幕截图中，你可以看到三个进程：
- en: '`VisualVM`: This is a Java process and detects itself.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisualVM`：这是一个Java进程，并会自动检测自己。'
- en: '`GlassFish`: This is a standalone GlassFish server.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlassFish`：这是一个独立的GlassFish服务器。'
- en: '`org.codehaus.plexus.classworlds.launcher.Launcher`: This is a maven process.
    If you start GlassFish with maven, as we saw in [Chapter 1](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml), *Money
    – The Quote Manager Application*, this is the process to choose.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.codehaus.plexus.classworlds.launcher.Launcher`：这是一个maven进程。如果你使用maven启动GlassFish，正如我们在[第1章](f8931396-0636-41a9-8bf7-2b67bb424b76.xhtml)“货币
    – 引用管理应用”中看到的，这是需要选择的过程。'
- en: 'Once you have identified your process in the list, you need to double-click
    on it and you will get the following screen showing high-level information about
    the process:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在列表中识别出你的进程，你需要双击它，你将看到以下屏幕，显示关于进程的高级信息：
- en: '![](img/7ea6385a-b6ba-40fb-b27a-d48215f06c26.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ea6385a-b6ba-40fb-b27a-d48215f06c26.png)'
- en: 'Once you have selected a JVM on the left, the right pane will show information
    about the JVM. It is organized in tabs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在左侧选择了JVM，右侧窗格将显示关于JVM的信息。它组织在标签页中：
- en: 'Overview: This gives high-level information about the JVM (process ID, main
    class, arguments, Java version, system properties, and so on).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概览：这提供了关于JVM（进程ID、主类、参数、Java版本、系统属性等）的高级信息。
- en: 'Monitor: This gives an overview of the CPU usage, the memory usage (in particular,
    the heap), the number of classes loaded, and the number of threads.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控：这提供了CPU使用率、内存使用率（特别是堆）、加载的类数量和线程数量的概述。
- en: 'Threads: This gives a live view of the existing threads managed by the JVM
    and shows the thread state over time (whether it is idled or active). Here is
    a screenshot:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：这提供了JVM管理的现有线程的实时视图，并显示了线程状态随时间的变化（是否空闲或活跃）。以下是截图：
- en: '![](img/aaa560d5-7b79-43dc-ad75-58df9d02a6a5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaa560d5-7b79-43dc-ad75-58df9d02a6a5.png)'
- en: The legend is in the bottom-right corner and uses colors to help this view to
    be readable: green for running, purple for sleeping, yellow for wait, red for
    fork, and orange for monitor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇故事位于右下角，并使用颜色帮助此视图可读：绿色代表运行，紫色代表睡眠，黄色代表等待，红色代表分叉，橙色代表监控。
- en: What is interesting are the green blocks. This is when a thread does something.
    If you take the http-listener(x) threads for instance, you can see that they are
    orange and green. The orange part is when the threads are waiting for requests
    and the green part is when they are serving something. This view must be coupled
    with the thread dumps (or thread stack view) to ensure that the waiting threads
    are actually waiting for something relevant (such as waiting for some I/O), which
    the application does not control.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是绿色块。这是线程正在执行某事的时候。以http-listener(x)线程为例，你可以看到它们是橙色和绿色的。橙色部分是线程等待请求的时候，绿色部分是它们在提供服务的时候。这个视图必须与线程转储（或线程堆栈视图）结合使用，以确保等待的线程实际上正在等待某些相关的事情（例如等待某些I/O），这是应用程序无法控制的。
- en: 'Sampler: This tab is very interesting and allows you to capture what the server
    is doing in terms of CPU and memory. We find some information that we had with
    `jcmd`, but this is easier to use. All you need to do is to click on the CPU or
    Memory button and `jvisualvm` will start capturing the related information. Here
    is the memory view that you will get once some samples have been captured:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本采集器：这个标签非常有趣，允许你捕获服务器在CPU和内存方面的操作。我们发现了一些与`jcmd`相关的信息，但使用起来更简单。你只需要点击CPU或内存按钮，`jvisualvm`就会开始捕获相关信息。以下是捕获一些样本后你将得到的内存视图：
- en: '![](img/9a972a09-dc1f-46ae-a3a8-57e670c2de75.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a972a09-dc1f-46ae-a3a8-57e670c2de75.png)'
- en: This view is really close to the GC histogram command of `jcmd`; you'll find
    the class name, the corresponding size in bytes, and the number of instances.
    You can filter the visible classes at the bottom using any pattern related to
    your application; in this screenshot, we filtered by Quote.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图非常接近`jcmd`的GC直方图命令；你将找到类名、相应的字节数和实例数。你可以使用与你的应用程序相关的任何模式在底部过滤可见的类；在这个截图中，我们通过Quote进行了过滤。
- en: 'If you capture some CPU samples, the view is centered on the methods and their
    execution time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你捕获了一些CPU样本，视图将集中在方法和它们的执行时间上：
- en: '![](img/6b32bad0-b22b-4ecd-81ba-b667df2bf656.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b32bad0-b22b-4ecd-81ba-b667df2bf656.png)'
- en: The first column is the method identifier and the other columns show the corresponding
    time for the respective methods. Self Time is the time of the method itself. Self
    Time (CPU) is the same but ignores waiting time (locks and so on). Same goes for
    the Total Time columns. What is the main difference between the Self Time and
    the Total Time columns? The Total Time columns include further method calls, which
    the Self Time columns don't.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是方法标识符，其他列显示了相应方法的对应时间。Self Time是方法本身的时间。Self Time (CPU)与Self Time相同，但忽略了等待时间（锁等）。同样适用于Total
    Time列。Self Time列和Total Time列之间主要区别是什么？Total Time列包括进一步的方法调用，而Self Time列不包括。
- en: While on the CPU view, you can click on Thread Dump to get a thread dump, the
    same as for `jcmd` but it is directly accessible in `jvisualvm`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在CPU视图上时，你可以点击线程转储来获取线程转储，与`jcmd`相同，但它在`jvisualvm`中直接可访问。
- en: 'Profiler: This is the last tab of the JVM view and provides more or less the
    same view as the Sampler tab. The main difference is the way it captures the data.
    Don''t worry if the time between your click and the first data you can see is
    quite long in Profiler. While the Sampler tab just takes a *screenshot* of the
    JVM (memory or thread stacks) from time to time and generates approximate statistics
    from them, the Profiler tab modifies the classes (actual bytecode) to capture
    accurate data. This implies that the sampling overhead is not very huge but the
    profiling overhead can be if it affects all the codebase, including the fast methods
    (which are instrumented by default). If you want precise metrics, you will need
    to use the profiler, but it is recommended that you hit the Settings checkbox
    to precisely tune which classes you want to get the metrics for and not let the
    defaults, which are too wide to not affect the system.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器：这是JVM视图的最后一个选项卡，提供与采样选项卡大致相同的视图。主要区别在于它捕获数据的方式。如果你在分析器中点击和看到第一份数据之间的时间相当长，请不要担心。而采样选项卡只是定期从JVM（内存或线程堆栈）中获取*快照*并从中生成近似统计，分析器选项卡则修改类（实际字节码）以捕获准确数据。这意味着采样开销不是很大，但如果它影响到整个代码库，包括快速方法（默认情况下都会进行仪器化），则分析开销可能会很大。如果你想获得精确的度量，你需要使用分析器，但建议你勾选设置复选框，精确调整你想要获取度量信息的类，而不是使用默认设置，因为默认设置范围太广，可能会影响系统。
- en: How to connect remotely
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何远程连接
- en: Connecting locally is easy since `jvisualvm` will just locally look up the running
    JVM. But for connecting remotely, you will need some more setup.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本地连接很简单，因为`jvisualvm`只需本地查找正在运行的JVM。但为了远程连接，你需要做一些额外的设置。
- en: All the communication relies on JMX and, therefore, you need to set up a remote
    JMX connection. This relies on what is called a connector (can be seen as a small
    embedded JMX server). There are multiple protocols available but out of the box;
    they rely on RMI communications and system properties to be configured.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通信都依赖于JMX，因此你需要设置一个远程JMX连接。这依赖于所谓的连接器（可以看作是一个小型嵌入式JMX服务器）。有多种协议可用，但默认情况下，它们依赖于RMI通信和系统属性的配置。
- en: 'To add these system properties, the fastest and easiest way is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些系统属性，最快和最简单的方法如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It will enable JMX on port 1234 and disable SSL and security. For performances,
    we don't need more, but if you want to keep it in production, you may need to
    configure the security and SSL. For more details on how to do so, you can refer
    to the Oracle website at [https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html](https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在1234端口上启用JMX并禁用SSL和安全功能。为了性能，我们不需要更多，但如果你想在生产环境中使用它，你可能需要配置安全和SSL。有关如何操作的更多详细信息，你可以参考Oracle网站上的[https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html](https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html)。
- en: Once this is configured, you just have to right-click on the Local item in the
    tree on the left side, select Add JMX Connection, and fill in the related information
    (host/port and the potential credentials if you've configured the security).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，你只需在左侧树中的本地项上右键单击，选择添加JMX连接，并填写相关信息（主机/端口以及如果你已配置安全性的潜在凭证）。
- en: Java Mission Control
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java Mission Control
- en: Since Java 7u40, the JDK has included the Java Flight Recorder tool. If you
    remember the available commands in `jcmd`, you had some `JFR.*` options, which
    are directly related to this tool. It allows you to capture a set of JVM events.
    It is coupled with **Java Mission Control** (**JMC**), which enables you to analyze
    and exploit the JVM events.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java 7u40版本起，JDK已经包含了Java飞行记录器工具。如果你记得`jcmd`中可用的命令，你有一些`JFR.*`选项，这些选项与这个工具直接相关。它允许你捕获一组JVM事件。它与**Java
    Mission Control**（**JMC**）结合使用，使你能够分析和利用JVM事件。
- en: 'Launching it is easy:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 启动它很简单：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once it is launched, you''ll get a welcome screen; the view looks similar to
    the `jvisualvm` view, with a list of the available processes on the left-hand
    side:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，你将看到一个欢迎屏幕；视图看起来与`jvisualvm`视图相似，左侧列出了可用的进程：
- en: '![](img/88479a83-56f5-41db-91d6-ac8e0c6883f4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88479a83-56f5-41db-91d6-ac8e0c6883f4.png)'
- en: You can use the same kind of hints as for `jvisualvm` to identify the process. If
    you are not quite sure, don't hesitate to use the `jps -v` command, which will
    show you the command line and its PID for each running JVM (which will allow you
    to identify the number in parentheses in JMC).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与`jvisualvm`相同的提示来识别进程。如果您不太确定，请不要犹豫，使用`jps -v`命令，它将显示每个正在运行的JVM的命令行及其PID（这将允许您在JMC中识别括号中的数字）。
- en: 'Once you''ve identified your process, you can right-click on it and select
    the Start JMX console to have a view similar to `jvisualvm` and specific to the
    selected JVM:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已识别出您的进程，您可以右键单击它并选择“启动JMX控制台”，以获得类似于`jvisualvm`且针对所选JVM的视图：
- en: '![](img/eb6fd349-8bd8-410e-a755-1a0333595293.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb6fd349-8bd8-410e-a755-1a0333595293.png)'
- en: You find the CPU (processor here), the memory, and thread information, and also
    the MBean view, which is how the JVM can export the internal data in a standard
    manner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到CPU（处理器）、内存和线程信息，以及MBean视图，这是JVM以标准方式导出内部数据的方式。
- en: 'One interesting thing is when you go to the Diagnostic Commands tab you will
    recognize the `jcmd` commands listed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事情是当您转到“诊断命令”选项卡时，您将认出列出的`jcmd`命令：
- en: '![](img/90602a7e-d088-4c1f-951d-74ce83713c37.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90602a7e-d088-4c1f-951d-74ce83713c37.png)'
- en: This pane allows you to execute the `jcmd` commands directly from the UI. Here,
    we are interested in the **Java Flight Recorder** (**JFR**) commands, as we want
    more information about our JVM.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板允许您直接从UI执行`jcmd`命令。在这里，我们感兴趣的是**Java飞行记录器**（**JFR**）命令，因为我们想获取更多关于我们的JVM的信息。
- en: 'In the previous screenshot, you may have noted that there is a Flight Recorder
    item on the left tree. It provides a UI for these commands. However, if you hit
    Start Recording, you will get the following error:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可能已经注意到左侧树中有一个飞行记录器项。它为这些命令提供了一个用户界面。然而，如果您点击“开始录音”，您将得到以下错误：
- en: '![](img/43cd46f7-8ad2-4d86-958f-727a669504d1.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43cd46f7-8ad2-4d86-958f-727a669504d1.png)'
- en: 'To use Java Flight Recorder, you need to add the following options to your
    JVM:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Java飞行记录器，您需要将以下选项添加到您的JVM中：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These two options will activate the Java Flight Recorder features. To add them
    to GlassFish, you can edit the `$GLASSFISH_HOME/glassfish/domains/domain1/config/domain.xml`
    file and add it to the `java-config` block after `jvm-options`. Alternatively,
    you can use the `create-jvm-options` command line's `glassfish` command. In any
    case, you will need to restart (or start) your server after this modification.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项将激活Java飞行记录器功能。要将它们添加到GlassFish中，您可以编辑`$GLASSFISH_HOME/glassfish/domains/domain1/config/domain.xml`文件，并在`jvm-options`之后将其添加到`java-config`块中。或者，您可以使用`create-jvm-options`命令行的`glassfish`命令。无论如何，您都需要在此修改后重新启动（或启动）您的服务器。
- en: 'If you want to test it using our maven GlassFish, you can just add them to
    `MAVEN_OPTS`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用我们的maven GlassFish进行测试，您只需将它们添加到`MAVEN_OPTS`：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now the options are activated on the JVM; you can go back to Java Mission Control
    and hit Start Recording on the Start Flight Recorder item. It will ask you a file
    location to store the recording and either a duration or a limit (size/age) for
    the recording. Finally, you can select whether you want to profile your server
    or just to monitor it. Here again, the difference is in the associated overhead.
    Let's select profiling for now. You can then hit Next and select what you want
    to monitor. An important parameter is the heap one, but if you continue through
    the wizard, you will see that you can precisely customize what you monitor, including
    the I/O. Once everything is well configured, simply hit Finish. It will proceed
    with the recording and open it once done.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选项已在JVM上激活；您可以返回Java任务控制台，在“启动飞行记录器”项上点击开始录音。它将询问您存储录音的文件位置以及录音的时长或限制（大小/年龄）。最后，您可以选择是否要分析您的服务器或只是监控它。在这里，差异在于相关的开销。现在让我们选择分析。然后您可以点击“下一步”并选择您想要监控的内容。一个重要的参数是堆参数，但如果您继续通过向导，您将看到您可以精确地自定义您要监控的内容，包括I/O。一旦一切配置妥当，只需点击“完成”。它将开始录音并在完成后打开。
- en: For the first time, select 1 min as the recording duration; it will prevent
    you from waiting for too long.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首次使用时，请选择1分钟作为录音时长；这将避免您等待过长时间。
- en: 'After the recording is done, you should get a view similar to the following
    one, showing the captured data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 录音完成后，您应该得到一个类似于以下视图的视图，显示捕获的数据：
- en: '![](img/2c39e00f-0dbb-4552-b92d-c6da0799d962.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c39e00f-0dbb-4552-b92d-c6da0799d962.png)'
- en: Looking at the top, we can see the event timeline. You can click on it to refine
    the time-slot selection. The counters show the summary of the capture in terms
    of memory and CPU. Finally, at the bottom, you have the CPU and memory graph.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部看，我们可以看到事件时间线。您可以点击它来细化时间选择。计数器显示了内存和CPU捕获的摘要。最后，在底部，您有CPU和内存图。
- en: 'What makes this tool more advanced than the previous one is the fact that you
    can visualize the code hotspot in the Code tab (the tabs are on the left in this
    tool) and the I/O in a single tool. The in-built JDK also makes it quite easy
    to use, whereas the overhead is not as important (if you select continuous monitoring,
    a counterpart is that the statistics won''t be very accurate but close enough
    so as to give you an idea). A major strength of this tool is the Call Tree view
    of the Code tab. It allows you to associate, through a stack, the method execution
    time cost with the method calls. For instance, while the server was running, this
    capture shows that the cost of our `findAll` method is mainly related to the way
    we are mapping each quote that requires using the JPA layer (eclipselink) and
    the database:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个工具比之前的工具更先进的是，您可以在代码标签页（在这个工具中标签位于左侧）中可视化代码热点，并在单个工具中查看I/O。内置的JDK也使得使用它相当容易，而开销并不重要（如果您选择连续监视，一个对应的是统计信息可能不会非常准确，但足够接近，以便给您一个大致的概念）。这个工具的一个主要优势是代码标签页的调用树视图。它允许您通过堆栈将方法执行时间成本与方法调用关联起来。例如，当服务器运行时，这个捕获显示我们的`findAll`方法成本主要与我们将每个报价映射的方式有关，这需要使用JPA层（eclipselink）和数据库：
- en: '![](img/a5185f39-2577-4661-8380-12f600d29bba.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5185f39-2577-4661-8380-12f600d29bba.png)'
- en: This view is a really great way to investigate the hotspots of the application.
    It kind of merges the thread dumps and the profiling views (sometimes called *Path
    Tracking*) and enables you to get directly to the costly operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图是调查应用程序热点的一种真正很好的方式。它有点将线程转储和性能视图（有时称为*路径跟踪*）合并在一起，并允许您直接访问成本较高的操作。
- en: GlassFish ad hoc monitoring
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlassFish临时监视
- en: Many servers have inbuilt monitoring capabilities. This depends highly on the
    server, but it can give some interesting insights without having to use another
    tool. This is precious when you don't control the machine or don't have the permissions
    to access/configure the server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务器都有内置的监视功能。这高度取决于服务器，但它可以在不使用其他工具的情况下提供一些有趣的见解。当您无法控制机器或没有权限访问/配置服务器时，这非常宝贵。
- en: 'To illustrate this kind of monitoring, let''s use our Java EE reference implementation:
    GlassFish.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种监视，让我们使用我们的Java EE参考实现：GlassFish。
- en: 'Once started with the normal `./bin/asadmin start-domain` command, you can
    activate monitoring with this additional command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用正常的`./bin/asadmin start-domain`命令启动，您可以使用此附加命令激活监视：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Indeed, there is a symmetric command if you want to deactivate monitoring:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想禁用监视，确实有一个对称的命令：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can list the monitors available with the `get` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`get`命令列出可用的监视器：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This output shows that the Jersey monitoring level is `HIGH` but other ones
    are disabled (`OFF`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示，Jersey的监视级别为`HIGH`，但其他监视器处于禁用状态（`OFF`）。
- en: 'An alternative is to use the administration UI (by default on `http://localhost:4848`,
    for a standalone installation). Going to your configuration part on the left tree,
    you will have a Monitoring item where you can access the exact same entries:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用管理UI（默认情况下在`http://localhost:4848`，对于独立安装）。转到左侧树中的配置部分，您将有一个监视项，您可以访问相同的条目：
- en: '![](img/4e9ffa0f-3b31-410a-8722-aa4d3308a839.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e9ffa0f-3b31-410a-8722-aa4d3308a839.png)'
- en: Selecting the level you want on the left of the table for the corresponding
    module will activate the associated monitoring. Once the monitoring is activated,
    you'll generally need to restart the server to let GlassFish take it into account.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格左侧选择您想要的对应模块的级别将激活相关的监视。一旦监视被激活，通常需要重新启动服务器，以便GlassFish能够考虑它。
- en: 'Once it is done, you can access the associated information through the Monitoring
    Data item of the left tree:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以通过左侧树的监视数据项访问相关信息：
- en: '![](img/6d6d1771-f9b8-49be-80b4-9579ca0fae1c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d6d1771-f9b8-49be-80b4-9579ca0fae1c.png)'
- en: 'Here, you can see the monitored instances. (If you use a standalone GlassFish,
    you will probably have a single entry.) The View Monitoring Data column will let
    you select the data you want to see. If you click on Application, for instance,
    you will obtain the corresponding screen with the information filled in, depending
    on the monitoring level you activated before. Here is a sample screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看监控的实例。（如果您使用独立的GlassFish，您可能只有一个条目。）“查看监控数据”列将允许您选择您想要查看的数据。例如，如果您点击“应用程序”，您将获得相应的屏幕，其中填写了信息，具体取决于您之前激活的监控级别。以下是一个示例截图：
- en: '![](img/606466a5-ce14-4b6b-8fb7-200cf0cb782c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/606466a5-ce14-4b6b-8fb7-200cf0cb782c.png)'
- en: Depending on the application, this is more or less useful. However, for us (a
    JAX-RS service), the Request Statistics block is interesting even if it gives
    high-level information. We can use it to monitor the maximum response time and
    error count. By itself, it will not be enough to improve the performance, but
    it will enable us to compare it with the client-side information; we can then
    easily obtain and validate our performance testing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用的不同，这会有所不同。然而，对于我们（一个JAX-RS服务）来说，即使它只提供高级信息，请求统计块也是有趣的。我们可以用它来监控最大响应时间和错误计数。仅凭它本身，可能不足以提高性能，但它将使我们能够将其与客户端信息进行比较；然后我们可以轻松地获取和验证我们的性能测试。
- en: It is important to keep in mind that servers often give aggregated performance
    figures for recent production monitoring, not performance tuning. This doesn't
    mean that it is useless but that you will only rely on ad hoc monitoring to validate
    your performance measurement pipeline (your client or your request injector, to
    put it simply).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，服务器通常为最近的生产监控提供汇总的性能数据，而不是性能调整。这并不意味着它是无用的，而是您只能依靠临时的监控来验证您的性能测量管道（简单来说，就是您的客户端或请求注入器）。
- en: Libraries monitor your application
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库监控您的应用程序
- en: We saw what the JVM provides us with tools and what the server gives us performance
    hints, but there are a lot of libraries intended to help you work on the performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了JVM为我们提供的工具以及服务器给我们提供的性能提示，但还有很多库旨在帮助您提高性能。
- en: Counters, gauges, timers, and more
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器、仪表、计时器以及更多
- en: 'The most famous library is probably *Metrics* from Dropwizard ([http://metrics.dropwizard.io](http://metrics.dropwizard.io))
    but all libraries share more or less the same sort of API. The metrics are centered
    around a few important concepts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的库可能是来自Dropwizard的*Metrics*（[http://metrics.dropwizard.io](http://metrics.dropwizard.io)），但所有库都共享更多或更少的相同类型的API。度量值围绕几个重要概念展开：
- en: '**Gauges**: These provide the measure of a value at a certain time. They are
    intended to build a time series. Most famous examples are the CPU or memory usages.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：这些提供了在特定时间点的值度量。它们旨在构建时间序列。最著名的例子是CPU或内存使用情况。'
- en: '**Counters**: These are long values, often associated with a gauges in order
    to build time series.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：这些是长值，通常与仪表相关联，以构建时间序列。'
- en: '**Histogram**: This structure allows you to compute the statistics around a
    value, for instance, the mean or the percentiles of request lengths.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图**：这种结构允许您计算围绕值的统计信息，例如，请求长度的平均值或百分位数。'
- en: '**Timers**: These are a bit like histograms; they compute other metrics based
    on one metric. Here, the goal is to have information about the rate of a value.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器**：这些有点像直方图；它们基于一个度量值计算其他度量。在这里，目标是获取关于值速率的信息。'
- en: '**Health checks**: These are less related to the performance; they allows you
    to validate that a resource (such as a database) is working or not. Health checks
    throw a warning/error if the resource isn''t working.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：这些与性能关系不大；它们允许您验证资源（如数据库）是否正在运行。如果资源不工作，健康检查会抛出警告/错误。'
- en: All these libraries provide different ways to export/expose the collected data.
    Common configurations are related to JMX (through MBeans), Graphite, Elasticsearch,
    and so on, or just the console/logger as the output.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都提供了不同的方式来导出/公开收集到的数据。常见的配置与JMX（通过MBeans）、Graphite、Elasticsearch等相关，或者只是控制台/日志作为输出。
- en: How can these concepts be linked to the performance? The most important features
    for us will be the gauges and the counters. The gauges will enable us to make
    sure the server is doing well (for example, the CPU is not always at 100%, the
    memory is well released, and so on). The counters will enable us to measure the
    execution time. They will also enable us to export the data in an aggregated storage
    if you test against multiple instances, allowing you to detect some potential
    side effects of one instance on another one (if you have any clustering for example).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念如何与性能联系起来？对我们来说最重要的功能将是仪表和计数器。仪表将使我们能够确保服务器运行良好（例如，CPU 不总是达到 100%，内存得到良好释放等）。计数器将使我们能够衡量执行时间。它们还将使我们能够在针对多个实例进行测试时导出聚合存储中的数据，这样你就可以检测一个实例对另一个实例的潜在副作用（例如，如果你有任何聚类的话）。
- en: Concretely, we want to measure some important segments of our code. In the extreme
    case, if you don't know anything about the application, you will likely want to
    measure all parts of the code then refine it when you have more knowledge about
    your application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们希望衡量我们代码的一些重要部分。在极端情况下，如果你对应用程序一无所知，你可能会想要衡量代码的所有部分，然后在你对应用程序有更多了解时再对其进行细化。
- en: 'To be very concrete and illustrate what we are trying to achieve, we want to
    replace application methods by this kind of pattern:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了非常具体地说明我们试图实现的目标，我们希望用这种模式来替换应用程序方法：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In other words, we want to surround our business code with a timer to collect
    statistics about our execution time. One common and *poor man* solution you can
    be tempted to start with is to use loggers to do it. It often looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望用计时器包围我们的业务代码，以收集关于我们执行时间的统计数据。你可以尝试的一个常见且*简陋*的解决方案是使用日志记录器来完成。它通常看起来如下：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code manually measures the execution time of the method and, then,
    dumps the result with a description text in a specific logger to identify the
    code portion it is related to.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码手动测量方法的执行时间，然后，将带有描述性文本的结果输出到特定的日志记录器中，以识别与之相关的代码部分。
- en: In doing so, the issue you will encounter is that you will not get any statistics
    about what you measure and will need to preprocess all the data you collect, delaying
    the use of the metrics to identify the hotspots of your application and work on
    them. This may not seem like a big issue, but as you are likely to do it many
    times during a benchmark phase, you will not want to do it manually.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，你将遇到的问题是，你将无法获得任何关于你所衡量的统计数据，并且需要预处理你收集的所有数据，这将延迟使用指标来识别应用程序的热点并对其进行工作。这看起来可能不是一个大问题，但因为你很可能在基准测试阶段多次这样做，你将不希望手动进行。
- en: Then, the other issues are related to the fact that you need to add this sort
    of code in all the methods you want to measure. Thus, you will pollute your code
    with monitoring code, which is rarely worth it. It impacts even more if you add
    it temporarily to get metrics and remove it later. This means that you will try
    to avoid this kind of work as much as possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，其他问题都与这样一个事实有关，即你需要将此类代码添加到你想要衡量的所有方法中。因此，你会在代码中添加监控代码，这通常是不值得的。如果你只是临时添加它以获取指标并在之后移除，那么影响会更大。这意味着你将尽可能避免这种工作。
- en: The final issue is that you can miss the server or library (dependency) data,
    as you don't own this code. That means that you may spend hours and hours working
    on a code block that is, in fact, not the slowest one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是你可能会错过服务器或库（依赖）数据，因为你不拥有这段代码。这意味着你可能会花费数小时数小时地工作在一个代码块上，而这个代码块实际上并不是最慢的。
- en: Instrumenting the code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码仪表化
- en: The immediate question is *how do you instrument the code you want to measure
    without having to modify it?* The first goal is to avoid being too intrusive in
    the code and, also, to avoid affecting the entire application just for the duration
    of a benchmark. The second goal is to be able to *toggle* the instrumentation
    and to be able to deactivate it in order to measure the application without monitoring
    (particularly, if you put it everywhere) and ignore the associated overhead on
    the metrics you take.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 立即的问题是*如何在不修改代码的情况下对想要衡量的代码进行仪表化？* 第一个目标是避免在代码中过于侵入，同时也要避免为了基准测试的持续时间而影响整个应用程序。第二个目标是能够*切换*仪表化，并能够将其停用，以便在不进行监控的情况下测量应用程序（尤其是如果你将其放在每个地方），并忽略你获取的指标上的相关开销。
- en: 'Nowadays, in Java and Java EE state, you have several options to instrument
    the code. We will browse through most of them, but here is an overview of the
    choices you have:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java和Java EE状态下，您有几种方法可以对代码进行插装。我们将浏览其中大部分，但这里是对您所拥有的选择的概述：
- en: '**Choice 1 – manual**: In this solution, you wrap the instance you use with
    a *Factory* of the monitoring framework you rely on, and the returned instance
    is wrapped in a monitored proxy (new instance delegating to the original one).
    Concretely, it can look like the following:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择1 – 手动**：在这个解决方案中，您使用您所依赖的监控框架的*Factory*包装您使用的实例，返回的实例被包装在一个监控代理中（新实例委托给原始实例）。具体来说，它可以看起来像以下这样：'
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From what we talked about earlier, this has a drawback of impacting the code
    and limiting the instrumentation to the code you own (or can modify). However,
    the big advantage is that it is simple to integrate and works with any kind of
    code (managed by the EE container or not). Concretely, most of the monitoring
    libraries will have such a utility and often just use it internally in other kinds
    of integrations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前讨论的内容来看，这有一个缺点，即影响代码并限制插装仅限于您拥有的（或可以修改的）代码。然而，它的一个重大优势是它简单易集成，并且可以与任何类型的代码（由EE容器管理或不管理）一起工作。具体来说，大多数监控库都将拥有此类实用程序，并且通常在其他的集成中内部使用它。
- en: '**Choice 2 – through CDI (or the interceptor API)**: The Java EE standard way
    to *inject* logic into a service is to use an interceptor. We will detail how
    it works in a dedicated part but the overall idea is to flag a method as being
    monitored. Here again, the limitation will be to have access to the code you want
    to monitor through the CDI container. However, it is less impacting than the previous
    solution in terms of coding.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择2 – 通过CDI（或拦截器API）**：将逻辑注入到服务中的Java EE标准方式是使用拦截器。我们将在专门的部分详细说明它是如何工作的，但总体思路是将方法标记为被监控。在这里，限制将是您需要通过CDI容器访问您想要监控的代码。然而，在编码方面，它比前一种解决方案的影响要小。'
- en: If your application relies on Spring, the Spring framework has the same kind
    of tooling (referenced as *AOP* in their documentation). So, the same concept
    applies even if it is activated a bit differently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序依赖于Spring，Spring框架有相同类型的工具（在他们的文档中称为*AOP*）。因此，即使激活的方式略有不同，同样的概念也适用。
- en: '**Choice 3 – through a javaagent**: The javaagent is the most powerful way
    to instrument the code. The drawback is that you need to configure it directly
    on the JVM, while the good point is that you can monitor almost every class (except
    for a few of the JVM itself).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择3 – 通过javaagent**：javaagent是插装代码的最强大方式。缺点是您需要直接在JVM上配置它，而优点是您可以监控几乎所有的类（除了JVM本身的少数几个类）。'
- en: Some containers (such as Tomcat/TomEE for instance) allow you to configure `java.lang.instrument.ClassFileTransformer`. This
    will basically enable you to perform bytecode instrumentation at load time (dynamically).
    This allows you to benefit from almost the same power as that of a javaagent,
    except that you will not be able to instrument the container—and potentially,
    a part of the JVM—but only the classes of the application. However, it is still
    more powerful than CDI instrumentation as it sees all the classes of the application,
    not only the ones that the CDI processes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器（例如Tomcat/TomEE等）允许您配置`java.lang.instrument.ClassFileTransformer`。这基本上使您能够在加载时（动态地）执行字节码插装。这使得您能够享受到几乎与javaagent相同的强大功能，但您将无法对容器——以及可能的部分JVM——进行插装，而只能对应用程序的类进行插装。然而，它仍然比CDI插装更强大，因为它可以看到应用程序的所有类，而不仅仅是CDI处理的那些类。
- en: CDI instrumentation
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI插装
- en: 'If we focus back on the Metrics library, we will find several CDI integrations.
    The global idea is to decorate the code with some annotation and automatically
    get the metrics associated with the executed code. Clearly, it will impact your
    code this way (using [https://github.com/astefanutti/metrics-cdi](https://github.com/astefanutti/metrics-cdi)
    for instance):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次关注Metrics库，我们会发现几个CDI集成。全局的想法是在代码上装饰一些注解，并自动获取与执行代码关联的度量。显然，这种方式会影响您的代码（例如使用[https://github.com/astefanutti/metrics-cdi](https://github.com/astefanutti/metrics-cdi)）：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `@Timed` annotation will automatically wrap the method execution in a Metrics
    timer and will therefore provide the statistics about the execution time of the
    method. The relevant code of the interceptor associated with the `@Timed` annotation
    is very close to this logic:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Timed`注解将自动将方法执行包装在Metrics计时器中，因此将提供关于方法执行时间的统计信息。与`@Timed`注解关联的拦截器的相关代码非常接近以下逻辑：'
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is exactly what we want to achieve but it has one trap we didn''t think
    about yet: the exception handling. To understand this point, we can compare the
    code used in the retired project (called Apache Sirona), which had the following
    differently implemented feature:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要实现的目标，但它有一个我们还没有考虑到的陷阱：异常处理。为了理解这一点，我们可以比较在已退役的项目（称为Apache Sirona）中使用的代码，该项目具有以下不同实现的功能：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What is important to see here is that the code path changes in the case of
    an exception. In terms of statistics, this implies that failures will have a different
    marker from successful calls in the metrics report. This is important to notice
    because the execution time of a failure is rarely comparable to a success, even
    for simple methods. Let''s take a simple finder example from our quote manager
    application and observe this. Here is the line we will investigate:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是要注意，在异常的情况下代码路径会发生变化。从统计学的角度来看，这意味着失败将会有与成功调用不同的标记在指标报告中。这一点很重要，因为失败的执行时间很少与成功可比较，即使是对于简单的方法。让我们从一个简单的报价管理应用程序的查找示例中观察这一点。以下是我们要调查的行：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A normal call with a valid ID will be around 6 to 7 ms (on my reference machine,
    with my personal configuration). The `EntityManager#find` method can take any
    type for the identifier, so if we pass a wrong type (such as `String` instead
    of `long` ) then the call should compile and execute. Eclipselink will complain
    with an exception but the performance impact is something interesting: 0 ms! Indeed,
    this example is very extreme and is a bug, but if you have some rate limiting
    on an endpoint or some sanity checks at the beginning of the methods, the same
    impact can be observed.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正常的带有有效ID的调用大约在6到7毫秒（在我的参考机器上，使用我的个人配置）。`EntityManager#find`方法可以接受任何类型的标识符，因此如果我们传递错误类型（例如，`String`而不是`long`），那么调用应该编译并执行。Eclipselink会抛出异常，但性能影响是很有趣的：0毫秒！确实，这个例子非常极端，是一个错误，但如果你在端点上有一些速率限制或在方法开始时有一些合理性检查，你可能会观察到相同的影响。
- en: This means that if the framework you are using is putting all the invocations
    (with errors or not) in the same bucket, you can have a very good performance
    but a very slow application, since the average of the success/failure makes the
    figures look good.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你使用的框架将所有调用（无论是否有错误）放入同一个桶中，你可能会获得非常好的性能，但应用程序可能会非常慢，因为成功/失败的平均值使得数据看起来很好。
- en: Implementing your own configurable monitoring interceptor
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现你自己的可配置监控拦截器
- en: 'Implementing a CDI interceptor is not that complicated. Thus, you may want
    to have your own if you do not find a library matching your expectations. It can
    have two kinds of direct impact on the way you use monitoring:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实现CDI拦截器并不复杂。因此，如果你找不到符合你期望的库，你可能想自己实现。它可以从两个方面直接影响你使用监控的方式：
- en: Be able to control the counters you use depending on the case you are in. This
    includes success/failure handling, but it can also be tenant-related (if your
    application is handling multiple tenants). This can be very important if you do
    not use the exact same system as the tenant (one can have a slower database than
    the other, for instance).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够根据你所在的情况控制你使用的计数器。这包括成功/失败处理，但也可能是与租户相关的（如果你的应用程序正在处理多个租户）。如果你不使用与租户完全相同的系统（例如，一个可能比另一个慢的数据库），这可能非常重要。
- en: Be able to configure the monitored beans. Yes, with CDI you can also avoid having
    to decorate the beans you want to monitor and just do it automatically from a
    configuration.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够配置要监控的Bean。是的，使用CDI，你也可以避免装饰你想要监控的Bean，而是从配置中自动完成。
- en: 'The first step to create a CDI interceptor is to have what CDI calls *interceptor
    binding*. It is the annotation you will use on your beans that will mark the method
    as being monitored. Here is a simple one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CDI拦截器的第一步是拥有CDI所说的*拦截器绑定*。这是你将在你的Bean上使用的注解，它将标记方法为被监控。这里有一个简单的例子：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is a normal annotation that you can put in a method (or a class to mark all
    the methods as being monitored). The only particular thing is its `@InterceptorBinding`
    marker.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的注解，你可以将其放在方法中（或类中以标记所有方法为监控）。唯一特别的是它的`@InterceptorBinding`标记。
- en: 'Then, to link this interceptor bind to the actual interceptor implementation,
    you create an interceptor with the same annotation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要将这个拦截器绑定到实际的拦截器实现，你需要创建一个具有相同注解的拦截器：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The method being decorated with `@AroundInvoke` will handle the method invocation,
    and being decorated with `@AroundTimeout`, it will also support EJB timer callbacks
    (`@Timeout`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 被`@AroundInvoke`装饰的方法将处理方法调用，而被`@AroundTimeout`装饰的方法也将支持 EJB 定时器回调（`@Timeout`）。
- en: Note that if you also want to monitor the constructors, you can do so, but you
    will need to implement an `@AroundConstruct` method (with the same sort of implementation
    as our `monitor` method). The fact that our interceptor is decorated with `@Priority`
    automatically enables it, and you do not need to activate it in `beans.xml`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你还想监控构造函数，你也可以这样做，但你需要实现一个`@AroundConstruct`方法（与我们的`monitor`方法有类似的实现）。我们的拦截器自动被`@Priority`装饰，因此它被启用，你不需要在`beans.xml`中激活它。
- en: With this code, you can decorate any method with `@Monitored` and, assuming
    that your `Context` stores the metrics, you will get your figures in the reporting
    solution you used.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你可以用`@Monitored`装饰任何方法，并且假设你的`Context`存储了指标，你将在使用的报告解决方案中获得你的数据。
- en: 'However, one goal of writing a custom implementation was also to be able to
    configure it. With CDI, it can be done with `Extension`. The global idea will
    be to observe the application types/methods, and if one is configured to be monitored,
    we will add `@Monitored` automatically. This way, we''ll have no code impact in
    the application and we can easily activate/deactivate monitoring by simply changing
    our configuration. For the configuration, we can just start with a `performance.properties`
    resource as follows (note that it will be easy to change to a particular file
    outside the application):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写自定义实现的一个目标也是能够配置它。使用CDI，可以通过`Extension`来实现。全局思路将是观察应用程序类型/方法，如果配置为要监控，我们将自动添加`@Monitored`。这样，我们将在应用程序中没有代码影响，并且我们可以通过简单地更改我们的配置来轻松激活/停用监控。对于配置，我们可以从以下`performance.properties`资源开始（注意，它将很容易更改为应用程序外的特定文件）：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code uses the `BeforeBeanDiscovery` event (beginning of the CDI lifecycle)
    to load our configuration. Here, you can read from whatever place you want. A
    small optimization is to have a special key to check whether the extension is
    activated or not. If it is set to something other than true, then we will just
    skip all other events. In case it is enabled, we'll observe all the discovered
    types through the `ProcessAnnotatedType` event. If the bean should be monitored
    (our test is very simple here, we just check whether the class name suffixed with* monitor*
    is true in our configuration), then we override `AnnotatedType`, keeping all its
    information but adding `@Monitored` into the set of the class's annotations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`BeforeBeanDiscovery`事件（CDI生命周期的开始）来加载我们的配置。在这里，你可以从任何地方读取。一个小优化是有一个特殊的键来检查扩展是否已激活。如果它设置为除了true之外的其他值，那么我们将跳过所有其他事件。如果它被启用，我们将通过`ProcessAnnotatedType`事件观察所有发现类型。如果bean应该被监控（我们这里的测试非常简单，我们只是检查类名后缀*monitor*是否在我们的配置中为true），那么我们将覆盖`AnnotatedType`，保留所有其信息，但将`@Monitored`添加到类的注解集合中。
- en: You can do exactly the same at the method level, wrapping `AnnotatedMethod`
    returned by `AnnotatedType#getMethods`. The logic is the same; you just need to
    have one more configuration level (for methods).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在方法级别上做完全相同的事情，通过`AnnotatedType#getMethods`返回的`AnnotatedMethod`包装。逻辑是相同的；你只需要多一个配置级别（针对方法）。
- en: 'The `WrappedAnnotatedType` implementation is a simple delegation implementation,
    except for the annotation accessors, where a new set is used instead of the original
    one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrappedAnnotatedType`实现是一个简单的代理实现，除了注解访问器，这里使用了一个新集合而不是原始集合：'
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the only logic is in `getAnnotation` and in the constructor
    where a new set of annotations is created to replace the original one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，唯一的逻辑在`getAnnotation`和构造函数中，其中创建了一个新集合的注解来替换原始集合。
- en: Finally, to enable `Extension` and let the CDI find it, we just put its qualified
    name in `META-INF/services/javax.enterprise.inject.spi.Extension` in our project
    resources.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Once this extension is added to your application (you can develop it as a library
    and just add the `jar` file inside your `war` package if you want), you can configure
    it through `performances.properties`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, monitoring our quote service looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What's more, you can add a line by the class you want to monitor. Don't forget
    to restart between updates in this file, since the configuration and the CDI model's
    wrapping is done only at startup.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Javaagent – a complex but powerful instrumentation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back again to metrics, you can find existing javaagents even if they
    are less numerous, since writing an agent is a bit more complicated.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: A javaagent is a particular kind of the main method provided by the JVM that
    enables you to register `ClassFileTransformer`, which is a way to modify the classes'
    bytecode before they get loaded. In other words, you will write some code and
    compile it, but the JVM will never execute it. Instead, it will execute a rewritten
    version of the code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We will not detail how to do it here. In fact, it is more complicated than writing
    an interceptor (you need to take care of the classloaders, write low-level bytecode
    with the ASM library or an equivalent, and so on). However, it is important to
    see that the scope of a javaagent is the JVM—not an application, not a container,
    but the full JVM. For technical reasons, as you may guess, you can not instrument
    all the JVM classes, but all the classes that are loaded after the javaagent are
    started (which is already far enough).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting `java.net.HttpURLConnection` is a good example of instrumentation
    using a javaagent.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: This class is often used to implement a Java HTTP client, but it is often hidden
    by libraries (such as a JAX-RS client implementation). Therefore, it is not easy
    to have the current request and framework time if you cannot measure this specific
    class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: That is how a javaagent will be way more powerful than a CDI or a Spring instrumentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of what you can do with a javaagent, we will configure the
    Sirona project in our quote manager application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Sirona javaagent
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep it simple and easy to understand, we will use maven, but you can follow
    the same steps on any application server, since javaagent is set up on the JVM
    and not on a particular server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download the javaagent `jar` file. To do so with maven,
    you can just add the dependency maven plugin in your `pom.xml`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is configured to download sirona-javaagent shaded JAR (all in one bundle).
    Now, if you execute this maven command, you should obtain the javaagent JAR in
    your maven project:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once this command is executed, you should find a `sirona-javaagent.jar` file
    next to your pom.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the javaagent, we need to configure it. To make it simple,
    sirona supports a `sirona.properties` configuration file in the current directory,
    so we will use it. Here''s what it will contain to activate monitoring in our
    application:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `CounterListener`-related configuration is about the scope of the monitoring:
    what is instrumented and what is not. Here, we just instrument our application
    package and make Sirona ignoring the JVM classes (*container* is an alias for
    a set of built-in exclusions). Then, we configure `CounterDataStore` where the
    metrics are stored. In this example, we use a logging flavor (the metrics will
    then be outputted in a logger) and a CSV formatting. This is the simplest way,
    but you can also configure it to output the data in Elasticsearch, Graphite or
    any external system. Then, we configure our storage to log every 5 seconds (5000
    ms)—this is mainly for demonstration, but in real life, you will probably want
    to wait for a minute or so. Next, we request the storage to be cleared after collection.
    This last point means that every time the data is logged, the data is reset. It
    avoids keeping the startup data from having side-effects on the runtime data.
    Finally, the last line deactivates the path tracking feature of Sirona, which
    is built in with the javaagent, but we do not need it here.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything is configured, we just need to ensure that our application
    is ready to run (you can re-execute `mvn clean package` if you have a doubt) and
    then launch it with the javaagent on the JVM (maven if you launch GlassFish with
    maven or directly GlassFish if you use a standalone instance):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, adding a javaagent is as simple as adding the `-javaagent` option
    on the JVM, followed by the path of the JAR.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: If the agent is natively developed and not done in Java, the command would be
    quite similar (but using `-agentlib`). This is how you can distinguish between
    Java and native agents, but the principle remains the same.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have started the server, if you wait for a few seconds (~5 seconds
    as for our configuration), you will start getting some output related to the metrics
    Sirona took:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output format depends on the logger configuration. Out of the box, it is
    not that fancy, but if you configure your logger, you will get a plain CSV output.
    By default in Sirona, the logger name will be `com.github.rmannibucau.sirona.counters`.
    If you want to configure this particular logger in a specific file without a specific
    formatter pattern, you will have to use the logger name and not the class name.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep it simple for us, we will just change the `SimpleFormatter` format
    in the JVM (it will affect all loggers using this formatter):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that depending on your operating system, you may (or may not) need to escape
    the dollars, as in the previous example (it was for Linux).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server starts with this new configuration, the output is more readable:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What is interesting here is that you can directly import this in a CSV editor,
    including Microsoft Excel or LibreOffice Calc, and work on the data (sort it,
    compare it, and so on).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'To efficiently work on the data, you need to know what the columns are. For
    this particular datastore, here is the header list:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Timer/counter name
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer/counter role (*performance* means the execution time is measured, *failure*
    means an exception has occurred)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hits (indicates how often the method has been called in the measuring window)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max concurrency (indicates what the maximum of a concurrent call for a method
    in the measuring window is)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max (gives the maximum execution time)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min (gives the minimum execution time)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mean (gives the the average execution time)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum (gives the sum of all the execution times)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard deviation of all the execution times of the window
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your investigations into finding the bottleneck of a method to dig into (in
    order to optimize the performance), you will have to take multiple datasets into
    account. The first data will be the *sum*. If you sort by *sum* (decreasing order),
    the first method will be the one consuming a lot of time for your application.
    However, you need to validate it against the number of hits. For instance, if
    you have a single hit, then you know that caching this method's data will not
    be helpful. The standard deviation (or comparing the min/max range) will also
    give you an idea of the method’s behavior. If the range is high, then you need
    to investigate what this method does, and why it is fast sometimes and slow some
    other times.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Once you've found a good method to investigate, you can reuse the tools we talked
    about earlier to dig into the method. Having this level of information to start
    working is generally easier to deal with and more centered on the application
    overview than the detailed view, which can be hard (or long) to organize. It is
    always easier to drill down the performance data than starting from the detailed
    view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now, to show you how powerful a javaagent can be, we will temporarily change
    our sirona configuration a bit. We will exclude the Oracle package (just to override
    the default exclusion, which is the whole JVM), and we will include `HttpURLConnection`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The goal for our application can be to compare the time we spend in the provisioning
    versus the current network cost, which we can not optimize as it is linked to
    our environment, which we assume to be constant during the benchmark phase.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the configuration looks like now:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Only the two first lines change, and you can see that the JVM is no more excluded
    to be able to instrument the sum package and that `HttpUrlConnection` is now included
    in the white list of instrumented classes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We relaunch our server, and after the provisioning, we get these new outputs:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The configuration change includes the JVM HTTP client monitoring, and we can
    now have a part of the time spent in the actual network as well as the time spent
    in the client code itself, with retries and all the logic it embeds. This is the
    kind of information you cannot get without a javaagent.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern* architectures tend to encourage microservices. This means that you
    will mainly split your overall system into subsystems with a clear responsibility
    separation. It implies a lot of issues, such as the requirement to handle transactions
    across different systems (what XA was doing in its time), the addition of multiple
    remote communications, which slows down the overall process, and so on, but it
    comes with the advantage of allowing you to develop systems more rapidly and to
    go into production more easily in general. There is always a trade-off.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In any case, if you work on the performance, you may have to deal with such
    a system now and, therefore, need to know which tools can help you.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly two kinds of solutions that will help a lot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Data aggregation**: All the data of all the applications will be aggregated
    in a single system. For instance, the previously captured execution times of N
    instances will be stored in a single *database* (such as InfluxDB or Elasticsearch).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing**: The entire system will propagate a single *transaction ID* (also
    called *request ID*), which will enable you to identify the request (user action)
    across all the systems and the stage you are at (third system of the pipeline,
    for instance).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Monitoring
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of applications, most of the time will be taken by the SQL queries'
    execution. Therefore, it is important to monitor them. You can use one of the
    previous techniques but there are also some specific ways to monitor them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the idea is to replace the native driver you use (the Oracle, MySQL
    ones, for instance) with a monitoring driver, which will wrap the default driver
    and delegate all the logic to the original one, adding some metrics on top of
    it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, using sirona JDBC driver ([http://repo.maven.apache.org/maven2/com/github/rmannibucau/sirona/sirona-jdbc/0.6/](http://repo.maven.apache.org/maven2/com/github/rmannibucau/sirona/sirona-jdbc/0.6/))
    for our datasource, we will define the application DataSource this way:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The driver's class name is now the monitoring one, and the URL changed a bit
    to configure the monitoring driver. Here, with Sirona, you append `sirona` before
    the native driver URL and after the `jdbc:` prefix, and you add the `delegateDriver`
    query parameter to the URL with the classname of the native driver as the value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Once done, Sirona will automatically create counters for each statement and
    add it to its report.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This kind of solution works very well with prepared statements, as you will
    reuse the same *key* (the SQL value). This is generally what any JPA provider
    does.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: This visualization, between Java and the database, can help determine the slow
    queries. There are a lot of implementations of such a type. Just pick the one
    you prefer, between Sirona, Jamon, JavaSimon, Log4jJDBC, P6Spy, and others.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Data aggregation
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices—or more generally services with small scopes—are fast-moving applications
    in general, and it is easy to add/remove them in a global system. In this condition,
    the performance will need to be comparable and validatable against any change
    of the sibling services (which can impact the central service by overusing or
    misusing it).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Being able to have a centralized vision of all the systems is a key to understanding
    how optimizing another application can make your application go faster. The corollary
    of this statement is that when you depend on another application, which is too
    slow for your SLA, you need to be aware of it as soon as possible. Once identified,
    you can add caching or alternative ways to make your application less dependent
    on others and behave faster.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: It is not always possible—for instance, in our quote manager application, we
    can't get data about Yahoo—but in a microservice structure, you will often get
    a company policy or at least contacts to be able to discuss it and implement it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it is mainly about agreeing on a way of identifying the application
    (which is just about defining a convention in the overall system, shared by all
    the subsystems) and the data format put inside the aggregator. For instance, you
    can say that you will use the `Company-ID` HTTP header as a request identifier
    and the log format will be `${Company-Id} | ${Tenant-Id} | ${Machine-Id} | ${Execution-Time}
    | ${action/method} | ${message}`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple example, but the idea is to be able to browse the log
    across applications pretty quickly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what you will log, you need to select a system to store your data.
    Here, you have a lot of choices but do not forget to check whether you can exploit
    the data once it is stored. It means that you need to ensure you have a good user
    interface that will fulfill your expectations on top of the storage.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The most known are these:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Elastic stack: It is based on Elasticsearch to store the data and Kibana to
    visualize it. It is available for free.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Splunk: It is a custom stack dedicated to the aggregation of data.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana: It is mainly a UI tool, but it is pluggable on most of the monitoring
    databases, including Elasticsearch, Graphite or InfluxDB.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple options for tracing (Zipkin, Dapper, and others) but a few
    of them seem to have become mainstream. One of them is the OpenTracing initiative
    ([http://opentracing.io/](http://opentracing.io/)). All share more or less the
    same design based on spans.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The global idea is to let each transaction’s actors mark their presence with
    a span. A span contains an identifier, some metadata about the invocation, and
    the execution time. The identifier is generally composed of multiple values representing
    the overall trace identifier (the request marker), the span identifier, and, often,
    the parent identifier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: When correctly installed, the tracing happens on the client and server sides,
    so you have a full vision of the system handling, and it is associated with the
    processing time of each part of the system. It is really about ensuring that every
    part of your system is properly instrumented—each time you exit or enter a system,
    you must be set up to handle the associated tracing. This includes HTTP clients/servers,
    and also the JDBC or NoSQL drivers.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: As for the monitoring libraries, this relies on storage, but there are also
    local implementations (a bit like our CSV logger when we talked about the Sirona
    javaagent) you can use to test your configuration or use as fallbacks if you can’t
    have a real monitoring database. However, using local outputs with such systems
    will make your work harder and longer, since it is really about aggregating multiple
    data to have a consolidated vision. What you need to understand is that you shouldn't
    hesitate to invest in setting a server dedicated to the data collection. It will
    not only help you for performance, but also for tracing your system. So, it is
    a worthy investment!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: APM
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find tools called **Application Performance Management** (**APM**) on
    the market. These are really the Rolls Royce of monitoring tools and allow you
    to trace completely all the steps of the application, to go back in time to understand
    what happened, and to deduce the cause of a support issue very quickly. The paid
    offers generally include the infrastructure as well, which is not a negligible
    point, since it leads to a lot of data manipulation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Technically, they reuse several of the previous techniques but are really an
    all-in-one solution, which makes them very valuable. However, they are generally
    expensive and rarely open source.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, you can find a few open source implementations, such as PinPoint([https://github.com/naver/pinpoint](https://github.com/naver/pinpoint)),
    InspectIT([https://github.com/inspectIT/inspectIT](https://github.com/inspectIT/inspectIT)),
    and Glowroot([https://glowroot.org/](https://glowroot.org/)). In terms of a leading
    proprietary, solution you can find New Relic ([https://newrelic.com/java](https://newrelic.com/java)),
    DripStat ([https://dripstat.com](https://dripstat.com)), or DynaTrace ([https://www.dynatrace.com/](https://www.dynatrace.com/)).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part, we saw a lot of ways to gather information about the JVM and
    your application. We also saw that the JVM itself provides a set of tools to give
    you information about the memory, CPU, and garbage collection. Most of them are
    available through the command line (which can be very handy when benchmarking
    a machine without any UI), but they also come with several user interfaces, enabling
    you to get the information easily once you can connect to the JVM. One of these
    tools is the JMC: it gives you a lot of information and even allows you to drill
    down into the method invocations to have a detailed view of your application.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not enough and you may need to get access to the server information
    about the pool usage, and in this case, the server can give you some more information
    about configuration issues (such as a pool configured too small). Then, a set
    of libraries allows you to get the monitoring information in a more efficient
    and performance-oriented way, which enables you to investigate the application
    without a deep knowledge or any assumption about it. Note that these tools (such
    as Metrics or Sirona) also aggregate more data and often have plugins for the
    servers, which can prevent you from using the server-specific monitoring to get
    a more global vision.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw that in multisystem applications, you will need to ensure you
    can monitor your applications and also the ones linked to them so that you can
    identify the impacts on your own applications and try to decrease them if too
    impacting.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: All of these tools, in some way, have some kind of overlap, but they all fulfill
    different needs and answer to a different trade-off between ease, information
    completeness, and investment. Depending on the knowledge you have about the application
    you are working on, and the investment you can afford for the code and infrastructure
    of the application of the benchmarking platform, you will pick a solution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate the impact of resources on applications
    and their performance. We will go through the Java memory management and the server
    resource handling, such as `DataSource` and `ConnectionFactory`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
