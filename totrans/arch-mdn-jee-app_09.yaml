- en: Monitoring, Performance, and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控、性能和日志记录
- en: We have now seen how to craft modern, scalable, and resilient microservices
    with Java EE. In particular, the part about adding resilience as well as technical
    cross-cutting to microservices is a topic that we want to pursue further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用Java EE构建现代、可扩展和有弹性的微服务。特别是关于向微服务添加弹性和技术横切的部分，这是我们希望进一步探讨的主题。
- en: Enterprise applications run on server environments remote from the users. In
    order to provide insights into the system, we need to add visibility. There are
    multiple ways to achieve this aspect of telemetry that includes monitoring, health
    checks, tracing, or logging. This chapter covers the reasoning behind each of
    these approaches and what makes sense for enterprise applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序在远离用户的服务器环境中运行。为了提供对系统的洞察，我们需要增加可见性。有多种方法可以实现这一方面的遥测，包括监控、健康检查、跟踪或日志记录。本章涵盖了每种方法的理由以及哪些对企业应用程序是有意义的。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Business and technical metrics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业和技术指标
- en: Integrating Prometheus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Prometheus
- en: How to meet performance needs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何满足性能需求
- en: Java Performance Diagnostic Model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java性能诊断模型
- en: Monitoring and sampling techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和采样技术
- en: Why traditional logging is harmful
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么传统的日志记录是有害的
- en: Monitoring, logging, and tracing in a modern world
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代世界中监控、日志记录和跟踪
- en: Suitability of performance tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试的适用性
- en: Business metrics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业指标
- en: Visibility in the business processes is crucial to business-related persons
    in order to see and interpret what is happening inside an enterprise system. Business-relevant
    metrics allow to evaluate the effectiveness of processes. Without visibility into
    the processes, the enterprise application acts as a black box.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务流程中的可见性对于业务相关人员来说至关重要，以便看到并解释企业系统内部发生的事情。与业务相关的指标允许评估流程的有效性。如果没有对流程的可见性，企业应用程序就像一个黑盒。
- en: Business-related metrics are an invaluable asset to business experts. They provide
    domain-specific information as to how the use cases perform. Which metrics are
    of interested obviously depends on the domain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务相关的指标是业务专家的无价资产。它们提供了关于用例如何执行的具体领域信息。显然，哪些指标是有兴趣的取决于领域。
- en: How many cars are created per hour? How many articles are purchased and for
    what amount? What is the conversion rate? How many users followed the email marketing
    campaign? These are examples of domain-specific key performance indicators. The
    business experts have to define these indicators for the specific domain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每小时能创建多少辆车？销售了多少篇文章以及金额是多少？转换率是多少？有多少用户参与了电子邮件营销活动？这些都是领域特定关键性能指标的例子。业务专家必须为特定领域定义这些指标。
- en: The enterprise application has to emit this information which originate from
    various points in the business processes. The nature of this information depends
    on the actual domain. In many cases, business metrics arise from domain events
    that occur during performing the business processes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序必须发出来自业务流程中各个点的信息。这种信息的性质取决于实际领域。在许多情况下，业务指标源于执行业务流程期间发生的领域事件。
- en: Take the number of cars that are created per hour as an example. The car creation
    use case emits a corresponding `CarCreated` domain event, which is collected for
    future statistics. Whereas calculating the conversion rate involves much more
    information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以每小时创建的汽车数量为例。汽车创建用例发出相应的`CarCreated`领域事件，这些事件被收集以供未来统计。而计算转换率则涉及更多的信息。
- en: The business experts have to define the semantics and origin behind key performance
    indicators. Defining and collecting these indicators becomes part of the use case.
    Emitting this information is a responsibility of the application as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 业务专家必须定义关键性能指标的含义和来源。定义和收集这些指标成为用例的一部分。发出这些信息是应用程序的责任。
- en: It's important to distinguish between business-motivated and technically-motivated
    metrics. Although business metrics provide insights of high value, they are directly
    impacted by technical metrics. An example of a technical metric is the service
    response time which is, in turn, affected by other technical metrics. The sub-chapter
    *Technical metrics* will examine this topic further.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 区分业务驱动和技术驱动的指标非常重要。尽管业务指标提供了高价值的见解，但它们直接受到技术指标的影响。一个技术指标示例是服务响应时间，它反过来又受到其他技术指标的影响。子章节*技术指标*将进一步探讨此主题。
- en: Business experts, therefore, must not only care about the business aspects of
    monitoring but also the technical impact of an application's responsiveness.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，业务专家不仅必须关注监控的业务方面，还要关注应用程序响应性的技术影响。
- en: Collecting business metrics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集业务指标
- en: Business-relevant metrics allow business experts to evaluate the effectiveness
    of the enterprise system. The metrics provide helpful insights into specific parts
    of the business domain. The application is responsible for gathering business-relevant
    metrics as part of it's use cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务相关的指标允许业务专家评估企业系统的有效性。这些指标为业务领域的特定部分提供了有价值的见解。应用程序负责在其用例中收集与业务相关的指标。
- en: The *car manufacture* package, for example, performs business logic that can
    emit certain metrics, such as the number of cars created per hour.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*汽车制造*包执行的业务逻辑可以发出某些指标，例如每小时创建的汽车数量。
- en: From a business perspective, the relevant metrics usually originate from domain
    events. It's advisable to define and emit domain events, such as `CarCreated`,
    as part of the use case, as soon as a car has been successfully manufactured.
    These events are collected and being used to derive further information in the
    form of specific business metrics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务角度来看，相关的指标通常源自领域事件。建议在汽车成功制造后，立即在用例中定义和发出领域事件，例如`CarCreated`。这些事件被收集并用于以特定业务指标的形式推导更多信息。
- en: 'The `CarCreated` event is fired in the boundary as a CDI event and can be observed
    in a separate statistics collector. The following code snippet shows a domain
    event fired as part of a use case:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarCreated`事件在边界作为CDI事件触发，并可以在单独的统计收集器中观察到。以下代码片段展示了作为用例一部分触发的事件：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The boundary fires the CDI event that notifies about a successful car creation.
    The corresponding handling is decoupled from the business process and no further
    logic is involved in this place. The event will be observed in a separate application
    scoped bean. Synchronous CDI events can define to be handled during specific transaction
    phases. The following transactional observer therefore ensures that only successful
    database transactions are measured:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 边界触发通知成功创建汽车的CDI事件。相应的处理与业务流程解耦，并且在此处不涉及任何其他逻辑。该事件将在单独的应用程序作用域bean中观察到。同步CDI事件可以定义在特定事务阶段进行处理。以下事务观察者确保只有成功的数据库事务被测量：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The event information is collected and processed further in order to provide
    the business metrics. Depending on the situation, more business-relevant data
    could be required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事件信息被收集并进一步处理，以提供业务指标。根据情况，可能需要更多与业务相关的数据。
- en: Modeling the relevant information as domain events matches the business definition
    and decouples the use case from the statistics calculation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关信息建模为领域事件与业务定义相匹配，并解耦了用例与统计计算。
- en: Besides defining domain events, the information can also be collected via cross-cutting
    components, such as interceptors, depending on the situation and requirements. In
    the simplest case, the metrics are instrumented and collected in primitives. Application
    developers have to consider bean scopes in order not to throw away collected data
    with incorrect scopes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义领域事件外，根据情况和要求，信息还可以通过横切组件，如拦截器进行收集。在最简单的情况下，指标被仪器化和收集在原语中。应用程序开发人员必须考虑bean作用域，以避免因作用域不正确而丢弃收集到的数据。
- en: Emitting metrics
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出指标
- en: Metrics are usually not persisted in the application but in another system that
    is part of the environment, such as external monitoring solutions. This simplifies
    the implementation of metrics; the enterprise application keeps the information
    in memory and emits the specified metrics. External monitoring solutions scrape
    and process these metrics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 度量通常不会在应用程序中持久化，而是在环境中的另一个系统中，例如外部监控解决方案。这简化了度量的实现；企业应用程序将信息保留在内存中并发射指定的度量。外部监控解决方案抓取和处理这些度量。
- en: There are several techniques that can be used to emit and collect metrics. For
    example, measures can be formatted into custom JSON strings and exposed via HTTP
    endpoints.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用几种技术来发射和收集度量。例如，度量可以格式化为自定义JSON字符串，并通过HTTP端点公开。
- en: A monitoring solution that is part of the Cloud Native Computing Foundation,
    and, as of today, has huge momentum, is **Prometheus**. Prometheus is a monitoring
    and alerting technology that scrapes, efficiently stores, and queries time series
    data. It gathers data that is emitted by some service over HTTP in a specific
    format. Prometheus is powerful in scraping and storing data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为云原生计算基金会的一部分的监控解决方案，并且截至目前，它具有巨大的动力，是**Prometheus**。Prometheus是一种监控和警报技术，它抓取、高效存储和查询时间序列数据。它收集通过HTTP以特定格式发射的某些服务的数据。Prometheus在抓取和存储数据方面非常强大。
- en: For graphs and dashboards for business-related information, other solutions
    can be built on top of this. A technology that works well with Prometheus and
    provides many possibilities for appealing graphs is **Grafana**. Grafana doesn't
    store time series itself but uses sources such as Prometheus to query and display
    time series.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与业务相关的信息和图表，可以在其基础上构建其他解决方案。与Prometheus兼容且提供许多吸引人图表可能性的技术是**Grafana**。Grafana本身不存储时间序列数据，而是使用Prometheus等源查询和显示时间序列。
- en: 'The following screenshot shows an example of a Grafana dashboard:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Grafana仪表板的示例：
- en: '![](img/82f83925-226d-4da5-9af3-49ca9a817d8c.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/82f83925-226d-4da5-9af3-49ca9a817d8c.png)'
- en: The idea of dashboards provides visibility for business experts and combines
    relevant information. Depending on the requirements and motivations, coherent
    information is combined into graphs that provide overviews and insights. Dashboards
    provide the ability to query and customize time series representations based on
    the target group.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板的概念为业务专家提供了可见性，并综合了相关信息。根据需求和动机，相关信息被组合成图表，提供概述和洞察。仪表板提供了根据目标群体查询和自定义时间序列表示的能力。
- en: Enter Prometheus
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Prometheus
- en: The following examples show how to integrate Prometheus into Java EE. This is
    one possible monitoring solution and aims to give the readers an idea of how to
    slimly integrate business-related metrics.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何将Prometheus集成到Java EE中。这是可能的监控解决方案之一，旨在给读者一个如何巧妙地集成与业务相关的度量的想法。
- en: 'The application will emit the gathered metrics in the Prometheus output format.
    The Prometheus instances scrape and store this information, as demonstrated in
    the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将以Prometheus输出格式发射收集到的度量。Prometheus实例抓取并存储这些信息，如下面的图所示：
- en: '![](img/0bd00845-3cc1-4de5-b5b8-584a218eb27a.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0bd00845-3cc1-4de5-b5b8-584a218eb27a.png)'
- en: Developers can implement custom functionality to collect and emit information,
    or use Prometheus' Client API which already ships with several metric types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以实现自定义功能来收集和发射信息，或者使用Prometheus的Client API，该API已经包含了几种度量类型。
- en: 'There are multiple Prometheus metric types as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，有多个Prometheus度量类型：
- en: The one mostly used is a **counter** which represents an increasing numeric
    value. It counts the occurred events.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的一个是**计数器**，它代表一个递增的数值。它计算发生的事件。
- en: A **gauge** is a numeric value that goes up and down. It can be used for measuring
    values such as conversion rates, temperatures, or turnover.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**是一个上下波动的数值。它可以用来衡量诸如转化率、温度或周转率等值。'
- en: '**Histograms** and **summaries** are more complex metric types used to sample
    observations in buckets. They typically observe metrics distribution. For example,
    how long does it take to create a car, how much do these values vary, and how
    are they distributed?'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图**和**摘要**是更复杂的度量类型，用于在桶中对观测值进行采样。它们通常观察度量分布。例如，制造一辆汽车需要多长时间，这些值的变化有多大，以及它们的分布情况如何？'
- en: A Prometheus metric has a name and labels, which are sets of key-value pairs.
    A time series is identified by the metric's name and a set of labels. The label
    can be seen as parameters, sharding the overall amount of information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 度量有一个名称和标签，标签是一组键值对。时间序列由度量的名称和一组标签来识别。标签可以看作是参数，将整体信息量进行分片。
- en: An example of a counter metric representation using labels is `cars_manufactured_total{color="RED",
    engine="DIESEL"}`. The `cars_manufactured_total` counter includes the total number
    of manufactured cars that are specified by their color and engine type. The collected
    metrics can be queried for the provided label information later on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签的计数器度量表示示例为 `cars_manufactured_total{color="RED", engine="DIESEL"}`。`cars_manufactured_total`
    计数器包括由其颜色和发动机类型指定的所有制造汽车的总数。收集的度量可以在以后查询提供的标签信息。
- en: Realization with Java EE
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java EE 实现
- en: 'The following statistics implementation observes the domain event specified
    earlier and stores the information in the Prometheus counter metric:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下统计实现观察了之前指定的域事件并将信息存储在 Prometheus 计数器度量中：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The counter metric is created and registered to the Prometheus Client API. Measured
    values are qualified by the car `color` and `engine` type, which are taken into
    account when scraping the values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器度量被创建并注册到 Prometheus 客户端 API。测量的值由汽车的颜色和 `engine` 类型进行限定，这些类型在抓取值时被考虑在内。
- en: In order to emit this information, the Prometheus servlet library can be included.
    This outputs all the registered metrics in the correct format. The monitoring
    servlet is configured via `web.xml`. It's also possible to include a JAX-RS resource
    to emit the data by accessing `CollectorRegistry.defaultRegistry`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出此信息，可以包含 Prometheus servlet 库。这以正确的格式输出所有已注册的度量。监控 servlet 通过 `web.xml`
    进行配置。也可以通过访问 `CollectorRegistry.defaultRegistry` 来包含一个 JAX-RS 资源以发出数据。
- en: 'The emitted output will look similar to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 发出的输出将类似于以下内容：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Java EE components, such as CDI events, support developers in integrating domain
    event metrics in a lean way. In the preceding example, the `ManufacturingStatistics`
    class is the only point that depends on the Prometheus API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 组件，如 CDI 事件，以简洁的方式支持开发者在应用程序中集成域事件度量。在前面的示例中，`ManufacturingStatistics`
    类是唯一依赖于 Prometheus API 的点。
- en: It's highly advisable to include the Prometheus Client API as a separate container
    image layer and not in the application artifact.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议将 Prometheus 客户端 API 作为单独的容器镜像层包含，而不是包含在应用程序工件中。
- en: The monitoring solution scrapes and further processes the provided information,
    in order to gather the required business metrics. Scraping the counter of manufactured
    cars over time leads to the number of created cars per hour. This metric can be
    queried for the total number of cars as well as for specific color and engine
    combinations. The queries that define the business metrics can also be adapted
    and refined due to the requirements. The application ideally emits the needed
    atomic business-relevant metrics.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 监控解决方案抓取并进一步处理提供的信息，以收集所需的业务度量。随着时间的推移抓取制造汽车的计数器会导致每小时创建的汽车数量。此度量可以查询汽车的总数，以及特定颜色和发动机组合。定义业务度量的查询也可以根据需求进行适应和优化。理想情况下，应用程序会发出所需的原子业务相关度量。
- en: Integrating the environment
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境集成
- en: The application emits the business-relevant metrics via HTTP. The Prometheus
    instance scrapes and store this data and makes it available via queries, graphs,
    and external solutions, such as Grafana.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过 HTTP 发出业务相关的度量。Prometheus 实例抓取并存储这些数据，并通过查询、图形和外部解决方案（如 Grafana）使其可用。
- en: In a container orchestration, the Prometheus instance runs inside the cluster.
    This removes the necessity to configure externally accessible monitoring endpoints.
    Prometheus integrates with Kubernetes in order to discover the application instances.
    Prometheus needs to access every application pod individually, since every application
    instance emits its monitoring metrics separately. Prometheus accumulates the information
    of all instances.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器编排中，Prometheus 实例在集群内部运行。这消除了配置外部可访问监控端点的必要性。Prometheus 与 Kubernetes 集成以发现应用程序实例。由于每个应用程序实例分别发出其监控度量，Prometheus
    需要单独访问每个应用程序 pod，从而累积所有实例的信息。
- en: The Prometheus configuration is either stored in a config map or part of a base
    image. The instance is configured to access the applications and exporters every
    *n* seconds in order to scrape the time series. For configuring Prometheus, refer
    to its current documentation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus配置存储在配置映射中或作为基础镜像的一部分。实例配置为每*n*秒访问一次应用程序和导出器，以抓取时间序列。有关配置Prometheus的详细信息，请参阅其当前文档。
- en: This is one possible solution for integrating business monitoring into a cloud
    native application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将业务监控集成到云原生应用程序中的一种可能解决方案。
- en: Business-related metrics are advisably represented by domain events that emerge
    as part of the business use case. Integrating the chosen monitoring solutions
    should happen transparently from the domain logic, without much vendor lock-in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 建议用业务用例中出现的域事件来表示与业务相关的指标。将所选的监控解决方案集成应从域逻辑中透明地完成，而不应过度依赖供应商。
- en: Meeting performance requirements in distributed systems
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分布式系统中满足性能要求
- en: Responsiveness is an important non-technical requirement of an enterprise application.
    The system only provides business value if client requests can be served within
    a reasonable amount of time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 响应性是企业应用程序的一个重要非技术性要求。只有当客户端请求能在合理的时间内得到服务时，系统才提供业务价值。
- en: Meeting performance requirements in distributed systems requires to take all
    participating applications into account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中满足性能要求需要考虑所有参与的应用程序。
- en: Enterprise application are often required to meet a **service level agreement**
    (**SLA**). SLAs usually define thresholds for availability or response times,
    respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常需要满足**服务水平协议**（**SLA**）。SLA通常定义了可用性或响应时间的阈值。
- en: Service level agreements
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务水平协议
- en: In order to calculate and meet SLAs, it's important to consider which processes
    and applications are included in business use cases, especially in regard to synchronous
    communication. The performance of applications that synchronously call external
    systems directly depend on the performance of these calls. As mentioned before,
    distributed transactions should be avoided.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算和满足SLA，考虑哪些流程和应用程序包含在业务用例中非常重要，特别是在同步通信方面。同步调用外部系统的应用程序的性能直接取决于这些调用的性能。如前所述，应避免分布式事务。
- en: As per its nature, SLAs can only be met if all applications perform and work
    well together. Every application affects the SLAs of dependent systems. This not
    only concerns the slowest application in a system but all participating services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其本质，只有当所有应用程序都表现良好并协同工作时，才能满足SLA。每个应用程序都会影响依赖系统的SLA。这不仅涉及系统中最慢的应用程序，还涉及所有参与的服务。
- en: For example, meeting an uptime of 99.995% per definition is not possible if
    it includes synchronous calls to two applications with each of them guaranteeing
    99.995%. The resulting SLA is 99.99%, the values of each participating system
    multiplied.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果包括对两个应用程序的同步调用，每个应用程序都保证99.995%的可用性，那么根据定义，达到99.995%的可用性是不可能的。结果SLA是99.99%，每个参与系统的值相乘。
- en: The same is true for guaranteed response times. Every involved system slows
    down the overall response, resulting in a total response time that is the sum
    of all SLA times.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于保证响应时间也是如此。每个涉及的系统都会减慢整体响应速度，导致总响应时间是所有SLA时间的总和。
- en: Achieving SLAs in distributed systems
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分布式系统中实现SLA
- en: Let's see an example how to achieve SLAs in distributed systems, assuming the
    enterprise application resides in a high performance scenario where it's crucial
    to meet guaranteed response times. The application synchronously communicates
    with one or more backend systems that provide necessary information. The overall
    system needs to meet an SLA response time of 200 milliseconds.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在分布式系统中实现SLA的例子，假设企业应用程序位于一个高性能场景中，其中满足保证响应时间是至关重要的。该应用程序同步与一个或多个提供必要信息的后端系统通信。整个系统需要满足200毫秒的SLA响应时间。
- en: In this scenario the backend applications support in meeting the SLA time by
    applying backpressure and preventively rejecting requests that won't meet the
    guaranteed SLA. By doing so the originating application has the chance to use
    another backend service that may respond in time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景下，后端应用程序通过应用背压和预防性地拒绝无法满足保证SLA的请求来支持满足SLA时间。这样做，原始应用程序有机会使用可能及时响应的其他后端服务。
- en: In order to appropriately configure pooling, the engineers need to know the
    average response time of the backend system, here 20 milliseconds. The corresponding
    business functionality defines a dedicated thread pool by using a dedicated managed
    executor service. The thread pool can be configured individually.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适当地配置连接池，工程师需要知道后端系统的平均响应时间，这里为20毫秒。相应的业务功能通过使用专门的托管执行器服务定义一个专用的线程池。线程池可以单独配置。
- en: 'The configuration is achieved by following some steps: The engineers configure
    the maximum limit of the thread pool size plus the maximum queue size, so that
    the SLA time is *n* times the average response time. This *n*, here `10`, is the
    maximum number of requests the system will handle at a time, consisting of the
    maximum pool size and maximum queue size limit. Any request that exceeds this
    number is immediately rejected by a service temporarily unavailable response.
    This is based on the calculation that the new request will likely exceed the calculated
    SLA time of 200 milliseconds, if the current number of handled requests exceeds
    *n*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是通过遵循一些步骤来实现的：工程师配置线程池的最大限制加上最大队列大小，以确保SLA时间是平均响应时间的*n*倍。这里的*n*，即`10`，是系统一次将处理的请求数量的最大值，包括最大池大小和最大队列大小限制。任何超出这个数字的请求都会被服务暂时不可用响应立即拒绝。这是基于计算，如果当前处理的请求数量超过*n*，新请求很可能会超过计算出的200毫秒的SLA时间。
- en: Immediately rejecting requests sounds like a harsh response, but by doing so,
    the client application is given the opportunity to retry a different backend without
    consuming the whole SLA time in vain in a single invocation. It's a case example
    for high performance scenarios with multiple backends where meeting SLAs has a
    high priority.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 立即拒绝请求听起来像是一种严厉的回应，但通过这样做，客户端应用程序有机会重试不同的后端，而无需在单次调用中浪费整个SLA时间。这是一个在多个后端的高性能场景中的案例，其中满足SLA具有很高的优先级。
- en: The implementation of this scenario is similar to the backpressure example in
    the previous chapter. The client uses different backends as a fallback if the
    first invocation failes with an unavailable service. This implicitly makes the
    client resilient since it uses multiple backends as fallback. The backend service
    implicitly applies the bulkhead pattern. A single functionality that is unavailable
    doesn't affect the rest of the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景的实现与上一章中的背压示例类似。如果第一次调用失败，客户端会使用不同的后端作为后备。这隐式地使客户端具有弹性，因为它使用多个后端作为后备。后端服务隐式地应用了隔离舱模式。单个不可用的功能不会影响应用程序的其他部分。
- en: Tackling performance issues
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决性能问题
- en: 'Technical metrics, such as response time, throughput, error rates or uptime indicate
    the responsiveness of the system. As long as the application''s responsiveness
    is in acceptable ranges, there is arguably no other metric to consider. Insufficient
    performance means that the system''s SLAs are not being met, that is, the response
    time is too high or client requests fail. Then the question arises: what needs
    to be changed to improve the situation?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 技术指标，如响应时间、吞吐量、错误率或可用时间，表明系统的响应性。只要应用程序的响应性在可接受的范围内，就没有其他指标需要考虑。性能不足意味着系统的服务级别协议（SLA）没有得到满足，也就是说响应时间过高或客户端请求失败。那么问题来了：需要改变什么来改善这种情况？
- en: Theory of constraints
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束理论
- en: If the desired load on the system increases, the throughput ideally increases
    as well. The theory of constraints is based on the assumption that there will
    be at least one constraint that will throttle the system's throughput. The constraints
    or bottlenecks therefore cause a performance regression.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统所需的负载增加，理想情况下吞吐量也会增加。约束理论基于这样一个假设，即至少有一个约束将限制系统的吞吐量。因此，约束或瓶颈导致性能下降。
- en: Like a chain that is only as strong as its weakest link, the constraining resource
    limits the overall performance of the system or certain functionality thereof.
    It prevents the application from handling more load while other resources are
    not fully utilized. Only by increasing the flow through the constraining resource,
    that is, removing the bottleneck, will the throughput be increased. If the system
    is optimized *around the bottleneck* rather than removing it, the responsiveness
    of the overall system won't improve and, ultimately, it may even decrease.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像链条的强度取决于最薄弱的环节一样，限制性资源限制了系统的整体性能或某些功能的性能。它阻止了应用程序在其他资源未充分利用的情况下处理更多的负载。只有通过增加限制性资源的流量，即消除瓶颈，才能提高吞吐量。如果系统是围绕瓶颈进行优化的，而不是消除它，那么整体系统的响应性不会提高，甚至可能降低。
- en: It's therefore crucial to identify what the bottleneck is. The overall performance
    won't improve, before the limiting bottleneck gets targeted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确定瓶颈至关重要。在针对限制性瓶颈之前，整体性能不会提高。
- en: For example, throwing more CPU power at an application with high CPU utilization
    probably won't help to achieve better performance. Maybe the application isn't
    performing well because of other root causes than insufficient CPU.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将更多的CPU功率投入到高CPU利用率的程序中可能无法帮助实现更好的性能。也许程序表现不佳是因为其他根本原因，而不仅仅是CPU不足。
- en: It's important to mention here that the limiting constraint likely is external
    to the application. In a single, monolithic application, this includes the hardware
    and the operating system, with all running processes. If other software running
    on the same hardware heavily utilizes the network adapter, the application's network
    I/O and overall performance will be affected as well, even if the root cause,
    the limiting constraint, isn't the in responsibility of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是要提到，限制性约束可能位于应用程序之外。在单一、单体应用程序中，这包括硬件和操作系统，以及所有运行进程。如果其他在同一硬件上运行的软件大量使用网络适配器，那么应用程序的网络I/O和整体性能也会受到影响，即使根本原因，即限制性约束，不在应用程序的责任范围内。
- en: Inspecting performance issues therefore needs to take more into account than
    just the application itself. The whole set of processes running on the same hardware
    can have an impact on the application's performance, depending on how the other
    processes utilize the system's resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查性能问题需要考虑的不仅仅是应用程序本身。在同一硬件上运行的整个进程集都可能影响应用程序的性能，这取决于其他进程如何利用系统资源。
- en: In a distributed environment, performance analytics also involves all interdependent
    applications, that interact with the application, and the communication in between.
    In order to identify the constraining resource, the overall situation of the system
    has to be taken into account.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式环境中，性能分析还涉及所有相互依赖的应用程序，以及它们之间的通信。为了确定限制性资源，必须考虑系统的整体情况。
- en: Since the applications are interconnected, improving the responsiveness of a
    single system will affect others and can potentially even decrease the overall
    responsiveness. Again, trying to improve the wrong aspect, such as optimizing
    around the bottleneck, will not improve rather than most likely even downgrade
    the overall performance. An application that connects to an external system that
    represents the bottleneck , puts certain pressure on the external system. If the
    application's performance is tuned, rather than the external application, the
    load and pressure on the latter is increased which ultimately leads to overall
    worse responsiveness.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序是相互连接的，提高单个系统的响应性将影响其他系统，甚至可能降低整体响应性。再次强调，试图改善错误方面，如围绕瓶颈进行优化，不仅不会提高，反而很可能会降低整体性能。连接到代表瓶颈的外部系统的应用程序，会对外部系统施加一定的压力。如果调整的是应用程序的性能，而不是外部应用程序，那么对后者的负载和压力会增加，这最终会导致整体响应性变差。
- en: In distributed systems, the situation with all interdependent applications involved
    vastly complicates solving performance issues.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，所有相互依赖的应用程序都涉及其中，这使得解决性能问题变得更加复杂。
- en: Identifying performance regression with jPDM
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jPDM识别性能回归
- en: The **Java Performance Diagnostic Model** (**jPDM**) is a performance diagnostic
    model that abstracts the complexity of systems. It helps interpreting the *performance
    counters* of the system and thus understanding the root cause of why we experience
    performance regression.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java性能诊断模型**（**jPDM**）是一个性能诊断模型，它抽象了系统的复杂性。它有助于解释系统的**性能计数器**，从而理解我们为什么经历性能退化的根本原因。'
- en: The challenge with identifying performance regression is that a specific scenario
    is the result of innumerable influences, many of them external to the application.
    jPDM and the resulting methodologies helps dealing with that complexity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 识别性能退化的挑战在于，特定的场景是无数影响因素的结果，其中许多因素是与应用程序外部相关的。jPDM及其相关方法有助于处理这种复杂性。
- en: In terms of responsiveness, there is an infinite number of things that can go
    wrong, but they will go wrong in a finite number of ways. Performance regression
    can therefore be categorized into different manifestations. There will be a few
    typical forms of issues, emerging in innumerable, varying scenarios, and root
    causes. In order to identify the different categories, we will make use of the
    diagnostic model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应性方面，有无数的事情可能会出错，但它们将以有限的方式出错。因此，性能退化可以分类为不同的表现形式。将会有一些典型的问题形式，在无数、不同的场景和根本原因中涌现。为了识别不同的类别，我们将利用诊断模型。
- en: jPDM identifies important subsystems of our system, their roles, functions,
    and attributes. The subsystems interact with each other. The model helps to identify
    tools to measure levels of activity and interactions between the subsystems. Methodologies
    and processes that help to study and analyze systems and situations in regard
    to performance, fall out of this model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: jPDM识别我们系统的重要子系统、它们的角色、功能和属性。子系统之间相互交互。该模型有助于识别测量子系统活动水平和交互的工具。有助于研究和分析系统及情况的性能、方法和流程，都包含在这个模型中。
- en: Subsystems
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子系统
- en: 'The subsystems in a Java application environment are: the operating system,
    including hardware, the Java Virtual Machine, the application, and the actors.
    Subsystems utilize their corresponding, underlying subsystem to perform their
    tasks.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序环境中的子系统包括：操作系统（包括硬件）、Java虚拟机、应用程序和演员。子系统利用它们相应的底层子系统来执行它们的任务。
- en: 'The following diagram shows how the jPDM subsystems interact with each other:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了jPDM子系统之间是如何相互作用的：
- en: '![](img/ea6405ce-e28f-4b85-83b7-034a53748208.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea6405ce-e28f-4b85-83b7-034a53748208.png)'
- en: Actors
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: The actors are the users of the system in a broadest sense. This includes end
    users, batch processes, or external systems, depending on the use case.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 演员在广义上是指系统的用户。这包括最终用户、批处理过程或外部系统，具体取决于用例。
- en: By using the system, the actors will generate work load. The properties of the
    actors include the load factor, that is how many users are involved, as well as
    the velocity, that is how fast user requests are processed. These properties influence
    the overall situation similar to all other subsystem's properties.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用该系统，演员将生成工作负载。演员的特性包括负载因子，即涉及多少用户，以及速度，即用户请求的处理速度。这些特性会影响整体情况，类似于所有其他子系统的特性。
- en: The actors themselves don't represent a performance issue, they simply use the
    application. That said, if the system's performance isn't met, the limiting constraint
    is not to be searched for within the actors; the actors and the load they generate
    are part of the circumstances the system has to deal with.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 演员本身并不代表性能问题，他们只是使用应用程序。话虽如此，如果系统的性能未达到预期，限制性约束不应在演员中寻找；演员及其生成的工作负载是系统必须处理的情境的一部分。
- en: Application
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: The enterprise application contains the business logic algorithms. Part of the
    business use cases is to allocate memory, schedule threads, and use external resources.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序包含业务逻辑算法。部分业务用例包括分配内存、调度线程和使用外部资源。
- en: The application will use framework and Java language functionalities to fulfill
    this. It ultimately makes use of JVM code and configuration, directly or indirectly.
    By doing so, the application puts a certain load on the JVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将使用框架和Java语言功能来实现这一点。它最终直接或间接地使用JVM代码和配置，这样应用程序就对JVM产生了一定的负载。
- en: JVM
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM
- en: The **Java Virtual Machine** (**JVM**) interprets and executes the application
    byte code. It takes care of memory management--allocation as well as garbage collection.
    There are vast optimization techniques in place to increase the performance of
    the program, such as **Just-In-Time** (**JIT**) compilation of the Java HotSpot
    Performance Engine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java虚拟机**（**JVM**）解释并执行应用程序的字节码。它负责内存管理——包括分配以及垃圾回收。为了提高程序的性能，已经实施了许多优化技术，例如Java
    HotSpot性能引擎的**即时编译**（**JIT**）。'
- en: The JVM utilizes operating system resources to allocate memory, run threads,
    or use network or disk I/O.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JVM利用操作系统资源来分配内存、运行线程或使用网络或磁盘I/O。
- en: Operating system and hardware
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统和硬件
- en: A computer's hardware components such as CPU, memory, disk and network I/O,
    define the resources of a system. They contain certain attributes, such as capacities
    or speed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的硬件组件，如CPU、内存、磁盘和网络I/O，定义了系统的资源。它们包含某些属性，例如容量或速度。
- en: Since the hardware components represent non-shareable resources, the operating
    system provisions hardware between the processes. The operating system provides
    system-wide resources and schedule threads for the CPUs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于硬件组件代表不可共享的资源，操作系统在进程之间分配硬件。操作系统提供系统级资源并为CPU调度线程。
- en: For this reason, the model considers the overall system, including hardware.
    The enterprise application potentially doesn't run alone on the system's hardware.
    Other processes utilize hardware components and thus influence the application's
    performance. Multiple processes that simultaneously try to access the network
    will result in poorer responsiveness than running each of them independently.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该模型考虑了整个系统，包括硬件。企业应用程序可能不会单独在系统硬件上运行。其他进程使用硬件组件，从而影响应用程序的性能。同时尝试访问网络的多个进程将导致比独立运行每个进程更差的响应性。
- en: jPDM instances - production situations
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jPDM实例—生产情况
- en: Specific situations in a production system, are instances of the jPDM model.
    They contain all their properties, characteristics, and specific bottlenecks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 生产系统中的特定情况是jPDM模型的实例。它们包含所有它们的属性、特征和特定的瓶颈。
- en: Any change in one of the subsystems would result in a different situation with
    different properties and characteristics, thus in a different instance of the
    model. For example, changing the load on the system could result in a totally
    different bottleneck.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个子系统的任何变化都会导致具有不同属性和特征的不同情况，从而在模型中产生不同的实例。例如，改变系统负载可能会导致完全不同的瓶颈。
- en: This is also the reason why performance tests in environments other than production
    will result in potentially different bottlenecks. The different environment has
    at least a different OS and hardware situation, not necessarily in the hardware
    and configuration being used, but in the whole condition of OS processes. Simulated
    scenarios such as performance tests therefore don't allow conclusions about bottlenecks
    or performance optimizations. They represent a different jPDM instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么在生产环境之外的环境中进行性能测试可能会导致潜在的不同瓶颈。不同的环境至少有一个不同的操作系统和硬件情况，不一定是在使用的硬件和配置，而是在整个操作系统进程的状态。因此，模拟场景，如性能测试，不允许得出关于瓶颈或性能优化的结论。它们代表了一个不同的jPDM实例。
- en: Since we use the model to ultimately analyze performance issues, the following
    approaches only make sense when there are actual performance issues. If there
    is no issue, that is, the defined SLAs are met, there is nothing to investigate
    or act upon.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用该模型来最终分析性能问题，以下方法只有在存在实际性能问题时才有意义。如果没有问题，即定义的SLA得到满足，就没有什么需要调查或采取行动的。
- en: Analyzing the jPDM instances
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析jPDM实例
- en: jPDM is used to assist in investigating performance regression. Methodologies,
    processes and tools that fall out of the model help to identify limiting constraints.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: jPDM用于协助调查性能回归。模型之外的策略、流程和工具有助于识别限制性约束。
- en: Each subsystem with its distinct set of attributes and resources plays a specific
    role in the system. We use specific tools to both expose specific performance
    metrics and monitor interactions between subsystems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子系统都有其独特的属性和资源集，在系统中扮演着特定的角色。我们使用特定的工具来暴露特定的性能指标并监控子系统之间的交互。
- en: Looking back at the theory of constraints, we want to investigate the limiting
    constraint of a production situation, an instance of the jPDM. The tooling helps
    with investigating. It's important for the investigation to take the overall system
    into account. The hardware is shared by all operating system processes. The dominance,
    therefore, may be caused by a single process or the sum of all processes running
    on that hardware.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾约束理论，我们想要调查生产情况中的限制约束，即jPDM的一个实例。工具有助于进行调查。在调查中考虑整体系统是很重要的。硬件由所有操作系统进程共享。因此，主导性可能是由单个进程或在该硬件上运行的所有进程的总和引起的。
- en: First, we investigate the dominating consumer of the CPU and how the CPU is
    utilized. The CPU consumption pattern will lead us to the subsystem that contains
    the bottleneck.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调查CPU的主导消费者以及CPU的利用率。CPU消耗模式将引导我们到包含瓶颈的子系统。
- en: 'In order to investigate the dominating consumer, we make use of a decision
    tree. It indicates where the CPU time is spent - in kernel space, user space,
    or idling. The following diagram shows the decision tree:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查主导消费者，我们使用决策树。它指示CPU时间花费在哪里——在内核空间、用户空间还是空闲状态。以下图表显示了决策树：
- en: '![](img/d9c3ebf8-92cb-4a85-b606-62beb88093dc.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9c3ebf8-92cb-4a85-b606-62beb88093dc.png)'
- en: The round nodes in the graph represent the dominant consumers of the CPU. The
    colors represent the jPDM subsystems. Following the decision tree leads us to
    the subsystem that contains the bottleneck. Identifying the subsystem narrows
    down the performance regression to a specific category. We then use further tooling
    to analyze the instance of jPDM, the actual situation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的圆形节点代表CPU的主导消费者。颜色代表jPDM子系统。遵循决策树将引导我们到包含瓶颈的子系统。确定子系统将性能回归缩小到特定类别。然后我们使用进一步的工具来分析jPDM的实例，即实际情况。
- en: Since performance issues can originate from an infinite number of things, we
    need to follow a process to narrow down the causes. If we would not follow a process
    but blindly *peek and poke* or guess, we would not only waste time and effort
    but potentially wrongly identify symptoms as actual dominating constraints.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能问题可能源于无数的事物，我们需要遵循一个过程来缩小原因。如果我们不遵循一个过程，而是盲目地“窥视和戳探”或猜测，我们不仅会浪费时间和精力，而且可能会错误地将症状识别为实际的限制因素。
- en: The dominant consumers of the CPU represent where the CPU time is spent. This
    is an important information to investigate the situation. It's not sufficient
    to solely look at the overall amount of CPU utilization. This information alone
    neither gives us much evidence of the existence of a bottleneck or how much headroom
    there is, nor does it lead to the dominating consumer. A CPU usage of 60% doesn't
    tell us whether the CPU is the constraining resource, that is whether adding more
    CPU would improve the overall responsiveness. The CPU time needs to be analyzed
    in greater detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CPU的主导消费者表示CPU时间花费在哪里。这是调查情况的重要信息。仅仅查看CPU的整体利用率是不够的。仅此信息既不能给我们提供很多关于瓶颈存在与否的证据，也不能帮助我们找到主导消费者。CPU使用率为60%并不能告诉我们CPU是否是限制资源，也就是说，增加更多的CPU是否会提高整体响应速度。需要更详细地分析CPU时间。
- en: First, we look at the ratio between CPU user and system time. This indicates
    whether the CPU time is spent in the kernel for longer than expected and thus
    whether the operating system is the dominating consumer of the CPU.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看CPU用户时间和系统时间之间的比率。这表明CPU时间是否在内核中花费的时间比预期更长，从而判断操作系统是否是CPU的主导消费者。
- en: Dominating consumer - OS
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主导消费者 - 操作系统
- en: The operating system dominates the CPU consumption when it's asked to work harder
    than it usually should. This means that too much CPU time is spent on resource
    and device management. This includes network and disk I/O, locks, memory management,
    or context switches.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统被要求比通常应该工作得更努力时，它主导了CPU的消耗。这意味着过多的CPU时间被用于资源和管理设备。这包括网络和磁盘I/O、锁、内存管理或上下文切换。
- en: If the CPU system time is more than a certain percentage value of the user time,
    the operating system is the dominating consumer. The jPDM identified 10% as a
    threshold value, based on the experience of analyzing innumerable production situations.
    That means if the CPU system time is more than 10% of the user time, the bottlenecks
    are contained in the OS subsystem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CPU系统时间超过用户时间的某个百分比值，操作系统是主导消费者。jPDM根据分析无数生产情况的经验，将10%作为阈值值。这意味着如果CPU系统时间超过用户时间的10%，瓶颈包含在操作系统子系统内。
- en: In this case, we investigate the issue further using operating system tools,
    such as `vmstat`, `perf`, `netstat`, and others.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用操作系统工具进一步调查问题，例如`vmstat`、`perf`、`netstat`等。
- en: For example, an enterprise application that retrieves database entries with
    a huge number of individually executed queries puts lots of pressure on the operating
    system in managing all these database connections. The overhead spent on establishing
    each and every network connection will eventually dominate the overall system
    and represent the constraining resource in the system. Investigating this situation
    thus shows a big share of CPU time spent in the kernel where the network connections
    are established.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个企业应用程序通过执行大量单独查询检索数据库条目，给操作系统管理所有这些数据库连接带来了很大压力。建立每个网络连接所花费的额外开销最终会主导整个系统，并代表系统中的约束资源。因此，调查这种情况显示了在内核中建立网络连接时花费了大量CPU时间。
- en: Dominating consumer - none
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主导消费者 - 无
- en: If the CPU time didn't identify the OS to be the dominating consumer, we follow
    the decision tree further and analyze whether the CPU is idling. If that is the
    case, it means there is still CPU time available that cannot be consumed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CPU时间没有确定操作系统是主导消费者，我们继续遵循决策树并分析CPU是否空闲。如果是这种情况，这意味着还有CPU时间可用，但无法消耗。
- en: Since we are analyzing a situation where the SLA is not met, that is, the overall
    system is in a situation where it doesn't perform well enough for the given load,
    a well-saturated situation would fully utilize the CPU. Idling CPU times thus
    indicates a liveliness issue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在分析SLA未满足的情况，即整体系统在给定负载下表现不佳，一个充分饱和的情况将充分利用CPU。因此，空闲CPU时间表明存在活跃性问题。
- en: What needs to be investigated is why the threads are not scheduled by the operating
    system. This can have multiple causes, such as empty connection or thread pools,
    deadlock situations, or slow responding external systems. The state of the threads
    will indicate the cause of the constraint. We again use operating system tooling
    to investigate the situation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调查的是为什么线程没有被操作系统调度。这可能有多个原因，例如空连接或线程池、死锁情况或响应缓慢的外部系统。线程的状态将指示约束的原因。我们再次使用操作系统工具来调查这种情况。
- en: An example for this category of issues is when an external system that responds
    slowly is accessed synchronously. It will lead to threads that are waiting for
    network I/O and can't run. This is the difference to dominating OS consumption,
    that the thread is not actively executing work but waiting to get scheduled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题类别的一个例子是当同步访问响应缓慢的外部系统时。这将导致等待网络I/O的线程无法运行。这与主导操作系统消耗的区别在于，线程不是积极执行工作而是在等待被调度。
- en: Dominating consumer - JVM
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主导消费者 - JVM
- en: The dominating consumers so far weren't contained in the application or JVM
    subsystems. If the CPU time is not overly spent in the kernel or idling, we start
    investigations in the JVM.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，主导消费者不包含在应用程序或JVM子系统内。如果CPU时间没有过多地花费在内核或空闲，我们开始在JVM中进行调查。
- en: Since the JVM is responsible for memory management, its performance will indicate
    potential memory issues. Mainly **Garbage Collection** (**GC**) logs, together
    with **JMX** tooling help investigate scenarios.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JVM负责内存管理，其性能将指示潜在的内存问题。主要**垃圾收集**（**GC**）日志，以及**JMX**工具帮助调查场景。
- en: Memory leaks will lead to increasing memory usage and excessive garbage collector
    runs that occupy the CPU. Inefficient memory usage will equally lead to excessive
    garbage collections. The GC executions ultimately cause the JVM being the dominating
    consumer of the CPU.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏会导致内存使用量增加和垃圾收集器运行过度，占用CPU资源。不高效的内存使用同样会导致垃圾收集过度。GC执行最终导致JVM成为CPU的主导消费者。
- en: This is another example of why it's important to follow the process of the jPDM
    decision tree. The performance issue arises in high CPU usage, although the actual
    bottleneck in this case is the memory leak.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是为什么遵循jPDM决策树流程很重要的另一个例子。性能问题出现在高CPU使用率中，尽管在这种情况下实际的瓶颈是内存泄漏。
- en: As of today, the main cause of performance issues are related to memory, mostly
    from application logging that results in extensive string object creation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，性能问题的主要原因是与内存相关，主要是由于应用程序日志导致的广泛字符串对象创建。
- en: Dominating consumer - application
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主消费者—应用程序
- en: If the JVM analysis didn't indicate a memory issue, finally the application
    is the dominating consumer of the CPU. This means that the application code itself
    is responsible for the bottleneck. Especially applications that run sophisticated
    algorithms excessively utilize the CPU.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JVM分析没有表明内存问题，最终应用程序是CPU的主消费者。这意味着应用程序代码本身负责瓶颈。特别是运行复杂算法过多的应用程序过度利用CPU。
- en: Application-related profiling will lead to conclusions where in the application
    the issue originates and how the issue might be resolved. This means that the
    application either contains suboptimal code or reached the possible limit with
    the given resources, and ultimately needs to be scaled horizontally or vertically.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序相关的分析将导致以下结论：问题起源于应用程序的哪个部分以及问题可能如何解决。这意味着应用程序要么包含次优代码，要么在给定资源下达到了可能的极限，最终需要水平或垂直扩展。
- en: Conclusion
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The approach of solving performance issues is to try to characterize the regression
    first by investigating the situation by following a specific process. After the
    constraining resource has been identified, further steps to resolve the situation
    are applied. After potentially fixing the situation, the measurement in production
    needs to be repeated. It's important to not change behavior or configuration without
    the verification that the changes in fact provide the expected results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解决性能问题的方法是首先通过遵循特定流程来调查情况，尝试通过调查来表征回归。在确定了限制性资源之后，再采取进一步步骤来解决问题。在可能修复了情况之后，需要在生产中进行重复测量。重要的是不要在没有验证这些更改确实提供了预期结果的情况下更改行为或配置。
- en: The jPDM approach investigates performance regression without considering the
    application's code, by applying a uniform solving process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: jPDM方法通过应用统一的解决流程，不考虑应用程序代码来调查性能回归。
- en: What tools and metrics are needed to apply this approach?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要哪些工具和指标来应用这种方法？
- en: Depending on the system in production, tools that ship with the operating system,
    as well as Java Runtime-related tools, are useful. Since all aspects consider
    the overall system at the operating system level rather than just the application
    alone, operating system tools and lower-level metrics are more helpful than application-specific
    ones.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据生产中的系统，操作系统自带工具以及与Java运行时相关的工具都是有用的。由于所有方面都考虑了操作系统级别的整体系统，而不仅仅是应用程序本身，因此操作系统工具和底层指标比特定于应用程序的工具更有帮助。
- en: However, the technical metrics of the application, such as response time or
    throughput, are the first place of focus that indicate the application's quality
    of service. If these metrics indicate a performance issue, then it makes sense
    to investigate using lower-level metrics and tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序的技术指标，如响应时间或吞吐量，是首先关注的焦点，它们表明了应用程序的服务质量。如果这些指标表明存在性能问题，那么使用底层指标和工具进行调查是有意义的。
- en: The next section examines how to gather the application's technical metrics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨如何收集应用程序的技术指标。
- en: Technical metrics
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术指标
- en: Technical metrics indicate the load and responsiveness of the system. Prime
    examples for these metrics are the response time, as well as the throughput, often
    gathered as requests or transactions per second, respectively. They provide information
    about how the overall system currently performs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 技术指标表明系统的负载和响应能力。这些指标的典型例子包括响应时间以及吞吐量，通常分别以每秒请求数或事务数的形式收集。它们提供了关于整体系统当前性能的信息。
- en: These metrics will ultimately have an impact on other, business-related metrics.
    At the same time, as we have seen in the previous section, these metrics are just
    indicators and themselves affected by a lot of other technical aspects, namely
    all properties of jPDM subsystems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标最终将对其他与业务相关的指标产生影响。同时，正如我们在上一节中看到的，这些指标只是指标，并且自身受到许多其他技术方面的影响，即jPDM子系统的所有属性。
- en: Therefore, an application's performance is impacted by a lot of technical influences.
    Thus, the question is, which technical metrics besides response time, throughput,
    error rates, and uptime should reasonably be collected?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序的性能受到许多技术因素的影响。那么，除了响应时间、吞吐量、错误率和正常运行时间之外，还应该合理收集哪些技术指标呢？
- en: Types of technical metrics
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术指标的类型
- en: Technical metrics are primarily concerned with the quality of the application's
    service, such as response times or throughput. They are the indicators that represent
    the application's responsiveness and may point out potential performance issues.
    The information can be used to create statistics about trends and application
    peaks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 技术指标主要关注应用程序服务的质量，如响应时间或吞吐量。它们是代表应用程序响应性的指标，可能指出潜在的性能问题。这些信息可以用来创建关于趋势和应用程序高峰的统计数据。
- en: This insight increases the likelihood of foreseeing potential outages and performance
    issues in a timely manner. It is the technical equivalent of business insights
    into the otherwise black box system. These metrics alone allow no sound conclusions
    about the root cause or constraining resources in the case of performance issues.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种洞察增加了及时预见潜在故障和性能问题的可能性。这在技术上等同于对其他方面是黑盒系统的业务洞察。这些指标本身并不能得出关于性能问题的根本原因或约束资源的可靠结论。
- en: Lower-level technical information includes resource consumption, threading,
    pooling, transactions, or sessions. It's again important to mention that this
    information alone does not direct the engineers to potential bottlenecks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 低级技术信息包括资源消耗、线程、池化、事务或会话。再次强调，仅凭这些信息并不能直接指导工程师找到潜在的瓶颈。
- en: As shown previously, it's necessary to inspect the overall situation with everything
    running on specific hardware. The operating system information provides the best
    source of information. In order to solve performance issues, the operating system,
    as well as application tools, are required to take this into account.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有必要检查在特定硬件上运行的所有内容的整体情况。操作系统信息是最佳的信息来源。为了解决性能问题，操作系统以及应用程序工具都需要考虑这一点。
- en: This doesn't mean that the technical information emitted by the application
    or the JVM runtime has no value at all. The application-specific metrics can assist
    in solving performance issues. It's important to keep in mind that these metrics
    alone will lead to potentially wrong assumptions about what the constraining resources
    are when a system needs to be performance-tuned.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着应用程序或JVM运行时发出的技术信息毫无价值。应用程序特定的指标可以帮助解决性能问题。重要的是要记住，仅凭这些指标可能会导致关于系统性能调整时约束资源的错误假设。
- en: High frequency monitoring versus sampling
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高频监控与采样
- en: Often, monitoring aims to collect technical metrics with a high frequency of
    many collections per second. The problem with this high frequency collection is
    that it heavily impacts the performance of the system. Metrics often get collected
    even if there is no performance regression.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，监控的目的是以每秒多次收集的方式收集高频技术指标。这种高频收集的问题在于它严重影响了系统的性能。即使没有性能退化，指标也可能被收集。
- en: As mentioned, application-level metrics, such as resource consumption, alone
    don't help much in identifying potential performance constraints. In the same
    way, the collection disrupts the responsiveness of the system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，仅凭应用程序级别的指标，如资源消耗，在识别潜在的性能约束方面帮助不大。同样，收集数据会干扰系统的响应性。
- en: Instead of monitoring with a high frequency it's advisable to sample metrics
    with lower frequency, such as for only a few times per minute. The theory behind
    statistical populations shows that these few samples represent the population
    of data well enough.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与高频监控相比，建议以较低频率采样指标，例如每分钟仅采样几次。统计总体背后的理论表明，这些少量样本足以代表总体数据。
- en: Sampling the information should have as little impact on the application's performance
    as possible. All subsequent investigations, or metrics querying or calculations
    should happen out-of-band; that is, outsourced to a system that does not impact
    the running application. The concerns for sampling the information from storing,
    querying, and displaying it, are thus separated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 采样信息应尽可能少地影响应用程序的性能。所有后续的调查、指标查询或计算都应该在带外进行；也就是说，外包给一个不会影响运行应用程序的系统。因此，从存储、查询和显示信息中分离出采样信息的担忧。
- en: Collecting technical metrics
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集技术指标
- en: The application is a good place to gather the technical metrics, ideally at
    the system boundaries. It's equally possible to collect these in a potential proxy
    server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是收集技术指标的好地方，理想情况下是在系统边界处。同样有可能在潜在的代理服务器中收集这些指标。
- en: The application server already emits technically-relevant metrics such as information
    about resource consumption, threading, pooling, transactions, or sessions. Some
    solutions also provide Java agents that sample and emit technically-relevant information.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务器已经发出了一些技术相关的指标，例如关于资源消耗、线程、连接池、事务或会话的信息。一些解决方案还提供了Java代理，用于采样和发出技术相关的信息。
- en: Traditionally, application servers are required to make technically relevant
    metrics available via JMX. This functionality is part of the Management API, but
    has never been used much in projects. One of the reasons for this is that the
    model and API are quite cumbersome.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序服务器需要通过JMX提供技术相关的指标。这个功能是管理API的一部分，但在项目中从未被广泛使用。其中一个原因是模型和API相当繁琐。
- en: However, it's helpful to mention that Java EE application servers are required
    to gather and provide data about its resources. The container emits this information
    via JMX. There are several ways to scrape this information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提到Java EE应用程序服务器需要收集和提供其资源的数据是有帮助的。容器通过JMX发出这些信息。有几种方法可以抓取这些信息。
- en: There are so-called exporters available, applications that either run standalone
    or as **Java agents**, that access the JMX information and emit it via HTTP. The
    Prometheus JMX exporter, which exports the information in a similar format as
    shown previously, is an example of this. The benefit of this approach is that
    it doesn't add dependencies into the application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有所谓的导出器可用，这些应用程序要么作为独立运行，要么作为**Java代理**运行，它们访问JMX信息并通过HTTP发出。例如，Prometheus JMX导出器，它以前面的类似格式导出信息，就是这种方法的例子。这种方法的好处是它不会向应用程序添加依赖项。
- en: The installation and configuration of Java agents is done in the application
    server, in a base container image layer. This once again emphasizes the principle
    that containers should not couple the application's artifact with implementation
    details.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java代理的安装和配置是在应用程序服务器中完成的，在基本容器镜像层中。这再次强调了容器不应将应用程序的工件与实现细节耦合的原则。
- en: Boundary metrics
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界指标
- en: Technical metrics that are application-specific, such as response times, throughput,
    uptime, or error rates can be gathered at the system boundaries. This can happen
    via the interceptors or filters, depending on the situation. HTTP-relevant monitoring
    can be collected via a servlet filter for any technology that builds upon servlets,
    such as JAX-RS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 专门针对应用程序的指标，例如响应时间、吞吐量、正常运行时间或错误率，可以在系统边界处收集。这可以通过拦截器或过滤器来实现，具体取决于情况。与HTTP相关的监控可以通过servlet过滤器收集，适用于任何基于servlet技术的技术，例如JAX-RS。
- en: 'The following code snippet shows a servlet filter that gathers the response
    time and throughput in a Prometheus histogram metrics:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个servlet过滤器，它收集了Prometheus直方图指标中的响应时间和吞吐量：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This metric is registered similarly to the business-related example previously,
    and emitted via the Prometheus output format. The histogram buckets collect the
    time in four buckets, with the specified times from 0.1, 0.4, or 1.0 seconds,
    and everything above. These bucket configurations need to be adapted to the SLAs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此指标与之前提到的与业务相关的示例类似注册，并通过Prometheus输出格式发出。直方图桶收集四个桶中的时间，指定的时间为0.1、0.4或1.0秒，以及以上所有时间。这些桶配置需要根据SLA进行调整。
- en: The servlet filter is active on all resource paths and will collect the statistics,
    qualified by each path.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: servlet过滤器在所有资源路径上都是激活的，并将收集每个路径的统计数据。
- en: Logging and tracing
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和跟踪
- en: Historically, logging had quite high importance in enterprise applications.
    We have seen a lot of logging framework implementations and supposedly best practices
    on how to implement reasonable logs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，日志在企业应用程序中具有相当高的重要性。我们看到了许多日志框架的实现和关于如何实现合理日志的所谓最佳实践。
- en: Logging is typically used for debugging, tracing, journaling, monitoring, and
    outputting errors. In general, all information that developers consider somewhat
    important, but not made apparent to the users, is been placed into logs. In almost
    all cases, this includes logging to files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 日志通常用于调试、跟踪、日志记录、监控和输出错误。一般来说，所有开发者认为相对重要但未向用户明确显示的信息都被放入日志中。在几乎所有情况下，这包括将日志记录到文件中。
- en: Shortcomings of traditional logging
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统日志的不足
- en: This approach, which is way too common in enterprise projects, comes with a
    few problems.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在企业项目中非常常见的方法带来了一些问题。
- en: Performance
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Traditional logging, especially extensively used logging invocations, creates
    a lot of string objects. Even APIs such as **Slf4J** that aim to reduce unnecessary
    string concatenation will result in high memory rates. All these objects need
    to be garbage collected after their use, which utilizes the CPU.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的日志记录，尤其是广泛使用的日志调用，会创建大量的字符串对象。即使是旨在减少不必要的字符串连接的API，如**Slf4J**，也会导致高内存率。所有这些对象在使用后都需要进行垃圾回收，这会利用CPU。
- en: Storing log events as string messages is a verbose way of storing information. Choosing
    different formats, mainly binary formats would drastically reduce the message
    size and result in more efficient memory consumption and higher throughput.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志事件存储为字符串消息是一种冗长的信息存储方式。选择不同的格式，主要是二进制格式，将大大减少消息大小，并导致更高效的内存消耗和更高的吞吐量。
- en: Log messages that are stored in a buffer or directly on disk need to be synchronized
    with other log invocations. Synchronous loggers ultimately cause a file to be
    written within a single invocation. All simultaneous log invocations need to be
    synchronized in order to ensure that logged events appear in the right order. This
    presents the issue that synchronization indirectly couples functionality that
    otherwise is completely unrelated. It decreases the parallelism of intrinsically
    independent functionality and has a negative overall performance impact. With
    a high number of log messages being written, the probability of blocking threads
    due to synchronization increases.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在缓冲区或直接在磁盘上的日志消息需要与其他日志调用同步。同步日志记录器最终会导致文件在单个调用中写入。所有同时进行的日志调用都需要同步，以确保记录的事件按正确顺序出现。这间接地将原本完全无关的功能耦合在一起，降低了本质上独立的函数的并行性，并对整体性能产生负面影响。随着日志消息数量的增加，由于同步导致的线程阻塞概率也会增加。
- en: Another issue is that logging frameworks usually don't write the log messages
    to disk directly; rather, they use several layers of buffering. This optimization
    technique comes with certain management overhead involved that does not improve
    the situation either. Synchronous file operations advisably work with the least
    overhead layers as possible.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于，日志框架通常不会直接将日志消息写入磁盘；相反，它们使用多层缓冲。这种优化技术伴随着一定的管理开销，这并不会改善情况。建议同步文件操作尽可能与最小开销的层一起工作。
- en: Log files that reside on NFS storage decrease the overall performance even more,
    since the write operation hits the operation system I/O twice, with both file
    system and network calls involved. In order to manage and persist log files, network
    storage is an often chosen solution, especially for container orchestration that
    needs persisted volumes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 位于NFS存储上的日志文件会进一步降低整体性能，因为写操作会两次击中操作系统I/O，涉及文件系统和网络调用。为了管理和持久化日志文件，网络存储通常是首选解决方案，特别是对于需要持久卷的容器编排。
- en: In general, experience shows that logging has the biggest impact in an application's
    performance. This is mostly due to the memory impact on string log messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，经验表明，日志对应用程序性能的影响最大。这主要是因为字符串日志消息对内存的影响。
- en: Log levels
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志级别
- en: Logging solutions include the ability to specify the importance of a log entry
    via log levels, such as *debug*, *info*, *warning,* or *error*. Developers might
    ask themselves which log level to choose for specific invocations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 日志解决方案包括通过日志级别指定日志条目的重要性，例如 *debug*、*info*、*warning* 或 *error*。开发者可能会问自己为特定调用选择哪个日志级别。
- en: The approach of having several layers certainly sounds reasonable, since production
    systems can specify a higher log level than development runs, so as not to produce
    too much data in production.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个层级的做法听起来确实合理，因为生产系统可以指定比开发运行更高的日志级别，这样就不会在生产中产生太多数据。
- en: The challenge with this situation is that in production there is usually no
    debug log information available when it's needed. Potential error situations that
    could need additional insights don't have this information available. Debug or
    trace log levels that include tracing information are switched off.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下的挑战是，在生产环境中，通常在需要时没有可用的调试日志信息。可能需要额外洞察的错误情况没有这方面的信息。包含跟踪信息的调试或跟踪日志级别被关闭。
- en: Choosing log levels is always a trade-off regarding what information should
    be included. Debugging in development is done best using actual debug tools which
    connect against running applications, potentially remotely. Debug or trace logs
    are usually not available in production and therefore provide little benefit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日志级别始终是在关于应包含哪些信息之间进行权衡。在开发中进行调试最好使用实际的调试工具，这些工具连接到正在运行的应用程序，可能是在远程。调试或跟踪日志在生产环境中通常不可用，因此提供的益处很少。
- en: Whereas defining multiple log levels may have emerged from a good intention,
    the practical use in production systems adds little value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定义多个日志级别可能源于良好的意图，但在生产系统中的实际使用添加的价值很少。
- en: Log format
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志格式
- en: Traditional logging solutions specify particular log layouts that format the
    log messages in the resulting log file. The application needs to manage the creation,
    rolling, and formatting of log files that are not relevant for the business logic.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的日志解决方案指定特定的日志布局，该布局将日志消息格式化到生成的日志文件中。应用程序需要管理创建、滚动和格式化与业务逻辑无关的日志文件。
- en: Quite a few enterprise applications ship with third-party logging dependencies
    that implement this functionality, but provide no business value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业应用程序都附带第三方日志依赖项，这些依赖项实现了这种功能，但没有任何业务价值。
- en: Choosing particular plain text log formats is another decision that needs to
    be made by the application developers. There is a trade-off between a log entry
    format that is readable by both humans and machines. The result is usually the
    worst compromise for both parties; string log formats that are both hardly readable
    and have a tremendous impact on the system's performance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 选择特定的纯文本日志格式是应用程序开发者需要做出的另一个决定。在可由人类和机器读取的日志条目格式和系统性能之间存在着权衡。结果通常是双方都不满意的最差妥协；既难以阅读又对系统性能有巨大影响的字符串日志格式。
- en: It would be more reasonable to choose binary formats that store information
    with the highest density. Humans then could use tooling to make the messages visible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 选择以最高密度存储信息的二进制格式会更合理。然后，人类可以使用工具使消息可见。
- en: Amounts of data
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据量
- en: Extensive logging introduces a huge amount of data that is contained in log
    files. In particular, logs that are used for debugging and tracing purposes result
    in big files that are cumbersome and expensive to parse.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大量日志引入了包含在日志文件中的大量数据。特别是，用于调试和跟踪目的的日志会导致大文件，这些文件难以解析且成本高昂。
- en: Parsing log formats in general introduces an avoidable overhead. Information
    that is potentially technically-relevant is serialized in a specific format first,
    just to be parsed again later when inspecting the logs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解析日志格式会引入不必要的开销。可能具有技术相关性的信息首先以特定格式序列化，只是为了在稍后检查日志时再次解析。
- en: Later in this sub-section, we will see what other solutions there are.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节稍后，我们将看到其他有哪些解决方案。
- en: Obfuscation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆
- en: Equal to unreasonably checked exception handling, logging obfuscates business
    logic in the source code. This is especially the case for boilerplate log patterns
    that are common in many projects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与不合理检查的异常处理一样，日志会模糊源代码中的业务逻辑。这在许多项目中常见的样板日志模式中尤其如此。
- en: Log statements take up too much space in the code and especially draw the developer's
    attention.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 日志语句在代码中占用太多空间，尤其是会吸引开发者的注意力。
- en: Some logging technology, such as Slf4j, provides functionality to format strings
    in readable ways while avoiding immediate string concatenation. But still, log
    statements add obfuscating invocations that are unrelated to the business problem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志技术，如Slf4j，提供了以可读方式格式化字符串的功能，同时避免了立即的字符串连接。但是，日志语句仍然添加了与业务问题无关的模糊调用。
- en: This is obviously less the case if the debug log statements are added in a cross-cutting
    component, such as an interceptor. However, these cases mostly add logging for
    tracing purposes. We will see in the next sub-section that there are more suitable
    solutions for this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在横切组件（如拦截器）中添加调试日志语句，情况显然就不太一样了。然而，这些情况大多是为了跟踪目的而添加日志。我们将在下一小节中看到，有更多适合这种需求的解决方案。
- en: The concerns of applications
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的担忧
- en: As we have seen in 12-factor applications, it is not an application's concern
    to choose log files and message formats.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在12因子应用程序中看到的，选择日志文件和消息格式不是应用程序的担忧。
- en: In particular, logging frameworks that promise simpler logging solutions add
    technically-motivated third-party dependencies to the application; dependencies
    that have no direct business value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是那些承诺提供更简单日志解决方案的日志框架，会将技术驱动的第三方依赖项添加到应用程序中；这些依赖项没有直接的业务价值。
- en: If there is business value in events or messages, then the use of another solution
    should be favored. The following shows how traditional logging is misused for
    these other applications' concerns.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件或消息具有业务价值，那么应该优先考虑使用其他解决方案。以下展示了传统日志是如何被误用于这些其他应用程序的担忧。
- en: Wrong choice of technology
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术选择不当
- en: Traditional logging, and how it is used in the majority of enterprise projects,
    is a suboptimal choice for concerns that are better handled using different approaches.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传统日志，以及它在大多数企业项目中的使用方式，对于更适合使用不同方法处理的问题来说，是一个次优选择。
- en: 'The question is: what do developers want to log, anyway? What about metrics,
    such as the current resource consumption? Or business-related information, such
    as *car manufactured*? Should we log debugging and tracing information such as
    *request with UUID xy originated from application A, and called subsequent application
    B*? What about occurring exceptions?'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：开发者到底想记录什么？比如，关于当前资源消耗的指标？或者与业务相关的信息，比如*制造的汽车*？我们应该记录像*由应用程序A发起，调用后续应用程序B的请求*这样的调试和跟踪信息吗？关于发生的异常呢？
- en: Attentive readers will see that most of the use cases for traditional logging
    are far better handled using other approaches.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读的读者会发现，对于传统日志记录的大多数用例，使用其他方法处理会更好。
- en: If logging is used for debugging or debug tracing applications, the approach
    with using trace or debug levels doesn't help much. Information that will not
    be available in production can't reproduce a potential bug. Logging a huge amount
    of debug or trace events in production, however, will affect the application's
    responsiveness due to disk I/O, synchronization, and memory consumption. Debugging
    concurrency-related errors may even lead to a different outcome, due to the modified
    order of execution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志用于调试或调试跟踪应用程序，使用跟踪或调试级别的做法帮助不大。在生产环境中不可用的信息无法重现潜在的错误。然而，在生产环境中记录大量调试或跟踪事件，由于磁盘I/O、同步和内存消耗，将影响应用程序的响应性。调试与并发相关的错误甚至可能导致不同的结果，因为执行顺序已被修改。
- en: For debugging functionality, it's much more advisable to use actual debugger
    features during development, such as IDEs that connect against a running application.
    Logging that is used for business-motivated journaling is better accomplished
    via a proper journaling solution, as we will see later in this chapter. The plain
    text log messages are certainly not the ideal solution. The chosen technology
    should minimize the performance impact on the application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试功能，在开发期间使用实际的调试器功能（如连接到运行中的应用程序的IDE）更为可取。用于业务动机的日志记录，如我们将在本章后面看到的，最好通过适当的日志记录解决方案来完成。纯文本日志消息当然不是理想的解决方案。选择的技术应尽量减少对应用程序的性能影响。
- en: Another approach to realize the same motivations behind journaling is to introduce
    event sourcing. This makes the domain events part of the application's core model.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实现日志记录背后相同动机的另一种方法是引入事件溯源。这使得领域事件成为应用程序核心模型的一部分。
- en: Business-motivated tracing, this should be part of the business use case as
    well, implemented using an adequate solution. As we will see in the next sub-section,
    there are more suitable tracing solutions that require less parsing and have a
    smaller performance impact. Tracing solutions also support the consolidation of
    information and requests across microservices.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由业务动机驱动的跟踪，这也应该是业务用例的一部分，使用适当的解决方案实现。正如我们将在下一小节中看到的，有更多适合的跟踪解决方案，这些解决方案需要更少的解析，并且性能影响更小。跟踪解决方案还支持跨微服务的信息和请求的整合。
- en: Monitoring information that is stored in log messages is better managed via
    the use of proper monitoring solutions. This approach is not just much more performant,
    it is also a more effective way of emitting the information in proper data structures.
    The examples we have seen earlier in this chapter illustrate monitored data and
    possible solutions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在日志消息中的监控信息，通过使用适当的监控解决方案来管理会更好。这种方法不仅性能更佳，而且也是以适当的数据结构发出信息更有效的方式。本章前面看到的例子说明了监控数据和可能的解决方案。
- en: Logging is also traditionally being used to output exceptions and errors that
    cannot properly be handled in the application otherwise. This is arguably the
    only reasonable use of logging. Together with other potential metrics that may
    capture the error, such as error rate counters at the system boundary, the logged
    exception may support developers in investigating errors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录也传统上被用来输出那些在应用程序中无法适当处理的异常和错误。这可以说是日志记录的唯一合理用途。结合其他可能捕获错误的潜在指标，例如系统边界的错误率计数器，记录的异常可能有助于开发者调查错误。
- en: However, errors and exceptions should only be logged if they in fact concern
    the application and represent an error that can be resolved by developers. With
    monitoring and alerting solutions in place, the need to look into logs should
    indicate a serious problem with the application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有当错误和异常确实与应用程序相关，并且可以由开发者解决时，才应该记录它们。在部署了监控和警报解决方案的情况下，查看日志的需求应表明应用程序存在严重问题。
- en: Logging in a containerized world
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化世界的日志记录
- en: One of the 12-factor principles is to treat logging as a stream of events. This
    includes the idea that handling log files should not be a concern of the enterprise
    application. Log events should simply output to the process' standard output.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 12个因素原则之一是将日志视为事件流。这包括处理日志文件不应是企业应用程序关注点的想法。日志事件应简单地输出到进程的标准输出。
- en: The application's runtime environment consolidates and processes the log streams.
    There are solutions for unified access over all participating applications that
    can be deployed into the environment. The runtime environment where the application
    is deployed takes care of processing the log streams. **fluentd**, which is part
    of the Cloud Native Computing Foundation unifies the access to log events in a
    distributed environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的运行环境会整合和处理日志流。有针对所有参与应用程序的统一访问解决方案，可以部署到环境中。应用程序部署的运行环境负责处理日志流。**fluentd**，作为云原生计算基金会的一部分，统一了分布式环境中日志事件的访问。
- en: Application developers should treat the used logging technology as simply as
    possible. The application container is configured to output all server and application
    log events to standard output. This approach simplifies matters for enterprise
    developers and enables them to focus more on solving actual business problems.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者应尽可能简单地将使用的日志技术视为一种工具。应用程序容器被配置为将所有服务器和应用程序日志事件输出到标准输出。这种方法简化了企业开发者的工作，并使他们能够更多地关注解决实际业务问题。
- en: As we have seen, there is not much information left that application developers
    reasonably can log in a traditional way. Monitoring, journaling, or tracing solutions,
    as well as event sourcing, can solve the requirements in more suitable ways.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在传统方式下，应用程序开发者合理可以记录的信息并不多。监控、日志记录或跟踪解决方案，以及事件溯源，可以以更合适的方式解决需求。
- en: Together with logging to standard output without the need for sophisticated
    log file handling, there is no need for sophisticated logging framework. This
    supports zero-dependency applications and enables developers to be able to focus
    on business concerns instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与无需复杂日志文件处理的输出到标准输出的日志记录相结合，就没有必要使用复杂的日志框架。这支持零依赖的应用程序，并使开发者能够专注于业务关注点。
- en: It's therefore advisable to avoid third-party logging frameworks, as well as
    writing to traditional log files. The need to manage log rotations, log entry
    formats, levels, and framework dependencies, as well as configuration, becomes
    no longer necessary.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议避免使用第三方日志框架，以及写入传统的日志文件。管理日志轮换、日志条目格式、级别和框架依赖，以及配置的需求，就不再必要了。
- en: However, the following might seem antithetical to enterprise developers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下内容可能对企业开发者来说似乎有些矛盾。
- en: The straightforward, 12-factor way to log the output is using the standard output
    capabilities of Java via `System.out` and `System.err`. This directly writes the
    synchronous output without needless layers of buffering.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java的`System.out`和`System.err`标准输出能力是记录输出的简单、12因素方法。这直接写入同步输出，而没有不必要的缓冲层。
- en: It's important to mention that outputting data via this approach will not perform.
    The introduced synchronization, again, ties otherwise independent parts of the
    application together. If the output of the process is grabbed and emitted by a
    video card, the performance will further decrease.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，通过这种方法输出数据将不会执行。引入的同步，再次将应用程序中原本独立的各个部分联系在一起。如果将进程的输出抓取并由显卡发出，性能将进一步降低。
- en: Logging to console is only meant to emit errors that are, as the name of the
    Java type indicates - an exception. In all other cases, engineers must ask themselves
    why they want to output an information in the first place, or whether other solutions
    are more suitable. Therefore, logged errors should indicate a fatal problem that
    requires engineering action. It should not be expected to receive this log output
    in production; in this fatal error case, performance can be disrespected.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录到控制台仅意味着输出异常，正如Java类型的名称所表明的——异常。在其他所有情况下，工程师必须问自己为什么一开始就想输出信息，或者是否有其他更合适的解决方案。因此，记录的错误应表明一个需要工程行动的致命问题。不应期望在生产环境中接收到此日志输出；在这种情况下，性能可能会受到忽视。
- en: 'In order to output fatal error information, Java EE applications can use CDI
    features as well as Java SE 8 functional interfaces to provide a uniform logging
    functionality:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输出致命错误信息，Java EE应用程序可以使用CDI特性以及Java SE 8功能接口来提供统一的日志功能：
- en: '[PRE5]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Consumer<Throwable>` logger is then injectable in other beans, and it
    logs using the `accept()` method of the consumer type. If a more readable interface
    is desired, a thin logger facade type which is injected via `@Inject` can be defined
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Consumer<Throwable>`日志记录器可以注入到其他bean中，并使用消费者类型的`accept()`方法进行日志记录。如果希望有一个更易读的接口，可以通过`@Inject`注入定义一个薄的日志记录器外观类型，如下所示：
- en: '[PRE6]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach will seem antithetical to enterprise developers, especially logging
    without using a logging framework. Using a sophisticated logging framework, which
    is used to direct the output to standard out again, introduces overhead, which
    ultimately ends up in the same result. Some developers may prefer to use JDK logging
    at this point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于企业开发者来说可能看起来是反直觉的，尤其是在不使用日志框架的情况下进行日志记录。使用复杂的日志框架，该框架用于将输出再次定向到标准输出，引入了开销，最终导致相同的结果。一些开发者可能此时更喜欢使用JDK日志。
- en: However, providing sophisticated log interfaces and thus giving application
    developers the opportunity to output all kinds of information, especially human-readable
    strings, is counterproductive. This is why the code examples only allow to output
    throwable types in fatal error situations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提供复杂的日志接口，从而给应用程序开发者提供输出各种信息的机会，特别是可读性强的字符串，是适得其反的。这就是为什么代码示例只允许在致命错误情况下输出可抛出类型。
- en: 'It''s important to notice the following few aspects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意以下几个方面：
- en: Traditional logging should be avoided and substituted with more-suited solutions
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应避免传统的日志记录，并使用更适合的解决方案
- en: Only fatal error cases that are the exception, and are expected to ideally never
    happen, should be logged
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有那些例外情况，即理想情况下永远不会发生，的致命错误情况才应该被记录
- en: Containerized applications are advised to output log events to standard out
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议容器化应用程序将日志事件输出到标准输出
- en: Application logging and interfaces should be as simple as possible, preventing
    developers from excessive use
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志和接口应尽可能简单，防止开发者过度使用
- en: Journaling
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: If journaling is needed as part of the business logic, there are better ways
    than using logging frameworks. The requirements for journaling could be auditing
    regulations, such as is the case for trading systems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要作为业务逻辑一部分的日志记录，有比使用日志框架更好的方法。日志记录的要求可能是审计法规，例如交易系统的情况。
- en: If the business logic requires journaling, it should accordingly be treated
    as such - a business requirement. There is journaling technology available that
    synchronously persists the required information with higher density and lower
    latency than traditional logging. An example of these solutions is **Chronicle
    Queue**, which allows us to store messages with high throughput and low latency.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务逻辑需要日志记录，则应相应地将其视为业务需求。有可用的日志记录技术，它以比传统日志记录更高的密度和更低的延迟同步持久化所需信息。这些解决方案的例子是**Chronicle
    Queue**，它允许我们以高吞吐量和低延迟存储消息。
- en: The application domain could model the information as a domain event and directly
    persist it into a journaling solution. As mentioned previously, another way is
    to base the application on an event sourcing model. The auditing information is
    then already part of the application's model.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序领域可以将信息建模为领域事件，并将其直接持久化到日志记录解决方案中。如前所述，另一种方法是基于事件源模型构建应用程序。审计信息随后已成为应用程序模型的一部分。
- en: Tracing
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪
- en: Tracing is used to reproduce specific scenarios and request flows. It's already
    helpful in retracing complex application processes, but it's especially helpful
    when multiple applications and instances are involved.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪用于重现特定场景和请求流。它已经在回溯复杂的应用程序过程中很有帮助，但在涉及多个应用程序和实例时尤其有帮助。
- en: However, what's important to be pointed out is that there needs to be a business,
    not technical, requirement for tracing systems, similar to journaling.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要指出，跟踪系统需要有业务需求，而不是技术需求，类似于日志记录。
- en: Tracing is a poor technique for debugging or performance tracing systems. It
    will have a certain impact on performance and doesn't help much in resolving performance
    regression. Interdependent, distributed applications that need to be optimized
    in their performance advisably solely emit information about their quality of
    service, such as response times. Sampling techniques can sufficiently gather information
    that indicate performance issues in the applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪不是调试或性能跟踪系统的良好技术。它将对性能产生一定影响，并且在解决性能回归方面帮助不大。需要优化其性能的相互依赖的分布式应用程序最好仅发出有关其服务质量的信息，例如响应时间。采样技术可以充分收集指示应用程序中性能问题的信息。
- en: However, let's have a look at business-motivated tracing to track the components
    and systems involved.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看由业务动机驱动的跟踪，以跟踪涉及的组件和系统。
- en: 'The following diagram shows a trace of a specific request involving multiple
    application instances and components thereof:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了涉及多个应用程序实例及其组件的特定请求的跟踪。
- en: '![](img/e8a210b2-6eba-4d32-abf1-059aa19fb534.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8a210b2-6eba-4d32-abf1-059aa19fb534.png)'
- en: 'The trace can also be displayed in a timeline to show the synchronous invocations
    as demonstrated in the following diagram:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪也可以显示在时间轴上，以显示同步调用，如下面的图所示：
- en: '![](img/76967c55-0e8a-4e2a-91db-0c10f6107986.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76967c55-0e8a-4e2a-91db-0c10f6107986.png)'
- en: Tracing includes information about which applications or application components
    have been involved and how long the individual invocations took.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪包括有关哪些应用程序或应用程序组件已参与以及单个调用持续了多长时间的信息。
- en: Traditionally, log files have been used for this, by logging the start and end
    of each method or component invocation including a correlation ID, such as a thread
    identifier. There is the possibility of including correlation IDs into logs that
    are used from a single originating request and are reused and logged in subsequent
    applications. This results in traces that also span multiple applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，日志文件已用于此，通过记录每个方法或组件调用的开始和结束，包括一个关联ID，例如线程标识符。有可能将关联ID包含到仅用于单个源请求并随后在后续应用程序中重用和记录的日志中。这导致跟踪跨越多个应用程序。
- en: In the case of logging, the tracing information was accumulated from multiple
    log files; for example, using solutions such as the **ELK** stack. Trace logs
    are usually implemented in cross-cutting ways; for example, using logging filters
    and interceptors so as not to obfuscate the code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录的情况下，跟踪信息是从多个日志文件中累积的；例如，使用如**ELK**堆栈之类的解决方案。跟踪日志通常以横切方式实现；例如，使用日志过滤器和中继器，以免混淆代码。
- en: However, using log files for tracing is not advisable. Even enterprise applications
    that experience a moderate load introduce a lot of log entries that are written
    to files. Many log entries are needed for each and every request.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用日志文件进行追踪是不推荐的。即使是经历适度负载的企业应用程序也会引入大量的日志条目，这些条目被写入文件。每个请求都需要许多日志条目。
- en: File-based I/O and the needed log format serialization generally is too heavy
    for this approach and greatly affects the performance. Tracing to log file formats
    introduces a lot of data that needs to be parsed again afterwards.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的I/O和所需的日志格式序列化通常对这个方法来说太重了，并且极大地影响了性能。追踪到日志文件格式引入了大量的数据，之后还需要再次解析。
- en: There are tracing solutions that provide a much better fit.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些追踪解决方案提供了更好的匹配。
- en: Tracing in a modern world
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代世界的追踪
- en: In the past months and years, multiple tracing solutions have originated that
    aim to minimize the performance impact on the system.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几个月和几年中，出现了多个旨在最小化对系统性能影响的追踪解决方案。
- en: '**OpenTracing** is standard, vendor-neutral tracing technology that is part
    of the Cloud Native Computing Foundation. It defines the concepts and semantics
    of traces and supports tracing in distributed applications. It is implemented
    by multiple tracing technologies such as **Zipkin**, **Jaeger**, or **Hawkular**.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenTracing** 是一个标准、供应商中立的追踪技术，它是云原生计算基金会的一部分。它定义了追踪的概念和语义，并支持分布式应用程序的追踪。它由多个追踪技术实现，例如
    **Zipkin**、**Jaeger** 或 **Hawkular**。'
- en: A hierarchical trace consists of several spans, similar to the ones shown in
    the previous figures. A span can be a child of, or follow, another span.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化追踪由多个跨度组成，类似于之前图中所示。一个跨度可以是另一个跨度的子跨度或跟随者。
- en: In the previous example, the car manufacture component span is a child of the
    load balancer span. The persistence span follows the client span since their invocations
    happen sequentially.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，汽车制造组件跨度是负载均衡跨度的一个子跨度。持久化跨度跟随客户端跨度，因为它们的调用是顺序发生的。
- en: An OpenTracing API span includes a time span, an operation name, context information,
    as well as optional sets of tags and logs. The operation names and tags are somewhat
    similar to Prometheus metric names and labels described earlier in the *Enter Prometheus*
    section. Logs describe information such as span messages.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing API的跨度包括时间跨度、操作名称、上下文信息，以及可选的标签和日志集合。操作名称和标签与之前在 *进入Prometheus*
    部分中描述的Prometheus度量名称和标签有些相似。日志描述了诸如跨度消息等信息。
- en: An example for a single span is `createCar` with the tags `color=RED` and `engine=DIESEL,`
    as well as a log `message` field `Car successfully created`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 单个跨度的示例是 `createCar`，带有标签 `color=RED` 和 `engine=DIESEL`，以及日志字段 `message` 的 `Car
    successfully created`。
- en: The following code snippet shows an example of using the OpenTracing Java API
    in the *car manufacture* application. It supports Java's try-with-resource feature.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了在 *汽车制造* 应用程序中使用OpenTracing Java API的示例。它支持Java的try-with-resource功能。
- en: '[PRE7]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The created span starts actively and is added as a child to a potentially existing
    parent span. The `Tracer` is produced by a CDI producer that depends on the specific
    OpenTracing implementation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的跨度开始活动并作为子跨度添加到可能存在的父跨度中。`Tracer` 由一个CDI生产者产生，该生产者依赖于特定的OpenTracing实现。
- en: Obviously, this approach obfuscates the code a lot and should be moved to cross-cutting
    components, such as interceptors. Tracing interceptor bindings can decorate methods
    and extract information about method names and parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法会大量混淆代码，应该将其移动到横切组件，例如拦截器。追踪拦截器绑定可以装饰方法并提取有关方法名称和参数的信息。
- en: Depending on the desired information included in tracing spans, the interceptor
    binding can be enhanced to provide further information, such as the operation
    name.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 根据追踪跨度中包含的所需信息，拦截器绑定可以被增强以提供更多信息，例如操作名称。
- en: 'The following code snippet shows a business method decorated with an interceptor
    binding that adds tracing in a lean way. Implementing the interceptor is left
    as an exercise for the reader:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用拦截器绑定以简洁方式添加追踪的业务方法。实现拦截器留给读者作为练习：
- en: '[PRE8]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The traced information is carried into subsequent applications via span contexts
    and carriers. They enable participating applications to add their tracing information
    as well.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪信息通过跨度上下文和载体传递到后续应用程序中。它们使参与的应用程序能够添加自己的追踪信息。
- en: The gathered data can be extracted via the used OpenTracing implementation.
    There are filter and interceptor implementations available for technology such
    as JAX-RS resources and clients that transparently add the required debug information
    to the invocations, for example, using HTTP headers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的数据可以通过使用的OpenTracing实现提取。对于JAX-RS资源和服务端客户端等技术，有可用的过滤器和拦截器实现，这些实现可以透明地添加所需的调试信息到调用中，例如使用HTTP头。
- en: This way of tracing impacts the system's performance way less than traditional
    logging. It defines the exact steps and systems that instrument the business logic
    flow. However, as mentioned before, there needs to be a business requirement to
    implement a tracing solution.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种跟踪方式对系统性能的影响远小于传统日志记录。它定义了精确的步骤和系统，这些系统会检测业务逻辑流程。然而，如前所述，需要业务需求来实现跟踪解决方案。
- en: Typical performance issues
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型的性能问题
- en: Performance issues come with typical symptoms, such as response times, that
    are slow or become slower over time, timeouts, or even completely unavailable
    services. The error rates indicate the latter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题伴随着典型的症状，如响应时间变慢或成为更慢，超时，甚至完全不可用的服务。错误率指示了后者。
- en: When performance issues arise, the question to be asked is what the actual constraining
    resource, the bottleneck, is. Where does the issue originate? As shown earlier,
    engineers are advised to follow an investigative process that considers the overall
    situation, including hardware and operating systems, in order to find the constraint.
    There should be no guessing and premature decisions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能问题出现时，需要问的问题是实际限制资源，即瓶颈是什么。问题起源于哪里？如前所述，建议工程师遵循一个考虑整体情况（包括硬件和操作系统）的调查过程，以找到限制因素。不应有猜测和过早的决定。
- en: Performance problems can have a huge number of root causes. Most of them originate
    in coding errors or misconfiguration rather than actual workload exceeding the
    available resources. Modern application servers can handle a lot of load until
    the performance becomes an issue.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题可能有无数的根本原因。其中大部分源于编码错误或配置错误，而不是实际工作负载超过可用资源。现代应用程序服务器可以处理大量的负载，直到性能成为问题。
- en: However, experience shows that there are typical performance issue root causes.
    The following will show you the most serious ones.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经验表明，存在典型的性能问题根本原因。以下将展示最严重的一些。
- en: Engineers are instructed to investigate issues properly, without following supposedly
    best practices and premature optimizations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师被指示正确调查问题，而不是遵循所谓的最佳实践和过早优化。
- en: Logging and memory consumption
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和内存消耗
- en: Traditional logging, such as writing string-formatted log messages to files,
    is the most common root cause for poor performance. This chapter has already described
    the issues and advisable solutions for them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的日志记录，例如将字符串格式的日志消息写入文件，是性能不佳的最常见根本原因。本章已经描述了这些问题及其可行的解决方案。
- en: The biggest reason for poor performance is the extensive string object creation
    and resulting memory consumption. High memory consumption, in general, represents
    a major performance issue. This is not only caused by logging but by high memory
    rates in caching, memory leaks, or extensive object creation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不佳的最大原因是大量字符串对象的创建和随之而来的内存消耗。一般来说，高内存消耗代表了一个主要性能问题。这不仅仅是由日志记录引起的，还包括缓存中的高内存率、内存泄漏或大量对象创建。
- en: Since the JVM manages the garbage collection of memory, these high memory rates
    result in garbage collector runs, trying to free unused memory. The garbage collection
    utilizes the CPU. The situation is not resolved by a single collection run, what
    results in subsequent GC executions and thus high CPU usage. This happens if not
    sufficient memory can be freed either because of memory leaks or a high workload
    with high consumption. Even if the system doesn't crash with `OutOfMemoryError`,
    the CPU usage can effectively stall the application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JVM管理内存的垃圾回收，这些高内存率会导致垃圾回收器运行，试图释放未使用的内存。垃圾回收利用CPU。这种情况不会因为单次回收运行而得到解决，从而导致后续的GC执行和CPU使用率升高。如果无法释放足够的内存，无论是由于内存泄漏还是高负载和高消耗，这种情况就会发生。即使系统没有因为`OutOfMemoryError`而崩溃，CPU使用率也可能有效地使应用程序停滞。
- en: Garbage collection logs, heap dumps, and measurements can help with investigating
    these issues. JMX tools provide insights about the memory distribution and potential
    hot spots.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集日志、堆转储和测量可以帮助调查这些问题。JMX工具提供了关于内存分布和潜在热点方面的见解。
- en: If business logic is implemented in a lean, straightforward way using short-lived
    objects, memory issues are far less likely.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务逻辑以简洁、直接的方式使用短期对象实现，内存问题就远不太可能发生。
- en: Premature optimization
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过早优化
- en: It regularly happens in enterprise projects that developers try to prematurely
    optimize applications without proper verification. Examples for this are the usage
    of caching, configuring pools, and application server behavior, without sampling
    sufficient measurements before and after tweaking.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业项目中，经常发生开发者试图在没有适当验证的情况下过早优化应用程序的情况。例如，使用缓存、配置池以及应用程序服务器行为，但在调整前后没有进行足够的测量。
- en: It's highly advisable to not consider to use these optimizations before there
    is an identified performance problem. Proper performance sampling and measurements
    in production, as well as investigating the constraining resource, are a necessity
    before changing the setup.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有确定性能问题之前，强烈建议不要考虑使用这些优化。在更改设置之前，进行适当的性能采样和测量，以及调查限制性资源，是必要的。
- en: In the vast majority of cases, it's sufficient to go with convention over configuration.
    This is true for both the JVM runtime as well as the application server. If developers
    take a plain Java EE approach with the default application server configuration,
    they won't likely run into issues with premature optimization.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，遵循约定优于配置原则就足够了。这适用于JVM运行时以及应用程序服务器。如果开发者采用默认应用程序服务器配置的纯Java EE方法，他们不太可能遇到过早优化的问题。
- en: If technical metrics indicate that the current approach is not sufficient for
    the production workload, only then is there a need to introduce change. Also,
    engineers should validate the necessity of the change over time. Technology changes
    and an optimization that provided remedy in previous runtime versions might not
    be the best solution anymore.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果技术指标表明当前的方法不足以满足生产工作负载，那么才需要引入变更。此外，工程师应该随着时间的推移验证变更的必要性。技术会变化，之前运行版本中提供补救措施的优化可能不再是最佳解决方案。
- en: The approach of convention over configuration and taking the default configuration
    first also requires the least amount of initial effort.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 约定优于配置的方法以及首先采用默认配置也要求最少的初始努力。
- en: Again, experience shows that a lot of issues originated from prematurely introducing
    change without proper verification beforehand.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，经验表明，许多问题源于在事先没有适当验证的情况下过早引入变更。
- en: Relational databases
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Typical scapegoats for insufficient performance are relational databases. Usually,
    application servers are deployed in multiple instances that all connect against
    a single database instance. This is a necessity to ensure consistency due to the
    CAP theorem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库通常被视为性能不足的替罪羊。通常，应用程序服务器以多个实例部署，所有实例都连接到单个数据库实例。这是由于CAP定理确保一致性的必要条件。
- en: The database as a single point of responsibility, or failure, is predestined
    to become a bottleneck. Still, engineers must consider proper measurements to
    verify this assumption.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库作为一个单一的责任点或失败点，注定会成为瓶颈。然而，工程师必须考虑适当的测量来验证这个假设。
- en: If metrics indicate that the database response is slower than acceptable, again
    the first approach is to investigate the root cause. If the database query is
    responsible for causing the slow response, engineers are advised to take a look
    at the performed queries. Is a lot of data being loaded? If yes, is all this data
    necessary or will it be filtered and reduced by the application later on? In some
    cases, the database queries load more data than required.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指标表明数据库响应速度慢于可接受的范围，那么首先要调查根本原因。如果数据库查询是导致响应缓慢的原因，建议工程师查看执行的查询。是否有大量数据被加载？如果是，所有这些数据都是必要的吗？或者应用程序稍后会对其进行过滤和减少？在某些情况下，数据库查询加载的数据可能比所需的更多。
- en: This is also a question relevant to the business, especially for retrieving
    data, whether everything is required. More specific database queries that pre-filter
    results or size limits, such as pagination, can help in these cases.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个与业务相关的问题，特别是对于检索数据，是否一切都需要。在这种情况下，更具体的数据库查询，如预先过滤结果或大小限制（如分页），可能会有所帮助。
- en: Databases perform exceptionally well when joining and filtering data. Performing
    more complex queries directly in the database instance usually outperforms loading
    all required data into the application's memory and executing the query there.
    It's possible to define complex, nested SQL queries in Java and to execute them
    in the database. However, what enterprise applications should avoid is to define
    business logic queries directly in the database, using stored procedures. Business-related
    logic should reside in the application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库在连接和过滤数据时表现非常出色。在数据库实例中直接执行更复杂的查询通常优于将所有所需数据加载到应用程序的内存中并执行查询。在Java中可以定义复杂的嵌套SQL查询并在数据库中执行它们。然而，企业应用程序应该避免直接在数据库中使用存储过程来定义业务逻辑查询。与业务相关的逻辑应该位于应用程序中。
- en: A typical configuration mistake is also neglecting to index relevant database
    columns that are used in queries. There were many cases in projects where the
    overall performance could be improved by several factors just by defining proper
    indexes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的配置错误是忽略了在查询中使用的相关数据库列的索引。在许多项目中，仅通过定义适当的索引就可以将整体性能提高几个因素。
- en: In general, the insight measurements of specific use cases usually provide good
    insights on where the issue might originate from.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特定用例的洞察测量通常可以提供关于问题可能起源于哪里的良好见解。
- en: In some scenarios, queries that update data often result in optimistic locking
    errors. This originates from domain entities simultaneously being updated. Optimistic
    locking is rather a business issue than a technical one. The service error rate
    will indicate such issues.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，经常更新数据的查询往往会导致乐观锁定错误。这源于领域实体同时被更新。乐观锁定与其说是技术问题，不如说是业务问题。服务错误率将表明这些问题。
- en: If the business use case requires that entities are often changed simultaneously,
    development teams can consider changing the functionality to an event-based model.
    Similarly, as shown previously, event sourcing and event-driven architectures
    get rid of this situation by introducing eventual consistency.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务用例要求实体经常同时更改，开发团队可以考虑将功能更改为基于事件的模型。同样，如前所述，通过引入最终一致性，事件溯源和事件驱动架构消除了这种情况。
- en: If the performance issues purely originates from workload and concurrent accesses,
    then ultimately a different data model is required, such as event-driven architectures
    realized with CQRS. However, usually the situation is solvable in another way.
    The vast majority of enterprise applications scale well enough using relational
    databases.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能问题纯粹源于工作负载和并发访问，那么最终需要不同的数据模型，例如使用CQRS实现的事件驱动架构。然而，通常可以通过其他方式解决这个问题。绝大多数企业应用程序使用关系数据库就可以很好地扩展。
- en: Communication
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信
- en: The majority of communication-related performance issues are due to synchronous
    communication. Most issues in this area emerge from missing timeouts that lead
    client calls to block infinitely and cause deadlock situations. This happens if
    no client-side timeouts are configured and the invoked system is unavailable.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与通信相关的性能问题都是由于同步通信引起的。这个领域的大多数问题都源于缺少超时，导致客户端调用无限期地阻塞并造成死锁情况。这种情况发生在没有配置客户端超时并且调用的系统不可用的情况下。
- en: A less critical but similarly imperfect situation occurs if the configured timeouts
    are too large. This causes systems to wait for too long, slowing down processes
    and blocking threads.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置的超时时间过长，则会发生一个不那么关键但同样不完善的情况。这会导致系统等待时间过长，减慢进程并阻塞线程。
- en: Configuring timeouts for client invocations, as described earlier, provides
    simple but effective relief from this issue.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为客户端调用配置超时提供了简单但有效的缓解措施。
- en: High response time and low throughput can have multiple origins. Performance
    analysis provides insights into where the time is spent.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 高响应时间和低吞吐量可能有多个原因。性能分析可以提供关于时间花费在哪里的见解。
- en: There are some other potential bottlenecks, such as payload sizes. Whether data
    is sent as plain text or binary data can make quite some difference in payload
    sizes. Serialization that uses imperfect algorithms or technology can also decrease
    the responsiveness. Still, these concerns are usually negligible unless the application
    resides in high performance situations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他潜在的瓶颈，例如有效载荷大小。数据是作为纯文本发送还是作为二进制数据发送，在有效载荷大小上可能会有很大的差异。使用不完善算法或技术的序列化也可能降低响应速度。然而，除非应用程序位于高性能环境中，否则这些担忧通常是可以忽略的。
- en: If multiple, synchronous invocations are required, they should happen in parallel
    if possible, using container-managed threads; for example, provided by a managed
    executor service. This avoids unnecessarily making the application wait.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要多个同步调用，如果可能的话，它们应该并行发生，使用容器管理的线程；例如，由管理执行器服务提供。这样可以避免不必要地使应用程序等待。
- en: In general, use cases that span multiple transactional systems, such as databases
    using distributed transactions, should be avoided. As described previously, distributed
    transactions won't scale. The business use case should be considered to effectively
    process asynchronously instead.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，应避免跨越多个事务性系统的用例，例如使用分布式事务的数据库。如前所述，分布式事务无法扩展。业务用例应考虑有效地异步处理。
- en: Threading and pooling
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和池
- en: In order to reuse threads as well as connections, application containers manage
    pools. Requested threads don't necessarily have to be created but are reused from
    a pool.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用线程以及连接，应用程序容器管理池。请求的线程不一定需要创建，而是从池中重用。
- en: Pooling is used to control the load on specific parts of the system. Choosing
    appropriate pool sizes allows the system to be saturated well, but prevents it
    from overloading. This is due to the fact that empty pools will lead to suspended
    or rejected requests. All threads and connections of that pool are then being
    utilized already.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 池用于控制系统特定部分的负载。选择合适的池大小可以使系统很好地饱和，但防止其过载。这是因为空池会导致挂起或拒绝请求。该池的所有线程和连接已经被充分利用。
- en: The bulkhead pattern prevents different parts of the system from affecting each
    other by defining dedicated thread pools. This limits the resource shortage to
    a potentially problematic functionality. In some cases, functionality such as
    a legacy system might be known to cause issues. Bulkheads, implemented as dedicated
    thread pools, and timeout configuration help preserve the application's health.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义专用的线程池，bulkhead模式可以防止系统的不同部分相互影响。这限制了资源短缺到一个可能有问题功能。在某些情况下，如遗留系统可能已知会导致问题。作为专用线程池实现的bulkheads以及超时配置有助于保持应用程序的健康。
- en: Empty pools either originate from the current load on that pool being exceptionally
    high, or resources that are acquired for much longer than expected. In any case,
    it's advisable not to simply increase the corresponding pool size but to investigate
    where the issue originates from. The described investigation techniques as well
    as JMX insights and thread dumps will supports you in finding bottlenecks, as
    well as potential programming errors, such as deadlocks, misconfigured timeouts,
    or resource leaks. In the minority of cases will a shortage in pooling actually
    originate from a high workload.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 空池可能源于该池当前负载异常高，或者获取的资源比预期的时间长得多。在任何情况下，建议不要简单地增加相应的池大小，而是调查问题根源。描述的调查技术以及JMX洞察力和线程转储将帮助您找到瓶颈，以及潜在的编程错误，如死锁、配置不当的超时或资源泄漏。在少数情况下，池的短缺实际上可能源于高负载。
- en: Pool sizes and configuration is made in the application container. Engineers
    must perform proper performance sampling in production before and after reconfiguring
    the server.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 池的大小和配置在应用程序容器中完成。工程师必须在重新配置服务器前后在生产环境中进行适当的性能采样。
- en: Performance testing
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: The challenge with performance testing is that the tests run in a simulated
    environment.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的挑战在于测试是在模拟环境中运行的。
- en: Simulated environments are fine for other kinds of tests, such as system tests,
    since certain aspects are abstracted. Mock servers, for example, can simulate
    behavior similarly to production.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟环境适用于其他类型的测试，例如系统测试，因为某些方面被抽象化。例如，模拟服务器可以模拟与生产环境相似的行为。
- en: However, unlike in functional tests, validating the system's responsiveness
    requires to take everything in the environment into account. At the end of the
    day, applications are running on actual hardware, thus the hardware, as well as
    the overall situation, impacts the application's performance. The system's performance
    in simulated environments will never behave equally in production. Therefore,
    performance tests are not a reliable way of finding performance bottlenecks.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与功能测试不同，验证系统的响应性需要考虑环境中的所有因素。最终，应用程序是在实际硬件上运行的，因此硬件以及整体情况都会影响应用程序的性能。在模拟环境中的系统性能永远不会在生产环境中表现得一样。因此，性能测试不是可靠地找到性能瓶颈的方法。
- en: There are many scenarios where an application can perform much better in production
    compared to performance tests, depending on all the immediate and imminent influences.
    The HotSpot JVM, for example, performs better under high load.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，应用程序在生产环境中的性能可能比性能测试中表现更好，这取决于所有直接和即将到来的影响因素。例如，HotSpot JVM在高负载下表现更佳。
- en: Investigating performance constraints therefore can only happen in production.
    As shown earlier, the jPDM investigation processes, together with sampling techniques
    and tools applied to the production system, will identify the bottleneck.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调查性能限制只能在生产环境中进行。如前所述，jPDM调查过程，结合应用于生产系统的采样技术和工具，将识别瓶颈。
- en: Performance and stress tests help in finding obvious code or configuration errors,
    such as resource leaks, serious misconfiguration, missing timeouts, or deadlocks.
    These bugs will be found before deploying to production. Performance tests can
    also capture performance trends over time and warn engineers if the overall responsiveness
    decreases. Still, this may only indicate potential issues but should not lead
    the engineers to premature conclusions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和压力测试有助于发现明显的代码或配置错误，例如资源泄露、严重配置错误、超时缺失或死锁。这些错误将在部署到生产之前被发现。性能测试还可以捕捉到随时间推移的性能趋势，并在整体响应性下降时警告工程师。然而，这可能仅表明潜在问题，但不应该导致工程师过早得出结论。
- en: Performance and stress tests only make sense in the whole network of interdependent
    applications. This is because of dependencies and performance influences of all
    the systems and databases involved. The setup needs to be as similar to production
    as possible.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和压力测试只有在相互依赖的应用程序网络中才有意义。这是因为所有涉及的系统和数据库的依赖性和性能影响。设置需要尽可能接近生产环境。
- en: Even then, the outcome will not be the same as in production. It's highly important
    that engineers are aware of this. Performance optimizations that follow performance
    tests are therefore never fully representative.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，结果也不会与生产环境相同。工程师们对此要有清醒的认识。因此，在性能测试之后的性能优化永远不能完全代表真实情况。
- en: For performance tuning, it's important to use investigative processes together
    with sampling on production instead. Continuous Delivery techniques support in
    quickly bringing configuration changes to production. Then engineers can use the
    sampling and performance insights to see whether changing the setup has improved
    the overall solution. And again, the overall system needs to be taken into account.
    Simply tuning a single application without considering the whole system can have
    negative effects on the overall scenario.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能调优来说，重要的是在生产环境中结合调查过程和采样。持续交付技术有助于快速将配置更改应用到生产环境中。然后工程师可以使用采样和性能洞察来查看更改设置是否改善了整体解决方案。再次强调，需要考虑整个系统。仅仅调整单个应用程序而不考虑整个系统可能会对整体情况产生负面影响。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Business-related metrics can provide helpful insights into the enterprise application.
    These metrics are a part of the business use case and therefore should be treated
    as such. Business metrics are ultimately impacted by other, technical metrics.
    It's therefore advisable to monitor these metrics as well.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务相关的指标可以为企业应用程序提供有价值的见解。这些指标是业务用例的一部分，因此应被视为如此。业务指标最终会受到其他技术指标的影响。因此，建议也要监控这些指标。
- en: The theory of constraints describes that there will be one ore more limiting
    constraints that prevent the system from infinitely increasing its throughput.
    In order to improve the application's performance the limiting constraint therefore
    needs to be eradicated. jPDM helps identifying the limiting constraints by finding
    the dominating consumer of the CPU first and using appropriate tooling to further
    investigate performance issues. It's advisable to investigate potential bottlenecks
    by following this process, which takes the overall situation into account, rather
    than to blindly *peek and poke*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 约束理论描述了系统中将存在一个或多个限制性约束，这些约束会阻止系统无限增加其吞吐量。因此，为了提高应用程序的性能，需要消除这些限制性约束。jPDM通过首先找到CPU的主消费者，并使用适当的工具进一步调查性能问题，帮助识别这些限制性约束。建议按照这个考虑整体情况的过程来调查潜在的瓶颈，而不是盲目地*窥视和戳探*。
- en: Rather than using high-frequency monitoring, engineers are advised to sample
    technical metrics with low frequency and to query, calculate, and investigate
    out-of-band. This has tremendously less impact on the application's performance.
    Distributed applications will need to meet SLAs. The backpressure approach as
    well as the bulkhead pattern can help achieve highly responsive, resilient enterprise
    systems.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用高频监控相比，建议工程师以低频采样技术指标，并查询、计算和调查异常情况。这将对应用程序的性能产生极小的影响。分布式应用程序需要满足服务等级协议（SLAs）。背压方法以及舱壁模式可以帮助实现高度响应和弹性的企业系统。
- en: Traditional logging should be avoided for a number of reasons, especially the
    negative performance impact. Enterprise applications are advised to only output
    log events in case of fatal, unexpected errors, which are written to standard
    output in a preferably straightforward way. For all other motivations, such as
    debugging, tracing, journaling, or monitoring, there are more suitable solutions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多种原因，包括负面的性能影响，应避免使用传统的日志记录。企业应用程序建议仅在发生致命的意外错误时输出日志事件，这些错误以尽可能直接的方式写入标准输出。对于所有其他动机，如调试、跟踪、日志记录或监控，有更合适的解决方案。
- en: Performance and stress tests running in simulated environments can be used to
    find obvious errors in the application. The environments should be as close to
    production, including all applications and databases involved. For any other reasoning,
    especially statements about an application's expected performance, bottlenecks,
    or optimizations, performance tests are not helpful and might even lead to wrong
    assumptions.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟环境中运行的性能和压力测试可以用来发现应用程序中的明显错误。环境应该尽可能接近生产环境，包括所有涉及的应用程序和数据库。对于任何其他理由，特别是关于应用程序预期性能、瓶颈或优化的声明，性能测试并不有帮助，甚至可能导致错误的假设。
- en: The next chapter will cover the topic of application security.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖应用程序安全性的主题。
