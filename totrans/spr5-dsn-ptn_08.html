<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Accessing Database with Spring ORM and Transactions Implementing Patterns</h1>
                </header>
            
            <article>
                
<p>In <a href="81848842-717f-4e27-9204-ace0a6fdce6f.xhtml">Chapter 7</a>, <em>Accessing Database with Spring and JDBC Template Patterns</em>, we have learned how to access database using JBDC and how Spring can remove boilerplate code from the developer end to the framework by using template pattern and callbacks. In this chapter, we will learn one advanced step of accessing database using the <strong>Object Relational Mapping</strong> (<strong>ORM</strong>) Framework and managing transactions across the application.</p>
<p>When my son, Arnav, was one and a half years old, he used to play with a dummy mobile phone. But as he grew up, his needs too outgrew dummy mobiles to smartphones.</p>
<p>Similarly, when your application has a small set of data for a business tier, then JDBC works fine, but as your application grows and becomes more complex, it becomes difficult to map tables to the objects in the application. JDBC is the dummy small phone of the data access world. But with complex applications, we need Object Relational Mapping solutions that are able to map object properties to database columns. We also need more sophisticated platforms for our application at the data access layer, which create the queries and statements independently from the database technologies for us, and which we can define declaratively or programmatically.</p>
<p>Many ORM Frameworks are available to provide services at the data access layer of an application. Examples of such services include object relational mapping, lazy loading of data, eager loading of data, cascading, and so on. These ORM services save you from writing a lot of code for error handling, and managing resources in the application. The ORM Frameworks decrease the development time, and help to write error-free code, so that you just focus on the business requirements only. Spring doesn't implement its own ORM solution, but it provides support for many persistence frameworks such as Hibernate, the <strong>Java Persistence API</strong> (<strong>JPA</strong>), iBATIS, and <strong>Java Data Objects</strong> (<strong>JDO)</strong>. Spring also provides integration points to the ORM Frameworks so that we can easily integrate the ORM Framework in our Spring application.</p>
<p>Spring provides support for all these technologies in your application. In this chapter, we will explore Spring's support for ORM solutions, and cover the following topics:</p>
<ul>
<li>ORM Framework and used patterns
<ul>
<li>The data access object pattern</li>
<li>Creating DAOs using the Factory design pattern in Spring</li>
<li>The Data Mapper pattern</li>
<li>The domain model pattern</li>
<li>Proxy for the lazy loading pattern</li>
<li>The Hibernate template pattern</li>
</ul>
</li>
<li>Integrating Hibernate with Spring
<ul>
<li>Configuring Hibernate's <kbd>SessionFactory</kbd> in a Spring container</li>
<li>Implementing DAOs based on plain Hibernate API</li>
<li>Transaction management strategies in Spring</li>
<li>Declarative transaction implementation and demarcation</li>
<li>Programmatic transaction implementation and demarcation</li>
<li>Best practices for Spring ORM and transaction modules in the application</li>
</ul>
</li>
</ul>
<p><span>Before we go on to discuss more about the ORM Frameworks, let's first look at some design patterns used in the <strong>data access layer</strong> (<strong>DAL</strong>) of the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ORM Framework and the patterns used</h1>
                </header>
            
            <article>
                
<p>Spring provides support for several ORM Frameworks, such as Hibernate, the <strong>Java Persistence API</strong> (<strong>JPA</strong>), iBATIS, and <strong>Java Data Objects</strong> (<strong>JDO</strong>). By using any ORM solution in your application, you can easily persist and access data in the form of POJO objects from relational databases. The Spring ORM module is an extension of the previously discussed Spring JDBC DAO module. Spring provides ORM templates, such as JDBC-based templates, to work in the integration tier or data access layer. The following are the ORM Frameworks and integration supported by the Spring Framework:</p>
<ul>
<li>Hibernate</li>
<li>Java Persistence API</li>
<li>Java Data Objects</li>
<li>iBATIS</li>
<li>Data access object implementations</li>
<li>Transaction strategies</li>
</ul>
<p>You can use Spring's dependency injection feature to configure ORM solutions in your application. Spring also adds important enhancements to the ORM layer in your data access applications. The following are the benefits of using the Spring Framework to create your ORM DAOs:</p>
<ul>
<li><strong>Easier development and testing</strong>: Spring's IoC container manages the beans for ORM DAOs. You can easily swap the implementation of the DAO interface by using Spring's dependency injection feature. It also makes it easy to test persistence-related code in isolation.</li>
<li><strong>Common data access exceptions</strong>: <span>Spring provides a consistent data exception hierarchy to handle exceptions at the persistence layer. It wraps all the checked exceptions from the ORM tool, and converts these exceptions to unchecked general exceptions which are not related to any specific ORM solution and are DB-specific.</span></li>
<li><strong>General resource management</strong>: <span>Resources such as <kbd>DataSource</kbd>, DB connections, Hibernates <kbd>SessionFactory</kbd>, JPA <kbd>EntityManagerFactory</kbd>, and others are managed by the Spring IoC container. Spring also manages transactions--local or global--using JTA.</span></li>
<li><strong>Integrated transaction management</strong>: <span>Spring provides declarative and programmatic transaction management in your application. For declarative transaction management, you can use the</span> <kbd>@Transactional</kbd> <span>annotation.</span></li>
</ul>
<p>The main approach to Spring's integration with the ORM solution is loose coupling between the application's layers; that is, the business layer and the data access layer. It is clear application layering, and is independent of any specific database and transaction technology. Business services in the application are no longer dependent on data access and a specific transaction strategy. Because Spring manages the resources used in the integration layer, you don't need to look up resources for specific data access technologies. Spring provides templates for the ORM solution to remove the boilerplate codes, and it provides a consistent approach across all ORM solutions.</p>
<p>In <a href="81848842-717f-4e27-9204-ace0a6fdce6f.xhtml" target="_blank">Chapter 7</a>, <em>Accessing Database with Spring and JDBC Template Patterns</em>, you saw how Spring solves two major problems of the integration layer in the application. The first problem was <em>redundant code for managing resources from the application</em>, and the second problem was <em>handling checked exceptions</em> in the application at development time. Similarly, the Spring ORM module also provides solutions to these two problems, as we'll discuss in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource and transaction management</h1>
                </header>
            
            <article>
                
<p>In the Spring JDBC module, resources such as connection handling, statements handling, and exceptions handling are managed by the Spring's JdbcTemplate. It also translates SQL error codes of the database specific to meaningful unchecked exception classes. The same is true for the Spring ORM module--Spring manages both local and global transactions in the enterprise application by using the respective Spring transaction managers. Spring provides transaction managers for all supported ORM technologies. For example, Spring offers the Hibernate transaction manager for Hibernate, the JPA transaction manager for JPA, and JTA support for global or distributed transactions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consistent exception handling and translation</h1>
                </header>
            
            <article>
                
<p>In the Spring JDBC module, Spring provides <kbd>DataAccessException</kbd> to handle all types of database-specific SQL error code, and generates meaningful exception classes. In the Spring ORM module, as we already know, Spring supports integration for several ORM solutions, such as Hibernate, JPA, or JDO in a DAO, and these persistence technologies provide their own native exception classes as <kbd>HibernateException</kbd>, <kbd>PersistenceException</kbd>, or <kbd>JDOException</kbd> depending on the technology. These native exceptions of the ORM Frameworks are unchecked exceptions, so we don't have to handle them in the application. The caller of the DAO services cannot do specific handling unless the application is strongly ORM based, or does not need any special exception treatment. Spring provides a consistent approach throughout the ORM Frameworks; you don't need to implement specific code for any ORM in a Spring application. It enables exception translation by using the <kbd>@Repository</kbd> annotation. If any class in the Spring application is annotated with <kbd>@Repository</kbd> annotation, then that class is eligible for Spring <kbd>DataAccessException</kbd> translation. Take for example the following code for the <kbd>AccountDaoImpl</kbd> class:</p>
<pre>    @Repository 
    public class AccountDaoImpl implements AccountDao { 
      // class body here... 
    } 
 
    &lt;beans&gt; 
      &lt;!-- Exception translation bean post processor --&gt; 
      &lt;bean class="org.springframework.dao.annotation.<br/>      PersistenceExceptionTranslationPostProcessor"/&gt; 
      &lt;bean id="accountDao" class="com.packt.patterninspring.chapter8.<br/>      bankapp.dao.AccountDaoImpl"/&gt; 
    &lt;/beans&gt; </pre>
<p>As you can see in the preceding code, the <kbd>PersistenceExceptionTranslationPostProcessor</kbd> class is a bean <kbd>post processor</kbd>, which automatically searches for all exception translators and also advises all the registered beans annotated with the <kbd>@Repository</kbd> annotation in the container. It applies the discovered exception translators to those annotated beans, and these translators can intercept and apply the appropriate translation on the thrown exceptions.</p>
<p>Let's see some more design patterns that are implemented in the Spring ORM module to provide the best enterprise solution for the integration tier of an enterprise application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The data access object pattern</h1>
                </header>
            
            <article>
                
<p>The <strong>data access object</strong> (<strong>DAO</strong>) pattern is a very popular design pattern for the persistent layer in a J2EE application. It separates the business logic layer and persistence layer. The DAO pattern is based on the encapsulation and abstraction object-oriented principles. The context for using the DAO pattern is to access and persist data depending on the underlying vendor implementation and type of storage, such as object-oriented database, flat files, relational databases, and so on. Using the DAO pattern, you can create a DAO interface, and implement this DAO interface to abstract and encapsulate all access to the data source. This DAO implementation manages the database's resources like connections with the data source.</p>
<p>The DAO interfaces are very generic to all the underlying data source mechanisms, and don't need to change for any changes in the low-level persistence technologies. This pattern allows you to adopt any different data access technologies without affecting the business logic in the enterprise application. Let's see the following figure to understand more about the DAO pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/708d83c8-8fe7-4581-8629-133da0d44194.png"/></div>
<p class="packt_figure">As you can see in the preceding diagram, the following participants work on this pattern:</p>
<ul>
<li><strong>BusinessObject</strong>: This object works on the business layer, and is a client for the data access layer. It requires data for business modeling, and for preparing Java objects for the helper or controllers in the application.</li>
<li><strong>DataAccessObject</strong>: This is a primary object of the DAO pattern. This object hides all the low-level implementation of the underlying database implementation for the <strong>BusinessObject</strong>.</li>
<li><strong>DataSource</strong>: This is also an object to contain all the low-level information about the underlying database implementation, such as an RDBMS, flat files, or XML.</li>
<li><strong>TransferObject</strong>: This is also an object, and it is used as a data carrier. This object is used by <strong>DataAccessObject</strong> to return data to the business object.</li>
</ul>
<p>Let's see the following example of the DAO pattern, where <kbd>AccountDao</kbd> is a <kbd>DataAccessObject</kbd> interface, and <kbd>AccountDaoImpl</kbd> is the implementation class of the <kbd>AccountDao</kbd> interface:</p>
<pre>    public interface AccountDao { 
      Integer totalAccountsByBranch(String branchName); 
    } 
 
    public class AccountDaoImpl extends JdbcDaoSupport implements<br/>    AccountDao { 
      @Override 
      public Integer totalAccountsByBranch(String branchName) { 
        String sql = "SELECT count(*) FROM Account WHERE branchName = <br/>        "+branchName; 
        return this.getJdbcTemplate().queryForObject(sql,   <br/>        Integer.class); 
       } 
 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating DAOs using the Factory design pattern in Spring</h1>
                </header>
            
            <article>
                
<p>As we know, there are a lot of design patterns that play a role in the Spring Framework. As discussed in <a href="75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml" target="_blank">Chapter 2</a>, <em>Overview of GOF Design Patterns</em>--Core Design patterns, the Factory pattern is a creational design pattern, and it is used to create an object without exposing the underlying logic to the client, and to assign a new object to the caller using a common interface or abstract class. You can make the DAO pattern highly flexible by using the <kbd>Factory</kbd> method and Abstract Factory design patterns.</p>
<p>Let's see in our example where do we are implementing this strategy in which a factory produces the DAOs for a single database implementation. Please refer to the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="305" width="244" class=" image-border" src="assets/e6b56aff-d1ff-40e2-96a5-ef320074a864.png"/></div>
<p>You can see in the preceding diagram that the <strong>AccountDao</strong> object is produced by <strong>AccountDaoFactory</strong>, and <strong>AccountDaoFactory</strong> is a factory for <strong>AccountDao</strong>. We can change the underlying database at any time such that we do not need to change the business code--the factory takes care of these things, Spring provides support to maintain all the DAOs in the bean factory and in the factory for DAOs as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Data Mapper pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote"><em>A layer of Mappers that moves data between objects and a database while keeping them independent of each other and the mapper itself</em>.<br/>
- By <strong>Martin Fowler</strong>: Patterns of Enterprise Application Architecture</div>
<p>The ORM Framework provides mapping between the object and relational databases, because we know that Objects and tables in the relational databases have different ways of storing the data for the application. Also, objects and tables have mechanisms for structuring data. In your Spring application, if you use any ORM solution such as Hibernate, JPA, or JDO, then you don't need worry about the mapping mechanism between the object and relational databases. Let's see the following diagram to understand more about the Data Mapper pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="98" width="466" class=" image-border" src="assets/fc8e63e5-0863-4dc2-ac2f-4cd902fc4f45.png"/></div>
<p>As shown in the preceding diagram, <strong>Account</strong>, an object, is mapped to the relational database through <strong>AccountMapper</strong>. It works like a mediator layer between the Java object and the underlying database in the application. Let's see another pattern used in the data access layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The domain model pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">An object model of the domain that incorporates both behaviour and data.<br/>
-by Martin Fowler: Patterns of Enterprise Application Architecture</div>
<p>A domain model is an object that has behavior and data, so, the behavior defines the business logic of the enterprise application, and data is information about the business's output. A domain model combines data and process. In an enterprise application, data model lies under the business layer to insert the business logic, and it returns data from the business behaviors. Let's see the following diagram for more clarity on this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="134" width="352" class=" image-border" src="assets/8c41779b-59fc-49c8-be22-75ff9b2b98c7.png"/></div>
<p>As you can see in the preceding diagram, we have defined two domain models in our application as per as our business requirements. Business behavior for transferring money from one account to another account has been defined in the <strong>TransferService</strong> class. The classes <strong>TransferService</strong> and <strong>AccountService</strong> come under the domain model pattern in the enterprise application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxy for the lazy loading pattern</h1>
                </header>
            
            <article>
                
<p>Lazy loading is a design pattern, and this design pattern is used by some ORM solutions such as Hibernate in the enterprise application to defer initialization of an object until it is called by another object at a point where it is needed. The purpose of this design pattern is memory optimization in the application. The lazy loading design pattern in Hibernate is achieved by using a virtual proxy object. In Lazy loading demonstration, we use a proxy, but this is not part of the proxy pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring's Hibernate template pattern</h1>
                </header>
            
            <article>
                
<p>Spring provides a helper class to access data in the DAO layer--this class is based on the GoF template method design pattern. Spring provides the <kbd>HibernateTemplate</kbd> class for providing database operations such as <kbd>save</kbd>, <kbd>create</kbd>, <kbd>delete</kbd>, and <kbd>update</kbd>. The <kbd>HibernateTemplate</kbd> class ensures that only one Hibernate session is used per transaction.</p>
<p>Let's see Spring's support for Hibernate in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating Hibernate with Spring</h1>
                </header>
            
            <article>
                
<p>Hibernate is a persistence ORM Framework, it is open source, and it provides not only simple object relationship mapping between Java objects and database tables, but also provides a lot of sophisticated features for your application to improve performance, and helps in better resource utilization such as caching, lazy loading, eager fetching, and distributed caching.</p>
<p>Spring Framework provides full support to integrate the Hibernate Framework, and Spring has some inbuilt libraries for full utilization of the Hibernate Framework. We can use Spring's DI pattern and IoC container to configure Hibernate in your application.</p>
<p>Let's see in the following section how to configure Hibernate in the Spring IoC container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Hibernate's SessionFactory in a Spring container</h1>
                </header>
            
            <article>
                
<p>As the best approach for configuring Hibernate and other persistence technologies in any enterprise application, business objects should be separate from the hard-coded resource lookups such as a JDBC <kbd>DataSource</kbd> or Hibernate <kbd>SessionFactory</kbd>. You can define these resources as beans in the Spring container. But business objects require the references of these resources, such as <kbd>SessionFactory</kbd> and JDBC <kbd>DataSource</kbd>, to access them. Let's see the following DAO class which has <kbd>SessionFactory</kbd> to access data for the application:</p>
<pre>    public class AccountDaoImpl implements AccountDao { 
      private SessionFactory sessionFactory; 
 
      public void setSessionFactory(SessionFactory sessionFactory) { 
        this.sessionFactory = sessionFactory; 
      } 
       //..... 
    } </pre>
<p>As you can see in the preceding code, the DAO class, <kbd>AccountDaoImpl</kbd>, follows the dependency injection pattern. It is injected with Hibernate's <kbd>SessionFactory</kbd> object to access the data, and fits nicely into a Spring IoC container. Here, Hibernate's <kbd>SessionFactory</kbd> is singleton object; it produces the main object of <kbd>org.hibernate.Session</kbd> interface of Hibernate. <kbd>SessionFactory</kbd> manages the <kbd>Session</kbd> object of Hibernate, and is also responsible for opening and closing the <kbd>Session</kbd> object. The <kbd>Session</kbd> interface has actual data-access functionality such as <kbd>save</kbd>, <kbd>update</kbd>, <kbd>delete</kbd>, and <kbd>load</kbd> objects from the database. In the application, <kbd>AccountDaoImp</kbd> or any other repository uses this Hibernate <kbd>Session</kbd> object to perform all of its persistence needs.</p>
<p>Spring provides inbuilt Hibernate modules, and you could use Spring's Hibernate session-factory beans in your application.</p>
<p>The <kbd>org.springframework.orm.hibernate5.LocalSessionFactoryBean</kbd> bean is the implementation of the <kbd>FactoryBean</kbd> interface of Spring. <kbd>LocalSessionFactoryBean</kbd> is based on the Abstract Factory pattern, and it produces Hibernate <kbd>SessionFactory</kbd> in the application. You can configure the Hibernate <kbd>SessionFactory</kbd> as a bean in Spring's context in your application as follows:</p>
<pre>    @Bean 
    public LocalSessionFactoryBean sessionFactory(DataSource <br/>    dataSource) { 
      LocalSessionFactoryBean sfb = new LocalSessionFactoryBean(); 
      sfb.setDataSource(dataSource); 
      sfb.setPackagesToScan(new String[] {   <br/>        "com.packt.patterninspring.chapter8.bankapp.model" }); 
        Properties props = new Properties(); 
        props.setProperty("dialect", <br/>        "org.hibernate.dialect.H2Dialect"); 
        sfb.setHibernateProperties(props); 
        return sfb; 
    } </pre>
<p>In the preceding code, we have configured <kbd>SessionFactory</kbd> as a bean by using the Spring's <kbd>LocalSessionFactoryBean</kbd> class. This bean method takes <kbd>DataSource</kbd> as an argument; <kbd>DataSource</kbd> specifies how and where to find a database connection. We also specified a property, <kbd>setPackagesToScan</kbd>, for <kbd>LocalSessionFactoryBean</kbd> with a package named <kbd>"com.packt.patterninspring.chapter8.bankapp.model"</kbd> to be scanned, and set a property of <kbd>SessionFactory</kbd> is <kbd>hibernateProperties</kbd> to find what kind of database we will deal with in the application.</p>
<p>Let's see how to implement DAOs for the persistence layer of the application after configuring the Hibernate <kbd>SessionFactory</kbd> bean in the Spring application context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing DAOs based on the plain Hibernate API</h1>
                </header>
            
            <article>
                
<p>Let's create the following DAO implanting class:</p>
<pre>    package com.packt.patterninspring.chapter8.bankapp.dao; 
 
    import org.hibernate.SessionFactory; 
    import org.springframework.stereotype.Repository; 
    import org.springframework.beans.factory.annotation.Autowired; 
    @Repository 
    public class AccountDaoImpl implements AccountDao { 
      @Autowired 
      private SessionFactory sessionFactory; 
 
      public void setSessionFactory(SessionFactory sessionFactory) { 
        this.sessionFactory = sessionFactory; 
      } 
     
      @Override 
      public Integer totalAccountsByBranch(String branchName) { 
        String sql = "SELECT count(*) FROM Account WHERE branchName =<br/>        "+branchName; 
        return this.sessionFactory.getCurrentSession().createQuery(sql,<br/>        Integer.class).getSingleResult(); 
      } 
      @Override 
      public Account findOne(long accountId) { 
        return (Account)   <br/>        this.sessionFactory.currentSession().<br/>        get(Account.class, accountId); 
      } 
      @Override 
      public Account findByName(String name) { 
        return (Account) this.sessionFactory.currentSession().<br/>        createCriteria(Account.class) 
        .add(Restrictions.eq("name", name)) 
        .list().get(0); 
      } 
      @Override 
      public List&lt;Account&gt; findAllAccountInBranch(String branchName) { 
       return (List&lt;Account&gt;) this.sessionFactory.currentSession() 
           <br/>       .createCriteria(Account.class).add(Restrictions.eq("branchName",  <br/>       branchName)).list(); 
      }  
    } </pre>
<p>As you can see in the preceding code, <kbd>AccountDaoImpl</kbd> is a DAO implementation class, which is injected with Hibernate's <kbd>SessionFactory</kbd> bean by using the <kbd>@Autowired</kbd> annotation. The DAO implementations described earlier will throw unchecked Hibernate <kbd>PersistenceExceptions</kbd>--it is not desirable to let these propagate up to the service layer or other users of the DAOs. But the Spring AOP module allows translation to Spring's rich, vendor-neutral <kbd>DataAccessException</kbd> hierarchy--it hides the access technology used. Spring provides this capability out of the box by annotating the DAO implementation class with <kbd>@Repository</kbd>, and you just need to define a Spring-provided <kbd>BeanPostProcessor</kbd>, that is, <kbd>PersistenceExceptionTranslationPostProcessor</kbd>.</p>
<p>Let's add an exception translation to our Hibernate DAO implementation class; we can do this by just adding a <kbd>PersistenceExceptionTranslationPostProcessor</kbd> bean to the Spring application context, as follows:</p>
<pre>    @Bean 
    public BeanPostProcessor persistenceTranslation() { 
      return new PersistenceExceptionTranslationPostProcessor(); 
    } </pre>
<p>The preceding registered bean <kbd>PersistenceExceptionTranslationPostProcessor</kbd> is responsible for adding an adviser for the beans which are annotated with the <kbd>@Repository</kbd> annotation, and it is re-thrown as a Spring-specific unchecked data access exception for any platform-specific exceptions caught in the code.</p>
<p>Let's see, in the next section, how Spring manages transactions across the business and persistence layers of the Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transaction management strategies in Spring</h1>
                </header>
            
            <article>
                
<p>Spring provides comprehensive support for transaction management in a Spring application. This is one the most compelling features of the Spring Framework. Mostly, this feature forces software industries to develop enterprise applications with the Spring Framework. The Spring Framework provides a consistent way to manage transactions across the application using any persistence technology, such as Java Transaction API , JDBC, Hibernate, Java Persistence API, and Java Data Objects. Spring supports declarative transaction management as well as programmatic transaction management.</p>
<p>There are two types of Java transactions, which are as follows:</p>
<ul>
<li><strong>Local transactions - single resource</strong>: Local transactions managed by the underlying resource; these are resource-specific. Let's explain this with the help of the following diagram:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="51" width="296" class=" image-border" src="assets/ead72de9-5c64-40e8-aa11-4e5f91f63a00.png"/></div>
<p style="padding-left: 60px">As you can see in the preceding diagram, there is a transaction working between the application and the database platforms to ensure that every unit of task follows the ACID property of the databases.</p>
<ul>
<li><strong>Global (distributed) transactions - multiple</strong>: Global transactions, which are managed by separate, dedicated transaction managers, enable you to work with multiple transactional resources. Take a look at the following diagram to understand more about Global or distributed transactions:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="85" width="296" class=" image-border" src="assets/0999f1a4-94f1-447f-a3cb-fed0ca1b793c.png"/></div>
<p style="padding-left: 60px">As you can see in the last diagram, a <strong>Transaction Manager</strong> works with multiple database technologies in the application. A global transaction is independent of platform-specific persistence technologies.</p>
<p>Spring provides the same API for both types of transactions in Java applications. The Spring Framework provides a consistent programming model in any environment by either configuring the transactions declaratively, or by configuring the transaction programmatically.</p>
<p>Let's move on to the following sections to see how to configure transactions in Spring applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declarative transaction demarcation and implementation</h1>
                </header>
            
            <article>
                
<p>Spring supports declarative transaction management. Spring separates transaction demarcation from transaction implementation. Demarcation is expressed declaratively via the Spring AOP. We always recommend using Spring's declarative transaction demarcation and implementation in your Spring application, because the declarative programming model enables you to replace the external transaction demarcation API from the code, and you can configure it by using Spring AOP transaction interceptor. Transactions are, basically, cross-cutting concerns; this declarative transaction model allows you to keep your application's business logic separate from the repetitive transaction demarcation code.</p>
<p>As mentioned earlier, Spring provides a consistent model for handling transactions in a Spring application, and provides an interface <kbd>PlatformTransactionManager</kbd> to hide the implementation details. There are several implementations available for this interface in the Spring Framework, and some of these are listed next:</p>
<ul>
<li><kbd>DataSourceTransactionManager</kbd></li>
<li><kbd>HibernateTransactionManager</kbd></li>
<li><kbd>JpaTransactionManager</kbd></li>
<li><kbd>JtaTransactionManager</kbd></li>
<li><kbd>WebLogicJtaTransactionManager</kbd></li>
<li><kbd>WebSphereUowTransactionManager</kbd></li>
</ul>
<p>The following is a key interface:</p>
<pre>    public interface PlatformTransactionManager { 
      TransactionStatus getTransaction( 
        TransactionDefinition definition) throws TransactionException; 
       void commit(TransactionStatus status) throws   <br/>         TransactionException; 
       void rollback(TransactionStatus status) throws<br/>         TransactionException; 
   } </pre>
<p>In the preceding code, the <kbd>getTransaction()</kbd> method returns a <kbd>TransactionStatus</kbd> object. This object contains the status of transactions; either it is new or it returns existing in the current call stack. It depends on the <kbd>TransactionDefinition</kbd> parameter. As in JDBC or ORM modules, Spring also provides a consistent way to handle exceptions thrown by any transaction manager. The <kbd><span>getTransaction()</span></kbd> method throws a <kbd>TransactionException</kbd> exception, which is an unchecked exception.</p>
<p>Spring uses the same API for global and local transactions in the application. Very minor changes are required to move from local transaction to the global transaction in the application-that is just change the transaction manager.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the transaction manager</h1>
                </header>
            
            <article>
                
<p>There are two steps for deploying a transaction in your Spring application. The first step is that you have to implement or configure a pre-implemented Spring transaction manager class with your application. The second step is to declare transaction demarcation, that is, where you want to place the Spring transaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1 - Implementing the transaction manager</h1>
                </header>
            
            <article>
                
<p>Create the bean for the required implementation just like any other Spring bean. You can configure, as appropriate, the transaction manager for any persistence technologies such as JDBC, JMS, JTA, Hibernate, JPA, and so on. But in the following example, here is the manager for a <kbd>DataSource</kbd> using JDBC:</p>
<p>In Java configuration, let's see how to define the <kbd>transactionManager</kbd> bean in the application:</p>
<pre>    @Bean 
    public PlatformTransactionManager transactionManager(DataSource <br/>    dataSource) { 
      return new DataSourceTransactionManager(dataSource); 
    } </pre>
<p>In XML configuration, the bean can be created like this:</p>
<pre>    &lt;bean id="transactionManager" <br/>     class="org.springframework.jdbc.datasource.<br/>     DataSourceTransactionManager"&gt; 
     &lt;property name="dataSource" ref="dataSource"/&gt; 
    &lt;/bean&gt; </pre>
<p>In the preceding code, we use <kbd>dataSource</kbd> bean; a <kbd>dataSource</kbd> bean must be defined elsewhere. The bean ID, <kbd>"transactionManager"</kbd>, is the default name. We can change it, but then must specify the alternative name everywhere, and that is not so easy to do!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2 - Declaring the transaction demarcation</h1>
                </header>
            
            <article>
                
<p>As the best approach, the service layer of the application is the best place to demarcate the transactions. Let's see this in the following code:</p>
<pre>    @Service 
    public class TransferServiceImpl implements TransferService{ 
      //... 
      @Transactional 
      public void transfer(Long amount, Long a, Long b){ 
        // atomic unit-of-work 
      } 
      //... 
    } </pre>
<p>As you can see in the preceding code, <kbd>TransferServiceImpl</kbd> is our service class at the service layer of the application. This service is the best place to demarcate the transactions for units of work. Spring provides the <kbd>@Transactional</kbd> annotation to demarcate the transactions; this annotation can be used at either the class level or the method level of the service classes in the application. Let's look <kbd>@Transactional</kbd> at the class level:</p>
<pre>    @Service 
    @Transactional 
    public class TransferServiceImpl implements TransferService{ 
      //... 
      public void transfer(Long amount, Account a, Account b){ 
        // atomic unit-of-work 
      } 
      public Long withdraw(Long amount,  Account a){ 
        // atomic unit-of-work 
      } 
      //... 
    } </pre>
<p>If you declare the <kbd>@Transactional</kbd> annotation at the class level, all business methods in this service will be transactional methods.</p>
<div class="packt_infobox">Note--Method visibility should be public if you are using the <kbd>@Transactional</kbd> annotation. If you use this annotation with a non-public method, such as <kbd>protected</kbd>, <kbd>private</kbd>, or <kbd>package-visible</kbd>, no error or exception is thrown, but this annotated method does not show the transactional behavior.</div>
<p>But only using this annotation in the Spring application is not enough. We have to enable the transaction management feature of the Spring Framework by using the <kbd>@EnableTransactionManagement</kbd> annotation in the Java configuration file of Spring, or we can use the namespace <kbd>&lt;tx:annotation-driven/&gt;</kbd> in the XML configuration file. Let's look the following code, for example:</p>
<pre>    @Configuration 
    @EnableTransactionManagement 
    public class InfrastructureConfig { 
    
      //other infrastracture beans definitions 
    
     @Bean 
     public PlatformTransactionManager transactionManager(){ 
         return new DataSourceTransactionManager(dataSource()); 
     } 
   } </pre>
<p>As you can see in the preceding code, <kbd>InfrastructureConfig</kbd> is the Java configuration file of the Spring application--here, we define infrastructure-related beans, and one of the <kbd>transactionManager</kbd> beans too has been defined here. This configuration class annotated with one more annotation is <kbd>@EnableTransactionManagement</kbd>--this annotation defines a Bean Post-Processor in the application, and it proxies <kbd>@Transactional</kbd> beans. Now, take a look at the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="116" width="252" class=" image-border" src="assets/b3b63126-1c60-41c5-be2e-a6d0c607274d.png"/></div>
<p>As you see in the preceding diagram, the <kbd>TransferServiceImpl</kbd> class is wrapped in a Spring proxy.</p>
<p>But to know what happens exactly with the <kbd>@Transactional</kbd> beans in the application, let's see the following steps:</p>
<ol>
<li>The <kbd>target</kbd> object is wrapped in a proxy; it uses an Around advice as we have discussed in <a href="64590e34-2cb4-498b-a576-7a328e683632.xhtml" target="_blank">Chapter 6</a>, Spring Aspect Oriented Programming with Proxy &amp; Decorator Pattern.</li>
<li>The Proxy implements the following behavior:</li>
</ol>
<p style="padding-left: 90px">1. Start transaction before entering the business method.</p>
<p style="padding-left: 90px">2. Commit at the end of the business method.</p>
<p style="padding-left: 90px">3. Roll back if the business method throws a <kbd>RuntimeException</kbd>--it is the default behavior of a Spring transaction, but you can override it for checked and custom exceptions also.</p>
<ol start="3">
<li>The transaction context is now bound to the current thread in the application.</li>
<li>All steps controlled by the configuration either in XML, Java or Annotations.</li>
</ol>
<p>Now take a look at the following diagram of a local JDBC configuration with the associated transaction manager:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="272" width="324" class=" image-border" src="assets/96349dbf-cbec-40c6-8e1b-b60852adfc01.png"/></div>
<p>In the previous diagram, we have defined a local data source using JDBC and a <strong>DataSource Transaction Manager</strong>.</p>
<p>In the next section, we'll discuss how to implement and demarcate transactions programmatically in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Programmatic transaction demarcation and implementation</h1>
                </header>
            
            <article>
                
<p>Spring allows you to implement and demarcate transactions programmatically in the application by using the <kbd>TransactionTemplate</kbd> and a <kbd>PlatformTransactionManager</kbd> implementation directly. But declarative transaction management is highly recommended, because it provides a clean code and a very flexible configuration.</p>
<p>Let's see how to implement the transactions in the application programmatically:</p>
<pre>    package com.packt.patterninspring.chapter8.bankapp.service; 
 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.stereotype.Service; 
    import org.springframework.transaction.PlatformTransactionManager; 
    import org.springframework.transaction.TransactionStatus; 
    import org.springframework.transaction.support.TransactionCallback; 
    import org.springframework.transaction.support.TransactionTemplate; 
 
    import com.packt.patterninspring.chapter8.bankapp.model.Account; 
    import com.packt.patterninspring.chapter8.bankapp.<br/>      repository.AccountRepository; 
 
    @Service 
    public class AccountServiceImpl implements AccountService { 
      //single TransactionTemplate shared amongst all methods in this <br/>      instance 
      private final TransactionTemplate transactionTemplate; 
      @Autowired 
      AccountRepository accountRepository; 
    
      // use constructor-injection to supply the <br/>      PlatformTransactionManager 
      public AccountServiceImpl(PlatformTransactionManager <br/>      transactionManager) { 
        this.transactionTemplate = new <br/>        TransactionTemplate(transactionManager); 
      } 
     
      @Override 
      public Double cheeckAccountBalance(Account account) { 
        return transactionTemplate.execute(new <br/>        TransactionCallback&lt;Double&gt;() { 
          // the code in this method executes in a transactional <br/>          context 
          public Double doInTransaction(TransactionStatus status) { 
            return accountRepository.checkAccountBalance(account); 
          } 
        });  } 
    } </pre>
<p>In the preceding application code, we have used <kbd>TransactionTemplate</kbd> explicitly to execute the application logic in a transactional context. The <kbd>TransactionTemplate</kbd> is also based on the template method design pattern, and it has the same approach as other templates in the Spring Framework, such as the JdbcTemplate. Similar to JdbcTemplate, <kbd>TransactionTemplate</kbd> also uses a callback approach, and it makes application code free from having the boilerplate code for managing transactional resources. We constructed an object of the <kbd>TransactionTemplate</kbd> class in the Service class construction, and passed an object of <kbd>PlatformTransactionManager</kbd> as an argument to the constructor of the <kbd>TransactionTemplate</kbd> class. We also wrote a <kbd>TransactionCallback</kbd> implementation that contains the business logic code of your application, which shows tight coupling between the application logic and transactional code.</p>
<p>We have seen in this chapter how efficiently Spring manages transactions in an enterprise application. Let's now study some best practices that we have to keep in mind whenever we work on the any enterprise application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices for Spring ORM and transaction module in an application</h1>
                </header>
            
            <article>
                
<p>The following are the practices that we have to follow in the design and development of an application:</p>
<p>Avoid using Spring's <kbd>HibernateTemplate</kbd> helper class in the DAO implementation, and use <kbd>SessionFactory</kbd> and <kbd>EntityManager</kbd> in your application. Because of the contextual session capability of Hibernate, use <kbd>SessionFactory</kbd> directly in your DAOs. Additionally, use <kbd>getCurrentSession()</kbd> method to access the transactional current session in order to perform persistence operations in the application. Please refer to the following code:</p>
<pre>    @Repository 
    public class HibernateAccountRepository implements <br/>    AccountRepository { 
      SessionFactory sessionFactory; 
      public HibernateAccountRepository(SessionFactory <br/>      sessionFactory) { 
        super(); 
        this.sessionFactory = sessionFactory; 
      } 
     //... 
   } </pre>
<p>In your application, always use the <kbd>@Repository</kbd> annotation for data access objects or repositories; it provides exception translation. Please refer to the following code:</p>
<pre>    @Repository 
    public class HibernateAccountRepository{//...} </pre>
<p>The service layer must be separate even though business methods in the services only delegate their responsibilities to the corresponding DAO methods.</p>
<p>Always implement transactions at the service layer of the application and not the DAO layer--this is the best place for transactions. <span>Please refer to the following code:</span></p>
<pre>    @Service 
    @Transactional 
    public class AccountServiceImpl implements AccountService {//...} </pre>
<p>Declarative transaction management is more powerful and convenient to configure in the application, and is a highly recommend approach to use in a Spring application. It separates the cross-cutting concerns from business logic.</p>
<p>Always throw runtime exceptions instead of checked exceptions from the service layer.</p>
<p>Be careful of the readOnly flag for the <kbd>@Transactional</kbd> annotation. Mark transactions as <kbd>readOnly=true</kbd> when service methods only contain queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In <a href="81848842-717f-4e27-9204-ace0a6fdce6f.xhtml" target="_blank">Chapter 7</a>, <em>Accessing Database with Spring and JDBC Template Patterns</em>, we saw that Spring provides <kbd>JdbcTemplate</kbd> class based on the GOF template method design pattern. This class handles all the required boilerplate codes underlying the tradition JDBC API. But when we work with the Spring JDBC module, mapping tables to the objects becomes very tedious. In this chapter, we saw the solution to map objects to tables in a relational database--we can do much more with a relational database by using ORM in a complex application. Spring supports integration with several ORM solutions like Hibernate, JPA, and others. These ORM Frameworks enable the declarative programming model for the data persistence instead of using the JDBC programming model.</p>
<p>We also looked at the several design patterns that are implemented in the data access layer or integration tier. These patterns are implemented as a feature in the Spring Framework as proxy pattern for lazy loading, Facade pattern for integration with business tier, DAO patterns for data accessing, and so on.</p>
<p>In the next chapter, we'll see how we can improve our application's performance in production by using Spring's support for cache patterns.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>