- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta EE and JPA – State of Affairs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java, both in language and platform, has improved significantly in enabling
    an effective developer experience and creating highly performant stateful applications.
    Remarkable improvements become evident when examining the evolution of Java database
    integration capabilities and developer experience: look back to the introduction
    of `1.1` and compare it with the most modern experience offered by **Jakarta Enterprise
    Edition** (**Jakarta** **EE**), **MicroProfile**.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents an introduction and overview of the present and future
    of the main enablers of Java’s evolution and constant growth—Jakarta EE, formerly
    Java EE, and Eclipse MicroProfile. From one side, the Eclipse Foundation and Jakarta
    EE target enterprise organizations’ need for stability and reliability. Conversely,
    there’s Eclipse MicroProfile, with fast interactions and constant innovation.
    In parallel, the Jakarta EE platform keeps evolving and adopting comprehensive
    MicroProfile technologies. All this is happening as you read, so it’s time to
    finally comprehend what’s happening in the open community and what to expect from
    a data solution perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Java engineers seeking to deliver scalable enterprise solutions that smoothly
    enable distributed architectures mostly rely on a platform that can support cloud-native
    and traditional solutions. In the corporate world, given the long-term adoption
    of Java, there’s a frequent requirement for flexible technologies that can bring
    the best out of existing technologies and infrastructure without giving up on
    the opportunity of delivering new cloud-native solutions. In this context, the
    Jakarta EE platform is a great choice.
  prefs: []
  type: TYPE_NORMAL
- en: The specification of Jakarta EE is huge and impacts the whole Java community;
    it is essential to highlight that if you’re using Spring, Micronaut, or Quarkus,
    you’re using Jakarta EE even indirectly. In this chapter, we’ll check the specifications
    that Jakarta EE covers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework unveiled—reflection versus reflectionless solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Persistence API** (**JPA**) state of affairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of JPA with Quarkus and Panache cloud-native runtimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General JPA-related performance considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: "[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-05](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter\uFEFF\
    -05)"
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of Jakarta EE lies its collection of specifications, each addressing
    specific aspects of enterprise architecture. These specifications, commonly called
    the “EE specifications,” are designed to cover various use cases encountered in
    enterprise application development. They provide standardized approaches and guidelines
    for implementing key functionalities, ensuring interoperability and portability
    across different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jakarta EE specifications cater to a broad spectrum of enterprise architecture
    needs, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web applications**: The Jakarta Servlet specification provides a platform-independent
    API for building web applications. It defines how web requests and responses are
    handled, allowing developers to create dynamic, interactive, secure web-based
    solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise integration**: The **Jakarta Messaging** (**JMS**) specification
    provides a messaging system enabling seamless communication between distributed
    application components. It ensures a reliable and asynchronous exchange of information,
    facilitating integration across disparate systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: The JPA specification simplifies database access and manipulation
    by providing an **object-relational mapping** (**ORM**) framework. It allows developers
    to interact with relational databases using Java objects, abstracting the underlying
    SQL operations. We can include the Jakarta Bean Validation specification to define
    constraints on Java driven by annotations; further more, new specifications are
    coming to support NoSQL and **domain-driven design** (**DDD**) repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection (DI)**: The Jakarta **Contexts Dependency Injection**
    (**CDI**) specification facilitates loose coupling and promotes modular development
    by managing object creation, wiring, and life cycle management. It enables the
    easy integration of different components within an application, enhancing maintainability
    and testability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The Jakarta Security specification offers a comprehensive set
    of APIs and services for securing enterprise applications. It provides authentication,
    authorization, and data protection mechanisms, helping developers build secure
    applications and protect sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful web services**: The **Jakarta RESTful Web Services** (**JAX-RS**)
    specification simplifies the development of web services using the **Representational
    State Transfer** (**REST**) architectural style. It provides a set of annotations
    and APIs for building scalable, lightweight, and interoperable web APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows an overview of Jakarta EE 10 API, where you see
    the huge number of specifications that can help you as a software engineer; another
    area of the diagram is related to profiles. Currently, there are three profiles
    that you can use based on your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.1 \uFEFF– Jakarta EE 10 specification](img/Figure_5.01_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Jakarta EE 10 specification
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples of the extensive specifications available in Jakarta
    EE. Each specification addresses specific requirements, ensuring developers have
    the tools and guidelines to tackle various enterprise architecture challenges.
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to Jakarta EE specifications, developers can create portable applications
    across different application servers and vendors, allowing flexibility and scalability.
    The specifications foster interoperability and compatibility, enabling seamless
    integration with other systems and services.
  prefs: []
  type: TYPE_NORMAL
- en: Those specifications will help you with modern concepts, approaches, and architectural
    models. In the Jakarta EE 10 API, we have the CDI Lite specification, where the
    goal is to reduce reflection, but what is wrong with reflection? In the next section,
    let’s talk about this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Framework unveiled – reflection versus reflectionless solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java frameworks are crucial in simplifying and accelerating application development
    by providing reusable components, predefined structures, and standard methodologies.
    These frameworks encapsulate common functionalities and design patterns, allowing
    developers to focus on business logic rather than low-level implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: One fundamental concept in Java programming and many Java frameworks is reflection.
    Reflection enables a program to examine and modify its structure and behavior
    at runtime dynamically. It provides a mechanism for inspecting and manipulating
    classes, interfaces, methods, and fields, even if they are unknown at compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflection is essential to developers for several reasons. Here, we list some
    of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic code execution**: Reflection allows developers to instantiate classes,
    invoke methods, and access fields at runtime. This flexibility enables the creation
    of flexible, extensible, and customizable applications. For example, frameworks
    such as Spring and Hibernate heavily rely on reflection to dynamically create
    and wire dependencies, perform data mapping, and handle various aspects of application
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metadata extraction**: Reflection enables the extraction of metadata associated
    with classes, methods, and fields. This metadata may include information such
    as annotations, modifiers, generic types, and method signatures. By analyzing
    this metadata, developers can implement advanced application functionalities and
    behavior. For instance, frameworks such as JUnit use reflection to discover and
    execute test cases based on annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frameworks and annotations**: Java frameworks often utilize annotations,
    markers added to classes, methods, or fields to provide additional information
    or configure specific behaviors. Frameworks such as Spring, JPA, and Java Servlet
    extensively use annotations and reflection to simplify configuration and customization.
    Reflection allows frameworks to scan and process these annotations at runtime,
    enabling automatic configuration, DI, and **Aspect-Oriented** **Programming**
    (**AOP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, while reflection offers excellent flexibility and power, it can impact
    the performance of Java applications during startup. The process of introspecting
    classes and loading metadata dynamically can introduce significant overhead, especially
    in serverless or cloud-native environments where fast startup times are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? Native compilation for Java applications
  prefs: []
  type: TYPE_NORMAL
- en: A great example is the creation of natively executable Java applications, where
    developers use **Java virtual machines** (**JVMs**) such as GraalVM (Oracle) and
    Mandrel (Red Hat) to compile these applications and generate native binaries.
    This process, based on **ahead-of-time** (**AOT**) compilation, results in the
    inability to use some behaviors during runtime—including reflection. The AOT compiler
    does static code analysis during build time to create a native executable, which
    means that all processing done via dynamic loading (such as reflection, the **Java
    Native Interface** (**JNI**), or proxies) represents potential issues for this
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, frameworks such as Quarkus and Micronaut have adopted
    an alternative approach known as the **build-time** or **compile-time** approach.
    Instead of relying on *runtime* reflection, these frameworks leverage annotations
    to capture necessary metadata *during the build process*. Doing so eliminates
    costly reflection operations at runtime and delivers faster startup times and
    improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram illustrates how both approaches work, where with reflection
    Java reads the annotations and any metadata in real time, generating more flexibility
    and pluggability on reading time; this demands more memory and warmup time. We
    can read this information at the build time, where we get a better warmup and
    save more memory at the start; however, we lose our flexibility with reflection.
    As usual, this is a point of trade-off analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2 \uFEFF– Reading Java annotations \uFEFFat runtime versus build\
    \ time](img/Figure_5.02_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Reading Java annotations at runtime versus build time
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is a powerful mechanism in Java programming and frameworks. It enables
    dynamic code execution, metadata extraction, and the utilization of annotations
    for configuration and customization. While reflection can impact startup performance
    in specific scenarios, frameworks such as Quarkus and Micronaut have introduced
    build-time reflection as a solution, allowing developers to leverage the benefits
    of annotations without sacrificing performance. This approach, enabled by CDI
    Lite, promotes efficient usage of Java in serverless and cloud-native environments.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE platform constant evolution – CDI Lite
  prefs: []
  type: TYPE_NORMAL
- en: Based on the needs and impacts highlighted so far, the Jakarta EE platform released
    as version 10 has changes to the CDI specification that accommodate many behaviors
    helpful for this scenario. The CDI Lite specification brings behaviors needed
    by these frameworks and aims to provide a lightweight version of CDI. CDI Lite
    leverages *compile-time reflection* to eliminate the runtime overhead associated
    with full CDI implementations, making it suitable for resource-constrained environments
    and serverless architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can choose between frameworks that employ reflection or follow a
    reflectionless approach when developing Java applications. This comparison table
    will explore critical aspects such as annotation reading, warmup flexibility,
    and encapsulation in these two Java frameworks. Understanding the trade-offs and
    advantages of each approach can help developers make informed decisions based
    on their project requirements and development preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Reflection** | **Reflectionless** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read Java annotations | Real-time | Build time |'
  prefs: []
  type: TYPE_TB
- en: '| Warmup (extra time required by the framework on startup) | It has a slow
    startup | It has a faster startup |'
  prefs: []
  type: TYPE_TB
- en: '| Flexibility | Pluggability in real time | Limitation by build time |'
  prefs: []
  type: TYPE_TB
- en: '| Encapsulation | Strong encapsulation | More limitations at the Java encapsulation
    |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Reflection versus reflectionless solution
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about the application, we’re not sure about the architecture style,
    such as microservices or monolith, or whether we’ll use a real-time or build-time
    Java application; however, for the majority of the solutions, we’ll use any persistence
    engine. Let’s now discuss in more detail the most mature Jakarta persistence specification:
    JPA.'
  prefs: []
  type: TYPE_NORMAL
- en: JPA state of affairs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JPA is a crucial Jakarta EE specification and the most mature data specification
    for enterprise applications. It provides a standardized and robust approach to
    ORM in Java, enabling developers to interact seamlessly with relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the integration between Java applications and relational
    databases, several aspects need to be taken into consideration, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management**: How the configurations are externalized in order
    to be easily yet securely changed based on the environment in which it is being
    deployed (dev, prod, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection handling**: Improper handling of connections with the database
    may lead to extra processing time, as it is expensive. This need is related to
    the requirement of managing open, close, and track connections with the database
    in order to use resources effectively and avoid having too many open and idle
    connections or not enough connections available to the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping classes to database tables**: As we saw in previous chapters, mapping
    objects may be implemented in multiple ways and provide a higher or lower level
    of flexibility and abstraction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping the relation between classes**: OOP brings concepts such as hierarchy,
    which is not available in a relational database schema. Depending on the way these
    classes are configured, data management can have higher complexity and maintenance
    costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction management**: Managing transactions and assuring atomicity and
    rollbacks at the application layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code generation**: Developers can either write pure SQL queries or rely on
    abstractions to speed up the development time. Currently, some frameworks can
    abstract most basic CRUD queries. Unfortunately, if misused, code generation may
    lead to slow queries and restrictions on the proper usage of private methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fetching strategies**: Allows the retrieval of data in ways to take the best
    advantage of memory consumption, and when properly used, brings performance improvements
    as data will only be fetched from the database when needed. This is related to
    the well-known lazy/eager fetching modes available, for example, on Hibernate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupling business logic from technical aspects**: Based on their goals,
    a developer can create extremely flexible and customized code (for example, using
    JDBC) in exchange for negatively impacting code coupling between the data persistence
    layer and the business logic layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering these recurrent needs of Java developers and the possibility to
    create reproducible good practices that could be easily and largely adopted, the
    JPA specification has evolved since its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the ecosystem of JPA as the most mature persistence
    specification in the Jakarta EE world; several vendors and frameworks use it,
    and we can also apply several persistence patterns such as Active Record, Repository,
    and Mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3 \uFEFF– JPA timeline and landscape](img/Figure_5.03_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – JPA timeline and landscape
  prefs: []
  type: TYPE_NORMAL
- en: When combined with frameworks such as Spring and Quarkus, JPA offers the flexibility
    to implement different design approaches, including Active Record, Mapper, and
    Repository patterns. Let’s delve into these design approaches and explore how
    JPA can operate by reading annotations using reflection or at build time.
  prefs: []
  type: TYPE_NORMAL
- en: JPA and database mapping patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with JPA, developers mostly adopt three design options: Active
    Record, Mapper, and Repository. Notice that due to JPA capabilities such as mapping
    entities and their relationships to each other, abstractions for basic database
    operations, and exception-handling mechanisms, adopting the patterns becomes simpler.
    Let’s take a closer look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active Record with JPA**: In this approach, the domain model class encapsulates
    the persistence logic, following the Active Record pattern. It simplifies database
    operations as the domain classes are active participants and are responsible for
    handling CRUD operations and relationships directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When relying on JPA, it is possible to annotate a domain class with JPA annotations
    such as `@Entity` to mark it as a persistent entity. The domain class can also
    be annotated with `@Table`, which will define which is the corresponding database
    table that should be mapped to this entity. These annotations’ metadata enables
    JPA to map the object attributes to the respective database columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mapper**: According to the Mapper pattern, the domain model and the persistence
    logic should be separated with the help of new and dedicated mapper classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA, in combination with frameworks such as Spring and Quarkus, allows developers
    to configure and manage these mappers. The mappers handle the conversion between
    the domain objects and the database tables, abstracting the persistence details
    from the domain model. JPA’s `EntityManager` and `EntityManagerFactory` classes
    provide the necessary APIs to perform database operations, while the mapper classes
    facilitate the mapping between the database and the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Repositories**: The Repository pattern suggests introducing a layer of abstraction
    between the application domain layers and the data access layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing with JPA, developers can define repository interfaces that act
    as contracts specifying the available CRUD operations and queries. JPA’s `EntityManager`
    class is the underlying mechanism for executing queries and managing transactions,
    enabling efficient and scalable data access.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as Spring Data JPA and Quarkus support repositories and can
    automatically generate the necessary implementation code based on the defined
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: When considering the usage of frameworks to implement patterns, we should be
    aware of the pros and cons. We will delve into a detailed code example, but before
    that, let’s check the items to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the application use case and requirements, it would be recommended
    to know what happens under the covers and what limitations your application will
    inherit from the framework you are choosing. When using Active Record with Panache
    and Quarkus, for instance, your entity might be extending the `PanacheEntity`
    class. With Repository, it might be extending `JpaRepository`, a generic Spring
    Data JPA interface. By knowing the chosen framework implementation details, you
    can better identify where you are opting to tightly couple your application code
    with the framework, by using exclusive annotations or dependencies. You’d be aware
    whether and if so, to what extent there will be a violation of the principle of
    **separation of concerns** (**SoC**), or for instance, the extra effort that will
    be needed in case of the need of migration to a different persistence framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros and cons we learned about in *Chapter* 4 apply here as well: Active
    Record will be less complex than Repository, whereas adopting Repository can result
    in better SoC than Active Record, resulting in enhanced maintainability and testability.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll delve into a comprehensive code sample to clarify the trade-offs between
    choosing the convenience offered by frameworks versus adhering to well-known coding
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The power of JPA with Quarkus and Panache cloud-native runtimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how modern persistence frameworks enable developers to rely on
    their knowledge of JPA, let’s take a look at Quarkus and Panache, and the experience
    of developing cloud-native Java services with accelerated development speed. Within
    this context, we’ll evaluate key aspects of design pattern implementation, automatically
    generated persistence code, and some potential drawbacks to take into consideration
    when designing a solution.
  prefs: []
  type: TYPE_NORMAL
- en: You can either follow along or create a brand-new project to try the following
    code. If you haven’t used Quarkus and Panache yet, you may notice quite a difference
    in the development experience of a lightweight runtime compared to traditional
    application servers, and the simplicity of coding straightforward CRUD scenarios
    with Panache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Details on how to create the project can be found in the project’s repository:
    [https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md](https://github.com/architects4j/mastering-java-persistence-book-samples/edit/main/chapter-05/README.md).
    Now, let’s dive into it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The microservice we’re about to see will be used to manage *books* and *magazines*,
    and we’ll explore two different database design patterns using JPA: Repository
    and Active Record.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the new service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we will rely on features for persistence and REST endpoints (easily generated
    through the Quarkus starter page), the project needs dependencies to handle such
    capabilities. Interestingly, much of the hard work will be automatically generated
    by the frameworks, which in turn, are actually based on well-known specifications
    and technologies such as RESTEasy, JSON-B, Hibernate ORM, Hibernate Validator,
    Panache, and JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying storage will be handled by H2, an in-memory data storage, which
    should be useful for learning purposes as it doesn’t require installation of external
    databases or usage of Docker to bootstrap one database instance. However, remember
    that H2 is not recommended for production usage.
  prefs: []
  type: TYPE_NORMAL
- en: The first difference shows up in the Quarkus project’s configuration (`src/main/resources/application.properties`),
    as developers can rely on a single properties configuration file to have `h2`
    as the database kind and `memory` as the JDBC URL. This approach enables changes
    to the underlying database technology without any code modification (for example,
    from H2 to PostgreSQL, MariaDB, or others).
  prefs: []
  type: TYPE_NORMAL
- en: Another positive aspect is that this configuration style relies on the Eclipse
    MicroProfile Configuration specification, which has out-of-the-box support for
    overwriting the application’s properties based on the environment in which the
    application is running—in other words, this is how sensible data (such as the
    username and password) within production environments can remain confidential
    and not be configured directly at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property configuration could be set up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Persistent entities and database operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the foundation ready to go, the project’s entities are created next. We’ll
    start by checking the two patterns from this moment forward, where you can observe
    the `Book` entity is implemented using Active Record, and `Magazine` using the
    Repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Book` class is represented as follows. Note that even though it brings
    the `@Entity` annotation, there are no additional attribute-level annotations.
    Also, the `Book` entity “knows” its database operations, including, for instance,
    how to search for books by name and book release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ll see next, the `Magazine` class uses classic JPA annotations such
    as `@Entity` and `@id` (so far, nothing new under the sun). The reason why the
    `Book` entity does not require an `@id` annotation is that it inherits such capability
    from the class it extends, `PanacheEntity`. `PanacheEntity` handles several operations,
    through heritage, including the `id` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Differently from the class being implemented with Active Record where the database
    operation will be at the entity itself, the `Magazine` class requires an additional
    class to do such data manipulation—a `Repository` class. The `MagazineRepository`
    class has to implement the essential database procedures, plus the queries (such
    as `find by release and name`, as available in the `Book` class). As we are using
    the `PanacheRepository` class, we can save some time on the basic operations as
    they will be automatically generated by Panache later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MagazineRepository` code is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Exposing REST endpoints for data manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, to manipulate data through the classes we’ve checked so far, the application
    exposes REST APIs. The endpoints are `BookResource` and `MagazineResource`, which
    should expose the same database operations for `Book` and `Magazine` so that we
    can evaluate the differences in the usage of each approach. The first difference
    that can be mentioned is that, while we don’t need to inject anything in order
    to use the `BookResource` endpoint, to manipulate the `Magazine` entity, the developer
    must inject the respective `repository` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, observe how the `BookResource` endpoint allows interactions with `Book`,
    the entity implemented with Active Record. You’ll notice as a negative aspect
    the fact that there is a tighter coupling between the endpoint and the Active
    Record. As a positive point, notice how it allows the app to be simpler, with
    fewer layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BookResource` class includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three `GET` endpoints: `findAll`, `findByName`, and `findByYear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One `POST` and one `DELETE` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, observe that the `Book` entity already offers the methods
    that execute operations against the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the `MagazineResource` endpoint, which covers the Repository
    pattern. Observe that even though this is a simple example project, it will increase
    the complexity of the business requirements and time with the erosion of architecture
    in real life. It reminds us of [*Chapter 4*](B19375_04.xhtml#_idTextAnchor076),
    where we covered more about the layers and their trade-offs, so the same layer
    that can help us, in isolation, break what into pieces might impact more complex
    code. As the application expands and incorporates additional layers such as the
    service layer, or as it adopts a hexagonal model, it becomes crucial to carefully
    analyze the trade-offs and pay close attention to the design of persistence layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `MagazineResource` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Key points to observe in the preceding class are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer is required to inject an instance of the `MagazineRepository`
    endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer must implement the class and the methods that are needed, obtaining
    a greater level of control and customization of the underlying implementation,
    plus code with better SoC between the domain entity and the database integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the application is ready, and all operations are ready to be
    accessed via REST and by correctly manipulating data through the methods defined
    by the developer and provided out of the box by Panache.
  prefs: []
  type: TYPE_NORMAL
- en: Even faster development speed – automatic endpoint generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Panache allows even more development speed for standard scenarios, combining
    the benefits of Active Record we’ve seen with the automatic generation of REST
    endpoints. The following capabilities are offered by the `quarkus-hibernate-orm-rest-data-panache`
    Quarkus extension, instead of the previously used `quarkus-hibernate-orm-panache`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: The speed at which a developer can deliver a completely usable CRUD service
    is extremely noticeable when compared to the previous approach, and even more
    so if compared to traditional EE application servers. With the following steps,
    a developer should be able to create a whole CRUD for *newsletters* in just a
    few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking into consideration the existing project, a new `Newsletter` class could
    be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It relies on the Active Record implementation as well. On top of that, it combines
    Quarkus and Panache capabilities for automatically generating REST endpoints based
    on Panache entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the same results as the examples covered before, the following REST
    operations should be available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three `GET` resources: `findAll`, `findById`, and `getCount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`, `PUT`, and `DELETE`, to enable inserting, updating, and deleting newsletters,
    respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this objective, all that is needed is a new interface that extends
    the `PanacheEntityResource` interface. The interface indicates the Panache entity
    that is the `id` attribute type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s all! If running Quarkus using dev mode, the developer should already
    be able to validate the results simply by refreshing the page and checking the
    `swagger-ui` page and the new endpoints, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.4 \uFEFF– New endpoints automatically generated by Panache](img/Figure_5.04_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – New endpoints automatically generated by Panache
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, be aware that when choosing to go down this route, all the attributes
    are configured as public attributes. And here’s your trade-off when using such
    an approach: unless you add extra code to be able to handle the usage of private
    attributes, you will opt for development speed in exchange for completely giving
    up on encapsulation, no access control, increased code coupling (as changes to
    the class may result in potential changes to other classes), and limited control
    and data integrity (the attribute can be directly modified).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may think it is as simple as configuring the attributes as private and
    adding public getters and setters. True—this is mostly the same. But you would
    lack encapsulation in the very same way (as the setter is still public) with “dumb”
    getters and setters. Plus, that is exactly what Panache (in the current version
    at the time of writing) does under the covers: it generates `getter` and `setter`
    attributes and rewrites every usage of these attributes to the respective `getter`
    and `setter` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Panache is very powerful and allows developers to also be more efficient when
    writing queries, where it would be possible—for example—to use code such as `Newsletter.find("order
    by author")`, or `Newletter.find("author = ?1 and headline = ?2", "karina", "Java
    lives!")`, or, even better, `Newsletter.find("author", "karina")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have seen the amazing experience Java developers can get from modern runtime
    technologies and how effective it can be to create from scratch a completely new
    stateful service while relying on existing knowledge of JPA. Next, we’ll slightly
    shift to another topic, highlighting considerations on concerns commonly faced
    by most developers and architects who have ever worked with JPA: performance and
    scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: General JPA-related performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following considerations apply not only to Panache but also to JPA-based
    applications in general. To help identify or go through the performance tuning
    process, you can always rely on the framework capabilities of outputting the DDLs
    being executed (database SQL operations) and the database operations statistics.
    Hibernate, for example, offers several configuration parameters such as `show_sql`,
    `generate_statistics`, `jdbc.batch_size`, `default_batch_fetch_size`, and `cache.use_query_cache`.
    In the following paragraphs, you’ll find considerations revolving around such
    configurations. For now, check here how some configuration could be applied to
    the sample Quarkus application example we just created. These properties allow
    the logging of DDLs and statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that verbose logging configuration should not be used in production as
    it directly impacts application performance; plus, the application log categories
    can be configured individually to output only what you need. As an example, the
    preceding statistics configuration can help you identify slow execution DDLs.
    See one example of information you can obtain for each database operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2023-06-19 02:10:25,402 DEBUG [org.hib.sta.int.StatisticsImpl] (executor-thread-1)
    HHH000117: HQL: SELECT COUNT(*) FROM dev.a4j.mastering.data.Newsletter, time:
    1ms,` `rows: 1`'
  prefs: []
  type: TYPE_NORMAL
- en: If you are worried about performance, certify your code (either due to mapping
    or query parsing) is not *automatically generating slow-performing SQL queries*
    under the covers, *fetching unnecessary information* when not needed, or *automatically
    generating too many queries* instead of running a better-suited single one.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the persistence-related Java code itself, it is also possible to
    fine-tune your JPA data source connection by setting the number of connections
    to be opened by the application during startup, the connection pool size (so that
    open connections can be reused), and how you want the application (via your framework
    and class of choice) to identify and clean idle or unclosed connections.
  prefs: []
  type: TYPE_NORMAL
- en: Another item to consider is batch operations. Let’s say each newsletter can
    contain several articles, and an author can create a new newsletter along with
    50 articles, all at once. In this case, instead of going back and forth between
    the application and the database 51 times to create all articles and the newsletter,
    it would be possible to do it only once to execute all operations. The same applies
    to querying data.
  prefs: []
  type: TYPE_NORMAL
- en: For applications with an intensive number of queries, focus on creating specific
    SQL queries that can perform better, and if the app requires several query executions,
    it is recommended to fine-tune the batch-and-fetch size on the application configuration.
    JDBC batch operations are a good approach to defining how many operations can
    be executed in a single database roundtrip.
  prefs: []
  type: TYPE_NORMAL
- en: For applications with an intensive number of inserts, it is also possible to
    use bulk inserts, making sure to avoid long-running transactions or spending extra
    time each time the “flush” operation occurs (as `EntityManager` will have to handle
    the insert of a large set of objects at once). As applied to most fine-tuning
    configurations, the best way to evaluate which would be the best configuration
    to set on each application is to execute load tests and compare results. Still
    ,in the context of querying data, remember that caching frequently used queries
    helps reduce the number of database hits and improves performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regard to caching in the JPA context, there are two types of cache: first-
    and second-level cache. The first-level cache relates to the objects contained
    within the `EntityManager` cache (session cache). It allows the app to save time
    when accessing objects that were recently accessed or manipulated within a session.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with distributed applications scaled up to many running instances,
    it may be beneficial to consider a second-level cache that allows the usage of
    a shared cache. Remember that caching features are not recommended for 100% of
    scenarios, because even though it may lead to significantly better performance,
    it will demand a good understanding of how to fine-tune the caching solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, fine-tuning a cache solution means providing proper cache invalidation
    (to make sure the cache data is aligned with the underlying database’s current
    data), proper cache synchronization (as there may be multiple cache provider instances),
    eviction policies, and more. In scenarios where there is real-time or up-to-date
    data, take into consideration the challenges of cache usage and the introduced
    possibility of data staleness.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our Quarkus and JPA journey, where we have seen
    both Active Record and Repository patterns with JPA. We can see how easy Active
    Record can be, but at the same time, my entity knows and executes database operations.
    Thus, it has two responsibilities. This is fine when we talk about a redirect
    or any integral functions that do not require a huge demand of business complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, Jakarta EE is a robust platform that provides a comprehensive
    set of specifications, APIs, and tools for developing enterprise applications.
    Within the persistence layer, Jakarta EE shines with its mature JPA specification,
    which offers a standardized approach to ORM. With JPA, developers can leverage
    design patterns such as Active Record and Repository to simplify and streamline
    their data access operations.
  prefs: []
  type: TYPE_NORMAL
- en: When combined with the Quarkus framework, JPA in Jakarta EE demonstrates its
    capabilities in practice. Quarkus, known for its fast startup time and efficient
    resource utilization, enhances the development experience by seamlessly integrating
    with JPA. Developers can leverage the Active Record pattern, allowing their domain
    model classes to handle persistence operations directly. Alternatively, they can
    adopt the Repository pattern, which introduces an abstraction layer for flexible
    and scalable data access. By leveraging JPA within Quarkus, developers can efficiently
    interact with relational databases, ensure data integrity, and achieve optimal
    performance in their Jakarta EE applications.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, with its mature JPA specification, Jakarta EE, in conjunction with
    the Quarkus framework, empowers developers to build robust and efficient persistence
    layers. The combination of Jakarta EE’s standardized approach to persistence and
    Quarkus’ streamlined development experience opens up a world of possibilities
    for creating scalable and high-performing enterprise applications. But how about
    NoSQL? Does Jakarta EE have support for it? Yes, it does; the following chapter
    will cover how to handle several NoSQL database types such as key-value, document,
    and graph with Java.
  prefs: []
  type: TYPE_NORMAL
