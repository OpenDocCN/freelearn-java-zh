<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Server-Side Development</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java EE can be seen as<span class="calibre8"> being </span><strong class="calibre7">made for server-side development</strong>. Most of the APIs are powerful for server-side processing and managing.</p>
<p class="mce-root">This chapter will provide you with some common and useful scenarios that you may face as a Java EE developer and will show you how you should deal with them. </p>
<p class="mce-root"><span class="calibre8">In this chapter, we will cover the following recipes:</span></p>
<ul class="calibre13">
<li class="calibre14">Using CDI to inject context and dependency</li>
<li class="calibre14">Using Bean Validation for data validation</li>
<li class="calibre14">Using servlet for request and response management</li>
<li class="calibre14">Using Server Push to make objects available beforehand</li>
<li class="calibre14">Using EJB and JTA for transaction management</li>
<li class="calibre14">Using EJB to deal with concurrency</li>
<li class="calibre14">Using JPA for smart data persistence</li>
<li class="calibre14">Using EJB and JPA for data caching</li>
<li class="calibre14">Using batch processing</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using CDI to inject context and dependency</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Context and Dependency Injection for Java EE (CDI) is one of the most important APIs under the Java EE umbrella. Introduced in Java EE 6, it now has a big influence over many other APIs.</p>
<p class="mce-root">In the recipe, you will learn how to use CDI in a couple of different ways and situations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, let's add the required dependency needed:</p>
<pre class="calibre21">&lt;dependency&gt;<br class="calibre2"/>    &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;<br class="calibre2"/>    &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;<br class="calibre2"/>    &lt;version&gt;2.0&lt;/version&gt;<br class="calibre2"/>    &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>&lt;/dependency&gt; <br class="calibre2"/>&lt;dependency&gt;<br class="calibre2"/>    &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>    &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>    &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>    &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>&lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We are going to build a JAX-RS based application, so we will start by preparing the application to perform:</li>
</ol>
<pre class="mce-root2">@ApplicationPath("webresources")<br class="calibre2"/>public class Application extends javax.ws.rs.core.Application {<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, we create a <kbd class="calibre16">User</kbd> application as our main object:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO ADD THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<p class="calibre23">Our <kbd class="calibre16">User</kbd> class doesn't have a default constructor, so CDI doesn't know how to construct the class when it tries to inject it. So, we create a factory class and use the <kbd class="calibre16">@Produces</kbd> annotation over its methods:</p>
<pre class="mce-root2">public class UserFactory implements Serializable{<br class="calibre2"/><br class="calibre2"/>    @Produces<br class="calibre2"/>    public User getUser() {<br class="calibre2"/>        return new User("Elder Moraes", "elder@eldermoraes.com");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Let's create an enumeration to list our profile types:</li>
</ol>
<pre class="mce-root2">public enum ProfileType {<br class="calibre2"/>    ADMIN, OPERATOR;<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">Here, we create a custom annotation:</li>
</ol>
<pre class="mce-root2">@Qualifier<br class="calibre2"/>@Retention(RetentionPolicy.RUNTIME)<br class="calibre2"/>@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})<br class="calibre2"/>public @interface Profile {<br class="calibre2"/>    ProfileType value();<br class="calibre2"/>}</pre>
<ol start="5" class="calibre19">
<li class="chapter">Add them to an interface to prototype the user profile behavior:</li>
</ol>
<pre class="mce-root2">public interface UserProfile {<br class="calibre2"/>    ProfileType type();<br class="calibre2"/>}</pre>
<p class="calibre23">Now that we have defined the profile list and its behavior with respect to the user, we can give it a proper implementation for an admin profile:</p>
<pre class="mce-root2">@Profile(ProfileType.ADMIN)<br class="calibre2"/>public class ImplAdmin implements UserProfile{<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public ProfileType type() {<br class="calibre2"/>        System.out.println("User is admin");<br class="calibre2"/>        return ProfileType.ADMIN;<br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<p class="calibre23">And the same can be done for an operator profile:</p>
<pre class="mce-root2">@Profile(ProfileType.OPERATOR)<br class="calibre2"/>@Default<br class="calibre2"/>public class ImplOperator implements UserProfile{<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public ProfileType type() {<br class="calibre2"/>        System.out.println("User is operator");<br class="calibre2"/>        return ProfileType.OPERATOR;<br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<ol start="6" class="calibre19">
<li class="chapter">Then, we create a REST endpoint by injecting all the objects that we are going to use into it:</li>
</ol>
<pre class="calibre24">@Path("userservice/")<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class UserService {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private User user;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    @Profile(ProfileType.ADMIN)<br class="calibre2"/>    private UserProfile userProfileAdmin;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    @Profile(ProfileType.OPERATOR)<br class="calibre2"/>    private UserProfile userProfileOperator;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserProfile userProfileDefault;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private Event&lt;User&gt; userEvent;<br class="calibre2"/><br class="calibre2"/>    ...</pre>
<ol start="7" class="calibre19">
<li class="chapter">This method gets the user injected by CDI and sends it to the result page:</li>
</ol>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getUser")<br class="calibre2"/>    public Response getUser(@Context HttpServletRequest request, <br class="calibre2"/>            @Context HttpServletResponse response) <br class="calibre2"/>            throws ServletException, IOException{<br class="calibre2"/>        <br class="calibre2"/>        request.setAttribute("result", user);<br class="calibre2"/>        request.getRequestDispatcher("/result.jsp")<br class="calibre2"/>        .forward(request, response);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<ol start="8" class="calibre19">
<li class="chapter">This one does the same with an admin profile:</li>
</ol>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getProfileAdmin")<br class="calibre2"/>    public Response getProfileAdmin(@Context HttpServletRequest request, <br class="calibre2"/>            @Context HttpServletResponse response) <br class="calibre2"/>            throws ServletException, IOException{<br class="calibre2"/>        <br class="calibre2"/>            request.setAttribute("result", <br class="calibre2"/>            fireUserEvents(userProfileAdmin.type()));<br class="calibre2"/>             request.getRequestDispatcher("/result.jsp")<br class="calibre2"/>             .forward(request, response);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<ol start="9" class="calibre19">
<li class="chapter">And this one does the same with an operator profile:</li>
</ol>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getProfileOperator")<br class="calibre2"/>    public Response getProfileOperator(@Context HttpServletRequest request, <br class="calibre2"/>            @Context HttpServletResponse response) <br class="calibre2"/>            throws ServletException, IOException{<br class="calibre2"/>        <br class="calibre2"/>            request.setAttribute("result", <br class="calibre2"/>            fireUserEvents(userProfileOperator.type())); <br class="calibre2"/>            request.getRequestDispatcher("/result.jsp")<br class="calibre2"/>            .forward(request, response);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<ol start="10" class="calibre19">
<li class="chapter">Finally, we send the default profile to the result page:</li>
</ol>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getProfileDefault")<br class="calibre2"/>    public Response getProfileDefault(@Context HttpServletRequest request, <br class="calibre2"/>            @Context HttpServletResponse response) <br class="calibre2"/>            throws ServletException, IOException{<br class="calibre2"/>        <br class="calibre2"/>            request.setAttribute("result", <br class="calibre2"/>            fireUserEvents(userProfileDefault.type())); <br class="calibre2"/>            request.getRequestDispatcher("/result.jsp")<br class="calibre2"/>            .forward(request, response);<br class="calibre2"/>            return Response.ok().build();<br class="calibre2"/>    }</pre>
<ol start="11" class="calibre19">
<li class="chapter">We use the <kbd class="calibre16">fireUserEvents</kbd> method to fire an event and async events over a <span class="calibre5">previously injected</span> <kbd class="calibre16">User</kbd> object:</li>
</ol>
<pre class="calibre21">    private ProfileType fireUserEvents(ProfileType type){<br class="calibre2"/>        userEvent.fire(user);<br class="calibre2"/>        userEvent.fireAsync(user);<br class="calibre2"/>        return type;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void sendUserNotification(@Observes User user){<br class="calibre2"/>        System.out.println("sendUserNotification: " + user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void sendUserNotificationAsync(@ObservesAsync User user){<br class="calibre2"/>        System.out.println("sendUserNotificationAsync: " + user);<br class="calibre2"/>    }</pre>
<ol start="12" class="calibre19">
<li class="chapter">So, we build a page to call each endpoint method:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/> &lt;a href="http://localhost:8080/ch02-<br class="calibre2"/> cdi/webresources/userservice/getUser"&gt;getUser&lt;/a&gt;<br class="calibre2"/> &lt;br&gt;<br class="calibre2"/> &lt;a href="http://localhost:8080/ch02-<br class="calibre2"/> cdi/webresources/userservice/getProfileAdmin"&gt;getProfileAdmin&lt;/a&gt;<br class="calibre2"/> &lt;br&gt;<br class="calibre2"/> &lt;a href="http://localhost:8080/ch02-<br class="calibre2"/> cdi/webresources/userservice/getProfileOperator"&gt;getProfileOperator&lt;/a&gt;<br class="calibre2"/> &lt;br&gt;<br class="calibre2"/> &lt;a href="http://localhost:8080/ch02-<br class="calibre2"/> cdi/webresources/userservice/getProfileDefault"&gt;getProfileDefault&lt;/a&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<ol start="13" class="calibre19">
<li class="chapter">And finally, we use an expression language to print the result at the result page:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/>    &lt;h1&gt;${result}&lt;/h1&gt;<br class="calibre2"/>    &lt;a href="javascript:window.history.back();"&gt;Back&lt;/a&gt;<br class="calibre2"/>&lt;/body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Well, there's a lot happening in the previous section! We should first have a look at the <kbd class="calibre16">@Produces</kbd> annotation. It is a CDI annotation that says to the server: "<em class="calibre17">Hey! This method knows how to construct a User object.</em>"</p>
<p class="mce-root">As we didn't create a default constructor for the <kbd class="calibre16">User</kbd> class, the <kbd class="calibre16">getUser</kbd> method from our factory will be injected into our context as one.</p>
<p class="mce-root">The second annotation is our custom annotation <kbd class="calibre16">@Profile</kbd> that has our enumeration <kbd class="calibre16">ProfileType</kbd> as a parameter. It is the qualifier of our <kbd class="calibre16">UserProfile</kbd> objects.</p>
<p class="mce-root">Now, let's have a look at these declarations:</p>
<pre class="calibre21">@Profile(ProfileType.ADMIN)<br class="calibre2"/>public class ImplAdmin implements UserProfile{<br class="calibre2"/>   ...<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>@Profile(ProfileType.OPERATOR)<br class="calibre2"/>@Default<br class="calibre2"/>public class ImplOperator implements UserProfile{<br class="calibre2"/>   ...<br class="calibre2"/>}</pre>
<p class="mce-root">This code will <em class="calibre17">teach</em> CDI how to inject a <kbd class="calibre16">UserProfile</kbd> object:</p>
<ul class="calibre13">
<li class="calibre14">If the object is annotated as <kbd class="calibre16">@Profile(ProfileType.ADMIN)</kbd>, use <kbd class="calibre16">ImplAdmin</kbd></li>
<li class="calibre14">If the object is annotated as <kbd class="calibre16">@Profile(ProfileType.OPERATOR)</kbd>, use <kbd class="calibre16">ImplOperator</kbd></li>
<li class="calibre14">If the object is not annotated, use <span class="calibre5"><kbd class="calibre16">ImplOperator</kbd>, as it has the <kbd class="calibre16">@Default</kbd> annotation</span></li>
</ul>
<p class="mce-root">We can see them in action in our endpoint declaration:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    @Profile(ProfileType.ADMIN)<br class="calibre2"/>    private UserProfile userProfileAdmin;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    @Profile(ProfileType.OPERATOR)<br class="calibre2"/>    private UserProfile userProfileOperator;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserProfile userProfileDefault;</pre>
<p class="mce-root">So CDI is helping us to use the context to inject the right implementation of our <kbd class="calibre16">UserProfile</kbd> interface.</p>
<p class="mce-root">Looking at the endpoint methods, we see this:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getUser")<br class="calibre2"/>    public Response getUser(@Context HttpServletRequest request, <br class="calibre2"/>            @Context HttpServletResponse response) <br class="calibre2"/>            throws ServletException, IOException{<br class="calibre2"/>        <br class="calibre2"/>        request.setAttribute("result", user);<br class="calibre2"/>        request.getRequestDispatcher("/result.jsp")<br class="calibre2"/>        .forward(request, response);<br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }</pre>
<p class="mce-root">Note that we included <kbd class="calibre16">HttpServletRequest</kbd> and <kbd class="calibre16">HttpServletResponse</kbd> as parameters for our method, but annotated them as <kbd class="calibre16">@Context</kbd>. So even though this is not a servlet context (when we have easy access to request and response references), we can ask CDI to give us a proper reference to them.</p>
<p class="mce-root">And finally, we have our user event engine:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    private Event&lt;User&gt; userEvent;<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    private ProfileType fireUserEvents(ProfileType type){<br class="calibre2"/>        userEvent.fire(user);<br class="calibre2"/>        userEvent.fireAsync(user);<br class="calibre2"/>        return type;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void sendUserNotification(@Observes User user){<br class="calibre2"/>        System.out.println("sendUserNotification: " + user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void sendUserNotificationAsync(@ObservesAsync User user){<br class="calibre2"/>        System.out.println("sendUserNotificationAsync: " + user);<br class="calibre2"/>    }</pre>
<p class="mce-root">So, we are using the <kbd class="calibre16">@Observes</kbd> and <kbd class="calibre16">@ObserversAsync</kbd> annotations to say to CDI: "<em class="calibre17">Hey CDI! Watch over User object... when somebody fires an event over it, I want you to do something.</em>" </p>
<p class="mce-root">And for "something," CDI understands this as calling the <kbd class="calibre16">sendUserNotification</kbd> and <span class="calibre8"><kbd class="calibre16">sendUserNotificationAsync</kbd> methods. Try it!</span></p>
<p class="mce-root">Obviously, <kbd class="calibre16">@Observers</kbd> will be executed synchronously and <kbd class="calibre16">@ObservesAsync</kbd> asynchronously.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We used a GlassFish 5 to run this recipe. You can do it with whatever Java EE 8 compatible server you want, and you can even use CDI with Java SE without any server. Have a look at the CDI recipe from <a href="86071f26-42aa-43e2-8409-6feaed4759e0.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 1</a>, <em class="calibre17">New Features and Improvements</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">You can see the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Bean Validation for data validation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You can use Bean Validation to constrain your data in many different ways. In this recipe, we are going to use it to validate a JSF form, so we can validate it as soon as the user tries to submit it, and avoid any invalid data right away.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, we add our dependencies:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax.validation&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;validation-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;2.0.0.Final&lt;/version&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;6.0.1.Final&lt;/version&gt;<br class="calibre2"/>        &lt;/dependency&gt; <br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's create a <kbd class="calibre16">User</kbd> object that will be attached to our JSF page:</li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class User {<br class="calibre2"/>    <br class="calibre2"/>    @NotBlank (message = "Name should not be blank")<br class="calibre2"/>    @Size (min = 4, max = 10,message = "Name should be between <br class="calibre2"/>    4 and 10 characters")<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    @Email (message = "Invalid e-mail format")<br class="calibre2"/>    @NotBlank (message = "E-mail shoud not be blank")<br class="calibre2"/>    private String email;<br class="calibre2"/>    <br class="calibre2"/>    @PastOrPresent (message = "Created date should be <br class="calibre2"/>    past or present")<br class="calibre2"/>    @NotNull (message = "Create date should not be null")<br class="calibre2"/>    private LocalDate created;<br class="calibre2"/>    <br class="calibre2"/>    @Future (message = "Expires should be a future date")<br class="calibre2"/>    @NotNull (message = "Expires should not be null")<br class="calibre2"/>    private LocalDate expires;<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/><br class="calibre2"/>    ...</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we define the method that will be fired once all data is valid:</li>
</ol>
<pre class="calibre21">    public void valid(){<br class="calibre2"/>        FacesContext<br class="calibre2"/>                .getCurrentInstance()<br class="calibre2"/>                .addMessage(<br class="calibre2"/>                    null, <br class="calibre2"/>                    new FacesMessage(FacesMessage.SEVERITY_INFO,<br class="calibre2"/>                    "Your data is valid", ""));<br class="calibre2"/>    }</pre>
<ol start="3" class="calibre19">
<li class="chapter">And now our JSF page references each <kbd class="calibre16">User</kbd> class fields declared:</li>
</ol>
<pre class="mce-root2">&lt;h:body&gt;<br class="calibre2"/> &lt;h:form&gt;<br class="calibre2"/> &lt;h:outputLabel for="name" value="Name" /&gt;<br class="calibre2"/> &lt;h:inputText id="name" value="#{user.name}" /&gt;<br class="calibre2"/> &lt;br/&gt;<br class="calibre2"/> &lt;h:outputLabel for="email" value="E-mail" /&gt;<br class="calibre2"/> &lt;h:inputText id="email" value="#{user.email}" /&gt;<br class="calibre2"/> &lt;br/&gt;<br class="calibre2"/> &lt;h:outputLabel for="created" value="Created" /&gt;<br class="calibre2"/> &lt;h:inputText id="created" value="#{user.created}"&gt;<br class="calibre2"/>     &lt;f:convertDateTime type="localDate" pattern="dd/MM/uuuu" /&gt; <br class="calibre2"/> &lt;/h:inputText&gt;<br class="calibre2"/> &lt;br/&gt;<br class="calibre2"/> &lt;h:outputLabel for="expire" value="Expire" /&gt;<br class="calibre2"/> &lt;h:inputText id="expire" value="#{user.expires}"&gt;<br class="calibre2"/>     &lt;f:convertDateTime type="localDate" pattern="dd/MM/uuuu" /&gt; <br class="calibre2"/> &lt;/h:inputText&gt;<br class="calibre2"/> &lt;br/&gt;<br class="calibre2"/> &lt;h:commandButton value="submit" type="submit" action="#{user.valid()}" /&gt;<br class="calibre2"/> &lt;/h:form&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>
<p class="mce-root">Now, if you run this code, you will get all fields validated once you click the <span class="calibre8">Submit</span> button. Try it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's check each declared constraint:</p>
<pre class="calibre21">    @NotBlank (message = "Name should not be blank")<br class="calibre2"/>    @Size (min = 4, max = 10,message = "Name should be between <br class="calibre2"/>           4 and 10 characters")<br class="calibre2"/>    private String name;</pre>
<p class="mce-root">The <kbd class="calibre16">@NotBlank</kbd> annotation will deny not only null values, but also white spaces values, and <kbd class="calibre16">@Size</kbd> speaks for itself:</p>
<pre class="calibre21">    @Email (message = "Invalid e-mail format")<br class="calibre2"/>    @NotBlank (message = "E-mail shoud not be blank")<br class="calibre2"/>    private String email;</pre>
<p class="mce-root">The <kbd class="calibre16">@Email</kbd> constraint will check the email string format:</p>
<pre class="calibre21">    @PastOrPresent (message = "Created date should be past or present")<br class="calibre2"/>    @NotNull (message = "Create date should not be null")<br class="calibre2"/>    private LocalDate created;</pre>
<p class="mce-root"><kbd class="calibre16">@PastOrPresent</kbd> will constrain <kbd class="calibre16">LocalDate</kbd> to be in the past or until the present date. It can't be in the future. </p>
<p class="mce-root">Here we can't use <kbd class="calibre16">@NotBlank</kbd>, as there is no blank date, only null, so we avoid it using <kbd class="calibre16">@NotNull</kbd>:</p>
<pre class="calibre21">    @Future (message = "Expires should be a future date")<br class="calibre2"/>    @NotNull (message = "Expires should not be null")<br class="calibre2"/>    private LocalDate expires;</pre>
<p class="mce-root">This is the same as the last one, but constraints for a future date.</p>
<p class="mce-root">In our UI, there are two places worth a careful look:</p>
<pre class="calibre21"> &lt;h:inputText id="created" value="#{user.created}"&gt;<br class="calibre2"/>     &lt;f:convertDateTime type="localDate" pattern="dd/MM/uuuu" /&gt; <br class="calibre2"/> &lt;/h:inputText&gt;<br class="calibre2"/><br class="calibre2"/> ...<br class="calibre2"/><br class="calibre2"/> &lt;h:inputText id="expire" value="#{user.expires}"&gt;<br class="calibre2"/>     &lt;f:convertDateTime type="localDate" pattern="dd/MM/uuuu" /&gt; <br class="calibre2"/> &lt;/h:inputText&gt;</pre>
<p class="mce-root">We are using <kbd class="calibre16">convertDateTime</kbd> to automatically convert the data inputted into <kbd class="calibre16">inputText</kbd> according to the <span class="calibre8"><kbd class="calibre16">dd/MM/uuuu</kbd> </span>pattern. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">You can check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using servlet for request and response management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Servlet API was created even before Java EE exists—actually before J2EE existed! It became part of EE in J2EE 1.2 (Servlet 2.2) in 1999.</p>
<p class="mce-root">This is a powerful tool to deal with a request/response context and this recipe will show you an example of how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's add our dependencies:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.0.0-b05&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt; <br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's create a <kbd class="calibre16">User</kbd> class for our recipe:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And then our servlet:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "UserServlet", urlPatterns = {"/UserServlet"})<br class="calibre2"/>public class UserServlet extends HttpServlet {<br class="calibre2"/>    <br class="calibre2"/>    private User user;<br class="calibre2"/>    <br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void instantiateUser(){<br class="calibre2"/>        user = new User("Elder Moraes", "elder@eldermoraes.com");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>   ...</pre>
<div class="packt_infobox">We use the<span class="calibre5"> </span><kbd class="calibre25">@PostConstruct</kbd><span class="calibre5"> annotation over the </span><kbd class="calibre25">instantiateUser()</kbd><span class="calibre5"> method. It says to the server that whenever this servlet is constructed (a new instance is up), it can run this method.</span></div>
<ol start="3" class="calibre19">
<li class="chapter">We also implement the <kbd class="calibre16">init()</kbd> and <kbd class="calibre16">destroy()</kbd> super methods:</li>
</ol>
<pre class="calibre21">    @Override<br class="calibre2"/>    public void init() throws ServletException {<br class="calibre2"/>        System.out.println("Servlet " + this.getServletName() + <br class="calibre2"/>                           " has started");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void destroy() {<br class="calibre2"/>        System.out.println("Servlet " + this.getServletName() + <br class="calibre2"/>                           " has destroyed");<br class="calibre2"/>    }</pre>
<ol start="4" class="calibre19">
<li class="chapter">And we also implemented <kbd class="calibre16">doGet()</kbd> and <kbd class="calibre16">doPost()</kbd>:</li>
</ol>
<pre class="calibre21">    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPost(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }</pre>
<ol start="5" class="calibre19">
<li class="chapter">Both <kbd class="calibre16">doGet()</kbd> and <kbd class="calibre16">doPost()</kbd> will call our custom method <kbd class="calibre16">doRequest()</kbd>:</li>
</ol>
<pre class="calibre21">    protected void doRequest(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        response.setContentType("text/html;charset=UTF-8");<br class="calibre2"/>        try (PrintWriter out = response.getWriter()) {<br class="calibre2"/>            out.println("&lt;html&gt;");<br class="calibre2"/>            out.println("&lt;head&gt;");<br class="calibre2"/>            out.println("&lt;title&gt;Servlet UserServlet&lt;/title&gt;");<br class="calibre2"/>            out.println("&lt;/head&gt;");<br class="calibre2"/>            out.println("&lt;body&gt;");<br class="calibre2"/>            out.println("&lt;h2&gt;Servlet UserServlet at " + <br class="calibre2"/>                         request.getContextPath() + "&lt;/h2&gt;");<br class="calibre2"/>            out.println("&lt;h2&gt;Now: " + new Date() + "&lt;/h2&gt;");<br class="calibre2"/>            out.println("&lt;h2&gt;User: " + user.getName() + "/" + <br class="calibre2"/>                        user.getEmail() + "&lt;/h2&gt;");<br class="calibre2"/>            out.println("&lt;/body&gt;");<br class="calibre2"/>            out.println("&lt;/html&gt;");<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<ol start="6" class="calibre19">
<li class="chapter">And we finally have a web page to call our servlet:</li>
</ol>
<pre class="calibre21">    &lt;body&gt;<br class="calibre2"/>        &lt;a href="&lt;%=request.getContextPath()%&gt;/UserServlet"&gt;<br class="calibre2"/>        &lt;%=request.getContextPath() %&gt;/UserServlet&lt;/a&gt;<br class="calibre2"/>    &lt;/body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java EE server itself will call <kbd class="calibre16">doGet()</kbd> or <kbd class="calibre16">doPost()</kbd> methods, depending on the HTTP method used by the caller. In our recipe, we are redirecting them both to the same <kbd class="calibre16"><span class="calibre5">doRequest()</span></kbd> method.</p>
<p class="mce-root">The <kbd class="calibre16">init()</kbd> method belongs to the servlet life cycle managed by the server and is executed as a first method after the servlet instantiation. </p>
<p class="mce-root">The <kbd class="calibre16">destroy()</kbd> method also belongs to the servlet life cycle and it's executed as the last method before the instance deallocation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre8">The <kbd class="calibre16">init()</kbd> behavior seems like <kbd class="calibre16">@PostConstruct</kbd>, but this last one is executed before <kbd class="calibre16">init()</kbd>, so keep it in mind when using both.</span></p>
<p class="mce-root">The <kbd class="calibre16">@PostConstruct</kbd> is executed right after the default constructor.</p>
<p class="mce-root">Be careful when using the <kbd class="calibre16">destroy()</kbd> method and avoid holding any memory reference; otherwise, you can mess up with the servlet life cycle and run into memory leaks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Server Push to make objects available beforehand</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the most important new features of Servlet 4.0 is the HTTP/2.0 support. It brings another cool and reliable feature—the Server Push.</p>
<p class="mce-root"><span class="calibre8">This recipe will show you how to use Server Push in a filter and push the resources needed in every request that we want.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We should first add the dependencies needed:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.0.0-b07&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt; <br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We first create <kbd class="calibre16">UserServlet</kbd> that calls <kbd class="calibre16">user.jsp</kbd>:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "UserServlet", urlPatterns = {"/UserServlet"})<br class="calibre2"/>public class UserServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    protected void doRequest(HttpServletRequest request, <br class="calibre2"/>                             HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        request.getRequestDispatcher("/user.jsp")<br class="calibre2"/>        .forward(request, response);<br class="calibre2"/>        System.out.println("Redirected to user.jsp");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>                         HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPost(HttpServletRequest request, <br class="calibre2"/>                          HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And we do the same with <kbd class="calibre16">ProfileServlet</kbd>, but by calling <kbd class="calibre16">profile.jsp</kbd>:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "ProfileServlet", urlPatterns = {"/ProfileServlet"})<br class="calibre2"/>public class ProfileServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    protected void doRequest(HttpServletRequest request, <br class="calibre2"/>                             HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        request.getRequestDispatcher("/profile.jsp").<br class="calibre2"/>        forward(request, response);<br class="calibre2"/>        System.out.println("Redirected to profile.jsp");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>                         HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPost(HttpServletRequest request, <br class="calibre2"/>                          HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        doRequest(request, response);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And then we create a filter that will be executed on every request (<kbd class="calibre16">urlPatterns = {"/*"}</kbd>):</li>
</ol>
<pre class="mce-root2">@WebFilter(filterName = "PushFilter", urlPatterns = {"/*"})<br class="calibre2"/>public class PushFilter implements Filter {<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public void doFilter(ServletRequest request, <br class="calibre2"/>    ServletResponse response,<br class="calibre2"/>            FilterChain chain)<br class="calibre2"/>            throws IOException, ServletException {<br class="calibre2"/>        <br class="calibre2"/>        HttpServletRequest httpReq = (HttpServletRequest)request;<br class="calibre2"/>        PushBuilder builder = httpReq.newPushBuilder();<br class="calibre2"/>        <br class="calibre2"/>        if (builder != null){<br class="calibre2"/>            builder<br class="calibre2"/>                .path("resources/javaee-logo.png")<br class="calibre2"/>                .path("resources/style.css")<br class="calibre2"/>                .path("resources/functions.js")<br class="calibre2"/>                .push(); <br class="calibre2"/>            System.out.println("Resources pushed");<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        chain.doFilter(request, response);<br class="calibre2"/>        <br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">Here we create a page to call our servlets:</li>
</ol>
<pre class="mce-root2">&lt;body&gt;<br class="calibre2"/> &lt;a href="UserServlet"&gt;User&lt;/a&gt;<br class="calibre2"/> &lt;br/&gt;<br class="calibre2"/> &lt;a href="ProfileServlet"&gt;Profile&lt;/a&gt;<br class="calibre2"/>&lt;/body&gt;</pre>
<ol start="5" class="calibre19">
<li class="chapter">And here are the pages called by the servlets. First is the <kbd class="calibre16">user.jsp</kbd> page:</li>
</ol>
<pre class="calibre21">    &lt;head&gt;<br class="calibre2"/>        &lt;meta http-equiv="Content-Type" content="text/html; <br class="calibre2"/>         charset=UTF-8"&gt;<br class="calibre2"/>        &lt;link rel="stylesheet" type="text/css"   <br class="calibre2"/>         href="resources/style.css"&gt;<br class="calibre2"/>        &lt;script src="resources/functions.js"&gt;&lt;/script&gt;<br class="calibre2"/>        &lt;title&gt;User Push&lt;/title&gt;<br class="calibre2"/>    &lt;/head&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;body&gt;<br class="calibre2"/>        &lt;h1&gt;User styled&lt;/h1&gt;<br class="calibre2"/>        &lt;img src="resources/javaee-logo.png"&gt;<br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;button onclick="message()"&gt;Message&lt;/button&gt;<br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;a href="javascript:window.history.back();"&gt;Back&lt;/a&gt;<br class="calibre2"/>    &lt;/body&gt;</pre>
<ol start="6" class="calibre19">
<li class="chapter">Second, the <kbd class="calibre16">profile.jsp</kbd> page is called:</li>
</ol>
<pre class="calibre21">    &lt;head&gt;<br class="calibre2"/>        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;<br class="calibre2"/>        &lt;link rel="stylesheet" type="text/css" href="resources/style.css"&gt;<br class="calibre2"/>        &lt;script src="resources/functions.js"&gt;&lt;/script&gt;<br class="calibre2"/>        &lt;title&gt;User Push&lt;/title&gt;<br class="calibre2"/>    &lt;/head&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;body&gt;<br class="calibre2"/>        &lt;h1&gt;Profile styled&lt;/h1&gt;<br class="calibre2"/>        &lt;img src="resources/javaee-logo.png"&gt;<br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;button onclick="message()"&gt;Message&lt;/button&gt;<br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;a href="javascript:window.history.back();"&gt;Back&lt;/a&gt;<br class="calibre2"/>    &lt;/body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A web application running under HTTP/1.0 sends a request to the server when it finds references for an image file, CSS file, and any other resources needed to render a web page.</p>
<p class="mce-root">With HTTP/2.0 you still can do it, but now you can do better: the server can now push the resources beforehand, avoiding unnecessary new requests, decreasing the server load, and improving performance.</p>
<p class="mce-root">In this recipe, our resources are represented by the following:</p>
<pre class="calibre21">        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;<br class="calibre2"/>        &lt;link rel="stylesheet" type="text/css" href="resources/style.css"&gt;<br class="calibre2"/>        &lt;script src="resources/functions.js"&gt;&lt;/script&gt;</pre>
<p class="mce-root">And the push happens at this part of our filter:</p>
<pre class="calibre21">        HttpServletRequest httpReq = (HttpServletRequest)request;<br class="calibre2"/>        PushBuilder builder = httpReq.newPushBuilder();<br class="calibre2"/>        <br class="calibre2"/>        if (builder != null){<br class="calibre2"/>            builder<br class="calibre2"/>                .path("resources/javaee-logo.png")<br class="calibre2"/>                .path("resources/style.css")<br class="calibre2"/>                .path("resources/functions.js")<br class="calibre2"/>                .push(); <br class="calibre2"/>            System.out.println("Resources pushed");<br class="calibre2"/>        }</pre>
<p class="mce-root">So when the browser needs those resources to render the web page, they are already available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Note that your browser needs to support the Server Push feature; otherwise, your page will work as usual. So make sure you check if <kbd class="calibre16">PushBuilder</kbd> is null before using it and ensure all users will have the working application.</p>
<p class="mce-root">Note that JSF 2.3 is built over the Server Push feature, so if you just migrate your JSF application to a Java EE 8 compatible server, you get its performance boost for free!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">View the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using EJB and JTA for transaction management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java Transaction API, or JTA, is an API that enables distributed transactions over the Java EE environment. It is most powerful when you delegate the transaction management to the server.</p>
<p class="mce-root">This recipe will show you how to do it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, add the dependencies:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.3.1.Final&lt;/version&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;junit&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.12&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;1.3&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.apache.openejb&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;openejb-core&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.7.4&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we need to create our persistence unit (at <kbd class="calibre16">persistence.xml</kbd>):</li>
</ol>
<pre class="calibre21">    &lt;persistence-unit name="ch02-jta-pu" transaction-type="JTA"&gt;<br class="calibre2"/>        &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;<br class="calibre2"/>        <br class="calibre2"/>        &lt;jta-data-source&gt;userDb&lt;/jta-data-source&gt;<br class="calibre2"/>        &lt;non-jta-data-source&gt;userDbNonJta&lt;/non-jta-data-source&gt;<br class="calibre2"/>        <br class="calibre2"/>        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;<br class="calibre2"/><br class="calibre2"/>        &lt;properties&gt;<br class="calibre2"/>            &lt;property name="javax.persistence.schema-<br class="calibre2"/>             generation.database.action" <br class="calibre2"/>             value="create"/&gt;<br class="calibre2"/>        &lt;/properties&gt;<br class="calibre2"/>    &lt;/persistence-unit&gt;</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we create a <kbd class="calibre16">User</kbd> class as an entity (<kbd class="calibre16">@Entity</kbd>):</li>
</ol>
<pre class="mce-root2">@Entity<br class="calibre2"/>public class User implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @GeneratedValue(strategy = GenerationType.AUTO)<br class="calibre2"/>    private Long id;<br class="calibre2"/>    <br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    protected User() {<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name, String email) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">We also need an EJB to perform the operations over the <kbd class="calibre16">User</kbd> entity:</li>
</ol>
<pre class="mce-root2">@Stateful<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext(unitName = "ch02-jta-pu", <br class="calibre2"/>    type = PersistenceContextType.EXTENDED)<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/>    <br class="calibre2"/>    public void add(User user){<br class="calibre2"/>        em.persist(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void update(User user){<br class="calibre2"/>        em.merge(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void remove(User user){<br class="calibre2"/>        em.remove(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User findById(Long id){<br class="calibre2"/>        return em.find(User.class, id);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And then we create our unit test:</li>
</ol>
<pre class="mce-root2">public class Ch02JtaTest {<br class="calibre2"/>    <br class="calibre2"/>    private EJBContainer ejbContainer;<br class="calibre2"/>    <br class="calibre2"/>    @EJB<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    public Ch02JtaTest() {<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Before<br class="calibre2"/>    public void setUp() throws NamingException {<br class="calibre2"/>        Properties p = new Properties();<br class="calibre2"/>        p.put("userDb", "new://Resource?type=DataSource");<br class="calibre2"/>        p.put("userDb.JdbcDriver", "org.hsqldb.jdbcDriver");<br class="calibre2"/>        p.put("userDb.JdbcUrl", "jdbc:hsqldb:mem:userdatabase");<br class="calibre2"/><br class="calibre2"/>        ejbContainer = EJBContainer.createEJBContainer(p);<br class="calibre2"/>        ejbContainer.getContext().bind("inject", this);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @After<br class="calibre2"/>    public void tearDown() {<br class="calibre2"/>        ejbContainer.close();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Test<br class="calibre2"/>    public void validTransaction() throws Exception{<br class="calibre2"/>        User user = new User(null, "Elder Moraes", <br class="calibre2"/>                             "elder@eldermoraes.com");<br class="calibre2"/>        <br class="calibre2"/>        userBean.add(user);<br class="calibre2"/>        user.setName("John Doe");<br class="calibre2"/>        userBean.update(user);<br class="calibre2"/>        <br class="calibre2"/>        User userDb = userBean.findById(1L);<br class="calibre2"/>        assertEquals(userDb.getName(), "John Doe");<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The key code line in this recipe for JTA is right here:</p>
<pre class="calibre21">&lt;persistence-unit name="ch02-jta-pu" transaction-type="JTA"&gt;</pre>
<p class="mce-root">When you use <kbd class="calibre16">transaction-type='JTA'</kbd>, you are saying to the server that it should take care of all transactions made under this context. If you use <kbd class="calibre16">RESOURCE-LOCAL</kbd> instead, you are saying that you are taking care of the transactions:</p>
<pre class="calibre21">    @Test<br class="calibre2"/>    public void validTransaction() throws Exception{<br class="calibre2"/>        User user = new User(null, "Elder Moraes", <br class="calibre2"/>        "elder@eldermoraes.com");<br class="calibre2"/>        <br class="calibre2"/>        userBean.add(user);<br class="calibre2"/>        user.setName("John Doe");<br class="calibre2"/>        userBean.update(user);<br class="calibre2"/>        <br class="calibre2"/>        User userDb = userBean.findById(1L);<br class="calibre2"/>        assertEquals(userDb.getName(), "John Doe");<br class="calibre2"/>        <br class="calibre2"/>    }</pre>
<p class="mce-root">Each called method of <kbd class="calibre16">UserBean</kbd> starts a transaction to be completed and would run into a rollback if there's any issue while the transaction is alive would commit to the end of it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Another important piece of code is the following:</p>
<pre class="calibre21">@Stateful<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext(unitName = "ch02-jta-pu", <br class="calibre2"/>                        type = PersistenceContextType.EXTENDED)<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">So, here we are defining our <kbd class="calibre16">PersistenceContext</kbd> as <kbd class="calibre16">EXTENDED</kbd>. It means that this persistence context is bound to the <kbd class="calibre16">@Stateful</kbd> bean until it is removed from the container.</p>
<p class="mce-root">The other option is <kbd class="calibre16">TRANSACTION</kbd>, which means the persistence context would live only by the time of transaction.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using EJB to deal with concurrency</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Concurrency management is one of the biggest advantages supplied by a Java EE server. You can rely on a <span class="calibre8">ready </span>environment to deal with this tricky topic.</p>
<p class="mce-root">This recipe will show you how you can set up your beans to use it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Just add a Java EE dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The recipe will show you three scenarios.</p>
<p class="mce-root">In the first scenario, <kbd class="calibre16">LockType</kbd> is defined at the class level:</p>
<pre class="calibre21">@Singleton<br class="calibre2"/>@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)<br class="calibre2"/>@Lock(LockType.READ)<br class="calibre2"/>@AccessTimeout(value = 10000)<br class="calibre2"/>public class UserClassLevelBean {<br class="calibre2"/><br class="calibre2"/>    private int userCount;<br class="calibre2"/><br class="calibre2"/>    public int getUserCount() {<br class="calibre2"/>        return userCount;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void addUser(){<br class="calibre2"/>        userCount++;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre8">In the second scenario, <kbd class="calibre16">LockType</kbd> is defined at the method level:</span></p>
<pre class="calibre21">@Singleton<br class="calibre2"/>@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)<br class="calibre2"/>@AccessTimeout(value = 10000)<br class="calibre2"/>public class UserMethodLevelBean {<br class="calibre2"/><br class="calibre2"/>    private int userCount;<br class="calibre2"/>    <br class="calibre2"/>    @Lock(LockType.READ)<br class="calibre2"/>    public int getUserCount(){<br class="calibre2"/>        return userCount;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Lock(LockType.WRITE)<br class="calibre2"/>    public void addUser(){<br class="calibre2"/>        userCount++;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre8">The third scenario is a self-managed bean:</span></p>
<pre class="calibre21">@Singleton<br class="calibre2"/>@ConcurrencyManagement(ConcurrencyManagementType.BEAN)<br class="calibre2"/>public class UserSelfManagedBean {<br class="calibre2"/><br class="calibre2"/>    private int userCount;<br class="calibre2"/><br class="calibre2"/>    public int getUserCount() {<br class="calibre2"/>        return userCount;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public synchronized void addUser(){<br class="calibre2"/>        userCount++;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first thing to have a look at the following:</p>
<pre class="calibre21">@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)</pre>
<p class="mce-root">This is completely redundant! Singleton beans are container-managed by default, so you don't need to specify them.</p>
<p class="mce-root">Singletons are designed for concurrent access, so they are the perfect use case for this recipe.</p>
<p class="mce-root">Now let's check the <kbd class="calibre16">LockType</kbd> defined at the class level:</p>
<pre class="calibre21">@Lock(LockType.READ)<br class="calibre2"/>@AccessTimeout(value = 10000)<br class="calibre2"/>public class UserClassLevelBean {<br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">When we use the <kbd class="calibre16">@Lock</kbd> annotation at the class level, the informed <kbd class="calibre16">LockType</kbd> will be used for all class methods.</p>
<p class="mce-root">In this case, <kbd class="calibre16">LockType.READ</kbd> means that many clients can access a resource at the same time. It is usual for reading data.</p>
<p class="mce-root">In case of some kind of locking, <kbd class="calibre16"><span class="calibre5">LockType</span></kbd> will use the <kbd class="calibre16">@AccessTimeout</kbd> annotation time defined to run into a timeout or not.</p>
<p class="mce-root">Now, let's check <kbd class="calibre16">LockType</kbd> defined at the method level:</p>
<pre class="calibre21">    @Lock(LockType.READ)<br class="calibre2"/>    public int getUserCount(){<br class="calibre2"/>        return userCount;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Lock(LockType.WRITE)<br class="calibre2"/>    public void addUser(){<br class="calibre2"/>        userCount++;<br class="calibre2"/>    }</pre>
<p class="mce-root">So, here we are basically saying that <kbd class="calibre16">getUserCount()</kbd> can be accessed by many users at once (<kbd class="calibre16">LockType.READ</kbd>), but <kbd class="calibre16">addUser()</kbd> will be accessed just by one user at a time (<kbd class="calibre16">LockType.WRITE</kbd>).</p>
<p class="mce-root">The last case is the self-managed bean:</p>
<pre class="calibre21">@ConcurrencyManagement(ConcurrencyManagementType.BEAN)<br class="calibre2"/>public class UserSelfManagedBean{<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    public synchronized void addUser(){<br class="calibre2"/>        userCount++;<br class="calibre2"/>    }<br class="calibre2"/> <br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">In this case, you have to manage all the concurrency issues for your bean in your code. We used a synchronized qualifier as an example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Unless you really <em class="calibre17">really</em> need to, don't use self-managed beans. The Java EE container is (well) designed to do it in a very efficient and elegant way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using JPA for smart data persistence</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java Persistence API is a specification that describes an interface for managing relational databases using Java EE. </p>
<p class="mce-root">It eases data manipulation and reduces a lot of the code written for it, especially if you are used to SQL ANSI.</p>
<p class="mce-root">This recipe will show you how to use it to persist your data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add the dependencies needed:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.3.1.Final&lt;/version&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;junit&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.12&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;1.3&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.apache.openejb&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;openejb-core&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;4.7.4&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's begin by creating an entity (you can see it as a table):</li>
</ol>
<pre class="mce-root2">@Entity<br class="calibre2"/>public class User implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @GeneratedValue(strategy = GenerationType.AUTO)<br class="calibre2"/>    private Long id;<br class="calibre2"/>    <br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    protected User() {<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name, String email) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Here we declare our persistence unit (at <kbd class="calibre16">persistence.xml</kbd>):</li>
</ol>
<pre class="calibre21">    &lt;persistence-unit name="ch02-jpa-pu" transaction-type="JTA"&gt;<br class="calibre2"/>        &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;<br class="calibre2"/>        &lt;jta-data-source&gt;userDb&lt;/jta-data-source&gt;<br class="calibre2"/>        <br class="calibre2"/>        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;<br class="calibre2"/><br class="calibre2"/>        &lt;properties&gt;<br class="calibre2"/>            &lt;property name="javax.persistence.schema-<br class="calibre2"/>             generation.database.action" <br class="calibre2"/>             value="create"/&gt;<br class="calibre2"/>        &lt;/properties&gt;<br class="calibre2"/>    &lt;/persistence-unit&gt;</pre>
<ol start="3" class="calibre19">
<li class="chapter">Then we create a session bean to manage our data:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext(unitName = "ch02-jpa-pu", <br class="calibre2"/>    type = PersistenceContextType.TRANSACTION)<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/>    <br class="calibre2"/>    public void add(User user){<br class="calibre2"/>        em.persist(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void update(User user){<br class="calibre2"/>        em.merge(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void remove(User user){<br class="calibre2"/>        em.remove(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User findById(Long id){<br class="calibre2"/>        return em.find(User.class, id);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And here we use a unit test to try it out:</li>
</ol>
<pre class="mce-root2">public class Ch02JpaTest {<br class="calibre2"/>    <br class="calibre2"/>    private EJBContainer ejbContainer;<br class="calibre2"/>    <br class="calibre2"/>    @EJB<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    public Ch02JpaTest() {<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Before<br class="calibre2"/>    public void setUp() throws NamingException {<br class="calibre2"/>        Properties p = new Properties();<br class="calibre2"/>        p.put("userDb", "new://Resource?type=DataSource");<br class="calibre2"/>        p.put("userDb.JdbcDriver", "org.hsqldb.jdbcDriver");<br class="calibre2"/>        p.put("userDb.JdbcUrl", "jdbc:hsqldb:mem:userdatabase");<br class="calibre2"/><br class="calibre2"/>        ejbContainer = EJBContainer.createEJBContainer(p);<br class="calibre2"/>        ejbContainer.getContext().bind("inject", this);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @After<br class="calibre2"/>    public void tearDown() {<br class="calibre2"/>        ejbContainer.close();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Test<br class="calibre2"/>    public void persistData() throws Exception{<br class="calibre2"/>        User user = new User(null, "Elder Moraes", <br class="calibre2"/>        "elder@eldermoraes.com");<br class="calibre2"/>        <br class="calibre2"/>        userBean.add(user);<br class="calibre2"/>        user.setName("John Doe");<br class="calibre2"/>        userBean.update(user);<br class="calibre2"/>        <br class="calibre2"/>        User userDb = userBean.findById(1L);<br class="calibre2"/>        assertEquals(userDb.getName(), "John Doe");<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's break down our <strong class="calibre7">persistence unit</strong> (<strong class="calibre7">pu</strong>).</p>
<p class="mce-root">This line defines the<span class="calibre8"> </span>pu<span class="calibre8"> </span>name and the transaction type used:</p>
<pre class="calibre21">&lt;persistence-unit name="ch02-jpa-pu" transaction-type="JTA"&gt;</pre>
<p class="mce-root"><span class="calibre8">The following line shows the provider the JPA implementation used:</span></p>
<pre class="calibre21">&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;</pre>
<p class="mce-root">It is the<span class="calibre8"> </span>datasource<span class="calibre8"> </span>name that will be accessed through JNDI:</p>
<pre class="calibre21">&lt;jta-data-source&gt;userDb&lt;/jta-data-source&gt;</pre>
<p class="mce-root">This<span class="calibre8"> </span>line<span class="calibre8"> </span>lets all your<span class="calibre8"> </span>entities<span class="calibre8"> </span>be available for this<span class="calibre8"> </span>pu, so you don't need to declare each one:</p>
<pre class="calibre21">&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;</pre>
<p class="mce-root">This block allows the database objects to be created if they don't exist:</p>
<pre class="calibre21">        &lt;properties&gt;<br class="calibre2"/>            &lt;property name="javax.persistence.schema-<br class="calibre2"/>             generation.database.action" <br class="calibre2"/>             value="create"/&gt;<br class="calibre2"/>        &lt;/properties&gt;</pre>
<p class="mce-root"><span class="calibre8">And now let's have a look at</span> <kbd class="calibre16">UserBean</kbd><span class="calibre8">:</span></p>
<pre class="calibre21">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext(unitName = "ch02-jpa-pu", <br class="calibre2"/>                        type = PersistenceContextType.TRANSACTION)<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/><br class="calibre2"/>   ...<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root"><kbd class="calibre16">EntityManager</kbd> is the object responsible for the interface between the bean and the datasource. It's bound to the context by the <kbd class="calibre16">@PersistenceContext</kbd> annotation.</p>
<p class="mce-root">And we check the <kbd class="calibre16">EntityManager</kbd> operations as follows:</p>
<pre class="calibre21">    public void add(User user){<br class="calibre2"/>        em.persist(user);<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">persist()</kbd> method is used to add new data to the datasource. At the end of the execution, the object is attached to the context:</p>
<pre class="calibre21">    public void update(User user){<br class="calibre2"/>        em.merge(user);<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">merge()</kbd> method is used to update existing data on the datasource. The object is first found at the context, then updated at the database and attached to the context with the new state:</p>
<pre class="calibre21">    public void remove(User user){<br class="calibre2"/>        em.remove(user);<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">remove()</kbd> method, guess what is it?</p>
<pre class="calibre21">    public User findById(Long id){<br class="calibre2"/>        return em.find(User.class, id);<br class="calibre2"/>    }</pre>
<p class="mce-root">And finally the <kbd class="calibre16">find()</kbd> method uses the <kbd class="calibre16">id</kbd> parameter to search a database object with the same ID. That's why JPA demands your entities have an ID declared with the <kbd class="calibre16">@Id</kbd> annotation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using EJB and JPA for data caching</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Knowing how to build a simple and local cache for your application is an important skill. It may have a big impact on some data access performance and it is quite easy to do.</p>
<p class="mce-root">This recipe will show you how.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Simply add a Java EE dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's create a <kbd class="calibre16">User</kbd> class to be our cached object:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/>    <br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/>  <br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And then create a singleton to hold our user list cache:</li>
</ol>
<pre class="mce-root2">@Singleton<br class="calibre2"/>@Startup<br class="calibre2"/>public class UserCacheBean {<br class="calibre2"/><br class="calibre2"/>    protected Queue&lt;User&gt; cache = null;<br class="calibre2"/>    <br class="calibre2"/>    @PersistenceContext<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/><br class="calibre2"/>    public UserCacheBean() {<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    protected void loadCache() {<br class="calibre2"/>        List&lt;User&gt; list = em.createQuery("SELECT u FROM USER <br class="calibre2"/>                                         as u").getResultList();<br class="calibre2"/><br class="calibre2"/>        list.forEach((user) -&gt; {<br class="calibre2"/>            cache.add(user);<br class="calibre2"/>        });<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Lock(LockType.READ)<br class="calibre2"/>    public List&lt;User&gt; get() {<br class="calibre2"/>        return cache.stream().collect(Collectors.toList());<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    protected void init() {<br class="calibre2"/>        cache = new ConcurrentLinkedQueue&lt;&gt;();<br class="calibre2"/>        loadCache();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first understand our bean declaration:</p>
<pre class="calibre21">@Singleton<br class="calibre2"/>@Startup<br class="calibre2"/>public class UserCacheBean {<br class="calibre2"/>    <br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    protected void init() {<br class="calibre2"/>        cache = new ConcurrentLinkedQueue&lt;&gt;();<br class="calibre2"/>        loadCache();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">We are using a singleton because it has one and only one instance in the application context. And that's the way we want a data cache because we don't want to allow the possibility of different data being shared.</p>
<p class="mce-root">Also note that we used the <kbd class="calibre16">@Startup</kbd> annotation. It says to the server that this bean should be <em class="calibre17">executed</em> once it is loaded and the method annotated with <kbd class="calibre16">@PostConstruct</kbd> is used for it.</p>
<p class="mce-root">So we take the startup time to load our cache:</p>
<pre class="calibre21">    protected void loadCache() {<br class="calibre2"/>        List&lt;User&gt; list = em.createQuery("SELECT u FROM USER <br class="calibre2"/>                                         as u").getResultList();<br class="calibre2"/><br class="calibre2"/>        list.forEach((user) -&gt; {<br class="calibre2"/>            cache.add(user);<br class="calibre2"/>        });<br class="calibre2"/>    }</pre>
<p class="mce-root">Now let's check the object holding our cache:</p>
<pre class="calibre21">protected Queue&lt;User&gt; cache = null;<br class="calibre2"/><br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>cache = new ConcurrentLinkedQueue&lt;&gt;();</pre>
<p class="mce-root"><kbd class="calibre16">ConcurrentLinkedQueue</kbd> is a list built with one main purpose—being accessed by multiple processes in a thread-safe environment. That's exactly what we need and also it offers great performance on accessing its members.</p>
<p class="mce-root">And finally, let's check the access to our data cache:</p>
<pre class="calibre21">    @Lock(LockType.READ)<br class="calibre2"/>    public List&lt;User&gt; get() {<br class="calibre2"/>        return cache.stream().collect(Collectors.toList());<br class="calibre2"/>    }</pre>
<p class="mce-root">We annotated the <kbd class="calibre16">get()</kbd> method with <kbd class="calibre16">LockType.READ</kbd>, so it says to the concurrency manager that it can be accessed by multiple processes at once in a thread-safe way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you need big and complex caches in your application, you should use some enterprise cache solutions for better results.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using batch processing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Batch processing is the last recipe of this chapter. Running background tasks is a useful and important skill in an enterprise context.</p>
<p class="mce-root">You could use it to process data in bulk or just to separate it from the UI processes. This recipe will show you how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's add our dependencies:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;5.2.10.Final&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;runtime&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;7.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We first define our persistence unit:</li>
</ol>
<pre class="mce-root2">  &lt;persistence-unit name="ch02-batch-pu" &gt;<br class="calibre2"/>    &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;<br class="calibre2"/>    &lt;jta-data-source&gt;java:app/userDb&lt;/jta-data-source&gt;<br class="calibre2"/>    &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;<br class="calibre2"/>    &lt;properties&gt;<br class="calibre2"/>      &lt;property name="javax.persistence.schema- <br class="calibre2"/>       generation.database.action" <br class="calibre2"/>       value="create"/&gt;<br class="calibre2"/>      &lt;property name="hibernate.transaction.jta.platform" <br class="calibre2"/>       value="org.hibernate.service.jta.platform<br class="calibre2"/>       .internal.SunOneJtaPlatform"/&gt;<br class="calibre2"/>    &lt;/properties&gt;<br class="calibre2"/>  &lt;/persistence-unit&gt;</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we declare a <kbd class="calibre16">User</kbd> entity:</li>
</ol>
<pre class="mce-root2">@Entity<br class="calibre2"/>@Table(name = "UserTab")<br class="calibre2"/>public class User implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @NotNull<br class="calibre2"/>    private Integer id;<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    public User() {<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter"><span class="calibre5">Here we create a job reader:</span></li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@Dependent<br class="calibre2"/>public class UserReader extends AbstractItemReader {<br class="calibre2"/><br class="calibre2"/>    private BufferedReader br;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void open(Serializable checkpoint) throws Exception {<br class="calibre2"/>        br = new BufferedReader(<br class="calibre2"/>                new InputStreamReader(<br class="calibre2"/>                        Thread.currentThread()<br class="calibre2"/>                        .getContextClassLoader()<br class="calibre2"/>                        .getResourceAsStream<br class="calibre2"/>                        ("META-INF/user.txt")));<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public String readItem() {<br class="calibre2"/>        String line = null;<br class="calibre2"/><br class="calibre2"/>        try {<br class="calibre2"/>            line = br.readLine();<br class="calibre2"/>        } catch (IOException ex) {<br class="calibre2"/>            System.out.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        return line;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">Then we create a job processor:</li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@Dependent<br class="calibre2"/>public class UserProcessor implements ItemProcessor {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public User processItem(Object line) {<br class="calibre2"/>        User user = new User();<br class="calibre2"/><br class="calibre2"/>        StringTokenizer tokens = new StringTokenizer((String)<br class="calibre2"/>        line, ",");<br class="calibre2"/>        user.setId(Integer.parseInt(tokens.nextToken()));<br class="calibre2"/>        user.setName(tokens.nextToken());<br class="calibre2"/>        user.setEmail(tokens.nextToken());<br class="calibre2"/>        <br class="calibre2"/>        return user;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="5" class="calibre19">
<li class="chapter">And here we create a job writer:</li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@Dependent<br class="calibre2"/>public class UserWriter extends AbstractItemWriter {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext<br class="calibre2"/>    EntityManager entityManager;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    @Transactional<br class="calibre2"/>    public void writeItems(List list) {<br class="calibre2"/>        for (User user : (List&lt;User&gt;) list) {<br class="calibre2"/>            entityManager.persist(user);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre23">The processor, reader, and writer are referenced by the <kbd class="calibre16">acess-user.xml</kbd> file located at <kbd class="calibre16">META-INF.batch-jobs</kbd>:</p>
<pre class="mce-root2">&lt;?xml version="1.0" encoding="windows-1252"?&gt;<br class="calibre2"/>&lt;job id="userAccess" <br class="calibre2"/>      <br class="calibre2"/>     version="1.0"&gt;<br class="calibre2"/>    &lt;step id="loadData"&gt;<br class="calibre2"/>        &lt;chunk item-count="3"&gt;<br class="calibre2"/>            &lt;reader ref="userReader"/&gt;<br class="calibre2"/>            &lt;processor ref="userProcessor"/&gt;<br class="calibre2"/>            &lt;writer ref="userWriter"/&gt;<br class="calibre2"/>        &lt;/chunk&gt;<br class="calibre2"/>    &lt;/step&gt;<br class="calibre2"/>&lt;/job&gt;</pre>
<ol start="6" class="calibre19">
<li class="chapter">And finally, we create a bean to interact with the batch engine:</li>
</ol>
<pre class="mce-root2">@Named<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext<br class="calibre2"/>    EntityManager entityManager;<br class="calibre2"/><br class="calibre2"/>    public void run() {<br class="calibre2"/>        try {<br class="calibre2"/>            JobOperator job = BatchRuntime.getJobOperator();<br class="calibre2"/>            long jobId = job.start("acess-user", new Properties());<br class="calibre2"/>            System.out.println("Job started: " + jobId);<br class="calibre2"/>        } catch (JobStartException ex) {<br class="calibre2"/>            System.out.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public List&lt;User&gt; get() {<br class="calibre2"/>        return entityManager<br class="calibre2"/>                .createQuery("SELECT u FROM User as u", User.class)<br class="calibre2"/>                .getResultList();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">For the purpose of this example, we are going to use a JSF page to run the job and load the data:</p>
<pre class="calibre21">&lt;h:body&gt;<br class="calibre2"/> &lt;h:form&gt;<br class="calibre2"/> &lt;h:outputLabel value="#{userBean.get()}" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> &lt;h:commandButton value="Run" action="index" actionListener="#{userBean.run()}"/&gt;<br class="calibre2"/> &lt;h:commandButton value="Reload" action="index"/&gt;<br class="calibre2"/> &lt;/h:form&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>
<p class="mce-root">Run it on a Java EE server, click on the <span class="calibre8">Run</span> button and then the <span class="calibre8">Reload</span> button.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To understand what is happening:</p>
<ol class="calibre19">
<li class="chapter"><kbd class="calibre16">UserReader</kbd> extends the <kbd class="calibre16">AbstractItemReader</kbd> class that has two key methods: <kbd class="calibre16">open()</kbd> and <kbd class="calibre16">readItem()</kbd>. In our case, the first one opens the <kbd class="calibre16">META-INF/user.txt</kbd> and the second one reads each line of the file.</li>
<li class="chapter">The <kbd class="calibre16">UserProcessor</kbd> class extends the <kbd class="calibre16">ItemProcessor</kbd> class that has a <kbd class="calibre16">processItem()</kbd> method. It gets the item read by <kbd class="calibre16">readItem()</kbd> (from <kbd class="calibre16">UserReader</kbd>) to generate the <kbd class="calibre16">User</kbd> object that we want.</li>
<li class="chapter">Once all items are processed and available in a list (in memory) we use the <kbd class="calibre16">UserWriter</kbd> class; that extends the <kbd class="calibre16">AbstractItemWriter</kbd> class and has the <kbd class="calibre16">writeItems</kbd> method. We use it, in our case, to persist the data read from the <kbd class="calibre16">user.txt</kbd> file.</li>
</ol>
<p class="mce-root">All set so, we just use <kbd class="calibre16">UserBean</kbd> to run the job:</p>
<pre class="calibre21">    public void run() {<br class="calibre2"/>        try {<br class="calibre2"/>            JobOperator job = BatchRuntime.getJobOperator();<br class="calibre2"/>            long jobId = job.start("acess-user", new Properties());<br class="calibre2"/>            System.out.println("Job started: " + jobId);<br class="calibre2"/>        } catch (JobStartException ex) {<br class="calibre2"/>            System.out.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">job.start()</kbd> method is referencing the <kbd class="calibre16">acess-user.xml</kbd> file, enabling our reader, processor, and writer to work together.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch</a></li>
</ul>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </div>



  </body></html>