- en: Extending the Game - Run Parallel, Run Faster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展游戏 - 并行运行，更快运行
- en: In this chapter, we will extend the Mastermind game. As it is now, it can guess
    the secret that was hidden and also hide the pegs. The test code can even do both
    at the same time. It can play against itself leaving us only with the fun of programming.
    What it cannot do is make use of all the processors that we have in today's notebooks
    and servers. The code runs synchronous and utilizes only a single processor core.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展Mastermind游戏。现在，它不仅可以猜测隐藏的秘密，还可以隐藏柱子。测试代码甚至可以同时做这两件事。它可以与自己玩游戏，只留下编程的乐趣。它不能利用我们今天在笔记本电脑和服务器上拥有的所有处理器。代码是同步运行的，并且只利用单个处理器核心。
- en: We will alter the code extending the guessing algorithm to slice up the guessing
    into subtasks and execute the code in parallel. During this, we will get acquainted
    with Java concurrent programming. This will be a huge topic with many subtle corners
    and caveats lurking in the dark. We will get into those details that are the most
    important and will form a firm base for further studies whenever you need concurrent
    programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改代码，扩展猜测算法，将猜测分割成子任务，并并行执行代码。在这个过程中，我们将熟悉Java并发编程。这将是一个巨大的主题，其中隐藏着许多细微的角落和陷阱。我们将深入研究最重要的细节，这将为你需要并发程序时提供一个坚实的基础。
- en: 'As the outcome of the game is the same as it was, only faster, we have to assess
    what faster is. To do that, we will utilize a new feature introduced in Java 9:
    microbenchmarking harness.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏的结果与之前相同，只是更快，我们必须评估“更快”是什么意思。为了做到这一点，我们将利用Java 9中引入的新功能：微基准测试工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The meaning of processes, threads and fibers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程、线程和纤维的含义
- en: Multithreading in Java
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的多线程
- en: Issues with multithread programming and how to avoid them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程编程的问题以及如何避免它们
- en: Locking, synchronization, and blocking queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定、同步和阻塞队列
- en: Microbenchmarking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微基准测试
- en: How to make Mastermind parallel
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使Mastermind并行化
- en: The old algorithm was to go through all the variations and try to find a guess
    that matches the current state of the table. Assuming that the currently examined
    guess is the secret, will we get the same answers for the guesses that are already
    on the table as the answers are actually on the table? If yes, then the current
    guess can be the secret, and it is just as good a guess as any other guesses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 旧算法是遍历所有可能的变体，并尝试找到一个与当前表格状态匹配的猜测。假设当前检查的猜测是秘密，我们是否会得到与表格上实际答案相同的答案？如果是，那么当前的猜测可以是秘密，它和其他任何猜测一样好。
- en: A more complex approach can implement the min-max algorithm ([https://en.wikipedia.org/wiki/Minimax](https://en.wikipedia.org/wiki/Minimax)).
    This algorithm does not simply get the next possible guess but also looks at all
    the possible guesses and selects the one that shortens the outcome of the game
    the most. If there is a guess that can be followed by three more guesses in the
    worst case, and there is another for which this number is only two, then min-max
    will choose the latter. It is a good exercise for the interested readers. In the
    case of the six colors and four columns for the pegs, the min-max algorithm solves
    the game in no more than 5 steps. The simple algorithm we implemented also solves
    the game in 5 steps. However, we do not go in that direction.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更复杂的方法可以实现最小-最大算法（[https://en.wikipedia.org/wiki/Minimax](https://en.wikipedia.org/wiki/Minimax)）。这个算法不仅得到下一个可能的猜测，还考虑了所有可能的猜测，并选择那个最能缩短游戏结果的猜测。如果一个猜测在最坏情况下可以跟随三个更多的猜测，而另一个只有两个，那么最小-最大算法将选择后者。这对感兴趣的读者来说是一个很好的练习。在六种颜色和四个柱子的游戏中，最小-最大算法最多在5步内解决游戏。我们实现的那种简单算法也在5步内解决游戏。然而，我们不走那条路。
- en: Instead, we want to have a version of the game that utilizes more than one processor.
    How can you transform the algorithm into a parallel one? There is no simple answer
    to this. When you have an algorithm, you can analyze the calculations and parts
    of the algorithm, and you can try to find dependencies. If there is some calculation
    *B* that needs the data, which is the result of another calculation *A*, then
    it is obvious that *A* can only be performed when *B* is ready. If there are parts
    of the algorithm that do not depend on the outcome of the others, then they can
    be executed in parallel.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的不是只用一个处理器的游戏版本。你该如何将算法转换成并行算法呢？这个问题没有简单的答案。当你有一个算法时，你可以分析算法的计算部分，并尝试找出依赖关系。如果有一些计算
    *B* 需要另一计算 *A* 的数据，而 *A* 是 *B* 的结果，那么很明显，*A* 只能在 *B* 准备好的时候执行。如果算法中有不依赖于其他部分结果的计算部分，那么它们可以并行执行。
- en: 'For example, the quick-sort has two major tasks: partitioning and then sorting
    of the two parts. It is fairly obvious that the partitioning has to finish before
    we start sorting the two partitioned parts. However, the sorting tasks of the
    two parts do not depend on each other, they can be done independently. You can
    give them to two different processors. One will be happy sorting the part containing
    the smaller elements; the other one will carry the heavier, larger ones.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，快速排序有两个主要任务：分区和排序两个部分。很明显，分区必须在开始排序两个已分区的部分之前完成。然而，两个部分的排序任务并不相互依赖，它们可以独立完成。你可以将它们分配给两个不同的处理器。一个会高兴地排序包含较小元素的分区；另一个则会处理较重、较大的元素。
- en: If you turn the pages back to [Chapter 3](part0076.html), *Optimizing the Sort
    - Making Code Professional* where we implemented quick-sort in a non-recursive
    way, you can see that we scheduled sorting tasks into a stack and then performed
    the sorting by fetching the elements from the stack in a `while` loop. Instead
    of executing the sort right there in the core of the loop, we could pass the task
    to an asynchronous thread to perform it and go back for the next waiting task.
    We just do not know how. Yet. That is why we are here in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你翻到[第3章](part0076.html)，*优化排序 - 使代码专业化*，我们在这里以非递归的方式实现了快速排序，你可以看到我们将排序任务安排到栈中，然后通过在
    `while` 循环中从栈中获取元素来执行排序。我们本可以在循环的核心处直接执行排序，但我们可以将任务传递给异步线程来执行，然后返回去处理下一个等待的任务。我们只是不知道如何做。目前还不知道。这就是我们为什么在这里的原因。
- en: Processors, threads, and processes are complex and abstract things and they
    are hard to imagine. Different programmers have different techniques to imagine
    parallel processing and algorithms. I can tell you how I do it but it is not a
    guarantee that this will work for you. Others may have different techniques in
    their mind. As a matter of fact, I just realized that as I write this, I have
    actually never told this to anyone before. It may seem childish, but anyway, here
    it goes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器、线程和进程是复杂且抽象的概念，它们很难想象。不同的程序员有不同的技巧来想象并行处理和算法。我可以告诉你我是如何做的，但这并不能保证这对你也有效。其他人可能在心中有不同的技巧。实际上，当我写这段话的时候，我实际上从未告诉过任何人。这听起来可能有些幼稚，但无论如何，就这样吧。
- en: When I imagine algorithms, I imagine people. One processor is one person. This
    helps me overcome the freaking fact that a processor can make billions of calculations
    in a second. I actually imagine a bureaucrat wearing a brown suit and doing the
    calculations. When I create a code for a parallel algorithm, I imagine many of
    them working behind their desks. They work alone and they do not talk. It is important
    that they do not talk to each other. They are very formal. When there is a need
    for information exchange, they stand up with a piece of paper they have written
    something on, and they bring it to each other. Sometimes, they need a piece of
    paper for their work. Then they stand up, go to the place where the paper is,
    take it, bring it back to their desk, and go on working. When they are ready,
    they go back and bring the paper back. If the paper is not there when they need
    it, they queue up and wait until someone who has the paper brings it there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想象算法时，我会想象人。一个处理器就是一个人。这有助于我克服这样一个事实：处理器可以在一秒钟内进行数十亿次的计算。我实际上想象一个穿着棕色西装的官僚在进行计算。当我为并行算法编写代码时，我会想象他们中的许多人在他们的办公桌后面工作。他们独自工作，不交谈。重要的是他们不互相交谈。他们非常正式。当需要信息交流时，他们会站起来，拿着写有内容的纸，把它带给对方。有时，他们需要纸来完成工作。然后他们会站起来，走到纸所在的地方，取回纸，回到他们的办公桌继续工作。当他们准备好时，他们会回去取回纸。如果他们需要纸时纸不在那里，他们会排队等待，直到有纸的人把纸带来。
- en: How does it help with Mastermind?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何帮助理解“大师心智”游戏？
- en: I imagine a boss who is responsible for the guesses. There is a table on the
    wall in the office with the previous guesses and the results for each row. The
    boss is too lazy to come up with new guesses so he gives this task to subordinates.
    When a subordinate comes up with a guess, the boss checks whether the guess is
    valid or not. He does not trust the subordinates, and if the guess is good, he
    makes it as an official guess, putting it on the table along with the result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我想象一个负责猜测的老板。办公室墙上有一张表格，上面记录了之前的猜测和每行的结果。老板太懒了，不想想新的猜测，所以他把这个任务交给下级。当一个下级提出一个猜测时，老板会检查这个猜测是否有效。他不信任下级，如果猜测好，他会将其作为官方猜测，放在表格上，并附上结果。
- en: The subordinates deliver the guesses written on small post-it notes, and they
    put them in a box on the table of the boss. The boss looks at the box from time
    to time, and if there is a note, the boss takes it. If the box is full and a subordinate
    wants to put a paper there, the subordinate stops and waits until the boss takes
    at least one note so that there is some room in the box for a new note. If the
    subordinates queue up to deposit guesses in the box, they all wait for their time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下级将写在小便签上的猜测交给老板，并将它们放在老板桌子上的一个盒子里。老板时不时地看看盒子，如果有便签，他会拿走。如果盒子满了，一个下级想要放一张纸进去，他会停下来等待，直到老板至少拿走一张便签，这样盒子里就有空间放新的便签。如果下级排队将猜测放入盒子，他们都会等待他们的时间。
- en: The subordinates should be coordinated; otherwise, they will just come up with
    the same guesses. Each of them should have an interval of guesses. For example,
    the first one should check the guesses from 1234 up until 2134, the second should
    check from 2134 up until 3124, and so on, if we denote the colors with numbers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下级应该协调一致；否则，他们只会提出相同的猜测。每个下级都应该有一个猜测的间隔。例如，第一个应该检查从1234到2134的猜测，第二个应该检查从2134到3124，以此类推，如果我们用数字表示颜色的话。
- en: Will this structure work? Common sense says that it will. However, bureaucrats,
    in this case, are metaphors and metaphors are not exact. Bureaucrats are human,
    even when they do not seem like it much more than threads or processors. They
    sometimes behave extremely strangely, doing things that normal humans don't really
    do often. However, we can still use this metaphor if it helps us imagine how parallel
    algorithms work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构能行得通吗？常识告诉我们它应该可以。然而，在这个例子中，官僚主义者是隐喻，而隐喻并不精确。官僚主义者是人，即使他们看起来不像，也比线程或处理器多得多。他们有时会表现得极其奇怪，做一些正常人类不太经常做的事情。然而，如果这个隐喻能帮助我们想象并行算法是如何工作的，我们仍然可以使用它。
- en: We can imagine that the boss goes on holiday and does not touch the heap of
    paper piling up on the table. We can imagine that some of the workers are producing
    results much faster than the others. As this is only imagination, the speedup
    can be 1000 times (think of a time-lapse video). Imagining these situations may
    help us discover special behavior that rarely happens, but may cause problems.
    As the threads work in parallel, many times subtle differences may influence the
    general behavior greatly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象老板去度假了，他没有触摸桌子上堆积如山的纸张。我们可以想象一些工人比其他人生产结果要快得多。由于这只是想象，加速可以高达1000倍（想想时间流逝的视频）。想象这些情况可能有助于我们发现很少发生但可能引起问题的特殊行为。由于线程并行工作，许多时候微小的差异可能会极大地影响整体行为。
- en: In some early version, as I coded the parallel Mastermind algorithm, the bureaucrats
    started working and filled the box of the boss with guesses before the boss could
    put any of them on the table. As there were no guesses on the table, the bureaucrats
    simply found all possible variations in their interval being a possibly good guess.
    The boss gained nothing by the help of the parallel helpers; they had to select
    the correct ones from all possible guesses, while the guessers were just idle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些早期版本中，当我编写并行Mastermind算法时，官僚们开始工作，在老板能够将任何猜测放在桌子上之前，他们已经填满了老板的盒子。由于桌子上没有猜测，官僚们只是简单地在他们间隔中找到所有可能的变化，这可能是一个好的猜测。老板通过并行助手的帮助一无所获；他们必须从所有可能的猜测中选择正确的，而猜测者只是闲置。
- en: Another time, the bureaucrats were checking guesses against the table while
    the boss was putting a guess on one of them created beforehand. And some of the
    bureaucrats freaked out saying that it is not possible to check a guess against
    a table if someone is changing it. More precisely, the code executing in one thread,
    threw `ConcurrentModificationException` when the `List` of the table was modified.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一次，当老板正在将一个事先创建的猜测放在桌子上时，官僚们正在检查猜测与表格的一致性。有些官僚惊慌失措地说，如果有人在更改它，就不可能检查一个猜测与表格的一致性。更确切地说，在一个线程中执行的代码，当表格的`List`被修改时，抛出了`ConcurrentModificationException`。
- en: 'Another time, I tried to avoid the too fast work of bureaucrats, and I limited
    the size of the box where they could put their papers containing the guesses.
    When the boss finally found the secret, and the game finished, the boss told the
    bureaucrats that they could go home. The boss did that by creating a small paper
    with the instruction: you can go home, and put it on the tables of the bureaucrats.
    What did the bureaucrats do? Kept waiting for the box to have space for the paper!
    (Until the process was killed. This is kind of equivalent on Mac OS and on Linux
    as ending the process from the task manager on Windows.)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一次，我试图避免官僚们过于快速的工作，我限制了他们可以放置包含猜测的纸张的盒子的大小。当老板最终找到秘密，游戏结束时，老板告诉官僚们他们可以回家了。老板通过创建一张小纸条这样做：你可以回家了，把它放在官僚们的桌子上。官僚们做了什么？他们继续等待盒子有空间放纸条！（直到进程被终止。这在Mac
    OS和Linux上与在Windows的任务管理器中结束进程相当。）
- en: Such coding errors happen and, to avoid as many as possible, we have to do at
    least two things. Firstly, we have to understand how Java multithreading works
    and secondly, have a code as clean as possible. For the second, we will clean
    up the code even more and then we will look at how the parallel algorithm described
    earlier can be implemented in Java, running on the JVM instead of utilizing bureaucrats.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的编码错误会发生，为了尽可能避免，我们必须至少做两件事。首先，我们必须理解Java多线程是如何工作的；其次，编写尽可能干净的代码。对于第二点，我们将进一步清理代码，然后我们将看看如何将之前描述的并行算法在Java中实现，在JVM上运行而不是利用官僚们。
- en: Refactoring
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: When we finished the previous chapter, we had the classes of the Mastermind
    game designed and coded in a nice and perfectly object oriented way that did not
    break any of the *OO* principles. Did we? Absurd. There is no code, except some
    trivial examples, that cannot be made to look nicer or better. Usually, when we
    develop code and finish the coding, it looks great. It works, the tests all run,
    and documentation is ready. From the professional point of view, it really is
    perfect. Well, it is good enough. The big question that we have not tested yet
    is maintainability. What is the cost to alter the code?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成上一章时，我们已经以优雅且完全面向对象的方式设计了Mastermind游戏的类，并且没有违反任何*OO*原则。是这样吗？荒谬。除了某些琐碎的例子外，没有代码不能变得更好看或更优秀。通常，当我们开发代码并完成编码时，它看起来很棒。它运行正常，所有测试都通过了，文档也准备好了。从专业角度来看，这真的很完美。嗯，已经足够好了。我们还没有测试的大问题是可维护性。改变代码的成本是多少？
- en: That is not an easy question, especially because it is not a definite one. Alter
    to what? What is the modification that is to be made to the code? We do not know
    that when we create the code in the first place. If the modification is to fix
    a bug, then it is obvious that we did not know that beforehand. If we knew, we
    would not have introduced the bug in the first place. If this is a new feature,
    then there is a possibility that the function was foreseen. However, usually it
    is not the case. When a developer tries to predict the future, and what features
    the program will need in the future, they usually fail. It is the task of the
    customer to know the business. Features needed are driven by the business in case
    of professional software development. After all, that is what it means to be professional.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个容易的问题，尤其是因为它不是确定的。改变到什么程度？要对代码进行什么样的修改？当我们最初创建代码时，我们并不知道这一点。如果修改是为了修复一个错误，那么很明显，我们事先并不知道。如果我们知道，我们最初就不会引入这个错误。如果是新功能，那么有可能这个功能是事先预见的。然而，通常情况下并非如此。当开发者试图预测未来，以及程序将需要的未来功能时，他们通常都会失败。了解业务是客户的责任。在专业软件开发中，所需的功能是由业务驱动的。毕竟，这就是专业意味着什么。
- en: 'Even though we do not exactly know what needs to be altered later in the code,
    there are certain things that may give hints to experienced software developers.
    Usually, the OO code is easier to maintain than the ad-hoc code, and there are
    code smells that one can spot. For example, take a look at the following code
    lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们并不确切知道代码的哪个部分需要稍后进行修改，但有些事情可能会给经验丰富的软件开发者提供线索。通常，面向对象的代码比临时编写的代码更容易维护，并且可以识别出代码的某些“异味”。例如，看看下面的代码行：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We may sense the odor of something strange. (Each of these lines is in the code
    of the application as we finished it in [Chapter 4](part0111.html), *Mastermind
    - Creating a Game*.) The return value of the `guess` method is compared to `Row.none`,
    which is a `Row`. Then, we compare the return value of `nextGuess` to `Guesser.none`,
    which should be a `Guesser`. When we add a new guess to something, we actually
    add a `Row`. Finally, we can realize that `nextGuess` returns a guess that is
    not an object with its own declared class. A `guess` is just an array of colors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能察觉到某种奇怪气味的存在。（每一行都包含在我们在[第4章](part0111.html)，“思维大师 - 创建游戏”中完成的应用代码中。）`guess`方法的返回值与`Row.none`进行比较，`Row.none`是一个`Row`。然后，我们将`nextGuess`的返回值与`Guesser.none`进行比较，`Guesser.none`应该是一个`Guesser`。当我们向某个东西添加一个新的猜测时，我们实际上是在添加一个`Row`。最后，我们可以意识到`nextGuess`返回的猜测不是一个具有自己声明类的对象。一个`guess`只是一个颜色数组。
- en: Should we introduce another layer of abstraction creating a `Guess` class? Will
    it make the code more maintainable? Or will it only make the code more complex?
    It is usually true that the less code lines we have, the less possibility we have
    for bugs. However, sometimes, the lack of abstraction will make the code complex
    and tangled. What is the case in this situation? How can we decide that generally?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该引入另一层抽象，创建一个`Guess`类？这将使代码更易于维护吗？还是只会使代码更复杂？通常情况下，代码行数越少，出现错误的可能性就越小。然而，有时缺乏抽象会使代码变得复杂和混乱。在这种情况下是什么情况？我们如何一般性地决定？
- en: The more experience you have, the easier you will tell by looking at the code
    and acutely knowing what modifications you want to make. Many times, you will
    not bother making the code more abstract, and many other times, you will create
    new classes without hesitation. When in doubt, do create the new classes and see
    what comes out. The important thing is not to ruin the already existing functionality.
    You can do that only if you have sufficient unit tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经验越多，你通过查看代码和敏锐地知道你想要进行的修改就越容易。很多时候，你不会费心使代码更加抽象，而在许多其他时候，你会毫不犹豫地创建新的类。当有疑问时，创建新的类并看看结果。重要的是不要破坏已经存在的功能。你只能在你有足够的单元测试的情况下做到这一点。
- en: When you want to introduce some new functionality or fix a bug, but the code
    is not appropriate, you will have to modify it first. When you modify the code
    so that the functionality does not change, the process is named **refactoring**.
    You change a small part of the code in a limited time, and then you build it.
    If it compiles and all unit tests run, then you can go on. The hint is to run
    the build frequently. It is like building a new road near an existing one. Once
    in every few miles, you should meet the old line. Failing to do so, you will end
    up somewhere in the middle of the desert in a totally wrong direction, and all
    you can do is return to the starting point—your old to-be-refactored code. Effort
    wasted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想引入一些新的功能或修复一个错误，但代码不合适时，你将不得不先修改它。当你修改代码而不改变功能的过程时，这个过程被称为**重构**。你在一个有限的时间内修改代码的一小部分，然后构建它。如果它能编译并且所有单元测试都运行，那么你可以继续。提示是经常运行构建。这就像在现有道路附近修建一条新道路。每隔几英里，你应该遇到旧线路。如果没有这样做，你最终会在沙漠的中间某个地方，完全错误的方向，而你唯一能做的就是回到起点——你旧的重构代码。这是徒劳的。
- en: It is not only the safety that advises us to run the build frequently, it is
    also time limitation. Refactoring does not directly deliver revenue. The functionality
    of the program is tied directly to income. Nobody will pay us for infinite refactoring
    work. Refactoring has to stop some time and it is usually not the time when there
    is nothing to be refactored any more. The code will never be perfect, but you
    may stop when it is good enough. And, many times, programmers are never satisfied
    with the quality of the code, and when they are stopped by some external factor
    (usually called project manager), the code should compile and tests should run
    so that the new feature and bug fixing can be performed on the actual code base.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅安全性建议我们经常运行构建，还有时间限制。重构不会直接带来收入。程序的功能直接与收入挂钩。没有人会为我们无限期的重构工作付费。重构必须在某时停止，这通常不是没有更多重构要做的时候。代码永远不会完美，但你可以在它足够好的时候停止。而且，很多时候，程序员永远不会对代码的质量感到满意，当被某些外部因素（通常称为项目经理）阻止时，代码应该能编译，测试应该能运行，以便在实际代码库上执行新功能和错误修复。
- en: Refactoring is a huge topic and there are many techniques that can be followed
    during such an activity. It is so complex that there is a whole book about it
    by Martin Fowler ([http://martinfowler.com/books/refactoring.html](http://martinfowler.com/books/refactoring.html)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是一个非常大的主题，在进行这样的活动时可以遵循许多技术。它如此复杂，以至于有一整本书是关于它的，由马丁·福勒所著([http://martinfowler.com/books/refactoring.html](http://martinfowler.com/books/refactoring.html))。
- en: 'In our case, the modification we want to apply to our code is to implement
    a parallel algorithm. The first thing we will modify is the `ColorManager`. When
    we wanted to print guesses and rows on the terminal, we had to implement some
    bad tricks. Why not have color implementations that can be printed? We can have
    a class that extends the original `Color` class and has a method that returns
    something that represents that color. Do you have any candidate name for that
    method? It is the `toString` method. It is implemented in the `Object` class and
    any class can freely override it. When you concatenate an object to a string,
    automatic type conversion will call this method to convert the object to `String`.
    By the way, it is an old trick to use `""+object` instead of `object.toString()`
    to avoid `null` pointer exception. Needless to say, we do not use tricks. The
    `toString` method is also invoked by the IDEs when the debugger wants to display
    the value of some object, so it is generally recommended to implement `toString`
    if for nothing else, then to ease development. If we have a `Color` class that
    implements `toString`, then the `PrettyPrintRow` class becomes fairly straightforward
    and tricks less:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们想要应用到我们的代码中的修改是实现一个并行算法。我们首先将修改的是`ColorManager`。当我们想在终端上打印猜测和行时，我们必须实现一些糟糕的技巧。为什么不有可以打印的颜色实现呢？我们可以有一个扩展原始`Color`类并具有返回表示该颜色的方法的类。你有没有为这个方法想出一个候选名称？它是`toString`方法。它在`Object`类中实现，并且任何类都可以自由地覆盖它。当你将一个对象连接到一个字符串时，自动类型转换将调用此方法将对象转换为`String`。顺便说一句，使用`""+object`而不是`object.toString()`来避免`null`指针异常是一个老技巧。不言而喻，我们不使用技巧。`toString`方法也会在IDEs调用调试器显示某些对象的值时被调用，因此通常建议实现`toString`，即使不是为了别的，也是为了简化开发。如果我们有一个实现了`toString`的`Color`类，那么`PrettyPrintRow`类就变得相当直接，技巧也更少：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We removed the problem from the printing class, but you may argue that the issue
    is still there, and you are right. Many times, when there is a problem in a class
    design, the way to the solution to move the problem from the class to another.
    If it is still a problem there, then you may split the design more and more and,
    at the last stage, you will realize that what you have is an issue and not a problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从打印类中移除了问题，但你可能会争辩说问题仍然存在，你是对的。很多时候，当类设计有问题时，解决问题的方法是将问题从类移动到另一个类。如果问题仍然存在，那么你可能需要将设计分割得越来越细，到最后阶段，你将意识到你遇到的是一个问题而不是一个难题。
- en: 'To implement a `LetteredColor` class is also straightforward:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`LetteredColor`类也很直接：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, the problem was pushed forward. But, in reality, this is not a problem.
    It is an OO design. Printing is not responsible for assigning `String` to colors
    for their representation. And the color implementation itself is also not responsible
    for that. The assignment has to be performed where the color is made, and then
    the `String` has to be passed to the constructor of the `LetteredColor` class.
    The `color` instances are created in `ColorManager` so we have to implement this
    in the `ColorManager` class. Or not? What does `ColorManager` do? It creates the
    colors and...
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，问题被推向前。但在现实中，这并不是一个问题。这是一个面向对象的设计。打印不负责为颜色的表示分配`String`。颜色实现本身也不负责这一点。分配必须在颜色创建的地方进行，然后`String`必须传递给`LetteredColor`类的构造函数。`color`实例在`ColorManager`中创建，所以我们必须在`ColorManager`类中实现这一点。或者不是吗？`ColorManager`做什么？它创建颜色，...
- en: When you come to an explanation or description of a class that lists the functionalities,
    you may immediately see that the **single responsibility principle** was ignored.
    `ColorManager` should manage the colors. Managing is providing a way to get the
    colors in a definite order and getting the first and the next when we know one
    color. We should implement the other responsibility—the creation of a color in
    a separate class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你来到一个列出功能的类的解释或描述时，你可能立即会看到**单一职责原则**被忽略了。"ColorManager"应该管理颜色。管理意味着提供一种方式以确定顺序获取颜色，并在已知一个颜色时获取下一个颜色。我们应该实现另一个职责——在单独的类中创建颜色。
- en: 'A class that has the sole functionality to create an instance of another class
    is called factory. That is almost the same as using the `new` operator but unlike
    `new`, the factories can be used more flexibly. We will see that immediately.
    The `ColorFactory` interface contains a single method, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个功能来创建另一个类实例的类被称为工厂。这几乎和使用`new`操作符一样，但与`new`不同，工厂可以更加灵活地使用。我们马上就会看到。`ColorFactory`接口包含一个方法，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Interfaces that define only one method are named functional interfaces because
    their implementation can be provided as a lambda expression at the place where
    you would use an object that is an instance of a class which implements the functional
    interface. The `SimpleColorFactory` implementation creates the following `Color`
    objects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 只定义了一个方法的接口被称为函数式接口，因为它们的实现可以作为lambda表达式在需要使用实现函数式接口的类的实例的对象的地方提供。`SimpleColorFactory`实现创建了以下`Color`对象：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is very much like how we create an interface, and then an implementation,
    instead of just writing `new Color()` in the code in `ColorManager`. `LetteredColorFactory`
    is a bit more interesting:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常类似于我们创建一个接口，然后创建一个实现，而不是在`ColorManager`的代码中直接写`new Color()`。`LetteredColorFactory`有点更有趣：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, here we have the functionality that assigns `String`s to the `Color` objects
    when they are created. It is very important that the `counter` variable that keeps
    track of the already created colors is not `static`. The similar variable in the
    previous chapter was `static` and it meant that it could run out of characters
    as ever-newer `ColorManager`s created too many colors. It actually did happen
    to me during the unit test execution when the tests each created `ColorManager`s
    and new `Color` instances, and the printing code tried to assign new letters to
    the new colors. The tests were running in the same JVM under the same classloader
    and the unfortunate `static` variable had no clue when it could just start counting
    from zero for the new tests. The drawback is that somebody, somewhere, has to
    instantiate the factory and it is not the `ColorManager`. `ColorManager` already
    has a responsibility and it is not to create a color factory. The `ColorManager`
    has to get the `ColorFactory` in its constructor:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里我们有在创建`Color`对象时分配`String`的功能。非常重要的一点是，跟踪已创建颜色的`counter`变量不是`static`的。前一章中类似的变量是`static`的，这意味着它可能会因为新的`ColorManager`创建了太多的颜色而耗尽字符。实际上，在我执行单元测试时发生了这种情况，每个测试都创建了`ColorManager`和新的`Color`实例，而打印代码试图为新颜色分配新的字母。测试是在同一个JVM和同一个类加载器下运行的，不幸的`static`变量根本不知道它可以从零开始为新测试计数。缺点是，某处某人有责任实例化工厂，而这个责任不是`ColorManager`的。`ColorManager`已经有了责任，那就是不是创建颜色工厂。`ColorManager`必须在构造函数中获取`ColorFactory`：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may also notice that I could not resist refactoring the `createColors` method
    into two methods to follow the single responsibility principle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，我无法抗拒将`createColors`方法重构为两个方法，以遵循单一责任原则。
- en: 'Now, the code that creates `ColorManager` has to create a factory and pass
    it to the constructor. For example, the unit test''s `ColorManagerTest` class
    will contain the following method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`ColorManager`的代码必须创建一个工厂并将其传递给构造函数。例如，单元测试的`ColorManagerTest`类将包含以下方法：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the simplest way ever to implement a factory defined by a functional
    interface. Just name the class and reference the `new` operator like it was a
    method by creating a method reference.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有史以来实现由函数式接口定义的工厂的最简单方式。只需命名类并创建一个方法引用，就像使用`new`操作符一样引用它。
- en: The next thing we will refactor is the `Guess` class, which, actually, we did
    not have so far. A `Guess` class contains the pegs of the guess and can calculate
    the number of full (color as well as position) and partial (color present but
    in wrong position) matches, and can also calculate the next `Guess` that comes
    after this guess. This functionality was implemented in the `Guesser` class so
    far, but this is not really the functionality for how we select the guesses when
    checking the already made guesses on the table. If we follow the pattern we set
    up for the colors, we may implement this functionality in a separate class named
    `GuessManager`, but as for now, it is not needed. Again, this is not black and
    white.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构`Guess`类，实际上，我们之前还没有这个类。`Guess`类包含猜测的针，可以计算完全匹配（颜色和位置）和部分匹配（颜色存在但位置错误）的数量，还可以计算在此猜测之后的下一个`Guess`。到目前为止，这个功能是在`Guesser`类中实现的，但这并不是我们在检查表格上已经做出的猜测时选择猜测的方式的功能。如果我们遵循为颜色设定的模式，我们可以在一个名为`GuessManager`的单独类中实现这个功能，但到目前为止，它不是必需的。再次强调，这不是非黑即白。
- en: 'It is important to note that a `Guess` object can only be made at once. If
    it is on the table, the player is not allowed to change it. If we have a `Guess`
    that is not yet on the table, it is still just a `Guess` identified by the colors
    and orders of the pegs. A `Guess` object never changes after it was created. Such
    objects are easy to use in multithread programs and are called immutable objects:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Guess`对象只能创建一次。如果它在桌子上，玩家不允许更改它。如果我们有一个尚未放在桌子上的`Guess`，它仍然只是一个由珠子的颜色和顺序标识的`Guess`。`Guess`对象在创建后永远不会改变。这样的对象在多线程程序中很容易使用，被称为不可变对象：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constructor is creating a copy of the array of colors that were passed.
    As a `Guess` is immutable, this is extremely important. If we just keep the original
    array, any code outside of the `Guess` class could alter the elements of the array,
    essentially changing the content of `Guess` that is not supposed to be changing:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数正在创建传递的颜色数组的副本。由于`Guess`是不可变的，这非常重要。如果我们只是保留原始数组，任何在`Guess`类之外的代码都可以改变数组的元素，本质上改变了不应该改变的内容：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this method, we start to calculate the next `Guess` starting with the color
    array that is contained in the actual object. We need a work array that is modified,
    so we will copy the original. The final new object can, this time, use the array
    we use during the calculation, so that will need a separate constructor that does
    not create a copy. It is possible extra code, but we should consider making that
    only if we see that that is the bottleneck in the code and we are not satisfied
    with the actual performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们从实际对象中包含的颜色数组开始计算下一个`Guess`。我们需要一个可修改的工作数组，所以我们将复制原始数组。这次，新的最终对象可以使用我们在计算期间使用的数组，因此需要一个不创建副本的单独构造函数。这可能需要额外的代码，但我们应该考虑只在看到这是代码瓶颈且我们对实际性能不满意时才这么做。
- en: 'The next method just checks if the passed `Guess` has the same number of colors
    as the actual one. This is just a safety check used by the next two methods that
    calculate the matches:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法只是检查传递的`Guess`是否有与实际相同的颜色数量。这只是下一个两个计算匹配的方法使用的一个安全检查：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `isUnique` method checks if there is any color more than once in the `Guess`.
    As the `Guess` is immutable, it may not happen that a `Guess` is unique one time
    and not unique at another time. This method should return the same result whenever
    it is called on a specific object. Because of that, it is possible to cache the
    result. This method does this, saving the return value to an instance variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`isUnique`方法检查`Guess`中是否有任何颜色出现超过一次。由于`Guess`是不可变的，所以`Guess`可能在某个时间点是唯一的，而在另一个时间点不是唯一的。这个方法应该在每次被特定对象调用时都返回相同的结果。正因为如此，才有可能缓存结果。这个方法就是这样做的，将返回值保存到一个实例变量中。'
- en: 'You may say that this is premature optimization. Yes, it is. I decided to do
    it for one reason. It is demonstration, and based on that, you can try to modify
    the `nextGuess` method to do the same:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说这是过早优化。是的，确实是。我决定这么做的一个原因是示范，基于这个，你可以尝试修改`nextGuess`方法来做到同样的事情：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Methods that return the same result for the same arguments are called idempotent.
    Caching the return value for such a method can be very important if the method
    is called many times and the calculation is using a lot of resources. When the
    method has arguments, the result caching is not simple. The object method has
    to remember the result for all arguments that were already calculated, and this
    storage has to be effective. If it takes more resources to find the stored result
    than the calculation of it, then the use of cache not only uses more memory but
    also slows down the program. If the method is called for several arguments during
    the lifetime of the object, then the storage memory may just grow too large. Some
    of the elements have to be purged—those that will not be needed anymore in the
    future. However, we cannot know which elements of the cache are not needed, so
    we will have to guess.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回相同结果的方法，我们称之为幂等。如果该方法被多次调用且计算使用了大量资源，缓存返回值可能非常重要。当方法有参数时，结果缓存并不简单。对象方法必须记住所有已计算过的参数的结果，并且这种存储必须有效。如果查找存储结果所需的资源比计算它所需的资源还多，那么使用缓存不仅会使用更多内存，还会减慢程序的速度。如果在对象的整个生命周期中调用该方法多次，那么存储内存可能会变得过大。一些元素必须被清除——那些未来不再需要的元素。然而，我们无法知道缓存中哪些元素是不需要的，所以我们将不得不猜测。
- en: As you can see, caching can get complex very fast and, to do that professionally,
    it is almost always better to use some readily available cache implementation.
    The caching we use here is only the tip of the iceberg. Or, it is even only the
    sunshine glimpsing on it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，缓存可以迅速变得复杂，为了专业地完成这项工作，几乎总是更好的使用一些现成的缓存实现。我们这里使用的缓存只是冰山一角。或者，甚至可以说只是阳光一瞥。
- en: 'The rest of the class is fairly standard and something we have talked about
    in detail—a good check of your knowledge is to understand how the `equals`, `hashCode`,
    and `toString` methods are implemented this way. I implemented the `toString`
    method to help me during debugging, but it is also used in the following example
    output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分相当标准，这是我们之前详细讨论过的——一个很好的知识检查是理解`equals`、`hashCode`和`toString`方法是如何这样实现的。我实现了`toString`方法来帮助我在调试期间，但它也被用于以下示例输出中：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is mainly the modification that I needed while I developed the parallel
    algorithm. Now, the code is fairly up-to-date and described to focus on the main
    topic of this chapter: how to execute code in Java in parallel.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是我开发并行算法时需要的修改。现在，代码相当更新，描述的重点是本章的主要主题：如何在Java中并行执行代码。
- en: The parallel execution of the code in Java is done in threads. You may know
    that there is a `Thread` object in Java runtime, but without understanding what
    a thread in the computer is, it makes no sense. In the following subsections,
    we will learn what these threads are, how to start a new thread, how to synchronize
    data exchange between threads, and finally put all this together and implement
    the Mastermind parallel guessing algorithm.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的代码并行执行是通过线程来完成的。你可能知道Java运行时中有一个`Thread`对象，但如果不理解计算机中的线程是什么，那么这毫无意义。在接下来的小节中，我们将学习这些线程是什么，如何启动一个新的线程，如何同步线程间的数据交换，最后将所有这些整合起来并实现Mastermind并行猜测算法。
- en: Processes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: When you start your computer, the program that starts is the **operating system**
    (**OS**). The OS controls the machine hardware and the programs that you can run
    on the machine. When you start a program, the OS creates a new process. It means
    that the OS allocates a new entry in a table (array) where it administers the
    processes and fills in the parameters that it knows, and needs to know, about
    the process. For example, it registers what memory segment the process is allowed
    to use, what the ID of the process is, and which user started from which other
    process. You cannot start a process just out of thin air. When you double-click
    on an EXE file, you actually tell the file explorer, which is a program running
    as a process, to start the EXE file as a separate process. The explorer calls
    the system via some API and kindly asks the OS to do that. The OS will register
    the explorer process as the parent of the new process. The OS does not actually
    start the process, but creates all the data that it needs to start it and, when
    there is some free CPU resource, then the process gets started, and then it gets
    paused very soon. You will not notice it because the OS will start it again and
    again and is always pausing the process repeatedly. It needs to do it to provide
    run possibilities to all processes. That way, we experience all processes running
    at the same time. In reality, processes do not run at the same time on a single
    processor, but they get time slots to run often.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的计算机时，启动的程序是**操作系统**（**OS**）。操作系统控制机器硬件以及你可以在机器上运行的程序。当你启动一个程序时，操作系统会创建一个新的进程。这意味着操作系统在它管理进程的表中（数组）分配一个新的条目，并填写它所知道以及需要知道的关于进程的参数。例如，它会注册进程允许使用的内存段，进程的ID，以及哪个用户从哪个其他进程启动。你不能凭空启动一个进程。当你双击一个EXE文件时，你实际上是在告诉文件浏览器，这是一个作为进程运行的程序，让它作为一个单独的进程启动EXE文件。浏览器通过某些API调用系统，并友好地请求操作系统这样做。操作系统会将浏览器进程注册为新进程的父进程。操作系统实际上并没有启动进程，而是创建了启动进程所需的所有数据，当有可用的CPU资源时，进程就会被启动，然后很快就会暂停。你不会注意到这一点，因为操作系统会不断地重新启动它，并反复暂停进程。它需要这样做，以便为所有进程提供运行的可能性。这样，我们体验到的所有进程都是同时运行的。实际上，在单个处理器上，进程并不是同时运行的，但它们会得到运行的时间槽。
- en: If you have more than one CPU in the machine, then processes can actually run
    at the same time, as many CPUs as there are. As the integration gets more advanced
    today, desktop computers have CPUs that contain multiple cores that function almost
    like separate CPUs. On my machine, I have four cores, each capable of executing
    two threads simultaneously; so, my Mac is almost like an 8 CPU machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器中有多于一个CPU，那么进程可以真正地同时运行，CPU的数量有多少，进程就可以同时运行多少。随着技术的不断进步，现在的台式电脑中包含的CPU拥有多个核心，这些核心几乎可以像独立的CPU一样工作。在我的机器上，我有四个核心，每个核心可以同时执行两个线程；因此，我的Mac几乎就像一个8CPU的机器。
- en: Processes have separate memories. They are allowed to use one part of the memory
    and if a process tries to use another part that does not belong to it, the processor
    will stop doing so. The OS will kill the process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有各自的内存。它们被允许使用内存的一部分，如果一个进程试图使用不属于它的另一部分内存，处理器将停止这样做。操作系统将杀死该进程。
- en: Just imagine how frustrated the developers of the original UNIX could have been
    that they named the program to stop a process to kill, and stopping a process
    is called killing it. It is like medieval ages when they cut off the hand of a
    felon. You touch the wrong part of the memory and get killed. I would not like
    to be a process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，原始UNIX的开发者给停止进程的程序命名为“kill”，停止进程被称为“杀死”，这就像中世纪时代他们砍掉罪犯的手一样。你触摸了内存的错误部分，就会被“杀死”。我不想成为一个进程。
- en: The memory handling by the operating system is very complex in addition to separating
    the processes from each other. When there is not enough memory, the OS writes
    part of the memory to disk freeing up the memory and reloading that part when
    it is needed again. This is a very complex, low-level implemented and highly optimized
    algorithm that is the responsibility of the OS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统对内存的处理非常复杂，除了将进程彼此分离之外。当内存不足时，操作系统会将部分内存写入磁盘，从而释放内存，并在需要时再次加载这部分内存。这是一个非常复杂、低级实现且高度优化的算法，这是操作系统的责任。
- en: Threads
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: When I said that the OS executes the processes in time slots, I was not absolutely
    precise. Every process has one or more threads, and threads are executed. A thread
    is the smallest execution managed by an external scheduler. Older operating systems
    did not have the notion of a thread and were executing processes. As a matter
    of fact, the first thread implementations were simply duplications of processes
    that were sharing the memory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说操作系统在时间槽中执行进程时，我并不是完全精确的。每个进程都有一个或多个线程，线程被执行。线程是外部调度器管理的最小执行单元。较老的操作系统没有线程的概念，它们只执行进程。实际上，最早的线程实现只是共享内存的进程的复制。
- en: You may hear the terminology, lightweight process—it means a thread.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到术语“轻量级进程”——这意味着线程。
- en: The important thing is that the threads do not have their own memory. They use
    the memory of the process. In other words, the threads that run in the same process
    have undistinguished access to the same memory segment. It is an extremely powerful
    possibility to implement parallel algorithms that make use of the multiple cores
    in the machine, but at the same time, it may lead to bugs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，线程没有自己的内存。它们使用进程的内存。换句话说，在同一个进程中运行的线程对相同的内存段有未区分的访问权限。这是实现利用机器中多个核心的并行算法的极其强大的可能性，但同时也可能导致错误。
- en: '![](img/00044.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: Imagine that two threads increment the same long variable. The increment first
    calculates the incremented value of the lower 32 bits and then the upper, if there
    were any overflow bits. These are two or more steps that may be interrupted by
    the OS. It may happen that one thread increments the lower 32 bits, remembers
    that there is something to do to the upper 32 bits, starts the calculation, but
    has no time to store the result before it gets interrupted. Then, another thread
    increments the lower 32 bits, the upper 32 bits, and then the first thread just
    saves the upper 32 bits that it calculated. The result gets garbled. On an older
    32-bit Java implementation, it was extremely easy to demonstrate this effect.
    On a 64-bit Java implementation, all the 64 bits are loaded into registers and
    saved back to the memory in one step so it is not that easy to demonstrate multithread
    issues, but it does not mean that there are none.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个线程增加同一个长整型变量。增加操作首先计算低 32 位的增加值，然后是高 32 位（如果有溢出位）。这些是可能被操作系统中断的两个或多个步骤。可能发生的情况是，一个线程增加了低
    32 位，记得需要对高 32 位进行一些操作，开始计算，但在它被中断之前没有时间存储结果。然后，另一个线程增加了低 32 位，高 32 位，而第一个线程只是保存了它计算出的高
    32 位。结果变得混乱。在旧的 32 位 Java 实现中，演示这种效果非常容易。在 64 位 Java 实现中，所有 64 位都一次性加载到寄存器中，并一次性保存回内存，因此演示多线程问题并不那么容易，但这并不意味着没有。
- en: When a thread is paused and another thread is started, the operating system
    has to perform a context switch. It means that, among other things, the CPU registers
    have to be saved and then set to the value that they should have for the other
    thread. A context switch is always saving the state of the thread and loading
    the previously saved state of the thread to be started. This is on a CPU register
    level. This context switch is time consuming; therefore, the more context switches
    that are done, the more CPU resource is used for the thread administration instead
    of letting them run. On the other hand, if there are not enough switches, some
    threads may not get enough time slots to execute, and the program hangs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程被暂停而另一个线程被启动时，操作系统必须执行上下文切换。这意味着，在其他事情中，CPU 寄存器必须被保存，然后设置为其他线程应有的值。上下文切换始终保存线程的状态，并将之前保存的线程状态加载到要启动的线程中。这是在
    CPU 寄存器级别上。这种上下文切换是耗时的；因此，执行的上下文切换越多，用于线程管理的 CPU 资源就越多，而不是让它们运行。另一方面，如果切换不够，一些线程可能得不到足够的时间片来执行，程序可能会挂起。
- en: Fibers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纤程
- en: Java does not have fibers, but as there are some libraries that support fiber
    handlings, it is worth mentioning. A fiber is a finer unit than a thread. A program
    code executing in a thread may decide to give up the execution and tell the fiber
    manager to just execute some other fiber. What is the point and why is it better
    than using another thread? The reason is that this way, fibers can avoid part
    of the context switch.  A context switch cannot be avoided totally because a different
    part of the code that starts to execute it may use the CPU registers in a totally
    different way. As it is the same thread, the context switching is not the task
    of the OS, but the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Java 没有纤程，但既然有一些库支持纤程处理，那么提一下也是有价值的。纤程是一个比线程更细小的单位。在一个线程中执行的程序代码可以决定放弃执行并告诉纤程管理器去执行其他纤程。这有什么意义，为什么它比使用另一个线程更好呢？原因在于这种方式，纤程可以避免部分上下文切换。上下文切换无法完全避免，因为开始执行它的不同部分的代码可能会以完全不同的方式使用
    CPU 寄存器。由于它们是同一个线程，上下文切换不是操作系统的任务，而是应用程序的任务。
- en: The OS does not know if the value of a register is used or not. There are bits
    in the registers, and no one can tell seeing only the processor state whether
    those bits are relevant for the current code execution or just happen to be there
    in that way. The program generated by a compiler does know which registers are
    important and which are those that can just be ignored. This information changes
    from place to place in the code, but when there is a need for a switch, the fiber
    passes the information of what is needed to be switched at that point to the code
    that does the switching.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统不知道寄存器的值是否被使用。寄存器中有位，仅通过查看处理器状态，没有人能说出这些位是否与当前代码执行相关，或者只是偶然以这种方式存在。编译器生成的程序知道哪些寄存器是重要的，哪些可以忽略。这些信息在代码的不同位置会变化，但当需要切换时，纤程会将需要在该点切换的信息传递给执行切换的代码。
- en: The compiler calculates this information, but Java does not support fibers in
    the current version. The tools that implement fibers in Java analyze and modify
    the byte code of the classes to do this after the compilation phase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器计算这些信息，但Java当前版本不支持纤程。在编译阶段之后，实现纤程的工具会分析和修改类的字节码来完成这项工作。
- en: Golang's goroutines are fibers and that is why you can easily start many thousand
    goroutines in Go, but you better limit the number of threads in Java to a lower
    number. They are not the same things.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的goroutines是纤程，这就是为什么在Go中可以轻松启动成千上万的goroutines，但最好将Java中的线程数量限制在一个较低的数字。它们不是同一件事。
- en: As the terminology lightweight process is fading out and used by less and less
    fibers, many times are referred to as lightweight threads.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于轻量级进程这个术语正在逐渐消失，并且越来越少地用于纤程，因此很多时候被称为轻量级线程。
- en: java.lang.Thread
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`java.lang.Thread`'
- en: 'As everything in Java (well, almost) is object, if we want to start a new thread,
    we will need a class that represents the thread. This class is `java.lang.Thread`
    built into the JDK. When you start a Java code, the JVM automatically creates
    a few `Thread` objects and uses them to run different tasks that are needed by
    it. If you start up **VisualVM**, you can select the Threads tab of any JVM process
    and see the actual threads that are in the JVM. For example, the VisualVM as I
    started it has 29 live threads. One of them is the thread named `main`. This is
    the one that starts to execute the `main` method (surprise!). The `main` thread
    started most of the other threads. When we want to write a multithread application,
    we will have to create new `Thread` objects and start them. The simplest way to
    do that is `new Thread()`, and then calling the `start` method on the thread.
    It will start a new Thread that will just finish immediately as we did not give
    it anything to do. The `Thread` class, as it is in the JDK, does not do our business
    logic. The following are the two ways to specify the business logic:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java（几乎）中的所有东西都是对象，如果我们想启动一个新的线程，我们需要一个表示线程的类。这个类是内置在JDK中的`java.lang.Thread`。当你启动Java代码时，JVM会自动创建几个`Thread`对象，并使用它们来运行它需要的不同任务。如果你启动**VisualVM**，你可以选择任何JVM进程的“线程”标签，并查看JVM中实际存在的线程。例如，我启动的VisualVM有29个活跃的线程。其中一个是名为`main`的线程。这就是开始执行`main`方法的线程（惊喜！）。`main`线程启动了大多数其他线程。当我们想要编写一个多线程应用程序时，我们必须创建新的`Thread`对象并启动它们。最简单的方法是`new
    Thread()`，然后在线程上调用`start`方法。它将启动一个新的线程，但由于我们没有给它分配任何任务，所以这个线程将立即结束。`Thread`类，正如它在JDK中一样，并不执行我们的业务逻辑。以下有两种指定业务逻辑的方法：
- en: Creating a class that implements the `Runnable` interface
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现`Runnable`接口的类
- en: Creating a class that extends the `Thread` class and overrides the `run` method
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个扩展`Thread`类并重写`run`方法的类
- en: 'The following block of code is a very simple demonstration program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是一个非常简单的演示程序：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code creates two threads and starts them one after the other.
    When the start method is called, it schedules the thread object to be executed
    and then returns. As a result, the new thread will soon start executing asynchronously
    while the calling thread continues its execution. The two threads, and the `main`
    thread, run parallel in the following example and create an output that looks
    something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了两个线程并依次启动它们。当调用`start`方法时，它将线程对象调度为执行，然后返回。因此，新线程将很快异步开始执行，而调用线程继续执行。在以下示例中，这两个线程以及`main`线程是并行运行的，并创建了一个类似以下输出的结果：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The actual output changes from run to run. There is no definite order of the
    execution or how the threads get access to the single screen output. There is
    not even guarantee that in each and every execution, the message `started` is
    printed before any of the thread messages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际输出每次运行都会变化。没有执行顺序或线程如何访问单个屏幕输出的确定顺序。甚至不能保证在每次执行中，`started`消息都会在任何一个线程消息之前打印出来。
- en: 'To get a better understanding of this, we will have to look at the state diagram
    of threads. A Java Thread can be in one of the following states:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们需要查看线程的状态图。Java线程可以处于以下状态之一：
- en: '`NEW`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`'
- en: '`RUNNABLE`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`'
- en: '`BLOCKED`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`'
- en: '`WAITING`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`'
- en: '`TIMED_WAITING`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`'
- en: '`TERMINATED`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`'
- en: These states are defined in the `enumThread.State`. When you create a new thread
    object, it is in the `NEW` state. At this moment, the thread is nothing special,
    it is just an object but the operating system execution-scheduling does not know
    about it. In some sense, it is only a piece of memory allocated by the JVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态在`enumThread.State`中定义。当你创建一个新的线程对象时，它处于`NEW`状态。在这个时候，线程并没有什么特别之处，它仅仅是一个对象，但操作系统的执行调度并不知道它。从某种意义上说，它只是JVM分配的一块内存。
- en: When the start method is invoked, the information about the thread is passed
    to the operating system and the OS schedules the thread so it can be executed
    by it when there is an appropriate time slot. Doing this is a resourceful action
    and that is the reason why we do not create and, especially, do not start new
    Thread objects only when it is needed. Instead of creating new Threads, we will
    keep the existing threads for a while, even if they are not needed at the moment,
    and reuse an existing one if there is one suitable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用start方法时，线程的信息被传递给操作系统，操作系统调度线程，以便在适当的时间槽中由它执行。这样做是一种资源丰富的行为，这也是为什么我们不会仅在需要时创建和，尤其是启动新的Thread对象。相反，我们将保留现有的线程一段时间，即使它们目前不需要，如果有一个合适的线程，我们将重用现有的一个。
- en: 'A thread in the OS can also be in a running state as well as runnable when
    the OS schedules and executes it at the moment. Java JDK API does not distinguish
    between the two for good reason. It would be useless. When a thread is in the
    `RUNNABLE` state asking if it is actually running from the thread itself, it will
    result in an obvious answer: if the code just returned from the `getState` method
    implemented in the `Thread` class, then it runs. If it were not running, it would
    not have returned from the call in the first place. If the `getState` method was
    called from another thread, then the result about the other thread by the time
    the method returns would be meaningless. The OS may have stopped, or started,
    the queried thread several times until then.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统调度并执行线程时，线程在OS中也可以处于运行状态以及可运行状态。Java JDK API没有在这两者之间进行区分，这是有充分理由的。这样做是没有用的。当线程处于`RUNNABLE`状态并询问它是否实际上正在运行时，它将得到一个明显的答案：如果代码刚刚从`Thread`类中实现的`getState`方法返回，那么它正在运行。如果没有运行，它最初就不会从调用中返回。如果`getState`方法是从另一个线程调用的，那么在方法返回时关于其他线程的结果将是没有意义的。操作系统可能在此之前已经停止或启动了查询的线程几次。
- en: A thread is in a `BLOCKED` state when the code executing in the thread tries
    to access some resource that is not currently available. To avoid constant polling
    of resources, the operating system provides effective notification mechanism so
    the threads get back to the `RUNNABLE` state when the resource they need becomes
    available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程中正在执行的代码试图访问当前不可用的资源时，线程处于`BLOCKED`状态。为了避免对资源的持续轮询，操作系统提供了一个有效的通知机制，以便当线程需要的资源变得可用时，线程能够回到`RUNNABLE`状态。
- en: A thread is in the `WAIT` or `TIMED_WAITING` state when it waits for some other
    thread or lock. `TIMED_WAITING` is the state when the waiting started calling
    a version of a method that has timeout.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程等待其他线程或锁时，它处于`WAIT`或`TIMED_WAITING`状态。`TIMED_WAITING`是等待开始调用具有超时版本的方法的状态。
- en: 'Finally, the `TERMINATED` state is reached when the thread finishes its execution.
    If you append the following lines to the end of our previous example, then you
    will get a `TERMINATED` printout and also an exception thrown up to the screen
    complaining about illegal thread state, which is because you cannot start an already
    terminated thread:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当线程完成其执行时，会达到`TERMINATED`状态。如果你将以下几行代码添加到我们之前的示例末尾，那么你会得到一个`TERMINATED`的输出，并且屏幕上还会抛出一个异常，抱怨非法的线程状态，这是因为你不能启动一个已经终止的线程：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of extending the `Thread` class to define what to execute asynchronously,
    we can create a class that implements `Runnable`. Doing that is more in line with
    the OO programming approach. The something that we implement in the class is not
    a functionality of a thread. It is more of a something that can be executed. It
    is something that can just run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过扩展`Thread`类来定义异步执行的内容，而是可以创建一个实现`Runnable`接口的类。这样做更符合面向对象编程的方法。我们在类中实现的东西不是线程的功能。它更像是可以执行的东西。它是一种可以简单运行的东西。
- en: If this execution is asynchronous in a different thread, or it is executed in
    the same thread that was calling the run method, is a different concern that has
    to be separated. If we do it that way, we can pass the class to a `Thread` object
    as a constructor argument. Calling `start` on the `Thread` object will start the
    run method of the object we passed. This is not the gain. The gain is that we
    can also pass the `Runnable` object to an `Executor` (dreadful name, huhh!). `Executor`
    is an interface, and implementations execute `Runnable` (and also `Callable`,
    see later) objects in `Thread`s in an efficient way. Executors usually have a
    pool of `Thread` objects that are prepared, and in the `BLOCKED` state. When the
    `Executor` has a new task to execute, it gives it to one of the `Thread` objects
    and releases the lock that is blocking the thread. The `Thread` gets into the
    `RUNNABLE` state, executes the `Runnable`, and gets blocked again. It does not
    terminate and thus can be reused to execute another `Runnable` later. That way,
    `Executor`s avoid the resource consuming process of thread registration into the
    operating system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个执行是在不同的线程中异步进行的，或者它是在调用run方法的同一个线程中执行的，这是一个需要单独考虑的不同问题。如果我们那样做，我们可以将类作为构造函数参数传递给`Thread`对象。在`Thread`对象上调用`start`将启动我们传递的对象的run方法。这不是我们的收获。收获在于我们还可以将`Runnable`对象传递给一个`Executor`（名字听起来很糟糕，嗯！）。`Executor`是一个接口，它以高效的方式在`Thread`s中执行`Runnable`（以及稍后将要提到的`Callable`）对象。`Executors`通常有一个准备好的`Thread`对象池，它们处于`BLOCKED`状态。当`Executor`有一个新的任务要执行时，它会将其分配给一个`Thread`对象，并释放阻塞线程的锁。`Thread`进入`RUNNABLE`状态，执行`Runnable`，然后再次被阻塞。它不会终止，因此可以稍后重新用于执行另一个`Runnable`。这样，`Executor`s避免了将线程注册到操作系统的资源消耗过程。
- en: Professional application code never creates a new `Thread`. Application code
    uses some framework to handle the parallel execution of the code or uses `Executor`s
    provided by some `ExecutorService` to start `Runnable` or `Callable` objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 专业应用程序代码永远不会创建一个新的`Thread`。应用程序代码使用某些框架来处理代码的并行执行，或者使用由某些`ExecutorService`提供的`Executor`s来启动`Runnable`或`Callable`对象。
- en: Pitfalls
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陷阱
- en: We have already discussed many of the problems that we may face when developing
    parallel program. In this section, we will summarize them with the usual terminology
    used for the problems. Terminology is not only interesting, but it is also important
    when you talk with colleagues to easily understand each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多在开发并行程序时可能遇到的问题。在本节中，我们将使用通常用于描述这些问题的术语来总结它们。术语不仅有趣，而且在与同事交谈时，为了轻松理解彼此，它也很重要。
- en: Deadlocks
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁
- en: Deadlock is the most infamous parallel programming pitfall, and for this reason,
    we will start with this one. To describe the situation, we will follow the metaphor
    of bureaucrats.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是并行编程中最臭名昭著的陷阱，因此，我们将从这里开始。为了描述这种情况，我们将遵循官僚主义的隐喻。
- en: The bureaucrat has to stamp a paper he has in his hand. To do that, he needs
    the stamp, and he also needs the inkpad. First, he goes to the drawer where the
    stamp is and takes it. Then, he walks to the drawer where the inkpad is and takes
    the inkpad. He inks the stamp, pushes on the paper. Then, he puts the stamp back
    to its place and then the inkpad back in its place. Everything is nice, we are
    on cloud 9.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 官僚必须在他手中的文件上盖章。为了做到这一点，他需要印章，也需要墨盒。首先，他走到放印章的抽屉那里，把它拿走。然后，他走到放墨盒的抽屉那里，拿走墨盒。他给印章上墨，按在纸上。然后，他把印章放回原位，然后把墨盒放回原位。一切都很完美，我们正处在天堂里。
- en: What happens if another bureaucrat takes the inkpad first and then the stamp
    second? They may soon end up as one bureaucrat with the stamp in hand waiting
    for the inkpad and another one with the inkpad in hand waiting for the stamps.
    And, they may just stay there, frozen forever, and then more and more start to
    wait for these locks, the papers never get stamped, and the whole system sinks
    into anarchy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个官僚先拿墨盒，然后拿印章，会发生什么？他们可能很快就会变成一个拿着印章等待墨盒的官僚，另一个拿着墨盒等待印章的官僚。而且，他们可能就这样僵在那里，永远冻结，然后越来越多的人开始等待这些锁，文件永远不会被盖章，整个系统陷入无政府状态。
- en: To avoid such situations, the locks have to be ordered and the locks should
    always be acquired in the order. In the preceding example, the simple agreement
    that the inkpad is acquired first and the stamp second solves the problem. Whoever
    acquired the stamp can be sure that the inkpad is free or will soon be free.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，锁必须按顺序排列，并且应该始终按顺序获取锁。在先前的例子中，简单的协议是首先获取墨垫，然后是邮票，这解决了问题。任何获取邮票的线程都可以确信墨垫是空闲的或很快就会空闲。
- en: Race conditions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞态条件
- en: 'We talk about race conditions when the result of a calculation may be different
    based on the speed and CPU access of the different parallel running threads. Let''s
    take a look at the following two code lines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算的结果可能基于不同并行运行的线程的速度和CPU访问时，我们谈论竞态条件。让我们看看以下两行代码：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the value of `b` at the start of the execution is 0, and two different threads
    execute the two methods, then the order of the lines can be 1234, 1324, 1342,
    3412, 3142, or 3142\. Any execution order of the four lines may happen which assures
    that 1 runs before 2 and 3 runs before 4, but no other restrictions. The outcome,
    the value of `b`, is either 1 or 2 at the end of the execution of the segments,
    which may not be good and what we wanted when coding.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行开始时`b`的值为0，并且两个不同的线程执行这两个方法，那么行的顺序可以是1234、1324、1342、3412、3142或3142。四个行的任何执行顺序都可能发生，这保证了1在2之前运行，3在4之前运行，但没有其他限制。结果，`b`的值在段执行结束时为1或2，这可能不是我们在编码时想要的，也不太好。
- en: Note that the implementation of the parallel Mastermind game also has something
    like this. The actual guesses very much depend on the speed of the different threads,
    but this is irrelevant from the final result point of view. We may have different
    guesses in different runs and that way the algorithm is not deterministic, but
    we are guaranteed to find the final solution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并行Mastermind游戏的实现也有类似的情况。实际的猜测很大程度上取决于不同线程的速度，但从最终结果的角度来看，这是无关紧要的。我们可能在不同的运行中有不同的猜测，这样算法就不是确定性的，但我们保证能找到最终解决方案。
- en: Overused locks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度使用的锁
- en: In many situations, it may happen that the threads are waiting on a lock, which
    protects a resource from concurrent access. If the resource cannot be used by
    multiple threads simultaneously, and there are more threads than can be served,
    then the threads are starving. However, in many cases, the resource can be organized
    in a way so that the threads can get access to some of the services that the resource
    provides, and the locking structure can be less restrictive. In that case, the
    lock is overused and the situation can be mended without allocating more resource
    for the threads. It may be possible to use several locks that control the access
    to the different functionality of the resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可能会发生线程正在等待一个锁，该锁保护资源免受并发访问。如果资源不能被多个线程同时使用，并且有比可以服务的线程更多的线程，那么这些线程就会处于饥饿状态。然而，在许多情况下，资源可以被组织成一种方式，使得线程可以访问资源提供的一些服务，并且锁定结构可以不那么限制性。在这种情况下，锁被过度使用，并且可以通过为线程分配更多资源来修复这种情况。可能可以使用多个锁来控制对资源不同功能的访问。
- en: Starving
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿
- en: Starving is the situation when several threads are waiting for a resource trying
    to acquire a lock and some threads get access to the lock only after extremely
    long time or never. When the lock is released and there are threads waiting for
    it, then one of the threads can get the lock. There is usually no guarantee that
    a thread gets the lock if it waits long enough. Such a mechanism would require
    intensive administration of the threads, sorting them in the waiting queue. As
    locking should be a low latency and high performance action, even a few CPU clock
    cycles are significant; therefore, the locks do not provide this type of fair
    access by default. Not wasting time with fairness in thread scheduling is a good
    approach, in case the locks have one thread waiting. The main goal of locks is
    not scheduling the waiting threads, but rather preventing parallel access to resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 饥饿是当多个线程等待一个资源，试图获取一个锁，而一些线程只有在经过极长时间或永远之后才能获取到锁的情况。当锁被释放并且有线程等待它时，其中一个线程可以获取到锁。通常没有保证如果线程等待足够长的时间，它就能获取到锁。这种机制需要大量管理线程，对等待队列中的线程进行排序。由于锁定应该是低延迟和高性能的操作，即使是几个CPU时钟周期也是重要的；因此，锁默认不提供这种公平访问。如果锁只有一个线程等待，不浪费时间在线程调度中的公平性是一个好方法。锁的主要目标不是调度等待的线程，而是防止对资源的并行访问。
- en: It is like in a shop. If there is somebody at the cashier, you wait. It is a
    lock built in implicitly. It is not a problem if people do not queue up for the
    cashier, so long as long there is almost always one free. However, when there
    are several queues built up in front of the cashiers, then having no queue and
    waiting order will certainly lead to some very long waiting order for someone
    who is slow to get access to the cashier. Generally, the solution of fairness
    and creating queue of waiting threads (customers) is not a good solution. The
    good solution is to eliminate the situation that leads to waiting queues. You
    can employ more cashiers, or you can do something totally different that makes
    the peak load smaller. In a shop, you can give discount to drive customers who
    come in at off-peak hours. In programming, several techniques can be applied,
    usually, depending on the actual business we code and fair scheduling of locks
    is usually a workaround.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在商店里。如果有人在收银台，你就得等。这是一个隐含的锁。如果人们不排队等待收银，只要几乎总是有一个空闲的收银台，那就没问题。然而，当收银台前有多个队伍时，如果没有排队和等待的顺序，肯定会给那些慢吞吞地到达收银台的人带来非常长的等待时间。通常，公平性和创建等待线程（顾客）的队列的解决方案并不是一个好的解决方案。好的解决方案是消除导致等待队列的情况。你可以增加收银员，或者你可以做一些完全不同的事情，以减少高峰负载。在商店里，你可以给在非高峰时段来店的顾客打折。在编程中，可以应用几种技术，通常，这取决于我们实际编写的业务代码和锁的公平调度，通常是一个解决方案。
- en: ExecutorService
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExecutorService
- en: '`ExecutorService` is an interface in the JDK. An implementation of the interface
    can execute a `Runnable` or `Callable` class in an asynchronous way. The interface
    only defines the API for the implementation and does not require that the invocation
    is asynchronous but, in reality, that is the main point implementing such a service.
    Invoking the `run` method of a `Runnable` interface in a synchronous way is simply
    calling a method. We do not need a special class for that.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService` 是 JDK 中的一个接口。该接口的实现可以以异步方式执行 `Runnable` 或 `Callable` 类。该接口仅定义了实现该接口的
    API，并不要求调用必须是异步的，但实际上，这是实现此类服务的主要点。以同步方式调用 `Runnable` 接口的 `run` 方法仅仅是调用一个方法。我们不需要为这个目的创建一个特殊的类。'
- en: The `Runnable` interface defines one `run` method. It has no arguments returns
    no value and does not throw any exception. The `Callable` interface is parameterized
    and the only method it defines, `call`, has no argument but returns a generic
    value and may also throw `Exception`. In our code, we will implement `Runnable`
    if we just want to run something, and `Callable` when we want to return something.
    Both of these interfaces are functional interfaces, therefore, they are good candidates
    to be implemented using lambda.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable` 接口定义了一个 `run` 方法。它没有参数，不返回任何值，也不抛出任何异常。`Callable` 接口是参数化的，它定义的唯一方法
    `call` 没有参数，但返回一个泛型值，并且可能抛出 `Exception`。在我们的代码中，如果我们只想运行某些东西，我们将实现 `Runnable`，如果我们想返回某些东西，我们将实现
    `Callable`。这两个接口都是函数式接口，因此，它们是使用 lambda 实现的好候选。'
- en: 'To have an instance of an implementation of an `ExecutorService`, we can use
    the utility class `Executors`. Many times when there is an `XYZ` interface in
    the JDK, there can be an `XYZs` (plural) utility class that provides factory for
    the implementations of the interface. If we want to start the `t1` task many times,
    we can do so without creating a new `Thread`. We should use the following executor
    service:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个 `ExecutorService` 实现的实例，我们可以使用实用工具类 `Executors`。很多时候，当 JDK 中有一个 `XYZ` 接口时，可能有一个
    `XYZs`（复数）实用工具类，它为该接口的实现提供工厂。如果我们想多次启动 `t1` 任务，我们可以这样做，而不需要创建一个新的 `Thread`。我们应该使用以下执行服务：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, we do not get any exception. Instead, the `t1` task runs second time.
    In this example, we are using a fixed size thread pool that has two `Thread`s.
    As we want to start only two threads simultaneously, it is enough. There are implementations
    that grow and shrink the size of the pool dynamically. Fixed size pool should
    be used when we want to limit the number of the threads or we know from some other
    information source the number of the a-priory threads. In this case, it is a good
    experiment to change the size of the pool to one and see that the second task
    will not start in this case until the first one finishes. The service will not
    have another thread for `t2` and will have to wait until the one and only `Thread`
    in the pool is freed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有遇到任何异常。相反，`t1`任务运行了第二次。在这个例子中，我们使用了一个固定大小的线程池，它包含两个`Thread`。由于我们只想同时启动两个线程，所以这已经足够了。有一些实现会动态地增加和减少池的大小。当我们想要限制线程的数量或者从其他信息源得知预先线程的数量时，应该使用固定大小的池。在这种情况下，将池的大小改为一个，并观察在这种情况下第二个任务不会启动，直到第一个任务完成，这是一个很好的实验。服务将不会有另一个线程用于`t2`，它必须等待池中唯一的`Thread`被释放。
- en: When we submit the task to the service, it returns even if the task cannot currently
    be executed. The tasks are put in a queue and will start execution as soon as
    there is enough resource to start them. The submit method returns a `Future` object,
    as we can see in the preceding sample.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将任务提交给服务时，即使任务当前无法执行，它也会返回。任务被放入队列中，一旦有足够的资源启动它们，就会开始执行。`submit`方法返回一个`Future`对象，正如我们在前面的示例中所看到的。
- en: It is like a service ticket. You bring your car to the repair mechanic, and
    you get a ticket. You are not required to stay there until the car is fixed, but
    at any time, you can ask if the car is ready. All you need is the ticket. You
    can also decide to wait until the car is ready. A `Future` object is also something
    like that. You do not get the value that you need. It will be calculated asynchronously.
    However, there is a `Future` promise that it will be there and your ticket to
    access the object you need is the `Future` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一张服务票。你把你的车带到维修技师那里，你得到一张票。你不需要在那里一直等到车修好，但任何时候你都可以询问车是否准备好了。你所需要的只是这张票。你也可以决定等到车修好。一个`Future`对象也是这样。你不会得到你需要的值。它将异步计算。然而，有一个`Future`承诺它将会在那里，你需要访问所需对象的票就是`Future`对象。
- en: When you have a `Future` object, you can call the `isDone` method to see if
    it is ready. You can start waiting for it to call `get` with, or without, some
    timeout. You can also cancel the task executing it, but in that case, the outcome
    may be questionable. Just like, in case of your car, if you decide to cancel the
    task, you may get back your car with the motor disassembled. Similarly, cancelling
    a task that is not prepared for it may lead to resource loss, opened and inaccessible
    database connection (this is a painful memory for me, even after 10 years), or
    just a garbled unusable object. Prepare your tasks to be cancelled or do not cancel
    them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个`Future`对象时，你可以调用`isDone`方法来查看它是否已经准备好。你可以开始等待它，用或不用超时调用`get`，你也可以取消正在执行的任务，但在这种情况下，结果可能是可疑的。就像，在你的车的情况下，如果你决定取消任务，你可能会得到一辆发动机被拆解的车。同样，取消一个没有为此准备的任务可能会导致资源损失，打开且无法访问的数据库连接（这是我的一个痛苦记忆，即使是在10年后），或者只是一个混乱的无法使用的对象。为取消任务做好准备，或者不要取消它们。
- en: In the preceding example, there is no return value for `Future` because we submitted
    a `Runnable` object and not a `Callable` one. In that case the value passed to
    the `Future` is not to be used. It is usually `null`, but that is nothing to lean
    on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Future`没有返回值，因为我们提交了一个`Runnable`对象而不是`Callable`对象。在这种情况下，传递给`Future`的值不应该被使用。它通常是`null`，但这并不是可以依赖的。
- en: The final and most important thing that many developers miss, even me, after
    not writing multithread Java API using code for years, is shutting down the `ExecutorService`.
    The `ExecutorService` is created and it has `Thread` elements. The JVM stops when
    all non-daemon threads are stopped. It ain't over till the fat lady sings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者甚至包括我在内，在多年没有使用代码编写多线程Java API之后，常常会忽略的一个重要事情是关闭`ExecutorService`。`ExecutorService`被创建后，它包含`Thread`元素。当所有非守护线程都停止时，JVM才会停止。没有到最后，胖女人还没有唱完。
- en: A thread is a daemon thread if it was set to be daemon (invoking `setDaemon(true)`)
    before it was started. A thread is automatically daemon of the starting thread
    is a daemon thread. Daemon threads are stopped by the JVM when all other threads
    are finished and the JVM wants to finish. Some of the threads the JVM executes
    itself are daemon threads, but it is likely that there is no practical use of
    creating daemon threads in an application program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程在启动之前被设置为守护线程（调用`setDaemon(true)`），则该线程是一个守护线程。如果一个线程的启动线程是守护线程，则该线程自动成为守护线程。当所有其他线程完成并且JVM想要结束时，守护线程会被JVM停止。JVM自己执行的某些线程是守护线程，但在应用程序程序中创建守护线程可能没有实际用途。
- en: Not shutting down the service simply prevents the JVM from stopping. The code
    will hang after the `main` method finishes. To tell the `ExecutorService` that
    there is no need for the threads it has, we will have to `shutdown` the service.
    The call will only start the shutdown and return immediately. In this case, we
    do not want to wait. The JVM does anyway. If we need to wait, we will have to
    call `awaitTermination`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不关闭服务只是阻止JVM停止。在`main`方法完成后，代码将挂起。为了告诉`ExecutorService`它不需要它拥有的线程，我们必须`shutdown`服务。调用将仅启动关闭并立即返回。在这种情况下，我们不想等待。JVM无论如何都会这样做。如果我们需要等待，我们必须调用`awaitTermination`。
- en: ForkJoinPool
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ForkJoinPool
- en: The `ForkJoinPool` is a special `ExecutorService` that has methods to execute
    `ForkJoinTask` objects. These classes are very handy when the task that we want
    to perform can be split into many small tasks and then the results, when they
    are available, aggregated. Using this executor, we need not care about the size
    of the thread pool and shutting down the executor. The size of the thread pool
    is adjusted to the number of processors on the given machine to have optimal performance.
    As the `ForkJoinPool` is a special `ExecutorService` that is designed for short
    running tasks, it does not expect any task to be there longer or being needed
    when there are no more tasks to run. Therefore, it is executed as a daemon thread;
    when the JVM shuts down, the `ForkJoinPool` automatically stops and the lady does
    not sing any more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`是一个特殊的`ExecutorService`，它有执行`ForkJoinTask`对象的方法。当我们要执行的任务可以分解成许多小任务，然后当结果可用时聚合时，这些类非常有用。使用此执行器，我们不需要关心线程池的大小和关闭执行器。线程池的大小调整到给定机器上的处理器数量以获得最佳性能。由于`ForkJoinPool`是一个为短运行任务设计的特殊`ExecutorService`，它不期望有任何任务在任务运行完毕后仍然存在或被需要。因此，它作为守护线程执行；当JVM关闭时，`ForkJoinPool`自动停止，女士不再唱歌。'
- en: To create a task, the programmer should extend either `RecursiveTask` or `RecursiveAction`.
    The first one is to be used when there is some return value from the task, the
    second when there is no computed value returned. They are called recursive because
    many times, these tasks split the problem they have to solve smaller problems
    and invoke these tasks asynchronously through the fork-join API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个任务，程序员应该扩展`RecursiveTask`或`RecursiveAction`之一。第一个用于任务有返回值的情况，第二个用于没有计算值返回的情况。它们被称为递归的，因为很多时候，这些任务将它们必须解决的问题分解成更小的子问题，并通过fork-join
    API异步调用这些任务。
- en: A typical problem to be solved using this API is the quick-sort. In the [Chapter
    3](part0076.html), *Optimizing the Sort - Making Code Professional* we created
    two versions of the quick-sort algorithm. One using recursive calls and one without
    using it. We can also create a new one, which, instead of calling itself recursively,
    schedule the task to be executed, perhaps by another processor. The scheduling
    is the task of the `ForkJoinPool` implementation of `ExecutorService`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此API要解决的问题的一个典型问题是快速排序。在[第3章](part0076.html)，*优化排序 - 使代码专业化*中，我们创建了快速排序算法的两个版本。一个使用递归调用，另一个不使用。我们也可以创建一个新的版本，它不是通过递归调用自己，而是调度要执行的任务，可能由另一个处理器执行。调度是`ForkJoinPool`实现`ExecutorService`的任务。
- en: 'You may revisit the code of `Qsort.java` in [Chapter 3](part0076.html), *Optimizing
    the Sort - Making Code Professional*. Here is the version that is using `ForkJoinPool`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以回顾[第3章](part0076.html)中的`Qsort.java`代码，*优化排序 - 使代码专业化*。这里使用`ForkJoinPool`的版本：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Whenever you can split your tasks into subtasks similar to the way it was done
    in the preceding quick-sort example, I recommend that you use `ForkJoinPool` as
    an `ExecutorService`. You can find good documentation on the API and the use on
    the JavaDoc documentation of Oracle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你可以将任务分解成类似于前面快速排序示例中的子任务时，我建议你使用`ForkJoinPool`作为`ExecutorService`。你可以在Oracle的JavaDoc文档中找到关于API和使用的良好文档。
- en: Variable access
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量访问
- en: 'Now that we can start threads and create code that runs parallel, it is time
    to talk a little bit about how these threads can exchange data between each other.
    At first glimpse, it seems fairly simple. The threads use the same shared memory;
    therefore, they all can read and write all the variables that the Java access
    protection allows them. This is true, except that some threads may just decide
    not to read the memory. After all, if they have just recently read the value of
    some variable, why read it again from the memory to the registers if it was not
    modified? Who would have modified them? Let''s see the following short example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够启动线程并创建并行运行的代码，是时候稍微谈谈这些线程之间如何交换数据了。乍一看，这似乎相当简单。线程使用相同的共享内存；因此，它们都可以读取和写入Java访问保护允许它们读取和写入的所有变量。这是真的，除非某些线程可能只是决定不读取内存。毕竟，如果它们刚刚读取了某个变量的值，为什么还要从内存中再次读取到寄存器，如果它没有被修改？谁会修改它们？让我们看看以下简短的例子：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What will happen? You may expect that the code starts up, starts the new thread,
    and one minute, when the `main` thread sets the object to something not `null`,
    will it stop? It will not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么？你可能预期代码会启动，启动新线程，然后一分钟，当`main`线程将对象设置为非`null`时，它就会停止？不会的。
- en: It may stop on some Java implementations, but in most of them, it will just
    keep spinning. The reason for that is that the JIT compiler optimizes the code.
    It sees that the loop does nothing and also that the variable will just never
    be non-null. It is allowed to assume that because the variables not declared `volatile`
    are not supposed to be modified by any other thread, the JIT is eligible to optimize.
    If we declare the `Object o` variable to be `volatile` (with the `volatile` keyword),
    then the code will stop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Java实现中，它可能会停止，但在大多数情况下，它只是会继续旋转。这是因为JIT编译器优化了代码。它看到循环什么也没做，而且变量永远不会是非`null`的。它被允许假设这一点，因为未声明为`volatile`的变量不应该被任何其他线程修改，JIT编译器有资格进行优化。如果我们声明`Object
    o`变量为`volatile`（使用`volatile`关键字），那么代码就会停止。
- en: In case you try to remove the call to sleep, the code will also stop. This,
    however, does not fix the issue. The reason is that JIT optimization kicks in
    only after about 5000 loops of the code execution. Before that, the code runs
    naive and stops before the optimization will eliminate the extra and regularly
    not needed access to the non-volatile variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试移除调用sleep的代码，代码也会停止。然而，这并不能解决问题。原因是JIT优化只在代码执行大约5000次循环之后才会启动。在此之前，代码会以原始方式运行，并在优化消除额外的、定期不需要访问的非`volatile`变量之前停止。
- en: If this is so gruesome, then why don't we declare all variables to be volatile?
    Why does Java not do that for us? The answer is speed, and to understand it deeper,
    we will use our metaphor, the office, and the bureaucrat.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来如此糟糕，那么我们为什么不将所有变量都声明为`volatile`呢？为什么Java不为我们这样做？答案是速度，为了更深入地理解它，我们将使用我们的比喻，办公室和官僚主义者。
- en: The CPU heartbeat
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU的心跳
- en: These days CPUs run on 2 to 4 GHz frequency processors. It means that a processor
    gets 2 to 4 times 10⁹ clock signals to do something every second. A processor
    cannot do any atomic operation faster than this, and also there is no reason to
    create a clock that is faster than what a processor can follow. It means that
    a CPU performs a simple operation, such as incrementing a register in half or
    quarter of a nanosecond. This is the heartbeat of the processor, and if we think
    of the bureaucrat as humans, who they are, then it is equivalent to one second,
    approximately, if and as their heartbeat.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，CPU运行在2到4 GHz频率的处理器上。这意味着处理器每秒会接收到2到4次10⁹个时钟信号来执行某些操作。处理器无法以比这更快的速度执行任何原子操作，也没有理由创建一个比处理器能跟上的更快的时钟。这意味着CPU执行一个简单的操作，比如在半纳秒或四分之一纳秒内增加一个寄存器。这是处理器的心跳，如果我们把官僚主义者比作人类，那么他们的心跳相当于大约一秒钟。
- en: Processors have registers and caches on the chip on different levels, L1, L2,
    and sometimes L3; there is memory, SSD, disk, network, and tapes that may be needed
    to retrieve data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器在芯片上有不同级别的寄存器和缓存，L1、L2，有时还有L3；有内存、SSD、磁盘、网络和可能需要检索数据的磁带。
- en: Accessing data that is in the L1 cache is approximately 0.5ns. You can grab
    a paper that is on your desk—half of a second. L2 cache is 7ns. This is a paper
    in the drawer. You have to push the chair a bit back, bend it in a sitting position,
    pull out the drawer, take the paper, push the drawer back, and raise and put the
    paper on the desk; it takes 10 seconds, give or take.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 访问位于L1缓存中的数据大约需要0.5纳秒。你可以抓起你桌上的纸张——半秒钟。L2缓存是7纳秒。这就像从抽屉里拿出一张纸。你必须把椅子稍微往后推，弯腰坐好，拉开抽屉，拿出纸张，把抽屉推回去，然后站起来把纸张放在桌子上；这大概需要10秒，上下浮动。
- en: Main memory read is 100ns. The bureaucrat stands up, goes to the shared file
    at the wall, he waits while other bureaucrats are pulling their papers or putting
    theirs back, selects the drawer, pulls it out, takes the paper, and walks back
    to the desk. This is two minutes. This is volatile variable access every time
    you write a single word on a document and it has to be done twice. Once to read,
    and once to write, even if you happen to know that the next thing you will do
    is just fill another field of the form on the same paper.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主内存读取需要100纳秒。官僚站起来，走向墙上的共享文件，他等待其他官僚取回或放回他们的文件，选择抽屉，拉开它，拿出纸张，然后走回桌子。这是两分钟。这是每次你在文档上写一个单词并需要执行两次的易失性变量访问。一次读取，一次写入，即使你碰巧知道你接下来要做的就是填写同一张纸上的另一个字段。
- en: Modern architectures, where there are no multiple CPUs but rather single CPUs
    with multiple cores, are a bit faster. One core may check the other core's caches
    to see if there was any modification on the same variable, but this speeds the
    volatile access to 20ns or so, which is still a magnitude slower than nonvolatile.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现代架构，其中没有多个CPU，而是有多个核心的单个CPU，要快一些。一个核心可能会检查另一个核心的缓存，看看是否有相同的变量被修改，但这将易失性访问速度加快到大约20纳秒，这仍然比非易失性慢一个数量级。
- en: Although the rest is less focused on multithread programming, it is worth mentioning
    here, because it gives good understanding on the different time magnitudes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其余部分不太关注多线程编程，但在这里提一下是值得的，因为它能让我们对不同时间尺度有更好的理解。
- en: Reading a block from an SSD (4K block usually) is 150,000ns. In human speed,
    that is a little bit more than 5 days. Reading or sending something to a server
    over the network on the Gb local Ethernet is 0.5ms, which is like waiting for
    almost a month for the metaphoric bureaucrat. If the data over the network is
    on a spinning magnetic disk, then seek time adds up (the time until the disk rotates
    so that the part of the magnetic surface gets under the reading head) to 20ms.
    It is, approximately, a year in human terms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从SSD（通常是4K块）读取数据需要150,000纳秒。以人类速度来计算，这相当于5天多。在网络上的Gb本地以太网上读取或发送数据到服务器需要0.5毫秒，这就像等待几乎一个月的象征性官僚。如果网络上的数据在旋转的磁盘中，那么寻址时间（直到磁盘旋转到磁表面的一部分到达读取头）会增加到20毫秒。在人类术语中，这大约是一年。
- en: If we send a network packet over the Atlantic on the Internet, it is approximately
    is 150ms. It is like 14 years, and this was only one single package; if we want
    to send data over the ocean, it may be seconds that count up to historic times,
    thousands of years. If we count one minute for a machine to boot, it is equivalent
    to the time span of our whole civilization.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在互联网上通过大西洋发送一个网络数据包，它大约需要150毫秒。这就像14年一样，而这只是一个单一的数据包；如果我们想要通过海洋发送数据，可能就是几秒钟的时间，这可以追溯到历史时期，甚至几千年。如果我们把机器启动一分钟算作时间，那么它就相当于我们整个文明的时间跨度。
- en: 'We should consider these numbers when we want to understand what the CPU is
    doing most of the time: it waits. Additionally, it also helps cool your nerves
    when you think about the speed of a real-life bureaucrat. They are not that slow
    after all, if we consider their heartbeat, which implies the assumption that they
    have a heart. However, let''s go back to real life, CPUs, and L1, L2 caches and
    volatile variables.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要了解CPU大部分时间在做什么时，我们应该考虑这些数字：它是在等待。此外，当你想到现实生活中官僚的速度时，这也帮助你冷静下来。实际上，他们并不那么慢，如果我们考虑到他们的心跳，这意味着他们有心脏的假设。然而，让我们回到现实生活，回到CPU，以及L1、L2缓存和易失性变量。
- en: Volatile variables
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易失性变量
- en: 'Let''s modify the declaration of the `o` variable in our sample code as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们样本代码中`o`变量的声明如下：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code runs fine and stops after a second or so. Any Java implementation
    has to guarantee that multiple threads can access `volatile` fields and the value
    of the field is consistently updated. This does not mean that volatile declaration
    will solve all synchronization issues, but guarantees that the different variables
    and their value change relations are consistent. For example, let''s consider
    we have the following two fields incremented in a method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码运行良好，大约一秒后停止。任何Java实现都必须保证多个线程可以访问`volatile`字段，并且字段的值是一致更新的。这并不意味着`volatile`声明将解决所有同步问题，但它保证了不同变量及其值变化关系的一致性。例如，让我们考虑我们在一个方法中递增以下两个字段：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, reading `i` and `j` from another thread will never result
    an `i>j`. Without the volatile declaration, the compiler is free to reorganize
    the execution of the increment operations if it needs and thus, it will not guarantee
    that an asynchronous thread reads consistent values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，从另一个线程读取`i`和`j`永远不会导致`i>j`。如果没有`volatile`声明，编译器在需要时可以自由重新组织增量操作的执行，因此它不能保证异步线程读取一致值。
- en: Synchronized block
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步块
- en: Declaring variables are not the only tool to ensure the consistency between
    threads. There are other tools in the Java language and one of them is the synchronized
    block. The `synchronized` keyword is part of the language and it can be used in
    front of a method or a program block inside a method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量不是确保线程之间一致性的唯一工具。Java语言中还有其他工具，其中之一就是`synchronized`块。`synchronized`关键字是语言的一部分，它可以用在方法或方法内部程序块的前面。
- en: 'Every object in the Java program has a monitor that can be locked and unlocked
    by any running thread. When a thread locks a monitor, it is said that that thread
    holds the lock, and no two threads can hold the lock of a monitor at a time. If
    a thread tries to lock a monitor that is already locked, it gets `BLOCKED` until
    the monitor is released. A synchronized block starts with the `synchronized` keyword,
    and then an object instance specified between parentheses and the block comes.
    The following small program demonstrates the `synchronized` block:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序中的每个对象都有一个可以被任何运行线程锁定和解锁的监视器。当一个线程锁定一个监视器时，我们说该线程持有锁，并且任何时候不会有两个线程同时持有监视器的锁。如果一个线程尝试锁定已经锁定的监视器，它将`BLOCKED`直到监视器被释放。一个`synchronized`块以`synchronized`关键字开始，然后是一个在括号中指定的对象实例和块。以下小程序演示了`synchronized`块：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code starts two different threads. One of the threads appends `aa` to the
    `StringBuffer`. The other one appends `bb`. This appending is done in two separate
    steps with a sleep in between. The sleep is needed to avoid JIT that optimizes
    the two separate steps into one. Each thread executes the `append` 1000 times
    each time appending `a` or `b` two times. As the two `append`s one after the other
    are inside a `synchronized` block it cannot happen that an `aba` or `bab` sequence
    gets into the `StringBuffer`. While one thread executes the synchronized block,
    the other thread cannot execute it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码启动了两个不同的线程。其中一个线程将`aa`追加到`StringBuffer`中。另一个线程追加`bb`。这种追加是在两个独立的步骤中完成的，中间有一个睡眠时间。睡眠是必要的，以避免JIT将两个独立的步骤优化为一个步骤。每个线程执行`append`
    1000次，每次追加`a`或`b`两次。由于两个连续的`append`操作都在`synchronized`块内部，所以不可能出现`aba`或`bab`序列进入`StringBuffer`。当一个线程执行`synchronized`块时，另一个线程不能执行它。
- en: If I remove the synchronized block, then the JVM I used to test Java HotSpot
    (TM) 64-Bit Server VM (build 9-ea+121, mixed mode) prints out the failure with
    a try-count around a few hundreds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我移除`synchronized`块，那么我用来测试Java HotSpot (TM) 64位服务器虚拟机（构建9-ea+121，混合模式）的JVM将打印出失败，尝试计数大约几百次。
- en: It clearly demonstrates what the synchronization means, but it draws our attention
    to another important phenomena. The error occurs only around every few hundred
    thousand executions only. It is extremely rare, even though this example was furnished
    to demonstrate such a mishap. If a bug appears so rare, it is extremely hard to
    reproduce and, even more, to debug and fix. Most of the synchronization errors
    manifest in mysterious ways and their fixing usually is the result of meticulous
    code review rather than debugging. Therefore, it is extremely important to clearly
    understand the true nature of Java multithread behavior before starting commercial
    multithread application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地展示了同步的含义，但它也引起了我们对另一个重要现象的关注。错误只会在每执行几百万次之后才会发生。尽管这个例子是为了展示这种意外情况而提供的，但它仍然极其罕见。如果错误如此罕见，那么重现它就非常困难，更不用说调试和修复了。大多数同步错误以神秘的方式表现出来，它们的修复通常是通过细致的代码审查而不是调试来实现的。因此，在开始商业多线程应用程序之前，清楚地理解Java多线程行为的真正性质至关重要。
- en: The `synchronized` keyword can also be used in front of a method. In this case,
    the object to acquire the lock of is the object. In case of a `static` method,
    the synchronization is done on the whole class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字也可以用于方法之前。在这种情况下，获取锁的对象是当前对象。如果是`static`方法，则同步是在整个类上完成的。'
- en: Wait and notify
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待和通知
- en: 'There are five methods implemented in the class `Object` that can be used to
    get further synchronization functionality: `wait` with three different timeout
    argument signature, `notify`, and `notifyAll`. To call `wait`, the calling thread
    should have the lock of the `Object` on which `wait` is invoked. It means that
    you can only invoke `wait` from inside a synchronized block, and when it is called,
    the thread gets `BLOCKED` and releases the lock. When another thread calls `notify`
    all on the same `Object`, the thread gets into the `RUNNABLE` state. It cannot
    continue execution immediately as it cannot get the lock on the object. The lock
    is held at that moment by the thread that just called `notifyAll`. However, sometime
    after the other thread releases, the lock gets out of the `synchronized` block,
    and the waiting thread continues the execution.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Object`类中实现了五种方法，可以用来获取更高级的同步功能：带有三个不同超时参数签名的`wait`，`notify`和`notifyAll`。要调用`wait`，调用线程应该拥有被`wait`调用的`Object`的锁。这意味着你只能从`synchronized`块内部调用`wait`，当它被调用时，线程会进入`BLOCKED`状态并释放锁。当另一个线程在同一个`Object`上调用`notifyAll`时，该线程会进入`RUNNABLE`状态。它不能立即继续执行，因为它无法获取对象的锁。此时，锁被刚刚调用`notifyAll`的线程持有。然而，在其他线程释放锁之后的一段时间内，锁会从`synchronized`块中退出，等待的线程将继续执行。
- en: If there are more threads waiting on an object, all of them get out of the `BLOCKED`
    state. The `notify` method wakes only one of the waiting threads. There is no
    guarantee which thread is awakened.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多线程正在等待一个对象，它们都会从`BLOCKED`状态中退出。`notify`方法只会唤醒其中一个等待的线程。无法保证哪个线程会被唤醒。
- en: The typical use of `wait`, `notify`, and `notifyAll` is when one or more threads
    are creating `Object`s that are consumed by other thread, or threads. The storage
    where the objects travel between the threads is some kind of queue. The consumer
    waits until there is something to read from the queue, and the producer puts the
    objects into the queue one after the other. The producer notifies the consumers
    when it stores something into the queue. If there is no room left in the queue,
    the producer has to stop and wait until the queue has some space. In this case,
    the producer calls the `wait` method. To wake the producer up, the consumer calls
    `notifyAll` when it reads something.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`、`notify`和`notifyAll`的典型用法是在一个或多个线程创建由其他线程或线程消费的`Object`时。对象在线程之间传输的存储通常是某种类型的队列。消费者会等待直到可以从队列中读取到内容，生产者则依次将对象放入队列。当生产者将对象存入队列时，它会通知消费者。如果队列中没有剩余空间，生产者必须停止并等待直到队列中有空间。在这种情况下，生产者会调用`wait`方法。为了唤醒生产者，消费者在读取到内容时会调用`notifyAll`。'
- en: The consumer consumes the objects from the queue in a loop and calls `wait`
    only if there is nothing to be read from the queue. When the producer calls `notifyAll`,
    and there is no consumer waiting, the notification is just ignored. It flies away,
    but this is not a problem; consumers are not waiting. When the consumer consumes
    an object and calls `notifyAll` and there is no producer waiting, the situation
    is the same. It is not a problem.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者从队列中以循环的方式消费对象，并且只有在队列中没有东西可读时才调用`wait`。当生产者调用`notifyAll`，但没有消费者等待时，通知就被忽略了。它飞走了，但这不是问题；消费者没有在等待。当消费者消费一个对象并调用`notifyAll`，但没有生产者等待时，情况相同。这不是问题。
- en: It cannot happen that the consumer consumes, calls `notifyAll`, and after the
    notification was flying in the air not finding any waiting producer, a producer
    starts to wait. This cannot happen because the whole code is in a `synchronized`
    block and it ensures that no producer is in the critical section. This is the
    reason why `wait`, `notify`, and `notifyAll` can only be invoked when the lock
    of the `Object` class is acquired.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能出现消费者消费了，调用了`notifyAll`，但在通知在空中飞舞时没有找到任何等待的生产者，然后一个生产者开始等待的情况。这种情况不可能发生，因为整个代码都在一个`synchronized`块中，并且它确保没有生产者在临界区。这就是为什么`wait`、`notify`和`notifyAll`只能在获取了`Object`类的锁时调用。
- en: If there are many consumers, which are executing the same code and are equivalently
    good in consuming the objects, then it is an optimization to call `notify` instead
    of `notifyAll`. In that case, `notifyAll` will just awake all consumer threads
    and all, but the lucky one will recognize that they were woken up but somebody
    else already got away with the bait.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个消费者，它们正在执行相同的代码，并且消费对象的能力相当，那么调用`notify`而不是`notifyAll`是一种优化。在这种情况下，`notifyAll`将唤醒所有消费者线程，但幸运的那个会意识到他们被唤醒了，但有人已经用诱饵逃脱了。
- en: 'I recommend that you practice at least once to implement a blocking queue that
    can be used to pass `Object`s between threads. However, never use that code in
    production: starting with Java 1.5, there are implementations of the `BlockingQueue`
    interface. Use one that fits your needs. We will too, in our example code.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你至少实践一次实现一个可以用于在线程之间传递`Object`的阻塞队列。然而，永远不要在生产环境中使用那段代码：从Java 1.5开始，就有`BlockingQueue`接口的实现。使用适合你需求的实现。在我们的示例代码中，我们也会这样做。
- en: Feel lucky that you can code in Java 9\. I started using Java professionally
    when it was 1.4 and once I had to implement a blocking queue. Life gets just better
    and easier all the time with Java.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你能在Java 9中编码。我开始使用Java是在1.4版本时，那时我不得不实现一个阻塞队列。随着Java的使用，生活变得越来越美好和简单。
- en: In professional code, we usually avoid using `synchronized` methods or blocks
    and `volatile` fields as well as the `wait` and `notify` methods, `notifyAll`
    too, if possible. We can use asynchronous communication between threads, or pass
    the whole multithreading to the framework for handling. `Synchronized` and `volatile`
    cannot be avoided in some special cases when the performance of the code is important,
    or we cannot find a better construct. Sometimes, the direct synchronization on
    specific code and data structures is more efficient than the approach delivered
    by JDK classes. It is to note, however, that those classes also use these low-level
    synchronization constructs, so it is not magic how they work; and to develop yourself,
    you can look into the code of the JDK classes before you want to implement your
    own version. You will realize that it is not that simple to implement these queues;
    the code of the classes is not complex and compound without reason. If you find
    the code simple, it means that you are senior enough to know what not to reimplement.
    Or, perhaps, you do not even realize what code you read.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业代码中，我们通常避免使用`synchronized`方法或块以及`volatile`字段，以及`wait`和`notify`方法，`notifyAll`也是如此，如果可能的话。我们可以使用线程间的异步通信，或者将整个多线程传递给框架处理。在某些特殊情况下，当代码的性能很重要，或者我们找不到更好的结构时，`Synchronized`和`volatile`是无法避免的。有时，对特定代码和数据结构的直接同步比JDK类提供的方法更有效。然而，需要注意的是，这些类也使用这些低级同步结构，所以它们的工作方式并不是魔法；在你想实现自己的版本之前，你可以查看JDK类的代码。你会意识到实现这些队列并不简单；类的代码不是没有理由地复杂和复合。如果你觉得代码简单，这意味着你已经足够资深，知道什么不要重写。或者，也许你没有意识到你读到的代码。
- en: Lock
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁
- en: '`Lock`s are built in Java; every `Object` has a lock that a thread may acquire
    when it enters a `synchronized` block. We discussed that already. In some programming
    code, there are situations when this kind of structure is not optimal.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`是Java内置的；每个`Object`都有一个锁，线程在进入`synchronized`块时可以获取这个锁。我们已经讨论过这一点了。在某些编程代码中，这种结构可能不是最优的。'
- en: In some situations, the structure of locks may be lined up to avoid deadlock.
    It may be needed to acquire lock *A* before *B* and to acquire *B* before C*.*
    However, *A* should be released as soon as possible, not to prevent access to
    resource protected by lock *D*, but also needing lock *A* before it. In complex
    and highly parallel structures, the locks are structured many times into trees
    where accessing a resource a thread should climb down along the tree to a leaf
    representing the resource. In this climbing, the thread gets hold of a lock on
    a node, then a lock on a node below it, and then releases the lock above, just
    like a real climber descending (or climbing up if you imagine the tree with the
    leafs at the top, which is more realistic, nevertheless graphs usually show trees
    upside down).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，锁的结构可能被排列以避免死锁。可能需要先获取锁*A*，然后再获取锁*B*，以及先获取锁*B*，然后再获取锁*C*。然而，*A*应该尽快释放，不仅是为了防止访问由锁*D*保护的资源，也是因为需要在使用锁*A*之前获取它。在复杂且高度并行的结构中，锁通常被多次结构化为树，线程在访问资源时应该沿着树向下爬到代表资源的叶子节点。在这个过程中，线程会获取一个节点的锁，然后是它下面的节点的锁，然后释放上面的锁，就像真正的登山者下降（或者如果你想象树叶在顶部的树，这更现实，尽管图形通常将树倒置显示）一样。
- en: 'You cannot leave a `synchronized` block remaining in another that is inside
    the first one. Synchronized blocks are nested. The `java.util.concurrent.Lock`
    interface defines methods to handle that situation and the implementations are
    also there in the JDK to be used in our code. When you have a lock, you can call
    the methods lock and unlock. The actual order is in your hand and you can write
    the following line of code to get the locking sequence:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能让一个`synchronized`块留在另一个块中，该块位于第一个块内部。`synchronized`块是可以嵌套的。《java.util.concurrent.Lock》接口定义了处理这种情况的方法，JDK中也提供了相应的实现，可以在我们的代码中使用。当你拥有锁时，你可以调用`lock`和`unlock`方法。实际的顺序由你控制，你可以编写以下代码行来获取锁定顺序：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The freedom, however, comes with responsibility as well. The locks and unlocks
    are not tied to the execution sequence of the code, like in case of synchronized
    block, and it may be very easy to create code that in some case just loses a lock
    not unlocking it rendering some resource unusable. The situation is similar to
    a memory leak: you will allocate (lock) something and forget to release (unlock)
    it. After a while, the program will run out of resource.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种自由也伴随着责任。锁和解锁并不绑定到代码的执行顺序，就像在`synchronized`块的情况下，这可能会非常容易创建出在某些情况下只是丢失了锁而没有解锁，导致某些资源无法使用的代码。这种情况类似于内存泄漏：你会分配（锁定）某物，却忘记了释放（解锁）它。过了一段时间，程序将耗尽资源。
- en: My personal recommendation is to avoid using locks if possible and use higher-level
    constructs and asynchronous communications between threads, such as blocking queues.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的建议是尽可能避免使用锁，并使用线程之间的高级构造和异步通信，例如阻塞队列。
- en: Condition
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Condition
- en: The `java.util.concurrent.Condition` interface in functionality is similar to
    the built-in `wait, notify`, and `notifyAll`. Any implementation of `Lock` should
    create new `Condition` objects and return as a result to the invocation of the
    `newCondition` method. When the thread has a `Condition`, it can call `await`,
    `signal`, and `signalAll` when the thread has the lock that created the condition
    object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`java.util.concurrent.Condition`接口在功能上类似于内置的`wait`、`notify`和`notifyAll`。任何`Lock`的实现都应该创建新的`Condition`对象，并将它们作为`newCondition`方法调用的结果返回。当线程拥有`Condition`时，它可以在拥有创建该条件对象的锁时调用`await`、`signal`和`signalAll`。
- en: The functionality is very similar to the methods of `Object` mentioned. However,
    the big difference is that you can create many `Condition`  for a single `Lock`
    and they will work independent of each other, but not independent of the `Lock`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 功能与前面提到的`Object`方法非常相似。然而，最大的区别是你可以为单个`Lock`创建多个`Condition`，它们将相互独立工作，但不是独立于`Lock`。
- en: ReentrantLock
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReentrantLock
- en: '`ReentrantLock` is the simplest implementation of the interface lock in the
    JDK. There are two ways to create this type of lock: with and without fairness
    policy. If the `ReentrantLock(Boolean fair)` constructor is called with the true
    argument, then the lock will be assigned to the thread that is waiting for the
    lock the longest time in case there are many threads waiting. This will avoid
    a thread made to wait for infinite time and starving.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 是 JDK 中接口锁的最简单实现。创建此类锁有两种方式：带有公平策略和不带有公平策略。如果使用 `ReentrantLock(Boolean
    fair)` 构造函数并传入 true 参数，那么在存在多个等待线程的情况下，锁将被分配给等待时间最长的线程。这将避免线程被无限期地等待，从而避免饥饿。'
- en: ReentrantReadWriteLock
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReentrantReadWriteLock
- en: This class is an implementation of `ReadWriteLock`. `ReadWriteLock` is a lock
    that can be used for parallel read access and exclusive write access. It means
    that several threads can read the resource protected by the lock, but when a thread
    writes the resource, no other thread can get access to it, not even read during
    that period. A `ReadWriteLock` is simply two `Lock` objects returned by the `readLock`
    and `writeLock` methods. To get read access on `ReadWriteLock`, the code has to
    invoke `myLock.readLock().lock()`, and to get access to write lock, `myLock.writeLock().lock()`.
    Acquiring one of the locks and releasing it in the implementation is coupled with
    the other lock. To acquire a write lock, no thread should have an active read
    lock, for example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是 `ReadWriteLock` 的实现。`ReadWriteLock` 是一种可以用于并行读访问和独占写访问的锁。这意味着多个线程可以读取由锁保护的资源，但当线程写入资源时，其他线程无法访问它，甚至在那个期间也不能读取。`ReadWriteLock`
    简单来说就是由 `readLock` 和 `writeLock` 方法返回的两个 `Lock` 对象。要获取 `ReadWriteLock` 的读访问，代码必须调用
    `myLock.readLock().lock()`，要获取写锁访问，则调用 `myLock.writeLock().lock()`。在实现中获取一个锁并释放它与另一个锁是耦合的。例如，要获取写锁，不应有任何线程持有活动的读锁。
- en: There are several intricacies in the use of the different lock. For example,
    you can acquire a read lock, but you cannot get a write lock so long as you have
    the read lock. You have to release the read lock first to acquire a write lock.
    This is just one of the simple details, but this is the one that novice programmers
    have trouble with many times. Why is it implemented this way? Why should the program
    get a write lock, which is more expensive—in sense of higher probability locking
    other threads—when it still is not sure that it wants to write the resource? The
    code wants to read it and. based on the content. it may later decide that it wants
    to write it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用不同锁的过程中存在一些复杂性。例如，你可以获取一个读锁，但只要你有读锁，就无法获取写锁。你必须先释放读锁才能获取写锁。这只是简单细节中的一个，但这是新手程序员经常遇到的问题。为什么它要以这种方式实现？为什么程序在还不确定是否要写入资源时，应该获取更昂贵的写锁（在意义上是更高的概率锁定其他线程）？代码想要读取它，并且基于内容，它可能稍后会决定想要写入它。
- en: The issue is not with the implementation. The developers of the library decided
    this rule, not because they just liked it that way or because they were aware
    of parallel algorithms and deadlock possibilities. When two threads have read
    lock and each decides to upgrade the lock to write lock, then they would intrinsically
    create a deadlock. Each would hold the read lock waiting for the write and none
    of them would get it ever.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于实现。库的开发者决定了这个规则，并不是因为他们只是喜欢这种方式，也不是因为他们意识到并行算法和死锁的可能性。当两个线程都持有读锁并且每个线程都决定将锁升级为写锁时，它们本质上会创建一个死锁。每个线程都会持有读锁等待写锁，而它们中的任何一个都不会再得到它。
- en: On the other end, you can downgrade a write lock to a read lock without risking
    that in the meantime somebody acquires a write lock and modifies the resource.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，你可以将写锁降级为读锁，而不用担心在此期间有人获取了写锁并修改了资源。
- en: Atomic classes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子类
- en: Atomic classes enclose primitive values into objects and provide atomic operations
    on them. We discussed race conditions and volatile variables. For example, if
    we have an `int` variable to be used as a counter and we want to assign a unique
    value to objects that we work with, we can increment the value and use the result
    as a unique ID. However, when multiple threads use the same code, we cannot be
    sure about the value we read after the increment. It may happen that another thread
    also incremented the value in the meantime. To avoid that, we will have to enclose
    the increment and the assignment of the incremented value to an object into a
    `synchronized` block. This can also be done using `AtomicInteger`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 原子类将原始值封装到对象中，并提供了对它们的原子操作。我们讨论了竞态条件和`volatile`变量。例如，如果我们有一个用作计数的`int`变量，并希望为处理的对象分配一个唯一的值，我们可以递增值并使用结果作为唯一ID。然而，当多个线程使用相同的代码时，我们无法确保在递增后读取的值。可能发生的情况是，在同时，另一个线程也递增了该值。为了避免这种情况，我们必须将递增和将递增后的值赋给对象的操作封装在一个`synchronized`块中。这也可以使用`AtomicInteger`来完成。
- en: If we have a variable of `AtomicInteger`, then calling `incrementAndGet` increments
    the value of `int` enclosed in the class and returns the incremented value. Why
    do it instead of using synchronized block? The first answer is that if the functionality
    is there in the JDK, then using it is less line than implementing it again. Developers
    maintaining the code you create are expected to know the JDK libraries but have
    to study your code, and this takes time and time is money.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`AtomicInteger`类型的变量，那么调用`incrementAndGet`会递增类中封装的`int`值，并返回递增后的值。为什么不用同步块来做这件事呢？第一个答案是，如果这个功能已经在JDK中存在，那么使用它比再次实现它要少写很多代码。维护你创建的代码的开发者预期应该了解JDK库，但不得不研究你的代码，这需要时间和金钱。
- en: The other reason is that these classes are highly optimized and, many times,
    they implement the features using platform specific native code that greatly over
    performs the version we can implement using synchronized blocks. Worrying about
    performance too early is not good, but parallel algorithms and synchronization
    between threads are usually used when performance is crucial; thus, there is a
    good chance that the performance of the code using the atomic classes is important.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是这些类高度优化，很多时候，它们使用特定平台的本地代码来实现功能，这比我们使用同步块实现的版本性能要好得多。过早担心性能并不好，但并行算法和线程间的同步通常在性能至关重要的场合使用；因此，使用原子类编写的代码的性能可能很重要。
- en: In the `java.util.concurrent.atomic` package, there are several classes, `AtomicInteger`,
    `AtomicBoolean`, `AtomicLong`, and `AtomicReference` among them. They all provide
    methods that are specific to the encapsulated value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent.atomic`包中，有几个类，其中包括`AtomicInteger`、`AtomicBoolean`、`AtomicLong`和`AtomicReference`。它们都提供了针对封装值的特定方法。
- en: 'The method, which is implemented by every atomic class, is `compareAndSet`.
    This is a conditional value-setting operation that has the following format:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原子类都实现了一个方法，即`compareAndSet`。这是一个条件值设置操作，其格式如下：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When it is applied on an atomic class, it compares the actual value with the
    one `expectedValue`, and if they are the same, then it sets the value to `updateValue`.
    If the value was updated, the method returns `true` and it does all this in an
    atomic action.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当它应用于原子类时，它会比较实际值与`expectedValue`，如果它们相同，则将值设置为`updateValue`。如果值已更新，则方法返回`true`，并且它所有这些操作都是在原子操作中完成的。
- en: You may ask the question that if this method is in all of these classes, why
    is there no `Interface` defining this method? The reason for this is that the
    argument types are different based on the encapsulated type, and these types are
    primitives. As primitives cannot be used as generic types, not even a generic
    interface can be defined. In case of `AtomicXXXArray`, the method has an extra
    first argument, which is the index of the array element handled in the call.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果这个方法在所有这些类中都有，为什么没有定义这个方法的`Interface`？原因在于根据封装的类型，参数类型不同，而这些类型是原始类型。由于原始类型不能用作泛型类型，甚至不能定义泛型接口。在`AtomicXXXArray`的情况下，方法有一个额外的第一个参数，即调用中处理的数组元素的索引。
- en: The variables encapsulated are handled the same way as volatile, as far as the
    reordering is concerned, but there are special methods that loosen the conditions
    a bit to be used when possible, and performance is key.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 封装变量在重新排序方面的处理方式与`volatile`相同，但有一些特殊方法稍微放宽了条件，以便在可能的情况下使用，并且性能是关键。
- en: The general advice is to consider using atomic classes, if there is one usable,
    and you will find yourself creating a synchronized block for check-and-set, atomic
    increment, or addition operations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议考虑使用原子类，如果有一个可用的，你会发现自己在创建用于检查和设置、原子递增或加法操作的同步块。
- en: BlockingQueue
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BlockingQueue
- en: '`BlockingQueue` is an interface that extends the standard `Queue` interface
    with methods that are suitable to be used by multithread applications. Any implementation
    of this interface provides methods that allow different threads to put element
    into the queue, pull elements off the queue, and wait for elements that are in
    the queue.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue`是一个接口，它通过提供适合多线程应用程序使用的方法扩展了标准的`Queue`接口。任何实现此接口的类都提供了允许不同线程将元素放入队列、从队列中取出元素以及等待队列中元素的机制。'
- en: When there is a new element that is to be stored in the queue, you can `add`
    it, `offer` it, or `put` it. These are the name of the methods that store elements
    and they do the same thing, but a bit differently. The `add` element throws an
    exception if the queue is full and there is no room for the element. The `offer`
    element does not throw exception but returns either `true` or `false`, based on
    the success. If it can store the element in the queue, it returns `true`. There
    is also a version of `offer` that specifies a timeout. That version of the method
    waits, and returns only `false` if it cannot store the value into the queue during
    the period. The `put` element is the dumbest version; it waits until it can do
    its job.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新元素要存储在队列中时，你可以`add`它，`offer`它，或者`put`它。这些是存储元素的名称，它们做的是同一件事，但略有不同。如果队列已满且没有空间容纳元素，`add`元素会抛出异常。`offer`元素不会抛出异常，但根据成功与否返回`true`或`false`。如果它可以将元素存储在队列中，则返回`true`。还有一个指定超时的`offer`版本。该版本的方法会等待，如果在指定的时间内无法将值存储到队列中，则返回`false`。`put`元素是最简单的版本；它会等待直到可以执行其任务。
- en: When talking about available room in a queue, do not get puzzled and mix it
    with general Java memory management. If there is no more memory, and the garbage
    collector can also not release any, you will certainly get `OutOfMemoryError`.
    Exception is thrown by `add`, and `false` is returned by `offer`, when the queue
    limits are reached. Some of the `BlockingQueue` implementations can limit the
    number of elements that can be stored at a time in a queue. If that limit is reached,
    then the queue is full and cannot accept more elements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论队列中的可用空间时，不要感到困惑，并将其与一般的Java内存管理混淆。如果没有更多内存，并且垃圾收集器也无法释放任何内存，你肯定会得到`OutOfMemoryError`错误。当队列达到限制时，`add`方法会抛出异常，而`offer`方法会返回`false`。
- en: Fetching elements from a `BlockingQueue` implementation also has four different
    ways. In this direction, the special case is when the queue is empty. In that
    case, `remove` throws an exception instead of returning the element, `poll` returns
    `null` if there is no element, and `take` just waits until it can return an element.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从`BlockingQueue`实现中获取元素也有四种不同的方式。在这种情况下，特殊情况是当队列为空时。在这种情况下，`remove`方法会抛出异常而不是返回元素，`poll`在没有元素时返回`null`，而`take`会等待直到可以返回一个元素。
- en: 'Finally, there are two methods inherited from the interface `Queues` that do
    not consume the element from the queue only *look at*. The `element` return the
    head of the queue and throws an exception if the queue is empty, and `peek` returns
    `null` if there is no element in the queue. The following table summarizes the
    operations borrowed from the documentation of the interface:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个从`Queues`接口继承的方法，它们不会从队列中消耗元素，只是*查看*。`element`方法返回队列的头部，如果队列为空，则抛出异常，而`peek`方法在没有元素在队列中时返回`null`。以下表格总结了从接口文档中借用的操作：
- en: '|  | **Throws exception** | **Special value** | **Blocks** | **Times out**
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | **抛出异常** | **特殊值** | **阻塞** | **超时** |'
- en: '| **Insert** | `add(e)` | `offer(e)` | `put(e)` | `offer(e, time, unit)` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **插入** | `add(e)` | `offer(e)` | `put(e)` | `offer(e, time, unit)` |'
- en: '| **Remove** | `remove()` | `poll()` | `take()` | `poll(time, unit)` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **移除** | `remove()` | `poll()` | `take()` | `poll(time, unit)` |'
- en: '| **Examine** | `element()` | `peek()` | `not applicable` | `not applicable`
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **检查** | `element()` | `peek()` | `不适用` | `不适用` |'
- en: LinkedBlockingQueue
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedBlockingQueue
- en: This is an implementation of the `BlockingQueue` interface, which is backed
    up by a linked list. The size of the queue is not limited by default (to be precise,
    it is `Integer.MAX_VALUE`) but it can optionally be limited in a constructor argument.
    The reason to limit the size in this implementation is to aid the use when the
    parallel algorithm performs better with limited size queue, but the implementation
    does not have any restriction on the size.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BlockingQueue`接口的一个实现，它由一个链表支持。队列的大小默认不受限制（确切地说，是`Integer.MAX_VALUE`），但可以在构造函数参数中可选地限制。在这个实现中限制大小的原因是为了帮助当并行算法在有限大小的队列上表现更好时使用，但实现本身对大小没有任何限制。
- en: LinkedBlockingDeque
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedBlockingDeque
- en: This is the simplest implementation of the `BlockingQueue` and also its subinterface
    `BlockingDeque`. As we discussed in the previous chapter, a `Deque` is a double-ended
    queue that has `add`, `remove`, `offer`, and so on, type of methods in the form
    of `xxxFirst` and `xxxLast` to do the act with one or the other end of the queue.
    The `Deque` interface defines `getFirst` and `getLast` instead of consistently
    naming `elementFirst` and `elementLast`, so this is something you should get used
    to. After all, the IDEs help with automatic code completion so this should not
    be a really big problem.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BlockingQueue`最简单的实现，也是其子接口`BlockingDeque`的实现。正如我们在上一章所讨论的，`Deque`是一个双端队列，它具有`add`、`remove`、`offer`等类型的方法，以`xxxFirst`和`xxxLast`的形式出现，用于对队列的一端或另一端进行操作。`Deque`接口定义了`getFirst`和`getLast`，而不是始终使用`elementFirst`和`elementLast`来命名，所以这是你应该习惯的东西。毕竟，IDEs可以帮助自动完成代码，所以这不应该是一个真正的大问题。
- en: ArrayBlockingQueue
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayBlockingQueue
- en: '`ArrayBlockingQueue` implements the `BlockingQueue` interface, hence the Queue
    interface. This implementation manages a queue with fixed size elements. The storage
    in the implementation is an array and the elements are handled in a *FIFO* manner:
    first-in first-out. This is the class that we will also use in the parallel implementation
    of Mastermind for the communication between the boss and the subordinated bureaucrats.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`实现了`BlockingQueue`接口，因此也实现了Queue接口。这个实现管理一个具有固定大小元素的队列。在实现中，存储是一个数组，元素以*FIFO*（先进先出）的方式处理。这是我们将在Mastermind游戏的并行实现中使用，以实现老板和下属官僚之间的通信的类。'
- en: LinkedTransferQueue
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedTransferQueue
- en: The `TransferQueue` interface is extending `BlockingQueue` and the only implementation
    of it in the JDK is `LinkedTransferQueue`. A `TransferQueue` comes handy when
    a thread wants to hand over some data to another thread and needs to be sure that
    some other thread takes the element. This `TransferQueue` has a method transfer
    that puts an element on the queue but does not return until some other thread
    `remove`s (or `poll`s) it. That way the producing thread can be sure that the
    object put on the queue is in the hands of another processing thread and does
    not wait in the queue. The method `transfer` also has a format `tryTransfer` in
    which you can specify some timeout value. If the method times out the element
    is not put into the queue.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferQueue`接口扩展了`BlockingQueue`，在JDK中，它的唯一实现是`LinkedTransferQueue`。当线程想要将一些数据传递给另一个线程并确保有其他线程接收该元素时，`TransferQueue`非常有用。这个`TransferQueue`有一个`transfer`方法，它将一个元素放入队列，但不会返回，直到另一个线程`remove`（或`poll`）它。这样，生产线程可以确信队列中放置的对象已落入另一个处理线程手中，而不会在队列中等待。`transfer`方法还有一个`tryTransfer`格式，你可以指定一个超时值。如果方法超时，元素将不会放入队列。'
- en: IntervalGuesser
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntervalGuesser
- en: We discussed the different Java language elements and JDK classes that are all
    available to implement parallel algorithms. Now, we will see how to use these
    approaches to implement the parallel guesser for the Masterrmind game.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了所有可用于实现并行算法的不同Java语言元素和JDK类。现在，我们将看到如何使用这些方法来实现Masterrmind游戏的并行猜数器。
- en: The class that performs the creation of the guesses is named `IntervalGuesser`.
    It creates the guesses between a start and an end guess and sends them to a `BlockingQueue`.
    The class implements `Runnable` so it can run in a separate `Thread`. The purist
    implementation will separate the `Runnable` functionality from the interval guessing,
    but as the whole class is hardly more than 50 lines, it is forgivable sin implementing
    the two functionalities in a single class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 执行猜测创建的类被命名为`IntervalGuesser`。它创建介于起始猜测和结束猜测之间的猜测，并将它们发送到一个`BlockingQueue`。这个类实现了`Runnable`接口，因此它可以在一个单独的`Thread`中运行。纯粹的实施将把`Runnable`功能与区间猜测分开，但由于整个类只有50行左右，将两个功能实现在一个类中是可以原谅的罪过。
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The implementation is very simple as most of the functionality is already implemented
    in the abstract `Guesser` class. The more interesting code is the one that invoked
    the `IntervalGuesser`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，因为大部分功能已经在前置的 `Guesser` 抽象类中实现。更有趣的代码是调用 `IntervalGuesser` 的代码。
- en: ParallelGamePlayer
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ParallelGamePlayer
- en: 'The `ParallelGamePlayer` class implements the `Player` interface that defines
    the `play` method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelGamePlayer` 类实现了定义了 `play` 方法的 `Player` 接口：'
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method creates a Table, a `RandomSecret` that creates the guess used as
    a secret in a random way, a `Game` object, `IntervalGuesser`s, and a `UniqueGuesser`.
    The `IntervalGuesser`s are the bureaucrats; the `UniqueGuesser` is the boss who
    crosschecks the guesses that the `IntervalGuesser`s create. The method starts
    off the asynchronous guessers and then reads the guesses in a loop from them and
    puts them on the table if they are OK until the game finishes. At the end of the
    method, in the `finally` block, the asynchronous guessers are stopped.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个表，一个 `RandomSecret`，它以随机方式创建用于秘密猜测的代码，一个 `Game` 对象，`IntervalGuesser`s
    和一个 `UniqueGuesser`。`IntervalGuesser`s 是官僚主义者；`UniqueGuesser` 是老板，他交叉检查 `IntervalGuesser`s
    创建的猜测。该方法启动异步猜测器，然后循环读取它们的猜测，如果它们是正确的，就将它们放在桌子上，直到游戏结束。在方法结束时，在 `finally` 块中，异步猜测器被停止。
- en: The start and the stop method for the asynchronous guessers use `ExecutorService`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 异步猜测器的启动和停止方法使用 `ExecutorService`。
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code is quite straightforward. The only thing that may need mention is that
    the queue of the guesses is drained into a collection that we do not use afterward.
    This is needed to help any `IntervalGuesser` that is waiting with a suggested
    guess in hand, trying to put it into the queue. When we drain the queue, the guesser
    thread returns from the method put in the `guessQueue.put(guess);` line in `IntervalGuesser`
    and can catch the interrupt. The rest of the code does not contain anything that
    would be radically different from what we have already seen and you can find it
    on GitHub.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接。唯一可能需要提及的是，猜测的队列被排空到一个我们之后不再使用的集合中。这是为了帮助任何手持建议猜测并试图将其放入队列中的 `IntervalGuesser`。当我们排空队列时，猜测器线程会从
    `IntervalGuesser` 中的 `guessQueue.put(guess);` 行返回方法，并可以捕获中断。其余的代码不包含任何与我们之前看到的截然不同之处，你可以在
    GitHub 上找到它。
- en: The last question that we still want to discuss in this chapter is how much
    speed did we gain making the code parallel?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中还想讨论的最后一个问题是，我们通过使代码并行化获得了多少速度？
- en: Microbenchmarking
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试
- en: Microbenchmarking is measuring the performance of a small code fragment. When
    we want to optimize our code, we will have to measure it. Without measurement,
    code optimization is like shooting blindfolded. You will not hit the target, but
    you likely will shoot somebody else.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试是测量一小段代码的性能。当我们想要优化我们的代码时，我们必须对其进行测量。没有测量，代码优化就像蒙着眼睛射击。你不会击中目标，但你很可能会射中其他人。
- en: Shooting is a good metaphor because you should usually not do it, but when you
    really have to then you have no choice. If there is no performance issue and the
    software meets the requirements, then any optimization, including speed measurement,
    is a waste of money. This does not mean that you are encouraged to write slow
    and sloppy code. When we measure performance, we will compare it against a requirement,
    and the requirement is usually on the user level. Something like, the response
    time of the application should be less than 2 seconds. To do such a measurement,
    we usually create load tests in a test environment and use different profiling
    tools that tell us what is consuming the most time and where we should optimize.
    Many times, it is not only Java code, but configuration optimization, using larger
    database connection pool, more memory, and similar things.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 射击是一个好的隐喻，因为你通常不应该这样做，但当你真的不得不这样做时，你别无选择。如果没有性能问题，软件满足要求，那么任何优化，包括速度测量，都是金钱的浪费。这并不意味着你被鼓励编写缓慢和草率的代码。当我们测量性能时，我们会将其与要求进行比较，而要求通常在用户层面。例如，应用程序的响应时间应小于
    2 秒。为了进行此类测量，我们通常在测试环境中创建负载测试，并使用不同的分析工具，这些工具告诉我们什么消耗了最多时间，我们应该在哪里进行优化。很多时候，不仅限于
    Java 代码，还包括配置优化、使用更大的数据库连接池、更多内存等类似的事情。
- en: Microbenchmarking is a different story. It is about the performance of a small
    Java code fragment and, as such, closer to the Java programming.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试是一个不同的话题。它关乎一小段 Java 代码的性能，因此更接近 Java 编程。
- en: It is rarely used, and before starting to do a microbenchmark for real commercial
    environment, we will have to think twice. Microbenchmark is a luring tool to optimize
    something small without knowing if it is worth optimizing that code. When we have
    a huge application that has several modules run on several servers, how can we
    be sure that improving some special part of the application drastically improves
    the performance? Will it pay back in increased revenue that generates so much
    profit that will cover the cost we burned into the performance testing and development?
    Statistically, almost sure that such an optimization including microbenchmarking
    will not pay off.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法很少见，在开始为真实商业环境进行微基准测试之前，我们必须三思而后行。微基准测试是一个诱人的工具，可以在不知道是否值得优化代码的情况下优化一些小东西。当我们有一个由多个模块组成的大型应用程序，这些模块运行在多个服务器上时，我们如何确保改进应用程序的某个特殊部分会显著提高性能？这将通过增加的收入来偿还我们在性能测试和开发中投入的成本吗？从统计学的角度来看，几乎可以肯定，包括微基准测试在内的这种优化不会带来回报。
- en: Once I was maintaining the code of a senior's colleague. He created a highly
    optimized code to recognize configuration keywords that were present in a file.
    He created a program structure that represented a decision tree based on the characters
    in the key string. If there was a keyword in the configuration file that was misspelled,
    the code threw an exception at the very first character where it could decide
    that the keyword could not be correct.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经我负责维护一位资深同事的代码。他编写了一个高度优化的代码来识别文件中存在的配置关键字。他创建了一个程序结构，该结构基于关键字字符串中的字符表示一个决策树。如果配置文件中存在拼写错误的关键字，代码会在第一个能够判断该关键字可能不正确的地方抛出异常。
- en: To insert a new keyword, it needed to get through the code structure to find
    the occasion in the code where the new keyword was first different from already
    existing ones and extend the deeply nested if/else structures. To read the list
    of the handled keywords was possible from the comments that listed all the keywords
    that he did not forget to document. The code was working blazingly fast, probably
    saving a few milliseconds of the servlet application startup time. The application
    was started up only after system maintenance every few month.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入一个新关键字，需要通过代码结构找到代码中第一个新关键字与已存在的关键字不同的地方，并扩展深层嵌套的if/else结构。要读取处理的关键字列表，可以从注释中读取，注释中列出了他没有忘记记录的所有关键字。代码运行得非常快，可能节省了几个毫秒的servlet应用程序启动时间。应用程序仅在每几个月的系统维护后启动。
- en: You feel the irony, don't you? Seniority is not always the number of years.
    Lucky ones can save their inner child.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你感觉到了讽刺，不是吗？资深并不总是指年数。幸运的人可以保留他们的内心小孩。
- en: 'So when to use microbenchmarking? I can see two areas:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时使用微基准测试呢？我可以看到两个领域：
- en: You identified the code segment that eats most of the resources in your application
    and the improvement can be tested by microbenchmarks
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经确定了消耗你应用程序大部分资源的代码段，并且可以通过微基准测试来测试改进效果。
- en: You cannot identify the code segment that will eat most of the resources in
    an application but you suspect it
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法确定将消耗应用程序大部分资源的代码段，但你有所怀疑。
- en: The first is the usual case. The second is when you develop a library, and you
    just do not know all the applications that will use it. In this case, you will
    try to optimize the part that you think is the most crucial for most of the imagined,
    suspected applications. Even in that case, it is better to take some sample applications
    that are created by users of your library and collect some statistics about the
    use.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是通常的情况。第二个是你开发了一个库，但你并不知道所有将使用它的应用程序。在这种情况下，你将尝试优化你认为对于大多数想象中的、怀疑的应用程序来说最关键的部分。即使在那种情况下，最好也收集一些由你的库的用户创建的示例应用程序，并收集一些关于它们使用的统计数据。
- en: Why should we talk about microbenchmarking in details? What are the pitfalls?
    Benchmarking is an experiment. The first programs I wrote was a TI calculator
    code and I can just count the number of steps the program made to factor two large
    (10 digits those days) prime numbers. Even at that time, I was using an old Russian
    stopwatch to measure the time, being lazy to calculate the number of steps. Experiment
    and measurement was easier.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要详细讨论微基准测试？有哪些陷阱？基准测试是一种实验。我写的第一个程序是TI计算器代码，我可以简单地计算程序执行分解两个大（当时是10位数）质数所需的步骤数。即使在那时，我也使用了一个老式的俄罗斯秒表来测量时间，因为懒得计算步骤数。实验和测量更容易。
- en: Today, you cannot calculate the number of steps the CPU makes even if you wanted.
    There are so many small factors that may change the performance of the applications
    that are out of control of the programmer, which makes it impossible to calculate
    the steps. We have the measurement left for us, and we will gain all the problems
    of measurements.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使你想计算CPU的步骤数，也是不可能的。有太多微小的因素可能会改变应用程序的性能，而这些因素超出了程序员的控制范围，这使得计算步骤变得不可能。我们只剩下测量留给我们的，我们将获得所有测量问题。
- en: What is the biggest problem? We are interested in something, say *X*, and we
    usually cannot measure that. So, we will measure *Y* instead and hope that the
    values of *Y* and *X* are coupled together. We want to measure the length of the
    room, but instead we measure the time it takes for the laser beam to travel from
    one end to the other. In this case, the length *X* and the time *Y* are strongly
    coupled. Many times, *X* and *Y* only correlate more or less. Most of the times,
    when people do measurement, the *X* and *Y* values have no relation to each other
    at all. Still, people put their money and more on decisions backed by such measurements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的问题是什么？我们感兴趣的是某物，比如说 *X*，而我们通常无法测量它。所以，我们将测量 *Y* 而不是 *X*，并希望 *Y* 和 *X* 的值是相互关联的。我们想要测量房间的长度，但相反，我们测量激光束从一端到另一端所需的时间。在这种情况下，长度
    *X* 和时间 *Y* 是强烈关联的。很多时候，*X* 和 *Y* 只是有一定的相关性。大多数时候，当人们进行测量时，*X* 和 *Y* 的值之间根本没有任何关系。尽管如此，人们还是把金钱和更多的东西押在了基于这种测量的决策上。
- en: Microbenchmarking is no different. The first question is how to measure the
    execution time? Small code runs short times and `System.currentTimeMillis()` may
    just return the same value when the measurement starts and when it ends, because
    we are still in the same millisecond. Even if the execution is 10ms, the error
    of the measurement is still at least 10% purely because of the quantization of
    the time as we measure. Luckily, there is `System.nanoTime()`. But is there? Just
    because the name says it returns the number of nanoseconds from a specific start
    time, it does not necessarily mean it really can.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试也没有什么不同。第一个问题是如何测量执行时间？小代码运行时间短，`System.currentTimeMillis()` 可能会在测量开始和结束时返回相同的值，因为我们仍然在同一毫秒内。即使执行时间是
    10ms，测量的误差至少也有 10%，纯粹是因为我们测量时间时的量化。幸运的是，有 `System.nanoTime()`。但是，它真的有吗？仅仅因为名字说它返回从特定开始时间以来的纳秒数，并不意味着它真的可以。
- en: It very much depends on the hardware and the implementation of the method in
    the JDK. It is called nano because this is the precision that we cannot certainly
    reach. If it was microseconds, then some implementation may be limited by the
    definition, even if on the specific hardware, there is a more precise clock. However,
    this is not only the precision of an available hardware clock; it is about the
    precision of the hardware.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于硬件和 JDK 中方法的实现。它被称为纳秒，因为这是我们无法肯定达到的精度。如果它是微秒，那么某些实现可能受到定义的限制，即使在某些特定的硬件上，有一个更精确的时钟。然而，这不仅仅是可用硬件时钟的精度；这是关于硬件的精度。
- en: Let's remember the heartbeat of the bureaucrats, and the time needed to read
    something from memory. Calling a method, such as `System.nanoTime(),` is like
    asking the bellboy in a hotel to run down from the second floor to the lobby and
    peek out to look at the clock on the tower on the other side of the road, come
    back, and tell seconds precision what the time was it when we asked. Nonsense.
    We should know the precision of the clock on the tower and the speed of the bellboy
    running from the floor to the lobby and back. This is a bit more than just calling
    `nanoTime`. This is what a microbenchmarking harness does for us.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住官僚的心跳，以及从内存中读取某物所需的时间。调用一个方法，比如 `System.nanoTime()`，就像要求酒店的门童从二楼跑到大厅，向外窥视对面街道上塔楼上的时钟，然后回来，告诉我们在我们询问时的秒精度时间。荒谬。我们应该知道塔楼时钟的精度和门童从楼层跑到大厅再回来的速度。这不仅仅是调用
    `nanoTime`。这就是微基准测试工具箱为我们做的事情。
- en: The **Java Microbenchmarking Harness** (**JMH**) is available for some time
    as a library. It is developed by Oracle and used to tune the performance of some
    core JDK classes, and with Java 9, these performance measurements and results
    become part of the distributed JDK. This is good news for those who develop Java
    platform for new hardware, but also for developers, because it means that the
    JMH is and will be supported by Oracle.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 微基准测试工具**（**JMH**）作为库已经存在一段时间了。它由 Oracle 开发，用于调整一些核心 JDK 类的性能，并且从 Java
    9 开始，这些性能测量和结果成为分布式 JDK 的一部分。这对那些为新型硬件开发 Java 平台的开发者来说是个好消息，同样对开发者来说也是个好消息，因为这意味着
    JMH 将由 Oracle 支持。'
- en: '"*JMH is a Java harness to build, run, and analyze nano/micro/milli/macro benchmarks
    written in Java and other languages targeting the JVM.*" (quote from the official
    site of JMH, [http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"*JMH 是一个 Java 工具，用于构建、运行和分析用 Java 和其他语言编写的针对 JVM 的纳米/微/毫/宏基准测试。"（摘自 JMH 官方网站，[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))。'
- en: You can run `jmh` as a separate project independent from the actual project
    you measure, or you can just store the measurement code in a separate directory.
    The harness will compile against the production class files and will execute the
    benchmark. The easiest way, as I see, is to use the Gradle plugin to execute JMH.
    You can store the benchmark code in a directory called `jmh` (the same level as
    `main` and `test`) and create a `main` that can start the benchmark.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `jmh` 作为独立于实际测量项目的单独项目运行，或者你只需将测量代码存储在单独的目录中。工具将针对生产类文件进行编译并执行基准测试。在我看来，最简单的方法是使用
    Gradle 插件来执行 JMH。你可以在名为 `jmh` 的目录（与 `main` 和 `test` 同级）中存储基准测试代码，并创建一个可以启动基准测试的
    `main`。
- en: 'The Gradle build script is extended with the following lines:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 构建脚本通过以下行进行了扩展：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And the microbenchmark class is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试类如下：
- en: '[PRE29]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ParallelGamePlayer` is created to play the game with -1, 1, 4, and 8 `IntervalGuesser`
    threads, and in each case, there is a test running with a queue of length 1, 10,
    100, and 1 million. These are 16 test executions. When the number of threads is
    negative, then the constructor uses `LinkedBlockingDeque`. There is another separate
    measurement that measures the nonparallel player. The test was executed with unique
    guesses and secrets (no color used more than once) and ten colors and six columns.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelGamePlayer` 是为了使用 -1、1、4 和 8 个 `IntervalGuesser` 线程来玩游戏而创建的，并且每种情况下都有一个长度为
    1、10、100 和 100 万的队列进行测试。这些是 16 次测试执行。当线程数为负数时，构造函数使用 `LinkedBlockingDeque`。还有另一个单独的测量，用于测量非并行玩家。测试使用了独特的猜测和秘密（没有使用超过一次的颜色）以及十种颜色和六列。'
- en: When the harness starts, it does all the calibrations automatically and runs
    the tests for many iterations to let the JVM start up. You may recall the code
    that just never stopped unless we used the `volatile` modifier in for the variable
    that was used to signal the code to stop. That happened because the JIT compiler
    optimized the code. This is done only when the code was already run a few thousand
    times. The harness makes these executions to warm up the code and ensure that
    the measurement is done when JVM is at full speed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当工具启动时，它会自动进行校准，并运行多次测试以让 JVM 启动。你可能还记得，除非我们使用了 `volatile` 修饰符来为用于通知代码停止的变量，否则代码永远不会停止。这是因为
    JIT 编译器优化了代码。这只有在代码已经运行了几千次之后才会进行。工具执行这些执行以预热代码并确保测量是在 JVM 全速运行时进行的。
- en: Running this benchmark takes approximately 15 minutes on my machine. During
    the execution, it is recommended to stop all other processes and let the benchmark
    use all available resources. If there is anything using resources during the measurement,
    then it will be reflected in the result.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上运行这个基准测试大约需要 15 分钟。在执行过程中，建议停止所有其他进程，让基准测试使用所有可用资源。如果在测量过程中有任何进程使用资源，那么它将反映在结果中。
- en: '[PRE30]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The actual output of the program is a bit more verbose; it was edited for printing
    purposes. The `Score` column shows how many times the benchmark can run in a second.
    The `Error` shows that the measurement shows less than 10% scattering.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的实际输出更为详细；为了打印目的进行了编辑。`Score` 列显示基准测试在一秒内可以运行多少次。`Error` 显示测量显示的散布小于 10%。
- en: The fastest performance we have is when the algorithm runs on eight threads,
    which is the number of threads the processor can independently handle on my machine.
    It is interesting that limiting the size of the queue did not help the performance.
    I actually expected it to be different. Using a one million length array as a
    blocking queue has a huge overhead and this is not a surprise that, in this case,
    the execution is slower than when we have only 100 elements in the queue. The
    unlimited linked list-based queue handling, on the other hand, fairly fast and
    clearly shows that the extra speed at the limited queue for 100 elements does
    not come from the fact that the limit does not allow the `IntervalThreads` to
    run too far.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最快的性能是在算法在八个线程上运行时，这是在我的机器上处理器可以独立处理的线程数。有趣的是，限制队列的大小并没有帮助性能。我实际上预期它会不同。使用一个长度为一百万的数组作为阻塞队列有很大的开销，这并不奇怪，在这种情况下，执行速度比我们只有队列中100个元素时慢。另一方面，基于无限链表的队列处理相当快，并且清楚地表明，对于100个元素的有限队列，额外的速度并不是因为限制不允许`IntervalThreads`运行得太远。
- en: When we start one thread, then we expect similar results, as when we run the
    serial algorithm. The fact that the serial algorithm beats the parallel algorithm
    running on one thread is not a surprise. The thread creation and the communication
    between the main thread and the extra one thread have overhead. The overhead is
    significant, especially when the queue is unnecessarily large.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个线程时，我们期望得到与运行串行算法相似的结果。串行算法打败了在单个线程上运行的并行算法并不令人惊讶。线程创建以及主线程和额外线程之间的通信都有开销。这种开销是显著的，尤其是在队列不必要地大时。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a lot of things. First of all, we refactored the
    code to be ready for further development that uses parallel guessing. We got acquainted
    with processes and threads, and we even mentioned fibers. After that, we looked
    at how Java implements threads and how to create code that runs on multiple threads.
    Additionally, we saw the different means that Java provides to programmers needing
    parallel programs, starting threads, or just starting some tasks in already existing
    threads.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多东西。首先，我们将代码重构以准备进一步使用并行猜测的开发。我们熟悉了进程和线程，甚至提到了纤程。之后，我们研究了Java如何实现线程以及如何创建在多个线程上运行的代码。此外，我们还看到了Java为需要并行程序的开发者提供的不同手段，包括启动线程或只是启动现有线程中的某些任务。
- en: Perhaps the most important part of this chapter that you should remember is
    the metaphor of bureaucrats and the different speeds. This is extremely important
    when you want to understand the performance of concurrent applications. And I
    hope that this is a catchy picture, which is easy to remember.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的部分可能是关于官僚和不同速度的隐喻。当你想要理解并发应用程序的性能时，这一点非常重要。我希望这是一个容易记住的生动画面。
- en: There was a huge topic about the different synchronization means that Java provides,
    and you have also learned about the pitfalls that programmers can fall into when
    programming concurrent applications.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Java提供的不同同步手段有一个很大的主题，你也学习了程序员在编写并发应用程序时可能会陷入的陷阱。
- en: Last but not least, we created the concurrent version of the Mastermind guesser
    and also measured that it is indeed faster than the version that uses only one
    processor (at least on my machine). We used the Java Microbenchmark Harness with
    the Gradle build tool and discussed, a bit, how to perform microbenchmarking.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们创建了Mastermind猜谜游戏的并发版本，并测量了它确实比仅使用一个处理器的版本快（至少在我的机器上）。我们使用了Java
    Microbenchmark Harness和Gradle构建工具，并讨论了如何进行微基准测试。
- en: This was a long chapter and not an easy one. I may tend to think that this is
    the most complex and most theoretical one. If you understood half of it at first
    read, you can be proud. On the other hand, be aware that this is only a good base
    to start experimenting with concurrent programming and there is a long way to
    being senior and professional in this area. And, it is not an easy one. But first
    of all, be proud of yourself at the end of this chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长且不容易的一章。我可能倾向于认为这是最复杂和最理论化的一章。如果你第一次阅读时理解了一半，你可以感到自豪。另一方面，要意识到这只是一个好的基础，可以开始尝试并发编程，而在这个领域成为高级和专业人士还有很长的路要走。而且，这并不容易。但首先，在结束这一章时，要为自己感到自豪。
- en: In the following chapters we will learn more about web and web programming.
    In the very next chapter we will develop our little game so that it can run in
    a server and the player can play with it using a web browser. This will establish
    the basic knowledge for web programming. Later we will build on this developing
    web based service applications, reactive programming and all the tools and areas
    that will make a professional Java developer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习更多关于网页和网页编程的知识。在下一章，我们将开发我们的小游戏，使其能够在服务器上运行，玩家可以使用网页浏览器来玩。这将为我们建立网页编程的基本知识。稍后，我们将在此基础上开发基于网页的服务应用程序、响应式编程以及所有将使Java开发者成为专业人士的工具和领域。
