- en: 5\. Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how exceptions are dealt with in Java. You will first
    learn how to identify the situations that produce exceptions in your code. This
    knowledge will simplify the process of handling these exceptions by alerting you
    to those circumstances in which they are most likely to arise. In this endeavor,
    this chapter also provides a list of best practices guiding you through common
    scenarios and the best methods of either catching exceptions or throwing them
    to the calling class, logging their details as you go. You will further learn
    to differentiate between different types of exceptions, and practice the techniques
    for handling each. By the end of the chapter, you will even be able to create
    your own exception class, capable of logging each type of exception in order of
    severity.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are not errors, or, more accurately, exceptions are not bugs, even
    if you might perceive them to be when they crash your programs. Exceptions are
    situations that occur in your code when there is a mismatch between the data you
    are handling and the method or command you are using to process it.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there is a class that is dedicated to errors. Errors are unexpected
    situations that affect programs on the **Java Virtual Machine** (**JVM**) level.
    For example, if you fill-up the program stack through an unconventional use of
    memory, then your whole JVM will crash. Unlike errors, exceptions are situations
    that your code, when properly designed, can catch on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are not as drastic as errors, even if the result for you, the developer,
    will be the same—that is, a non-working program. In this chapter, we are inviting
    you to make your programs crash by intentionally provoking exceptions that you
    will later learn how to catch (that is, handle) and avoid. Depending on how you
    develop the catch mechanism, you can decide whether to get your program to recover
    and continue operating or to gracefully end its execution with a human-readable
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Exception Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by provoking a simple exception in your code. First, type in the following
    program in the **Integrated Development Environment** (**IDE**) and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code listing shows how the program starts executing a command
    that works fine. The sentence `Go Java Go!` is printed on the console, but then
    a `NullPointerException` shows up, highlighting that something exceptional happened.
    In this case, we tried to print the length of a string initiated to null by calling
    `text.length()`. Since there is no length to be calculated (that is, we don''t
    even have an empty string), either `System.out.println()` or `text.length()` provoked
    the exception. Additionally, there was an error at that point, so the program
    exited and the final call to `System.out.println("done")` was not executed. You
    could try to separate both commands to see what the outcome will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the line numbers in the IDE, you will see that the exception takes
    place on the line where we are trying to get the length of the string. Now that
    we know the cause of the problem, there are two ways around this issue: either
    we fix the data (note that there will be situations where this will be impossible),
    or we include a countermeasure in our code to detect the exceptions and then handle
    or ignore them. The action of handling an unexpected event is what we call catching
    the exception. On the other hand, bypassing the event is called throwing the exception.
    Later in the chapter, we will explore different ways of doing both of these actions,
    as well as good practices for when writing code-handling exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, before learning about how to avoid or handle exceptions, let's provoke
    some more. Almost every Java API includes the definition of an exception that
    can help to propagate errors towards the main class, and thus the developer. In
    that way, it will be possible to avoid situations where the code will break in
    front of the user's eyes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exceptions covered by the Java APIs are what we call built-in exceptions.
    It is also possible to create your own when you define a class. Talking about
    classes, let''s try to get a character from a non-existing location within an
    object instantiated from `String` and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The IDE will respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the text variable is only 12 characters long. When trying to extract
    the 15th character, the IDE will issue an exception and terminate the program.
    In this case, we got one called `StringOutOfBoundsException`. There are many different
    types of built-in exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of the various types of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NullPointerException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringOutOfBoundsException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArithmeticException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassCastException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IllegalArgumentException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IndexOutOfBoundsException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberFormatException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IllegalAccessException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstantiationException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoSuchMethodException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, the names of the different exceptions are quite descriptive.
    When you get one, it should be quite easy to figure out where to find more information
    about it within the Java documentation in order to mitigate the problem. We classify
    exceptions as checked or unchecked:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checked exceptions**: These are highlighted during compilation. In other
    words, your program will not make it to the end of the compilation process, and
    therefore you will not be able to run it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NullPointerException` and `StringOutOfBoundsException`) are both unchecked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Two Types of Exception?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are two possibilities for exceptions: either we, as developers, make
    a mistake and don''t realize that our way of handling data is going to produce
    an error (such as when we are trying to get the length of an empty string or when
    we are dividing a number by zero), or the error happens because we are uncertain
    about the nature of the data we will be gathering during an exchange with something
    external to our program (such as when getting parameters from the CLI and they
    are of the wrong type). In cases like the first one, checked exceptions make more
    sense. The second scenario is the reason why we need unchecked exceptions. In
    this second case, we should develop strategies to handle potential threats to
    the proper execution of the program.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Making an example of a checked exception is slightly more complicated because
    we have to anticipate things that will not be introduced in depth until a later
    chapter. However, we consider that the following example, which displays an example
    of `IOException`, is simple enough even if it includes a couple of classes that
    haven''t been touched on in the book yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The newest thing in this code listing is the use of `java.nio.file.*`. This
    is an API that includes classes and methods to manage files, among other things.
    The goal of this program is to read a whole text file called readme.txt into a
    list that will then be printed using an iterator, as we saw in *Chapter 4*, *Collections,
    Lists, and Java's Built-In APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: This is a case where a checked exception could occur when calling `Files.readAllLines()`
    if there is no file to be read because of, for example, having a wrongly declared
    filename. The IDE knows this and, therefore, it flags that there is a potential
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the IDE displays a warning from the moment we write the code. Furthermore,
    when trying to compile the program, the IDE will respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Catching** and **throwing** are the two strategies that you can use to avoid
    exceptions. We will talk about them in more detail later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: NullPointerException – Have No Fear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We presented the concept of `null` within Java in a previous chapter. As you
    may recall, `null` is the value that is implicitly assigned to an object upon
    creation, that is, unless you assign a different value to it. Related to `null`
    is the `NullPointerException` value. This is a very common event that can and
    will happen to you for a variety of reasons. In this section, we will highlight
    some of the most common scenarios of this in an effort to introduce you to a different
    way of thinking when dealing with any type of exception in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Example01*, we examined the process of trying to perform operations on
    an object that was pointing to `null`. Let''s look at some other possible cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of this example would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You could have prevented this exception if you had written your code to compare
    the existing variable with the potentially `null` one instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no conceptual difference between the examples; however,
    there is a difference at the code level. This difference is enough for your code
    to issue an exception upon compilation. This is because the `equals()` method
    for the `String` class is prepared to handle the situation of its parameter being
    `null`. On the other hand, a `String` variable that is initialized to `null` cannot
    have access to the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common situation for provoking a `NullPointerException` occurs when
    trying to call non-static methods from an object initialized to `null`. The following
    example shows a class with two methods that you can call to see whether they produce
    the exception. You can do this by simply commenting or uncommenting each of the
    lines calling the methods from `main()`. Copy the code in the IDE and try the
    two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are other cases when this exception can appear, but let's focus on how
    to deal with exceptions. The following sections will describe different mechanisms
    you can use to enable your programs to recover from unexpected situations.
  prefs: []
  type: TYPE_NORMAL
- en: Catching Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are two ways to handle exceptions: catching and
    throwing. In this section, we will deal with the first of these methods. Catching
    an exception requires encapsulating the code that might generate an unwanted result
    into a specific statement, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put this code to test with any of the previous examples. Let''s demonstrate
    how we could stop the exception we found in the first example of the chapter,
    where we tried to check the length of a string that was initialized to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have wrapped the potentially broken code inside a `try-catch`
    statement. The result of this code listing is very different from the result that
    we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Mainly, we find that the program is not interrupted until the end. The `try`
    section of the program detects the arrival of the exception, and the `catch` part
    will execute a specific code if the exception is of the `NullPointerException`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several `catch` statements can be placed in sequence after the call to `try`
    as a way to detect different types of exceptions. To try this out, let''s go back
    to the example where we were trying to open a non-existing file and try to catch
    the reason for `readAllLines()` stopping the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw earlier in the chapter, we have made a program that tries to open
    a non-existing file. The exception that we got then was `IOException`. In reality,
    that exception is triggered by `NoSuchFileException`, which is escalated and triggers
    `IOException`. Therefore, we get that exception on the IDE. When implementing
    the multiple try-catch statements, as shown in the previous example, we get the
    following outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the program detects the `NoSuchFileException` and, therefore,
    prints the message included in the corresponding catch statement. However, if
    you want to see the full sequence of exceptions triggered by the non-existing
    readme.txt file, you can use a method called `printStackTrace()`. This will send
    to the output everything that was on the way to the proper execution of the program.
    To see this, simply add the following highlighted changes to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program will now include a full printout of the different
    exceptions triggered during program execution. You will see the output of the
    stack is inverted: first, you will see the reason why the program stopped (`NoSuchFileException`),
    and it will end with the method that starts the process that provokes the exception
    (`readAllLines`). This is due to the way exceptions are built. As we will discuss
    later, there are many different types of exceptions. Each one of these types is
    defined as a class of exceptions, which may be extended by several other subclasses
    of exceptions. If an extension of a certain type occurs, then the class that it
    is extending will also appear when printing out the stack. In our case, `NoSuchFileException`
    is a subclass of `IOException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your operating system, the different nested exceptions for dealing
    with opening a file will probably be called differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been catching two different exceptions – one nested inside the other.
    It should also be possible to handle exceptions coming from different classes,
    such as `IOException` and `NullPointerException`. The following example demonstrates
    how to do this. If you are dealing with exceptions that are not a subclass of
    one another, it is possible to catch both exceptions using a logical OR operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is possible to handle both exceptions in a single `catch`
    statement. However, if you want to handle the exceptions differently, you will
    have to work with the object containing the information about the exception, which,
    in this case, is `ex`. The keyword you need to distinguish the between the exceptions
    that you may be handling simultaneously is `instanceof`, as shown in the following
    modification of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How Many Different Exceptions Can You Catch in a Single Try?
  prefs: []
  type: TYPE_NORMAL
- en: The fact is that you can daisy chain as many catch statements as you need to.
    If you use the second method that we discussed in this chapter (that is, using
    the OR statement), then you should remember that it is not possible to have a
    subclass together with its parent class. For example, it is not possible to have
    NoSuchFileException and IOException together in the same statement – they should
    be placed in two different catch statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Logging Exceptions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main actions that you can perform when catching exceptions aside
    from any type of creative coding you may want to do to respond to the situation;
    these actions are logging or throwing. In this exercise, you will learn how to
    log the exception. In a later exercise, you will learn how to throw it instead.
    As we will reiterate in the *Best Practices for Handling Exceptions* section of
    this chapter, you should never do both at once:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java project in IntelliJ using the template for CLI. Name it LoggingExceptions.
    You will be creating classes inside it that you can then use later in other programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code, you need to import the logging API by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an object that you will be using to log the data into. This object
    will be printed to the terminal upon program termination; therefore, you don''t
    need to worry about where it will end up at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provoke an exception, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the time of catching the exception, send the data to the logger object using
    the `log()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your full program should read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you execute the code, the output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the exception is logged at the determined `SEVERE` level, but
    the code ends without an error code because we were able to handle the exception.
    The log is useful because it tells us where the exception happened in the code
    and, additionally, helps us to find the place of where we can dig deeper into
    the code and fix any potential issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throws and Throw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can choose not to deal with some caught exceptions in your code at a low
    level, as described in the previous section. It could be interesting to filter
    out an exception''s parent class and focus on detecting a subclass that might
    be of more importance to us. The `throws` keyword is used in the definition of
    the method you are creating and where the exception may occur. In the following
    case, which is a modification of *Example 09*, we should call throws in the definition
    of `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are throwing any `IOException` that is occurring during
    runtime. In this way, we can focus on catching the one that actually happens:
    `NoSuchFileException`. It is possible to throw more than one exception type in
    this way by separating them using commas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of such a method definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The one thing that is not possible is having an exception class and its subclass
    being thrown in the same method definition – just as we saw when trying to catch
    more than one exception in a single `catch` statement. It is also interesting
    to see that `throws` is operating at a certain scope; for example, we could disregard
    a certain exception within a method in a class but not a different one.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there is yet another keyword that you will find relevant
    for dealing with exceptions as you advance in your understanding of the term.
    The `throw` keyword (note that this is not `throws`) will explicitly invoke an
    exception. You can use this to create your own exceptions and try them out in
    your code. We will demonstrate in a later section how you can create your own
    exception, and then we will use `throw` as part of the example to also see how
    exceptions propagate. The main reason to use `throw` is if you want your code
    to hand over an exception occurring within your class to another one higher up
    in the hierarchy. For the sake of learning about how this works, let''s look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we reproduce the `NullPointerException` example we saw earlier
    by trying to call the `length()` method on a string initialized as `null`. However,
    if you run this code, you will see that the exception that is being displayed
    is `RuntimeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is the call to `throw new RuntimeException()` that we issued
    in the `catch` block. As you can see, when dealing with the exception, we are
    provoking a different exception. This can be very useful for catching exceptions
    and piping them through your own exceptions, or simply catching the exception,
    giving a meaningful message to help the user understand what went down, and then
    letting the exception continue its own path, and eventually crashing the program
    if the exception is not handled at a higher level in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Breaking the Law (and Fixing It)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, you will create your own checked exception class. You will
    define a class and then experiment by provoking that exception, logging its results,
    and then analyzing them:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java project in IntelliJ using the template for CLI. Name it `BreakingTheLaw`.
    You will be creating classes inside it that you can use later in other programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the code, create a new class to describe your exception. This class should
    extend the base `Exception` class. Call it `MyException` and include the empty
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your constructor should include all the possibilities to be thrown. This implies
    that the constructor needs to contemplate several different cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will allow us to now wrap any exception with our newly formed exception.
    However, there are a couple of modifications that we should apply to our program
    in order for it to compile. First, we need to make the exception class static
    for it to work in the context we are using it in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to make sure that the main class is throwing your new exception
    since you are going to be issuing that exception in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you need to generate some code that will provoke an exception, such
    as `NullPointerException`, when trying to get the length of a `String` initialized
    to `null`, `catch` it, and then `throw` it away using our newly created class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of running this code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now experiment with the call to `throw` by using any other of the constructors
    in the class. We just tried one that includes our own error message, so let''s
    add the stack trace for the exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What will make the output slightly more informative is that it will now include
    information about the exception that generated our own `NullPointerException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have now learned how to use throw to wrap an exception into your own exception
    class. This can be very handy when dealing with a large codebase and having to
    look for the exceptions generated by your code in a long log file, or similar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final code can be referred at: [https://packt.live/2VVdy2f](https://packt.live/2VVdy2f).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The finally Block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `finally` block can be used to execute some common code after any of the
    `catch` blocks used to handle a series of different exceptions in the code. Going
    back to our example where we tried to open a non-existing file, a modified version
    of it including a `finally` statement would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: After the `catch` block detecting the `NoSuchFileException`, the handling mechanism
    jumps into the `finally` block and executes whatever is in it, which, in this
    case, implies printing yet another line of text to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Designing an Exception Class Logging Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen examples of how to log exceptions and how to throw them. We have
    also learned how to create exception classes and throw them. With all that information,
    the goal of this activity is to create your own exception class that should log
    the different exceptions in terms of severity. You should make an application
    that is based on the arguments to the program, and the program will respond to
    the logging exceptions in different ways. Just to have a common ground, use the
    following standard:'
  prefs: []
  type: TYPE_NORMAL
- en: If the input is number 1, issue the `NullPointerException` with a severity level
    of SEVERE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input is number 2, issue the `NoSuchFileException` with a severity level
    of WARNING.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input is number 3, issue the `NoSuchFileException` with a severity level
    of INFO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to make this program, you will need to consider making your own methods
    for issuing exceptions, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 540.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Best Practices for Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dealing with exceptions in your code requires following a set of best practices
    in order to avoid deeper issues when writing your programs. This list of common
    practices is of relevance to your code in order to keep some degree of professional
    programming consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first piece of advice is to avoid throwing or catching the main `Exception`
    class. You need to be as specific as possible when dealing with an exception.
    Therefore, a case like the following is not recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code listing will catch any exception, with no granularity. So, how are
    you supposed to properly handle the exception this way?
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will do a quick recap of where the Exception class
    is located within the Java API structure. We will examine how it hangs from the
    Throwable class at the same level as the Error class. Therefore, if you were to
    catch the Throwable class, you would mask possible errors occurring in your code
    and not only exceptions. Remember that errors are those situations when your code
    should be exited because they alert to a real malfunction that could lead to the
    misuse of JVM resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Masking such a scenario behind a catch could stall the whole JVM. Therefore,
    avoid code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Exercise 2*, *Breaking the Law (and Fixing It)* you saw how to make your
    own exception class. As discussed, it is possible to redirect exceptions toward
    others by using `throw`. It is good practice to not disregard the stack trace
    of the original exception since it will help you to debug the source of the issue
    in a better way. Therefore, when catching the original exception, you should consider
    passing over the whole stack trace as a parameter to the exception constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same exercise, when making your own exception, you learned how to use
    the system''s log to store the information of the exception. You should avoid
    both logging the exception and throwing it once more. You should try to log at
    the highest level possible in your code. Otherwise, you will get duplicated information
    about the situation inside your log, making the debugging a lot more complicated.
    Therefore, we recommend that you use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following inside the same `catch` block, but
    not for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, when logging information, try to use a single call to the system''s
    log. As your code grows bigger, there will be multiple processes working in parallel,
    thus a lot of different sources will be issuing log commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will most likely not show up as two consecutive lines in the log, but
    as two lines that are far apart. Instead, you should do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with multiple exceptions, some being subclasses of others, you
    should catch them in order, starting from the most specific. We have seen this
    in some of the examples in this chapter when, for example, dealing with `NoSuchFileException`
    and `IOException`. Your code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not planning to catch the exception at all, but you are still forced
    to use the try block for the code to compile, use a finally block to close whatever
    actions were initiated prior to the exception. An example of this is opening a
    file that should be closed prior to leaving the method, which will happen because
    of the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `throw` keyword is a very powerful tool, as you have noticed. Being able
    to redirect exceptions allows you to create your own strategy for handling different
    situations and, additionally, it means that you don't have to rely on the strategy
    provided by default by the JVM. However, you should be careful with placing `throw`
    in some of the blocks when catching. You should avoid using `throw` inside a `finally`
    block as it will mask the original reason for the exception.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, this is in line with the "throw early, catch late" principle when
    dealing with Java exceptions. Imagine that you are doing a low-level operation
    that is part of a larger method. For example, you are opening a file as part of
    a piece of code that will parse its contents and look for patterns. If the action
    of opening the file fails due to an exception, it is a better option to simply
    `throw` that exception to the following method for it to put in context and be
    able to decide at a higher level how to proceed with the whole task. You should
    handle the exceptions only when you can make final decisions at a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the use of `printStackTrace()` throughout the previous examples as a
    way to see the full source of an exception. While it is very interesting to be
    able to see that when debugging some code, it is also almost irrelevant when not
    being in that mindset. Therefore, you should make sure to either delete or comment
    away all the `printStackTrace()` commands you might have been using. Other developers
    will have to determine where they want to put their probes when analyzing the
    code later if that is ever needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, when dealing with exceptions in whatever way inside your
    methods, you should remember to document things properly in your Javadoc. You
    should add an `@throws` declaration to clarify what kind of exception arrives
    and whether it is handled, passed over, or what:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Where Do Exceptions Come from?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving away from the more-pragmatic approach we have followed in this chapter,
    it is now time to put things into perspective and understand where things come
    from in the larger schema of the Java API. Exceptions, as mentioned in a previous
    section, hang from the `Throwable` class, which is part of the `java.lang` package.
    They are on the same level as errors (which we explained earlier). In other words,
    both `Exception` and `Error` are subclasses of `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: Only object instances of the `Throwable` class can be thrown by the Java `throw`
    statement; therefore, the way we had to define our own exception implied using
    this class as a point of departure. As stated in the Java documentation for the
    `Throwable` class, this includes a snapshot of the execution stack at the time
    of creation. This allows you to look for the source of the exception (or the error)
    because it includes the state of computer memory at that time. A throwable object
    can contain the reason for which it was constructed. This is what is known as
    the chained exception facility because one exceptional event might be caused by
    a certain chain of exceptions. This is something we have seen when analyzing the
    stack traces in some of the programs in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken a very hands-on approach with this chapter. We started by making
    your code break in different ways, and then explained the differences between
    an error and an exception. We focused on ways to handle the latter because those
    are the only ones that should not make your program crash immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can be handled by catching or throwing. The former is done by observing
    the different exceptions and defining different strategies to respond to the situations
    by means of a try-catch statement. You have the option of either resending the
    exception to a different class with the `throw` or responding within the `catch`
    block. Independently of what strategy you follow, you can set the system to execute
    some final lines of code after handling the exception using the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also included a series of recommendations on how to deal with exceptions
    on a more conceptual level. You have a list of best practices that any professional
    programmer will follow.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the practical level, you worked on a number of exercises that guided
    you through classic scenarios of dealing with exceptions, and you have seen different
    tools that you can use to debug your code, such as logs and `printStackTrace()`.
  prefs: []
  type: TYPE_NORMAL
