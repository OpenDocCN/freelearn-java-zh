<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;File Upload and Error Handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. File Upload and Error Handling</h1></div></div></div><p>In this chapter, we will enable our user to upload a profile picture. We will also see how to handle errors in Spring MVC.</p><div class="section" title="Uploading a file"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Uploading a file</h1></div></div></div><p>We will now <a id="id212" class="indexterm"/>make it possible for our user to upload a profile picture. This <a id="id213" class="indexterm"/>will be available from the profile page later on, but for now, we will simplify things and create a new page in the templates directory under <code class="literal">profile/uploadPage.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Profile Picture Upload&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center"&gt;Upload&lt;/h2&gt;

    &lt;form th:action="@{/upload}" method="post" <span class="strong"><strong>enctype="multipart/form-data"</strong></span> class="col m8 s12 offset-m2"&gt;

        &lt;div class="input-field col s6"&gt;
            &lt;input type="file" id="file" name="file"/&gt;
        &lt;/div&gt;

        &lt;div class="col s6 center"&gt;
            &lt;button class="btn indigo waves-effect waves-light" type="submit" name="save" th:text="#{submit}"&gt;Submit
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Not much to see besides the <code class="literal">enctype</code> attribute on the form. The file will be sent by the <code class="literal">POST</code> method to the <code class="literal">upload</code> URL. We<a id="id214" class="indexterm"/> will now create the corresponding controller right beside <code class="literal">ProfileController</code> in the <code class="literal">profile</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Controller
public class PictureUploadController {
    public static final Resource PICTURES_DIR = new FileSystemResource("./pictures");

    @RequestMapping("upload")
    public String uploadPage() {
        return "profile/uploadPage";
    }

    @RequestMapping(value = "/upload", method = RequestMethod.POST)
    public String onUpload(MultipartFile file) throws IOException {
        String filename = file.getOriginalFilename();
        File tempFile = File.createTempFile("pic", getFileExtension(filename), PICTURES_DIR.getFile());

        try (InputStream in = file.getInputStream();
             OutputStream out = new FileOutputStream(tempFile)) {
            IOUtils.copy(in, out);
        }

        return "profile/uploadPage";
    }

    private static String getFileExtension(String name) {
        return name.substring(name.lastIndexOf("."));
    }
}</pre></div><p>The first thing this code will do is create a temporary file in the <code class="literal">pictures</code> directory, which can be found inside the project's root folder; so, ensure that it exists. In Java, a temporary file is just a commodity to obtain a unique file identifier on the filesystem. It is up to the<a id="id215" class="indexterm"/> user to optionally delete it.</p><p>Create a pictures directory at the root of the project and add an empty file called <code class="literal">.gitkeep</code> to ensure that you can commit it in Git.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>
<span class="strong"><strong>Empty directories in Git</strong></span>
</p><p>Git<a id="id216" class="indexterm"/> is file-based and it is not possible to commit an empty directory. A <a id="id217" class="indexterm"/>common workaround is to commit an empty file, such as <code class="literal">.gitkeep</code>, in a directory to force Git to keep it under version control.</p></div></div><p>The file uploaded by the user will be injected as a <code class="literal">MultipartFile</code> interface in our controller. This interface provides several methods to get the name of the file, its size, and its contents.</p><p>The method that particularly interests us here is <code class="literal">getInputStream()</code>. We will indeed copy this stream to a <code class="literal">fileOutputStream</code> method, thanks to the <code class="literal">IOUtils.copy</code> method. The code to write an input stream to an output stream is pretty boring, so it's handy to have the Apache Utils in the classpath (it is part of the <code class="literal">tomcat-embedded-core.jar</code> file).</p><p>We make heavy use of the pretty cool Spring and Java 7 NIO features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The resource class of string is a utility class that represents an abstraction of resources that can be found in different ways</li><li class="listitem" style="list-style-type: disc">The <code class="literal">try…with</code> block will automatically close our streams even in the case of an exception, removing the boilerplate of writing a <code class="literal">finally</code> block</li></ul></div><p>With the preceding code, any file uploaded by the user will be copied into the <code class="literal">pictures</code> directory.</p><p>There are a handful of properties available in Spring Boot to customize file upload. Take a look at the <code class="literal">MultipartProperties</code> class.</p><p>The most interesting ones are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">multipart.maxFileSize</code>: This defines the maximum file size allowed for the uploaded files. Trying to upload a bigger one will result in a <code class="literal">MultipartException</code> class. The default value is <code class="literal">1Mb</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">multipart.maxRequestSize</code>: This defines the maximum size of the multipart request. The default value is <code class="literal">10Mb</code>.</li></ul></div><p>The defaults <a id="id218" class="indexterm"/>are good enough for our application. After a few uploads, our picture directory will look like this:</p><div class="mediaobject"><img src="graphics/2117_04_01.jpg" alt="Uploading a file"/></div><p>Wait! Somebody uploaded a ZIP file! I cannot believe it. We better add some checks in our controller to ensure that the uploaded files are real images:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import java.io.*;

@Controller
public class PictureUploadController {
    public static final Resource PICTURES_DIR = new FileSystemResource("./pictures");

    @RequestMapping("upload")
    public String uploadPage() {
        return "profile/uploadPage";
    }

    @RequestMapping(value = "/upload", method = RequestMethod.POST)
    public String onUpload(MultipartFile file, RedirectAttributes redirectAttrs) throws IOException {

<span class="strong"><strong>        if (file.isEmpty() || !isImage(file)) {</strong></span>
<span class="strong"><strong>            redirectAttrs.addFlashAttribute("error", "Incorrect file. Please upload a picture.");</strong></span>
<span class="strong"><strong>            return "redirect:/upload";</strong></span>
<span class="strong"><strong>        }</strong></span>

        copyFileToPictures(file);

        return "profile/uploadPage";
    }

    private Resource copyFileToPictures(MultipartFile file) throws IOException {
        String fileExtension = getFileExtension(file.getOriginalFilename());
        File tempFile = File.createTempFile("pic", fileExtension, PICTURES_DIR.getFile());
        try (InputStream in = file.getInputStream();
             OutputStream out = new FileOutputStream(tempFile)) {

            IOUtils.copy(in, out);
        }
        return new FileSystemResource(tempFile);
    }

    <span class="strong"><strong>private boolean isImage(MultipartFile file) {</strong></span>
<span class="strong"><strong>        return file.getContentType().startsWith("image");</strong></span>
<span class="strong"><strong>    }</strong></span>

    private static String getFileExtension(String name) {
        return name.substring(name.lastIndexOf("."));
    }
}</pre></div><p>Pretty easy! The <code class="literal">getContentType()</code> method returns the <span class="strong"><strong>Multipurpose Internet Mail Extensions</strong></span> (<span class="strong"><strong>MIME</strong></span>) type of the file. It will be <code class="literal">image/png</code>, <code class="literal">image/jpg</code>, and so on. So we just have to <a id="id219" class="indexterm"/>check if the MIME <a id="id220" class="indexterm"/>type starts with "image".</p><p>We added an error message to the form so we should add something in our web page to display it. Place the following code just under the title in the <code class="literal">uploadPage</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="col s12 center red-text" th:text="${error}" th:if="${error}"&gt;
    Error during upload
&lt;/div&gt;</pre></div><p>The next time <a id="id221" class="indexterm"/>you try to upload a ZIP file, you will get an error! This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_04_02.jpg" alt="Uploading a file"/></div><div class="section" title="Writing an image to the response"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Writing an image to the response</h2></div></div></div><p>The uploaded images are not served from the static directories. We will need to take special <a id="id222" class="indexterm"/>measures to display them in our web page.</p><p>Let's add the following lines to our upload page, just above the form:</p><div class="informalexample"><pre class="programlisting">&lt;div class="col m8 s12 offset-m2"&gt;
    &lt;img th:src="@{/uploadedPicture}" width="100" height="100"/&gt;
&lt;/div&gt;</pre></div><p>This will try and get the image from our controller. Let's add the corresponding method to the <code class="literal">PictureUploadController</code> class: </p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/uploadedPicture")
public void getUploadedPicture(HttpServletResponse response) throws IOException {
    ClassPathResource classPathResource = new ClassPathResource("/images/anonymous.png");
    response.setHeader("Content-Type", URLConnection.guessContentTypeFromName(classPathResource.getFilename()));
    IOUtils.copy(classPathResource.getInputStream(), response.getOutputStream());
}</pre></div><p>This code will write an image found in the <code class="literal">src/main/resources/images/anonymous.png</code> directory directly to the response! How exciting!</p><p>If we go to our page again, we will see the following image:</p><div class="mediaobject"><img src="graphics/2117_04_03.jpg" alt="Writing an image to the response"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>I found the<a id="id223" class="indexterm"/> anonymous <a id="id224" class="indexterm"/>user image on iconmonstr (<a class="ulink" href="http://iconmonstr.com/user-icon">http://iconmonstr.com/user-icon</a>) and downloaded it as a 128 x 128 PNG file.</p></div></div></div><div class="section" title="Managing upload properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Managing upload properties</h2></div></div></div><p>A good thing to do at this point is to allow the configuration of the upload directory and the path to the<a id="id225" class="indexterm"/> anonymous user image through the <code class="literal">application.properties</code> file.</p><p>Let's create a <code class="literal">PicturesUploadProperties</code> class inside a newly created <code class="literal">config</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;

import java.io.IOException;
@ConfigurationProperties(prefix = "upload.pictures")
public class PictureUploadProperties {
    private Resource uploadPath;
    private Resource anonymousPicture;

    public Resource getAnonymousPicture() {
        return anonymousPicture;
    }

    public void setAnonymousPicture(String anonymousPicture) {
        this.anonymousPicture = new DefaultResourceLoader().getResource(anonymousPicture);
    }

    public Resource getUploadPath() {
        return uploadPath;
    }

    public void setUploadPath(String uploadPath) {
        this.uploadPath = new DefaultResourceLoader().getResource(uploadPath);
    }
}</pre></div><p>In this class, we make use of the Spring Boot <code class="literal">ConfigurationProperties</code>. This will tell Spring Boot to automatically map properties found in the classpath (by default, in the <code class="literal">application.properties</code> file) in a type-safe fashion.</p><p>Notice that we defined setters taking 'String's as arguments but are at liberty to let the getters return any type is the most useful.</p><p>We now need to add the <code class="literal">PicturesUploadProperties</code> class to our configuration:</p><div class="informalexample"><pre class="programlisting">@SpringBootApplication
@EnableConfigurationProperties({PictureUploadProperties.class})
public class MasterSpringMvc4Application extends WebMvcConfigurerAdapter {
  // code omitted
}</pre></div><p>We can now add the properties' values inside the <code class="literal">application.properties</code> file:</p><div class="informalexample"><pre class="programlisting">upload.pictures.uploadPath=file:./pictures
upload.pictures.anonymousPicture=classpath:/images/anonymous.png</pre></div><p>Because we use Spring's <code class="literal">DefaultResourceLoader</code> class, we can use prefixes such as <code class="literal">file:</code> or <code class="literal">classpath:</code> to specify where our resources can be found.</p><p>This would be the equivalent of creating a <code class="literal">FileSystemResource</code> class or a <code class="literal">ClassPathResource</code> class.</p><p>This approach<a id="id226" class="indexterm"/> also has the advantage of documenting the code. We can easily see that the picture directory will be found in the application root, whereas the anonymous picture will be found in the classpath.</p><p>That's it. We can now use our properties inside our controller. The following are the relevant parts of the <code class="literal">PictureUploadController</code> class:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import masterSpringMvc.config.PictureUploadProperties;
import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URLConnection;

@Controller
public class PictureUploadController {
    <span class="strong"><strong>private final Resource picturesDir;</strong></span>
<span class="strong"><strong>    private final Resource anonymousPicture;</strong></span>

<span class="strong"><strong>    @Autowired</strong></span>
<span class="strong"><strong>    public PictureUploadController(PictureUploadProperties uploadProperties) {</strong></span>
<span class="strong"><strong>        picturesDir = uploadProperties.getUploadPath();</strong></span>
<span class="strong"><strong>        anonymousPicture = uploadProperties.getAnonymousPicture();</strong></span>
<span class="strong"><strong>    }</strong></span>

    @RequestMapping(value = "/uploadedPicture")
    public void getUploadedPicture(HttpServletResponse response) throws IOException {
        <span class="strong"><strong>response.setHeader("Content-Type", URLConnection.guessContentTypeFromName(anonymousPicture.getFilename()));</strong></span>
<span class="strong"><strong>        IOUtils.copy(anonymousPicture.getInputStream(), response.getOutputStream());</strong></span>
    }

  private Resource copyFileToPictures(MultipartFile file) throws IOException {
       String fileExtension = getFileExtension(file.getOriginalFilename());
       File tempFile = File.createTempFile("pic", <span class="strong"><strong>fileExtension, picturesDir.getFile());</strong></span>
       try (InputStream in = file.getInputStream();
            OutputStream out = new FileOutputStream(tempFile)) {

           IOUtils.copy(in, out);
       }
       return new FileSystemResource(tempFile);
   }    
// The rest of the code remains the same
}</pre></div><p>At this <a id="id227" class="indexterm"/>point, if you launch your application again, you will see that the result hasn't changed. The anonymous picture is still displayed and the pictures uploaded by our users still end up in the <code class="literal">pictures</code> directory at the project root.</p></div><div class="section" title="Displaying the uploaded picture"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Displaying the uploaded picture</h2></div></div></div><p>It would be<a id="id228" class="indexterm"/> nice to display the user's picture now, wouldn't it? To do this, we will add a model attribute to our <code class="literal">PictureUploadController</code> class:</p><div class="informalexample"><pre class="programlisting">@ModelAttribute("picturePath")
public Resource picturePath() {
  return anonymousPicture;
}</pre></div><p>We can now inject it to retrieve its value when we serve the uploaded picture:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/uploadedPicture")
public void getUploadedPicture(HttpServletResponse response, <span class="strong"><strong>@ModelAttribute("picturePath") Path picturePath</strong></span>) throws IOException {
    response.setHeader("Content-Type", URLConnection.guessContentTypeFromName(picturePath.toString()));
    Files.copy(picturePath, response.getOutputStream());
}</pre></div><p>The <code class="literal">@ModelAttribute</code> annotation is a handy way to create model attributes with an annotated method. They can then be injected with the same annotation into controller methods. With this code, a <code class="literal">picturePath</code> parameter will be available in the model as long as we are not redirected to another page. Its default value is the anonymous picture we defined in our properties.</p><p>We need to <a id="id229" class="indexterm"/>update this value when the file is uploaded. Update the <code class="literal">onUpload</code> method:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/upload", method = RequestMethod.POST)
public String onUpload(MultipartFile file, RedirectAttributes redirectAttrs, <span class="strong"><strong>Model model</strong></span>) throws IOException {

    if (file.isEmpty() || !isImage(file)) {
        redirectAttrs.addFlashAttribute("error", "Incorrect file. Please upload a picture.");
        return "redirect:/upload";
    }

    <span class="strong"><strong>Resource picturePath = copyFileToPictures(file);</strong></span>
<span class="strong"><strong>    model.addAttribute("picturePath", picturePath);</strong></span>

    return "profile/uploadPage";
}</pre></div><p>By injecting the model, we can update the <code class="literal">picturePath</code> parameter after the upload is complete.</p><p>Now, the problem is that our two methods, <code class="literal">onUpload</code> and <code class="literal">getUploadedPicture</code>, will occur in different requests. Unfortunately, the model attributes will be reset between each.</p><p>That's why we will define the <code class="literal">picturePath</code> parameter as a session attribute. We can do this by adding another annotation to our controller class:</p><div class="informalexample"><pre class="programlisting">@Controller
<span class="strong"><strong>@SessionAttributes("picturePath")</strong></span>
public class PictureUploadController {
}</pre></div><p>Phew! That's a lot of annotations just to handle a simple session attribute. You will get the following output:</p><div class="mediaobject"><img src="graphics/2117_04_04.jpg" alt="Displaying the uploaded picture"/></div><p>This<a id="id230" class="indexterm"/> approach makes code composition really easy. Plus, we didn't use <code class="literal">HttpServletRequest</code> or <code class="literal">HttpSession</code> directly. Moreover, our object can be typed easily.</p></div><div class="section" title="Handling file upload errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Handling file upload errors</h2></div></div></div><p>It must have <a id="id231" class="indexterm"/>certainly occurred to my attentive readers that our code is susceptible to throw two kinds of exceptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">IOException</code>: This error is thrown if something bad happens while writing the file to disk.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MultipartException</code>: This error is thrown if an error occurs while uploading the file. For instance, when the maximum file size is exceeded.</li></ul></div><p>This will give us a good opportunity to look at two ways of handling exceptions in Spring:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">@ExceptionHandler</code> annotation locally in a controller method</li><li class="listitem" style="list-style-type: disc">Using a global exception handler defined at the Servlet container level</li></ul></div><p>Let's handle <code class="literal">IOException</code> with the <code class="literal">@ExceptionHandler</code> annotation inside our <code class="literal">PictureUploadController</code> class by adding the following method:</p><div class="informalexample"><pre class="programlisting">@ExceptionHandler(IOException.class)
public ModelAndView handleIOException(IOException exception) {
    ModelAndView modelAndView = new ModelAndView("profile/uploadPage");
    modelAndView.addObject("error", exception.getMessage());
    return modelAndView;
}</pre></div><p>This is a simple yet powerful approach. This method will be called every time an <code class="literal">IOException</code> is thrown in our controller.</p><p>In order to test the exception handler, since making the Java IO code throw an exception can be tricky, just replace the <code class="literal">onUpload</code> method body during the test:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/upload", method = RequestMethod.POST)
public String onUpload(MultipartFile file, RedirectAttributes redirectAttrs, Model model) throws IOException {
    throw new IOException("Some message");
}</pre></div><p>After this <a id="id232" class="indexterm"/>change, if we try to upload a picture, we will see the error message of this exception displayed on the upload page:</p><div class="mediaobject"><img src="graphics/2117_04_05.jpg" alt="Handling file upload errors"/></div><p>Now, we will handle the <code class="literal">MultipartException</code>. This needs to happen at the Servlet container level (that is, at the Tomcat level), as this exception is not thrown directly by our controller.</p><p>We will need to add a new <code class="literal">EmbeddedServletContainerCustomizer</code> bean to our configuration. Add this method to the <code class="literal">WebConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Bean
public EmbeddedServletContainerCustomizer containerCustomizer() {
    EmbeddedServletContainerCustomizer 
embeddedServletContainerCustomizer = new EmbeddedServletContainerCustomizer() {
        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            container.addErrorPages(new ErrorPage(MultipartException.class, "/uploadError"));
        }
    };
    return embeddedServletContainerCustomizer;
}</pre></div><p>This is a little<a id="id233" class="indexterm"/> verbose. Note that <code class="literal">EmbeddedServletContainerCustomizer</code> is an interface that contains a single method; it can therefore be replaced by a lambda expression:</p><div class="informalexample"><pre class="programlisting">@Bean
public EmbeddedServletContainerCustomizer containerCustomizer() {
    EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer
            = container -&gt; container.addErrorPages(new ErrorPage(MultipartException.class, "/uploadError"));
    return embeddedServletContainerCustomizer;
}</pre></div><p>So, let's just write the following:</p><div class="informalexample"><pre class="programlisting">@Bean
public EmbeddedServletContainerCustomizer containerCustomizer() {
    return container -&gt; container.addErrorPages(new ErrorPage(MultipartException.class, "/uploadError"));
}</pre></div><p>This code creates a new error page, which will be called when a <code class="literal">MultipartException</code> happens. It can also be mapped to an HTTP status. The <code class="literal">EmbeddedServletContainerCustomizer</code> interface has many other features that will allow<a id="id234" class="indexterm"/> the customization of the Servlet container in which our application runs. Visit <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers">http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers</a> for more information.</p><p>We now need<a id="id235" class="indexterm"/> to handle this <code class="literal">uploadError</code> URL in our <code class="literal">PictureUploadController</code> class:</p><div class="informalexample"><pre class="programlisting">@RequestMapping("uploadError")
public ModelAndView onUploadError(HttpServletRequest request) {
    ModelAndView modelAndView = new ModelAndView("uploadPage");
    modelAndView.addObject("error", request.getAttribute(WebUtils.ERROR_MESSAGE_ATTRIBUTE));
    return modelAndView;
}</pre></div><p>The error pages defined in a Servlet environment contain a number of interesting attributes that will help debug the error:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.status_code</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the HTTP status code of the error.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.exception_type</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the exception class.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.message</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the message of the exception thrown.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.request_uri</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the URI on which the exception occurred.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.exception</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the actual exception.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.servlet.error.servlet_name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the Servlet that caught the exception.</p>
</td></tr></tbody></table></div><p>All these<a id="id236" class="indexterm"/> attributes are conveniently accessible on the <code class="literal">WebUtils</code> class of Spring Web.</p><p>If someone tries to upload too big a file, they will get a very clear error message.</p><p>You can now test that the error is handled correctly by uploading a really big file (&gt; 1Mb) or setting the <code class="literal">multipart.maxFileSize</code> property to a lower value: 1kb for instance:</p><div class="mediaobject"><img src="graphics/2117_04_06.jpg" alt="Handling file upload errors"/></div></div></div></div>
<div class="section" title="Translating the error messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Translating the error messages</h1></div></div></div><p>It is really good for a developer to see the exceptions thrown by the application. However, for our users, they bear little value. We will therefore translate them. In order to do that, we<a id="id237" class="indexterm"/> have to inject our application's <code class="literal">MessageSource</code> class into our controller's constructor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>private final MessageSource messageSource;</strong></span>

@Autowired
public PictureUploadController(PictureUploadProperties uploadProperties, <span class="strong"><strong>MessageSource messageSource</strong></span>) {
    picturesDir = uploadProperties.getUploadPath();
    anonymousPicture = uploadProperties.getAnonymousPicture();
    <span class="strong"><strong>this.messageSource = messageSource;</strong></span>
}</pre></div><p>Now, we can retrieve messages from our messages bundle:</p><div class="informalexample"><pre class="programlisting">@ExceptionHandler(IOException.class)
public ModelAndView handleIOException(<span class="strong"><strong>Locale locale</strong></span>) {
    ModelAndView modelAndView = new ModelAndView("profile/uploadPage");
    <span class="strong"><strong>modelAndView.addObject("error", messageSource.getMessage("upload.io.exception", null, locale));</strong></span>
    return modelAndView;
}

@RequestMapping("uploadError")
public ModelAndView onUploadError(<span class="strong"><strong>Locale locale</strong></span>) {
    ModelAndView modelAndView = new ModelAndView("profile/uploadPage");
    <span class="strong"><strong>modelAndView.addObject("error", messageSource.getMessage("upload.file.too.big", null, locale));</strong></span>
    return modelAndView;
}</pre></div><p>Here<a id="id238" class="indexterm"/> are the English messages:</p><div class="informalexample"><pre class="programlisting">upload.io.exception=An error occurred while uploading the file. Please try again.
upload.file.too.big=Your file is too big.</pre></div><p>Now, the French ones:</p><div class="informalexample"><pre class="programlisting">upload.io.exception=Une erreur est survenue lors de l'envoi du fichier. Veuillez réessayer.
upload.file.too.big=Votre fichier est trop gros.</pre></div></div>
<div class="section" title="Placing the profile in a session"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Placing the profile in a session</h1></div></div></div><p>The next thing we<a id="id239" class="indexterm"/> want is the profile to be stored in a session so that it <a id="id240" class="indexterm"/>does not get reset every time we go on the profile page. This can apparently prove tiresome to some users and we have to address it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<span class="strong"><strong>HTTP sessions</strong></span><a id="id241" class="indexterm"/> are a way to store information between requests. HTTP is a stateless protocol, which means that there is no way to relate two requests coming from the same user. What most Servlet containers do is they associate a cookie called <code class="literal">JSESSIONID</code> to each user. This cookie will be transmitted in the request header and will allow you to store arbitrary objects in a map, an abstraction called <code class="literal">HttpSession</code>. Such a session will typically end when the user closes or switches web browsers or after a predefined period of inactivity.</p></div></div><p>We just saw a method to put objects in a session using the <code class="literal">@SessionAttributes</code> annotation. This works well within a controller but makes the data difficult to share when spread across multiple controllers. We have to rely on a string to resolve the attribute from its name, which is hard to refactor. For the same reason, we don't want to manipulate the <code class="literal">HttpSession</code> directly. Another argument that will discourage the direct usage of the session is how difficult it is to unit test the controller that depends on it.</p><p>There is another popular approach when it comes to saving things in a session with Spring: annotate a bean with <code class="literal">@Scope("session")</code>.</p><p>You will then be <a id="id242" class="indexterm"/>able to inject your session bean in your controllers <a id="id243" class="indexterm"/>and other Spring components to either set or retrieve values from it.</p><p>Let's create a <code class="literal">UserProfileSession</code> class in the <code class="literal">profile</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;
import java.io.Serializable;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserProfileSession implements Serializable {
    private String twitterHandle;
    private String email;
    private LocalDate birthDate;
    private List&lt;String&gt; tastes = new ArrayList&lt;&gt;();

    public void saveForm(ProfileForm profileForm) {
        this.twitterHandle = profileForm.getTwitterHandle();
        this.email = profileForm.getEmail();
        this.birthDate = profileForm.getBirthDate();
        this.tastes = profileForm.getTastes();
    }

    public ProfileForm toForm() {
        ProfileForm profileForm = new ProfileForm();
        profileForm.setTwitterHandle(twitterHandle);
        profileForm.setEmail(email);
        profileForm.setBirthDate(birthDate);
        profileForm.setTastes(tastes);
        return profileForm;
    }
}</pre></div><p>We have conveniently provided a way to convert from and to a <code class="literal">ProfileForm</code> object. This will help us store and retrieve the form data from our <code class="literal">ProfileController</code> constructor. We need to inject our <code class="literal">UserProfileSession</code> variable in the controller's constructor and store it as a field. We also need to expose the <code class="literal">ProfileForm</code> as a model attribute, which will remove the<a id="id244" class="indexterm"/> need to inject it in the <code class="literal">displayProfile</code> method. Finally, we <a id="id245" class="indexterm"/>can save the profile once it has been validated:</p><div class="informalexample"><pre class="programlisting">@Controller
public class ProfileController {

    private UserProfileSession userProfileSession;
    @Autowired
    public ProfileController(UserProfileSession userProfileSession) {
        this.userProfileSession = userProfileSession;
    }

    @ModelAttribute
    public ProfileForm getProfileForm() {
        return userProfileSession.toForm();
    }

    

    @RequestMapping(value = "/profile", params = {"save"}, method = RequestMethod.POST)
    public String saveProfile(@Valid ProfileForm profileForm, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return "profile/profilePage";
        }
        <span class="strong"><strong>userProfileSession.saveForm(profileForm);</strong></span>
        return "redirect:/profile";
    }

    // the rest of the code is unchanged
}</pre></div><p>That's all it takes to save data in a session with Spring MVC.</p><p>Now, if you complete the profile form and refresh the page, the data will be persisted between requests.</p><p>Just before moving on to the next chapter, I want to detail a couple of concepts we just used.</p><p>The first is the injection by the constructor. The <code class="literal">ProfileController</code> constructor is annotated with <code class="literal">@Autowired</code>, which means Spring will resolve the constructor arguments from the application context before instantiating the bean. The alternative, which is a little less <a id="id246" class="indexterm"/>verbose, would have been to use field injection:</p><div class="informalexample"><pre class="programlisting">@Controller
public class ProfileController {

    @Autowired
    private UserProfileSession userProfileSession;
}</pre></div><p>Constructor injection is arguably better because it makes the unit testing of our controller easier if we <a id="id247" class="indexterm"/>were to move away from the <code class="literal">spring-test</code> framework <a id="id248" class="indexterm"/>and it makes the dependencies of our bean somewhat more explicit.</p><p>For a detailed discussion on field injection and constructor injection, refer to the excellent blog post by <a id="id249" class="indexterm"/>Oliver Gierke at <a class="ulink" href="http://olivergierke.de/2013/11/why-field-injection-is-evil/">http://olivergierke.de/2013/11/why-field-injection-is-evil/</a>.</p><p>Another thing that might need clarification is the <code class="literal">proxyMode</code> parameter on the <code class="literal">Scope</code> annotation:</p><div class="informalexample"><pre class="programlisting">@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)</pre></div><p>There are three <code class="literal">proxyMode</code> parameters available with Spring, if we don't count the default one:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TARGET_CLASS</code>: This uses a CGI proxy</li><li class="listitem" style="list-style-type: disc"><code class="literal">INTERFACES</code>: This creates a JDK proxy</li><li class="listitem" style="list-style-type: disc"><code class="literal">NO</code>: This does not create any proxy</li></ul></div><p>The advantage of a proxy typically comes into play when you inject something into a long-lived component such as a singleton. Because injection only happens once, when the bean is created, subsequent calls to the injected bean might not reflect its actual state.</p><p>In our case, a session bean's actual state is stored in the session and not directly on the bean. This explains why Spring has to create a proxy: it needs to intercept calls to our bean methods and listen for its mutations. This way, the state of the bean can be transparently stored and retrieved from the underlying HTTP session.</p><p>For a session bean, we are forced to use a proxy mode. The CGI proxy will instrument your bytecode and work on any class, whereas the JDK approach might be a bit more lightweight but requires you to implement an interface.</p><p>Lastly, we made the <code class="literal">UserProfileSession</code> bean implement the <code class="literal">Serializable</code> interface. This is not strictly required because the HTTP sessions can store arbitrary objects in memory, but making objects that end up in the session serializable really is a good practice.</p><p>Indeed, we<a id="id250" class="indexterm"/> might change the way the session is persisted. In fact, we <a id="id251" class="indexterm"/>will store the session in a Redis database in <a class="link" href="ch08.html" title="Chapter 8. Optimizing Your Requests">Chapter 8</a>, <span class="emphasis"><em>Optimizing Your Requests</em></span>, where Redis has to work with <code class="literal">Serializable</code> objects. It's always best to think of the session of a generic data store. We have to provide a way to write and read objects from this storage system.</p><p>For serialization to work properly on our bean, we also need every one of its field to be serializable. In our case, strings and dates are serializable so we are good to go.</p></div>
<div class="section" title="Custom error pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Custom error pages</h1></div></div></div><p>Spring Boot lets you define your own error view instead of the Whitelabel error page that we saw <a id="id252" class="indexterm"/>earlier. It must have the name <code class="literal">error</code> and its purpose is to handle all exceptions. The default <code class="literal">BasicErrorController</code> class will expose a lot of useful model attributes that you can display on this page.</p><p>Let's create a custom error page in <code class="literal">src/main/resources/templates</code>. Let's call it <code class="literal">error.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"/&gt;
    &lt;title th:text="${status}"&gt;404&lt;/title&gt;

    &lt;link href="/webjars/materializecss/0.96.0/css/materialize.css" type="text/css" rel="stylesheet"
          media="screen,projection"/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row"&gt;
    &lt;h1 class="indigo-text center" th:text="${error}"&gt;Not found&lt;/h1&gt;

    &lt;p class="col s12 center" th:text="${message}"&gt;
        This page is not available
    &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Now, if we navigate to a URL that is not handled by our application, we see our custom error page:</p><div class="mediaobject"><img src="graphics/2117_04_07.jpg" alt="Custom error pages"/></div><p>A more advanced<a id="id253" class="indexterm"/> option to handle errors is to define your own implementation of the <code class="literal">ErrorController</code> class, a controller in charge of handling all the exceptions at a global level. Take a look at the <code class="literal">ErrorMvcAutoConfiguration</code> class and the <code class="literal">BasicErrorController</code> class, which is the default <a id="id254" class="indexterm"/>implementation.</p></div>
<div class="section" title="URL mapping with matrix variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>URL mapping with matrix variables</h1></div></div></div><p>We are now aware of what our user is interested in. It would be a good idea to improve our Tweet controller so that it allows searching from a list of keywords.</p><p>One interesting <a id="id255" class="indexterm"/>way to pass key-value pairs in a URL is to<a id="id256" class="indexterm"/> use a matrix variable. It is pretty similar to request parameters. Consider the following code:</p><div class="informalexample"><pre class="programlisting">someUrl/param?var1=value1&amp;var2=value2</pre></div><p>Instead of the preceding parameter, matrix variables understand this:</p><div class="informalexample"><pre class="programlisting">someUrl/param;var1=value1;var2=value2</pre></div><p>They also allow each parameter to be a list:</p><div class="informalexample"><pre class="programlisting">someUrl/param;var1=value1,value2;var2=value3,value4</pre></div><p>A matrix variable can be mapped to different object types inside a controller:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Map&lt;String, List&lt;?&gt;&gt;</code>: This handles multiple variables and multiple values</li><li class="listitem" style="list-style-type: disc"><code class="literal">Map&lt;String, ?&gt;</code>: This handles a case in which each variable has only one value</li><li class="listitem" style="list-style-type: disc"><code class="literal">List&lt;?&gt;</code>: This is used if we are interested in a single variable whose name can be configured</li></ul></div><p>In our case, we want to handle something like this:</p><div class="informalexample"><pre class="programlisting">http://localhost:8080/search/popular;keywords=scala,java</pre></div><p>The first parameter, <code class="literal">popular</code>, is the result type known by the Twitter search API. It can take the following values: <code class="literal">mixed</code>, <code class="literal">recent</code>, or <code class="literal">popular</code>.</p><p>The rest of our URL is a list of keywords. We will therefore map them to a simple <code class="literal">List&lt;String&gt;</code> object.</p><p>By default, Spring MVC removes every character following a semicolon in a URL. The first thing we need to do to enable matrix variables in our application is to turn off this behavior.</p><p>Let's add the following code to our <code class="literal">WebConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
    UrlPathHelper urlPathHelper = new UrlPathHelper();
    urlPathHelper.setRemoveSemicolonContent(false);
    configurer.setUrlPathHelper(urlPathHelper);
}</pre></div><p>Let's create a new controller in the <code class="literal">search</code> package, which we will call <code class="literal">SearchController</code>. Its role is to handle the following request:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.social.twitter.api.Tweet;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.MatrixVariable;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import java.util.List;

@Controller
public class SearchController {
    private SearchService searchService;
    @Autowired
    public SearchController(SearchService searchService) {
        this.searchService = searchService;
    }

    @RequestMapping("/search/{searchType}")
    public ModelAndView search(@PathVariable String searchType, @MatrixVariable List&lt;String&gt; keywords) {
        List&lt;Tweet&gt; tweets = searchService.search(searchType, keywords);
        ModelAndView modelAndView = new ModelAndView("resultPage");
        modelAndView.addObject("tweets", tweets);
        modelAndView.addObject("search", String.join(",", keywords));
        return modelAndView;
    }
}</pre></div><p>As you can <a id="id257" class="indexterm"/>see, we are able reuse the existing result <a id="id258" class="indexterm"/>page to display the tweets. We also want to delegate the search to another class called <code class="literal">SearchService</code>. We will create this service in the same package as <code class="literal">SearchController</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.social.twitter.api.Tweet;
import org.springframework.social.twitter.api.Twitter;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class SearchService {
    private Twitter twitter;

    @Autowired
    public SearchService(Twitter twitter) {
        this.twitter = twitter;
    }

    public List&lt;Tweet&gt; search(String searchType, List&lt;String&gt; keywords) {
        return null;
    }
}</pre></div><p>Now, we need to implement the <code class="literal">search()</code> method.</p><p>The search operation accessible on <code class="literal">twitter.searchOperations().search(params)</code> takes <code class="literal">searchParameters</code> as an argument for an advanced search. This object allows us to conduct a search on a dozen of criteria. We are interested in the <code class="literal">query</code>, <code class="literal">resultType</code>, and <code class="literal">count</code> attributes.</p><p>First, we <a id="id259" class="indexterm"/>need to create a <code class="literal">ResultType</code> constructor <a id="id260" class="indexterm"/>with the <code class="literal">searchType</code> path variable. The <code class="literal">ResultType</code> is an enum, so we can iterate over its different values and find one that matches the input, ignoring the case:</p><div class="informalexample"><pre class="programlisting">private SearchParameters.ResultType getResultType(String searchType) {
    for (SearchParameters.ResultType knownType : SearchParameters.ResultType.values()) {
        if (knownType.name().equalsIgnoreCase(searchType)) {
            return knownType;
        }
    }
    return SearchParameters.ResultType.RECENT;
}</pre></div><p>We can now create a <code class="literal">SearchParameters</code> constructor with the following method:</p><div class="informalexample"><pre class="programlisting">private SearchParameters createSearchParam(String searchType, String taste) {

    SearchParameters.ResultType resultType = getResultType(searchType);
    SearchParameters searchParameters = new SearchParameters(taste);
    searchParameters.resultType(resultType);
    searchParameters.count(3);
    return searchParameters;
}</pre></div><p>Now, creating a list of the <code class="literal">SearchParameters</code> constructor is as easy as conducting a map operation (taking a list of keywords and returning a <code class="literal">SearchParameters</code> constructor for each one):</p><div class="informalexample"><pre class="programlisting">List&lt;SearchParameters&gt; searches = keywords.stream()
        .map(taste -&gt; createSearchParam(searchType, taste))
        .collect(Collectors.toList());</pre></div><p>Now, we want to fetch the tweets for each <code class="literal">SearchParameters</code> constructor. You might think of something like this:</p><div class="informalexample"><pre class="programlisting">List&lt;Tweet&gt; tweets = searches.stream()
        .map(params -&gt; twitter.searchOperations().search(params))
        .map(searchResults -&gt; searchResults.getTweets())
        .collect(Collectors.toList());</pre></div><p>However, if you think about it, this will return a list of tweets. What we want is to flatten all the<a id="id261" class="indexterm"/> tweets to get them as a simple list. It turns out that<a id="id262" class="indexterm"/> calling <code class="literal">map</code> and then flattening the result is an operation known as <code class="literal">flatMap</code>. So we can write:</p><div class="informalexample"><pre class="programlisting">List&lt;Tweet&gt; tweets = searches.stream()
        .map(params -&gt; twitter.searchOperations().search(params))
        .flatMap(searchResults -&gt; searchResults.getTweets().stream())
        .collect(Collectors.toList());</pre></div><p>The syntax of <code class="literal">flatMap</code> function, that takes a stream as a parameter, is a bit difficult to understand at first. Let me show you the entire code of the <code class="literal">SearchService</code> class so we can take a step back:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.social.twitter.api.SearchParameters;
import org.springframework.social.twitter.api.Tweet;
import org.springframework.social.twitter.api.Twitter;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SearchService {
    private Twitter twitter;

    @Autowired
    public SearchService(Twitter twitter) {
        this.twitter = twitter;
    }

    public List&lt;Tweet&gt; search(String searchType, List&lt;String&gt; keywords) {
        List&lt;SearchParameters&gt; searches = keywords.stream()
                .map(taste -&gt; createSearchParam(searchType, taste))
                .collect(Collectors.toList());

        List&lt;Tweet&gt; results = searches.stream()
                .map(params -&gt; twitter.searchOperations().search(params))
                .flatMap(searchResults -&gt; searchResults.getTweets().stream())
                .collect(Collectors.toList());

        return results;
    }

    private SearchParameters.ResultType getResultType(String searchType) {
        for (SearchParameters.ResultType knownType : SearchParameters.ResultType.values()) {
            if (knownType.name().equalsIgnoreCase(searchType)) {
                return knownType;
            }
        }
        return SearchParameters.ResultType.RECENT;
    }

    private SearchParameters createSearchParam(String searchType, String taste) {
        SearchParameters.ResultType resultType = getResultType(searchType);
        SearchParameters searchParameters = new SearchParameters(taste);
        searchParameters.resultType(resultType);
        searchParameters.count(3);
        return searchParameters;
    }
}</pre></div><p>Now, if we <a id="id263" class="indexterm"/>navigate to <code class="literal">http://localhost:8080/search/mixed;keywords=scala,java</code>, we get the expected result. A<a id="id264" class="indexterm"/> search for the Scala keyword and then for Java:</p><div class="mediaobject"><img src="graphics/2117_04_08.jpg" alt="URL mapping with matrix variables"/></div></div>
<div class="section" title="Putting it together"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Putting it together</h1></div></div></div><p>Now that everything works separately, it's time to assemble everything. We will do this in three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Move the <a id="id265" class="indexterm"/>upload form to the profile page and remove the old upload page.</li><li class="listitem">Change the submit button on the profile page to trigger the taste search directly.</li><li class="listitem">Change the home page of our application. It should display search results matching our users' tastes right away. If they are unavailable, go to the profile page.</li></ol></div><p>I encourage you to try to do it on your own. You will run into very manageable problems along the way but you should know enough to resolve them on your own. I believe in you.</p><p>OK, now that you have done the work (you have, haven't you?), let's take a look at my solution.</p><p>The first step is <a id="id266" class="indexterm"/>to remove the old <code class="literal">uploadPage</code> title. Don't look back, just do it.</p><p>Next, put these lines just below the <code class="literal">profilePage</code> title:</p><div class="informalexample"><pre class="programlisting">&lt;div class="row"&gt;

    &lt;div class="col m8 s12 offset-m2"&gt;
        &lt;img th:src="@{/uploadedPicture}" width="100" height="100"/&gt;
    &lt;/div&gt;

    &lt;div class="col s12 center red-text" th:text="${error}" th:if="${error}"&gt;
        Error during upload
    &lt;/div&gt;

    &lt;form th:action="@{/profile}" method="post" enctype="multipart/form-data" class="col m8 s12 offset-m2"&gt;

        &lt;div class="input-field col s6"&gt;
            &lt;input type="file" id="file" name="file"/&gt;
        &lt;/div&gt;

        &lt;div class="col s6 center"&gt;
            &lt;button class="btn indigo waves-effect waves-light" type="submit" name="upload" th:text="#{upload}"&gt;Upload
                &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;</pre></div><p>It is very similar to the content of the late <code class="literal">uploadPage</code>. We just removed the title and changed the label of the submit button. Add the corresponding translation to the bundles.</p><p>In English:</p><div class="informalexample"><pre class="programlisting">upload=Upload</pre></div><p>In French:</p><div class="informalexample"><pre class="programlisting">Upload=Envoyer</pre></div><p>We also changed the name of the submit button to <code class="literal">upload</code>. That will help us identify this action on the controller side.</p><p>Now, if we try to upload our picture, it will redirect us to the old upload page. We need to fix this in the <code class="literal">onUpload</code> method of our <code class="literal">PictureUploadController</code> class:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(<span class="strong"><strong>value = "/profile",</strong></span> params = {"upload"}, method = RequestMethod.POST)
public String onUpload(@RequestParam MultipartFile file, RedirectAttributes redirectAttrs) throws IOException {

    if (file.isEmpty() || !isImage(file)) {
        redirectAttrs.addFlashAttribute("error", "Incorrect file. Please upload a picture.");
        <span class="strong"><strong>return "redirect:/profile";</strong></span>
    }

    Resource picturePath = copyFileToPictures(file);
    <span class="strong"><strong>userProfileSession.setPicturePath(picturePath);</strong></span>

    <span class="strong"><strong>return "redirect:profile";</strong></span>
}</pre></div><p>Note that we <a id="id267" class="indexterm"/>changed the URL that handles the post. It is now <code class="literal">/profile</code> instead of <code class="literal">/upload</code>. Form handling is much simpler when the <code class="literal">GET</code> and <code class="literal">POST</code> requests have the same URL, and will save us a lot of trouble especially when dealing with exceptions. This way, we will not have to redirect the user after an error.</p><p>We also removed the model attribute, <code class="literal">picturePath</code>. Since we now have a bean representing our user in a session, <code class="literal">UserProfileSession</code>, we decided to add it there. We added a <code class="literal">picturePath</code> attribute to the <code class="literal">UserProfileSession</code> class and the associated getters and setters.</p><p>Don't forget to inject the <code class="literal">UserProfileSession</code> class and make it available as a field in our <code class="literal">PictureUploadController</code> class.</p><p>Remember that all the properties of our session bean must be serializable, unlike resources. So we need to store it differently. The URL class seems to be a good fit. It is serializable and it is easy to create a resource from a URL with the <code class="literal">UrlResource</code> class:</p><div class="informalexample"><pre class="programlisting">@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserProfileSession implements Serializable {
    private URL picturePath;

    public void setPicturePath(Resource picturePath) throws IOException {
        this.picturePath = picturePath.getURL();
    }

    public Resource getPicturePath() {
        return picturePath == null ? null : new UrlResource(picturePath);
    }
}</pre></div><p>The last thing <a id="id268" class="indexterm"/>that I had to do is to make the <code class="literal">profileForm</code> available as a model attribute after an error. This is because the <code class="literal">profilePage</code> requires it when it is rendered.</p><p>To sum up, here is the final version of the <code class="literal">PictureUploadController</code> class:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.profile;

import masterSpringMvc.config.PictureUploadProperties;
import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URLConnection;
import java.util.Locale;

@Controller
public class PictureUploadController {
    private final Resource picturesDir;
    private final Resource anonymousPicture;
    private final MessageSource messageSource;
    private final UserProfileSession userProfileSession;

    @Autowired
    public PictureUploadController(PictureUploadProperties uploadProperties,
                                   MessageSource messageSource,
                                   UserProfileSession userProfileSession) {
        picturesDir = uploadProperties.getUploadPath();
        anonymousPicture = uploadProperties.getAnonymousPicture();
        this.messageSource = messageSource;
        this.userProfileSession = userProfileSession;
    }

    @RequestMapping(value = "/uploadedPicture")
    public void getUploadedPicture(HttpServletResponse response) throws IOException {
        Resource picturePath = userProfileSession.getPicturePath();
        if (picturePath == null) {
            picturePath = anonymousPicture;
        }
        response.setHeader("Content-Type", URLConnection.guessContentTypeFromName(picturePath.getFilename()));
        IOUtils.copy(picturePath.getInputStream(), response.getOutputStream());
    }

    @RequestMapping(value = "/profile", params = {"upload"}, method = RequestMethod.POST)
    public String onUpload(@RequestParam MultipartFile file, RedirectAttributes redirectAttrs) throws IOException {

        if (file.isEmpty() || !isImage(file)) {
            redirectAttrs.addFlashAttribute("error", "Incorrect file. Please upload a picture.");
            return "redirect:/profile";
        }

        Resource picturePath = copyFileToPictures(file);
        userProfileSession.setPicturePath(picturePath);

        return "redirect:profile";
    }

    private Resource copyFileToPictures(MultipartFile file) throws IOException {
        String fileExtension = getFileExtension(file.getOriginalFilename());
        File tempFile = File.createTempFile("pic", fileExtension, picturesDir.getFile());
        try (InputStream in = file.getInputStream();
             OutputStream out = new FileOutputStream(tempFile)) {

            IOUtils.copy(in, out);
        }
        return new FileSystemResource(tempFile);
    }

    @ExceptionHandler(IOException.class)
    public ModelAndView handleIOException(Locale locale) {
        ModelAndView modelAndView = new ModelAndView("profile/profilePage");
        modelAndView.addObject("error", messageSource.getMessage("upload.io.exception", null, locale));
        modelAndView.addObject("profileForm", userProfileSession.toForm());
        return modelAndView;
    }

    @RequestMapping("uploadError")
    public ModelAndView onUploadError(Locale locale) {
        ModelAndView modelAndView = new ModelAndView("profile/profilePage");
        modelAndView.addObject("error", messageSource.getMessage("upload.file.too.big", null, locale));
        modelAndView.addObject("profileForm", userProfileSession.toForm());
        return modelAndView;
    }

    private boolean isImage(MultipartFile file) {
        return file.getContentType().startsWith("image");
    }

    private static String getFileExtension(String name) {
        return name.substring(name.lastIndexOf("."));
    }
}</pre></div><p>So, now we <a id="id269" class="indexterm"/>can go to the profile page and upload our picture as well as provide personal information, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_04_09.jpg" alt="Putting it together"/></div><p>Now, let's redirect<a id="id270" class="indexterm"/> our user to its search after the profile is completed. For this, we need to modify the <code class="literal">saveProfile</code> method in the <code class="literal">ProfileController</code> class:</p><div class="informalexample"><pre class="programlisting">@RequestMapping(value = "/profile", params = {"save"}, method = RequestMethod.POST)
public String saveProfile(@Valid ProfileForm profileForm, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        return "profile/profilePage";
    }
    userProfileSession.saveForm(profileForm);
    <span class="strong"><strong>return "redirect:/search/mixed;keywords=" + String.join(",", profileForm.getTastes());</strong></span>
}</pre></div><p>Now that we are able to search for tweets from our profile, we don't need the <code class="literal">searchPage</code> or <code class="literal">TweetController</code> we previously made. Simply delete the <code class="literal">searchPage.html</code> page and the <code class="literal">TweetController</code>.</p><p>To finish, we can modify our home page so that it redirects us to a search matching our tastes if we have already completed our profile.</p><p>Let's create a <a id="id271" class="indexterm"/>new controller in the controller package. It is responsible for redirecting a user arriving at the root of our website either to their profile if it's incomplete or to the <code class="literal">resultPage</code> if their tastes are available:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.controller;

import masterSpringMvc.profile.UserProfileSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

@Controller
public class HomeController {
    private UserProfileSession userProfileSession;

    @Autowired
    public HomeController(UserProfileSession userProfileSession) {
        this.userProfileSession = userProfileSession;
    }

    @RequestMapping("/")
    public String home() {
        List&lt;String&gt; tastes = userProfileSession.getTastes();
        if (tastes.isEmpty()) {
            return "redirect:/profile";
        }
        return "redirect:/search/mixed;keywords=" + String.join(",", tastes);
    }
}</pre></div></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>The check point</h1></div></div></div><p>In this chapter, we <a id="id272" class="indexterm"/>added two controllers, the <code class="literal">PictureUploadController</code>, which is in charge of writing uploaded files to the disk and handling upload errors, and the <code class="literal">SearchController</code> that can search tweets from a list of keywords with matrix parameters.</p><p>This controller then delegates the search to a new service, <code class="literal">SearchService</code>.</p><p>We deleted the old <code class="literal">TweetController</code>.</p><p>We created a session bean, <code class="literal">UserProfileSession</code>, to store the information about our user.</p><p>Finally, we<a id="id273" class="indexterm"/> added two things to <code class="literal">WebConfiguration</code>. We added the error pages for our Servlet container and support for matrix variables.</p><div class="mediaobject"><img src="graphics/2117_04_10.jpg" alt="The check point"/></div><p>On the resources side, we added a picture representing an anonymous user and a static page to handle errors. We added the file upload to <code class="literal">profilePage</code> and got rid of the old <code class="literal">searchPage</code>.</p><div class="mediaobject"><img src="graphics/2117_04_11.jpg" alt="The check point"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we discussed file upload and error handling. Uploading a file is not really complicated. However, a big design decision is what to do with the uploaded files. We could have stored the images it in a database, but instead we chose to write it to the disk and save the location of each user's picture in their session.</p><p>We saw typical ways to handle exceptions at the controller level and at the servlet container level. For additional resources on Spring MVC error handling, you can refer to the blog post at <a class="ulink" href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a>.</p><p>Our application is looking pretty good already and yet the amount of code we had to write is very reasonable.</p><p>Stay tuned for the next chapter where we will see that Spring MVC is also a powerful framework to build REST applications.</p></div></body></html>