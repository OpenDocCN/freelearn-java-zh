<html><head></head><body>
		<div>
			<div id="_idContainer267" class="Content">
			</div>
		</div>
		<div id="_idContainer268" class="Content">
			<h1 id="_idParaDest-287"><a id="_idTextAnchor382"/>13. Database Interaction and the Application Layer</h1>
		</div>
		<div id="_idContainer274" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor383"/>Overview</p>
			<p class="callout">In this chapter we will create and connect to an Apache Derby instance on your local machine. We will also create and use a connection pool for efficient database interactions, and create and load a database schema. We will then create, read, update, and delete data using <strong class="source-inline">clojure.java.jdbc</strong>.</p>
			<p class="callout">By the end of this chapter, you will be able to implement an application layer sitting on top of a database instance, ingest data from a CSV file on disk, and write it to the database via an application layer API.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor384"/>Introduction</h1>
			<p>So far, we have been interacting with <strong class="bold">Comma-Separated Values</strong> (<strong class="bold">CSV</strong>) files from disk and in memory with no persistence. Each time we restart our REPL, we lose all the data manipulation or ELO calculations we've made up to that point and must restart from scratch.  If there were a means of persisting this state each time, we could begin where we left off last time. Indeed, we could imagine building an ELO calculation application with a web interface or even a ClojureScript frontend once we've established a means of persistent storage so that our progress is maintained from session to session.</p>
			<p>When considering persistence, most applications will reach for a relational database implementation (for example, MySQL, Oracle, or PostgreSQL). There are many implementations to choose from, each with their own strengths and weaknesses.</p>
			<p>We'll use Apache Derby as an on-disk <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>). It is implemented entirely in Java, meaning there is minimal setup required for our use case, giving us more time to focus on the topics of data modeling, persistence, and retrieval. The function of the RDBMS is to manage the storage of our data across our user-defined tables, allowing queries to be executed across them. It is relational as it supports relations across these tables. For example, a driver owning one or more cars could be represented as a <strong class="source-inline">Driver</strong> table and a <strong class="source-inline">Car</strong> table, with a reference linking them. We'll cover the means of describing this relation in the <em class="italic">Creating Database Schemas</em> section later.</p>
			<p>Going into a little more detail about our potential ELO calculation application, there are numerous topics to consider when it comes to persistence. We'll need to determine what data we want to store, and then determine the model that best describes that data and any relations between different parts of the model. There are constraints we'll have to consider; for example, how will we uniquely identify the entities we're persisting? This will be codified in our database schema using the <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>).</p>
			<p>With a schema defined, we need a means of inserting, retrieving, updating, and deleting data. Since Apache Derby is a <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>)-based RDBMS, this is the most appropriate means of interacting with the database for these purposes. We'll construct SQL commands that cover each of the preceding requirements. These commands will understand the underlying data model, how the relations are constructed, and how to access the relevant parts of the model we're interested in. Apache Derby will execute the SQL commands for us and return the result.</p>
			<p>In terms of interacting with this database from Clojure, we'll primarily use <strong class="source-inline">clojure.java.jdbc</strong>, which is a longstanding, stable, low-level library for talking to databases using <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>).</p>
			<p>It should be noted that the maintainers of this library have created a successor, <strong class="source-inline">next.jdbc</strong>, with a focus on simplicity and performance. An interesting task for you would be to take the examples provided here and rework them to conform to the <strong class="source-inline">next.jdbc</strong> API.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor385"/>Connecting to a Database</h1>
			<p>As alluded to previously, we'll be leveraging JDBC for all our database interactions. JDBC allows a Java client to connect to an RDBMS using a well-defined <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). This API gives us a clear contract between ourselves (the client) and our database (the server). Since Clojure sits atop the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), JDBC is the natural choice for us.</p>
			<p>For those familiar with JDBC, you'll have encountered the (occasionally unwieldy) JDBC URL. These URLs vary depending on the RDBMS, where the database is located, and how it is secured, among other things. In essence, they are a database connection descriptor.</p>
			<p>Fortunately, <strong class="source-inline">clojure.java.jdbc</strong> abstracts this away with its concept of <strong class="source-inline">db-spec</strong> (a database specification). <strong class="source-inline">db-spec</strong> is a simple map structure holding details pertinent to the connection we're looking to make. This <strong class="source-inline">db-spec</strong> structure can then be passed to any <strong class="source-inline">clojure.java.jdbc</strong> API call and it will build the connection for us behind the scenes. This specification is fairly broad and can take many different forms. We'll touch on a few as we progress.</p>
			<p>An important point to note is that <strong class="source-inline">clojure.java.jdbc</strong> expects the driver of your target database to be available on the classpath prior to making an API call. The driver acts as a means of converting your JDBC-based API calls into something your RDBMS understands.  Each RDBMS will, therefore, have its own specific driver. Without this, any database operations will throw an exception.</p>
			<p>For example, if we were to define a <strong class="source-inline">deps.edn</strong> with only the <strong class="source-inline">clojure.java.jdbc</strong> dependency, and then attempt a <strong class="source-inline">jdbc/query</strong> operation, this would be the result:</p>
			<p class="source-code">{:deps {org.clojure/java.jdbc {:mvn/version "0.7.9"}}}</p>
			<p class="source-code">(require '[clojure.java.jdbc :as jdbc])</p>
			<p>Here, we encounter our first concrete <strong class="source-inline">db-spec</strong> definition. This is the <strong class="source-inline">DriverManager</strong> form of <strong class="source-inline">db-spec</strong> and is the preferred format for <strong class="source-inline">clojure.java.jdbc</strong>:</p>
			<p class="source-code">(def db {:dbtype "derby" ;; the type of RDBMS</p>
			<p class="source-code">         :dbname "derby-local" ;; the DB as it will be stored on disk</p>
			<p class="source-code">         :create true       ;; essential on first interaction</p>
			<p class="source-code">         })</p>
			<p>Breaking down our <strong class="source-inline">db-spec</strong> definition, we're interacting with an Apache Derby database (this is the driver we're looking for). We're naming our database <strong class="source-inline">derby-local</strong> in the current working directory. The <strong class="source-inline">:create true</strong> flag will create the database file if it does not already exist:</p>
			<p class="source-code">user=&gt; (jdbc/get-connection db)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B14502_13_01.jpg" alt="Figure 13.1: Error due to no driver being added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1: Error due to no driver being added</p>
			<p>Encountering this is generally an indication that you have not added the driver to your <strong class="source-inline">deps.edn</strong> file or equivalent.</p>
			<p>The <em class="italic">Releases and Dependencies</em> section of the <strong class="source-inline">clojure.java.jdbc</strong> GitHub page contains links to drivers for popular RDBMSes. Once the appropriate driver version has been located, add it to your <strong class="source-inline">deps.edn</strong> file. Consider the following example:</p>
			<p class="source-code">{:deps {org.apache.derby/derby {:mvn/version "10.14.2.0"}}</p>
			<p>As you can see, Apache Derby provides a package containing its database implementation alongside an embedded driver, meaning we don't need an explicit driver dependency in our project.</p>
			<h2 id="_idParaDest-290">E<a id="_idTextAnchor386"/>xercise 13.01: Establishing a Database Connection</h2>
			<p>In this exercise, we will connect to a local on-disk database:</p>
			<ol>
				<li>We'll begin by setting up our dependencies. Create a file named <strong class="source-inline">deps.edn</strong> in your current working directory and paste in the following content:<p class="source-code">{:deps</p><p class="source-code"> {org.apache.derby/derby {:mvn/version "10.14.2.0"}</p><p class="source-code">  org.clojure/java.jdbc {:mvn/version "0.7.9"}}}</p><p>It should be noted, at the time of writing, that Apache Derby version 10.15.1.3 is available. This should <em class="italic">not</em> be used with <strong class="source-inline">clojure.java.jdbc</strong> <strong class="source-inline">0.7.9</strong>! The maintainer of <strong class="source-inline">clojure.java.jdbc</strong> advises that it is untested against 10.15.x.</p></li>
				<li>Require <strong class="source-inline">clojure.java.jdbc</strong> and alias (a temporary name) it as <strong class="source-inline">jdbc</strong> for convenience:<p class="source-code">user=&gt; (require '[clojure.java.jdbc :as jdbc])</p><p class="source-code">nil</p></li>
				<li>Here, we use the <strong class="source-inline">db-spec</strong> definition from the preceding introduction. Introduce a concrete instance of a <strong class="source-inline">db-spec</strong> definition:<p class="source-code">user=&gt; (def db {:dbtype "derby" </p><p class="source-code">                :dbname "derby-local" </p><p class="source-code">                :create true})</p><p class="source-code">=&gt; #'user/db</p></li>
				<li>Test that we can obtain a connection to this database:<p class="source-code">user=&gt; (jdbc/get-connection db)</p><p>The output is as follows:</p><div id="_idContainer270" class="IMG---Figure"><img src="image/B14502_13_02.jpg" alt="Figure 13.2: Obtaining a connection to the database&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.2: Obtaining a connection to the database</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding output is the <strong class="source-inline">toString</strong> representation of our connection. The content is of no real consequence as we are not concerned with the internal representation of the connection object.</p>
			<p>Great! We have a means of creating an Apache Derby instance on disk and have established a connection successfully. This <strong class="source-inline">db-spec</strong> definition is, therefore, valid and can be used anywhere the <strong class="source-inline">db-spec</strong> definition is accepted.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Any time we wish to remove our local database and start over, we can do so by removing the directory matching our database name in our current working directory.</p>
			<h1 id="_idParaDest-291">In<a id="_idTextAnchor387"/>troduction to Connection Pools</h1>
			<p>Although it's convenient for <strong class="source-inline">clojure.java.jdbc</strong> to create our database connections for us (it does this on each API call when we pass it a <strong class="source-inline">db-spec</strong> definition), there is a resulting performance overhead we should be aware of. This can become burdensome as establishing a connection (particularly to a remote machine) can often take many times longer than our query will actually take to execute! This is, therefore, an expensive operation that we'd like to avoid. Connection pooling is one such way of avoiding this overhead.</p>
			<p>When we talk of a connection pool, we're essentially talking about establishing one or more connections ahead of time and making them available to our application anytime a database connection is required. In this way, we deal with the connection overhead once on application startup and benefit from connection reuse from that point onward. </p>
			<p><strong class="source-inline">clojure.java.jdbc</strong> does not itself offer a connection pooling implementation, but it does integrate well with a number of pooling libraries, including <strong class="source-inline">c3p0</strong> and <strong class="source-inline">hikari-cp</strong>. We'll focus on <strong class="source-inline">hikari-cp</strong> as it is a Clojure wrapper for the lightning-quick <strong class="source-inline">hikariCP</strong> connection with a super-simple API.</p>
			<p><strong class="source-inline">hikari-cp</strong> provides an API that allows us to construct a connection-pooled data source; we can use this to construct an alternative <strong class="source-inline">db-spec</strong> definition to use in place of our <strong class="source-inline">DriverManager</strong> based <strong class="source-inline">db-spec</strong> with no other changes required. <strong class="source-inline">hikari-cp</strong> will manage the pool of connections for us.</p>
			<h2 id="_idParaDest-292">Ex<a id="_idTextAnchor388"/>ercise 13.02: Creating a Connection Pool</h2>
			<p>In this exercise, we will create an alternative <strong class="source-inline">db-spec</strong>  definition that can be used in place of the one created in <em class="italic">Step 3</em> of <em class="italic">Exercise 13.01</em>, <em class="italic">Establishing a Database Connection</em>. The benefit will be an increase in the speed of database interactions since a connection does not need to be established afresh for each interaction:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">hikari-cp</strong> dependency into our application:<p class="source-code">{:deps</p><p class="source-code"> {hikari-cp {:mvn/version "2.8.0"}</p><p class="source-code">  org.apache.derby/derby {:mvn/version "10.14.2.0"}</p><p class="source-code">  org.clojure/java.jdbc {:mvn/version "0.7.9"}}}</p></li>
				<li>Now, depending on our precise needs, we have a few different means of constructing a valid data source. When we are starting from scratch and are expected to create the database as well as establish a connection, then we will need to reach for the appropriate JDBC URL. The Apache Derby URLs are less troublesome than others to construct and follow this simple syntax:<p class="source-code">jdbc:derby:[subprotocol:][databaseName][;attribute=value]</p><p class="callout-heading">Note</p><p class="callout">More details on Derby JDBC database connection URL can be found at <a href="https://packt.live/2Fnnx9f">https://packt.live/2Fnnx9f</a>.</p></li>
				<li>Given this, we can define our <strong class="source-inline">db-spec</strong> definition (using the <strong class="source-inline">datasource</strong> format) like so:<p class="source-code">user=&gt; (require '[clojure.java.jdbc :as jdbc]</p><p class="source-code">                '[hikari-cp.core :as hikari])</p><p class="source-code">nil</p><p class="source-code">user=&gt; (def db {:datasource (hikari/make-datasource {:jdbc-url "jdbc:derby:derby-local;create=true"})})</p><p class="source-code">=&gt; #'user/db</p><p>To break this down, we're connecting to an Apache Derby instance where the database is named <strong class="source-inline">derby-local</strong>. You will recall that <strong class="source-inline">create=true</strong> instructs the database to be created if not already present.</p></li>
				<li>Alternatively, if we know the database already exists, then the <strong class="source-inline">create=true</strong> flag will not be required. We could amend the JDBC URL or allow <strong class="source-inline">hikari-cp</strong> to build it for us: <p class="source-code">(def db {:datasource </p><p class="source-code">  (hikari/make-datasource {:database-name "derby-local" </p><p class="source-code">                           :datasource-class-name "org.apache.derby.jdbc.EmbeddedDataSource"})})</p><p>Note that, here, we are required to specify the <strong class="source-inline">datasource-class-name</strong>, which, in this case, is the embedded version, since we're running locally.</p></li>
				<li>Regardless of the means we've used to construct our data source, we can pass this to the <strong class="source-inline">clojure.java.jdbc</strong> library as an alternative <strong class="source-inline">db-spec</strong> definition:<p class="source-code">(jdbc/get-connection db)</p><p>The output is as follows:</p><div id="_idContainer271" class="IMG---Figure"><img src="image/B14502_13_03.jpg" alt="Figure 13.3: Printing the output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.3: Printing the output</p>
			<p>We've now defined and tested two different <strong class="source-inline">db-spec</strong> formats successfully, demonstrating the flexibility offered by <strong class="source-inline">clojure.java.jdbc</strong>. It should be noted that a considerable number of alternatives are also acceptable, including <strong class="source-inline">:connection-uri</strong> (a JDBC URL) and <strong class="source-inline">:connection</strong> (an already established connection, rarely required).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to http://clojure.github.io/java.jdbc/#clojure.java.jdbc/get-connection for full details of the supported <strong class="source-inline">db-spec</strong> definition.</p>
			<p>To summarize, <strong class="source-inline">clojure.java.jdbc</strong> is flexible in what it consumes. Therefore, we'll be working with a connection-pooled data source as we start to interact more seriously with our newly created database.</p>
			<h2 id="_idParaDest-293">Cre<a id="_idTextAnchor389"/>ating Database Schemas</h2>
			<p>We have our database connection. Before we begin to persist and query data, we must define our database model, or "schema" as it is more commonly known. This will take the form of the following:</p>
			<ul>
				<li>Tables</li>
				<li>Fields/columns within tables</li>
				<li>Relationships across tables</li>
			</ul>
			<p>Let's consider the example of a sports activity tracker, which our tennis superstars might use in their spare time. We'd like to store application users and activities. Let's look at how we could model those using two tables.</p>
			<p>The <strong class="source-inline">app_user</strong> table will store the first name, surname, height, and weight. The activity table will store the date, activity type, distance, and duration.</p>
			<h2 id="_idParaDest-294">Pri<a id="_idTextAnchor390"/>mary Keys</h2>
			<p>It's important to note that there is nothing unique in the information we're storing. How would we correctly load a user's height and weight when we only have their name to query on? For example, multiple users could be created with the same name, and then we'd run into issues regarding correct ownership of activities.</p>
			<p>We need to introduce <strong class="bold">primary keys</strong> to each of our tables. These are unique to each row and could be constructed and added to our <strong class="source-inline">insert</strong> statements; however, it is useful to leverage a feature of Apache Derby where it can allocate a unique ID on our behalf, and then communicate that back to us on insertion.</p>
			<p>Adding <strong class="source-inline">GENERATED ALWAYS AS IDENTITY</strong> to a column definition will instruct Apache Derby to auto-allocate a monotonically increasing integer ID on the insertion of each new row in our table. This removes any overhead we might have in constructing one and guarantees its uniqueness.</p>
			<h2 id="_idParaDest-295">For<a id="_idTextAnchor391"/>eign Keys</h2>
			<p>When considering an activity, we can observe that one cannot exist without the prior existence of an <strong class="source-inline">app_user</strong>; that is, an activity must reference an existing entry in the <strong class="source-inline">app_user</strong> table. This is where the concept of a <strong class="bold">foreign key</strong> comes in.</p>
			<p>A foreign key is a means of creating a relationship between a parent table and a child table. We can define a foreign key in our activity table, which references the primary key of our <strong class="source-inline">app_user</strong> table. When we create an activity, we must have the primary key of the <strong class="source-inline">app_user</strong> table available to us such that we can add it to our activity. With this linkage/relationship in place, we can then construct a query for all activities belonging to a user, for example.</p>
			<p>The definition of a simple foreign key would look like this:</p>
			<p class="source-code">&lt;foreign key field name&gt; &lt;foreign key type&gt; REFERENCES &lt;parent table&gt;</p>
			<p>Additionally, we generally add <strong class="source-inline">ON DELETE CASCADE</strong> to this definition, indicating that entries in the child table should be deleted when the corresponding entries are deleted from the parent table. This is important if the entry in the activity table cannot exist as a standalone entity; that is, it only makes sense in the context of its association with an <strong class="source-inline">app_user</strong>.</p>
			<h2 id="_idParaDest-296">Exe<a id="_idTextAnchor392"/>rcise 13.03: Defining and Applying a Database Schema</h2>
			<p>Given our table requirements mentioned previously, we'll now codify those using DDL (that is, the actual SQL commands we'll use to create these structures):</p>
			<ol>
				<li value="1">Representing this in DDL, we will have something like this:<p class="source-code">(def create-app-user-ddl "CREATE TABLE app_user (</p><p class="source-code">id INT GENERATED ALWAYS AS IDENTITY CONSTRAINT USER_ID_PK PRIMARY KEY,</p><p class="source-code">first_name VARCHAR(32),</p><p class="source-code">surname VARCHAR(32),</p><p class="source-code">height SMALLINT,</p><p class="source-code">weight SMALLINT)")</p><p class="source-code">=&gt; #'user/create-app-user-ddl</p><p class="source-code">(def create-activity-ddl "CREATE TABLE activity (</p><p class="source-code">  id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,</p><p class="source-code">  activity_type VARCHAR(32),</p><p class="source-code">  distance DECIMAL(5,2),</p><p class="source-code">  duration INT,</p><p class="source-code">  user_id INT REFERENCES app_user ON DELETE CASCADE)")</p><p class="source-code">#'user/create-activity-ddl</p><p class="callout-heading">Note</p><p class="callout">Each of our preceding symbols is suffixed with <strong class="source-inline">-ddl</strong>. This is the syntax that's typically used for describing database schemas.</p></li>
				<li><strong class="source-inline">clojure.java.jdbc</strong> provides a helper function of sorts that can construct a DDL statement for us. Although, the only real benefits for our use case are the ability to switch the format of the entities (table names, column names, and types) as well as the usage of keywords in place of parts of the manually constructed string. The equivalent function execution that would generate the <strong class="source-inline">create-app-user-ddl</strong> is as follows:<p class="source-code">(def create-app-user-ddl-2 (jdbc/create-table-ddl :app_user</p><p class="source-code">  [[:id :int "GENERATED ALWAYS AS IDENTITY CONSTRAINT USER_ID_PK PRIMARY KEY"]</p><p class="source-code">  [:first_name "varchar(32)"]</p><p class="source-code">  [:surname "varchar(32)"]</p><p class="source-code">  [:height :smallint]</p><p class="source-code">  [:weight :smallint]]</p><p class="source-code">  {:entities clojure.string/lower-case}))</p></li>
				<li>Looking at the <strong class="source-inline">clojure.java.jdbc</strong> API, we may intuitively expect that we can execute these DDL statements using the <strong class="source-inline">jdbc/execute!</strong> function. We can (this approach will work for the creation of single tables), however, if we wish to create more than one table, make use of <strong class="source-inline">db-do-commands</strong>, which accepts one or more command statements to be executed within a transaction:<p class="source-code">user=&gt; (jdbc/db-do-commands db [create-app-user-ddl create-activity-ddl])</p><p class="source-code">=&gt; (0 0)</p><p class="callout-heading">Note </p><p class="callout">Rerunning the preceding command results in an error indicating the table already exists.</p><p>The output is as follows:</p><div id="_idContainer272" class="IMG---Figure"><img src="image/B14502_13_04.jpg" alt="Figure 13.4: The execution error&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.4: The execution error</p>
			<p>It should be noted that, in general, using <strong class="source-inline">CREATE TABLE IF NOT EXISTS</strong> is sufficient to avoid this. However, Apache Derby does not support this syntax. Avoidance of this error would involve writing custom code to do the following:</p>
			<ul>
				<li>Attempt a <strong class="source-inline">SELECT</strong> statement from said table and detect a <strong class="source-inline">table does not exist</strong> error before performing the creation of the table.</li>
				<li>Attempt the creation and gracefully handle the <strong class="source-inline">table already exists</strong> error message.</li>
				<li>Leverage a migration library such as <strong class="source-inline">Migratus</strong> to keep track of the schema updates that we've applied up to this point, and automatically apply new changes as we introduce them.</li>
			</ul>
			<p>In summary, we now have the ability to define our database schema using DDL and can apply this schema to our database, ready for data ingestion.</p>
			<h2 id="_idParaDest-297">Mana<a id="_idTextAnchor393"/>ging Our Data</h2>
			<p>When dealing with persistent storage, and services that interact with them, we usually encounter the term <strong class="bold">CRUD</strong>, which stands for <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong>. These are the four primary operations we can expect to perform against our database. <strong class="source-inline">clojure.java.jdbc</strong> exposes an API that directly maps to each of those operations, as we'd expect any good database library to do.</p>
			<p>The following commands describe each of the CRUD operations and the appropriate API call to use in <strong class="source-inline">clojure.java.jdbc</strong>. Note that the tables, columns, and values are arbitrary and only serve to show the format of the call.</p>
			<p>For creating an entry in the <strong class="source-inline">example</strong> table, we will set <strong class="source-inline">col1</strong> to the numeric value <strong class="source-inline">42</strong> and <strong class="source-inline">col2</strong> to the string value <strong class="source-inline">"123"</strong>:</p>
			<p class="source-code">(jdbc/insert! db-spec :example {:col1 42 :col2 "123"})</p>
			<p>We can read or extract an entry from the example table where the <strong class="source-inline">id</strong> value of the row is <strong class="source-inline">13</strong>:</p>
			<p class="source-code">(jdbc/query   db-spec ["SELECT * FROM example WHERE id = ?" 13])</p>
			<p>To update the row with an ID of 13, we will set <strong class="source-inline">col1</strong> to the numeric value <strong class="source-inline">77</strong> and <strong class="source-inline">col2</strong> to the string value <strong class="source-inline">"456"</strong>:</p>
			<p class="source-code">(jdbc/update! db-spec :example {:col1 77 :col2 "456"} ["id = ?" 13])</p>
			<p>Delete or remove an entry from the example table with ID <strong class="source-inline">13</strong>:</p>
			<p class="source-code">(jdbc/delete! db-spec :example ["id = ?" 13])</p>
			<p>It should be noted that these functions have multiple arities, where the optional last argument is a map of SQL options. We'll cover these options as we are introduced to each function in turn.</p>
			<p>Also of note is the <strong class="source-inline">!</strong> suffix on three of the API calls. This is conventionally (but not always!) used to indicate that the function itself will perform a side effect. In the functional programming world, this can be deemed important enough to draw extra attention to.</p>
			<p>Inserting, updating, and deleting will indeed result in a side effect – that of changing the persistent storage in some way. A query, by contrast, is a simple read function and will have no effect besides data retrieval.</p>
			<h2 id="_idParaDest-298">Inse<a id="_idTextAnchor394"/>rting Data</h2>
			<p>We'll cover the <strong class="bold">C</strong> in <strong class="bold">CRUD</strong> first. Indeed, we can't do anything exciting with our database until it's populated with some data.</p>
			<p>Recall our two database tables, <strong class="source-inline">app_user</strong> and <strong class="source-inline">activity</strong>, and the relationship between them. Our foreign key reference stipulates that an activity cannot exist without the prior existence of an <strong class="source-inline">app_user</strong>. The creation of an activity must, therefore, reference an entity in the <strong class="source-inline">app_user</strong>.</p>
			<h2 id="_idParaDest-299">Inse<a id="_idTextAnchor395"/>rting Single Rows</h2>
			<p><strong class="source-inline">jdbc/insert!</strong> operates in two modes, accepting either a map of column-value pairs or accepting a vector of columns and a vector of values. Let's explore the differences between both modes.</p>
			<p>Firstly, using map mode, the structure of our <strong class="source-inline">insert</strong> command and the associated return value will be:</p>
			<p class="source-code">user=&gt; (jdbc/insert!</p>
			<p class="source-code">         &lt;db-spec&gt;</p>
			<p class="source-code">         table name keyword&gt;</p>
			<p class="source-code">         {&lt;column_name&gt; &lt;column_value&gt;</p>
			<p class="source-code">          ..})</p>
			<p class="source-code">({:1 1M})</p>
			<p>The equivalent in vector mode is as follows:</p>
			<p class="source-code">user=&gt; (jdbc/insert! </p>
			<p class="source-code">         &lt;db-spec&gt;</p>
			<p class="source-code">         &lt;table name keyword&gt;</p>
			<p class="source-code">         [&lt;column name&gt; ..] </p>
			<p class="source-code">         [&lt;column value&gt; ..])</p>
			<p class="source-code">(1)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is possible to omit the vector describing the column names. This would require us to insert values using the column order of the table as it was created. However, it is not possible to do this with Apache Derby when one or more of the columns is autogenerated.</p>
			<p>Although entirely equivalent in terms of the rows created in the database, you'll notice the return values differ.</p>
			<p>In the first case, we are returned a single-element sequence containing a map. The value associated with the <strong class="source-inline">:1</strong> key is the ID that's been generated and persisted along with the row that we've just inserted. That's handy; we can use that when persisting any further rows in tables that require this as a foreign key. Without the automatic return of the generated ID, we'd need to submit a separate query to the database to retrieve it.</p>
			<p>In the second case, we again get a single-element sequence – this time containing an integer. It may be tempting to assume that the integer corresponds to a generated ID; this would be incorrect – the integer instead tells us the number of rows affected. <strong class="source-inline">jdbc/insert!</strong> only supports the insertion of a single row; this integer will always be 1 and is, therefore, of little use.</p>
			<p>A few important points should be noted here. The "generated ID" or "generated key" format is RDBMS-specific. If we were to swap in MySQL instead, we'd find our return value would be of the following form:</p>
			<p class="source-code">({:generated_key 1})</p>
			<p>We should, therefore, be careful about how we process these return values and be cognizant that a change of database could result in broken code.</p>
			<p>The <strong class="source-inline">({:1 1M})</strong> return value looks a little curious. Keywordized integers are perfectly valid – they're just not encountered particularly often. Apache Derby obviously has no concept of Clojure keywords; <strong class="source-inline">clojure.java.jdbc</strong> is (helpfully) keywordizing our return keys by default.</p>
			<p>This segues nicely into some of the options we can pass to any of the CRUD API calls, namely:</p>
			<ul>
				<li><strong class="source-inline">keywordize?</strong> (Boolean, defaults to <strong class="source-inline">true</strong>)</li>
				<li>identifiers (function, defaults to <strong class="source-inline">identity</strong>)</li>
			</ul>
			<p>If we are happy to receive our keys as is, then we can switch keywordization off:</p>
			<p class="source-code">user=&gt; (jdbc/insert! db :app_user {:first_name "Andre" :surname "Agassi" :height 180 :weight 80} {:keywordize? false})</p>
			<p class="source-code">({"1" 1M})</p>
			<h2 id="_idParaDest-300">Inse<a id="_idTextAnchor396"/>rting Multiple Rows</h2>
			<p><strong class="source-inline">insert-multi!</strong> (like <strong class="source-inline">insert!</strong>) works in two different modes. It accepts a collection of maps or a collection of vectors. The overall result of calling either is identical, but there are key differences that you need to be aware of.</p>
			<p>We've already covered the "generated ID" (when working with maps) versus "rows affected" (when working with vectors) return values. This also holds true when working with <strong class="source-inline">insert-multi!</strong>.</p>
			<p>In addition, we should be aware that doing multiple inserts in vector mode will execute the inserts in batched transactions. This is more performant when doing a large number of inserts.</p>
			<p>The following code demonstrates <strong class="source-inline">insert-multi!</strong> in map and vector mode:</p>
			<p class="source-code">user=&gt; (jdbc/insert-multi!</p>
			<p class="source-code">  &lt;db-spec&gt;</p>
			<p class="source-code">  &lt;table name keyword&gt;</p>
			<p class="source-code">  [{&lt;column name&gt; &lt;column value&gt; ..}</p>
			<p class="source-code">   {&lt;column name&gt; &lt;column value&gt; ..}])</p>
			<p class="source-code">({:1 1M} {:1 2M})</p>
			<p class="source-code">(jdbc/insert-multi!</p>
			<p class="source-code">  &lt;db-spec&gt;</p>
			<p class="source-code">  &lt;table name keyword&gt;</p>
			<p class="source-code">  [&lt;column name&gt; ..] </p>
			<p class="source-code">  [[&lt;column value&gt; ..] [&lt;column value&gt; ..]])</p>
			<p class="source-code">=&gt; (1 1)</p>
			<p>Again, note the return values indicating that we've allocated IDs <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong> to the inserted rows.</p>
			<p>We can insert partial records using either map or vector mode. When working with map mode, we simply omit any unwanted key-value pairs. In vector mode, we must specify the column names, and then insert nil values as required.</p>
			<h2 id="_idParaDest-301">Exer<a id="_idTextAnchor397"/>cise 13.04: Data Insertion</h2>
			<p>Let's begin by creating entries in each of the tables we've defined, ensuring we respect the foreign key constraint:</p>
			<ol>
				<li value="1">Inserting our favorite tennis player of the 1990s as an <strong class="source-inline">app_user</strong> can be achieved with either of the following function calls. We recommend choosing one of these to avoid spurious duplicates in our data:<p class="source-code">user=&gt; (jdbc/insert!</p><p class="source-code">         db</p><p class="source-code">         :app_user</p><p class="source-code">         {:first_name "Andre"</p><p class="source-code">          :surname    "Agassi"</p><p class="source-code">          :height     180</p><p class="source-code">          :weight     80})</p><p class="source-code">({:1 1M})</p><p class="source-code">user=&gt; (jdbc/insert! </p><p class="source-code">         db</p><p class="source-code">         :app_user </p><p class="source-code">         [:first_name :surname :height :weight] </p><p class="source-code">         ["Andre" "Agassi" 180 80])</p><p class="source-code">(1)</p><p class="callout-heading">Note</p><p class="callout">When considering the existing state of the database, the <strong class="source-inline">1M</strong> value for our generated key can differ since it represents the next unique integer value.</p></li>
				<li>We've inserted our first record successfully. Let's now create several activities and associate them with our <strong class="source-inline">app_user</strong>, Andre. This will allow us to exercise the <strong class="source-inline">jdbc/insert-multi!</strong> API call:<p class="source-code">user=&gt; (jdbc/insert-multi!</p><p class="source-code">  db</p><p class="source-code">  :activity</p><p class="source-code">  [{:activity_type "run" :distance 8.67 :duration 2520 :user_id 1}</p><p class="source-code">   {:activity_type "cycle" :distance 17.68 :duration 2703 :user_id 1}])</p><p class="source-code">({:1 1M} {:1 2M})</p></li>
			</ol>
			<p>When<a id="_idTextAnchor398"/> inserting data, there are several considerations to keep in mind. If inserting a single row, use <strong class="source-inline">insert!</strong>. If inserting multiple rows, use <strong class="source-inline">insert-multi!</strong>. If we are interested in the generated keys, then we should favor map insertion mode. If, on the other hand, performance is critical, we may favor vector insertion mode. When inserting a mixture of full and partial rows, then the reader may use their personal preference of map versus vector mode.</p>
			<h2 id="_idParaDest-302">Quer<a id="_idTextAnchor399"/>ying Data</h2>
			<p>In order to view what we've persisted in our database thus far, we'll consider the <strong class="bold">R</strong> in <strong class="bold">CRUD</strong>. Reading, or querying, data is very simple. At its most basic, we just need our <strong class="source-inline">db-spec</strong> definition along with a vector containing a SQL string.</p>
			<h2 id="_idParaDest-303">Exer<a id="_idTextAnchor400"/>cise 13.05: Querying Our Database</h2>
			<p>Here, we'll cover the variety of options that we have available to us when querying the data we inserted as part of the prior exercise:</p>
			<ol>
				<li value="1">To find what we have in our <strong class="source-inline">app_user</strong> and activity tables, the following will suffice:<p class="source-code">user=&gt; (jdbc/query db ["select * from app_user"])</p><p class="source-code">({:id 1, :first_name "Andre", :surname "Agassi", :height 180, :weight 80})</p><p class="source-code">user=&gt; (jdbc/query db ["select * from activity"])</p><p class="source-code">({:id 1, :activity_type "run", :distance 8.67M, :duration 2520, :user_id 1} </p><p class="source-code"> {:id 2, :activity_type "cycle", :distance 17.68M, :duration 2703, :user_id 1})</p><p>As alluded to in the <em class="italic">Managing Our Data</em> introduction, there is a 3-arity definition of <strong class="source-inline">jdbc/query</strong>, accepting a map of options. Since we have not provided that (we used the 2-arity version here) we have accepted all the default options. We'll now explore those options and how they can be used to manipulate the result set.</p><p>Consider the preceding return values. We're returned a sequence of maps by default, where the keys are lowercase keywords.</p><p>Of the options that are supported, the first three we'll cover are trivial and allow us to control the format of the keys returned are <strong class="source-inline">keywordize?</strong>, <strong class="source-inline">identifiers</strong>, and <strong class="source-inline">qualifier</strong>.</p></li>
				<li>Setting <strong class="source-inline">keywordize?</strong> to <strong class="source-inline">false</strong> gives us string keys. Identifiers can be overridden by providing a single-arity function that converts the key to our chosen format. For example, retrieving data where the keys are uppercase strings can be achieved using these options (and <strong class="source-inline">clojure.string</strong>):<p class="source-code">{:keywordize? false :identifiers str/upper-case}</p><p class="source-code">user=&gt; (require '[clojure.string :as str])</p><p class="source-code">=&gt; nil</p><p class="source-code">user=&gt; (jdbc/query db ["select * from app_user"] {:keywordize? false :identifiers str/upper-case})</p><p class="source-code">({"ID" 1, "FIRST_NAME" "Andre", "SURNAME" "Agassi", "HEIGHT" 180, "WEIGHT" 80})</p><p><strong class="source-inline">qualifier</strong> only works when <strong class="source-inline">keywordize?</strong> is true (the default) and allows us to specify a namespace for our keywords. Our keys are then returned in the form:</p><p class="source-code">:&lt;qualifier&gt;/&lt;column name&gt;</p><p class="source-code">user=&gt; (jdbc/query db ["select * from app_user"] {:identifiers str/upper-case :qualifier "app_user"})</p><p class="source-code">(#:app_user{:ID 1, :FIRST_NAME "Andre", :SURNAME "Agassi", :HEIGHT 180, :WEIGHT 80})</p></li>
				<li>For those not familiar with the preceding format, this indicates that we have a map where our keyword namespace is homogenous (every key has the same <strong class="source-inline">app_user</strong> namespace). More explicitly, we can see the individual keys from that query:<p class="source-code">user=&gt; (-&gt; (jdbc/query db ["select * from app_user"] {:identifiers str/upper-case :qualifier "app_user"})</p><p class="source-code">    first</p><p class="source-code">    keys)</p><p class="source-code">=&gt; (:app_user/ID :app_user/FIRST_NAME :app_user/SURNAME :app_user/HEIGHT :app_user/WEIGHT)</p></li>
				<li>In the same way, we can insert data using (sequences of) maps or (sequences of) vectors. We can control the maps versus vectors result format in our queries as well. In the preceding code, we see maps as the default and can alter this by passing the following options map:<p class="source-code">{:as-arrays? true}</p><p>The output is as follows:</p><p class="source-code">user=&gt; (jdbc/query db ["select * from activity"] {:as-arrays? true})</p><p class="source-code">[[:id :activity_type :distance :duration :user_id] </p><p class="source-code"> [1 "run" 8.67M 2520 1] </p><p class="source-code"> [2 "cycle" 17.68M 2703 1]]</p></li>
			</ol>
			<p>Thinking back to the chapter where we first interacted with CSV files, you may recognize this as the same data structure used for reading from or writing to a CSV file; that is, a sequence of vectors where the first vector corresponds to the columns of the file and subsequent vectors are the data entries of the file.</p>
			<h2 id="_idParaDest-304">Mani<a id="_idTextAnchor401"/>pulating Query Return Values</h2>
			<p>Besides manipulating the format of the return values, there are two additional options that give us complete control over each individual row returned by the query, or over the result set as a whole. We provide these using the <strong class="source-inline">:row-fn</strong> or <strong class="source-inline">:result-set-fn</strong> options; these <em class="italic">can</em> be combined if required.</p>
			<p>The <strong class="source-inline">row-fn</strong> option should be a single-arity function, where the sole argument is a map representation of the current row. Similarly, the <strong class="source-inline">result-set-fn</strong> option should be a single-arity function where the sole argument is a sequence of maps representing the entirety of the query result. Consider the following example.</p>
			<p class="source-code">(defn custom-row-fn [row]</p>
			<p class="source-code">)</p>
			<p class="source-code">(defn custom-result-set-fn [result-set]</p>
			<p class="source-code">)</p>
			<p>There are no constraints in what our functions can do, besides returning a value in the same data structure we received as input.</p>
			<p>It should be noted that the <strong class="source-inline">result-set-fn</strong> option you pass should <em class="italic">not</em> be lazy; otherwise, the connection could be closed before the function completes. <strong class="source-inline">reduce</strong> (or a function that calls <strong class="source-inline">reduce</strong> under the hood) is a good choice here.</p>
			<h2 id="_idParaDest-305">Exer<a id="_idTextAnchor402"/>cise 13.06: Controlling Results with Custom Functions</h2>
			<p>Examples, where the <strong class="source-inline">row-fn</strong> would be applicable, include performing some calculation or aggregation that would be clumsy to achieve in raw SQL, formatting values, and enriching each row with computed values.</p>
			<p>Combining all three of these use cases, let's consider our activity table, specifically the duration column. This is an integer value measuring the number of seconds of the activity in question. For the purposes of display or reporting to a user, we may find it more user-friendly to quote this in hours, minutes, and seconds:</p>
			<ol>
				<li value="1">Defining a <strong class="source-inline">row-fn</strong> where the sole argument is a map representation of a row and that generally speaking the row should be returned, with any manipulation applied:<p class="source-code">(defn add-user-friendly-duration</p><p class="source-code">  [{:keys [duration] :as row}]</p><p class="source-code">  (let [quot-rem (juxt quot rem) </p><p class="source-code">        [hours remainder] (quot-rem duration (* 60 60))</p><p class="source-code">        [minutes seconds] (quot-rem remainder 60)]</p><p class="source-code">    (assoc row :friendly-duration</p><p class="source-code">               (cond-&gt; ""</p><p class="source-code">                       (pos? hours) (str hours "h ")</p><p class="source-code">                       (pos? minutes) (str minutes "m ")</p><p class="source-code">                       (pos? seconds) (str seconds "s")</p><p class="source-code">                       :always str/trim))))</p><p class="source-code">#'user/add-user-friendly-duration</p></li>
				<li>Now adding that to our SQL options map and re-running the activity query from <em class="italic">Exercise 13.05</em>, <em class="italic">Querying Our Database</em>:<p class="source-code">user=&gt; (jdbc/query db ["select * from activity"]</p><p class="source-code">       {:row-fn add-user-friendly-duration})</p><p class="source-code">({:id 1, :activity_type "run", :distance 8.67M, :duration 2520, :user_id 1, :friendly-duration "42m"}</p><p class="source-code"> {:id 2, :activity_type "cycle", :distance 17.68M, :duration 2703, :user_id 1, :friendly-duration "45m 3s"})</p></li>
				<li>Let's now calculate the total distance traveled across all activities in the database. This could trivially be achieved via raw SQL, but nevertheless will give us an opportunity to explore alternatives.<p>We'll define our function as follows:</p><p class="source-code">(fn [result-set]</p><p class="source-code">  (reduce (fn [total-distance {:keys [distance]}]</p><p class="source-code">            (+ total-distance distance))</p><p class="source-code">          0</p><p class="source-code">          result-set))</p></li>
				<li>When used along with our query, we predictably retrieve a single number representing total distance across all activities:<p class="source-code">user=&gt; (jdbc/query db ["select * from activity"]</p><p class="source-code">            {:result-set-fn (fn [result-set]</p><p class="source-code">                              (reduce (fn [total-distance {:keys [distance]}]</p><p class="source-code">                                        (+ total-distance distance))</p><p class="source-code">                                      0</p><p class="source-code">                                      result-set))})</p><p class="source-code">26.35M</p></li>
				<li>To demonstrate how <strong class="source-inline">row-fn</strong> and <strong class="source-inline">result-set-fn</strong> can work together, we could use a <strong class="source-inline">row-fn</strong> to extract the distance, then a much simpler <strong class="source-inline">result-set-fn</strong> to sum those numbers like so:<p class="source-code">(jdbc/query db ["select * from activity"]</p><p class="source-code">            {:row-fn        :distance</p><p class="source-code">             :result-set-fn #(apply + %)})</p><p class="source-code">=&gt; 26.35M</p></li>
			</ol>
			<p>Through these last two exercises, we see <strong class="source-inline">clojure.java.jdbc</strong> gives us complete control over our query results, directly within the API call. Regardless of our requirements, we can leverage the options to the <strong class="source-inline">jdbc/query</strong> function to achieve the result we want, with custom formatting.</p>
			<h2 id="_idParaDest-306">Upda<a id="_idTextAnchor403"/>ting and Deleting Data</h2>
			<p>Finally, we come to the <strong class="bold">U</strong> and <strong class="bold">D</strong> in CRUD; updates and deletes. These are simpler operations than the previous two and can be covered much more concisely.</p>
			<p>When the state of the world we're modeling has changed, we'll want to reflect that in our persisted data. Before we perform our update, we determine the following:</p>
			<ul>
				<li>The table(s) affected</li>
				<li>The new values we wish to set</li>
				<li>The subset of data we want to have those values</li>
			</ul>
			<p>The signature of <strong class="source-inline">jdbc/update!</strong> gives us these pointers if we were not already aware:</p>
			<p class="source-code">(update! db table set-map where-clause opts)</p>
			<h2 id="_idParaDest-307">Exer<a id="_idTextAnchor404"/>cise 13.07: Updating and Removing Existing Data</h2>
			<p>Let's assume we discover that Andre Agassi has lost 2 kg. We can surmise that we'll be updating the <strong class="source-inline">app_user</strong> table, setting the weight to 78 kg where the first name and last names are <strong class="source-inline">Andre</strong> and <strong class="source-inline">Agassi</strong> (or where the ID is <strong class="source-inline">1</strong>; we may have this available to us from earlier queries):</p>
			<ol>
				<li value="1">Construct the <strong class="source-inline">update!</strong> function call as follows:<p class="source-code">user=&gt; (jdbc/update! db :app_user {:weight 78} ["first_name = 'Andre' and surname = 'Agassi'"])</p><p class="source-code">=&gt; (1)</p><p class="callout-heading">Note</p><p class="callout">Updates (and deletes), when successful, will only ever return the number of rows affected.</p></li>
				<li>If we query the <strong class="source-inline">app_user</strong> table, we expect this new fact to be persisted:<p class="source-code">user =&gt; (jdbc/query db ["select * from app_user"])</p><p class="source-code">=&gt; ({:id 1, :first_name "Andre", :surname "Agassi", :height 180, :weight 78})</p></li>
				<li>Now, we could imagine a case where <strong class="source-inline">Agassi</strong> has removed his account from our activity tracking service and requested that his data be deleted. We have a function signature as follows:<p class="source-code">(delete! db table where-clause opts)</p></li>
				<li>We can construct a function call that will remove <strong class="source-inline">Agassi</strong> and all his activities from our database:<p class="source-code">user=&gt; (jdbc/delete! db :app_user ["first_name = 'Andre' and surname = 'Agassi'"])</p><p class="source-code">=&gt; [1]</p><p>Interestingly, the number of rows affected is reported as <strong class="source-inline">1</strong>. Since we set an <strong class="source-inline">ON DELETE CASCADE</strong> option, we expected that all Andre's activities would also be removed. Let's verify that is indeed the case:</p><p class="source-code">user=&gt; (jdbc/query db ["select * from activity"])</p><p class="source-code">=&gt; ()</p></li>
			</ol>
			<p>As w<a id="_idTextAnchor405"/>e can see, Andre's activities have been removed. We can, therefore, conclude that the rows affected will only ever correspond to those removed from the target table.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor406"/>Introduction to the Application Layer</h1>
			<p>Until now, we've been creating ad hoc functions, testing them out at the REPL, occasionally creating a namespace or two that brings them together. We can think of the application layer as bringing all those namespaces and functions together into a working, coherent application with an associated API. In essence, we are designing the backend of our application in this step. We will then learn how to expose that API via REST in the next chapter; it will be useful to bear that in mind as we design our application.</p>
			<p>When designing our application layer, it makes sense to take a step back and ask what our requirements are. If we consider the activity tracking application, we might realistically have the following high-level requirements:</p>
			<ul>
				<li>Create a new user.</li>
				<li>Create an activity for a given user.</li>
				<li>Query users and activities.</li>
				<li>Run reports across individual users (that is, by activity or time period).</li>
			</ul>
			<p>Implementing the preceding requirements would give us a functional (albeit limited) application that users could begin interacting with to track activities and measure their fitness.</p>
			<p>Since we've already demonstrated most of this functionality as we learned how to interact with a database, we can leverage a lot of the code we've already written, making it more generic as we go.</p>
			<p>We could structure the preceding application in a number of different ways, depending on our own individual views on the logical split that makes the most sense. We could spend a number of hours in the design phase, working out the exact project structure before we write any code; however, we would prefer to propose a starting structure, begin fleshing it out, and take an agile/evolutionary approach to develop this simple application.  </p>
			<h2 id="_idParaDest-309">Exer<a id="_idTextAnchor407"/>cise 13.08: Defining the Application Layer</h2>
			<p>We'll look to create our backend/application layer here; defining our namespaces and exposing an appropriate API.</p>
			<p>Looking at the requirements we have, I'd suggest the following namespaces:</p>
			<ul>
				<li><strong class="source-inline">schema</strong>: Our data models</li>
				<li><strong class="source-inline">ingest</strong>: Single user and activity ingestion</li>
				<li><strong class="source-inline">query</strong>: General queries for users and activities, plus more complex report queries</li>
			</ul>
			<p>Again, remembering that we'd ideally layer on a REST service on top, imagine a top-level <strong class="source-inline">web</strong> or <strong class="source-inline">api</strong> namespace that will be interacting with the preceding namespaces and the public functions within.</p>
			<p>Before proceeding with this exercise, add the following to your <strong class="source-inline">deps.edn</strong> file or similar:</p>
			<p class="source-code">{:deps {..</p>
			<p class="source-code">        semantic-csv {:mvn/version "0.2.1-alpha1"}</p>
			<p class="source-code">        org.clojure/data.csv {:mvn/version "0.1.4"}}</p>
			<p>Starting with a clean database, we'll begin by defining our <strong class="source-inline">ns</strong> schema, containing our DDL definitions that we'll expand slightly to support our reporting requirement. Notably, we've added an <strong class="source-inline">activity_date</strong> field to the activity table, allowing us to report on activities across time:</p>
			<ol>
				<li value="1">Define our namespace, including our <strong class="source-inline">jdbc</strong> and <strong class="source-inline">hikari</strong> requirements:<p class="source-code">(ns packt-clj.fitness.schema</p><p class="source-code">  (:refer-clojure :exclude [load])</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]</p><p class="source-code">    [hikari-cp.core :as hikari]))</p><p>Note the use of <strong class="source-inline">(:refer-clojure :exclude [load])</strong> in the previous code. This is not essential, but will suppress a warning that we're replacing a function from <strong class="source-inline">clojure.core</strong> when we come to define our own <strong class="source-inline">load</strong> function next. The warning we'd experience without this line would be as follows:</p><p class="source-code">WARNING: load already refers to: #'clojure.core/load in namespace: packt-clj.fitness.schema, being replaced by: #'packt-clj.fitness.schema/load</p></li>
				<li>Now, define our <strong class="source-inline">jdbc-url</strong> parameter and create a <strong class="source-inline">hikari</strong> connection-pooled data source. This <strong class="source-inline">db</strong> variable will be referenced and used throughout this exercise whenever we load our schema, insert rows, or query rows from our database:<p class="source-code">(def ^:private jdbc-url "jdbc:derby:derby-local;create=true")</p><p class="source-code">(def db {:datasource (hikari/make-datasource {:jdbc-url jdbc-url})})</p></li>
				<li>We'll now create our <strong class="source-inline">app_user</strong> and <strong class="source-inline">activity</strong> DDL:<p class="source-code">(def ^:private create-app-user-ddl "CREATE TABLE app_user (</p><p class="source-code">  id int GENERATED ALWAYS AS IDENTITY CONSTRAINT USER_ID_PK PRIMARY KEY,</p><p class="source-code">  first_name varchar(32),</p><p class="source-code">  surname varchar(32),</p><p class="source-code">  height smallint,</p><p class="source-code">  weight smallint)")</p><p class="source-code">(def ^:private create-activity-ddl "CREATE TABLE activity (</p><p class="source-code">  id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,</p><p class="source-code">  activity_type VARCHAR(32),</p><p class="source-code">  distance DECIMAL(7,2),</p><p class="source-code">  duration INT,</p><p class="source-code">  activity_date DATE,</p><p class="source-code">  user_id INT REFERENCES app_user ON DELETE CASCADE)")</p></li>
				<li>Finally, we'll bring this all together under a <strong class="source-inline">load</strong> function, which will apply our database schema (that is, our DDL) to the database referenced by our JDBC URL, via a connection pool:<p class="source-code">(defn load</p><p class="source-code">  []</p><p class="source-code">  (jdbc/db-do-commands db [create-app-user-ddl create-activity-ddl]))</p><p>Notice that some of our variables are defined as private, meaning that referencing them outside of the schema namespace is not required (or permitted). We make reference to them indirectly by calling the public <strong class="source-inline">load</strong> function. Note that <strong class="source-inline">schema/load</strong> is the only function in this <strong class="source-inline">ns</strong> that makes up our public API. The <strong class="source-inline">db</strong> var is public and we'd expect to reference it when making any queries or ingesting data.</p></li>
				<li>Now for our ingestion code, where we'll allow the creation of individual users and activities:<p class="source-code">(ns packt-clj.fitness.ingest</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]))</p><p class="source-code">(defn user</p><p class="source-code">  [db app_user]</p><p class="source-code">  (first (jdbc/insert! db :app_user app_user)))</p><p class="source-code">(defn activity</p><p class="source-code">  [db activity]</p><p class="source-code">  (first (jdbc/insert! db :activity activity)))</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">jdbc/insert!</strong> returns a one-element sequence. We can, therefore, call first on the result of each <strong class="source-inline">insert</strong> statement to save our callers some work.</p></li>
				<li>This is our query code where we'll expand a little on what we've written before:<p class="source-code">(ns packt-clj.fitness.query</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]))</p><p class="source-code">(defn all-users</p><p class="source-code">  [db]</p><p class="source-code">  (jdbc/query db ["select * from app_user"]))</p><p class="source-code">(defn user</p><p class="source-code">  [db user-id]</p><p class="source-code">  (jdbc/query db [(str "select * from app_user where id = " user-id)]))</p></li>
				<li>Expand on the <strong class="source-inline">all-activities</strong> function as follows:<p class="source-code">(defn all-activities</p><p class="source-code">  [db]</p><p class="source-code">  (jdbc/query db ["select * from activity"]))</p><p class="source-code">(defn activity</p><p class="source-code">  [db activity-id]</p><p class="source-code">  (jdbc/query db [(str "select * from activity where id = " activity-id)]))</p><p class="source-code">(defn activities-by-user</p><p class="source-code">  [db user-id]</p><p class="source-code">  (jdbc/query db [(str "select * from activity where user_id = " user-id)]))</p></li>
				<li>Now, let's add our more advanced query definitions to the <strong class="source-inline">query</strong> namespace. We'll introduce the <strong class="source-inline">medley</strong> and <strong class="source-inline">java-time</strong> dependencies into our project and require them in our <strong class="source-inline">ns</strong> query before creating a function that determines the most active user:<p class="source-code">{:deps {..</p><p class="source-code">        clojure.java-time {:mvn/version "0.3.2"}</p><p class="source-code">        medley {:mvn/version "1.2.0"}}</p><p class="source-code">(ns packt-clj.fitness.query</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]</p><p class="source-code">    [java-time :as t]</p><p class="source-code">    [medley.core :as medley]))</p><p><strong class="source-inline">medley</strong> is a third-party convenience library that provides commonly required functions that would otherwise be constructed using components of <strong class="source-inline">clojure.core</strong>:</p></li>
				<li>The <strong class="source-inline">most-active-user</strong> function would look as follows:<p class="source-code">(defn most-active-user</p><p class="source-code">  [db]</p><p class="source-code">  (jdbc/query</p><p class="source-code">    db</p><p class="source-code">    ["select au.first_name, au.surname, a.duration from app_user au, activity a where au.id = a.user_id "]</p><p class="source-code">    {:row-fn        (fn [{:keys [first_name surname duration]}] {:name     (str first_name " " surname)</p><p class="source-code">:duration duration})</p><p class="source-code">     :result-set-fn (fn [rs]</p><p class="source-code">                      (-&gt;&gt; rs</p><p class="source-code">                           (group-by :name)</p><p class="source-code">                           (medley/map-vals #(apply + (map :duration %)))</p><p class="source-code">                           (sort-by val)</p><p class="source-code">                           last))}))</p></li>
				<li>Finally, we'll create a function that will calculate our single-user activity report by month:<p class="source-code-heading">query.clj</p><p class="source-code">41 (defn monthly-activity-by-user</p><p class="source-code">42   [db user-id]</p><p class="source-code">43   (jdbc/query</p><p class="source-code">44     db</p><p class="source-code">45     [(str "select au.first_name, au.surname, a.duration, a.activity_type, a.distance, a.activity_date from app_user au, activity a where au.id = a.user_id and a.user_id = " 1)]</p><p class="source-code">46     {:row-fn        (fn [row] (update row :activity_date t/local-date))</p><p class="source-code">47      :result-set-fn (fn [rs]</p><p class="source-code">48                       (reduce</p><p class="source-code">49                         (fn [acc {:keys [activity_date activity_type distance duration first_name surname] :as row}]</p><p class="source-code">50                           (let [month-year (t/as activity_date :month-of-year :year)]</p><p class="source-code-link">The complete code can be referred at: <a href="https://packt.live/37G4naC">https://packt.live/37G4naC</a></p></li>
				<li>Now that we have an application layer defined, we can begin interacting with the functions we've exposed in each of our namespaces. We should see they read and return results in an intuitive manner. In order to make use of our API, require and alias each of our namespaces:<p class="source-code">(require '[packt-clj.fitness.ingest :as ingest]</p><p class="source-code">         '[packt-clj.fitness.schema :as schema]</p><p class="source-code">         '[packt-clj.fitness.query :as query])</p></li>
				<li>We must load our schema to our empty database, being careful to drop any child tables before their parents:<p class="source-code">user=&gt; (jdbc/execute! schema/db ["drop table activity"])</p><p class="source-code">[0]</p><p class="source-code">user=&gt; (jdbc/execute! schema/db ["drop table app_user"])</p><p class="source-code">[0]</p><p class="source-code">user=&gt; (schema/load)</p><p class="source-code">(0 0)</p></li>
				<li>Now, let's define a handful of users and persist them to the database:<p class="source-code">user=&gt; (def users [{:first_name "Andre"</p><p class="source-code">            :surname    "Agassi"</p><p class="source-code">            :height     180</p><p class="source-code">            :weight     80}</p><p class="source-code">           {:first_name "Pete"</p><p class="source-code">            :surname    "Sampras"</p><p class="source-code">            height     185</p><p class="source-code">            :weight     77</p><p class="source-code">            }</p><p class="source-code">            {:first_name "Steffi"</p><p class="source-code">            surname    "Graff"</p><p class="source-code">            :height     176</p><p class="source-code">            :weight     64}])</p><p class="source-code">#'user/users</p><p class="source-code">user=&gt; (doseq [user users]</p><p class="source-code">  (ingest/user schema/db user))</p><p class="source-code">nil</p><p>Note our use of <strong class="source-inline">doseq</strong> in the preceding code. <strong class="source-inline">doseq</strong> can be used to iterate over a collection when we are not interested in the result (as we are when using <strong class="source-inline">map</strong>). Since we are iterating over a collection purely for side effects, we cannot be lazy about this operation as there is no guarantee we'd ever persist every user.</p><p>Familiarize yourself with the <strong class="source-inline">sample-activities.csv</strong> file, which contains 20 randomly generated activities for each of the three users we've just persisted. Note how the structure of the file does not map perfectly to our schema and consider potential methods we could use to parse the CSV file into a format that our <strong class="source-inline">ingest/activity</strong> function would support.</p><p>One method would be to define a map where the keys are precisely those that meet our schema requirements. If the values were then single-arity functions that would extract the relevant data from a given row, we could apply each of these in turn, generating a map that conforms to our schema.</p></li>
				<li>Define the accessor map as follows:<p class="source-code">user=&gt; (def accessors</p><p class="source-code">  {:activity_type :type</p><p class="source-code">   :distance :distance_metres</p><p class="source-code">   :duration :duration_seconds</p><p class="source-code">   :user_id :userid</p><p class="source-code">   :activity_date (fn [{:keys [day month year]}] (str year "-" month "-" day))})</p><p class="source-code">user=&gt; #'user/accessors</p><p>Note how all but the <strong class="source-inline">activity_date</strong> accessor is performing a simple rename. <strong class="source-inline">activity_date</strong> is doing a (very slightly!) more complex operation, extracting multiple fields from a row and combining them into one. We could imagine extending this to perform arbitrarily complex parsing and data extraction.</p></li>
				<li>An <strong class="source-inline">apply-accessors</strong> function is required to actually take a row, an accessor map, and return the schema-conforming map:<p class="source-code">user=&gt; (defn apply-accessors</p><p class="source-code">  [row accessors]</p><p class="source-code">  (reduce-kv</p><p class="source-code">    (fn [acc target-key accessor]</p><p class="source-code">      (assoc acc target-key (accessor row)))</p><p class="source-code">    {}</p><p class="source-code">    accessors))</p><p class="source-code">=&gt; #'user/apply-accessors</p><p><strong class="source-inline">reduce-kv</strong> can be used to iterate over the key-value pairs in our accessor map.</p></li>
				<li>With our accessors and our <strong class="source-inline">apply-accessors</strong> functions defined, we can now read our CSV file and parse to a form that matches our activity table schema:<p class="source-code">user=&gt; (require '[semantic-csv.core :as sc]</p><p class="source-code">                '[clojure.data.csv :as csv]</p><p class="source-code">                '[clojure.java.io :as io])</p><p class="source-code">=&gt; nil</p><p class="source-code">user=&gt; (def activities</p><p class="source-code">  (-&gt;&gt; (csv/read-csv (io/reader "resources/sample-activities.csv"))</p><p class="source-code">       sc/mappify</p><p class="source-code">       (map #(apply-accessors % accessors))))</p><p class="source-code">user=&gt; #'user/activities</p><p>Inspecting our first entry, we see that it does indeed look as we expect:</p><p class="source-code">user=&gt; (first activities)</p><p class="source-code">=&gt; {:activity_type "swim", :distance "5100.00", :duration "9180", :user_id "1", :activity_date "2019-01-22"}</p></li>
				<li>We can now persist these activities in the same manner that we did for persisting our users:<p class="source-code">user=&gt; (doseq [activity activities]</p><p class="source-code">  (ingest/activity schema/db activity))</p><p class="source-code">=&gt; nil</p></li>
				<li>Finally, let's exercise our queries in turn and verify the results:<p class="source-code">user=&gt; (count (query/all-users schema/db))</p><p class="source-code">=&gt; 3</p><p class="source-code">user=&gt; (count (query/all-activities schema/db))</p><p class="source-code">=&gt; 60</p><p class="source-code">user=&gt; (query/user schema/db 1)</p><p class="source-code">=&gt; ({:id 1, :first_name "Andre", :surname "Agassi", :height 180, :weight 80})</p><p class="source-code">user=&gt; (query/activity schema/db 1)</p><p class="source-code">=&gt;</p><p class="source-code">({:id 1,</p><p class="source-code">  :activity_type "swim",</p><p class="source-code">  :distance 5100.00M,</p><p class="source-code">  :duration 9180,</p><p class="source-code">  :activity_date #inst"2019-01-22T00:00:00.000-00:00",</p><p class="source-code">  :user_id 1})</p><p class="source-code">user=&gt; (count (query/activities-by-user schema/db 1))</p><p class="source-code">=&gt; 20</p><p class="source-code">user=&gt; (query/most-active-user schema/db)</p><p class="source-code">=&gt; ["Pete Sampras" 136680]</p><p class="source-code">user=&gt; (clojure.pprint/pprint (query/monthly-activity-by-user schema/db 3))</p><p>The output will look as follows:</p><div id="_idContainer273" class="IMG---Figure"><img src="image/B14502_13_05.jpg" alt="Figure 13.5: Output on verifying the results&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.5: Output on verifying the results</p>
			<p>We've now created the backend of our application, logically separating the various functions our application comprises. We've created a database, loaded our schema, and then ingested and retrieved data. This demonstrates a typical application life cycle, and hopefully we could imagine a REST service or mobile app sitting on top of this API we've constructed.</p>
			<h2 id="_idParaDest-310">Activ<a id="_idTextAnchor408"/>ity 13.01: Persisting Historic Tennis Results and ELO Calculations</h2>
			<p>Given your experience with historic tennis results and ELO calculations, you've been hired by Tennis Analytics Ltd. They have a large CSV file that is difficult to work with; they'd like the competitor data to be modeled and persisted to a database. Once ingested, they would like to perform ELO calculations across the entire dataset maintaining a full ELO history.  The ultimate goal is to find the competitor with the best ELO rating for a historic dataset.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Add the required dependencies to your <strong class="source-inline">deps.edn</strong> file or equivalent.</li>
				<li>Create the <strong class="source-inline">packt-clj.tennis.database</strong>, <strong class="source-inline">packt-clj.tennis.elo, packt-clj.tennis.ingest</strong>, <strong class="source-inline">packt-clj.tennis.parse</strong>, and <strong class="source-inline">packt-clj.tennis.query</strong> namespaces.</li>
				<li>In the <strong class="source-inline">database</strong> namespace, define a connection pool, referencing a new <strong class="source-inline">tennis</strong> database on disk, and store it in the <strong class="source-inline">db</strong> var.</li>
				<li>Define a database <strong class="source-inline">player</strong> table using DDL consisting of the <strong class="source-inline">id</strong> (provided in the CSV file) and <strong class="source-inline">full_name</strong> fields.</li>
				<li>Define a <strong class="source-inline">tennis_match</strong> table consisting of the <strong class="source-inline">id</strong> (a composite ID can be constructed from the CSV file), <strong class="source-inline">tournament_year</strong>, <strong class="source-inline">tournament</strong>, <strong class="source-inline">tournament_order</strong>, <strong class="source-inline">round_order</strong>, <strong class="source-inline">match_order</strong>, and <strong class="source-inline">winner_id</strong> (a foreign key referencing the player ID from the table in <em class="italic">Step 4</em>) fields.</li>
				<li>Define an <strong class="source-inline">elo</strong> table consisting of the <strong class="source-inline">id</strong> (can be autogenerated), <strong class="source-inline">player_id</strong> (foreign key referencing the player ID from the table in <em class="italic">Step 4</em>), and <strong class="source-inline">rating</strong> fields.</li>
				<li>Create (and execute) a <strong class="source-inline">load</strong> function that will apply the DDL from <em class="italic">Steps 4-6</em> to our database defined in <em class="italic">Step 3</em>.<p>In the <strong class="source-inline">parse</strong> namespace, define a <strong class="source-inline">historic</strong> function that accepts a string representing a file path on the local disk. This function should read the CSV file from disk; convert the file to a sequence of maps; iterate over each row in turn; extract the fields pertinent for our <strong class="source-inline">players</strong> and <strong class="source-inline">matches</strong> data structures (fields will not necessarily be extracted exactly as-is; that is, some additional parsing or formatting will be required); and build up a data structure, ultimately returning a map of the following form:</p><p class="source-code">{:players [&lt;player 1&gt; ...]</p><p class="source-code"> :matches [&lt;match 1&gt; ...]}</p><p>Here, <strong class="source-inline">players</strong> and <strong class="source-inline">matches</strong> are maps that conform to the schema we've created.</p><p>Helper functions should be defined as required. Some suggestions of functions that could prove helpful include being a means of parsing a row into a <strong class="source-inline">winning-player</strong>, <strong class="source-inline">losing-player</strong>, and <strong class="source-inline">match</strong> column, and being a means of defining the mapping of <strong class="source-inline">target-key</strong> function to the <strong class="source-inline">row-extraction</strong> function for each of the preceding structures.</p><p class="callout-heading">Note</p><p class="callout">We should be cautious to avoid defining unique players multiple times. We should also be aware that the <strong class="source-inline">match_id</strong> column in the CSV file <em class="italic">is not unique</em>! An appropriate composite should be constructed.</p></li>
				<li>In the <strong class="source-inline">ingest</strong> namespace, define a <strong class="source-inline">historic</strong> function that accepts a <strong class="source-inline">db-spec</strong> definition and a string representing a path/filename on the local disk. This function should pass the file path to the function defined in <em class="italic">step 8</em>, destructure the players and matches, and then perform <strong class="source-inline">insert-multi!</strong> on each in turn.<p class="callout-heading">Note</p><p class="callout">Players must be ingested prior to matches to ensure we satisfy our foreign key constraints.</p></li>
				<li>Copy the <strong class="source-inline">match_scores_1991-2016_unindexed_csv.csv</strong> CSV file into the <strong class="source-inline">resources</strong> directory, and then ingest all <strong class="source-inline">player</strong> and <strong class="source-inline">match</strong> data from this file using the <strong class="source-inline">historic</strong> function from <em class="italic">Step 8</em>.<p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">match_scores_1991-2016_unindexed_csv.csv</strong> CSV file can be found on GitHub at <a href="https://packt.live/30291NO">https://packt.live/30291NO</a>.</p></li>
				<li>Now we have our data ingested, we'd like to calculate the ELO value for all historic matches, storing the ELO rating as we go. In the <strong class="source-inline">query</strong> namespace, define an <strong class="source-inline">all-tennis-matches</strong> function that accepts <strong class="source-inline">db-spec</strong> and returns the contents of the <strong class="source-inline">tennis_match</strong> table. This should be sorted appropriately by <strong class="source-inline">tournament_year</strong>, <strong class="source-inline">tournament_order</strong>, <strong class="source-inline">reverse round_order</strong>, and <strong class="source-inline">match_order</strong> to ensure we're calculating ratings chronologically.</li>
				<li>We'll now leverage two of the functions we've already met in <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, namely <strong class="source-inline">match-probability</strong> and <strong class="source-inline">recalculate-rating</strong>. Introduce those to the <strong class="source-inline">elo</strong> namespace.</li>
				<li>In the <strong class="source-inline">elo</strong> namespace, define a new <strong class="source-inline">calculate-all</strong> function that accepts <strong class="source-inline">db-spec</strong> and retrieves all tennis matches using <strong class="source-inline">query/all-tennis-matches</strong> (ordered chronologically, as described in <em class="italic">Step 1<a id="_idTextAnchor409"/>0</em>), and then iterates over this dataset, calculating the ELO rating for each match, returning a collection of <strong class="source-inline">elo</strong> ratings that conform to the schema of the <strong class="source-inline">elo</strong> table.</li>
				<li>Define a simple function that takes the result of the <strong class="source-inline">calculate-all</strong> function call and persists it into the <strong class="source-inline">elo</strong> table. Call this function to persist our ELO calculations.</li>
				<li>Finally, define a <strong class="source-inline">select-max-elo</strong> function (we are interested in the player who has the highest ELO rating) in the <strong class="source-inline">query</strong> namespace, which returns a result in the following form:<p class="source-code">{:max-rating …</p><p class="source-code"> :player-name …}</p><p>On executing this, we should see a familiar name!</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 745.</p></li>
			</ol>
			<h1 id="_idParaDest-311">Summa<a id="_idTextAnchor410"/>ry</h1>
			<p>This chapter gave us an introduction to the Apache Derby RDBMS, creating a locally hosted instance with minimal setup. We then explored data models and how to codify them into a schema using DDL. We used <strong class="source-inline">clojure.java.jdbc</strong> to load this schema before investigating how the API allows us to perform CRUD operations, spending time on how to control the results from our query executions.</p>
			<p>We then built an application layer for our ELO calculation application. In doing so, we learned which functions to expose as part of our API and which are internal to our application and should be kept private from a user.</p>
			<p>In the next chapter, we'll take the public API of our application layer and learn how to build a REST-based web service to expose that API over HTTP. In this way, we can make calls from a REST client and interact with our application over a network, rather than via a locally hosted REPL.</p>
			<p>Subsequently, we'll improve this RESTful interaction by adding a higher-level UI layer so that a user can interact with our service via a web browser.</p>
		</div>
		<div>
			<div id="_idContainer275" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer276" class="Content">
			</div>
		</div>
	</body></html>