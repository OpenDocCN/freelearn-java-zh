- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Execution Engine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行引擎
- en: In the intricate landscape of the **Java Virtual Machine** (**JVM**), the execution
    engine takes center stage, playing a pivotal role in interpreting bytecode and
    executing **just-in-time (JIT) compilation** for performance optimization. Bytecode,
    the intermediary language between Java source code and the JVM, undergoes interpretation
    as the execution engine dynamically translates it into native machine code during
    program execution. The stack-based execution model employed by the JVM manipulates
    an operand stack, pushing and popping operands as bytecode instructions are interpreted.
    While bytecode interpretation ensures platform independence, it cannot consistently
    deliver peak performance due to an additional abstraction layer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的 **Java 虚拟机**（**JVM**）的领域中，执行引擎扮演着核心角色，在解释字节码和执行性能优化的 **即时（JIT）编译**中发挥着关键作用。字节码，作为
    Java 源代码和 JVM 之间的中介语言，在执行引擎动态将其转换为本地机器码的过程中被解释。JVM 使用的基于栈的执行模型操作一个操作数栈，在解释字节码指令时推入和弹出操作数。尽管字节码解释确保了平台独立性，但由于额外的抽象层，它无法始终提供最佳性能。
- en: To address performance challenges, the JVM incorporates JIT compilation. This
    strategic optimization technique identifies frequently executed code segments,
    or hotspots, and dynamically compiles them into native machine code at runtime.
    By selectively optimizing hotspots, the JVM balances portability and performance,
    significantly enhancing the execution speed of Java applications. This chapter
    delves into the nuances of bytecode interpretation and the intricacies of JIT
    compilation, unraveling how these processes synergize to make the JVM a robust
    and adaptive runtime environment for Java programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决性能挑战，JVM 引入了 JIT 编译。这种战略优化技术识别频繁执行的代码段，或热点，并在运行时动态地将它们编译成本地机器码。通过选择性地优化热点，JVM
    平衡了可移植性和性能，显著提高了 Java 应用程序的执行速度。本章深入探讨了字节码解释和 JIT 编译的细微差别，揭示了这些过程如何协同作用，使 JVM
    成为 Java 程序的强大且适应性强的运行环境。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The foundation of execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的基础
- en: System operation layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统操作层
- en: Decoding JVM execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码 JVM 执行
- en: JIT compilation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 编译
- en: Class loading
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载
- en: The foundation of execution
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行的基础
- en: With a solid understanding of the compilation process that transforms Java source
    code into class files and bytecode, we now focus on the fascinating realm of JVM
    execution. This crucial phase is where the magic happens, as the JVM takes the
    reins to bring our Java programs to life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入理解将 Java 源代码转换为类文件和字节码的编译过程之后，我们现在关注 JVM 执行的迷人领域。这一关键阶段是魔法发生的地方，因为 JVM
    接管了控制权，使我们的 Java 程序得以实现。
- en: As the JVM receives the compiled class files containing bytecode, the execution
    engine kicks into action. Bytecode, the intermediary representation of our Java
    programs, is interpreted in a stack-based execution model. The execution engine
    dynamically executes the bytecode instructions, manipulating an operand stack.
    This stack-based approach allows the JVM to process the instructions efficiently,
    pushing and popping operands onto and from the stack. While bytecode interpretation
    ensures platform independence, it may introduce performance considerations, which
    leads us to the next crucial step in the execution journey.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JVM 接收到包含字节码的编译后的类文件时，执行引擎开始工作。字节码，我们 Java 程序的中介表示，在基于栈的执行模型中被解释。执行引擎动态执行字节码指令，操作操作数栈。这种基于栈的方法允许
    JVM 高效地处理指令，将操作数推入和弹出栈。尽管字节码解释确保了平台独立性，但它可能会引入性能考虑，这使我们转向执行旅程中的下一个关键步骤。
- en: 'When a JVM program is executed, several steps unfold to bring the Java application
    to life:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JVM 程序执行时，几个步骤展开，以使 Java 应用程序得以运行：
- en: '**Loading**: The class loader locates and loads the compiled Java class files
    (bytecode) into the JVM. This includes the core Java libraries and any user-defined
    classes.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载**：类加载器定位并加载编译后的 Java 类文件（字节码）到 JVM 中。这包括核心 Java 库和任何用户定义的类。'
- en: '**Verification**: The loaded bytecode undergoes a verification process to ensure
    it adheres to Java language specifications, preventing potentially harmful code
    from being executed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：加载的字节码经过验证过程，以确保其符合 Java 语言规范，防止可能有害的代码被执行。'
- en: '**Preparation**: Memory space is allocated for class variables and static fields,
    initializing them with default values.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：为类变量和静态字段分配内存空间，并用默认值初始化它们。'
- en: '**Resolution**: Symbolic references in the bytecode are resolved to concrete
    references, ensuring that classes and methods can be linked correctly.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：字节码中的符号引用被解析为具体引用，确保类和方法可以正确链接。'
- en: '**Initialization**: The static blocks and variables of the class are executed,
    initializing the class for use.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：执行类的静态块和变量，初始化类以供使用。'
- en: '**Execution**: The **main()** method or the designated entry point is invoked,
    and the program begins its execution.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：调用 **main()** 方法或指定的入口点，程序开始执行。'
- en: 'As a Java class file takes center stage within the JVM, a sophisticated orchestration
    of processes unfolds, paving the way for the execution of a Java application.
    The class file, a compiled representation of Java source code, becomes the focal
    point as the JVM’s class loader meticulously locates and loads it into the runtime
    environment. Once loaded, the JVM undertakes a series of steps, from verifying
    the bytecode’s adherence to language specifications to resolving symbolic references
    and initializing class variables. The culmination of these steps results in the
    transformed class file operating within the JVM. With the `main()` method or designated
    entry point invoked, the application embarks on its runtime journey, with each
    line of code dynamically interpreted and executed. The synergy between the class
    file, JVM, and the running application exemplifies the intricate dance that underlies
    the execution of Java programs within the versatile and adaptive environment of
    the JVM, as the following diagram shows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 中，Java 类文件占据核心地位，一系列复杂的流程展开，为 Java 应用的执行铺平道路。类文件，Java 源代码的编译表示，成为焦点，因为
    JVM 的类加载器仔细地定位并加载它到运行环境中。一旦加载，JVM 执行一系列步骤，从验证字节码是否符合语言规范到解析符号引用和初始化类变量。这些步骤的最终结果是转换后的类文件在
    JVM 中运行。当 `main()` 方法或指定的入口点被调用时，应用开始其运行时之旅，每一行代码都被动态地解释和执行。类文件、JVM 和运行中的应用之间的协同作用展示了在
    JVM 的灵活和自适应环境中执行 Java 程序背后的复杂舞蹈，如下面的图示所示：
- en: '![Figure 4.1: The process to execute a class in the JVM](img/B22030_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：在 JVM 中执行类的过程](img/B22030_04_01.jpg)'
- en: 'Figure 4.1: The process to execute a class in the JVM'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：在 JVM 中执行类的过程
- en: Each time a Java application is executed, the JVM creates a unique runtime environment.
    However, it’s important to note that the JVM optimizes performance within each
    runtime using various techniques. One notable optimization technique is the JIT
    compiler. In repeated executions of the same application, the JVM identifies frequently
    executed code paths, known as hotspots, within that specific runtime and dynamically
    compiles them into native machine code. This compiled code is stored in memory
    within the same runtime, reducing the need for repeated interpretation of the
    same bytecode and significantly improving execution speed within that particular
    runtime. Additionally, JVM implementations may employ caching mechanisms to store
    frequently accessed classes and resources, further optimizing the application’s
    performance within the scope of each runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行 Java 应用时，JVM 都会创建一个独特的运行时环境。然而，需要注意的是，JVM 使用各种技术优化每个运行时的性能。一种值得注意的优化技术是
    JIT 编译器。在相同应用的重复执行中，JVM 识别出特定运行时中频繁执行的代码路径，称为热点，并将它们动态编译成本地机器代码。这段编译后的代码存储在同一运行时的内存中，减少了重复解释相同字节码的需要，并显著提高了该特定运行时的执行速度。此外，JVM
    实现可能采用缓存机制来存储频繁访问的类和资源，进一步优化每个运行时范围内的应用性能。
- en: To summarize, the JVM optimizes performance within each runtime, and the benefits
    of JIT compilation and caching mechanisms apply to a single execution instance,
    ensuring that the application runs efficiently within its specific runtime environment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，JVM 在每个运行时优化性能，JIT 编译和缓存机制的好处适用于单个执行实例，确保应用在其特定的运行时环境中高效运行。
- en: Despite these optimizations, it’s important to note that they are lost when
    the Java application stops. Therefore, with each run of an application on the
    same or another machine, the entire optimization and compilation of the native
    code process must happen again. Ongoing projects, such as the Project Leyden ([https://openjdk.org/projects/leyden/](https://openjdk.org/projects/leyden/)),
    aim to address this challenge. The primary goal of the Leyden project is to improve
    startup time, time-to-peak performance, and the overall footprint of Java programs
    by giving developers more control over which optimizations are applied. However,
    it’s worth noting that the extent of such control may be limited in the project’s
    current state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些优化，但重要的是要注意，当Java应用程序停止时，它们会丢失。因此，每次在相同或另一台机器上运行应用程序时，整个优化和编译原生代码的过程都必须再次发生。正在进行的计划，如Project
    Leyden ([https://openjdk.org/projects/leyden/](https://openjdk.org/projects/leyden/))，旨在解决这一挑战。Leyden项目的主要目标是通过让开发者更多地控制应用哪些优化来提高Java程序的启动时间、峰值性能时间和整体占用空间。然而，值得注意的是，在项目的当前状态下，这种控制的程度可能有限。
- en: Another noteworthy project in this context is **Coordinated Restore at Checkpoint**
    (**CRaC**) ([https://docs.azul.com/core/crac/crac-introduction](https://docs.azul.com/core/crac/crac-introduction)),
    which is a JDK project designed to optimize the startup time and resource utilization
    of Java programs. CRaC allows you to start Java programs with a shorter time to
    the first transaction and requires fewer resources to achieve complete code speed.
    It accomplishes this by taking a snapshot of the Java process (checkpoint) when
    it is fully warmed up. It then uses that snapshot to launch multiple JVMs from
    this captured state, leveraging native Linux features. It’s worth mentioning that
    alternatives such as **InstantOn from Open Liberty** also exist, and both are
    proprietary technologies. Additionally, the CRaC API is used by AWS Lambda SnapStart,
    showcasing real-world applications of this checkpointing approach. Popular frameworks
    such as Spring, Micronaut, and Quarkus also support CRaC checkpointing, making
    it a promising approach to optimize Java application performance further.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，另一个值得注意的项目是**协调恢复点**（**CRaC**）（[https://docs.azul.com/core/crac/crac-introduction](https://docs.azul.com/core/crac/crac-introduction)），这是一个旨在优化Java程序启动时间和资源利用率的JDK项目。CRaC允许您以更短的时间启动Java程序，并且需要更少的资源来实现完整的代码速度。它通过在Java进程完全预热时对其进行快照（检查点）来实现这一点。然后，它使用该快照从这个捕获的状态启动多个JVM，利用了原生的Linux特性。值得一提的是，像**Open
    Liberty的InstantOn**这样的替代方案也存在，并且两者都是专有技术。此外，CRaC API被AWS Lambda SnapStart使用，展示了这种检查点方法的实际应用。流行的框架，如Spring、Micronaut和Quarkus也支持CRaC检查点，使其成为进一步优化Java应用程序性能的有希望的方法。
- en: The bytecode interpreter, a critical component within the JVM, plays a pivotal
    role in executing Java programs. When a Java application is launched, the JVM
    loads bytecode generated from previously compiled Java source code, typically
    packaged into a JAR file. This bytecode is then meticulously interpreted by the
    bytecode interpreter, following a step-by-step process of fetching, decoding,
    and executing each instruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码解释器是JVM中的一个关键组件，在执行Java程序中起着至关重要的作用。当Java应用程序启动时，JVM加载从先前编译的Java源代码生成的字节码，通常打包成一个JAR文件。然后，字节码解释器会仔细地逐条解释这些字节码，遵循获取、解码和执行每个指令的逐步过程。
- en: At its core, the bytecode interpreter adheres to the platform independence principle.
    Executing the same bytecode on any device equipped with a JVM enables Java applications
    to run seamlessly across diverse environments without modification. This adaptability
    is fundamental to Java’s renowned *Write Once, Run Anywhere* philosophy, liberating
    developers from concerns about underlying hardware and operating systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，字节码解释器遵循平台独立性原则。在配备JVM的任何设备上执行相同的字节码，使Java应用程序能够在不同的环境中无缝运行，无需修改。这种适应性是Java著名的*一次编写，到处运行*哲学的基础，使开发者免于担心底层硬件和操作系统。
- en: Operating on a stack-based model, the interpreter navigates through bytecode
    instructions, pushing operands onto and popping them off a stack as operations
    are executed. This stack-oriented approach allows efficient bytecode processing
    and contributes to Java applications’ adaptability and quick startup times. While
    interpreted code may not match the speed of natively compiled counterparts, the
    bytecode interpreter strikes a balance by providing the agility of fast startup
    combined with the portability that defines Java’s strength in cross-platform development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于栈的模型上操作，解释器通过字节码指令导航，在执行操作时将操作数推入栈中并从中弹出。这种面向栈的方法允许高效的字节码处理，并有助于 Java 应用程序的适应性和快速启动时间。虽然解释代码可能无法与本地编译的对应物相匹配，但字节码解释器通过提供快速启动的敏捷性和定义
    Java 在跨平台开发中优势的可移植性来达到平衡。
- en: As we transition from the nuanced workings of the JVM to a broader perspective,
    our journey now unfolds in the layers of system operation. The system’s foundation,
    the hardware layer, provides the raw power, while the **Instruction Set Architecture**
    (**ISA**) layer is the intermediary language. Operating atop these, the operating
    system orchestrates the harmony of resources, paving the way for the application
    layer to shine. As we explore each layer’s significance, we uncover how the JVM
    collaborates with hardware, communicates through the ISA, dances with the operating
    system, and eventually manifests Java applications at the pinnacle of the computing
    symphony. Let’s embark on this layered expedition to understand the intricate
    dynamics of system operation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从 JVM 的细腻运作过渡到更广阔的视角，我们的旅程现在展开在系统操作的层级之中。系统的基石，硬件层，提供了原始动力，而**指令集架构**（**ISA**）层则是中介语言。在这些之上，操作系统协调资源的和谐，为应用层的光彩夺目铺平道路。当我们探索每一层的意义时，我们揭示了
    JVM 如何与硬件协作，通过 ISA 进行通信，与操作系统共舞，并最终在计算交响乐的顶峰展现 Java 应用程序。让我们开始这次层级的探险，以理解系统操作的复杂动态。
- en: System operation layers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统操作层
- en: 'System operation layers constitute the fundamental architecture that underpins
    the seamless functionality of modern computing. These layers are hierarchical
    strata, each serving a distinct purpose in orchestrating the collaboration between
    hardware and software. Let’s unravel the significance of these layers and understand
    why they are crucial to the operation of a computer system:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 系统操作层构成了支撑现代计算无缝功能的基本架构。这些层是层级结构，每个层在协调硬件和软件之间的协作中都有其独特的目的。让我们揭示这些层的意义，并理解为什么它们对计算机系统的运行至关重要：
- en: '**Hardware layer**: At the lowest level, the hardware layer consists of the
    physical components of a computer system—processors, memory, storage devices,
    and input/output devices. It provides the foundation upon which all higher-level
    operations and software function.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件层**：在最低层，硬件层由计算机系统的物理组件组成——处理器、内存、存储设备和输入/输出设备。它为所有更高层次的运作和软件功能提供了基础。'
- en: '**ISA layer**: Above the hardware layer lies the ISA layer, defining the interface
    between software and the hardware. It includes the instruction set and the architecture,
    which the processor understands. The ISA layer acts as a bridge, allowing software
    to communicate with and utilize underlying hardware resources.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISA 层**：在硬件层之上是 ISA 层，定义了软件和硬件之间的接口。它包括指令集和架构，这是处理器所理解的。ISA 层充当桥梁，允许软件与底层硬件资源进行通信和利用。'
- en: '**Operating system layer**: Sitting above the ISA layer, the operating system
    is a crucial intermediary between application software and the hardware. It manages
    resources, provides a runtime environment for applications, and facilitates communication
    between software and hardware components.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统层**：位于 ISA 层之上，操作系统是应用软件和硬件之间的重要中介。它管理资源，为应用程序提供运行时环境，并促进软件和硬件组件之间的通信。'
- en: '**Application layer**: The topmost layer encompasses the application software,
    which includes programs and tools designed to fulfill specific user needs. This
    layer interacts with the operating system to efficiently execute tasks and leverage
    hardware resources.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：最顶层包括应用软件，这包括旨在满足特定用户需求的程序和工具。这一层与操作系统交互，以高效执行任务并利用硬件资源。'
- en: 'In this visual snapshot, witness the layered ballet of computing as hardware,
    the tangible powerhouse, lays the foundation. The ISA layer is a vital bridge,
    defining the language between software and hardware. Ascending, the operating
    system is a conductor, orchestrating the dynamic interplay. This diagram encapsulates
    the essence of computing layers, showcasing the interconnected dance that brings
    our digital landscape to life:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视觉快照中，见证计算层级的分层芭蕾舞。硬件，这个有形的动力源泉，奠定了基础。ISA层是一个至关重要的桥梁，定义了软件与硬件之间的语言。向上，操作系统扮演着指挥家的角色，协调动态的互动。这张图概括了计算层级的本质，展示了将我们的数字世界带入生机的相互交织的舞蹈：
- en: '![Figure 4.2: The layers of system operation](img/B22030_04_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：系统操作层](img/B22030_04_02.jpg)'
- en: 'Figure 4.2: The layers of system operation'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：系统操作层
- en: 'In the intricate choreography of computing, the JVM emerges as a graceful dancer,
    seamlessly bridging gaps between system layers. A captivating narrative unfolds
    as we explore the symbiotic relationship between the JVM and the foundational
    layers of hardware, ISA, and the operating system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的计算编排中，JVM（Java虚拟机）如同一位优雅的舞者，无缝地连接着系统各层之间的差距。随着我们探索JVM与硬件、ISA（指令集架构）和操作系统基础层之间的共生关系，一个引人入胜的故事逐渐展开：
- en: '**Interaction with ISA and hardware**: The JVM indirectly interacts with the
    ISA layer and hardware through the operating system. It relies on the ISA layer’s
    instruction set to execute bytecode while the operating system manages hardware
    resources on behalf of the JVM.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与ISA和硬件的交互**：JVM通过操作系统间接与ISA层和硬件交互。它依赖于ISA层的指令集来执行字节码，而操作系统代表JVM管理硬件资源。'
- en: '**Collaboration with the operating system**: The JVM works closely with the
    operating system layer, utilizing its services for memory management, file operations,
    and other system-related tasks. The JVM abstracts the underlying hardware and
    operating system differences, providing a platform-independent execution environment
    for Java applications.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与操作系统的协作**：JVM与操作系统层紧密合作，利用其服务进行内存管理、文件操作和其他系统相关任务。JVM抽象了底层硬件和操作系统的差异，为Java应用程序提供了一个平台无关的执行环境。'
- en: '**Application execution**: The JVM is a runtime environment for Java applications
    residing within the application layer. It interprets and executes Java bytecode,
    ensuring that Java programs can run consistently across various platforms without
    direct concern for the underlying hardware or operating system specifics.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序执行**：JVM是位于应用程序层内的Java应用程序的运行时环境。它解释并执行Java字节码，确保Java程序能够在各种平台上一致地运行，无需直接关注底层硬件或操作系统的具体细节。'
- en: In essence, the JVM operates as a crucial bridge between the high-level application
    layer and lower-level system layers, abstracting away hardware and operating system
    details to provide a standardized and portable execution environment for Java
    applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JVM作为高级应用程序层与低级系统层之间的重要桥梁，抽象出硬件和操作系统的细节，为Java应用程序提供一个标准化和可移植的执行环境。
- en: As we draw the curtains on our exploration of system operation layers and their
    intricate dance, we find ourselves on the precipice of a more profound revelation—the
    nuanced execution of the JVM. At this point, we have navigated the significance
    of abstraction, resource management, interoperability, and security, witnessing
    how these pillars shape the very essence of computing. Our journey propels us
    to unravel the layers beneath the JVM’s execution. Join us in the next section
    as we delve into the intricacies of JVM execution, decoding the magic that transpires
    when Java applications come to life. The continuum of our exploration promises
    a deeper understanding of the symbiotic relationship between the JVM and the layers
    we’ve unraveled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束对系统操作层及其复杂舞蹈的探索时，我们发现自己站在一个更深刻的启示的边缘——JVM细微的执行过程。在此阶段，我们已经了解了抽象、资源管理、互操作性和安全性的重要性，见证了这些支柱如何塑造计算的精髓。我们的旅程推动我们去揭示JVM执行之下的层级。请加入我们，在下一节中，我们将深入探讨JVM执行的复杂性，解码当Java应用程序焕发生机时的魔法。我们探索的连续性承诺将更深入地理解JVM与我们所揭示的层级之间的共生关系。
- en: Decoding JVM execution
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码JVM执行
- en: In the orchestration of JVM execution, the performance unfolds across distinct
    stages, each contributing to the seamless functionality of Java applications.
    The overture commences with the loading of the JVM, where the class loader diligently
    fetches and loads class files and bytecode into the memory, setting the stage
    for the ensuing performance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM执行的编排中，性能在各个不同的阶段展开，每个阶段都对Java应用程序的无缝功能做出贡献。前奏从加载JVM开始，其中类加载器勤奋地检索并加载类文件和字节码到内存中，为随后的表演做好准备。
- en: As the curtains rise, the JVM’s execution engine takes the lead, dynamically
    interpreting bytecode in a stack-based execution model. Simultaneously, the data
    area is meticulously initialized, allocating memory spaces for the runtime components
    such as the heap and stack. This orchestrated dance culminates in integration
    with native elements, seamlessly linking native libraries to augment the application’s
    capabilities. Join us in the upcoming section as we delve deeper into the intricacies
    of JVM execution, unraveling the magic that transpires as Java applications come
    to life in this finely tuned symphony.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当帷幕升起时，JVM的执行引擎成为主导，在基于栈的执行模型中动态解释字节码。同时，数据区被细致地初始化，为堆和栈等运行时组件分配内存空间。这场精心编排的舞蹈最终与本地元素集成，无缝地将本地库链接到应用程序的能力中。在下一节中，我们将深入探讨JVM执行的复杂性，揭示Java应用程序在这个精心调校的交响曲中焕发生命时的魔法。
- en: 'When the JVM application executes, it follows these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM应用程序执行时，它遵循以下步骤：
- en: The overture begins with the loading of the JVM itself. This pivotal phase involves
    the class loader locating and loading the necessary class files and bytecode into
    the JVM’s memory. The class loader acts as a gatekeeper, ensuring that the required
    classes are accessible for execution.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前奏从加载JVM本身开始。这个关键阶段涉及类加载器定位和加载必要的类文件和字节码到JVM内存中。类加载器充当守门人，确保所需的类可供执行。
- en: With the stage set, the JVM’s execution engine takes the spotlight. Initially,
    the bytecode is interpreted in a stack-based execution model. As each bytecode
    instruction is dynamically executed, the application begins to take shape, and
    the JVM transforms the high-level code into actionable instructions.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阶段设定完毕后，JVM的执行引擎成为焦点。最初，字节码在基于栈的执行模型中解释。随着每条字节码指令的动态执行，应用程序开始成形，JVM将高级代码转换为可执行指令。
- en: Simultaneously, the JVM initializes its data area, carving out memory spaces
    for the program’s runtime components. It includes sites for the heap, where objects
    are allocated, and the stack, which manages method calls and local variables.
    The meticulous organization of the data area ensures efficient memory management
    during the application’s life cycle.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，JVM初始化其数据区，为程序的运行时组件划分内存空间。这包括堆空间，用于分配对象，以及栈空间，用于管理方法调用和局部变量。对数据区的细致组织确保了应用程序生命周期中的高效内存管理。
- en: 'As the application gains momentum, the JVM seamlessly integrates with the native
    environment. It entails linking native libraries and incorporating them into the
    execution. The native integration bridges the gap between Java and platform-specific
    functionality, enhancing the application’s capabilities and performance. The following
    diagram indicates the flow of the process:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着应用程序的加速，JVM无缝地与本地环境集成。这包括链接本地库并将它们纳入执行。本地集成架起了Java与平台特定功能之间的桥梁，增强了应用程序的能力和性能。以下图表显示了该过程的流程：
- en: '![Figure 4.3: JVM in execution](img/B22030_04_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：JVM执行过程](img/B22030_04_03.jpg)'
- en: 'Figure 4.3: JVM in execution'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：JVM执行过程
- en: This symphony of stages encapsulates the dynamic execution of a Java application
    within the JVM. From the initial loading to the interpretation of bytecode, meticulous
    organization of the data area, and seamless integration with native elements,
    each stage contributes to the harmonious performance of Java applications. Join
    us in the next section as we delve deeper into each stage, unraveling the intricacies
    of JVM execution and demystifying the magic behind Java’s adaptability and cross-platform
    prowess.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的交响曲封装了Java应用程序在JVM中的动态执行过程。从初始加载到字节码的解释，对数据区的细致组织，以及与本地元素的完美融合，每个阶段都对Java应用程序的和谐性能做出了贡献。在下一节中，我们将深入探讨每个阶段，揭示JVM执行的复杂性，并揭开Java适应性和跨平台能力的神秘面纱。
- en: In the intricate symphony of JVM execution, we’ve navigated through the stages
    of loading, bytecode interpretation, data area initialization, and native integration,
    witnessing the seamless orchestration that brings Java applications to life. As
    this chapter concludes, it serves as a prelude to the forthcoming exploration
    into the transformative realm of JIT compilation. In the next section, we will
    unravel the dynamic optimization orchestrated by JIT compilation, where bytecode
    is translated into native machine code during runtime, unlocking new dimensions
    of performance for Java applications. Join us as we delve deeper into the evolving
    symphony of JVM execution, exploring the art of on-the-fly optimization and the
    unparalleled adaptability that JIT compilation brings to the world of Java programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 执行的复杂交响曲中，我们已经经历了加载、字节码解释、数据区初始化和本地集成等阶段，见证了将 Java 应用带入生命的无缝编排。随着本章的结束，它成为对即将到来的
    JIT 编译变革领域的探索的序曲。在下一节中，我们将揭示由 JIT 编译器编排的动态优化，在运行时将字节码转换为本地机器代码，为 Java 应用解锁新的性能维度。随着我们深入探索
    JVM 执行的演变交响曲，我们将探讨即时优化和 JIT 编译为 Java 编程世界带来的无与伦比的适应性。加入我们，一起深入了解。
- en: JIT compilation
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT 编译
- en: JIT compilation stands as a pivotal component in the JVM, revolutionizing the
    execution of Java applications. Unlike traditional **ahead-of-time** (**AOT**)
    compilation, where the entire code is translated into machine code before execution,
    JIT compilation occurs dynamically during runtime. This on-the-fly translation
    transforms Java bytecode into native machine code just before execution, optimizing
    performance and adaptability for the machine it runs on, considering which parts
    of the code are used the most and need to be optimized. This dynamic optimization
    process ensures that the JVM focuses on the most frequently executed portions
    of the code, effectively enhancing performance and adaptability to the specific
    runtime conditions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 编译是 JVM 的一个关键组件，彻底改变了 Java 应用的执行方式。与传统的前置编译（**AOT**）不同，前置编译是在执行之前将整个代码转换为机器代码，而
    JIT 编译是在运行时动态发生的。这种即时转换在执行前将 Java 字节码转换为本地机器代码，优化了性能和适应性，考虑了代码中使用最多且需要优化的部分。这种动态优化过程确保
    JVM 专注于代码中最频繁执行的部分，有效地提高了性能和适应性，以适应特定的运行时条件。
- en: The adoption of JIT compilation within the JVM is rooted in the pursuit of striking
    a balance between portability and performance. By interpreting bytecode initially
    and then selectively compiling frequently executed code paths into native machine
    code, the JVM harnesses the advantages of both interpreted and compiled approaches.
    This approach allows Java applications to maintain platform independence while
    achieving performance comparable to natively compiled languages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 中 JIT 编译的采用源于追求便携性和性能之间的平衡。通过最初解释字节码，然后选择性地将频繁执行的代码路径编译成本地机器代码，JVM 利用了解释和编译方法的优势。这种方法允许
    Java 应用保持平台独立性，同时实现与本地编译语言相当的性能。
- en: Within the intricate tapestry of JVM execution, the tiers of JIT compilation
    play a pivotal role in balancing adaptability with performance. Let’s delve into
    these levels, understanding why they exist and how they collectively enhance the
    execution of Java applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 执行的复杂织锦中，JIT 编译的层级在平衡适应性和性能方面发挥着关键作用。让我们深入了解这些级别，了解它们为什么存在以及它们如何共同增强 Java
    应用的执行。
- en: 'The presence of multiple JIT compilation levels allows the JVM to strike a
    delicate balance between the advantages of interpretation and the performance
    benefits of native machine code. The interpreter provides agility and platform
    independence, while the JIT compilers optimize hotspots, ensuring that Java applications
    adapt dynamically to their execution environment. This adaptive compilation approach
    is pivotal in achieving high-performance results without sacrificing the cross-platform
    nature of Java. Join us in the upcoming section as we dissect the inner workings
    of JIT compilation, unveiling how these levels collaborate to empower the Java
    runtime environment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 多个即时编译级别的存在使得 JVM 能够在解释的优势和本地机器代码的性能优势之间取得微妙的平衡。解释器提供了灵活性和平台独立性，而 JIT 编译器则优化热点，确保
    Java 应用能够动态适应其执行环境。这种自适应编译方法对于在不牺牲 Java 的跨平台性质的情况下实现高性能结果至关重要。在接下来的部分，我们将剖析 JIT
    编译的内部工作原理，揭示这些级别如何协作以增强 Java 运行时环境：
- en: '**Interpreter level**: At the interpreter level, the JVM utilizes an interpreter
    to execute Java bytecode dynamically. This interpreter is the initial bridge between
    the platform-independent bytecode and the underlying hardware. When a Java program
    is executed, the interpreter reads the bytecode instructions individually and
    translates them into machine code on the fly. While this approach offers advantages
    such as quick startup and platform independence, it introduces inherent overhead
    due to the interpretation process, which can impact execution speed.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器级别**: 在解释器级别，JVM使用解释器动态执行Java字节码。这个解释器是平台无关的字节码和底层硬件之间的初始桥梁。当Java程序执行时，解释器逐个读取字节码指令，并即时将它们翻译成机器码。虽然这种方法提供了快速启动和平台无关性等优势，但解释过程引入了固有的开销，这可能会影响执行速度。'
- en: The interpreter essentially acts as a swift executor, enabling Java applications
    to run on any platform without the need for precompiled native code. However,
    because of the real-time translation of bytecode to machine code during execution,
    the overall performance might not be as optimized as it could be. It is where
    the subsequent JIT compilation levels come into play, aiming to enhance performance
    by selectively translating and optimizing frequently executed code paths, known
    as hotspots, into native machine code. The interpreter level, therefore, provides
    a balance between agility and adaptability, laying the groundwork for the more
    advanced JIT compilation stages.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释器本质上是一个快速的执行器，使得Java应用程序能够在任何平台上运行，而无需预编译的本地代码。然而，由于执行过程中实时将字节码翻译成机器码，整体性能可能不如预期优化。这就是后续的即时编译级别发挥作用的地方，旨在通过选择性地翻译和优化频繁执行的代码路径（称为热点），将其转换为本地机器代码来提升性能。因此，解释器级别在敏捷性和适应性之间提供了平衡，为更高级的即时编译阶段奠定了基础。
- en: '**Baseline JIT compilation**: Baseline JIT compilation represents the next
    tier in the dynamic compilation process within the JVM. After the initial interpretation
    of bytecode, the JVM identifies specific sections of code frequently executed,
    known as hotspots. These hotspots are candidates for further optimization to enhance
    overall performance. It is where the baseline JIT compiler steps in.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基线即时编译**: 基线即时编译是JVM内动态编译过程中的下一级。在字节码的初始解释之后，JVM识别出频繁执行的特定代码段，称为热点。这些热点是进一步优化以提升整体性能的候选者。这就是基线即时编译器介入的地方。'
- en: In the baseline JIT compilation stage, the compiler employs selective compilation,
    targeting identified hotspots rather than the entire program. Focusing on frequently
    executed portions of the code translates them into native machine code just before
    execution. Emphasizing quick compilation for immediate performance enhancement,
    the baseline JIT compiler utilizes simple and rapid translation techniques, significantly
    improving over repeated interpretation. Dynamic adaptation is key, as the compiler
    continuously monitors the application’s execution, identifying and selectively
    compiling hotspots. This agile response ensures optimization efforts are concentrated
    on the most impactful areas, aligning with the evolving runtime behavior and optimizing
    for immediate performance gains.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在基线即时编译阶段，编译器采用选择性编译，针对已识别的热点而不是整个程序。专注于代码的频繁执行部分，在执行前将其转换为本地机器代码。强调快速编译以实现即时的性能提升，基线即时编译器使用简单且快速的翻译技术，显著优于重复的解释。动态适应是关键，因为编译器持续监控应用程序的执行，识别并选择性地编译热点。这种敏捷的响应确保优化努力集中在最有影响力的区域，与不断演变的运行时行为相一致，并优化即时性能提升。
- en: '**Dynamic adaptation**: Dynamic adaptation within baseline JIT compilation
    refers to the compiler’s agile response to the evolving runtime behavior of a
    Java application. Continuously monitoring the execution, the compiler identifies
    frequently executed code sections or hotspots and selectively compiles them into
    native machine code. This adaptive strategy ensures that the baseline JIT compiler
    focuses its optimization efforts on the most impactful areas, optimizing for immediate
    performance gains.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态适应**: 基线即时编译中的动态适应指的是编译器对Java应用程序运行时行为的演变所做出的敏捷响应。持续监控执行过程，编译器识别出频繁执行的代码段或热点，并将它们选择性地编译成本地机器代码。这种自适应策略确保基线即时编译器将优化努力集中在最有影响力的区域，以实现即时的性能提升。'
- en: The significance of dynamic adaptation lies in its ability to balance quick
    compilation and effective performance improvement. By tailoring its approach based
    on the runtime behavior, the compiler remains responsive to changes in the workload,
    refining its strategies to match the evolving execution patterns of the Java program.
    It ensures that the baseline JIT compilation, also known as the C1 compiler, remains
    a dynamic and effective component, optimizing Java applications in real time as
    they navigate diverse and dynamic workloads.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态适应的重要性在于其平衡快速编译和有效性能提升的能力。通过根据运行时行为调整其方法，编译器能够对工作负载的变化做出响应，优化其策略以匹配Java程序不断变化的执行模式。它确保基线JIT编译（也称为C1编译器）保持动态和有效，实时优化在多样化动态工作负载中导航的Java应用程序。
- en: Notably, this dynamic adaptation is the main difference from AOT compiled code.
    Such code always works the same way and is not capable of adapting to the *use
    case of the day*, something the JIT compiler handles perfectly. The JIT compiler’s
    ability to adjust its optimization strategies based on runtime behavior makes
    it a powerful tool for maximizing Java application performance in a wide range
    of scenarios.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，这种动态适应是AOT编译代码的主要区别。此类代码总是以相同的方式工作，并且无法适应“当天的用例”，这是JIT编译器完美处理的。JIT编译器根据运行时行为调整其优化策略的能力，使其成为在广泛场景中最大化Java应用程序性能的强大工具。
- en: In the culmination of our exploration into JIT compilation, we’ve witnessed
    the transformative power it wields in dynamically optimizing Java bytecode for
    enhanced performance. From the swift adaptability of the interpreter to the selective
    compilation prowess of the baseline JIT compiler, the intricate dance of JIT has
    unfolded. As we draw the curtain on this chapter, the stage is set for a more
    profound revelation—the role of class loading in Java’s runtime dynamics. Join
    us in the next section, where we will unravel the nuances of class loading, exploring
    how dynamically loading classes into the JVM forms the cornerstone of Java’s extensibility
    and dynamic nature. The continuum of our journey promises a seamless transition
    from the dynamic compilation orchestration of JIT to the backstage marvels of
    class loading.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索JIT编译的总结中，我们已经见证了它在动态优化Java字节码以提升性能方面的变革力量。从解释器的快速适应性到基线JIT编译器的选择性编译能力，JIT的复杂舞蹈已经展开。随着我们关闭这一章节的帷幕，舞台已经准备好揭示更深层次的奥秘——类加载在Java运行时动态中的作用。请加入我们下一部分的内容，我们将揭开类加载的微妙之处，探索如何将类动态加载到JVM中成为Java可扩展性和动态特性的基石。我们旅程的连续性承诺了一个从JIT动态编译编排到类加载幕后奇迹的顺畅过渡。
- en: Class loading
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载
- en: In this enlightening section, we dive deep into the intricate world of class
    loading, a cornerstone of Java’s dynamic and extensible nature. Join us as we
    unravel the mechanisms behind dynamic class loading, which allows Java applications
    to adapt and extend their functionality during runtime. We’ll explore `ClassLoader`,
    the unsung hero responsible for dynamically loading Java classes into the JVM.
    Gain insights into the nuances of the class loader hierarchy, understanding how
    different class loaders collaborate to assemble the rich tapestry of Java applications.
    From system class loaders to custom class loaders, we’ll traverse the layers underpinning
    Java’s ability to incorporate new classes and extend its functionality dynamically.
    Prepare for a journey into the heart of Java’s runtime dynamics, where the magic
    of class loading unfolds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启发性的部分，我们深入探讨了类加载的复杂世界，这是Java动态和可扩展特性的基石。随着我们揭开动态类加载背后的机制，我们将了解Java应用程序如何在运行时适应和扩展其功能。我们将探索`ClassLoader`，这位默默无闻的英雄，负责将Java类动态加载到JVM中。深入了解类加载器层次结构的微妙之处，理解不同的类加载器如何协作构建Java应用程序丰富多彩的画卷。从系统类加载器到自定义类加载器，我们将遍历支撑Java动态引入新类和扩展其功能的基础层。准备开始一段探索Java运行时动态核心的旅程，在这里，类加载的魔法得以展开。
- en: 'The realm of class loading in Java is delineated by two distinct entities:
    the bootstrap class loader, an integral part of the JVM, and user-defined class
    loaders. Each user-defined class loader, an instantiation of a subclass of the
    `ClassLoader` abstract class, empowers applications to customize how the JVM dynamically
    generates classes. These user-defined class loaders serve as conduits for extending
    the traditional means by which the JVM creates classes, allowing for the incorporation
    of classes from sources beyond the typical classpath.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的类加载领域由两个不同的实体界定：引导类加载器，它是JVM的一个组成部分，以及用户定义的类加载器。每个用户定义的类加载器都是`ClassLoader`抽象类的子类的实例化，它使应用程序能够自定义JVM动态生成类的方式。这些用户定义的类加载器作为扩展JVM创建类的传统手段的渠道，允许将来自典型类路径之外的来源的类纳入其中。
- en: When the JVM delegates the task of locating a binary representation for a class
    or interface named *N* to a class loader, denoted as L, it sets in motion a dynamic
    process. Class loader *L*, upon receiving this request, loads the specified class
    or interface *C* associated with *N*. This loading can occur directly, with L
    acquiring the binary representation and instructing the JVM to instantiate *C*
    from it. Alternatively, *L* may opt for an indirect loading approach by deferring
    the task to another class loader. This indirect loading may involve the delegated
    class loader loading *C* directly or employing further layers of delegation until
    *C* is eventually loaded. Such flexibility allows Java applications to seamlessly
    integrate classes from diverse sources, including those fetched over a network,
    generated on the fly, or extracted from encrypted files. The dynamics of user-defined
    class loaders thus play a pivotal role in shaping the extensibility and adaptability
    of Java applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM将定位名为*N*的类或接口的二进制表示的任务委托给一个名为L的类加载器时，它启动了一个动态过程。类加载器*L*在收到这个请求后，加载与*N*关联的指定的类或接口*C*。这种加载可以直接进行，L获取二进制表示并指示JVM从它实例化*C*。或者，*L*可以选择一种间接加载方法，将任务推迟给另一个类加载器。这种间接加载可能涉及委托的类加载器直接加载*C*，或者使用更进一步的委托层，直到*C*最终被加载。这种灵活性使得Java应用程序能够无缝地集成来自不同来源的类，包括通过网络获取的、即时生成的或从加密文件中提取的。因此，用户定义的类加载器的动态特性在塑造Java应用程序的可扩展性和适应性方面发挥着关键作用。
- en: Comprehending class loading and creation is essential for Java’s adaptability,
    facilitating the dynamic addition of classes during runtime. With the bootstrap
    class loader, the JVM checks if it has previously recorded this loader as the
    initiator for a given class or interface. The process concludes if recorded, and
    the identified class or interface is present. If not, the bootstrap class loader
    finds a representation, instructs the JVM to derive the class from it, and then
    creates it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解类加载和创建对于Java的可适应性至关重要，它促进了在运行时动态添加类。使用引导类加载器，JVM检查它是否以前记录了这个加载器作为给定类或接口的启动者。如果已记录，则过程结束，并且已识别的类或接口存在。如果没有，引导类加载器找到一个表示，指示JVM从它派生类，然后创建它。
- en: User-defined class loaders introduce a dynamic layer to this process. The JVM
    checks if a user-defined class loader has been recorded as the initiator for the
    identified class or interface. No further action is taken if recorded and the
    class or interface is present. Otherwise, the JVM invokes the class loader’s `loadClass`
    method, instructing it to either directly load and create the class or interface
    from the obtained bytes or delegate the loading process to another class loader.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类加载器给这个过程引入了一个动态层。JVM检查用户定义的类加载器是否被记录为已识别的类或接口的启动者。如果已记录并且类或接口存在，则不采取任何进一步行动。否则，JVM调用类加载器的`loadClass`方法，指示它直接从获取的字节加载和创建类或接口，或者将加载过程委托给另一个类加载器。
- en: The dynamic nature of class loading and creation, whether through the bootstrap
    class loader or user-defined class loaders, empowers Java applications with unparalleled
    flexibility. This adaptability allows for integrating classes from various sources,
    contributing to the extensibility and dynamism that define the Java programming
    language. Our exploration into class loading forms the foundation for understanding
    how Java seamlessly adapts and evolves at runtime, setting the stage for further
    revelations in the intricate symphony of Java’s runtime environment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载和创建的动态性，无论是通过引导类加载器还是用户定义的类加载器，赋予了Java应用程序无与伦比的灵活性。这种适应性允许从各种来源集成类，有助于定义Java编程语言的扩展性和动态性。我们对类加载的探索构成了理解Java在运行时无缝适应和演变的基础，为Java运行环境复杂交响乐中的进一步揭示奠定了基础。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude our exploration into the intricate realms of bytecode interpretation
    and execution within the JVM, we find ourselves standing at the gateway to a profound
    symphony—the orchestration of memory. The bytecode interpreter, a conductor in
    its own right, sets the tempo for the next chapter, where we will unravel the
    nuances of memory management within the JVM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索JVM中字节码解释和执行的复杂领域之后，我们发现自己站在一个深刻的交响乐——内存编排的门口。字节码解释器，作为其自身的指挥，为下一章设定了节奏，我们将揭示JVM内存管理的细微差别。
- en: In the preceding chapters, we deciphered bytecode’s journey, its interpretation,
    and the dynamic adaptations that breathe life into Java applications. Now, our
    journey propels us to the heart of the JVM’s inner workings—memory orchestration.
    Join us in the upcoming chapter as we navigate how the JVM allocates, utilizes,
    and deallocates memory, unveiling the artistry that ensures optimal performance
    and resource efficiency. The continuum of our exploration promises a deeper understanding
    of the symbiotic relationship between bytecode’s execution and the meticulous
    ballet of memory within the JVM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们解读了字节码的旅程，其解释以及赋予Java应用程序生命力的动态适应。现在，我们的旅程推动我们深入JVM内部工作的核心——内存编排。加入我们，在下一章中我们将探讨JVM如何分配、利用和释放内存，揭示确保最佳性能和资源效率的艺术。我们探索的连续性承诺对字节码执行与JVM内存内精细芭蕾之间的共生关系的更深入理解。
- en: Questions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: What is the purpose of the bytecode interpreter in the JVM?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中字节码解释器的目的是什么？
- en: Static code analysis
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Dynamic code execution
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态代码执行
- en: Memory allocation
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存分配
- en: Platform-specific compilation
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台特定的编译
- en: What does the term “hotspot” refer to in the context of baseline JIT compilation?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基线JIT编译的背景下，“hotspot”这个术语指的是什么？
- en: Code segments rarely executed
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很少执行的代码段
- en: Frequently executed code sections
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 频繁执行的代码段
- en: Compilation errors
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Interpreted bytecode
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释型字节码
- en: How does the bytecode interpreter contribute to platform independence in Java?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字节码解释器如何有助于Java平台的独立性？
- en: It performs static analysis
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行静态分析
- en: It interprets bytecode on the fly
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在运行时解释字节码
- en: It relies on platform-specific compilation
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它依赖于平台特定的编译
- en: It only works on certain operating systems
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它只在某些操作系统上工作
- en: What is the primary role of the baseline JIT compiler in JVM optimization?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线JIT编译器在JVM优化中的主要角色是什么？
- en: Quick compilation for all code segments
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有代码段进行快速编译
- en: In-depth analysis of code behavior
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码行为的深入分析
- en: Static translation of bytecode
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字节码的静态转换
- en: Selective compilation of frequently executed code
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对频繁执行的代码进行选择性编译
- en: How does dynamic adaptation contribute to baseline JIT compilation’s effectiveness?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态适应如何有助于基线JIT编译的有效性？
- en: By ignoring runtime behavior
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过忽略运行时行为
- en: By compiling the entire program at once
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一次性编译整个程序
- en: By adapting to changes in workload
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过适应工作负载的变化
- en: By prioritizing seldom-executed code
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过优先处理很少执行的代码
- en: Answers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: B. Dynamic code execution
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 动态代码执行
- en: B. Frequently executed code sections
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 频繁执行的代码段
- en: B. It interprets bytecode on the fly
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 它在运行时解释字节码
- en: D. Selective compilation of frequently executed code
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 对频繁执行的代码进行选择性编译
- en: C. By adapting to changes in workload
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 通过适应工作负载的变化
