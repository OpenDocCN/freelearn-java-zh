- en: An Introduction to Scala 2.13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment of this writing, Scala 2.13 has reached its five-year milestone
    and approaches the first release candidate. At this point, its feature set is
    unlikely to change and it is safe to take a look at the new features of the update.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the scope of the release, placing the main
    focus of the conversation on its centerpiece—the new collection library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Scala 2.13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features of Scala 2.13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scala 2.13 collection library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Scala 2.13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala 2.13 is the latest minor update of the Scala programming language. Despite
    looking like a minor bump in the version number, this release is much more important
    than it might appear.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that its main focus is the reworked collection library,
    which is going to replace the current version introduced in version 2.8 and slightly
    redesigned in version 2.9.
  prefs: []
  type: TYPE_NORMAL
- en: The new collection framework is here to stay in Scala 2 and also will become
    a part of Scala 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is mostly a library release, the language itself is not changing a lot
    as compared to the previous version. Apart from the collections, the new version
    improves on three aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizes the core library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeds up the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improves user-friendliness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These details are outside of the scope of this book and we will not discuss
    them further.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, there is an addition of literal and singleton types, which we
    will discuss in detail in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding
    Types in Scala*, and a few minor changes to the standard library which we'll look
    at next, before diving into the sea of maps and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Eager to look into the future? We'll take you there!
  prefs: []
  type: TYPE_NORMAL
- en: New features of Scala 2.13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss a few small improvements in the new version,
    which are not related to the collections topic and don't really belong to some
    bigger topic, such as optional parsing for string literals, adding names-reporting
    functions to case classes, methods for chaining operations, and automatic resource-management.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parsing for string literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala 2.13, `StringOps` has been extended with methods that return `Option` for
    string-literals parsing. Supported types include all numeric types and `Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new methods can greatly simplify the processing of user-provided data without
    the need to wrap the calls with the exception-handling, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The optional `Boolean` parsing ignores the case of the argument the same way
    the exception-throwing `toBoolean` method does.
  prefs: []
  type: TYPE_NORMAL
- en: Products can report the names of their element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature probably will be mostly useful for the case classes as it makes
    possible some generic programming without the need to resort to reflection or
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples demonstrate how the new `productElementName(idx)` method
    can be used to build a naive JSON serializer for simple case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this simple iteration does not take nesting and escaping into account,
    but it already can produce valid results in elementary cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the method taking an index of the element throws an exception
    in the case that the index is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss why throwing exceptions is not the best approach, as well as
    viable alternatives, in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects.*
  prefs: []
  type: TYPE_NORMAL
- en: Added methods for chaining operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Via `import scala.util.chaining._`, it is now possible to add `tap` and `pipe`
    methods to instances of any type. The functionality is provided by an implicit
    conversion to `ChainingOps`. We will look at implicits in detail in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to Know Implicits and Type Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: The `pipe` method applies a given function to the value and returns the result.
    It might be helpful in situations where it is desirable to convert nested function
    calls into the fluid-interface-like code. The following snippet shows an example
    of an imaginary user database with nested function calls chained via `pipe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following the database interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We could apply all three actions to the user at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`pipe` allows us to represent this in a more readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguably the same (or an even clearer) result could be achieved by combining
    functions before applying them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will look at functions in general, and function composition in particular, in
    [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep Dive into Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: '`tap` applies a function given as an argument solely for the side-effects it
    produces and returns the original value. It might be useful, for example, for
    logging purposes and the simplest kind of performance measurements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next snippet demonstrates an elementary side-effect-causing performance-tracking
    implementation that utilizes a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a global value of the `AtomicLong` type to store the last measured timestamp.
    Then we define a polymorphic `measure` method that captures the time between the
    moment of the last measurement and now, and a `start` method to reset the clock.
    After that, we can use the `tap` method to track the execution times of our actions.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about types and polymorphism in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml),
    *Understanding Types in Scala*, side-effects and more general concept of effects
    in [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    and show drawbacks of having global variables and a global state in [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Resource Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala 2.13 adds a practical way to automatically manage resources. We will discuss
    other ways to manage resources and implement dependency-injection in [Chapter
    9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing Yourself with Basic
    Monads* and 10. `scala.util.Using` allows us to do this in a familiar side-effecting
    way. All operations on the resource are wrapped in a `Try`, which we'll talk about
    in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*. If `Exceptions` is thrown, the first one is returned within a `Try`.
    The exception-handling is quite sophisticated in some corner cases and we invite
    the reader to consult ScalaDoc for a detailed description of it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Using` is a class that takes some resources as a by-name parameter. The resource
    can be anything that has a type class instance for `scala.util.Resource` available.
    Such an instance for `java.lang.AutoCloseable` is provided in the standard library.
    We will study type classes in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to Know Implicits and Type Classes*. `Using` also has a monadic interface,
    which allows us to combine multiple resources in for-comprehensions. We''ll discuss
    monads in [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the practical application of `Using`. We will define
    a resource that implements `AutoCloseable` and a few of these resources in for-comprehension
    as a source of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output in the console demonstrates that the result contains lines from all
    of the resources, and the resources themselves are automatically closed in the
    reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after this small warm-up, we are ready to dive into the foundation of version
    2.13—the new collection library.
  prefs: []
  type: TYPE_NORMAL
- en: The Scala 2.13 Collection Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala 2.13 delivers a new collection library, for historical reasons it is also
    known as "collection - strawman". The refactoring of the library pursued a few
    main goals, such as fixing common gotchas of the previous version, simplifying
    its implementation and internal structure, as well as usage and backward-compatibility,
    achieving better integration with lazy collections and java streams and cleaner
    API separation between mutable and immutable collections, improving performance,
    and, last but not least, minimizing the migration effort from Scala 2.12's collections.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we have a library that is mostly source-compatible with the previous
    version, has many old methods and types (such as `Traversable`, `TraversableOnce`,
    and `Stream`) deprecated, and has a simpler internal hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that the reader has a rudimentary understanding of Scala collections.
    With this assumption, the next section will take a holistic approach and focus
    on giving a consistent overview of the new collection framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram represents the top-level hierarchy of the collection library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47a0c9a1-6d31-418b-821d-9e270f3764fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here and further, we will pretend to always have `import scala.collections._` in
    the scope and use the following colour encoding in our diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/556be524-da3b-4ac4-b942-26d184f88e16.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of the traits describes the structure, the *essence* of the collection.
    As the name suggests, `IterableOnce` can be iterated over only one time. `Iterable`
    softens this constraint so that it is possible to iterate over the collection
    multiple times. `Seq` adds a notion of succession to the elements of the collection, `Set` adds
    a constraint of the uniqueness of its elements, and `Map` changes the type of
    the collection from a single element, `A`, to a pair of key, `K`, and value, `V`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, in the spirit of the separation of concerns, these traits cover
    only the structural characteristics. The operations defined for the specific type
    are placed in the helper traits carrying the `Ops` suffix in the name. These traits
    form a hierarchical structure similar to the previous one, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d47f2cb-69cf-454c-ba06-d4ac95462481.png)'
  prefs: []
  type: TYPE_IMG
- en: Where the "normal" traits had only one type parameter, the type of the element,
    the `Ops` have three of them. In addition to the type of the element, `A`, the `C` type
    describes the specific *representation *type of the collection this trait is mixed
    into and thus to the return type of the first-order methods defined on this collection.
    The `CC` type refers to the representation type that can be returned by the higher-order
    methods, or the type constructor. We will see later in this chapter how this works
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Because the inheritance tree is structured as it is, `IterableOps` and `IterableOnceOps`
    are effectively mixed into every collection implementation in the library. Three
    traits on the bottom just add some more methods, unique to the specific collection
    type, and override some of the definitions for efficiency. Both `Iterable*Ops`
    traits define more than a hundred of methods and they are the reason the Scala
    collection library is very consistent and homogenous.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the importance of `IterableOnceOps` and `IterableOps`, we will take
    a detailed look at them in the next section. After that, we will explore the unique
    features of the specialized collections.
  prefs: []
  type: TYPE_NORMAL
- en: IterableOnceOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IterableOnceOps` represents a blueprint for the collections that can be traversed
    one or multiple times. It defines a few abstract methods that must be implemented
    by every collection and a number of concrete methods implemented in terms of an
    iterator available from `IterableOnce`. The concrete methods provide default,
    if possible, lazy, implementations and fall into one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size operations:** `isEmpty`, `nonEmpty`, `size`, `knownSize`, and `isTraversableAgain`
    check the collection for (non) emptiness or return its size. `knownSize` is an
    optimization that returns `-1` if the size cannot be determined without iterating
    over the collection. `isTraversableAgain` returns `false` for `IterableOnce`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element tests:** `forall`, `exists`, and `count` check whether all, at least
    one, or some number of elements satisfy the given predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String operations:** `mkString` and `addString`. These methods with different
    argument sets provide a possibility to build alternative string representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversions to another collections:** `copyToArray`, `toList`, `toMap`, `to`,
    `toSet`, `toSeq`, `toIndexedSeq`, `toBuffer`, and `toArray`. These methods copy
    or convert an `Iterable` into another collection. The `to` method is special in
    this list because it allows us to return any type of the collection that has a
    `Factory` available. We will look at it in more detail soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fold and reduce:** `foldLeft`, `foldRight`, `reduce`, `reduceLeft`, `reduceRight`, `reduceOption`, `reduceLeftOption`,
    and `reduceRightOption` apply a binary operation to the elements of the collection.
    The `reduce*Option` methods handle the case of an empty collection gracefully
    by returning `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numeric combinations:** `sum` and `product` calculate the sum or product
    of the elements if there is an implicit `Numeric[B]` such that `B >: A` is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordering combinations:**  `min`, `minOption`, `max`, `maxOption`, `maxBy`,
    `maxByOption`, `minBy`, and `minByOption` find an element of the collection that satisfies
    giving predicate if there is an implicit `Ordering[B]` with `B >: A` available.
    The `*Option` methods return `None` for an empty collection instead of throwing
    an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrieval:** `collectFirst` and `find`. Choose an element that satisfies
    a given condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equality:** `corresponds` is an alternative way to compare collections. Satisfied
    if every element of this collection relates to matching element of another collection
    by given predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Abstract methods fall into one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `filter`, `filterNot`, `take`, `takeWhile`, `drop`,
    `dropWhile`, `slice`, and `span`. Take or discard elements that satisfy the given
    predicate or range, from the whole collection or beginning of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `map`, `flatMap`, `collect`, and `scanLeft`. Transforms elements
    of the collection by applying some function and possibly filtering the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zippers:** `zipWithIndex` adds an index to all elements of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IterableOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IterableOps` extends `IterableOnceOps` and contains methods that is impossible
    to implement without a possibility to iterate over the collection multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They fall into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `head`, `headOption`, `last`, and `lastOption` return
    the first or last element of the collection throwing `NoSuchElementException`
    or returning `None` for an empty collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size:** `sizeCompare` is an optimization that allows us to efficiently compare
    the size of the collection with given value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `partition`, `partitionWith`, `splitAt`, `takeRight`,
    `dropRight`, `grouped`, `sliding`, `tail`, `init`, `groupBy`, `groupMap`, `groupMapReduce`, `tails`,
    and `inits`. These split the collection as defined by some predicate or index,
    take or drop elements from the end, group elements by some criteria or predicate
    possibly applying transformative function, and discard first or last elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `scanRight` produces a collection containing the cumulative results
    of applying the giving function starting from the end of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition:** `concat, ++` returns another collection containing all elements
    of this collection and a collection provided as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zippers:** `zip`, `zipAll`, `unzip`, and `unzip3` combine the elements of
    the collection with the elements of another collection into a product, or split
    them into separate collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformation:** `transpose` transforms the collection of collections by
    turning rows into columns and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following methods that defined the abstract in `IterableOnceOps` got a
    concrete default implementation in `IterableOps`: `filter`, `filterNot`, `take`,
    `takeWhile`, `span`, `drop`, `dropWile`, `slice`, `scanLeft`, `map`, `flatMap`,
    `flatten`, `collect`, and `zipWithIndex`. `isTraversableAgain` is overriden to
    return `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that `Iterable` and `IterableOnce` do not support a general-equality
    operation, it is defined on specific collection subtypes. Because of this, it
    is impossible to compare these types directly using the equality operation, as
    the following example suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also there are three special methods that deserve our additional attention
    because they introduce types we haven''t met yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def withFilter(p: A => Boolean): collection.WithFilter[A, CC]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def iterableFactory: IterableFactory[CC]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def view: View[A]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them quickly before moving on to more specific collection types.
  prefs: []
  type: TYPE_NORMAL
- en: WithFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WithFilter` is a template class that contains the `map`, `flatMap`, `foreach`,
    and `withFilter` methods of `Iterable`. It allows us to specialize mapping and
    filtering operations for distinguished collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of its technical nature, we won't go into further details here.
  prefs: []
  type: TYPE_NORMAL
- en: IterableFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`trait IterableFactory[+CC[_]]` is a base trait for companion objects for specific
    collections which provides a number of operations to create a specific collection
    with the type specified by the `CC` type constructor; this is sometimes called
    *target-type driven building* because the type of the source collection is ignored.
    Most of the companion objects in the collection library extend this trait, which
    makes it possible to use them in places where `IterableFactory` is expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is the main abstraction that allows to build a collection from scratch,
    it is useful to know which methods it supplies. All of them return `CC[A]`. The
    following table contains a short summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `def from[A](source: IterableOnce[A])` | Creates a target collection from
    existing `IterableOnce`. |'
  prefs: []
  type: TYPE_TB
- en: '| `def empty[A]: CC[A]` | An empty collection, often defined as an object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `def apply[A](elems: A*): CC[A]` | Creates a collection from the `elems`
    given as var-arg. |'
  prefs: []
  type: TYPE_TB
- en: '| `def iterate[A](start: A, len: Int)(f: A => A): CC[A]` | Fills the collection
    with values taken from the result of the application of `f` on `start`, then on
    produced values and so on, `len` number of times. |'
  prefs: []
  type: TYPE_TB
- en: '| `def range[A : Integral](start: A, end: A, step: A): CC[A]` | Collection
    containing increasing integers [`start`, `end`-1] with difference between successive
    numbers of `step`. There is also a version of this method with default value of `step
    = 1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `def fill[A](n: Int)(elem: => A): CC[A]` | Fills the collection with `n` evaluations
    of `elem`. There are variations of this function that go up to five dimensions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `def tabulate[A](n: Int)(f: Int => A): CC[A]` | The same as `fill`, but using
    index as an argument for the evaluation. Similarly, there are variations of this
    function that go up to five dimensions. |'
  prefs: []
  type: TYPE_TB
- en: '| `def concat[A](xss: Iterable[A]*): CC[A]` | Concatenates all argument collections
    into a single collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `def unfold[A, S](init: S)(f: S => Option[(A, S)]): CC[A]` | Calls `f` to
    produce the element of the collection using and modifying the internal state starting
    with the `init` state. |'
  prefs: []
  type: TYPE_TB
- en: Arguably, `IterableFactory` provides a lot of different possibilities to create
    a collection of a desired type.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`View` has been reimplemented in the new version of the library. Now it represents
    a reified `Iterator` operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Reification is the process by which an abstract idea about a computer program
    is turned into an explicit data model or other object created in a programming
    language ([https://en.wikipedia.org/wiki/Reification_(computer_science)](https://en.wikipedia.org/wiki/Reification_(computer_science))[).](https://en.wikipedia.org/wiki/Reification_(computer_science))
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the `Iterator` methods are represented as a subclasses of `View`
    and encapsulate transformations to apply. The evaluation happens at the moment
    the view is converted to the strict collection type, or traversed, for example
    using the `foreach` method. Views don''t *remember* the type of the source collection.
    This can be demonstrated by the following example. First, we define a generic
    transformation that might be strict or lazy, depending on the type of the collection
    given as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for each transformation step, we print out its result in the console
    at the moment the step happens. Now we can compare lazy and strict collection
    behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet produces the following output in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we can see that the `take` method is always evaluated strictly
    regardless of the underlying collection type—this is commented as `A` in the preceding
    code. The second and third lines show the strict evaluation for `List[Char]`,
    line `B` in the code. Lines 4 and 5 demonstrate that `View[Char]` is then evaluated
    twice, each time at the moment it is forced, once by calling `foreach` (line `C`)
    and once by converting it to the `List` (line `D`). Also interesting is that `map`
    is only applied to the results of the `take` method even given the fact that `map`
    is the first transformation step in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Set` is a base trait for collections that have a notion of uniques of the
    elements. It is defined as `trait Set[A] extends Iterable[A] with SetOps[A, Set,
    Set[A]] with Equals`. We can see that it is effectively an `Iterable` that has
    some additional operations defined in `SetOps` and adds a notion of equality among
    sets. The sub-hierarchy of `Set` is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bf8e356-9aa9-488b-8758-6a084cda8847.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previously mentioned `SetOps` adds a few methods on top of `IterableOps`.
    These methods are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `contains` and `apply` return `true` if this set contains
    a given element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equality:** `subsetOf` and `subsets` check whether this set is a subset of
    another set, or return all subsets of this set, possibly with a given size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combinations with another set:** `intersect`, `&`, `diff`, `&~`, `concat`,
    `++`, `union`, and `|`. These methods compute the intersection, difference, or
    union of this and another set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few classes in the hierarchy that augment `Set` with further properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SortedSet** extends `Set` with `SortedOps[A, +C]` and has two immutable and
    two mutable implementations—two `TreeSets` and two `BitSets`. `SortedOps` embodies
    following methods that depend on the notion of `Ordering`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key retrieval:** `firstKey` and `lastKey` return the first or last element
    of this collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `range`, `rangeFrom`, `rangeUntil`, and `rangeTo`
    create a ranged projection of this collection, satisfying given criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of the overloading, `SortedSet` has many overloaded methods defined
    twice, with and without ordering. If an operation is intended to be applied to
    the underlying unsorted `Set`, the type has to be coerced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that direct type-ascription will not work in the case of `Set`
    because its definition is invariant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The invariance of `Set` is related to the fact that `Set[A]` extends a function, `A
    => Boolean`, that returns `true` if the set contains a given element. Thus, sets
    can be used in places where such one argument function is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four more specific set implementations in addition to `TreeSet` and
    `BitSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListSet` implements immutable sets using a list-based data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The immutable HashSet realizes immutable sets using a Compressed Hash-Array
    Mapped Prefix-tree (CHAMP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutable `HashSet` and `LinkedHashSet` implement mutable sets using a hash
    table, storing the data unordered and ordered, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sets are closely related to `Map`, which represents a collection with elements
    represented as a pair of keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Map` is defined as `trait Map[K, +V] extends Iterable[(K, V)] with MapOps[K,
    V, Map, Map[K, V]] with Equals` which makes it an `Iterable` over pairs of key, `K`,
    and value, `V`. It also defines a notion of equality among maps. The class hierarchy
    for `Map` is represented on the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fda9483-e5d1-41c5-9896-324d26c4f805.png)'
  prefs: []
  type: TYPE_IMG
- en: There are three different `MapOps`, one general for both mutable and immutable,
    and one specific for each of these forms.
  prefs: []
  type: TYPE_NORMAL
- en: '`MapOps` extends `IterableOps` with the following specific operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `get`, `getOrElse`, `apply`, `applyOrElse`, `default`,
    `contains`, and `isDefinedAt`. These methods allow us to retrieve a value or check
    whether a value is present by a given key, optionally returning a default value
    or throwing an exception if the key can''t be found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `keySet`, `keys`, `values`, `keysIterator`, and `valuesIterator`
    allow us to get a keys or values in different forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `map`, `flatMap`, and `collect` are transforming and optionally
    filtering the pairs of keys and values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition:** `concat` returns a new collection with elements of both maps
    combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`immutable.MapOps` adds the following methods on top of `MapOps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element removal**: `remove`, `removeAll`, `--` removes one or all given elements
    from the map returning new map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element updates**: `updated` and `+` update an element with the given key
    returning new map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `transform` applies a given function to all elements, producing
    a new map with the returned results as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutable.MapOps` has a different set of methods as compared to the mutable
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element addition:** `put` adds a new value or updates existing one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element update:** `updated`, `+`, and `getOrElseUpdate` updates a value in
    place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element removal:** `remove` and `clear` remove one or all elements of the
    map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering:** `filterInPlace` retains only mappings that satisfy the predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `mapValuesInPlace` applies a transformation to the values of the
    map, storing returned results as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general `Map` definition has quite a few specialized subtypes, as shown
    in the preceding diagram. We will take a quick look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: SortedMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SortedMap` is similar to `SortedSet`. It has a two implementations, a mutable
    and immutable `TreeMap`, and provides a few methods defined in terms of `SortedOps`
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `iteratorFrom`, `keysIteratorFrom`, `valuesIteratorFrom`,
    and `rangeTo` give us a way to get elements of the map as an iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrieval:** `firstKey`, `lastKey`, `minAfter`, and `maxBefore` allow
    us to retrieve an element that satisfies some ordering condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HashMap` is also available in two flavors—immutable and mutable.'
  prefs: []
  type: TYPE_NORMAL
- en: The immutable `HashMap` is implemented using a CHAMP tree.
  prefs: []
  type: TYPE_NORMAL
- en: The mutable `HashMap` implements mutable maps using a hashtable. A hash table
    stores its elements in an array. The hash code of the item is used to calculate
    the position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: MultiMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MultiMap` is a trait for mutable maps that have multiple values assigned to
    a key.'
  prefs: []
  type: TYPE_NORMAL
- en: It defines the `addBinding`, `removeBinding` and `entryExists` methods, which
    can be used to query or manipulate entries for a key.
  prefs: []
  type: TYPE_NORMAL
- en: SeqMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SeqMap` is a generic abstraction for ordered immutable maps. `SeqMap` itself
    exists in mutable and immutable forms. These forms have few different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: The immutable **ListMap** implements immutable maps using a list-based data
    structure. The methods traversing `ListMap` visit its elements in the order they
    were inserted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutable **ListMap** is a simple mutable map backed by a list. It preserves
    insertion order as its immutable sibling does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VectorMap** exists only in immutable form. It is implemented using a vector/map-based
    data structure and preserves insertion order. It has constant lookup but slower
    other operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinkedHashMap** is a mutable map whose implementation is based on a hashtable
    and preserves the insertion order if iterated over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Seq` is probably the most ubiquitous collection in the library. Like `Map`,
    it has a notion of succession of elements and the elements have indices. It is
    defined as `trait Seq[+A] extends Iterable[A] with PartialFunction[Int, A] with
    SeqOps[A, Seq, Seq[A]] with Equals`. Also similar to map, `Seq` specifies support
    for the equality relation and also extends `PartialFunction`, which accepts an index
    of the element as a parameter. As there are a lots of classes implementing `Seq`,
    we will take a gradual approach and look at them level by level. The direct children
    of `Seq` are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e4bd4e9-fc44-4f3e-85e4-a72b74f64192.png)'
  prefs: []
  type: TYPE_IMG
- en: '`scala.Seq`, known from previous Scala versions, is now replaced by `scala.collection.immutable.Seq`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other collections, `SeqOps` extend `IterableOps` by adding quite a
    few methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `apply` retrieves an element with a given index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexing and search:** `segmentLength`, `isDefinedAt`, `indexWhere`, `indexOf`,
    `lastIndexOf`, `lastIndexWhere`, `indexOfSlice`, `lastIndexOfSlice`, `containsSlice`,
    `contains`, `startsWith`, `endsWith`, `indices`, and `search`. These methods allow
    us to retrieve information about the presence or indexes of elements or subsequences given
    some predicate or element value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size:** `length` and `lengthCompare` provide efficient operations to retrieve
    the length of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition:** `prepend`, `+`, `appended`, `:+`, `prependAll`, `++`, `appendedAll`,
    `:++`, `concat`, and `union`. Can be used to append or prepend one or multiple
    elements to the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering:** `distinct` and `distinctBy` remove duplicates, possibly given
    some predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reversal:** `reverse` and `reverseIterator` return a new collection with
    elements in the reversed order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting:** `sorted`, `sortWith`, and `sortBy` sort this collection by some
    implicit `Ordering`, or by a given function, or both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equality:** `sameElements` and `corresponds` check whether this collection
    contains the same elements in the same order as given, using equality-checking
    or the provided comparison function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `permutations` and `combinations`. These methods
    allow us to retrieve a subcollection(s) that satisfies given conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updates:** `diff`, `intersect`, `patch`, `updated`, and `update` (mutable).
    Modify elements of this collection using another collection or element and returning
    another collection (except the last method defined on `mutable.Seq`, which update
    elements in place).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the `Seq` direct descendants has its own specific properties and a subtree
    of implementations. We'll breeze through them now.
  prefs: []
  type: TYPE_NORMAL
- en: IndexedSeq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IndexedSeq` does not introduce new operations, at least not in its immutable
    incarnation, but overrides a lots of methods defined in `SeqOps` to provide more
    efficient implementations. There are four classes implementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/314b6c54-94c0-4556-ac2a-4f976b9e1c99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `mutable.`** IndexedSeq** adds the following **mutation options**: `mapInPlace`,
    `sortInPlace`, `sortInPlaceWith`, and `sortInPlaceBy`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mutable.`** ArraySeq** is a collection representing an `Array`. It defines
    an `array` method returning an underlying array, and an `elemTag` method that
    returns the tag of the element type needed to properly support different kinds
    of arrays as required by the JVM. Because of this requirement, it has separate
    implementations for all primitive types including numeric types (in addition to
    `ofByte`, there are implementations for all other numeric primitives, not shown
    on the diagram) and `Boolean`, `AnyRef` and `Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: The `immutable.`** ArraySeq** was added in the version 2.13\. It is an effectively
    an immutable sequence that wraps an array and is used to pass varargs parameters.
    It has the same descendants as its mutable cousin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Range** is an immutable structure that contains integer values. It is defined
    by `start`, `end`, and a `step`. There are two additional methods available: `isInclusive`,
    which is `true` for `Range.Inclusive` and `false` for `Range.Exclusive`, and `by`,
    which creates the new range with a different `step` but the same `start` and `end`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector** is an immutable structure that provides constant-time access and
    updates and fast append and prepend. Because of this, `Vector` is the default
    implementation for `IndexedSeq`, as demonstrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`WrappedString` is an immutable wrapper over some `String`. It extends strings
    with all of the operations defined in `IndexedSeqOps`.'
  prefs: []
  type: TYPE_NORMAL
- en: LinearSeq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linear sequences have the notion of a head and a tail. The definition looks
    like `trait LinearSeq[+A] extends Seq[A] with LinearSeqOps[A, LinearSeq, LinearSeq[A]]`
    and the class diagram is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b71e25fd-af3f-408d-a9a1-8e115321176c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three representatives of `LinearSeq`, all are immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List** defines three symbolic methods which provide a nice syntax for pattern-matching
    and building lists. `::` prepends element to the list, `:::` prepends all elements
    of a given list, and `reverse_:::` prepends all elements of a given list but in
    the reverse order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LazyList** is a new immutable collection available since Scala 2.13\. It
    implements a list with a `head` and a `tail`, which are not evaluated until needed.
    As it is superior to `Stream`, which is only lazy in the tail, `Stream` is now
    deprecated. `LazyList` has two additional methods, `force` which evaluates it,
    and `lazyAppendAll` which lazily appends a given collection to this list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue** in this hierarchy is also immutable. It allows a first-in-first-out
    (FIFO) insertion and retrieval of the elements. For this functionality, it defines
    the `enqueue`, `enqueueAll`, `dequeue`, `dequeueOption`, and `front` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Buffers` conclude our rush through the collection library. In essence, `Buffer`
    is just a `Seq` that can grow and shrink. This sub-hierarchy exists only in immutable
    form, though `IndexedBuffer` inherits from both Buffer and `IndexedSeq`, as shown
    by the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2abfd717-cfc0-4baa-bd63-0acf4e4f3cde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the methods that these collections define, in addition
    to the definitions inherited from `SeqOps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer** defines methods to add or remove one or more elements in place or returning
    new buffer: `prepend`, `append`, `appendAll`, `+=:`, `prependAll`, `++=:`, `insert`, `insertAll`,
    `remove`, `subtractOne`, `trimStart`, `trimEnd`, `patchInPlace`, `dropInPlace`,
    `dropRightInPlace`, `takeRightInPlace`, `sliceInPlace`, `dropWhileInPlace`, `takeWhileInPlace`,
    and `padToInPlace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ListBuffer** is a concrete buffer implementation baked by a `List`. In addition
    to other discussed methods, it provides `prependToList`, which allows us to prepend
    this collection to another list and a triple of `mapInPlace`, `flatMapInPlace`,
    and `filterInPlace`, giving us a possibility to modify elements in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a `Buffer`, add an `IndexedSeq`, and you'll get an **IndexedBuffer**. Similar
    to `ListBuffer`, it provides the `flatMapInPlace` and `filterInPlace` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ArrayBuffer** is a concrete implementation of `IndexedBuffer` that uses an
    array to store its elements and has a constant time for append, update, and random
    access. It has a `sizeHint` method, which can be used to enlarge the underlying
    array. It is a default implementation instantiated if `mutable.Seq` is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ArrayDeque** is another efficient collection that emerged in the 2.13 version. It
    implements a double-ended queue that internally uses a resizable circular buffer.
    This allows to have a constant time for append, prepend, remove first, remove
    last, and random-access operations. There are lots of additional methods available
    on this collection, mostly because of the notion of the second-end: `removeHeadOption`,
    `removeHead`, `removeLastOption`, `removeLast`, `removeAll`, `removeAllReverse`,
    `removeHeadWhile`, `removeLastWhile`, `removeFirst`, `removeAll`, `clearAndShrink`,
    `copySliceToArray`, and `trimToSize`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Queue** in this hierarchy is mutable. It is based on `ArrayDeque` and
    allows us to insert and retrieve elements in the FIFO manner. The following methods
    are available for that: `enqueue`, `enqueueAll`, `dequeue`, `dequeueFirst`, `dequeueAll`,
    and `dequeueWhile.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Stack** is similar to `Queue`, but it implements in last-in-first-out
    (LIFO) order instead of FIFO. The methods it defines are formulated in the corresponding
    terms: `push`, `pushAll`, `pop`, `popAll`, `popWhile`, and `top`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala Collection Contrib library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Needless to say, the standard Scala collection library is very rich and provides
    collections for most of the common use cases. But of course, there are some other structures
    that might be useful in a number of specific situations. The Scala Collection
    `Contrib` module is Scala's way of having both a stable standard library and some
    extra features. In a sense, this module is an incubator for the new collection
    types; types that prove to be useful for a broad audience will presumably be incorporated
    into the standard library in further Scala versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are four collection types available in the module, each both
    mutable and immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MultiDict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMultiDict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMultiSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also this library provides a possibility to define additional operations on
    existing collections via an implicit enrichment. The following import is required
    to make it available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And it delivers these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Seq: `intersperse` and `replaced`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Map: `zipByKey`, `join`, `zipByKeyWith`, `mergeByKey`, `mergeByKeyWith`, `fullOuterJoin`,
    `leftOuterJoin`, and `rightOUterJoing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please consult the module documentation at [https://github.com/scala/scala-collection-contrib](https://github.com/scala/scala-collection-contrib)
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala 2.13 is a minor update of Scala with the main focus on the redesigned
    collection library. The few small additions to the standard library, such as automatic
    resource management, just accentuate this fact.
  prefs: []
  type: TYPE_NORMAL
- en: The new collection library mainly consists of two intermixed inheritance hierarchies
    with a similar shape. Members of the first hierarchy describe the structure of
    the collection and members of the second hierarchy—operations available on this
    collection type. Because of the inheritance relations, the collections situated
    lower in the tree define additional methods for more specific collections and
    override methods defined by the parent traits to provide more efficient implementation
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: The three main collection types are `Seq`, `Set`, and `Map`. Each of these types
    has multiple implementations that are useful in specific situations. Set is also
    a function of one argument; `Seq` and `Map` are `PartialFunctions`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the collections are available in mutable and immutable forms.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the collection hierarchies, there is a concept of View, which
    is a reified definition of iterators’ operations and can be used to lazily apply
    transformations to the collection. Another related abstraction is `IterableFactory`,
    which implements some general ways to create collection instances and to perform
    conversions between collection representations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our focus from the new features of version
    2.13 to a general exploration of Scala, starting with its type system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describe two ways to make it possible for some resource, `R`, to use it together
    with `scala.util.Using` resource management utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can an instance of a `Set` and an instance of a `List` be compared to each
    other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the default concrete implementation for an immutable `Seq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the default concrete implementation for an immutable indexed `Seq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the default concrete implementation for a mutable `Seq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the default concrete implementation for a mutable indexed `Seq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is sometimes said that `List.flatMap` is more powerful than it was expected
    to be. Can you explain why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe a way to map over a collection multiple times using different functions
    but without producing intermediate collections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mads Hartmann, Ruslan Shevchenko, Professional Scala: Write concise and expressive,
    type-safe code in an environment that lets you build for the JVM, browser, and
    more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vikash Sharma, *Learning Scala Programming: **Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
