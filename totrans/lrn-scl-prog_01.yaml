- en: An Introduction to Scala 2.13
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment of this writing, Scala 2.13 has reached its five-year milestone
    and approaches the first release candidate. At this point, its feature set is
    unlikely to change and it is safe to take a look at the new features of the update.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the scope of the release, placing the main
    focus of the conversation on its centerpiece—the new collection library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Scala 2.13
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features of Scala 2.13
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scala 2.13 collection library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 1.8+
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Scala 2.13
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala 2.13 is the latest minor update of the Scala programming language. Despite
    looking like a minor bump in the version number, this release is much more important
    than it might appear.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that its main focus is the reworked collection library,
    which is going to replace the current version introduced in version 2.8 and slightly
    redesigned in version 2.9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The new collection framework is here to stay in Scala 2 and also will become
    a part of Scala 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is mostly a library release, the language itself is not changing a lot
    as compared to the previous version. Apart from the collections, the new version
    improves on three aspects:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Minimizes the core library
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeds up the compiler
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improves user-friendliness
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These details are outside of the scope of this book and we will not discuss
    them further.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, there is an addition of literal and singleton types, which we
    will discuss in detail in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml), *Understanding
    Types in Scala*, and a few minor changes to the standard library which we'll look
    at next, before diving into the sea of maps and lists.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Eager to look into the future? We'll take you there!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: New features of Scala 2.13
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss a few small improvements in the new version,
    which are not related to the collections topic and don't really belong to some
    bigger topic, such as optional parsing for string literals, adding names-reporting
    functions to case classes, methods for chaining operations, and automatic resource-management.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Optional parsing for string literals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala 2.13, `StringOps` has been extended with methods that return `Option` for
    string-literals parsing. Supported types include all numeric types and `Boolean`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The new methods can greatly simplify the processing of user-provided data without
    the need to wrap the calls with the exception-handling, as shown in the following
    example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The optional `Boolean` parsing ignores the case of the argument the same way
    the exception-throwing `toBoolean` method does.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Products can report the names of their element
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature probably will be mostly useful for the case classes as it makes
    possible some generic programming without the need to resort to reflection or
    macros.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性可能主要用于案例类，因为它使得在不使用反射或宏的情况下进行一些泛型编程成为可能。
- en: 'The following examples demonstrate how the new `productElementName(idx)` method
    can be used to build a naive JSON serializer for simple case classes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用新的 `productElementName(idx)` 方法构建一个简单的 JSON 序列化器，用于简单案例类：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Obviously, this simple iteration does not take nesting and escaping into account,
    but it already can produce valid results in elementary cases:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个简单的迭代不考虑嵌套和转义，但它已经在基本情况下可以产生有效结果：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, the method taking an index of the element throws an exception
    in the case that the index is invalid:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当索引无效时，取元素索引的方法会抛出异常：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will discuss why throwing exceptions is not the best approach, as well as
    viable alternatives, in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects.*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)“探索内置效果”中讨论为什么抛出异常不是最佳方法，以及可行的替代方案。
- en: Added methods for chaining operations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加了链式操作的方法
- en: Via `import scala.util.chaining._`, it is now possible to add `tap` and `pipe`
    methods to instances of any type. The functionality is provided by an implicit
    conversion to `ChainingOps`. We will look at implicits in detail in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to Know Implicits and Type Classes*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `import scala.util.chaining._`，现在可以将 `tap` 和 `pipe` 方法添加到任何类型的实例中。该功能由对 `ChainingOps`
    的隐式转换提供。我们将在[第4章](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)“了解隐式和类型类”中详细查看隐式。
- en: The `pipe` method applies a given function to the value and returns the result.
    It might be helpful in situations where it is desirable to convert nested function
    calls into the fluid-interface-like code. The following snippet shows an example
    of an imaginary user database with nested function calls chained via `pipe`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe` 方法将给定的函数应用于值并返回结果。在需要将嵌套函数调用转换为类似流式接口的代码的情况下，这可能很有帮助。以下代码片段展示了通过 `pipe`
    链接嵌套函数调用的一个虚构用户数据库示例。'
- en: 'Consider the following the database interface:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据库接口：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could apply all three actions to the user at once:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有三个操作一次性应用于用户：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`pipe` allows us to represent this in a more readable format:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe` 允许我们以更可读的格式表示这一点：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Arguably the same (or an even clearer) result could be achieved by combining
    functions before applying them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为，通过在应用之前组合函数，可以得到相同（或更清晰）的结果：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will look at functions in general, and function composition in particular, in
    [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep Dive into Functions*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml)“深入函数”中查看函数，特别是函数组合。
- en: '`tap` applies a function given as an argument solely for the side-effects it
    produces and returns the original value. It might be useful, for example, for
    logging purposes and the simplest kind of performance measurements.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`tap` 方法仅为了产生副作用而应用作为参数传递的函数，并返回原始值。例如，它可能对日志记录目的和最简单的性能测量很有用。'
- en: 'The next snippet demonstrates an elementary side-effect-causing performance-tracking
    implementation that utilizes a global variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了一个基本的副作用引起性能跟踪实现，该实现利用全局变量：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we defined a global value of the `AtomicLong` type to store the last measured timestamp.
    Then we define a polymorphic `measure` method that captures the time between the
    moment of the last measurement and now, and a `start` method to reset the clock.
    After that, we can use the `tap` method to track the execution times of our actions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个全局的 `AtomicLong` 类型的值来存储最后测量的时间戳。然后我们定义了一个多态的 `measure` 方法，它捕获最后测量时刻和现在之间的时间，以及一个
    `start` 方法来重置时钟。之后，我们可以使用 `tap` 方法来跟踪我们动作的执行时间。
- en: We will talk about types and polymorphism in [Chapter 2](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml),
    *Understanding Types in Scala*, side-effects and more general concept of effects
    in [Chapter 8](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml), *Dealing with Effects*,
    and show drawbacks of having global variables and a global state in [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第2章[在Scala中理解类型](c2e10a85-e4e8-4a55-be68-234033ac93d3.xhtml)中讨论类型和多态性，在第8章[处理效果](d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml)中讨论副作用和更一般的概念，并展示全局变量和全局状态存在的缺点，这些内容在第9章[熟悉基本Monads](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml)中。
- en: Automatic Resource Management
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动资源管理
- en: Scala 2.13 adds a practical way to automatically manage resources. We will discuss
    other ways to manage resources and implement dependency-injection in [Chapter
    9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing Yourself with Basic
    Monads* and 10. `scala.util.Using` allows us to do this in a familiar side-effecting
    way. All operations on the resource are wrapped in a `Try`, which we'll talk about
    in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In
    Effects*. If `Exceptions` is thrown, the first one is returned within a `Try`.
    The exception-handling is quite sophisticated in some corner cases and we invite
    the reader to consult ScalaDoc for a detailed description of it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.13 添加了一种自动管理资源的方法。我们将在第9章[熟悉基本Monads](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml)和第10章`scala.util.Using`中讨论其他管理资源的方法和实现依赖注入，它允许我们以熟悉的方式执行副作用。所有对资源的操作都被封装在`Try`中，我们将在第6章[探索内置效果](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)中讨论。如果抛出`Exceptions`，则`Try`中返回第一个异常。在某些边缘情况下，异常处理相当复杂，我们邀请读者查阅ScalaDoc以获取其详细描述。
- en: '`Using` is a class that takes some resources as a by-name parameter. The resource
    can be anything that has a type class instance for `scala.util.Resource` available.
    Such an instance for `java.lang.AutoCloseable` is provided in the standard library.
    We will study type classes in [Chapter 4](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml),
    *Getting to Know Implicits and Type Classes*. `Using` also has a monadic interface,
    which allows us to combine multiple resources in for-comprehensions. We''ll discuss
    monads in [Chapter 9](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml), *Familiarizing
    Yourself with Basic Monads*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Using`是一个类，它接受一些资源作为by-name参数。资源可以是任何具有`scala.util.Resource`类型类实例的对象。标准库中提供了`java.lang.AutoCloseable`的实例。我们将在第4章[了解隐式和类型类](20767c8e-f580-4760-9e64-371c8fc523c6.xhtml)中研究类型类。`Using`还有一个单调接口，允许我们在for-comprehensions中组合多个资源。我们将在第9章[熟悉基本Monads](e66f4a4d-2e99-49cd-a090-ee8c8d661660.xhtml)中讨论单调性。'
- en: 'Here is an example of the practical application of `Using`. We will define
    a resource that implements `AutoCloseable` and a few of these resources in for-comprehension
    as a source of the data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Using`的实际应用示例。我们将定义一个实现`AutoCloseable`的资源，并在for-comprehension中将这些资源作为数据源：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output in the console demonstrates that the result contains lines from all
    of the resources, and the resources themselves are automatically closed in the
    reverse order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出显示结果包含所有资源的行，并且资源本身会按相反的顺序自动关闭。
- en: Now, after this small warm-up, we are ready to dive into the foundation of version
    2.13—the new collection library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过这个小热身，我们准备深入探讨2.13版本的基础——新的集合库。
- en: The Scala 2.13 Collection Library
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 2.13 集合库
- en: Scala 2.13 delivers a new collection library, for historical reasons it is also
    known as "collection - strawman". The refactoring of the library pursued a few
    main goals, such as fixing common gotchas of the previous version, simplifying
    its implementation and internal structure, as well as usage and backward-compatibility,
    achieving better integration with lazy collections and java streams and cleaner
    API separation between mutable and immutable collections, improving performance,
    and, last but not least, minimizing the migration effort from Scala 2.12's collections.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.13 提供了一个新的集合库，由于历史原因，它也被称为“集合 - strawman”。该库的重构追求几个主要目标，例如修复前一个版本中的常见问题，简化其实施和内部结构，以及使用和向后兼容性，实现与懒集合和Java流的更好集成，以及可变和不可变集合之间更清晰的API分离，提高性能，最后但同样重要的是，最小化从Scala
    2.12集合迁移的工作量。
- en: As a result, we have a library that is mostly source-compatible with the previous
    version, has many old methods and types (such as `Traversable`, `TraversableOnce`,
    and `Stream`) deprecated, and has a simpler internal hierarchy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个与上一个版本大部分源代码兼容的库，其中包含许多旧方法和类型（如`Traversable`、`TraversableOnce`和`Stream`）已被弃用，并且内部层次结构更加简单。
- en: This book assumes that the reader has a rudimentary understanding of Scala collections.
    With this assumption, the next section will take a holistic approach and focus
    on giving a consistent overview of the new collection framework.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者对Scala集合有基本的理解。基于这个假设，下一节将采取整体方法，重点介绍新集合框架的统一概述。
- en: 'The next diagram represents the top-level hierarchy of the collection library:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表示集合库的顶级层次结构：
- en: '![](img/47a0c9a1-6d31-418b-821d-9e270f3764fb.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47a0c9a1-6d31-418b-821d-9e270f3764fb.png)'
- en: 'Here and further, we will pretend to always have `import scala.collections._` in
    the scope and use the following colour encoding in our diagrams:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将假设总是有`import scala.collections._`在作用域内，并在我们的图中使用以下颜色编码：
- en: '![](img/556be524-da3b-4ac4-b942-26d184f88e16.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/556be524-da3b-4ac4-b942-26d184f88e16.png)'
- en: Each of the traits describes the structure, the *essence* of the collection.
    As the name suggests, `IterableOnce` can be iterated over only one time. `Iterable`
    softens this constraint so that it is possible to iterate over the collection
    multiple times. `Seq` adds a notion of succession to the elements of the collection, `Set` adds
    a constraint of the uniqueness of its elements, and `Map` changes the type of
    the collection from a single element, `A`, to a pair of key, `K`, and value, `V`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特质描述了结构，即集合的*本质*。正如其名所示，`IterableOnce`只能迭代一次。`Iterable`放宽了这个限制，使得可以多次迭代集合。`Seq`为集合的元素添加了连续性的概念，`Set`为其元素添加了唯一性的约束，而`Map`将集合的类型从单个元素`A`更改为键值对，键为`K`，值为`V`。
- en: 'As mentioned, in the spirit of the separation of concerns, these traits cover
    only the structural characteristics. The operations defined for the specific type
    are placed in the helper traits carrying the `Ops` suffix in the name. These traits
    form a hierarchical structure similar to the previous one, as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本着关注点分离的精神，这些特质仅涵盖结构特性。为特定类型定义的操作被放置在带有`Ops`后缀的辅助特质中。这些特质形成一个类似于之前的层次结构，如下所示：
- en: '![](img/1d47f2cb-69cf-454c-ba06-d4ac95462481.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d47f2cb-69cf-454c-ba06-d4ac95462481.png)'
- en: Where the "normal" traits had only one type parameter, the type of the element,
    the `Ops` have three of them. In addition to the type of the element, `A`, the `C` type
    describes the specific *representation *type of the collection this trait is mixed
    into and thus to the return type of the first-order methods defined on this collection.
    The `CC` type refers to the representation type that can be returned by the higher-order
    methods, or the type constructor. We will see later in this chapter how this works
    in practice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与“正常”特质只有一个类型参数（元素类型）不同，`Ops`有三个类型参数。除了元素类型`A`外，`C`类型描述了此特质混合到的集合的特定*表示*类型，以及此集合上定义的一阶方法的返回类型。`CC`类型指的是可以由高阶方法返回的表示类型或类型构造函数。我们将在本章后面看到这是如何在实际中工作的。
- en: Because the inheritance tree is structured as it is, `IterableOps` and `IterableOnceOps`
    are effectively mixed into every collection implementation in the library. Three
    traits on the bottom just add some more methods, unique to the specific collection
    type, and override some of the definitions for efficiency. Both `Iterable*Ops`
    traits define more than a hundred of methods and they are the reason the Scala
    collection library is very consistent and homogenous.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承树的结构如此，`IterableOps`和`IterableOnceOps`实际上被混合到库中的每个集合实现中。底部的三个特质仅添加了一些针对特定集合类型的独特方法，并覆盖了一些定义以提高效率。`Iterable*Ops`特质定义了超过一百个方法，这也是Scala集合库非常一致和同质化的原因。
- en: Because of the importance of `IterableOnceOps` and `IterableOps`, we will take
    a detailed look at them in the next section. After that, we will explore the unique
    features of the specialized collections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`IterableOnceOps`和`IterableOps`的重要性，我们将在下一节详细探讨它们。之后，我们将探索专用集合的独特特性。
- en: IterableOnceOps
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IterableOnceOps
- en: '`IterableOnceOps` represents a blueprint for the collections that can be traversed
    one or multiple times. It defines a few abstract methods that must be implemented
    by every collection and a number of concrete methods implemented in terms of an
    iterator available from `IterableOnce`. The concrete methods provide default,
    if possible, lazy, implementations and fall into one of the following categories:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`IterableOnceOps` 代表可以一次或多次遍历的集合的蓝图。它定义了一些必须由每个集合实现的抽象方法，以及一些以 `IterableOnce`
    中可用的迭代器为依据的具体方法。具体方法提供默认（如果可能）的懒实现，并分为以下几类：'
- en: '**Size operations:** `isEmpty`, `nonEmpty`, `size`, `knownSize`, and `isTraversableAgain`
    check the collection for (non) emptiness or return its size. `knownSize` is an
    optimization that returns `-1` if the size cannot be determined without iterating
    over the collection. `isTraversableAgain` returns `false` for `IterableOnce`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小操作：** `isEmpty`、`nonEmpty`、`size`、`knownSize` 和 `isTraversableAgain` 检查集合的（非）空性或返回其大小。`knownSize`
    是一种优化，如果无法在不遍历集合的情况下确定大小，则返回 `-1`。`isTraversableAgain` 对于 `IterableOnce` 返回 `false`。'
- en: '**Element tests:** `forall`, `exists`, and `count` check whether all, at least
    one, or some number of elements satisfy the given predicate.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素测试：** `forall`、`exists` 和 `count` 检查所有、至少一个或某些数量的元素是否满足给定的谓词。'
- en: '**String operations:** `mkString` and `addString`. These methods with different
    argument sets provide a possibility to build alternative string representation.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串操作：** `mkString` 和 `addString`。这些方法具有不同的参数集，提供了构建替代字符串表示的可能性。'
- en: '**Conversions to another collections:** `copyToArray`, `toList`, `toMap`, `to`,
    `toSet`, `toSeq`, `toIndexedSeq`, `toBuffer`, and `toArray`. These methods copy
    or convert an `Iterable` into another collection. The `to` method is special in
    this list because it allows us to return any type of the collection that has a
    `Factory` available. We will look at it in more detail soon.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为其他集合：** `copyToArray`、`toList`、`toMap`、`to`、`toSet`、`toSeq`、`toIndexedSeq`、`toBuffer`
    和 `toArray`。这些方法将 `Iterable` 复制或转换为另一个集合。`to` 方法在这个列表中是特殊的，因为它允许我们返回具有可用 `Factory`
    的任何类型的集合。我们很快会详细探讨它。'
- en: '**Fold and reduce:** `foldLeft`, `foldRight`, `reduce`, `reduceLeft`, `reduceRight`, `reduceOption`, `reduceLeftOption`,
    and `reduceRightOption` apply a binary operation to the elements of the collection.
    The `reduce*Option` methods handle the case of an empty collection gracefully
    by returning `None`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠和归约：** `foldLeft`、`foldRight`、`reduce`、`reduceLeft`、`reduceRight`、`reduceOption`、`reduceLeftOption`
    和 `reduceRightOption` 将二元运算应用于集合的元素。`reduce*Option` 方法通过返回 `None` 来优雅地处理空集合的情况。'
- en: '**Numeric combinations:** `sum` and `product` calculate the sum or product
    of the elements if there is an implicit `Numeric[B]` such that `B >: A` is available.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值组合：** `sum` 和 `product` 如果存在隐式的 `Numeric[B]` 使得 `B >: A` 可用，则计算元素的求和或乘积。'
- en: '**Ordering combinations:**  `min`, `minOption`, `max`, `maxOption`, `maxBy`,
    `maxByOption`, `minBy`, and `minByOption` find an element of the collection that satisfies
    giving predicate if there is an implicit `Ordering[B]` with `B >: A` available.
    The `*Option` methods return `None` for an empty collection instead of throwing
    an exception.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序组合：** `min`、`minOption`、`max`、`maxOption`、`maxBy`、`maxByOption`、`minBy`
    和 `minByOption` 如果存在隐式的 `Ordering[B]` 使得 `B >: A` 可用，则找到满足给定谓词的集合元素。`*Option`
    方法在空集合的情况下返回 `None` 而不是抛出异常。'
- en: '**Element retrieval:** `collectFirst` and `find`. Choose an element that satisfies
    a given condition.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索：** `collectFirst` 和 `find`。选择满足给定条件的元素。'
- en: '**Equality:** `corresponds` is an alternative way to compare collections. Satisfied
    if every element of this collection relates to matching element of another collection
    by given predicate.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平等性：** `corresponds` 是比较集合的另一种方式。如果这个集合的每个元素都通过给定的谓词与另一个集合的匹配元素相关联，则满足条件。'
- en: 'Abstract methods fall into one of the following categories:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法分为以下几类：
- en: '**Subcollection retrieval:** `filter`, `filterNot`, `take`, `takeWhile`, `drop`,
    `dropWhile`, `slice`, and `span`. Take or discard elements that satisfy the given
    predicate or range, from the whole collection or beginning of it.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合检索：** `filter`、`filterNot`、`take`、`takeWhile`、`drop`、`dropWhile`、`slice`
    和 `span`。从整个集合或其开始处取出或丢弃满足给定谓词或范围的元素。'
- en: '**Mapping:** `map`, `flatMap`, `collect`, and `scanLeft`. Transforms elements
    of the collection by applying some function and possibly filtering the results.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射：** `map`、`flatMap`、`collect` 和 `scanLeft`。通过应用某个函数并可能过滤结果来转换集合的元素。'
- en: '**Zippers:** `zipWithIndex` adds an index to all elements of the collection.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zipper:** `zipWithIndex` 为集合的所有元素添加一个索引。'
- en: IterableOps
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IterableOps
- en: '`IterableOps` extends `IterableOnceOps` and contains methods that is impossible
    to implement without a possibility to iterate over the collection multiple times.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`IterableOps` 扩展了 `IterableOnceOps` 并包含了一些不可能在不允许多次遍历集合的情况下实现的方法。'
- en: 'They fall into the following categories:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它们分为以下几类：
- en: '**Element retrieval:** `head`, `headOption`, `last`, and `lastOption` return
    the first or last element of the collection throwing `NoSuchElementException`
    or returning `None` for an empty collection.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索:** `head`, `headOption`, `last`, 和 `lastOption` 返回集合的第一个或最后一个元素，对于空集合抛出
    `NoSuchElementException` 或返回 `None`。'
- en: '**Size:** `sizeCompare` is an optimization that allows us to efficiently compare
    the size of the collection with given value.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小:** `sizeCompare` 是一种优化，允许我们有效地比较集合与给定值的大小。'
- en: '**Subcollection retrieval:** `partition`, `partitionWith`, `splitAt`, `takeRight`,
    `dropRight`, `grouped`, `sliding`, `tail`, `init`, `groupBy`, `groupMap`, `groupMapReduce`, `tails`,
    and `inits`. These split the collection as defined by some predicate or index,
    take or drop elements from the end, group elements by some criteria or predicate
    possibly applying transformative function, and discard first or last elements.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合检索:** `partition`, `partitionWith`, `splitAt`, `takeRight`, `dropRight`,
    `grouped`, `sliding`, `tail`, `init`, `groupBy`, `groupMap`, `groupMapReduce`,
    `tails`, 和 `inits`。这些方法根据某些谓词或索引拆分集合，从末尾取或丢弃元素，根据某些标准或谓词对元素进行分组，可能应用转换函数，并丢弃第一个或最后一个元素。'
- en: '**Mapping:** `scanRight` produces a collection containing the cumulative results
    of applying the giving function starting from the end of the collection.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射:** `scanRight` 生成一个包含从集合末尾开始应用给定函数的累积结果的集合。'
- en: '**Addition:** `concat, ++` returns another collection containing all elements
    of this collection and a collection provided as an argument.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加:** `concat, ++` 返回包含此集合和作为参数提供的集合中所有元素的另一个集合。'
- en: '**Zippers:** `zip`, `zipAll`, `unzip`, and `unzip3` combine the elements of
    the collection with the elements of another collection into a product, or split
    them into separate collections.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zipper:** `zip`, `zipAll`, `unzip`, 和 `unzip3` 将集合的元素与另一个集合的元素组合成一个产品，或者将它们拆分成单独的集合。'
- en: '**Transformation:** `transpose` transforms the collection of collections by
    turning rows into columns and vice versa.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换:** `transpose` 通过将行转换为列和相反的方式转换集合的集合。'
- en: 'The following methods that defined the abstract in `IterableOnceOps` got a
    concrete default implementation in `IterableOps`: `filter`, `filterNot`, `take`,
    `takeWhile`, `span`, `drop`, `dropWile`, `slice`, `scanLeft`, `map`, `flatMap`,
    `flatten`, `collect`, and `zipWithIndex`. `isTraversableAgain` is overriden to
    return `true`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IterableOnceOps` 中定义的以下方法在 `IterableOps` 中得到了具体的默认实现：`filter`, `filterNot`,
    `take`, `takeWhile`, `span`, `drop`, `dropWile`, `slice`, `scanLeft`, `map`, `flatMap`,
    `flatten`, `collect`, 和 `zipWithIndex`。`isTraversableAgain` 被覆盖以返回 `true`。
- en: 'It''s worth noting that `Iterable` and `IterableOnce` do not support a general-equality
    operation, it is defined on specific collection subtypes. Because of this, it
    is impossible to compare these types directly using the equality operation, as
    the following example suggests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Iterable` 和 `IterableOnce` 不支持通用相等操作，它是在特定的集合子类型上定义的。因此，无法使用相等操作直接比较这些类型，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also there are three special methods that deserve our additional attention
    because they introduce types we haven''t met yet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有三个特别值得注意的方法，因为它们引入了尚未遇到过的类型：
- en: '`def withFilter(p: A => Boolean): collection.WithFilter[A, CC]`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def withFilter(p: A => Boolean): collection.WithFilter[A, CC]`'
- en: '`def iterableFactory: IterableFactory[CC]`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def iterableFactory: IterableFactory[CC]`'
- en: '`def view: View[A]`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def view: View[A]`'
- en: Let's discuss them quickly before moving on to more specific collection types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论更具体的集合类型之前，让我们快速地讨论一下它们。
- en: WithFilter
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WithFilter
- en: '`WithFilter` is a template class that contains the `map`, `flatMap`, `foreach`,
    and `withFilter` methods of `Iterable`. It allows us to specialize mapping and
    filtering operations for distinguished collections.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithFilter` 是一个模板类，它包含 `Iterable` 的 `map`, `flatMap`, `foreach`, 和 `withFilter`
    方法。它允许我们对特殊集合进行映射和过滤操作的专门化。'
- en: Because of its technical nature, we won't go into further details here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其技术性质，我们在这里不会进一步详细介绍。
- en: IterableFactory
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IterableFactory
- en: '`trait IterableFactory[+CC[_]]` is a base trait for companion objects for specific
    collections which provides a number of operations to create a specific collection
    with the type specified by the `CC` type constructor; this is sometimes called
    *target-type driven building* because the type of the source collection is ignored.
    Most of the companion objects in the collection library extend this trait, which
    makes it possible to use them in places where `IterableFactory` is expected.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`trait IterableFactory[+CC[_]]` 是特定集合伴随对象的基特质，它提供了一系列操作来创建由 `CC` 类型构造器指定的特定集合；这有时被称为
    *目标类型驱动构建*，因为源集合的类型被忽略。集合库中的大多数伴随对象都扩展了这个特质，这使得它们可以在期望 `IterableFactory` 的地方使用。'
- en: 'As this is the main abstraction that allows to build a collection from scratch,
    it is useful to know which methods it supplies. All of them return `CC[A]`. The
    following table contains a short summary:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为允许从头开始构建集合的主要抽象，了解它提供的方法是有用的。所有这些方法都返回 `CC[A]`。以下表格包含了一个简要总结：
- en: '| `def from[A](source: IterableOnce[A])` | Creates a target collection from
    existing `IterableOnce`. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `def from[A](source: IterableOnce[A])` | 从现有的 `IterableOnce` 创建目标集合。 |'
- en: '| `def empty[A]: CC[A]` | An empty collection, often defined as an object.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `def empty[A]: CC[A]` | 一个空集合，通常定义为对象。 |'
- en: '| `def apply[A](elems: A*): CC[A]` | Creates a collection from the `elems`
    given as var-arg. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `def apply[A](elems: A*): CC[A]` | 从给定的 var-arg `elems` 创建集合。 |'
- en: '| `def iterate[A](start: A, len: Int)(f: A => A): CC[A]` | Fills the collection
    with values taken from the result of the application of `f` on `start`, then on
    produced values and so on, `len` number of times. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `def iterate[A](start: A, len: Int)(f: A => A): CC[A]` | 使用对 `start` 的应用结果、然后是生成的值，依此类推，重复
    `len` 次来填充集合。 |'
- en: '| `def range[A : Integral](start: A, end: A, step: A): CC[A]` | Collection
    containing increasing integers [`start`, `end`-1] with difference between successive
    numbers of `step`. There is also a version of this method with default value of `step
    = 1`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `def range[A : Integral](start: A, end: A, step: A): CC[A]` | 包含递增整数 `[start,
    end-1]` 的集合，相邻数字之间的差为 `step`。此方法还有一个默认值 `step = 1` 的版本。 |'
- en: '| `def fill[A](n: Int)(elem: => A): CC[A]` | Fills the collection with `n` evaluations
    of `elem`. There are variations of this function that go up to five dimensions.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `def fill[A](n: Int)(elem: => A): CC[A]` | 使用 `n` 次对 `elem` 的评估来填充集合。此函数有高达五维的变体。
    |'
- en: '| `def tabulate[A](n: Int)(f: Int => A): CC[A]` | The same as `fill`, but using
    index as an argument for the evaluation. Similarly, there are variations of this
    function that go up to five dimensions. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `def tabulate[A](n: Int)(f: Int => A): CC[A]` | 与 `fill` 相同，但使用索引作为评估的参数。类似地，此函数有高达五维的变体。
    |'
- en: '| `def concat[A](xss: Iterable[A]*): CC[A]` | Concatenates all argument collections
    into a single collection. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `def concat[A](xss: Iterable[A]*): CC[A]` | 将所有参数集合连接成一个单一集合。 |'
- en: '| `def unfold[A, S](init: S)(f: S => Option[(A, S)]): CC[A]` | Calls `f` to
    produce the element of the collection using and modifying the internal state starting
    with the `init` state. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `def unfold[A, S](init: S)(f: S => Option[(A, S)]): CC[A]` | 调用 `f` 来生成集合的元素，使用并修改从
    `init` 状态开始的内部状态。 |'
- en: Arguably, `IterableFactory` provides a lot of different possibilities to create
    a collection of a desired type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，`IterableFactory` 提供了许多创建所需类型集合的不同可能性。
- en: View
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: '`View` has been reimplemented in the new version of the library. Now it represents
    a reified `Iterator` operations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 在库的新版本中已被重新实现。现在它代表一个具体化的 `Iterator` 操作。'
- en: Reification is the process by which an abstract idea about a computer program
    is turned into an explicit data model or other object created in a programming
    language ([https://en.wikipedia.org/wiki/Reification_(computer_science)](https://en.wikipedia.org/wiki/Reification_(computer_science))[).](https://en.wikipedia.org/wiki/Reification_(computer_science))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 具体化是将关于计算机程序的概念转化为编程语言中创建的显式数据模型或其他对象的过程 ([https://en.wikipedia.org/wiki/Reification_(computer_science)](https://en.wikipedia.org/wiki/Reification_(computer_science))[)。](https://en.wikipedia.org/wiki/Reification_(computer_science))
- en: 'This means that the `Iterator` methods are represented as a subclasses of `View`
    and encapsulate transformations to apply. The evaluation happens at the moment
    the view is converted to the strict collection type, or traversed, for example
    using the `foreach` method. Views don''t *remember* the type of the source collection.
    This can be demonstrated by the following example. First, we define a generic
    transformation that might be strict or lazy, depending on the type of the collection
    given as an argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `Iterator` 方法被表示为 `View` 的子类，并封装了要应用的转换。评估发生在视图转换为严格集合类型或遍历（例如使用 `foreach`
    方法）的时刻。视图不 *记住* 源集合的类型。以下示例可以证明这一点。首先，我们定义一个通用的转换，它可能是严格的或懒散的，这取决于作为参数提供的集合类型：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, for each transformation step, we print out its result in the console
    at the moment the step happens. Now we can compare lazy and strict collection
    behaviors:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于每个转换步骤，我们在步骤发生时在控制台打印其结果。现在我们可以比较懒散和严格集合的行为：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This snippet produces the following output in the REPL:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在 REPL 中产生以下输出：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first line, we can see that the `take` method is always evaluated strictly
    regardless of the underlying collection type—this is commented as `A` in the preceding
    code. The second and third lines show the strict evaluation for `List[Char]`,
    line `B` in the code. Lines 4 and 5 demonstrate that `View[Char]` is then evaluated
    twice, each time at the moment it is forced, once by calling `foreach` (line `C`)
    and once by converting it to the `List` (line `D`). Also interesting is that `map`
    is only applied to the results of the `take` method even given the fact that `map`
    is the first transformation step in the chain.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们可以看到 `take` 方法始终严格评估，无论底层集合类型如何——这在上面的代码中注释为 `A`。第二行和第三行显示了 `List[Char]`
    的严格评估，代码中的 `B` 行。第 4 行和第 5 行演示了 `View[Char]` 被评估两次，每次在强制转换的时刻，一次是通过调用 `foreach`（代码中的
    `C` 行），一次是通过将其转换为 `List`（代码中的 `D` 行）。还有一点值得注意的是，即使在链中的第一个转换步骤，`map` 也只应用于 `take`
    方法的输出。
- en: Set
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: '`Set` is a base trait for collections that have a notion of uniques of the
    elements. It is defined as `trait Set[A] extends Iterable[A] with SetOps[A, Set,
    Set[A]] with Equals`. We can see that it is effectively an `Iterable` that has
    some additional operations defined in `SetOps` and adds a notion of equality among
    sets. The sub-hierarchy of `Set` is represented in the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 是具有元素唯一概念集合的基特质。它定义为 `trait Set[A] extends Iterable[A] with SetOps[A,
    Set, Set[A]] with Equals`。我们可以看到它实际上是一个 `Iterable`，在 `SetOps` 中定义了一些额外的操作，并在集合之间添加了等价性的概念。`Set`
    的子层次结构在以下图中表示：'
- en: '![](img/5bf8e356-9aa9-488b-8758-6a084cda8847.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bf8e356-9aa9-488b-8758-6a084cda8847.png)'
- en: 'The previously mentioned `SetOps` adds a few methods on top of `IterableOps`.
    These methods are shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的 `SetOps` 在 `IterableOps` 上添加了一些方法。这些方法在此处显示：
- en: '**Element retrieval:** `contains` and `apply` return `true` if this set contains
    a given element.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索：** `contains` 和 `apply` 如果这个集合包含一个给定元素，则返回 `true`。'
- en: '**Equality:** `subsetOf` and `subsets` check whether this set is a subset of
    another set, or return all subsets of this set, possibly with a given size.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等价性：** `subsetOf` 和 `subsets` 检查这个集合是否是另一个集合的子集，或者返回这个集合的所有子集，可能还有给定的大小。'
- en: '**Combinations with another set:** `intersect`, `&`, `diff`, `&~`, `concat`,
    `++`, `union`, and `|`. These methods compute the intersection, difference, or
    union of this and another set.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与另一个集合的组合：** `intersect`、`&`、`diff`、`&~`、`concat`、`++`、`union` 和 `|`。这些方法计算这个集合与另一个集合的交集、差集或并集。'
- en: 'There are few classes in the hierarchy that augment `Set` with further properties:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中很少有类增强了 `Set` 的进一步属性：
- en: '**SortedSet** extends `Set` with `SortedOps[A, +C]` and has two immutable and
    two mutable implementations—two `TreeSets` and two `BitSets`. `SortedOps` embodies
    following methods that depend on the notion of `Ordering`:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SortedSet** 通过 `SortedOps[A, +C]` 扩展了 `Set`，并有两个不可变和两个可变实现——两个 `TreeSets`
    和两个 `BitSets`。`SortedOps` 实现了以下依赖于 `Ordering` 概念的方法：'
- en: '**Key retrieval:** `firstKey` and `lastKey` return the first or last element
    of this collection.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键检索：** `firstKey` 和 `lastKey` 返回这个集合的第一个或最后一个元素。'
- en: '**Subcollection retrieval:** `range`, `rangeFrom`, `rangeUntil`, and `rangeTo`
    create a ranged projection of this collection, satisfying given criteria.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合检索：** `range`、`rangeFrom`、`rangeUntil` 和 `rangeTo` 创建了这个集合的按范围投影，满足给定的标准。'
- en: 'Because of the overloading, `SortedSet` has many overloaded methods defined
    twice, with and without ordering. If an operation is intended to be applied to
    the underlying unsorted `Set`, the type has to be coerced:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Please note that direct type-ascription will not work in the case of `Set`
    because its definition is invariant:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The invariance of `Set` is related to the fact that `Set[A]` extends a function, `A
    => Boolean`, that returns `true` if the set contains a given element. Thus, sets
    can be used in places where such one argument function is expected:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are four more specific set implementations in addition to `TreeSet` and
    `BitSet`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`ListSet` implements immutable sets using a list-based data structure.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The immutable HashSet realizes immutable sets using a Compressed Hash-Array
    Mapped Prefix-tree (CHAMP)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutable `HashSet` and `LinkedHashSet` implement mutable sets using a hash
    table, storing the data unordered and ordered, respectively.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sets are closely related to `Map`, which represents a collection with elements
    represented as a pair of keys and values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Map
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Map` is defined as `trait Map[K, +V] extends Iterable[(K, V)] with MapOps[K,
    V, Map, Map[K, V]] with Equals` which makes it an `Iterable` over pairs of key, `K`,
    and value, `V`. It also defines a notion of equality among maps. The class hierarchy
    for `Map` is represented on the following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fda9483-e5d1-41c5-9896-324d26c4f805.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: There are three different `MapOps`, one general for both mutable and immutable,
    and one specific for each of these forms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`MapOps` extends `IterableOps` with the following specific operations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `get`, `getOrElse`, `apply`, `applyOrElse`, `default`,
    `contains`, and `isDefinedAt`. These methods allow us to retrieve a value or check
    whether a value is present by a given key, optionally returning a default value
    or throwing an exception if the key can''t be found.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `keySet`, `keys`, `values`, `keysIterator`, and `valuesIterator`
    allow us to get a keys or values in different forms.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `map`, `flatMap`, and `collect` are transforming and optionally
    filtering the pairs of keys and values.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition:** `concat` returns a new collection with elements of both maps
    combined.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`immutable.MapOps` adds the following methods on top of `MapOps`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Element removal**: `remove`, `removeAll`, `--` removes one or all given elements
    from the map returning new map.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element updates**: `updated` and `+` update an element with the given key
    returning new map.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `transform` applies a given function to all elements, producing
    a new map with the returned results as values.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutable.MapOps` has a different set of methods as compared to the mutable
    one:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Element addition:** `put` adds a new value or updates existing one.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element update:** `updated`, `+`, and `getOrElseUpdate` updates a value in
    place.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element removal:** `remove` and `clear` remove one or all elements of the
    map.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering:** `filterInPlace` retains only mappings that satisfy the predicate.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping:** `mapValuesInPlace` applies a transformation to the values of the
    map, storing returned results as values.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general `Map` definition has quite a few specialized subtypes, as shown
    in the preceding diagram. We will take a quick look at them now.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: SortedMap
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SortedMap` is similar to `SortedSet`. It has a two implementations, a mutable
    and immutable `TreeMap`, and provides a few methods defined in terms of `SortedOps`
    such as:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `iteratorFrom`, `keysIteratorFrom`, `valuesIteratorFrom`,
    and `rangeTo` give us a way to get elements of the map as an iterator.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrieval:** `firstKey`, `lastKey`, `minAfter`, and `maxBefore` allow
    us to retrieve an element that satisfies some ordering condition.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashMap
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HashMap` is also available in two flavors—immutable and mutable.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The immutable `HashMap` is implemented using a CHAMP tree.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The mutable `HashMap` implements mutable maps using a hashtable. A hash table
    stores its elements in an array. The hash code of the item is used to calculate
    the position in the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: MultiMap
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MultiMap` is a trait for mutable maps that have multiple values assigned to
    a key.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: It defines the `addBinding`, `removeBinding` and `entryExists` methods, which
    can be used to query or manipulate entries for a key.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: SeqMap
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SeqMap` is a generic abstraction for ordered immutable maps. `SeqMap` itself
    exists in mutable and immutable forms. These forms have few different implementations:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The immutable **ListMap** implements immutable maps using a list-based data
    structure. The methods traversing `ListMap` visit its elements in the order they
    were inserted.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutable **ListMap** is a simple mutable map backed by a list. It preserves
    insertion order as its immutable sibling does.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VectorMap** exists only in immutable form. It is implemented using a vector/map-based
    data structure and preserves insertion order. It has constant lookup but slower
    other operations.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinkedHashMap** is a mutable map whose implementation is based on a hashtable
    and preserves the insertion order if iterated over.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seq
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Seq` is probably the most ubiquitous collection in the library. Like `Map`,
    it has a notion of succession of elements and the elements have indices. It is
    defined as `trait Seq[+A] extends Iterable[A] with PartialFunction[Int, A] with
    SeqOps[A, Seq, Seq[A]] with Equals`. Also similar to map, `Seq` specifies support
    for the equality relation and also extends `PartialFunction`, which accepts an index
    of the element as a parameter. As there are a lots of classes implementing `Seq`,
    we will take a gradual approach and look at them level by level. The direct children
    of `Seq` are shown in the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e4bd4e9-fc44-4f3e-85e4-a72b74f64192.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '`scala.Seq`, known from previous Scala versions, is now replaced by `scala.collection.immutable.Seq`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other collections, `SeqOps` extend `IterableOps` by adding quite a
    few methods:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Element retrieval:** `apply` retrieves an element with a given index.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexing and search:** `segmentLength`, `isDefinedAt`, `indexWhere`, `indexOf`,
    `lastIndexOf`, `lastIndexWhere`, `indexOfSlice`, `lastIndexOfSlice`, `containsSlice`,
    `contains`, `startsWith`, `endsWith`, `indices`, and `search`. These methods allow
    us to retrieve information about the presence or indexes of elements or subsequences given
    some predicate or element value.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size:** `length` and `lengthCompare` provide efficient operations to retrieve
    the length of the collection.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition:** `prepend`, `+`, `appended`, `:+`, `prependAll`, `++`, `appendedAll`,
    `:++`, `concat`, and `union`. Can be used to append or prepend one or multiple
    elements to the collection.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering:** `distinct` and `distinctBy` remove duplicates, possibly given
    some predicate.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reversal:** `reverse` and `reverseIterator` return a new collection with
    elements in the reversed order.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting:** `sorted`, `sortWith`, and `sortBy` sort this collection by some
    implicit `Ordering`, or by a given function, or both.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equality:** `sameElements` and `corresponds` check whether this collection
    contains the same elements in the same order as given, using equality-checking
    or the provided comparison function.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcollection retrieval:** `permutations` and `combinations`. These methods
    allow us to retrieve a subcollection(s) that satisfies given conditions.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updates:** `diff`, `intersect`, `patch`, `updated`, and `update` (mutable).
    Modify elements of this collection using another collection or element and returning
    another collection (except the last method defined on `mutable.Seq`, which update
    elements in place).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the `Seq` direct descendants has its own specific properties and a subtree
    of implementations. We'll breeze through them now.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: IndexedSeq
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IndexedSeq` does not introduce new operations, at least not in its immutable
    incarnation, but overrides a lots of methods defined in `SeqOps` to provide more
    efficient implementations. There are four classes implementing it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/314b6c54-94c0-4556-ac2a-4f976b9e1c99.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'The `mutable.`** IndexedSeq** adds the following **mutation options**: `mapInPlace`,
    `sortInPlace`, `sortInPlaceWith`, and `sortInPlaceBy`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `mutable.`** ArraySeq** is a collection representing an `Array`. It defines
    an `array` method returning an underlying array, and an `elemTag` method that
    returns the tag of the element type needed to properly support different kinds
    of arrays as required by the JVM. Because of this requirement, it has separate
    implementations for all primitive types including numeric types (in addition to
    `ofByte`, there are implementations for all other numeric primitives, not shown
    on the diagram) and `Boolean`, `AnyRef` and `Unit`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The `immutable.`** ArraySeq** was added in the version 2.13\. It is an effectively
    an immutable sequence that wraps an array and is used to pass varargs parameters.
    It has the same descendants as its mutable cousin.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Range** is an immutable structure that contains integer values. It is defined
    by `start`, `end`, and a `step`. There are two additional methods available: `isInclusive`,
    which is `true` for `Range.Inclusive` and `false` for `Range.Exclusive`, and `by`,
    which creates the new range with a different `step` but the same `start` and `end`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector** is an immutable structure that provides constant-time access and
    updates and fast append and prepend. Because of this, `Vector` is the default
    implementation for `IndexedSeq`, as demonstrated in the following snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`WrappedString` is an immutable wrapper over some `String`. It extends strings
    with all of the operations defined in `IndexedSeqOps`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: LinearSeq
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linear sequences have the notion of a head and a tail. The definition looks
    like `trait LinearSeq[+A] extends Seq[A] with LinearSeqOps[A, LinearSeq, LinearSeq[A]]`
    and the class diagram is shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b71e25fd-af3f-408d-a9a1-8e115321176c.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'There are three representatives of `LinearSeq`, all are immutable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**List** defines three symbolic methods which provide a nice syntax for pattern-matching
    and building lists. `::` prepends element to the list, `:::` prepends all elements
    of a given list, and `reverse_:::` prepends all elements of a given list but in
    the reverse order.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LazyList** is a new immutable collection available since Scala 2.13\. It
    implements a list with a `head` and a `tail`, which are not evaluated until needed.
    As it is superior to `Stream`, which is only lazy in the tail, `Stream` is now
    deprecated. `LazyList` has two additional methods, `force` which evaluates it,
    and `lazyAppendAll` which lazily appends a given collection to this list.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue** in this hierarchy is also immutable. It allows a first-in-first-out
    (FIFO) insertion and retrieval of the elements. For this functionality, it defines
    the `enqueue`, `enqueueAll`, `dequeue`, `dequeueOption`, and `front` methods.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Buffers` conclude our rush through the collection library. In essence, `Buffer`
    is just a `Seq` that can grow and shrink. This sub-hierarchy exists only in immutable
    form, though `IndexedBuffer` inherits from both Buffer and `IndexedSeq`, as shown
    by the next diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2abfd717-cfc0-4baa-bd63-0acf4e4f3cde.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the methods that these collections define, in addition
    to the definitions inherited from `SeqOps`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer** defines methods to add or remove one or more elements in place or returning
    new buffer: `prepend`, `append`, `appendAll`, `+=:`, `prependAll`, `++=:`, `insert`, `insertAll`,
    `remove`, `subtractOne`, `trimStart`, `trimEnd`, `patchInPlace`, `dropInPlace`,
    `dropRightInPlace`, `takeRightInPlace`, `sliceInPlace`, `dropWhileInPlace`, `takeWhileInPlace`,
    and `padToInPlace`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ListBuffer** is a concrete buffer implementation baked by a `List`. In addition
    to other discussed methods, it provides `prependToList`, which allows us to prepend
    this collection to another list and a triple of `mapInPlace`, `flatMapInPlace`,
    and `filterInPlace`, giving us a possibility to modify elements in place.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a `Buffer`, add an `IndexedSeq`, and you'll get an **IndexedBuffer**. Similar
    to `ListBuffer`, it provides the `flatMapInPlace` and `filterInPlace` methods.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ArrayBuffer** is a concrete implementation of `IndexedBuffer` that uses an
    array to store its elements and has a constant time for append, update, and random
    access. It has a `sizeHint` method, which can be used to enlarge the underlying
    array. It is a default implementation instantiated if `mutable.Seq` is created.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ArrayDeque** is another efficient collection that emerged in the 2.13 version. It
    implements a double-ended queue that internally uses a resizable circular buffer.
    This allows to have a constant time for append, prepend, remove first, remove
    last, and random-access operations. There are lots of additional methods available
    on this collection, mostly because of the notion of the second-end: `removeHeadOption`,
    `removeHead`, `removeLastOption`, `removeLast`, `removeAll`, `removeAllReverse`,
    `removeHeadWhile`, `removeLastWhile`, `removeFirst`, `removeAll`, `clearAndShrink`,
    `copySliceToArray`, and `trimToSize`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Queue** in this hierarchy is mutable. It is based on `ArrayDeque` and
    allows us to insert and retrieve elements in the FIFO manner. The following methods
    are available for that: `enqueue`, `enqueueAll`, `dequeue`, `dequeueFirst`, `dequeueAll`,
    and `dequeueWhile.`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Stack** is similar to `Queue`, but it implements in last-in-first-out
    (LIFO) order instead of FIFO. The methods it defines are formulated in the corresponding
    terms: `push`, `pushAll`, `pop`, `popAll`, `popWhile`, and `top`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala Collection Contrib library
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Needless to say, the standard Scala collection library is very rich and provides
    collections for most of the common use cases. But of course, there are some other structures
    that might be useful in a number of specific situations. The Scala Collection
    `Contrib` module is Scala's way of having both a stable standard library and some
    extra features. In a sense, this module is an incubator for the new collection
    types; types that prove to be useful for a broad audience will presumably be incorporated
    into the standard library in further Scala versions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are four collection types available in the module, each both
    mutable and immutable:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`MultiDict`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMultiDict`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiSet`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SortedMultiSet`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also this library provides a possibility to define additional operations on
    existing collections via an implicit enrichment. The following import is required
    to make it available:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And it delivers these methods:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'On Seq: `intersperse` and `replaced`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Map: `zipByKey`, `join`, `zipByKeyWith`, `mergeByKey`, `mergeByKeyWith`, `fullOuterJoin`,
    `leftOuterJoin`, and `rightOUterJoing`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Map：`zipByKey`、`join`、`zipByKeyWith`、`mergeByKey`、`mergeByKeyWith`、`fullOuterJoin`、`leftOuterJoin`和`rightOuterJoin`
- en: Please consult the module documentation at [https://github.com/scala/scala-collection-contrib](https://github.com/scala/scala-collection-contrib)
    for further details.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅[https://github.com/scala/scala-collection-contrib](https://github.com/scala/scala-collection-contrib)模块文档以获取更多详细信息。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Scala 2.13 is a minor update of Scala with the main focus on the redesigned
    collection library. The few small additions to the standard library, such as automatic
    resource management, just accentuate this fact.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 2.13是Scala的一个小更新，主要关注重新设计的集合库。标准库中的一些小增补，如自动资源管理，只是强调了这一点。
- en: The new collection library mainly consists of two intermixed inheritance hierarchies
    with a similar shape. Members of the first hierarchy describe the structure of
    the collection and members of the second hierarchy—operations available on this
    collection type. Because of the inheritance relations, the collections situated
    lower in the tree define additional methods for more specific collections and
    override methods defined by the parent traits to provide more efficient implementation
    as required.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新的集合库主要由两个形状相似的混合继承层次结构组成。第一个层次结构的成员描述了集合的结构，而第二个层次结构的成员——在这个集合类型上可用的操作。由于继承关系，位于树中较低位置的集合定义了针对更具体集合的额外方法，并覆盖了父特质定义的方法，以提供更高效的实现。
- en: The three main collection types are `Seq`, `Set`, and `Map`. Each of these types
    has multiple implementations that are useful in specific situations. Set is also
    a function of one argument; `Seq` and `Map` are `PartialFunctions`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要的集合类型是`Seq`、`Set`和`Map`。每种类型都有多种实现，适用于特定的情况。Set也是一个单参数函数；`Seq`和`Map`是`PartialFunctions`。
- en: Most of the collections are available in mutable and immutable forms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数集合都提供可变和不可变的形式。
- en: In addition to the collection hierarchies, there is a concept of View, which
    is a reified definition of iterators’ operations and can be used to lazily apply
    transformations to the collection. Another related abstraction is `IterableFactory`,
    which implements some general ways to create collection instances and to perform
    conversions between collection representations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合层次结构之外，还有一个概念叫做View，它是迭代器操作的具体化定义，可以用来对集合进行懒加载的转换。另一个相关的抽象是`IterableFactory`，它实现了一些创建集合实例和在不同集合表示之间进行转换的通用方法。
- en: In the next chapter, we will shift our focus from the new features of version
    2.13 to a general exploration of Scala, starting with its type system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的重点从2.13版本的特性转移到对Scala的一般探索，从其类型系统开始。
- en: Questions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe two ways to make it possible for some resource, `R`, to use it together
    with `scala.util.Using` resource management utility.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述两种使某些资源`R`能够与`scala.util.Using`资源管理实用工具一起使用的方法。
- en: How can an instance of a `Set` and an instance of a `List` be compared to each
    other?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何比较一个`Set`实例和一个`List`实例？
- en: Name the default concrete implementation for an immutable `Seq`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不可变`Seq`命名默认的具体实现。
- en: Name the default concrete implementation for an immutable indexed `Seq`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不可变索引`Seq`命名默认的具体实现。
- en: Name the default concrete implementation for a mutable `Seq`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可变`Seq`命名默认的具体实现。
- en: Name the default concrete implementation for a mutable indexed `Seq`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可变索引`Seq`命名默认的具体实现。
- en: It is sometimes said that `List.flatMap` is more powerful than it was expected
    to be. Can you explain why?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候人们说`List.flatMap`比预期的更强大。你能解释为什么吗？
- en: Describe a way to map over a collection multiple times using different functions
    but without producing intermediate collections.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一种方法，使用不同的函数多次映射集合，但又不产生中间集合。
- en: Further reading
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Mads Hartmann, Ruslan Shevchenko, Professional Scala: Write concise and expressive,
    type-safe code in an environment that lets you build for the JVM, browser, and
    more.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mads Hartmann, Ruslan Shevchenko，专业Scala：在允许你为JVM、浏览器等构建环境的条件下，编写简洁且富有表现力的、类型安全的代码。
- en: Vikash Sharma, *Learning Scala Programming: **Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you*.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vikash Sharma，*学习Scala编程：**学习如何在Scala中编写可扩展和并发程序，这是一种随着你成长的语言*。
