- en: Migrating Applications to Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序迁移到Java 9
- en: In the previous chapter, we took a close look at the structure of Java modules
    as specified by Project Jigsaw and examined how Project Jigsaw was implemented
    to improve the Java platform. We also reviewed key internal changes to the Java
    platform with specific focus on the new modular system. We started with a modular
    primer where we learned about Java 9's modular system in terms of benefits and
    requirements. Next, we explored how Java 9 introduced modularity to the JDK. This
    included a look at how the source code was reorganized for Java 9\. We also explored
    the JDK's seven primary tool categories and learned that Java 9 modularity extends
    to runtime images resulting in more maintainability, better performance, and increased
    security. The concept of **link time** was introduced as an optional phase between
    compile-time and runtime. We concluded the chapter with a look at the **Java linker**
    and how Java 9 encapsulates internal APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们仔细研究了Project Jigsaw指定的Java模块结构，并检查了Project Jigsaw是如何实施以改进Java平台的。我们还回顾了Java平台的关键内部更改，特别关注新的模块化系统。我们从模块入门开始，了解了Java
    9的模块化系统在优势和需求方面的内容。接下来，我们探讨了Java 9是如何将模块化引入JDK的。这包括对Java 9源代码重组的考察。我们还探讨了JDK的七个主要工具类别，并了解到Java
    9的模块化扩展到运行时镜像，从而提高了可维护性、性能和安全性。我们引入了**链接时间**的概念，作为编译时间和运行时之间可选的阶段。我们以对**Java链接器**的考察和Java
    9如何封装内部API来结束本章。
- en: In this chapter, we will explore how to migrate our existing applications to
    the Java 9 platform. We will look at both manual and semi-automated migration
    processes. Java 9 is a major release with numerous changes to the JDK so developers
    should not be surprised if their Java 8 code no longer works with Java 9\. This
    chapter aims to provide you with insights and processes to get your Java 8 code
    working with Java 9.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将现有应用程序迁移到Java 9平台。我们将查看手动和半自动迁移过程。Java 9是一个重大版本，对JDK进行了许多更改，因此如果开发者的Java
    8代码不再与Java 9兼容，开发者不应该感到惊讶。本章旨在为您提供洞察力和过程，以便使您的Java 8代码与Java 9兼容。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Quick review of Project Jigsaw
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Project Jigsaw的快速回顾
- en: How modules fit into the Java landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块如何在Java生态系统中定位
- en: Migration planning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移计划
- en: Advice from Oracle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Oracle的建议
- en: Useful tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的工具
- en: Quick review of Project Jigsaw
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Project Jigsaw的快速回顾
- en: 'Project Jigsaw is the Java project that encompasses several change recommendations
    to the Java platform. As you have read in earlier chapters, Java 9''s greatest
    changes involve modules and modularity. The initiative to move to modules in Java
    was driven by Project Jigsaw. The need for modularity stemmed from two major challenges
    with Java:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Project Jigsaw是涵盖对Java平台进行多项变更建议的Java项目。正如您在前面章节中读到的，Java 9的最大变化涉及模块化和模块。将Java迁移到模块的倡议是由Project
    Jigsaw推动的。对模块化的需求源于Java的两个主要挑战：
- en: Classpath
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Classpath
- en: JDK
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK
- en: Next, we will review both of those challenges and see how they were addressed
    and overcome with the new release to the Java platform, Java 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾这两个挑战，并看看它们是如何在Java平台的新版本Java 9中得到解决和克服的。
- en: Classpath
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Classpath
- en: 'Prior to Java 9, the classpath was problematic and the source of developer
    anguish. This was evident in the numerous developer forums and, fortunately, Oracle
    was paying attention. Here are the several instances in which the classpath can
    be problematic; here are two primary cases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，类路径存在问题，是开发者痛苦的来源。这在众多开发者论坛中很明显，幸运的是，Oracle正在关注这个问题。以下是类路径可能存在问题的几个实例；以下是两个主要案例：
- en: The first case involves having two or more versions of a library on your development
    computer. The way this was previously handled by the Java system was inconsistent.
    Which library was used during the class loading process was anyone's guess. This
    resulted in an undesired lack of specificity--not enough details regarding which
    library was loaded.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况涉及在您的开发计算机上安装两个或更多版本的库。以前Java系统处理这种情况的方式并不一致。在类加载过程中使用哪个库是任何人都可以猜测的。这导致了不希望的不确定性——关于加载了哪个库的细节不足。
- en: The second case is in exercising the most advanced features of the class loader.
    Often times, this type of class loader usage resulted in the most errors and bugs.
    These were not always easy to detect and resulted in a lot of extra work for developers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是在使用类加载器的最先进功能。很多时候，这种类加载器的使用导致了最多的错误和bug。这些错误并不总是容易检测到，并为开发者带来了很多额外的工作。
- en: Classpaths, before Java 9, were almost always very lengthy. Oracle, in a recent
    presentation, shared a classpath that contained 110 JAR files. This type of unwieldy
    classpath makes it difficult to detect conflicts or even determine if anything
    was missing and if so, what might be missing. The re-envisioning of the Java platform
    as a modular system made these classpath issues a thing of the past.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，类路径几乎总是非常长。Oracle 在最近的一次演讲中分享了一个包含 110 个 JAR 文件的类路径。这种难以管理的类路径使得检测冲突或确定是否缺少某些内容变得困难，如果缺少，可能缺少什么。将
    Java 平台重新构想为模块系统使得这些类路径问题成为过去式。
- en: Modules solve the pre-Java 9 classpath problem by providing reliable configuration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过提供可靠的配置解决了 Java 9 之前的类路径问题。
- en: The monolithic nature of the JDK
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 的单体性质
- en: 'Java has continually evolved in an impressive fashion since 1995 and with each
    evolutionary step, the JDK grew larger. As with Java 8, the JDK had become prohibitively
    large. Prior to Java 9, there were several problematic issues stemming from the
    monolithic nature of the JDK, including:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1995 年以来，Java 不断以令人印象深刻的方式发展，并且随着每一次的进化步骤，JDK 都变得越来越大。与 Java 8 类似，JDK 已经变得过于庞大。在
    Java 9 之前，由于 JDK 的单体性质，存在一些问题，包括：
- en: Because the JDK is so large, it does not fit on very small devices. In some
    development sectors this is enough reason to find a non-Java solution for software
    engineering problems.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 JDK 非常大，它不适合非常小的设备。在一些开发领域，这足以成为寻找非 Java 解决方案来解决软件工程问题的理由。
- en: The oversized JDK resulted in waste. It was wasteful in terms of processing
    and memory when running on devices, networks, and the cloud. This stems from the
    fact that the entire JDK is loaded, even when only a small subset of the JDK is
    required.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过大的 JDK 导致了浪费。在设备、网络和云上运行时，在处理和内存方面都造成了浪费。这源于整个 JDK 都被加载，即使只需要 JDK 的一小部分。
- en: While the Java platform has great performance when running, the startup performance,
    in terms of load and launch times, leaves much to be desired.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 Java 平台在运行时具有出色的性能，但在启动性能方面，即加载和启动时间，还有很大的提升空间。
- en: The vast number of internal APIs has also been a pain point. Because so many
    internal APIs existed and were used by developers, the system has been difficult
    to evolve.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量庞大的内部 API 也一直是一个痛点。由于存在如此多的内部 API 并被开发者使用，系统难以进化。
- en: The existence of internal APIs has made it difficult to make the JDK secure
    and scalable. With so many internal dependencies, isolating security and scalability
    issues has been overly problematic.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部 API 的存在使得使 JDK 安全和可扩展变得困难。由于存在如此多的内部依赖，隔离安全和可扩展性问题变得过于复杂。
- en: The answer to the monolithic woes of the JDK is the module. Java 9 introduced
    the module and its own modular system. One of the great updates to the platform
    is that only the modules needed are compiled, as opposed to the entire JDK. This
    modular system is covered throughout this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 JDK 单体问题的答案是模块。Java 9 引入了模块及其自己的模块系统。平台的一个重大更新是，只需编译所需的模块，而不是整个 JDK。这个模块系统在本书中进行了全面介绍。
- en: Modules solve the pre-Java 9 JDK monolithic issue by providing strong encapsulation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过提供强封装解决了 Java 9 之前 JDK 的单体问题。
- en: How modules fit into the Java landscape
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块如何融入 Java 生态系统
- en: As you can see from the following illustration, packages are comprised of classes
    and interfaces, and modules are comprised of packages. Modules are a container
    of packages. This is the basic premise, at a very high level, of Java 9's new
    modular system. It is important to view modules as part of the modular system
    and not simply as a new level of abstraction above packages, as the illustration
    might suggest.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下插图中所见，包由类和接口组成，而模块由包组成。模块是包的容器。这是 Java 9 新模块系统的基本前提，从非常高的层面来看。重要的是要将模块视为模块系统的一部分，而不仅仅是包之上的一个新抽象级别，正如插图可能暗示的那样。
- en: '![](img/89681376-2954-4ed2-a21d-1be3e4e0654b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89681376-2954-4ed2-a21d-1be3e4e0654b.png)'
- en: 'So, modules are new to Java 9 and they, as you would expect, require declaration
    before they can be used. A module''s declaration includes names of other modules
    in which it has a dependency. It also exports packages for other modules that
    have dependencies to it. Modular declarations are arguably the most important
    modular issue to address as you start developing with Java 9\. Here is an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块是 Java 9 的新特性，正如你所预期的，在使用之前需要声明。模块的声明包括它所依赖的其他模块的名称。它还导出其他模块依赖的包。模块声明可能是你在开始使用
    Java 9 开发时需要解决的最重要的问题。以下是一个示例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When programming a Java 9 application, your module declarations will be placed
    in a `module-info.java` file. Once this file is completed, you simply run `javac`,
    the Java Compiler, to generate the `module-info.class` Java class file. You accomplish
    this task in the same manner that you currently compile your `.java` files into
    `.class` files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程 Java 9 应用程序时，你的模块声明将放置在 `module-info.java` 文件中。一旦完成此文件，你只需运行 `javac`，Java
    编译器，以生成 `module-info.class` Java 类文件。你将以与当前编译 `.java` 文件到 `.class` 文件相同的方式完成此任务。
- en: You can also create modular JAR files that have your `module-info.class` file
    at its root. This represents a great level of flexibility.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建具有根目录中的 `module-info.class` 文件的模块 JAR 文件。这代表了一个很高的灵活性。
- en: Base module
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础模块
- en: 'When programming Java 9 applications, or porting existing applications programmed
    with older versions of Java, the base module (`java.base`) must be used. Every
    module requires the `java.base` module because it defines the critical, or foundational,
    Java platform APIs. Here are the contents of the `java.base` module:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程 Java 9 应用程序或移植使用旧版 Java 编写的现有应用程序时，必须使用基本模块 (`java.base`)。每个模块都需要 `java.base`
    模块，因为它定义了关键的或基础性的 Java 平台 API。以下是 `java.base` 模块的内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `java.base` module does not require any modules and it exports
    numerous packages. It can be useful to have a list of these exports handy so you
    know what is available to you as you start creating applications using the new
    Java platform, Java 9.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`java.base` 模块不需要任何模块，并且导出许多包。在开始使用新的 Java 平台，Java 9 创建应用程序时，有一个这些导出包的列表会很有用，这样你就知道可以使用什么了。
- en: 'You will notice that in the previous section, we did not include the `requires
    java.base;` line of code in our declaration of our `com.three19.irisScan` module.
    The updated code is provided as follows and now includes the `requires java.base;`
    line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前一节中，我们没有在我们的 `com.three19.irisScan` 模块声明中包含 `requires java.base;` 代码行。更新后的代码如下，并现在包含了
    `requires java.base;` 代码行：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you do not include the `requires java.base;` line of code in your module
    declarations, the Java Compiler will automatically include it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在模块声明中包含 `requires java.base;` 代码行，Java 编译器将自动包含它。
- en: Reliable configuration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠配置
- en: As suggested earlier in this chapter, modules provide a reliable configuration
    of our Java 9 applications that solves the classpath problem in earlier versions
    of the Java platform.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所建议的，模块为我们提供了可靠的 Java 9 应用程序配置，解决了早期 Java 平台版本中的类路径问题。
- en: 'Java reads and interprets modular declarations making the modules readable.
    These readable modules permit the Java platform to determine if any modules are
    missing, if there are duplicate libraries declared, or there are any other conflicts.
    In Java 9, very specific error messages will be generated and output by the compiler
    or at runtime. Here is an example of a compile-time error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Java 读取并解释模块声明，使得模块可读。这些可读的模块允许 Java 平台确定是否存在缺失的模块、是否有重复声明的库，或者存在其他冲突。在 Java
    9 中，编译器或运行时将生成并输出非常具体的错误信息。以下是一个编译时错误的示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an example of a runtime error that would occur if the module `com.three19.isrisCore`
    was not found, but required by the `com.three19.irisScan` app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到模块 `com.three19.isrisCore` 但 `com.three19.irisScan` 应用程序需要它，将会发生以下运行时错误：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Strong encapsulation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强封装
- en: 'Earlier in this chapter, you read that Java 9''s strong encapsulation remedied
    the monolithic JDK issue. Encapsulation, in Java 9, is driven by the information
    in the `module-info.java` file. The information in this file lets Java know what
    modules are dependent upon others and what each of them exports. This underscores
    the importance of ensuring our `module-info-java` files are properly configured.
    Let''s look at an example written with standard Java code, nothing new in Java
    9 in the way this was coded:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你了解到Java 9的强封装解决了单一代码库（JDK）的问题。在Java 9中，封装是由`module-info.java`文件中的信息驱动的。这个文件中的信息让Java知道哪些模块依赖于其他模块，以及每个模块导出了什么。这强调了确保我们的`module-info.java`文件正确配置的重要性。让我们看看一个用标准Java编写的示例，这种方式在Java
    9中没有引入任何新内容：
- en: '![](img/241204f0-a964-45ce-b51c-f605109382a9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/241204f0-a964-45ce-b51c-f605109382a9.png)'
- en: 'In the preceding example, the `com.three19.irisScan` module has an `irisScanner`
    package intended for internal use and an `irisScanResult` class. If the `com.three19.access`
    application tries to import and use the `irisScanResult` class, the following
    error message will be produced by the Java Compiler:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`com.three19.irisScan`模块有一个用于内部使用的`irisScanner`包和一个`irisScanResult`类。如果`com.three19.access`应用程序尝试导入和使用`irisScanResult`类，Java编译器将产生以下错误信息：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If for some reason the compiler does not catch this error, although it would
    be very unlikely, the following runtime error would occur:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因编译器没有捕获这个错误，尽管这非常不可能，以下运行时错误将会发生：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The detailed error messages will make debugging and troubleshooting much easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 详细错误信息将使调试和故障排除变得更加容易。
- en: Migration planning
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移规划
- en: The changes to the Java platform are significant and Java 9 is considered a
    major release. It would be naive to think our current Java applications will work
    seamlessly on Java 9\. While that might be the case, at least for simple programs,
    it is prudent to plan ahead and consider the issues you are most likely to encounter.
    Before we look at these issues, let's test a simple Java application in the next
    section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台的变化是显著的，Java 9被认为是一个重大版本。认为我们的当前Java应用程序将在Java 9上无缝工作是很天真的。虽然这可能成立，至少对于简单的程序来说，提前规划并考虑你可能会遇到的问题是很谨慎的。在我们查看这些问题之前，让我们在下一节测试一个简单的Java应用程序。
- en: Testing a simple Java application
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试简单的Java应用程序
- en: 'The following code consists of a single Java class, `GeneratePassword.` This
    class prompts the user for a desired password length and then generates a password
    based on the user''s requested length. If the user asks for a length shorter than
    8, the default length of 8 will be used. This code was written with the Java SE
    1.7 JRE System Library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含一个单一的Java类，`GeneratePassword.` 这个类会提示用户输入所需的密码长度，然后根据用户请求的长度生成密码。如果用户请求的长度小于8，将使用默认长度8。此代码是用Java
    SE 1.7 JRE系统库编写的：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following screenshot, we test the `GeneratePassword` app on a Mac running
    Java 8\. As you can see, we start by querying Java to verify the current version.
    In this test, Java `1.8.0_121` was used. Next, we compile the `GeneratePassword`
    Java file using the `javac` utility. Lastly, we run the app:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图，我们在运行Java 8的Mac上测试了`GeneratePassword`应用程序。如图所示，我们首先查询Java以验证当前版本。在这个测试中，使用了Java
    `1.8.0_121`。接下来，我们使用`javac`实用工具编译`GeneratePassword` Java文件。最后，我们运行了应用程序：
- en: '![](img/2028cdc6-0fd5-4b97-a1b0-098212dd72f6.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2028cdc6-0fd5-4b97-a1b0-098212dd72f6.png)'
- en: As you can see from the preceding test, `GeneratePassword.java` was successfully
    compiled with the `GeneratePassword.class` file resulting. The application was
    run using the `java GeneratePassword` command. The user was prompted for a desired
    password length and `32` was entered. The application then successfully generated
    a 32-character random password and provided the appropriate output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文测试所示，`GeneratePassword.java` 编译成功，生成了 `GeneratePassword.class` 文件。应用程序使用
    `java GeneratePassword` 命令运行。用户被提示输入所需的密码长度，并输入了 `32`。然后应用程序成功生成了一个32位的随机密码，并提供了相应的输出。
- en: This test demonstrated the example application works successfully using JDK
    1.8\. Next, let's test the same application using JDK 9.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试演示了示例应用程序使用JDK 1.8成功运行。接下来，让我们使用JDK 9测试同一个应用程序。
- en: 'We start with the `java -version` command to show that we are using JDK 9 on
    this computer. The following screenshot shows that we successfully compiled the
    `.java` file to a `.class` file. When the application was run, it functioned as
    expected and provided the proper results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `java -version` 命令开始，以表明我们在这台计算机上使用 JDK 9。以下截图显示我们成功将 `.java` 文件编译成 `.class`
    文件。当应用程序运行时，它按预期工作并提供了正确的结果：
- en: '![](img/b7818208-6821-45d3-8543-275953546fe3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7818208-6821-45d3-8543-275953546fe3.png)'
- en: As you can see, we clearly demonstrated that a pre-Java 9 application has the
    potential to successfully run on Java 9 without having to make any modifications.
    This is a simple case study and featured a very basic Java program. This is, of
    course, the best case scenario, and cannot be assumed. You will want to test your
    applications to ensure they run as expected on the Java 9 platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们清楚地证明了 Java 9 之前的应用程序有可能在无需进行任何修改的情况下成功运行在 Java 9 上。这是一个简单的案例研究，并展示了一个非常基础的
    Java 程序。这当然是最好的情况，不能假设。你将想要测试你的应用程序，以确保它们在 Java 9 平台上按预期运行。
- en: In the next section, we will review some potential issues you might encounter
    when testing your pre-Java 9 applications using the new Java platform with JDK
    9.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些在使用带有 JDK 9 的新 Java 平台测试你的 Java 9 之前的应用程序时可能会遇到的问题。
- en: Potential migration issues
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潜在迁移问题
- en: The potential migration issues featured in this section include direct access
    to the JRE, access to internal APIs, accessing internal JARs, JAR URL depreciation,
    the extension mechanism, and the JDK's modularization. Let's look at each of these
    potential migration issues.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到的潜在迁移问题包括直接访问 JRE、访问内部 API、访问内部 JAR、JAR URL 废弃、扩展机制以及 JDK 的模块化。让我们逐一查看这些潜在的迁移问题。
- en: The JRE
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JRE
- en: 'Creating the Java 9''s modular system resulted in some simplification in respect
    to the number and location of development and utility tools. One such example
    is the JDK''s consumption of the JRE. In all pre-Java 9 versions, the Java platform
    included the JDK and JRE as two separate components. In Java 9, these components
    have been combined. This is a significant change and one that developers should
    be keenly aware of. If you have an application that specifically points to the
    JRE directory, you will need to make changes to avoid problems. The JRE contents
    are shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Java 9 的模块化系统在开发工具和实用工具的数量和位置上带来了一些简化。一个例子是 JDK 对 JRE 的消耗。在所有 Java 9 之前的版本中，Java
    平台将 JDK 和 JRE 作为两个单独的组件包含在内。在 Java 9 中，这些组件已经被合并。这是一个重大的变化，开发者应该密切关注。如果你有一个指向
    JRE 目录的应用程序，你需要进行更改以避免问题。JRE 内容如下所示：
- en: '![](img/ca4dce21-485e-43cc-9627-bab90e65decd.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca4dce21-485e-43cc-9627-bab90e65decd.png)'
- en: Access to internal APIs
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问内部 API
- en: The Java 9 platform has encapsulated internal APIs to increase security of the
    platform and applications written in Java. Applications that you program in Java
    9 will not have default access to the JDK's internal APIs, unlike with previous
    versions of the Java platform. Oracle has identified some internal APIs as critical;
    those APIs remain accessible via the `jdk.unsupported` JDK module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 平台已经封装了内部 API，以增加平台和用 Java 编写的应用程序的安全性。与 Java 平台之前的版本不同，你在 Java 9 中编写的应用程序将无法默认访问
    JDK 的内部 API。Oracle 已经将一些内部 API 识别为关键；这些 API 通过 `jdk.unsupported` JDK 模块保持可访问。
- en: 'The aforementioned critical APIs (internal to the JDK) are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关键 API（JDK 内部）包括：
- en: '`sun.misc`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc`'
- en: '`sun.misc.Unsafe`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`'
- en: '`sun.reflect.Reflection`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.Reflection`'
- en: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
- en: If you have pre-Java 9 applications that implement any `sun.*` or `com.sun.*`
    package, you will likely run into problems migrating your applications to Java
    9\. In order to address this issue, you should review your class files for use
    of `sun.*` and `com.sun.*` packages. Alternatively, you can use the Java dependency
    analysis tool, `jdeps`, to help determine if your Java program has any dependencies
    on JDK internal APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的应用程序是 Java 9 之前的版本，并且实现了任何 `sun.*` 或 `com.sun.*` 包，那么在迁移到 Java 9 时你可能会遇到问题。为了解决这个问题，你应该检查你的类文件以确定是否使用了
    `sun.*` 和 `com.sun.*` 包。或者，你可以使用 Java 依赖分析工具 `jdeps` 来帮助确定你的 Java 程序是否有任何依赖 JDK
    内部 API。
- en: The `jdeps` tool is the Java dependency analysis tool, that can be used to help
    determine if your Java program has any dependencies on JDK internal APIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps` 工具是 Java 依赖分析工具，可以用来帮助确定你的 Java 程序是否有任何依赖 JDK 内部 API。'
- en: Accessing internal JARs
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问内部JAR文件
- en: 'Java 9 does not permit access to internal JARs such as `lib/ant-javax.jar`,
    `lib/dt.jar`, and others listed in the `lib` directory shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9不允许访问内部JAR文件，例如`lib/ant-javax.jar`、`lib/dt.jar`以及在此处显示的`lib`目录中列出的其他文件：
- en: '![](img/07a317a6-bc1c-40cf-93df-2d0e548ce833.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07a317a6-bc1c-40cf-93df-2d0e548ce833.png)'
- en: The key thing to note here is that if you have Java applications that are dependent
    on one of these tools residing in the `lib` folder, you will need to modify your
    code accordingly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的关键点是，如果你有依赖于`lib`文件夹中这些工具之一的Java应用程序，你需要相应地修改你的代码。
- en: It is recommended that you test your IDE once you start using Java 9 to ensure
    the IDE is updated and officially supports Java 9\. If you use more than one IDE
    for Java development, test each one to avoid surprises.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在开始使用Java 9之前测试你的IDE，以确保IDE已更新并官方支持Java 9。如果你使用多个IDE进行Java开发，测试每一个以避免意外。
- en: JAR URL depreciation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAR URL弃用
- en: 'JAR file URLs were, prior to Java 9, used by some APIs to identify specific
    files in the runtime image. These URLs contain a `jar:file:` prefix with two paths;
    one to the `jar` and one to the specific resource file within the `jar`. Here
    is the syntax for the pre-Java 9 JAR URL:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，JAR文件URL被一些API用来标识运行时图像中的特定文件。这些URL包含一个`jar:file:`前缀和两个路径；一个指向`jar`，另一个指向`jar`内的特定资源文件。以下是Java
    9之前JAR URL的语法：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the advent of Java 9''s modular system, containers will house resource
    files instead of individual JARs. The new syntax for accessing resource files
    is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 9模块系统的出现，容器将包含资源文件而不是单个JAR文件。访问资源文件的新语法如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A new URL schema, `jrt`, is now in place for naming resources within a runtime
    image. These resources include classes and modules. The new schema allows for
    the identification of a resource without introducing a security risk to the runtime
    image. This increased security ensures that the runtime image''s form and structure
    remain concealed. Here is the new schema:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新的URL模式`jrt`用于在运行时图像内命名资源。这些资源包括类和模块。新的模式允许在不引入运行时图像安全风险的情况下识别资源。这种增强的安全性确保了运行时图像的形式和结构保持隐蔽。以下是新的模式：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Interestingly, a `jrt` URL''s structure determines its meaning, suggesting
    that the structure can take one of several forms. Here are three examples of different
    `jrt` URL structures:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`jrt` URL的结构决定了其含义，这表明结构可以采取几种不同的形式。以下是三个不同`jrt` URL结构的示例：
- en: '`jrt:/$MODULE/$PATH`: This structure provides access to the resource file,
    identified with the `$PATH` parameter, within the module specified with the `$MODULE`
    parameter'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/$MODULE/$PATH`：这种结构提供了通过`$PATH`参数指定的资源文件，在由`$MODULE`参数指定的模块内的访问。'
- en: '`jrt:/$MODULE`: This structure provides reference to all resource files within
    the module specified with the `$MODULE` parameter'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/$MODULE`：这种结构提供了对由`$MODULE`参数指定的模块内所有资源文件的引用'
- en: '`jrt:/`: This structure provides reference to all resource files in the runtime
    image'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jrt:/`：这种结构提供了对运行时图像中所有资源文件的引用'
- en: If you have preexisting code that uses URL instances, returned by APIs, you
    should not have any problems. On the other hand, if your code is dependent on
    the `jar` URL structure, you will have problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的代码已经包含了由API返回的URL实例，你应该不会遇到任何问题。另一方面，如果你的代码依赖于`jar` URL结构，你将会遇到问题。
- en: Extension mechanism
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展机制
- en: 'The Java platform previously had an extension mechanism that gave developers
    the ability to make custom APIs available to all applications. As you can see
    in the following illustration, extensions are plugins of sorts, or add-ons to
    the Java platform. The APIs and classes in each extension are, by default, automatically
    available:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台之前有一个扩展机制，允许开发者将自定义API提供给所有应用程序。正如以下插图所示，扩展是某种插件，或者是Java平台的附加组件。每个扩展中的API和类默认情况下都是自动可用的：
- en: '![](img/d7fd1ca1-b597-4197-88eb-f338871ba25a.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7fd1ca1-b597-4197-88eb-f338871ba25a.png)'
- en: As the illustration suggests, Java applications have access both to the Java
    platform and extensions without requiring classpaths. This feature was depreciated
    in Java 8 and no longer exists in Java 9.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如插图所示，Java应用程序可以访问Java平台和扩展，而无需要求类路径。这个特性在Java 8中被弃用，并且在Java 9中不再存在。
- en: The JDK's modularization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK的模块化
- en: 'By now, you have a firm appreciation of Java 9''s modularization. The old adage
    in Java, and other object-oriented programming language, is *everything is a class*.
    Now, with Java 9, *everything is a module* is the new adage. There are three type
    of modules as explained as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经对 Java 9 的模块化有了深刻的理解。Java 中的古老谚语，以及其他面向对象编程语言，是“万物皆类”。现在，随着 Java 9
    的到来，“万物皆模块”成为新的谚语。有三种类型的模块，如下所述：
- en: '| **Module type** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **模块类型** | **描述** |'
- en: '| Automatic | When a JAR is placed on a new module path, modules are automatically
    created |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 自动 | 当一个 JAR 文件放置在新的模块路径上时，模块会自动创建 |'
- en: '| Explicit/Named | These modules are manually defined by editing the `module-info.java`
    file |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 显式/命名 | 这些模块通过编辑 `module-info.java` 文件手动定义 |'
- en: '| Unnamed | When a JAR is placed on a classpath, unnamed modules are created
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 未命名 | 当一个 JAR 文件放置在类路径上时，会创建未命名的模块 |'
- en: When you migrate your applications to Java 9, your application and its libraries
    become unnamed modules. So, you will need to ensure all the modules are in the
    module path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将应用程序迁移到 Java 9 时，你的应用程序及其库将成为未命名的模块。因此，你需要确保所有模块都在模块路径中。
- en: 'Another thing to be aware of is that your runtime image will not contain the
    entire JDK. Instead, it will only contain the modules your application requires.
    It is worth reviewing how the JDK is modularized in Java 9\. The following table
    contains the API specification for the JDK in Java 9:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，你的运行时镜像将不会包含整个 JDK。相反，它将只包含你的应用程序所需的模块。值得回顾 Java 9 中 JDK 的模块化方式。以下表格包含
    Java 9 中 JDK 的 API 规范：
- en: '| `jdk.accessibility` | `jdk.attach` | `jdk.charsets` | `jdk.compiler` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.accessibility` | `jdk.attach` | `jdk.charsets` | `jdk.compiler` |'
- en: '| `jdk.crypto.cryptoki` | `jdk.crypto.ec` | `jdk.dynalink` | `jdk.editpad`
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.crypto.cryptoki` | `jdk.crypto.ec` | `jdk.dynalink` | `jdk.editpad`
    |'
- en: '| `jdk.hotspot.agent` | `jdk.httpserver` | `jdk.incubator.httpclient` | `jdk.jartool`
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.hotspot.agent` | `jdk.httpserver` | `jdk.incubator.httpclient` | `jdk.jartool`
    |'
- en: '| `jdk.javadoc` | `jdk.jcmd` | `jdk.jconsole` | `jdk.jdeps` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.javadoc` | `jdk.jcmd` | `jdk.jconsole` | `jdk.jdeps` |'
- en: '| `jdk.jdi` | `jdk.jdwp.agent` | `jdk.jlink` | `jdk.jshell` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.jdi` | `jdk.jdwp.agent` | `jdk.jlink` | `jdk.jshell` |'
- en: '| `jdk.jsobject` | `jdk.jstatd` | `jdk.localedata` | `jdk.management` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.jsobject` | `jdk.jstatd` | `jdk.localedata` | `jdk.management` |'
- en: '| `jdk.management.agent` | `jdk.naming.dns` | `jdk.naming.rmi` | `jdk.net`
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.management.agent` | `jdk.naming.dns` | `jdk.naming.rmi` | `jdk.net`
    |'
- en: '| `jdk.pack` | `jdk.packager.services` | `jdk.policytool` | `jdk.rmic` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.pack` | `jdk.packager.services` | `jdk.policytool` | `jdk.rmic` |'
- en: '| `jdk.scripting.nashorn` | `jdk.sctp` | `jdk.security.auth` | `jdk.security.jgss`
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.scripting.nashorn` | `jdk.sctp` | `jdk.security.auth` | `jdk.security.jgss`
    |'
- en: '| `jdk.snmp` | `jdk.xml.dom` | `jdk.zipfs` |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `jdk.snmp` | `jdk.xml.dom` | `jdk.zipfs` |  |'
- en: 'The following table contains the API specification for Java SE in Java 9:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含 Java 9 中 Java SE 的 API 规范：
- en: '| `java.activation` | `java.base` | `java.compiler` | `java.cobra` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `java.activation` | `java.base` | `java.compiler` | `java.cobra` |'
- en: '| `java.datatransfer` | `java.desktop` | `java.instrument` | `java.logging`
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `java.datatransfer` | `java.desktop` | `java.instrument` | `java.logging`
    |'
- en: '| `java.management` | `java.management.rmi` | `java.naming` | `java.prefs`
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `java.management` | `java.management.rmi` | `java.naming` | `java.prefs`
    |'
- en: '| `java.rmi` | `java.scripting` | `java.se` | `java.se.ee` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `java.rmi` | `java.scripting` | `java.se` | `java.se.ee` |'
- en: '| `java.security.jgss` | `java.security.sasi` | `java.sql` | `java.sql.rowset`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `java.security.jgss` | `java.security.sasi` | `java.sql` | `java.sql.rowset`
    |'
- en: '| `java.transaction` | `java.xml` | `java.xml.bind` | `java.xml.crypto` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `java.transaction` | `java.xml` | `java.xml.bind` | `java.xml.crypto` |'
- en: '| `java.xml.ws` | `java.xml.ws` | `java.xml.ws.annotation` |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `java.xml.ws` | `java.xml.ws` | `java.xml.ws.annotation` |  |'
- en: Remember, all applications will have access to `java.base` as it is in the module
    path by default.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有应用程序都将默认访问 `java.base`，因为它在模块路径中。
- en: 'The following table contains the API specification for JavaFX in Java 9:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含 Java 9 中 JavaFX 的 API 规范：
- en: '| `javafx.base` | `javafx.controls` | `javafx.fxml` | `javafx.graphics` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `javafx.base` | `javafx.controls` | `javafx.fxml` | `javafx.graphics` |'
- en: '| `javafx.media` | `javafx.swing` | `javafx.web` |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `javafx.media` | `javafx.swing` | `javafx.web` |  |'
- en: 'There are two additional modules:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个额外的模块：
- en: '`java.jnlp` defines the API for **JNLP** (**Java Network Launch Protocol**)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.jnlp` 定义了 **JNLP**（**Java 网络启动协议**）的 API'
- en: '`java.smartcardio` defines the API for the Java Smart Card Input/Output'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.smartcardio` 定义了 Java Smart Card 输入/输出的 API'
- en: 'For details on any of these modules, visit Oracle''s *Java® Platform, Standard
    Edition & Java Development Kit Version 9 API Specification* website: [http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Advice from Oracle
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle has done a great job in bringing us this major update, version 9, to
    the Java platform. Their insights into getting ready for Java 9 and how to migrate
    to the new JDK is worth reviewing. In this section, we will look at preparatory
    steps, breaking encapsulation, changes to the runtime image, components such as
    tools and APIs that have been removed, changes to garbage collection, and deployment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory steps
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracle provides a five-step process to help developers migrate their Java applications
    to version 9\. These steps are listed as follows and then covered in subsequent
    sections:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Get the JDK 9 early access build.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your program before recompiling.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update third-party libraries and tools.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your application.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `jdeps` on your code.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the JDK 9 early access build
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are reading this book before Java 9 is officially released, then you
    can obtain a JDK 9 early access build from here--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    Early release builds are available for Windows (32 and 64), macOS (64), Linux
    (32 and 64) and various Linux ARM, Solaris, and Alpine Linux versions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Taking the time to test your applications for Java 9 and get them migrated before
    Java 9 is officially released, helps ensure you will not experience any downtime
    for services that rely on your Java applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Running your program before recompiling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated earlier in this chapter, there is a chance that your existing Java
    applications will run without modification on the Java 9 platform. So, before
    you make any changes, try running your current application on the Java 9 platform.
    If your application works fine on Java 9, that is great, but your work is not
    complete. Review the next three sections on updating third-party libraries and
    tools, compiling your application, and running `jdeps` on your code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Updating third-party libraries and tools
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-party libraries and tools can help extend our applications and shorten
    development time. For Java 9 compatibility, it is important to ensure that each
    third-party library and tool you use is compatible with and supports version 9
    of the JDK. Running your application on Java 9 will not provide you with the level
    of insight you need to ensure you do not have compatibility issues down the road.
    It is recommended that you review the official website for each library and tool
    to verify compatibility with and support of JDK 9.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If a library or tool that you use does have a version that supports JDK 9, download
    and install it. If you find one that does not yet support JDK 9, consider finding
    a replacement for it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In our context, tools includes **Integrated Development Environments** (**IDE**).
    NetBeans, Eclipse, and IntelliJ all have IDE versions that support JDK 9\. Links
    to those sites are provided as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，工具包括 **集成开发环境**（**IDE**）。NetBeans、Eclipse 和 IntelliJ 都有支持 JDK 9 的 IDE
    版本。以下是如何访问这些网站的链接：
- en: '**NetBeans**: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetBeans**: [http://bits.netbeans.org/download/trunk/nightly/latest/](http://bits.netbeans.org/download/trunk/nightly/latest/)'
- en: '**Eclipse**: [https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php](https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse**: [https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php](https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php)'
- en: '**IntelliJ**: [https://www.jetbrains.com/idea/nextversion/](https://www.jetbrains.com/idea/nextversion/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ**: [https://www.jetbrains.com/idea/nextversion/](https://www.jetbrains.com/idea/nextversion/)'
- en: Compiling your application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译你的应用程序
- en: Your next step is to compile your application using JDK 9's `javac`. This is
    important, even if your app works fine on JDK 9\. You might not receive compiler
    errors, but watch for warnings too. Here are the most common reasons your applications
    might not compile with JDK 9, assuming they compiled fine prior to Java 9.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一步是使用 JDK 9 的 `javac` 编译你的应用程序。即使你的应用程序在 JDK 9 上运行良好，这也是很重要的。你可能不会收到编译器错误，但也要注意警告。以下是你可能不会使用
    JDK 9 编译应用程序的最常见原因，假设它们在 Java 9 之前已经编译成功。
- en: First, as indicated earlier in this chapter, most of the JDK 9 internal APIs
    are not accessible by default. Your indication will be an `IllegalAccessErrors`
    error at runtime or compile time. You will need to update your code so that you
    are using accessible APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如本章前面所述，大多数 JDK 9 内部 API 默认情况下不可访问。你的指示将是在运行时或编译时出现的 `IllegalAccessErrors`
    错误。你需要更新你的代码，以便使用可访问的 API。
- en: 'A second reason your pre-Java 9 applications might not compile with JDK 9 is
    if you use the underscore character as a single character identifier. According
    to Oracle, this practice generates a warning in Java 8 and an error in Java 9\.
    Let''s look at an example. The following Java class instantiates an Object named
    `_` and prints a singular message to the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可能导致你的 Java 9 之前的程序无法使用 JDK 9 编译的原因是如果你使用下划线字符作为单个字符标识符。根据 Oracle 的说法，这种做法在
    Java 8 中会产生警告，在 Java 9 中会产生错误。让我们看一个例子。以下 Java 类实例化了一个名为 `_` 的对象，并向控制台打印了一条单一的消息：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we compile this program with Java 8, we receive a warning that use of
    ''`_`'' as an identifier might not be supported in releases after Java SE 8:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Java 8 编译此程序时，会收到一个警告，指出使用 '`_`' 作为标识符可能在 Java SE 8 之后的版本中不受支持：
- en: '![](img/439330e1-2220-4844-8d86-5a62ac66b26d.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/439330e1-2220-4844-8d86-5a62ac66b26d.png)'
- en: 'As you can see in the following screenshot, that is just a warning and the
    application runs fine:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，这只是警告，应用程序运行正常：
- en: '![](img/289ba83c-97b4-4ab1-8970-5bfdd03c2a26.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/289ba83c-97b4-4ab1-8970-5bfdd03c2a26.png)'
- en: 'Now, let''s try compiling the same class using JDK 9:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用 JDK 9 编译相同的类：
- en: '![](img/ab44bf56-f1d9-42db-b913-348fcead1715.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab44bf56-f1d9-42db-b913-348fcead1715.png)'
- en: 'As you can see, use of the underscore as a single character identifier still
    only resulted in a warning and not an error. The application ran successfully.
    This test was run when JDK 9 was still in early release. It is assumed that running
    this test once JDK 9 has been officially released will result in an error instead
    of just a warning. The error that would likely be thrown is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将下划线用作单个字符标识符仍然只会产生警告，而不会产生错误。应用程序运行成功。这次测试是在 JDK 9 仍处于早期发布阶段时运行的。假设在 JDK
    9 正式发布后运行此测试将导致错误而不是仅仅警告。可能会抛出的错误如下：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if this issue is not resolved with the formal release of JDK 9, use of
    an underscore as a single character identifier is not good programming practice,
    so you should steer away from using it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个问题在 JDK 9 的正式版本中未得到解决，将下划线用作单个字符标识符也不是好的编程实践，因此你应该避免使用它。
- en: A third potential reason for your pre-Java 9 programmed application not to compile
    with JDK 9 is if you are using the `-source` and `-target` compiler options. Let's
    take a look at the `-source` and `-target` compiler options pre-Java 9 and with
    Java 9.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 导致你的 Java 9 之前的程序无法使用 JDK 9 编译的第三个潜在原因是如果你使用了 `-source` 和 `-target` 编译器选项。让我们看看
    Java 9 之前和 Java 9 中的 `-source` 和 `-target` 编译器选项。
- en: Pre-Java 9 -source and -target options
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 之前的 -source 和 -target 选项
- en: 'The `-source` option specifies the Java SE version and has the following acceptable
    values:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Description** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| 1.3 | `javac` does not support features introduced after Java SE 1.3. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| 1.4 | `javac` accepts code with language features introduced in Java SE 1.4.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| 1.5 or 5 | `javac` accepts code with languages features introduced in Java
    SE 1.5. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| 1.6 or 6 | `javac` reports encoding errors as errors instead of warnings.
    Of note, no new language features were intruded with Java SE 1.6. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| 1.7 or 7 | `javac` accepts code with language features introduced in Java
    SE 1.7\. This is the default value if the `-source` option is not used. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: 'The `-target` option tells `javac` what version of the JVM to target. The acceptable
    values for the `-target` option are--`1.1`, `1.2`, `1.3`, `1.4`, `1.5` or `5`,
    `1.6` or `6` and `1.7` or `7`. If the `-target` option is not used, the default
    JVM target is dependent on the value used with the `-source` option. Here is a
    table of `-source` values with their associated `-target`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '| **-source value** | **default -target** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| unspecified | 1.7 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| 1.2 | 1.4 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| 1.3 | 1.4 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| 1.4 | 1.4 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| 1.5 or 5 | 1.7 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| 1.6 or 6 | 1.7 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| 1.7 | 1.7 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: Java 9 -source and -target options
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java 9, the supported values are shown as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| **Supported values** | **Remarks** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| 9 | This is the default, should no value be specified |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| 8 | Sets support to 1.8 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| 7 | Sets support to 1.7 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| 6 | Sets support to 1.6 and generates a warning (not an error) to indicate
    JDK 6 is depreciated |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: Running jdeps on your code
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jdeps` class dependency analysis tool is not new to Java 9, but perhaps
    has never been as important to developers with the advent of Java 9\. An important
    step to migrating your applications to Java 9 is to run the `jdeps` tool to determine
    the dependencies your applications and its libraries have. The `jdeps` tool does
    a great job of suggesting replacements if your code has dependencies on any internal
    APIs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options available to you when using the
    `jdeps` analyzer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd824bf6-231e-4035-b54e-26d71097801e.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at an example. Here is a simple Java class called `DependencyTest`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s use `javac` to compile this class using Java 8:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87c5c505-99ed-4534-a92f-93e4f211c8fd.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, Java 8 successfully compiled the class and the application
    ran. The compiler did give us a `DependencyTest.java:6: warning: BASE64Encoder
    is internal proprietary API and may be removed in a future release` warning. Now,
    let''s see what happens when we try to compile this class using Java 9:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8692a45-1e67-4647-96f6-4978636aa766.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'In this case, with Java 9, the compiler gave us two warnings instead of one.
    The first warning is for the `import sun.misc.BASE64Encoder;` statement and the
    second for the `BASE64Encoder.class.newInstance();` method call. As you can see,
    these are just warnings and not errors, so the `DependencyTest.java` class file
    is successfully compiled. Next, let''s run the application:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用Java 9，编译器给出了两个警告而不是一个。第一个警告是针对`import sun.misc.BASE64Encoder;`语句的，第二个是针对`BASE64Encoder.class.newInstance();`方法调用的。如您所见，这些只是警告而不是错误，因此`DependencyTest.java`类文件成功编译。接下来，让我们运行应用程序：
- en: '![](img/2d882662-f769-4857-abdc-a2c57a9777a3.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d882662-f769-4857-abdc-a2c57a9777a3.png)'
- en: 'Now, we can clearly see that Java 9 will not allow us to run the application.
    Next, let''s run a dependency test using the `jdeps` analyzer tool. We will use
    the following command line syntax--`jdeps DependencyTest.class`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以清楚地看到Java 9不会允许我们运行应用程序。接下来，让我们使用`jdeps`分析工具运行一个依赖性测试。我们将使用以下命令行语法--`jdeps
    DependencyTest.class`:'
- en: '![](img/fb0f1506-75b5-4f58-bb41-b78f8e94ca12.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb0f1506-75b5-4f58-bb41-b78f8e94ca12.png)'
- en: 'As you can see, we have three dependencies: `java.io`, `java.lang`, and `sun.misc`.
    Here we are given the suggestion to replace our `sun.misc` dependency with `rt.jar`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有三个依赖项：`java.io`、`java.lang`和`sun.misc`。在这里，我们得到了将我们的`sun.misc`依赖项替换为`rt.jar`的建议。
- en: Breaking encapsulation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏封装
- en: The Java 9 platform is more secure than its predecessor versions due to, in
    part, the increased encapsulation that resulted from the modular reorganization.
    That being said, you might have a requirement to break through the modular system's
    encapsulation. Breaking through these access control boundaries is permitted by
    Java 9.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java 9平台在模块重组后增加了封装，因此与前辈版本相比，Java 9平台更加安全。话虽如此，您可能需要突破模块系统的封装。Java 9允许突破这些访问控制边界。
- en: As you read earlier in this chapter, most internal APIs are strongly encapsulated.
    As previously suggested, you might look for replacement APIs when updating your
    source code. Of course, that is not always feasible. There are three additional
    approaches you can take--using the `--add-opens` option at runtime; employing
    the `--add-exports` option; and `--permit-illegal-access` command-line option.
    Let's look at each of those options.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中之前所读到的，大多数内部API都进行了强封装。正如之前所建议的，在更新源代码时，您可能会寻找替代API。当然，这并不总是可行的。您还可以采取三种额外的方法--在运行时使用`--add-opens`选项；使用`--add-exports`选项；以及`--permit-illegal-access`命令行选项。让我们看看这些选项中的每一个。
- en: The --add-opens option
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --add-opens选项
- en: 'You can use the `--add-opens` runtime option to allow your code to access non-public
    members. This can be referred to as deep reflection. Libraries that do this deep
    reflection are able to access all members, private and public. To grant this type
    of access to your code, you use the `--add-opens` option. Here is the syntax:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--add-opens`运行时选项来允许您的代码访问非公共成员。这可以被称为深度反射。执行深度反射的库能够访问所有成员，包括私有和公共成员。为了授予这种类型的访问权限给您的代码，您使用`--add-opens`选项。以下是语法：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows the given module to open the specified package. The compiler will
    not produce any errors or warnings when this is used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许给定的模块打开指定的包。当使用此功能时，编译器不会产生任何错误或警告。
- en: The --add-exports option
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --add-exports选项
- en: 'You can use `--add-exports` to break encapsulation so that you can use an internal
    API whose default is to be inaccessible. Here is the syntax:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--add-exports`来破坏封装，以便您可以使用默认情况下不可访问的内部API。以下是语法：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command-line option gives code in the `<target-module>` access to types
    in the `<source-module>` package.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令行选项允许`<target-module>`中的代码访问`<source-module>`包中的类型。
- en: 'Another method of breaking encapsulation is with a JAR file''s manifest. Here
    is an example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏封装的另一种方法是使用JAR文件的清单。以下是一个示例：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `--add-exports` command-line option should only be used if deemed absolutely
    necessary. It is not advisable to use this option except for short-term solutions.
    The danger of using it routinely is that any updates to referenced Internal APIs
    could result in your code not working properly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 应仅在绝对必要时使用`--add-exports`命令行选项。不建议除了短期解决方案之外使用此选项。常规使用此选项的危险在于，任何对引用的内部API的更新都可能导致您的代码无法正常工作。
- en: The --permit-illegal-access option
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --permit-illegal-access选项
- en: A third option for breaking encapsulation is to use the `--permit-illegal-access`
    option. Of course, it is prudent to check with third-party library creators to
    see if they have an updated version. If that is not an option, you use `--permit-illegal-access`
    to gain illegal access to operations to be implemented on the classpath. Due to
    the significantly illegal operation here, you will receive warnings each time
    one of these operations occurs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打破封装的第三种方法是使用`--permit-illegal-access`选项。当然，与第三方库创建者联系以查看他们是否有更新的版本是明智的。如果没有这个选项，你可以使用`--permit-illegal-access`来获取对类路径上要实现的操作的非法访问。由于这里的操作非法性显著，每次这些操作发生时，你都将收到警告。
- en: Runtime image changes
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时镜像变化
- en: Java 9 represents a major change to the JDK and the JRE. Much of these changes
    are related to modularity and have been covered in other chapters. There are still
    a few more things you should consider.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9对JDK和JRE进行了重大改变。其中许多变化与模块化相关，已在其他章节中介绍。还有一些其他事项你应该考虑。
- en: Java version schema
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java版本架构
- en: 'With Java 9, the way the Java platform''s version is displayed has changed.
    Here is an example of a pre-Java 9 version format:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，Java平台版本显示的方式已改变。以下是一个Java 9之前版本格式的示例：
- en: '![](img/32aa88c3-fa5a-4ea8-96d7-0fe0dacc39aa.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32aa88c3-fa5a-4ea8-96d7-0fe0dacc39aa.png)'
- en: 'Now, let''s look at how Java 9 reports its version:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Java 9如何报告其版本：
- en: '![](img/5e01176c-5184-4f4b-b6a7-503e01a856c9.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e01176c-5184-4f4b-b6a7-503e01a856c9.png)'
- en: As you can see, with Java 9, the version schema is now `$MAJOR.$MINOR.$SECURITY.$PATCH`.
    This is markedly different than with previous versions of Java. This will only
    impact your applications if you have code that parses the string returned by the
    `java -version` command and option.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Java 9的版本架构现在是`$MAJOR.$MINOR.$SECURITY.$PATCH`。这与Java的先前版本有显著不同。这只会影响你的应用程序，如果你有解析`java
    -version`命令返回的字符串的代码。
- en: JDK and JRE layout
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK和JRE布局
- en: 'How files are organized in the JDK and the JRE have changed in the new version
    of Java. It is worth your time to familiarize yourself with the new filesystem
    layout. The following screenshot shows the file structure of the JDK''s `/bin`
    folder:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java新版本中，JDK和JRE的文件组织方式已发生变化。熟悉新的文件系统布局是值得你花时间的。以下截图显示了JDK的`/bin`文件夹的文件结构：
- en: '![](img/42a9d7d0-cc34-485c-b8c8-2a6938ed2662.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42a9d7d0-cc34-485c-b8c8-2a6938ed2662.png)'
- en: 'Here is the layout of the `\lib` folder:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`\lib`文件夹的布局：
- en: '![](img/80dcb041-4f86-4a76-a085-7fcee1a85af4.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80dcb041-4f86-4a76-a085-7fcee1a85af4.png)'
- en: What has been removed
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已移除的内容
- en: Another area of change for the new version of the Java platform is that many
    platform components have been removed. The following sections represent the most
    significant components.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台新版本的变化还包括许多平台组件已被移除。以下部分代表了最显著的组件。
- en: Notably, the `rt.jar` and `tools.jar` and `dt.jar` have been removed. These
    JAR files contained class and other resources files and all resided in the `/lib`
    directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`rt.jar`、`tools.jar`和`dt.jar`已被移除。这些JAR文件包含类和其他资源文件，并且都位于`/lib`目录中。
- en: The e*ndorsed standards override mechanism* has been removed. In Java 9, both
    `javac` and `java` will exit if they detect that mechanism. The mechanism was
    used for application servers to override some JDK components. In Java 9, you can
    use upgradeable modules to achieve the same result.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权标准覆盖机制*已被移除。在Java 9中，如果`javac`和`java`检测到该机制，它们将退出。该机制被用于应用程序服务器以覆盖一些JDK组件。在Java
    9中，你可以使用可升级的模块来实现相同的结果。'
- en: As previously covered in this chapter, the e*xtension mechanism* has also been
    removed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章之前所述，*扩展机制*也已移除。
- en: 'The following listed APIs were previously depreciated and have been removed
    and are not accessible in Java 9\. Removal of these APIs is the result of the
    modularization of the Java platform:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的API之前已被弃用，已被移除，且在Java 9中不可访问。这些API的移除是Java平台模块化的结果：
- en: '`apple.applescript`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apple.applescript`'
- en: '`com.apple.concurrent`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.apple.concurrent`'
- en: '`com.sun.image.codec.jpeg`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.image.codec.jpeg`'
- en: '`java.awt.dnd.peer`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.dnd.peer`'
- en: '`java.awt.peer`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.peer`'
- en: '`java.rmi.server.disableHttp`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.rmi.server.disableHttp`'
- en: '`java.util.logging.LogManager.addPropertyChangeListener`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging.LogManager.addPropertyChangeListener`'
- en: '`java.util.logging.LogManager.removePropertyChangeListener`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging.LogManager.removePropertyChangeListener`'
- en: '`java.util.jar.Pack200.Packer.addPropertyChangeListener`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Packer.addPropertyChangeListener`'
- en: '`java.util.jar.Pack200.Packer.removePropertyChangeListener`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.Pack200.Packer.removePropertyChangeListener`'
- en: '`java.util.jar.Pack200.Unpacker.addPropertyChangeListener`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.jar.Pack200.Unpacker.removePropertyChangeListener`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.management.remote.rmi.RMIIIOPServerImpl`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.BASE64Encoder`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.misc.BASE64Decoder`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `sun.rmi.transport.proxy.connectTimeout` ``'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.proxy.eagerHttpFallback`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.proxy.logLevel`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun.rmi.transport.tcp.proxy`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following listed tools have been removed. In each case, the tool was previously
    depreciated or its functionality superseded by better alternatives:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`hprof`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java-rmi.cgi`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java-rmi.exe`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JavaDB`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jhat`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native2ascii`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two additional things that have been removed in Java 9 are:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: AppleScript engine. This engine was deemed as unusable and is dropped without
    replacement.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 32-bit client virtual machine. JDK 9 does support a 32-bit server JVM,
    but not a 32-bit client VM. This change was made to focus on the increased performance
    of 64-bit systems.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated garbage collection
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Garbage collection has been one of Java''s great claims to fame. In Java 9,
    the **Garbage-First** (**G1**) garbage collector is now the default garbage collector
    on both 32- and 64-bit servers. In Java 8, the default garbage collector was the
    parallel garbage collector. Oracle reports that there are three garbage collection
    combinations that will prohibit your application from starting in Java 9\. Those
    combinations are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: DefNew + CMS
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental CMS
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ParNew + SerialOld
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take an in-depth look at Java 9 garbage collection in [Chapter 7](d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml),
    *Leveraging the New Default G1 Garbage Collector*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three issues that you should be aware of, in the context of migrating
    to Java 9, when you are deploying your applications. These issues are JRE version
    selection, serialized applets, and the update to the JNLP.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**JNLP** is the acronym for **Java Network Launch Protocol** and is covered
    in a later section of this chapter.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: JRE version selection
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 9, developers could request a JRE version other than the version
    being launched when launching an application. This could be accomplished with
    a command-line option or with a proper JAR file manifest configuration. This feature
    has been removed in JDK 9 because of the way we typically deploy applications.
    Here are the three primary methods:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Active installers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Web Start** using JNLP'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native OS packaging systems
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialized applets
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 does not support the ability to deploy applets as serialized objects.
    In the past, applets were deployed as serialized objects to compensate for slow
    compression and JVM performance issues. With Java 9, compression techniques are
    advanced and the JVM has great performance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to deploy your applets as serialized objects, your object attributes
    and parameter tags will simply be ignored when your applet launches. Starting
    with Java 9, you can deploy your applets using standard deployment strategies.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: JNLP update
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JNLP is used for launching applications on a desktop client using resources
    located on a web server. JNLP clients include Java Web Start and Java Plug-in
    software because they are able to launch applets that are remotely hosted. This
    protocol is instrumental in launching RIAs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**RIAs** are **Rich Internet Applications** and when launched with JNLP have
    access to the various JNLP APIs that, with user permission, can access the user''s
    desktop.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, the JNLP specification has been updated. There are four specific
    updates as detailed in the next sections.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Nested resources
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to use component extensions with nest resources in Java or j2se
    elements was previously supported, but not documented in the specification. The
    specification has now been updated to reflect this support. The previous specification
    read:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: No java elements can be specified as part of the resources.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated specification for Java 9 now reads:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: A java element in a component extension will not govern what version of java
    is used, but may be used containing nested resource elements, and then those resources
    may be used only when using a Java version that matches the given version as specified
    in section 4.6
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: This specific change ensures that extension JLP files must have `java` or `j2se`
    resources and those resources will not dictate what JRE is used. Nested resources
    are permitted when using the specified version.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: FX XML extension
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the JNLP, you create a JNLP file. Here is an example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Two changes have been made to the `<application-desc>` element. First, the
    optional `type` attribute has been added so the type of application can be annotated.
    The default type is `Java`, so if your program is a Java app, you need not include
    the `type` attribute. Alternatively, you can specify `Java` as your type as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can indicate other application types to include `JavaFX` as shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you indicate an application type that is not supported by the JNLP client,
    your application launch will fail. For more information about JNLP, you can consult
    the official documentation: [http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html](http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change to the `<application-desc>` element in Java 9 is the addition
    of the `param` sub-element. This allows us to provide the name of parameters along
    with their value using the `value` attribute. Here is an example of how an `<application-desc>`
    element of a JNLP file looks with the `param` sub-element and the `value` attribute
    included. This example shows three sets of parameters:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the application `type` is Java, then any `param` sub-elements you use will
    be ignored.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: JNLP file syntax
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JNLP file syntax is now in complete compliance with XML specifications. Prior
    to Java 9, you could use `&` to create complex comparisons. That is not supported
    with standard XML. You can still create complex comparisons in JNLP files. Now
    you will use `&amp;` instead of `&`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Numeric version comparison
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JNLP specification has been changed to reflect how numeric version elements
    were compared against non-numeric version elements. Previous to the change, version
    elements were compared lexicographically by ASCII value. With Java 9 and this
    JNLP specification change, elements are still compared lexicographically by ASCII
    value. The change is evident when the two strings have different lengths. In new
    comparisons, the shorter string will be padded with leading zeros to match the
    length of the longer string.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Lexicographical comparisons use a mathematical model that is based on alphabetical
    order.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Useful tools
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you will need to do before migrating your applications to Java
    9 is to download JDK 9\. You can download the early access builds at this URL--[http://jdk.java.net/9/](http://jdk.java.net/9/).
    You will need to accept the license agreement and then select which build to download.
    As you can see in the following screenshot, there are several options based on
    your operating system:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7507f25b-438a-4b0d-83de-7175d486d28d.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: Now that you have JDK 9 installed on your development computer, let's look at
    a couple of tools that can help facilitate migrating your applications to Java
    9.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Java environment - jEnv
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you develop on a computer with Linux or macOS, you might consider using `jEnv`,
    an open source Java environment management tool. This is a command-line tool,
    so do not expect a GUI. You can download the tool at this URL--[https://github.com/gcuisinier/jenv](https://github.com/gcuisinier/jenv).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the installation command for Linux:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To download using macOS with Homebrew, use this command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also install on Linux or macOS using `Bash` as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can install on Linux or macOS using `Zsh` as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you have `jEnv` installed, you will need to configure it on your system
    as shown here. You will need to modify the script to reflect your actual path:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will want to repeat the `jenv add` command for each version of the JDK
    on your system. With each `jenv add` command, you will receive confirmation that
    the specific JDK version was added to `jEnv` as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check to see what JDK versions you have added to your `jEnv` by using
    `$ jenv versions` at the Command Prompt. This will result in an output list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three additional `jEnv` commands:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`jenv global <version>`: this sets the global version'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenv local <version>`: this sets the local version'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jenv shell <version>`: this sets the instance version for the shell'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maven is an open source tool that can be used for building and managing Java-based
    projects. It already supports Java 9 and is part of the *Apache Maven Project*.
    If you are not already using Maven and you do a lot of Java development you might
    be enticed by the following Maven objectives:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Making the build process easy
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a uniform build system
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing quality project information
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing guidelines for best practices development
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing transparent migration to new features
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more specifics about each of the Maven objectives at this site--[https://maven.apache.org/what-is-maven.html](https://maven.apache.org/what-is-maven.html).
    To download Maven, visit this site--[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
    Installation instructions for Windows, macOS, Linux, and Solaris are available
    here--[https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven can be integrated with Eclipse (M2Eclipse), JetBrains IntelliJ IDEA,
    and the Netbeans IDE. The M2Eclipse IDE, as an example, provides rich integration
    with Apache Maven and boasts the following features:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: You can launch Maven builds from within Eclipse
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage your dependencies for the Eclipse build path
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily resolve Maven dependencies (you can do this directly from Eclipse and
    not have to install a local Maven repository)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically download required dependencies (from remote Maven repositories)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use software wizards to create new Maven projects, create `pom.xml` files, and
    to enable Maven support for your plain Java projects
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapid dependency search of Maven remote repositories
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the M2Eclipse IDE
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain the M2Eclipse IDE, you must first have Eclipse installed. Here are
    the steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening your current Eclipse IDE. Next, select Preferences | Install/Update
    | Available Software Sites as shown in the following screenshot:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f69ad92-4013-4224-9d5a-23b2338ec88b.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: 'The next task is to add the M2Eclipse repository site to your list of Available
    Software Sites. To accomplish this, click the Add button and enter values in the
    Name and Location text input boxes. For Name, enter something to help you remember
    that M2Eclipse is available at this site. For Location, enter the URL--`http://download.eclipse.org/technology/m2e/releases`.
    Then, click the OK button:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/14158242-e84c-4793-8764-6c47ab9bad73.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: 'You should now see the M2Eclipse site listed in your list of Available Software
    Sites as shown in the following screenshot. Your final step is to click the OK
    button:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9a4b28f-f954-4a32-b675-5297cdb5fd85.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you start a new project, you will see `Maven Project` as an option:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a6add9c-c10f-431a-88ae-98f5e2a1fed8.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: 'Maven is a proven tool for Java developers. You might consider obtaining additional
    information on Maven with one of the following resources:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '*Apache Maven Project*: [https://maven.apache.org/index.html](https://maven.apache.org/index.html)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache Maven Cookbook*: [https://www.packtpub.com/application-development/apache-maven-cookbook](https://www.packtpub.com/application-development/apache-maven-cookbook)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache Maven 3.o Cookbook*: [https://www.packtpub.com/application-development/apache-maven-3-cookbook](https://www.packtpub.com/application-development/apache-maven-3-cookbook)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Apache Maven [Video]*: [https://www.packtpub.com/application-development/getting-started-apache-maven-video](https://www.packtpub.com/application-development/getting-started-apache-maven-video)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored potential issues involved in migrating our existing
    applications to the Java 9 platform. We looked at both manual and semi-automated
    migration processes. This chapter provided you with insights and processes to
    get your Java 8 code working with Java 9\. Specifically, we conducted a quick
    review of Project Jigsaw, looked at how modules fit into the Java landscape, provided
    tips for migration planning, shared advice from Oracle regarding migration, and
    shared tools that you can use to help you as you get started with Java 9.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a close look at the Java shell and the JShell
    API. We demonstrate the JShell API and the JShell tool's ability to interactively
    evaluate declarations, statements, and expressions of the Java programming language.
    We will demonstrate features and use of this command-line tool.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
