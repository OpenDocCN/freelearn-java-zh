<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Extending Our E-Commerce Application</h1>
            

            <article>
                
<p class="calibre2">In the last chapter, we started developing an e-commerce application and we created the functionality to look up products based on their ID and, also, by some parameters. In this chapter, we will extend the functionality so that we can also order the products we selected. While doing so, we will learn new technologies, focusing on functional programming in Java and on some other language features, such as reflection and annotation handling during runtime, and scripting interface.</p>
<p class="calibre2">As we did in the previous chapters, we will develop the application step by step. As we discover the newly learnt technologies, we will refactor the code to enroll the new tools and methods to produce more readable and effective code. We will also mimic the development of real-life projects in the sense that at the start, we will have simple requirements, and later, new requirements will be set as our imagined business develops and sells more and more products. We will become imagined millionaires.</p>
<p class="calibre2">We will use the code base of the previous chapter, and we will develop it further, though, in a new project. We will use Spring, Gradle, Tomcat, and soapUI, which are not new after we got acquainted with these in the previous chapter. In this chapter, you will learn the following topics:</p>
<ul class="calibre14">
<li class="calibre15">Annotation processing</li>
<li class="calibre15">Using reflection</li>
<li class="calibre15">Functional programming in Java using:
<ul class="calibre33">
<li class="calibre15">Lambda expressions</li>
<li class="calibre15">Streams</li>
<li class="calibre15">Invoking scripts from Java</li>
</ul>
</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The MyBusiness ordering</h1>
            

            <article>
                
<p class="calibre2">The ordering process is a little bit more complicated than just looking up products. The order form itself lists products and amounts, and identifies who the customer for that order is. Identifiers give the products. All that we have to do is check that the products are available in our store, and we can deliver them to the given customer. This is the simplest approach; however, with some products, there are more restrictions. For example, when somebody orders a desk-side lamp, we deliver the power cord separately. The reason for this is that the power cord is specific to the country. We deliver different power cords to the United Kingdom and to Germany. One possible approach could be to identify the country of the customer. But this approach does not take into account that our customers are resellers. All customers could be located in the United Kingdom, and at the same time they may want to deliver the lamp with the power cable to Germany. To avoid such situations and ambiguity, it would be Â apt that our customers order the desk-side lamp and the power cord as separate items in the same order. In some cases, we deliver the desk-side lamp without the power cord, but this is a special case. We need some logic to identify these special cases. Therefore, we have to implement logic to see if there is a power cord for a desk-side lamp and if there is no automatic handling of the order, it is refused. It does not mean that we will not deliver the product. We will only put the order in a queue and some operator will have to look at it.</p>
<p class="calibre2">The problem with this approach is that the desk-side lamp is only one product that needs configuration support. The more products we have, the more specialities they may have, and the piece of code that checks the consistency of an order becomes more and more complex until it reaches a level of complexity that is not manageable. When a class or method becomes too complex, the programmers refactor it, splitting up the method or class into smaller pieces. We have to do the same with the product checking. We shouldn't try to create one huge class that checks for the product and all the possible order constellations, but rather we should have many smaller checks so that each checks only one small set.</p>
<p class="calibre2">Checking for consistency is simpler in some cases. Checking whether the lamp has a power cord has a complexity any novice programmer can program. We use this example in our code because we want to focus on the actual structure of the code, and not on the complex nature of the check itself. In real life, however, the checks can be fairly complex. Imagine a shop that sells computers. It puts a configuration together: power supply, graphic cards, and motherboard, the appropriate CPU, and the memory. There are many choices and some of them may not work together. In a real-life situation, we need to check that the motherboard is compatible with the memory selected, that it has as many banks as are in the order, that they are appropriately paired (some memories can only be installed in pairs), that there is a compatible slot for the graphics card, and that the power has enough watts to reliably run the whole configuration. This is very complex and is better not mixed up with the code that checks if there is a power cord for a lamp.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Setting up the project</h1>
            

            <article>
                
<p class="calibre2">Since we are still using Spring boot, the build file does not need any modification; we will use it as we will use the same file as in the last chapter. The package structure, however, is a bit different. This time, we do something more complicated than getting a request and responding to whatever the backend services deliver to us. Now, we have to implement complex business logic that, as we will see, needs many classes. When we have more than 10 classes, give or take, in a certain package, it is time to think about putting them into separate packages. The classes that are related to each other and have a similar functionality should be put into one package. This way, we will have a package for the following:</p>
<ul class="calibre14">
<li class="calibre15">The controllers (though we have only one in this example, but usually there are more)</li>
<li class="calibre15">Data storing beans that have no more functionality than storing data, thus, fields, setters, and getters</li>
<li class="calibre15">Checkers that will help us check power cords when a desk-side lamp is ordered</li>
<li class="calibre15">Services that perform different services for the controller</li>
<li class="calibre15">The main package for our program that contains the <kbd class="calibre11">Application</kbd> class, <kbd class="calibre11">SpringConfiguration</kbd>, and some interfaces</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Order controller and DTOs</h1>
            

            <article>
                
<p class="calibre2">When a request comes to the server to order a bunch of products, it comes in an HTTPS <kbd class="calibre11">POST</kbd> request. The body of the request is encoded in JSON. Till now, we had controllers that were handling <kbd class="calibre11">GET</kbd> parameters, but handling <kbd class="calibre11">POST</kbd> requests is not much more difficult when we can rely on the data marshalling of Spring. The controller code itself is simple:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.controllers; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@RestController <br class="title-page-name"/>public class OrderController { <br class="title-page-name"/>    private Logger log = <br class="title-page-name"/>                LoggerFactory.getLogger(OrderController.class); <br class="title-page-name"/>    private final Checker checker; <br class="title-page-name"/><br class="title-page-name"/>    public OrderController(@Autowired Checker checker) { <br class="title-page-name"/>        this.checker = checker; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @RequestMapping("/order") <br class="title-page-name"/>    public Confirmation getProductInformation(@RequestBody Order order) { <br class="title-page-name"/>        if (checker.isConsistent(order)) { <br class="title-page-name"/>            return Confirmation.accepted(order); <br class="title-page-name"/>        } else { <br class="title-page-name"/>            return Confirmation.refused(order); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">There is only one request that we handle in this controller: <kbd class="calibre11">order</kbd>. This is mapped to the URL, <kbd class="calibre11">/order</kbd>. The order is automatically converted from JSON to an order object from the request body. This is what the <kbd class="calibre11">@RequestBody</kbd> annotation asks Spring to do for us. The functionality of the controller simply checks the consistency of the order. If the order is consistent, then we accept the order; otherwise, we refuse it. The real-life example will also check that the order is not only consistent but also comes from a customer who is eligible for buying those products and that the products are available in the warehouse or, at least, can be delivered, based on the promises and lead time from the producers.</p>
<p class="calibre2">To check the consistency of the order, we need something that does this job for us. As we know that we have to modularize the code and not implement too many things in a single class, we need a checker object. This is provided automatically based on the annotation on the class and also on the constructor of the controller by <kbd class="calibre11">@Autowired</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">Order</kbd> class is a simple bean, simply listing the items:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.dtos; <br class="title-page-name"/>import ...; <br class="title-page-name"/>public class Order { <br class="title-page-name"/>    private String orderId; <br class="title-page-name"/>    private List&lt;OrderItem&gt; items; <br class="title-page-name"/>    private String customerId; <br class="title-page-name"/><br class="title-page-name"/>... setters and getters ... <br class="title-page-name"/>}
</pre>
<div class="packtinfobox">The name of the package is <kbd class="calibre22">dtos</kbd>, whichÂ stands for the plural of <strong class="calibre24">Data Transfer Object</strong> (<strong class="calibre24">DTO</strong>). DTOs are objects that are used to transfer data between different components, usually over the network. Since the other side can be implemented in any language, the marshaling can be JSON, XML, or some other format that is capable of delivering nothing but data. These classes do not have real methods. DTOs usually have only fields, setters, and getters.</div>
<p class="calibre2">The following is the class that contains one item in an order:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.dtos; <br class="title-page-name"/><br class="title-page-name"/>public class OrderItem { <br class="title-page-name"/>    private double amount; <br class="title-page-name"/>    private String unit; <br class="title-page-name"/>    private String productId; <br class="title-page-name"/><br class="title-page-name"/>... setters and getters ... <br class="title-page-name"/>}
</pre>
<p class="calibre2">The order confirmation is also in this package, and though this is also a true DTO, it has some simple auxiliary methods:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.dtos; <br class="title-page-name"/><br class="title-page-name"/>public class Confirmation { <br class="title-page-name"/>    private final Order order; <br class="title-page-name"/>    private final boolean accepted; <br class="title-page-name"/><br class="title-page-name"/>    private Confirmation(Order order, boolean accepted) { <br class="title-page-name"/>        this.order = order; <br class="title-page-name"/>        this.accepted = accepted; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public static Confirmation accepted(Order order) { <br class="title-page-name"/>        return new Confirmation(order, true); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public static Confirmation refused(Order order) { <br class="title-page-name"/>        return new Confirmation(order, false); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public Order getOrder() { <br class="title-page-name"/>        return order; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public boolean isAccepted() { <br class="title-page-name"/>        return accepted; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">We provide two factory methods for the class. This is a little violation of the single responsibility principle that purists hate. Most of the time, when the code becomes more complex, such short cuts bite back, and the code has to be refactored to be cleaner. The purist solution would be to create a separate factory class. The use of the factory methods either from this class or from a separated class makes the code of the controller more readable.</p>
<p class="calibre2">The major task we have is the consistency check. The code, till this point, is almost trivial.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Consistency checker</h1>
            

            <article>
                
<p class="calibre2">We have a consistency checker class, and an instance of it is injected into the controller. This class is used to check the consistency, but it does not actually perform the check itself. It only controls the different checkers that we provide and invokes them one by one to do the real work.</p>
<p class="calibre2">We require that a consistency checker, such as the one that checks whether the order contains a power cord when a desk-side lamp is ordered, implements the <kbd class="calibre11">ConsistencyChecker</kbd> interface:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/>public interface ConsistencyChecker { <br class="title-page-name"/>    boolean isInconsistent(Order order); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The method <kbd class="calibre11">isInconsistent</kbd> should return <kbd class="calibre11">true</kbd> if the order is inconsistent. It returns <kbd class="calibre11">false</kbd> if it does not know whether the order is inconsistent or not, but from the aspect that the actual checker examines the order, there is no inconsistency. Having several <kbd class="calibre11">ConsistencyChecker</kbd> classes, we have to invoke one after the other until one returns <kbd class="calibre11">true</kbd> or we are out of them. If none of them returns <kbd class="calibre11">true</kbd>, then we can safely assume, at least from the automated checkers' point of view, that the order is consistent.</p>
<p class="calibre2">We know at the start of the development that we will really have a lot of consistency checkers and not all are relevant for all of the orders. We want to avoid the invocation of each checker for each order. To do so, we implement some filtering. We let products specify what type of checks they need. This is a piece of product information, such as the size or the description. To accommodate this, we need to extend the <kbd class="calibre11">ProductInformation</kbd> class.</p>
<p class="calibre2">We will create each <kbd class="calibre11">ConsistencyChecker</kbd> interface, implementing the class to be a Spring bean (annotated with the <kbd class="calibre11">@Component</kbd> annotation), and at the same time, we will annotate them with an annotation that specifies what type of checks they implement. At the same time, <kbd class="calibre11">ProductInformation</kbd> is extended, containing a set of <kbd class="calibre11">Annotation</kbd> class objects that specify which checkers to invoke. We could simply list the checker classes instead of the annotations, but this gives us some extra freedom in configuring the mapping between the products and the annotations. The annotation specifies the type of the products, and the checker classes are annotated. The desk-side lamp has the <kbd class="calibre11">PoweredDevice</kbd> type, and the checker class, <kbd class="calibre11">NeedPowercord</kbd>, is annotated with the <kbd class="calibre11">@PoweredDevice</kbd> annotation. If there is any other type of products that also needs a power cord, then the annotation of that type should be added to the <kbd class="calibre11">NeedPowercord</kbd> class, and our code will work. Since we start diving deep into annotations and annotation handling, we have to first learn what annotations really are. We have already used annotations since <a href="part0076.html" class="calibre6"><span>Chapter 3</span></a>, <em class="calibre12">Optimizing the Sort, Making Code Professional</em> but all we knew was how to use them, and that is usually dangerous without understanding what we did.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Annotations</h1>
            

            <article>
                
<p class="calibre2">Annotations are used with the <kbd class="calibre11">@</kbd> character in front of them and can be attached to packages, classes, interfaces, fields, methods, method parameters, generic type declaration and use, and, finally, to annotations. Annotations can be used almost everywhere and they are used to describe some program meta information. For example, the <kbd class="calibre11">@RestController</kbd> annotation does not directly alter the behavior of the <kbd class="calibre11">OrderController</kbd> class. The behavior of the class is described by the Java code that is inside. The annotation helps Spring to understand what the class is and how it can and should be used. When Spring scans all the packages and classes to discover the different Spring beans, it sees the annotation on the class and takes it into account. There can be other annotations on the class that Spring does not understand. They may be used by some other framework or program code. Spring ignores them as any well-behaving framework. For example, as we will see later, we have in our code base, the <kbd class="calibre11">NeedPowercord</kbd> class , which is a Spring bean and, as such, annotated with the <kbd class="calibre11">@Component</kbd> annotation. At the same time, it is also annotated with the <kbd class="calibre11">@PoweredDevice</kbd> annotation. Spring has no idea about what a powered device is. This is something that we define and use. Spring ignores this.</p>
<p class="calibre2">Packages, classes, interfaces, fields, and so on, can have many annotations attached to them. These annotations should simply be written in front of the declaration of the syntactical unit they are attached to.</p>
<div class="packtinfobox">In the case of packages, the annotation has to be written in front of the package name in the <kbd class="calibre22">package-info.java</kbd> file. This file can be placed in the directory of the package and can be used to edit the <em class="calibre27">JavaDoc</em> for the package and also to add an annotation to the package. This file cannot contain any Java class since the name, <kbd class="calibre22">package-info</kbd>, is not a valid identifier.</div>
<p class="calibre2">We cannot just write anything in front of anything as an annotation. Annotations should be declared. They are in the runtime of Java special interfaces. The Java file that declares the <kbd class="calibre11">@PoweredDevice</kbd> annotation, for example, looks like this:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.checkers; <br class="title-page-name"/><br class="title-page-name"/>import java.lang.annotation.Retention; <br class="title-page-name"/>import java.lang.annotation.RetentionPolicy; <br class="title-page-name"/><br class="title-page-name"/>@Retention(RetentionPolicy.RUNTIME) <br class="title-page-name"/>public @interface PoweredDevice { <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre11">@</kbd> character in front of the <kbd class="calibre11">interface</kbd> keyword shows us that this is a special one: an annotation type. There are some special rules; for example, an annotation interface should not extend any other interface, not even an annotation one. On the other hand, the compiler automatically makes the annotation interface so that it extends the JDK interface, <kbd class="calibre11">java.lang.annotation.Annotation</kbd>.</p>
<p class="calibre2">Annotations are in the source code, and thus, they are available during the compilation process. They can also be retained by the compiler and put into the generated class files, and when the class loader loads the class file, they may also be available during runtime. The default behavior is that the compiler stores the annotation along with the annotated element in the class file, but the class loader does not keep it available for runtime.</p>
<p class="calibre2">To handle annotations during the compilation process, the Java compiler has to be extended using annotation processors. This is a fairly advanced topic and there are only a few examples you can meet while working with Java. An annotation processor is a Java class that implements a special interface and is invoked by the compiler when it processes an annotation in the source file that the processor is declared to have an interest in.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Annotation retention</h1>
            

            <article>
                
<p class="calibre2">Spring and other frameworks usually handle annotations during runtime. The compiler and the class loader have to be instructed that the annotation is to be kept available during runtime. To do so, the annotation interface itself has to be annotated using the <kbd class="calibre11">@Retention</kbd> annotation. This annotation has one parameter of the <kbd class="calibre11">RetentionPolicy</kbd> type, which is an <kbd class="calibre11">enum</kbd>. We will soon discuss how annotation parameters should be defined.</p>
<p class="calibre2">It is interesting to note that the <kbd class="calibre11">@Retention</kbd> annotation on the annotation interface has to be available in the class file; otherwise, the class loaders would not know how to treat an annotation. How do we signal that an annotation is to be kept by the compiler after the compilation process? We annotate the annotation interface declaration. Thus, the declaration of <kbd class="calibre11">@Retention</kbd> is annotated by itself and it is declared to be available in runtime.</p>
<p class="calibre2">The annotation declaration can be annotated using <kbd class="calibre11">@Retention(RetentionPolicy.SOURCE)</kbd>, <kbd class="calibre11">@Retention(RetentionPolicy.CLASS)</kbd>, or <kbd class="calibre11">@Retention(RetentionPolicy.RUNTIME)</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Annotation target</h1>
            

            <article>
                
<p class="calibre2">The last retention type will be the most frequent used. There are also other annotations that can be used on annotation declarations. The <kbd class="calibre11">@Target</kbd> annotation can be used to restrict the use of the annotation to certain locations. The argument to this annotation is either a single <kbd class="calibre11">java.lang.annotation.ElementType</kbd> value or an array of these values. There is a good reason to restrict the use of annotations. It is much better to get a compilation time error when we place an annotation in theÂ wrong place than hunting during runtime why the framework ignores our annotation.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Annotation parameters</h1>
            

            <article>
                
<p class="calibre2">Annotations, as we saw, can have parameters. To declare these parameters in the <kbd class="calibre11">@interface</kbd> declaration of the annotation, we use methods. TheseÂ <span>methods</span> have a name and a return value, but they should not have an argument. You may try to declare some parameters, but the Java compiler will be strict and will not compile your code.</p>
<p class="calibre2">The values can be defined at the place where theÂ <span>annotation</span> is used, using the name of the method and with the <kbd class="calibre11">=</kbd> character, assigning to them some value that is compatible with the type of the method. For example, let's suppose that we modify the declaration of the annotation <kbd class="calibre11">PoweredDevice</kbd> to the following:</p>
<pre class="calibre20">
public @interface ParameteredPoweredDevice { <br class="title-page-name"/>    String myParameter(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">In such a case, at the use of the annotation, we should specify some value for the parameter, such as the following:</p>
<pre class="calibre20">
@Component <br class="title-page-name"/>@ParameteredPoweredDevice(myParameter = "1966") <br class="title-page-name"/>public class NeedPowercord implements ConsistencyChecker { <br class="title-page-name"/>...
</pre>
<p class="calibre2">If the name of the parameter is a value and at the place of use of the annotation there is no other parameter defined, then the name, "value", may be skipped. For example, modifying the code as follows is a handy shorthand when we have only one parameter:</p>
<pre class="calibre20">
public @interface ParameteredPoweredDevice{ <br class="title-page-name"/>    String value(); <br class="title-page-name"/>} <br class="title-page-name"/>... <br class="title-page-name"/>@Component <br class="title-page-name"/>@ParameteredPoweredDevice("1966") <br class="title-page-name"/>public class NeedPowercord implements ConsistencyChecker { <br class="title-page-name"/>...
</pre>
<p class="calibre2">We can define optional parameters also using the <kbd class="calibre11">default</kbd> keyword following the method declaration. In this case, we have to define a default value for the parameter. Modifying the sample annotation we have further, we still can, but need not, specify the value. In the latter case, it will be an empty string:</p>
<pre class="calibre20">
public @interface ParameteredPoweredDevice { <br class="title-page-name"/>    String value() default ""; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Since the value we specify should be constant and calculable during compile time, there is not much use of complex types. Annotation parameters are usually strings, integers, and sometimes, doubles, or other primitive types. The exact list of the types given by the language specification is as follows:</p>
<ul class="calibre14">
<li class="calibre15">Primitive (<kbd class="calibre11">double</kbd>, <kbd class="calibre11">int</kbd>, and so on)</li>
<li class="calibre15">String</li>
<li class="calibre15">Class</li>
<li class="calibre15">An enum</li>
<li class="calibre15">Another annotation</li>
<li class="calibre15">An array of any of the aforementioned types</li>
</ul>
<p class="calibre2">We have seen examples of <kbd class="calibre11">String</kbd> and also that <kbd class="calibre11">enum</kbd>:<kbd class="calibre11">Retention</kbd> and <kbd class="calibre11">Target</kbd> both have <kbd class="calibre11">enum</kbd> parameters. The interesting part we want to focus on is the last two items of the preceding list.</p>
<p class="calibre2">When the value of the parameter is an array, the value can be specified as comma-separated values between the <kbd class="calibre11">{</kbd> and<kbd class="calibre11">}</kbd> characters. For example:</p>
<pre class="calibre20">
String[] value();
</pre>
<p class="calibre2">This can then be addedÂ to the <kbd class="calibre11">@interface</kbd> annotation we can write:</p>
<pre class="calibre20">
@ParameteredPoweredDevice({"1966","1967","1991"})
</pre>
<p class="calibre2">However, in case there is only one value we want to pass as the parameter value, we can still use the format:</p>
<pre class="calibre20">
@ParameteredPoweredDevice("1966")
</pre>
<p class="calibre2">In this case, the value of the attribute will be an array of length <kbd class="calibre11">1</kbd>. When the value of an annotation is an array of annotation types, things get a bit more complex. We create an <kbd class="calibre11">@interface</kbd> annotation (note the plural in the name):</p>
<pre class="calibre20">
@Retention(RetentionPolicy.RUNTIME) <br class="title-page-name"/>public @interface PoweredDevices { <br class="title-page-name"/>ParameteredPoweredDevice[] value() default {}; <br class="title-page-name"/>}
</pre>
<p class="calibre2">The use of this annotation could be as follows:</p>
<pre class="calibre20">
@PoweredDevices( <br class="title-page-name"/>        {@ParameteredPoweredDevice("1956"), @ParameteredPoweredDevice({"1968", "2018"})} <br class="title-page-name"/>)
</pre>
<p class="calibre2">Note that this is not the same as having the <kbd class="calibre11">ParameteredPoweredDevice</kbd> annotation with three parameters. This is an annotation that has two parameters. Each parameter is an annotation. The first has one string parameter and the second has two.</p>
<div class="packttip">As you can see, annotations can be fairly complex, and some of the frameworks (or rather the programmers who created them) ran amok using them. Before you start writing a framework, research to see whether there is already a framework that you can use. Also, check whether there is some other way to solve your problem. 99% of annotation handling code could be avoided and made simpler. The less code we write for the same functionality, the happier we are. We programmers are the lazy types and this is the way it has to be.</div>
<p class="calibre2">The last example, where the parameter of the annotation is an array of annotations, is important to understand how we can create repeatable annotations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Repeatable annotations</h1>
            

            <article>
                
<p class="calibre2">Annotate the declaration of the annotation with <kbd class="calibre11">@Repeatable</kbd> to denote that the annotation can be applied multiple times at one place. The parameter to this annotation is an annotation type that should have a parameter of type, which is an array of this annotation. Don't try to understand! I'll give an example instead. I already have, in fact: we have <kbd class="calibre11">@PoweredDevices</kbd>. It has an argument that is an array of <kbd class="calibre11">@ParameteredPoweredDevice</kbd>. Consider that we now annotate this <kbd class="calibre11">@interface</kbd> as the following:</p>
<pre class="calibre20">
... <br class="title-page-name"/>@Repeatable(PoweredDevices.class) <br class="title-page-name"/>public @interface ParameteredPoweredDevice { <br class="title-page-name"/>...
</pre>
<p class="calibre2">Then, we can simplify the use of <kbd class="calibre11">@ParameteredPoweredDevice</kbd>. We can repeat the annotation multiple times and the Java runtime will automatically enclose it in the wrapping class, which, in this case, is <kbd class="calibre11">@PoweredDevices</kbd>. In this case, the following two will be equivalent:</p>
<pre class="calibre20">
... <br class="title-page-name"/>@ParameteredPoweredDevice("1956") <br class="title-page-name"/>@ParameteredPoweredDevice({"1968", "2018"}) <br class="title-page-name"/>public class NeedPowercord implements ConsistencyChecker { <br class="title-page-name"/>... <br class="title-page-name"/><br class="title-page-name"/>@PoweredDevices( <br class="title-page-name"/>        {@ParameteredPoweredDevice("1956"), @ParameteredPoweredDevice({"1968", "2018"})} <br class="title-page-name"/>) <br class="title-page-name"/>public class NeedPowercord implements ConsistencyChecker { <br class="title-page-name"/>...
</pre>
<p class="calibre2">The reason for this complex approach is again an example of backward compatibility that Java strictly follows. Annotations were introduced in Java 1.5 and repeatable annotations have been available only since version 1.8. We will soon talk about the reflection API that we use to handle the annotations during runtime. This API in the <kbd class="calibre11">java.lang.reflect.AnnotatedElement</kbd> interface has a <kbd class="calibre11">getAnnotation(annotationClass)</kbd> method, which returns an annotation. If a single annotation can appear more than once on a class, method, and so on, then there is no way of calling this method to get all the different instances with all the different parameters. Backward compatibility was ensured by introducing the containing type that wraps the multiple annotations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Annotation inheritance</h1>
            

            <article>
                
<p class="calibre2">Annotations, just like methods or fields, can be inherited between class hierarchies. If an annotation declaration is marked with <kbd class="calibre11">@Inherited</kbd>, then a class that extends another class with this annotation can inherit it. The annotation can be overridden in case the child class has the annotation. Because there is no multiple inheritance in Java, annotations on interfaces cannot be inherited. Even when the annotation is inherited, the application code that retrieves the annotation of a certain element can distinguish between the annotations that are inherited and those that are declared on the entity itself. There are methods to get the annotations and separate methods to get the declared annotations that are declared on the actual element, and not inherited.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">@Documented annotations</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">@Documented</kbd> annotation expresses the intent that the annotation is part of the contract of the entity and, this way, it has to get into the documentation. This is an annotation that the <em class="calibre12">JavaDoc</em> generator looks at when creating the documentation for an element that references the <kbd class="calibre11">@Documented</kbd> annotation.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">JDK annotations</h1>
            

            <article>
                
<p class="calibre2">There are other annotations defined in the JDK in addition to those that are to be used to define annotations. We have already seen some of these. The most frequently used is the <kbd class="calibre11">@Override</kbd> annotation. When the compiler sees this annotation, it checks that the method really overrides some inherited method. Failing to do so will result in an error, saving us from miserable runtime debugging.</p>
<p class="calibre2">The <kbd class="calibre11">@Deprecated</kbd> annotation signals in the documentation of a method, class, or some other element that the element is not to be used. It is still there in the code, because some users may still use it, but in the case of a new development that depends on the library containing the element, the newly developed code should not use it. The annotation has two parameters. One parameter is <kbd class="calibre11">since</kbd>, which can have a string value and may deliver version information about how long or since which version of the method, or class is deprecated. The other parameter is <kbd class="calibre11">forRemoval</kbd>, which should be <kbd class="calibre11">true</kbd> if the element will not appear in the future versions of the library. Some methods may be deprecated because there are better alternatives but the developers do not intend to remove the method from the library. In such a case, the <kbd class="calibre11">forRemoval</kbd> can be set to <kbd class="calibre11">false</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">@SuppressWarning</kbd> annotation is also a frequently used one, though its use is questionable. It can be used to suppress some of the warnings of the compiler. It is recommended to write code, if possible, which can be compiled without any warning.</p>
<p class="calibre2">The <kbd class="calibre11">@FunctionalInterface</kbd> annotation declares that an interface intends to have only one method. Such interfaces can be implemented as lambda expressions. You will learn about lambda expressions later in this chapter. When this annotation is applied on an interface and there is more than one method declared in the interface, the compiler will signal compilation error. This will prevent any developer early on from adding another method to an interface intended to be used together with functional programming and lambda expressions.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using reflection</h1>
            

            <article>
                
<p class="calibre2">Now that you have learnt how to declare annotations and how to attach them to classes and methods, we can return to our <kbd class="calibre11">ProductInformation</kbd> class. Recall that we wanted to specify the type of products in this class and that each product type is represented by an <kbd class="calibre11">@interface</kbd> annotation. We have already listed it in the previous few pages, the one we will implement in our Â <kbd class="calibre11">@PoweredDevice</kbd>Â example. We will develop the code assuming that later there will be many such annotations, product types, and consistency checkers that are annotated with <kbd class="calibre11">@Component</kbd> and with one or more of our annotations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting annotations</h1>
            

            <article>
                
<p class="calibre2">We will extend the <kbd class="calibre11">ProductInformation</kbd> class with the following field:</p>
<pre class="calibre20">
private List&lt;Class&lt;? extends Annotation&gt;&gt; check;
</pre>
<p class="calibre2">Since this is a DTO, and Spring needs the setters and getters, we will also add a new getter and setter to it. This field will contain the list of classes that each class implement one of our annotations and also the built-in JDK interface, <kbd class="calibre11">Annotation</kbd>, because that is the way the Java compiler generates them. At this point, this may be a bit murky but I promise that the dawn will break and there will be light as we go on.</p>
<p class="calibre2">To get the product information, we have to look it up by ID. This is the interface and service that we developed in the last chapter, except, this time, we have another new field. This is, in fact, a significant difference although the <kbd class="calibre11">ProductLookup</kbd> interface did not change at all. In the last chapter, we developed two versions. One of the versions was reading the data from a properties file, the other one was connecting to a REST service.</p>
<div class="packtinfobox">Properties files are ugly and old technology but a must if ever you intend to pass a Java interview or work on enterprise applications developed at the start of the 21<sup class="calibre31">st</sup>Â century. I had to include it in the last chapter. It was my own urge to include it in the book. At the same time, while coding for this chapter, I did not have the stomach to keep using it. I also wanted to show you that the same content could be managed in a JSON format.</div>
<p class="calibre2">Now, we will extend the implementation of <kbd class="calibre11">ResourceBasedProductLookup</kbd> to read the product information from JSON formatted resource files. Most of the code remains the same in the class; therefore, we only list the difference here:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.services; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Service <br class="title-page-name"/>public class ResourceBasedProductLookup implements ProductLookup { <br class="title-page-name"/>    private static final Logger log = LoggerFactory.getLogger(ResourceBasedProductLookup.class); <br class="title-page-name"/><br class="title-page-name"/>    private ProductInformation fromJSON(InputStream jsonStream) <br class="title-page-name"/>                                              throws IOException { <br class="title-page-name"/>        ObjectMapper mapper = new ObjectMapper(); <br class="title-page-name"/>        return mapper.readValue(jsonStream, <br class="title-page-name"/>                                   ProductInformation.class); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>... <br class="title-page-name"/>    private void loadProducts() { <br class="title-page-name"/>        if (productsAreNotLoaded) { <br class="title-page-name"/>            try { <br class="title-page-name"/>                Resource[] resources =  <br class="title-page-name"/>                     new PathMatchingResourcePatternResolver(). <br class="title-page-name"/>                        getResources("classpath:products/*.json"); <br class="title-page-name"/>                for (Resource resource : resources) { <br class="title-page-name"/>                    loadResource(resource); <br class="title-page-name"/>                } <br class="title-page-name"/>                productsAreNotLoaded = false; <br class="title-page-name"/>            } catch (IOException ex) { <br class="title-page-name"/>                log.error("Test resources can not be read", ex); <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    private void loadResource(Resource resource) <br class="title-page-name"/>                                       throws IOException { <br class="title-page-name"/>        final int dotPos = <br class="title-page-name"/>                      resource.getFilename().lastIndexOf('.'); <br class="title-page-name"/>        final String id = <br class="title-page-name"/>                      resource.getFilename().substring(0, dotPos); <br class="title-page-name"/>        final ProductInformation pi = <br class="title-page-name"/>                      fromJSON(resource.getInputStream()); <br class="title-page-name"/>        pi.setId(id); <br class="title-page-name"/>        products.put(id, pi); <br class="title-page-name"/>    } <br class="title-page-name"/>...
</pre>
<p class="calibre2">In the <kbd class="calibre11">project resources/products</kbd> directory we have a few JSON files. One of them contains the desk lamp product information:</p>
<pre class="calibre20">
{ <br class="title-page-name"/>  "id" : "124", <br class="title-page-name"/>  "title": "Desk Lamp", <br class="title-page-name"/>  "check": [ <br class="title-page-name"/>    "packt.java9.by.example.mybusiness.bulkorder.checkers.PoweredDevice" <br class="title-page-name"/>  ], <br class="title-page-name"/>  "description": "this is a lamp that stands on my desk", <br class="title-page-name"/>  "weight": "600", <br class="title-page-name"/>  "size": [ "300", "20", "2" ] <br class="title-page-name"/>}
</pre>
<p class="calibre2">The type of product is specified in a JSON array. In this example, this array has only one element and that element is the fully qualified name of the annotation interface that represents the type of product. When the JSON marshaller converts the JSON to a Java object, it recognizes that the field that needs this information is a <kbd class="calibre11">List</kbd>, so it converts the array to a list and, also, the elements from <kbd class="calibre11">String</kbd> to <kbd class="calibre11">Class</kbd> objects representing the annotation interface.</p>
<p class="calibre2">Now that we have the resources loaded from JSON formatted resources and we saw how easy it is to read JSON data when using Spring, we can get back to the order consistency check. The <kbd class="calibre11">Checker</kbd> class implements the logic to collect the pluggable checkers and to invoke them. It also implements the annotation-based screening so as not to invoke the checkers we don't really need for the actual products in the actual order:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.services; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Component() <br class="title-page-name"/>@RequestScope <br class="title-page-name"/>public class Checker { <br class="title-page-name"/>    private static final Logger log = <br class="title-page-name"/>                        LoggerFactory.getLogger(Checker.class); <br class="title-page-name"/><br class="title-page-name"/>    private final Collection&lt;ConsistencyChecker&gt; checkers; <br class="title-page-name"/>    private final ProductInformationCollector piCollector; <br class="title-page-name"/>    private final ProductsCheckerCollector pcCollector; <br class="title-page-name"/><br class="title-page-name"/>    public Checker( <br class="title-page-name"/>              @Autowired Collection&lt;ConsistencyChecker&gt; checkers, <br class="title-page-name"/>              @Autowired ProductInformationCollector piCollector, <br class="title-page-name"/>              @Autowired ProductsCheckerCollector pcCollector) { <br class="title-page-name"/>        this.checkers = checkers; <br class="title-page-name"/>        this.piCollector = piCollector; <br class="title-page-name"/>        this.pcCollector = pcCollector; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public boolean isConsistent(Order order) { <br class="title-page-name"/>        Map&lt;OrderItem, ProductInformation&gt; map = <br class="title-page-name"/>                piCollector.collectProductInformation(order); <br class="title-page-name"/>        if (map == null) { <br class="title-page-name"/>            return false; <br class="title-page-name"/>        } <br class="title-page-name"/>        Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations =  <br class="title-page-name"/>                pcCollector.getProductAnnotations(order); <br class="title-page-name"/>        for (ConsistencyChecker checker :  <br class="title-page-name"/>                checkers) { <br class="title-page-name"/>            for (Annotation annotation :  <br class="title-page-name"/>                    checker.getClass().getAnnotations()) { <br class="title-page-name"/>                if (annotations.contains( <br class="title-page-name"/>                                 annotation.annotationType())) { <br class="title-page-name"/>                    if (checker.isInconsistent(order)) { <br class="title-page-name"/>                        return false; <br class="title-page-name"/>                    } <br class="title-page-name"/>                    break; <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>        return true; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">One of the interesting things to mention is that the Spring auto-wiring is very clever. We have a field with the <kbd class="calibre11">Collection&lt;ConsistencyChecker&gt;</kbd> type. Usually, auto-wiring works if there is exactly one class that has the same type as the resources to wire. In our case, we do not have any such candidate since this is a collection, but we have many <kbd class="calibre11">ConsistencyChecker</kbd> classes. All our checkers implement this interface and Spring recognizes it, instantiates them all, magically creates a collection of them, and injects the collection into this field.</p>
<div class="packtinfobox">Usually a good framework works logically. I was not aware of this feature of Spring, but I thought that this would be logical and, magically, it worked. If things are logical and just work, you do not need to read and remember the documentation. A bit of caution does not harm however. After I experienced that this functionality works this way, I looked it up in the documentation to see that this is really a guaranteed feature of Spring and not something that just happens to work but may change in future versions without notice. Using only guaranteed features is extremely important but is neglected many times in our industry.</div>
<p class="calibre2">When the <kbd class="calibre11">isConsistent</kbd> method is invoked, it first collects the product information into <kbd class="calibre11">HashMap</kbd>, assigning a <kbd class="calibre11">ProductInformation</kbd> instance to each <kbd class="calibre11">OrderItem</kbd>. This is done in a separate class. After this, <kbd class="calibre11">ProductsCheckerCollector</kbd> collects the <kbd class="calibre11">ConsistencyChecker</kbd> instances needed by one or more product items. When we have this set, we need to invoke only those checkers that are annotated with one of the annotations that are in this set. We do that in a loop.</p>
<p class="calibre2">In this code, we use reflection. We loop over the annotations that each checker has. To get the collection of annotations, we invoke <kbd class="calibre11">checker.getClass().getAnnotations()</kbd>. This invocation returns a collection of objects. Each object is an instance of some JDK runtime generated class that implements the interface we declared as an annotation in its own source file. There is no guarantee, though, that the dynamically created class implements only our <kbd class="calibre11">@interface</kbd> and not some other interfaces. Therefore, to get the actual annotation class, we have to invoke the <kbd class="calibre11">annotationType</kbd> method.</p>
<div class="packtinfobox">The <kbd class="calibre22">ProductCheckerCollector</kbd> and <kbd class="calibre22">ProductInformationCollector</kbd> classes are very simple, and we will discuss them later when we learn about streams. They will serve as a good example at that place, when we implement them using loops and, right after that, using streams.</div>
<p class="calibre2">Having them all, we can finally create our actual checker classes. The one that helps us see that there is a power cord ordered for our lamp is the following:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.checkers; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/>@Component <br class="title-page-name"/>@PoweredDevice <br class="title-page-name"/>public class NeedPowercord implements ConsistencyChecker { <br class="title-page-name"/>    private static final Logger log = <br class="title-page-name"/>               LoggerFactory.getLogger(NeedPowercord.class); <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public boolean isInconsistent(Order order) { <br class="title-page-name"/>        log.info("checking order {}", order); <br class="title-page-name"/>        CheckHelper helper = new CheckHelper(order); <br class="title-page-name"/>        return !helper.containsOneOf("126", "127", "128"); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The helper class contains simple methods that will be needed by many of the checkers, for example:</p>
<pre class="calibre20">
public boolean containsOneOf(String... ids) { <br class="title-page-name"/>    for (final OrderItem item : order.getItems()) { <br class="title-page-name"/>        for (final String id : ids) { <br class="title-page-name"/>            if (item.getProductId().equals(id)) { <br class="title-page-name"/>                return true; <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return false; <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Invoking methods</h1>
            

            <article>
                
<p class="calibre2">In this example, we used only one single reflection call to get the annotations attached to a class. Reflection can do many more things. Handling annotations is the most important use for these calls since annotations do not have their own functionality and cannot be handled in any other way during runtime. Reflection, however, does not stop telling us what annotations a class or any other annotable element has. Reflection can be used to get a list of the methods of a class, the name of the methods as strings, the implemented interfaces of a class, the parent class it extends, the fields, the types of fields, and so on. Reflection generally provides methods and classes to walk through the actual code structure down to the method level, programmatically.</p>
<p class="calibre2">This walkthrough does not only allow reading types and code structure but also makes it possible to set field values and call methods without knowing the methods' name at compile time. We can even set fields that are <kbd class="calibre11">private</kbd> and are not generally accessible by the outside world. It is also to note that accessing the methods and fields through reflection is usually slower than through compiled code because it always involves lookup by the name of the element in the code.</p>
<div class="packttip">The rule of thumb is that if you see that you have to create code using reflection, then realize that you are probably creating a framework (or writing a book about Java that details reflection). Does it sound familiar?</div>
<p class="calibre2">Spring also uses reflection to discover the classes, methods, and fields, and also to inject an object. It uses the URL class loader to list all the JAR files and directories that are on the class path, loads them, and examines the classes.</p>
<p class="calibre2">For a contrived example, for the sake of demonstration, let's assume that the <kbd class="calibre11">ConsistencyChecker</kbd> implementations were written by many external software vendors, and the architect who originally designed the program structure just forgot to include the <kbd class="calibre11">isConsistent</kbd> method in the interface. (At the same time, to save our mental health, we can also imagine that this person is not working anymore in the company for doing so.) As a consequence, the different vendors delivered Java classes that "implement" this interface but we cannot invoke the method, not only because we do not have a common parent interface that has this method but also because the vendors just happened to use different names for their methods.</p>
<p class="calibre2">What can we do in this situation? Business-wise, asking all the vendors to rewrite their checkers is ruled out because them knowing we are in trouble attaches a hefty price tag to the task. Our managers want to avoid that cost and we developers also want to show that we can mend the situation and do miracles. (Later, I will have a comment on that.)</p>
<p class="calibre2">We could just have a class that knows every checker and how to invoke each of them in many different ways. This would require us to maintain the said class whenever a new checker is introduced to the system, and we want to avoid that. The whole plugin architecture we are using was invented for this very purpose in the first place.</p>
<p class="calibre2">How can we invoke a method on an object that we know has only one declared method, which accepts an order as a parameter? That is where reflection comes into the picture. Instead of calling <kbd class="calibre11">checker.isInconsistent(order)</kbd>, we implement a small <kbd class="calibre11">private</kbd> method, <kbd class="calibre11">isInconsistent</kbd>, which calls the method, whatever its name is, via reflection:</p>
<pre class="calibre20">
private boolean isInconsistent(ConsistencyChecker checker, Order order) { <br class="title-page-name"/>    Method[] methods = checker.getClass().getDeclaredMethods(); <br class="title-page-name"/>    if (methods.length != 1) { <br class="title-page-name"/>        log.error( <br class="title-page-name"/>                "The checker {} has zero or more than one methods", <br class="title-page-name"/>                checker.getClass()); <br class="title-page-name"/>        return false; <br class="title-page-name"/>    } <br class="title-page-name"/>    final Method method = methods[0]; <br class="title-page-name"/>    final boolean inconsistent; <br class="title-page-name"/>    try { <br class="title-page-name"/>        inconsistent = (boolean) method.invoke(checker, order); <br class="title-page-name"/>    } catch (InvocationTargetException | <br class="title-page-name"/>            IllegalAccessException | <br class="title-page-name"/>            ClassCastException e) { <br class="title-page-name"/>        log.error("Calling the method {} on class {} threw exception", <br class="title-page-name"/>                method, checker.getClass()); <br class="title-page-name"/>        log.error("The exception is ", e); <br class="title-page-name"/>        return false; <br class="title-page-name"/>    } <br class="title-page-name"/>    return inconsistent; <br class="title-page-name"/>}
</pre>
<p class="calibre2">We can get the class of the object by calling the <kbd class="calibre11">getClass</kbd> method, and on the object that represents the class itself, we can call <kbd class="calibre11">getDeclaredMethods</kbd>. Fortunately, the checker classes are not littered by many methods, so we check that there is only one method declared in the checker class. Note that there is also a <kbd class="calibre11">getMethods</kbd> method in the reflection library but it always will return more than one method. It returns the declared and the inherited methods. Because each and every class inherits from <kbd class="calibre11">java.lang.Object</kbd>, at least the methods of the <kbd class="calibre11">Object</kbd> class will be there.</p>
<p class="calibre2">After this, we try to invoke the class using the <kbd class="calibre11">Method</kbd> object that represents the method in the reflection class. Note that this <kbd class="calibre11">Method</kbd> object is not directly attached to an instance. We retrieved the method from the class, and thus, when we invoke it, we should pass the object it should work on as a first parameter. This way, <kbd class="calibre11">x.y(z)</kbd>, becomes <kbd class="calibre11">method.invoke(x,z)</kbd>. The last parameter of invoke is a variable number of arguments that are passed as an <kbd class="calibre11">Object</kbd> array. In most cases, when we invoke a method, we know the arguments in our code even if we do not know the name of the method and have to use reflection. When even the arguments are not known but are available as a matter of calculation, then we have to pass them as an <kbd class="calibre11">Object</kbd> array.</p>
<p class="calibre2">Invoking a method via reflection is a risky call. If we try to call a method the normal way, which is <kbd class="calibre11">private</kbd>, then the compiler will signal an error. If the number of arguments or types are not appropriate, the compiler will again will give us an error. If the returned value is not <kbd class="calibre11">boolean</kbd>, or there is no return value at all, then we again get a compiler error. In the case of reflection, the compiler is clueless. It does not know what method we will invoke when the code is executing. The <kbd class="calibre11">invoke</kbd> method, on the other hand, can and will notice all these failures when it is invoked. If any of the aforementioned problems occur, then we will get exceptions. If the <kbd class="calibre11">invoke</kbd> method itself sees that it cannot perform what we ask of it, then it will throw <kbd class="calibre11">InvocationTargetException</kbd> or <kbd class="calibre11">IllegalAccessException</kbd>. If the conversion from the actual return value to <kbd class="calibre11">boolean</kbd> is not possible, then we will get <kbd class="calibre11">ClassCastException</kbd>.</p>
<p class="calibre2">About doing magic, it is a natural urge that we feel like making something extraordinary, something outstanding. This is okay when we are experimenting with something, doing a hobby job. On the other hand, this is strongly not okay when we are working on a professional job. Average programmers, who do not understand your brilliant solution, will maintain the code in an enterprise environment. They will turn your nicely combed code into haystack while fixing some bugs or implementing some minor new features. Even if you are the Mozart of programming, they will be, at best, no-name singers. A brilliant code in an enterprise environment can be a requiem, with all the implications of that metaphor.</p>
<p class="calibre2">Last but not least, the sad reality is that we are usually not the Mozarts of programming.</p>
<p class="calibre2">Note that in case the return value of the original value is primitive, then it will be converted to an object by reflection, and then we will convert it back to the primitive value. If the method does not have a return value, in other words, if it is <kbd class="calibre11">void</kbd>, then the reflection will return a <kbd class="calibre11">java.lang.Void</kbd> object. The <kbd class="calibre11">Void</kbd> object is only a placeholder. We cannot convert it to any primitive value or any other type of objects. It is needed because Java is strict and <kbd class="calibre11">invoke</kbd> has to return an <kbd class="calibre11">Object</kbd>, so the runtime needs something that it can return. All we can do is check that the returned value class is really <kbd class="calibre11">Void</kbd>.</p>
<p class="calibre2">Let's go on with the storyline and our solution. We submitted the code and it works in production for a while till a new update from a software vendor breaks it. We debug the code in the test environment and see that the class now contains more than one method. Our documentation clearly states that they should only have one <kbd class="calibre11">public</kbd> method, and they provided a code that has...hmm...we realize that the other methods are <kbd class="calibre11">private</kbd>. They are right; they can have <kbd class="calibre11">private</kbd> methods according to the contract, so we have to amend the code. We replace the lines that look up the one and only method:</p>
<pre class="calibre20">
Method[] methods = checker.getClass().getDeclaredMethods(); <br class="title-page-name"/>if (methods.length != 1) { <br class="title-page-name"/>... <br class="title-page-name"/>} <br class="title-page-name"/>final Method method = methods[0];
</pre>
<p class="calibre2">The new code will be as follows:</p>
<pre class="calibre20">
final Method method = getSingleDeclaredPublicMethod(checker); <br class="title-page-name"/>if (method == null) { <br class="title-page-name"/>    log.error( <br class="title-page-name"/>            "The checker {} has zero or more than one methods", <br class="title-page-name"/>            checker.getClass()); <br class="title-page-name"/>    return false; <br class="title-page-name"/><br class="title-page-name"/>}
</pre>
<p class="calibre2">The new method we write to look up the one and only <kbd class="calibre11">public</kbd> method is as follows:</p>
<pre class="calibre20">
private Method getSingleDeclaredPublicMethod( <br class="title-page-name"/>                           ConsistencyChecker checker) { <br class="title-page-name"/>    final Method[] methods = <br class="title-page-name"/>        checker.getClass().getDeclaredMethods(); <br class="title-page-name"/>    Method singleMethod = null; <br class="title-page-name"/>    for (Method method : methods) { <br class="title-page-name"/>        if (Modifier.isPublic(method.getModifiers())) { <br class="title-page-name"/>            if (singleMethod != null) { <br class="title-page-name"/>                return null; <br class="title-page-name"/>            } <br class="title-page-name"/>            singleMethod = method; <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return singleMethod; <br class="title-page-name"/>}
</pre>
<p class="calibre2">To check whether the method is <kbd class="calibre11">public</kbd> or not, we use a <kbd class="calibre11">static</kbd> method from the <kbd class="calibre11">Modifier</kbd> class. There are methods to check all possible modifiers. The value that the <kbd class="calibre11">getModifiers</kbd> method returns is an <kbd class="calibre11">int</kbd> bit field. Different bits have different modifiers and there are constants that define these. This simplification leads to inconsistency, which you can check if a method is an interface or volatile, that is, actually nonsense. The fact is that bits that can only be used for other types of reflection objects will never be set.</p>
<div class="packtinfobox">There is one exception, which is <kbd class="calibre22">volatile</kbd>. This bit is reused to signal bridge methods. Bridge methods are created by the compiler automatically and can have deep and complex issues that we do not discuss in this book. The reuse of the same bit does not cause confusion because a field can be <kbd class="calibre22">volatile</kbd>, but as a field, it cannot be a bridge method. Obviously, a field is a field and not a method. In the same way, a method cannot be a <kbd class="calibre22">volatile</kbd> field. The general rule is: do not use methods on reflection objects where they do not have a meaning; or else, know what you do.</div>
<p class="calibre2">Making the storyline even more intricate, a new version of a checker accidentally implements the checking method as a package <kbd class="calibre11">private</kbd>. The programmer simply forgot to use the <kbd class="calibre11">public</kbd> keyword. For the sake of simplicity, let's assume that the classes declare only one method again, but it is not public. How do we solve this problem using reflection?</p>
<p class="calibre2">Obviously, the simplest solution is to ask the vendors to fix the problem: it is their fault. In some cases, however, we must create a workaround over some problems. There is another solution: creating a class with a <kbd class="calibre11">public</kbd> method in the same package, invoking the package <kbd class="calibre11">private</kbd> methods from the other class, thus relaying the other class. As a matter of fact, this solution, as a workaround for such a bug, seems to be more logical and cleaner, but this time, we want to use reflection.</p>
<p class="calibre2">To avoid <kbd class="calibre11">java.lang.IllegalAccessException</kbd>, we have to set the <kbd class="calibre11">method</kbd> object as accessible. To do so, we have to insert the following line in front of the invocation:</p>
<pre class="calibre20">
method.setAccessible(true);
</pre>
<p class="calibre2">Note that this will not change the method to <kbd class="calibre11">public</kbd>. It will only make the method accessible for invocation through the very instance of the <kbd class="calibre11">method</kbd> object that we set as accessible.</p>
<p class="calibre2">I have seen code that checks whether a method is accessible or not by calling the <kbd class="calibre11">isAccessible</kbd> method and saves this information; it sets the method as accessible if it was not accessible and restores the original accessibility after the invocation. This is totally useless. As soon as the <kbd class="calibre11">method</kbd> variable goes out of scope, and there is no reference to the object we set the accessibility flag to, the effect of the setting wears off. Also, there is no penalty for setting the accessibility of a <kbd class="calibre11">public</kbd> or an otherwise callable method.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Setting fields</h1>
            

            <article>
                
<p class="calibre2">We can also call <kbd class="calibre11">setAccessible</kbd> on <kbd class="calibre11">Field</kbd> objects and then we can even set the value of private fields using reflection. Without further fake stories, just for the sake of the example, let's make a <kbd class="calibre11">ConsistencyChecker</kbd> named <kbd class="calibre11">SettableChecker</kbd>:</p>
<pre class="calibre20">
@Component <br class="title-page-name"/>@PoweredDevice <br class="title-page-name"/>public class SettableChecker implements ConsistencyChecker { <br class="title-page-name"/>    private static final Logger log = LoggerFactory.getLogger(SettableChecker.class); <br class="title-page-name"/><br class="title-page-name"/>    private boolean setValue = false; <br class="title-page-name"/><br class="title-page-name"/>    public boolean isInconsistent(Order order) { <br class="title-page-name"/>        return setValue; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This checker will return <kbd class="calibre11">false</kbd>, unless we set the field to <kbd class="calibre11">true</kbd> using reflection. We do set it as such. We create a method in the <kbd class="calibre11">Checker</kbd> class and invoke it from the checking process for each checker:</p>
<pre class="calibre20">
private void setValueInChecker(ConsistencyChecker checker) { <br class="title-page-name"/>    Field[] fields = checker.getClass().getDeclaredFields(); <br class="title-page-name"/>    for( final Field field : fields ){ <br class="title-page-name"/>        if( field.getName().equals("setValue") &amp;&amp; <br class="title-page-name"/>            field.getType().equals(boolean.class)){ <br class="title-page-name"/>            field.setAccessible(true); <br class="title-page-name"/>            try { <br class="title-page-name"/>                log.info("Setting field to true"); <br class="title-page-name"/>                field.set(checker,true); <br class="title-page-name"/>            } catch (IllegalAccessException e) { <br class="title-page-name"/>                log.error("SNAFU",e); <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The method goes through all the declared fields and if the name is <kbd class="calibre11">setValue</kbd> and the type is <kbd class="calibre11">boolean</kbd>, then it sets it to <kbd class="calibre11">true</kbd>. This will essentially render all orders that contain a powered device as rejected.</p>
<p class="calibre2">Note that although <kbd class="calibre11">boolean</kbd> is a built-in language primitive, which is not a class by any means, it still has a class so that reflection can compare the type of the field gainst he class that <kbd class="calibre11">boolean</kbd> artificially has. NowÂ <kbd class="calibre11">boolean.class</kbd> is a class literal in the language, and for each primitive, a similar constant can be used. The compiler identifies these as class literals and creates the appropriate pseudo class references in the byte code so that primitives can also be checked in this way, as demonstrated in the sample code of the <kbd class="calibre11">setValueInChecker</kbd> method.</p>
<p class="calibre2">We checked that the field has the appropriate type, and we also called the <kbd class="calibre11">setAccessible</kbd> method on the field. Even though the compiler does not know that we really did everything to avoid <kbd class="calibre11">IllegalAccessException</kbd>, it still believes that calling <kbd class="calibre11">set</kbd> on <kbd class="calibre11">field</kbd> can throw such an exception, as it is declared. However, we know that it should not happen. (Famous last words of a programmer?) To handle this situation, we surround the method call with a <kbd class="calibre11">try</kbd> block, and in the <kbd class="calibre11">catch</kbd> branch, we log the exception.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Functional programming in Java</h1>
            

            <article>
                
<p class="calibre2">Since we have created a lot of code in our example for this chapter, we will look at the functional programming features of Java, which will help us delete many lines from our code. The less code we have, the easier it is to maintain the application; thus, programmers love functional programming. But this is not the only reason why functional programming is so popular. It is also an excellent way to describe certain algorithms in a more readable and less error prone manner than conventional loops.</p>
<p class="calibre2">Functional programming is not a new thing. The mathematical background was developed for it in the 1930s. One of the first (if not the first) functional programming languages is LISP. It was developed in the 1950s and it is still in use, so much that there is a version of the language implemented on the JVM (Clojure).</p>
<p class="calibre2">Functional programming, in short, means that we express the program structure in terms of functions. In this meaning, we should think of functions as in mathematics and not as the term is used in programming languages such as C. In Java, we have methods, and when we are following the functional programming paradigm, we create and use methods that behave like mathematical functions. A method is functional if it gives the same result no matter how many times we invoke it, just as <em class="calibre12">sin(0)</em> is always zero. Functional programming avoids changing the state of objects, and because the state is not changing, the results are always the same. This also eases debugging.</p>
<p class="calibre2">If a function has once returned a certain value for the given arguments, it will always return the same value. We can also read the code as a declaration of the calculation more than as commands that are executed one after the other. If the execution order is not important, then the readability of the code may also increase.</p>
<p class="calibre2">Java helps functional programming style with lambda expressions and streams. Note that these streams are not I/O streams and do not really have any relation to those.</p>
<p class="calibre2">We will first take a short look at lambda expressions and what streams are, and then, we will convert some parts of our program to use these programming constructs. We will also see how much more readable these codes become.</p>
<p class="calibre2">Readability is a debatable topic. A code may be readable to one developer and may be less readable to another. It very much depends on what they got used to. I experience many times that developers get distracted with streams. When developers first meet streams, the way to think about them and how they look is just strange. But this is the same as starting to learn using a bicycle. While you are still learning its use and you fall more than you roll, it is definitely slower than walking. On the other hand, once you have learnt how to ride a bike...</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Lambda</h1>
            

            <article>
                
<p class="calibre2">We have already used lambda expressions in <a href="part0076.html" class="calibre6"><span>Chapter 3</span></a>, <em class="calibre12">Optimizing the Sort - Making Code Professional</em> when we wrote the exception-throwing test. In that code, we set the comparator to a special value that was throwing <kbd class="calibre11">RuntimeException</kbd> at each invocation:</p>
<pre class="calibre20">
<a class="calibre26">sort.setComparator((String a, String b) -&gt; {</a> <br class="title-page-name"/>        throw new RuntimeException(); <br class="title-page-name"/>    });
</pre>
<p class="calibre2">The argument type is <kbd class="calibre11">Comparator</kbd>; therefore, what we have to set there should be an instance of a class that implements the <kbd class="calibre11">java.util.Comparator</kbd> interface. That interface defines only one method that implementations have to define: <kbd class="calibre11">compare.</kbd> Thus, we can define it as a lambda expression. Without lambda, if we need an instance, we have to type a lot. We have to create a class, name it, declare the <kbd class="calibre11">compare</kbd> method in it, and write the body of the method, as shown in the following code segment:</p>
<pre class="calibre20">
public class ExceptionThrowingComparator implements Comparator { <br class="title-page-name"/>  public int compare(T o1, T o2){ <br class="title-page-name"/>    throw new RuntimeException(); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">At the location of use, we should instantiate the class and pass it as an argument:</p>
<pre class="calibre20">
sort.setComparator(new ExceptionThrowingComparator());
</pre>
<p class="calibre2">We may save a few characters if we define the class as an anonymous class but the overhead is still there. What we really need is the body of the one and single method that we have to define. This is where lambda comes into the picture.</p>
<p class="calibre2">We can use a lambda expression in any place where we would otherwise need an instance of a class that has to define only one method. The methods that are defined and inherited from <kbd class="calibre11">Object</kbd> do not count, and we also do not care about the methods that are defined as <kbd class="calibre11">default</kbd> methods in the interface. They are there. Lambda defines the one that is not yet defined. In other words, lambda clearly depicts, with much less overhead as an anonymous class, that the value is a functionality that we pass as a parameter.</p>
<p class="calibre2">The simple form of a lambda expression is as follows:</p>
<pre class="calibre20">
parameters -&gt; body
</pre>
<p class="calibre2">The parameters can be enclosed between parentheses or can only stand without. The body similarly can be enclosed between the <kbd class="calibre11">{</kbd> and<kbd class="calibre11">}</kbd> characters or it can be a simple expression. This way a lambda expression can reduce the overhead to a minimum, using the parentheses only where they are really needed.</p>
<p class="calibre2">It is also an extremely useful feature of lambda expressions that we do not need to specify the types of the parameters in case it is obvious from the context where we use the expression. Thus, the preceding code segment can even be shorter, as follows:</p>
<pre class="calibre20">
sort.setComparator((a, b) -&gt; { <br class="title-page-name"/>    throw new RuntimeException(); <br class="title-page-name"/>});
</pre>
<p class="calibre2">The parameters, <kbd class="calibre11">a</kbd> and <kbd class="calibre11">b</kbd>, will have the type as needed. To make it even simpler, we can also omit the <kbd class="calibre11">(</kbd> and<kbd class="calibre11">)</kbd> characters around the parameters in case there is only one.</p>
<div class="packttip">The parentheses are not optional if there is more than one parameter. This is to avoid ambiguity in some situations. For example, the method call, <kbd class="calibre22">f(x,y-&gt;x+y)</kbd> could have been a method with two arguments: <kbd class="calibre22">x</kbd> and a lambda expression that has one parameter, <kbd class="calibre22">y</kbd>. At the same time, it could also be a method call with a lambda expression that has two parameters,Â <kbd class="calibre22">x</kbd> and <kbd class="calibre22">y</kbd>.</div>
<p class="calibre2">Lambda expressions are very handy when we want to pass functionality as an argument. The declaration of the type of argument at the place of the method declaration should be a functional interface type. These interfaces can optionally be annotated using <kbd class="calibre11">@FunctionalInterface</kbd>. The Java runtime has many such interfaces defined in the <kbd class="calibre11">java.util.function</kbd> package. We will discuss some of them in the next section along with their use in streams. For the rest, the standard Java documentation is available from Oracle.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Streams</h1>
            

            <article>
                
<p class="calibre2">Streams were also new in Java 8, just like lambda expressions. They work together very strongly, so their appearance at the same time is not a surprise. Lambda expressions as well as streams support the functional programming style.</p>
<p class="calibre2">The very first thing to clarify is that streams do not have anything to do with input and output streams, except the name. They are totally different things. Streams are more like collections with some significant differences. (If there were no differences, they would just have been collections.) Streams are essentially pipelines of operations that can run sequentially or in parallel. They obtain their data from collections or other sources, including data that is manufactured on-the-fly.</p>
<p class="calibre2">Streams support the execution of the same calculation on multiple data. This structure is referred to as <strong class="calibre1">Single Instruction Multiple Data</strong> (<strong class="calibre1">SIMD</strong>). Don't be afraid of the expression. This is a very simple thing. We have already done that many times in this book. Loops are also kind of SIMD structures. When we loop through the checker classes to see whether any of those opposes the order, we perform the same instruction for each and every checker. Multiple checkers are multiple data.</p>
<p class="calibre2">One problem with loops is that we define the order of execution when it is not needed. In the case of checkers, we do not really care what order the checkers are executed in. All we care about is that all are okay with the order. We still specify some order when we program the loop. This comes from the nature of loops, and there is no way we could change that. That is how they work. However, it would be nice if we could just, somehow, say <em class="calibre12">"do this and that for each and every checker"</em>. This is one point where streams come into the picture.</p>
<p class="calibre2">Another point is that code that uses loops is more imperative rather than descriptive. When we read the program of a loop construct, we focus on the individual steps. We first see what the commands in the loop do. These commands work on the individual elements of the data and not on the whole collection or array.</p>
<p class="calibre2">Later putting the individual steps together in our brain we realize what the big picture is, what the loop is for. In the case of streams, the description of operations is a level higher. Once we learn the stream methods, it is easier to read them. Stream methods work on the whole stream and not on the individual elements, and thus are more descriptive.</p>
<p class="calibre2"><kbd class="calibre11">java.lang.Stream</kbd> is an interface. An object with a type implementing this interface represents many objects and provides methods that can be used to perform instructions on these objects. The objects may or may not be available when we start the operation on one of them, or may just be created when needed. This is up to the actual implementation of the <kbd class="calibre11">Stream</kbd> interface. For example, suppose we generate a stream that contains <kbd class="calibre11">int</kbd> values using the following code:</p>
<pre class="calibre20">
IntStream.iterate( 0, (s) -&gt; s+1 )
</pre>
<p class="calibre2">In the preceding code snippet, all the elements cannot be generated because the stream contains an infinite number of elements. This example will return the numbers 0, 1, 2, and so on until further stream operations, which are not listed here, terminate the calculation.</p>
<p class="calibre2">When we program <kbd class="calibre11">Stream</kbd>, we usually create a stream from a <kbd class="calibre11">Collection</kbd>ânot always, but many times. The <kbd class="calibre11">Collection</kbd> interface was extended in Java 8 to provide the <kbd class="calibre11">stream</kbd> and <kbd class="calibre11">parallelStream</kbd> methods. Both of them return stream objects that represent the elements of the collection. While <kbd class="calibre11">stream</kbd> returns the elements in the same order as they are in the collection in case there is a natural order, the <kbd class="calibre11">parallelStream</kbd> creates a stream that may be worked on in a parallel manner. In this case, if some of the methods that we use on the stream are implemented in that way, the code can use the multiple processors available in the computer.</p>
<p class="calibre2">As soon as we have a stream, we can use the methods that the <kbd class="calibre11">Stream</kbd> interface defines. The one to start with is <kbd class="calibre11">forEach</kbd>. This method has one argument, which is usually provided as a lambda expression and will execute the lambda expression for each element of the stream.</p>
<p class="calibre2">In the <kbd class="calibre11">Checker</kbd> class, we have the <kbd class="calibre11">isConsistent</kbd> method. In this method, there is a loop that goes through the annotations of the checker class. If we wanted to log the interfaces that the annotation in the loop implements, we could add the following:</p>
<pre class="calibre20">
for (ConsistencyChecker checker :checkers) { <br class="title-page-name"/>  for (Annotation annotation : <br class="title-page-name"/>checker.getClass().getAnnotations()) { <br class="title-page-name"/>Arrays.stream(annotation.getClass().getInterfaces()) <br class="title-page-name"/>.forEach( <br class="title-page-name"/>t -&gt;log.info("annotation implemented interfaces {}",t) <br class="title-page-name"/>); <br class="title-page-name"/>...
</pre>
<p class="calibre2">In this example, we create a stream from an array using the factory method from the <kbd class="calibre11">Arrays</kbd> class. The array contains the interfaces returned by the reflection method, <kbd class="calibre11">getInterfaces</kbd>. The lambda expression has only one parameter; thus, we do not need to use parentheses around it. The body of the expression is a method call that returns no value; thus, we also omit the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters.</p>
<div class="packttip">Why all this hassle? What is the gain? Why couldn't we just write a simple loop that logs the elements of the array?<br class="calibre23"/>
The gains areÂ readability and maintainability. When we create a program, we have to focus on <em class="calibre27">what</em> the program should do and not on <em class="calibre27">how</em> it should do it. In an ideal world, a specification would just be executable. We may actually get there in the future when programming work will be replaced by artificial intelligence. (Not the programmers, though.) We are not there, yet. We have to tell the computers how to do what we want to achieve. We used to have to enter binary codes on the console of PDP-11 to get machine code deployed into the memory to have it executed. Later, we had assemblers; still later, we had FORTRAN and other high-level programming languages that have replaced much of the programming work as it was 40 years ago. All these developments in programming shift the direction from <em class="calibre27">how</em> towards <em class="calibre27">what</em>. Today, we program in Java 9, and the road still has miles to go.<br class="calibre23"/>
The more we can express what to do instead of how to do, the shorter and more understandable our programs will be. It will contain the essence and not some artificial litter that is needed by the machines to just do what we want.<br class="calibre23"/>
When I see a loop in a code I have to maintain, I assume that there is some importance of the order in which the loop is executed. There may be no importance at all. It may be obvious after a few seconds. It may need minutes or more to realize that the ordering is not important. This time is wasted and can be saved with programming constructs that better express the <em class="calibre27">what to do</em> part instead of the <em class="calibre27">how to do</em>.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Functional interfaces</h1>
            

            <article>
                
<p class="calibre2">The argument to the method should be <kbd class="calibre11">java.util.function.Consumer</kbd>. This is an interface that requires the <kbd class="calibre11">accept</kbd> method to be defined, and this method is <kbd class="calibre11">void</kbd>. The lambda expression or a class that implements this interface will <em class="calibre12">consume</em> the argument of the <kbd class="calibre11">accept</kbd> method and does not produce anything.</p>
<p class="calibre2">There are several other interfaces defined in that package, each serving as a functional interface used to describe some method arguments that can be given as lambda expressions in the actual parameters.</p>
<p class="calibre2">For example, the opposite of <kbd class="calibre11">Consumer</kbd> is <kbd class="calibre11">Supplier</kbd>. This interface has a method named <kbd class="calibre11">get</kbd> that does not need any argument but gives some <kbd class="calibre11">Object</kbd> as a return value.</p>
<p class="calibre2">If there is an argument and also a returned value, the interface is called <kbd class="calibre11">Function</kbd>. If the returned value has to be the same type as the argument, then the <kbd class="calibre11">UnaryOperator</kbd> interface is our friend. Similarly, there is a <kbd class="calibre11">BinaryOperator</kbd> interface, which returns an object of the same type as the arguments. Just as we got from <kbd class="calibre11">Function</kbd> to <kbd class="calibre11">UnaryOperator</kbd>, we can see that in the other direction, there is also <kbd class="calibre11">BiFunction</kbd> in case the arguments and the return values do not share the type.</p>
<div class="packtinfobox">These interfaces are not defined independently of each other. If a method requires <kbd class="calibre22">Function</kbd> and we have <kbd class="calibre22">UnaryOperator</kbd> to pass, it should not be a problem. <kbd class="calibre22">UnaryOperator</kbd> is nothing else but <kbd class="calibre22">Function</kbd> that has the same type of arguments. A method that can work with <kbd class="calibre22">Function</kbd>, which accepts an object and returns an object, should not have a problem if they have the same type. Those can be, but need not be, different.<br class="calibre23"/>
To let that happen, the <kbd class="calibre22">UnaryOperator</kbd> interface extends <kbd class="calibre22">Function</kbd> and thus can be used in the place of <kbd class="calibre22">Function</kbd>.</div>
<p class="calibre2">The interfaces in this class we met so far are defined using generics. Because generic types cannot be primitives, the interfaces that operate on primitive values should be defined separately. <kbd class="calibre11">Predicate</kbd>, for example, is an interface that defines <kbd class="calibre11">booleantest(T t)</kbd>. It is a function that returns a <kbd class="calibre11">boolean</kbd> value and is used many times in stream methods.</p>
<p class="calibre2">There are also interfaces, such as <kbd class="calibre11">BooleanSupplier</kbd>, <kbd class="calibre11">DoubleConsumer</kbd>, <kbd class="calibre11">DoubleToIntFunction</kbd>, and more, that work with primitive <kbd class="calibre11">boolean</kbd>, <kbd class="calibre11">double</kbd>, and <kbd class="calibre11">int</kbd>. The number of possible combinations of the different argument types and return values is infinite... almost.</p>
<div class="packttip"><strong class="calibre24">Fun fact</strong>: To be very precise, it is not infinite. A method can have at most 254 arguments. This limit is specified in the JVM and not in the Java language specification. Of course, one is useless without the other. There are 8 primitive types (plus <kbd class="calibre22">Object</kbd>, plus the possibility that there are less than 254 arguments), which means that the total number of possible functional interfaces is 10<sup class="calibre31">254</sup>, give or take, a few magnitudes. Practically, infinite!</div>
<p class="calibre2">We should not expect to have all the possible interfaces defined in the JDK in this package. These are only those interfaces that are the most useful. There is no interface, for example, that uses <kbd class="calibre11">short</kbd> or <kbd class="calibre11">char</kbd>. If we need anything like that, then we can define the <kbd class="calibre11">interface</kbd> in our code. Or just think hard and find out how to use an already defined one. (I have never used the <kbd class="calibre11">short</kbd> type during my professional carrier. It was never needed.)</p>
<p class="calibre2">How are these functional interfaces used in streams? The <kbd class="calibre11">Stream</kbd> interface defines the methods that have some functional interface types as arguments. For example, the <kbd class="calibre11">allMatch</kbd> method has a <kbd class="calibre11">Predicate</kbd> argument and returns a <kbd class="calibre11">Boolean</kbd> value, which is <kbd class="calibre11">true</kbd> if all the elements in the stream match <kbd class="calibre11">Predicate</kbd>. In other words, this method returns <kbd class="calibre11">true</kbd> if and only if <kbd class="calibre11">Predicate</kbd>, supplied as an argument, returns <kbd class="calibre11">true</kbd> for each and every element of the stream.</p>
<p class="calibre2">In the following code, we will rewrite some of the methods that we implemented in our sample code using loops to use streams, and through these examples, we will discuss the most important methods that streams provide. We saved up two classes, <a class="calibre6"><kbd class="calibre28">ProductsCheckerCollector</kbd></a> and <kbd class="calibre11">ProductInformationCollector</kbd>, to demonstrate the stream usage. We can start with these. <kbd class="calibre11">ProductsCheckerCollector</kbd> goes through all the products that are contained in the <kbd class="calibre11">Order</kbd> and collects the annotations that are listed in the products. Each product may contain zero, one, or many annotations. These are available in a list. The same annotation may be referenced multiple times. To avoid duplicates, we use <kbd class="calibre11">HashSet</kbd>, which will contain only one instance of the elements even if there are multiple instances in the products:</p>
<pre class="calibre20">
public class ProductsCheckerCollector { <br class="title-page-name"/><br class="title-page-name"/>    private final ProductInformationCollector pic; <br class="title-page-name"/>    public ProductsCheckerCollector(@Autowired <br class="title-page-name"/>      ProductInformationCollector pic) { this.pic = pic; } <br class="title-page-name"/><br class="title-page-name"/>    public Set&lt;Class&lt;? extends Annotation&gt;&gt; <br class="title-page-name"/>                       getProductAnnotations(Order order) { <br class="title-page-name"/>        Map&lt;OrderItem, ProductInformation&gt; piMap = <br class="title-page-name"/>                          pic.collectProductInformation(order); <br class="title-page-name"/>        final Set&lt;Class&lt;? extends Annotation&gt;&gt; <br class="title-page-name"/>                            annotations = new HashSet&lt;&gt;(); <br class="title-page-name"/>        for (OrderItem item : order.getItems()) { <br class="title-page-name"/>            final ProductInformation pi = piMap.get(item); <br class="title-page-name"/>            if (pi != null &amp;&amp; pi.getCheck() != null) { <br class="title-page-name"/>                for (Class&lt;? extends Annotation&gt; check : <br class="title-page-name"/>                                              pi.getCheck()) { <br class="title-page-name"/>                    annotations.addAll(pi.getCheck()); <br class="title-page-name"/>                } <br class="title-page-name"/>        } <br class="title-page-name"/>        return annotations; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Now, let's see how this method looks when we recode it using streams:</p>
<pre class="calibre20">
public Set&lt;Class&lt;? extends Annotation&gt;&gt; <br class="title-page-name"/>                getProductAnnotations(Order order) { <br class="title-page-name"/>    Map&lt;OrderItem, ProductInformation&gt; piMap = <br class="title-page-name"/>                      pic.collectProductInformation(order); <br class="title-page-name"/><br class="title-page-name"/>    return order.getItems().stream() <br class="title-page-name"/>            .map(piMap::get) <br class="title-page-name"/>            .filter(Objects::nonNull) <br class="title-page-name"/>            .peek(pi -&gt; { <br class="title-page-name"/>                if (pi.getCheck() == null) { <br class="title-page-name"/>                    log.info("Product {} has no annotation", <br class="title-page-name"/>                                                  pi.getId()); <br class="title-page-name"/>                } <br class="title-page-name"/>            }) <br class="title-page-name"/>            .filter(pi -&gt; pi.getCheck() != null) <br class="title-page-name"/>            .peek(pi -&gt; log.info("Product {} is annotated with class {}", pi.getId(), pi.getCheck())) <br class="title-page-name"/>            .flatMap(pi -&gt; pi.getCheck().stream()) <br class="title-page-name"/>            .collect(Collectors.toSet()); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The major work of the method gets into a single, though huge, stream expression. We will cover the elements of the expression in the coming pages. <kbd class="calibre11">List</kbd> returned by <kbd class="calibre11">order.getItems</kbd> is converted calling the <kbd class="calibre11">stream</kbd> method:</p>
<pre class="calibre20">
returnorder.getItems().stream()
</pre>
<p class="calibre2">As we have already mentioned it briefly, the <kbd class="calibre11">stream</kbd> method is part of the <kbd class="calibre11">Collection</kbd> interface. Any class that implements the <kbd class="calibre11">Collection</kbd> interface will have this method, even those that were implemented before streams were introduced in Java 8. This is because the <kbd class="calibre11">stream</kbd> method is implemented in the interface as a <kbd class="calibre11">default</kbd> method. This way, if we happen to implement a class implementing this interface, even if we do not need streams, we get it for free as an extra.</p>
<div class="packtinfobox">The <kbd class="calibre22">default</kbd> methods in Java 8 were introduced to support backward compatibility of interfaces. Some of the interfaces of the JDK were to be modified to support lambda and functional programming. One example is the <kbd class="calibre22">stream</kbd> method. With the pre-Java 8 feature set, the classes implementing some of the modified interfaces should have been modified. They would have been required to implement the new method. Such a change is not backward compatible, and Java as a language and JDK was paying keen attention to be backward compatible. Thus, <kbd class="calibre22">default</kbd> methods were introduced. These let a developer extend an interface and still keep it backward compatible, providing a default implementation for the methods, which are new.<br class="calibre23"/>
Contrary to this philosophy, brand new functional interfaces of Java 8 JDK also have <kbd class="calibre22">default</kbd> methods, though, having no prior version in the JDK, they have nothing to be compatible with. In Java 9, interfaces were also extended and now they can contain not only <kbd class="calibre22">default</kbd> and <kbd class="calibre22">static</kbd> methods but also <kbd class="calibre22">private</kbd> methods. This way, interfaces became kind of equivalent to abstract classes, though there are no fields in an interface except constant <kbd class="calibre22">static</kbd> fields. This interface functionality open up is a much criticized feature, which just poses the programming style and structural issues that other languages allowing multiple class inheritance face. Java was avoiding this till Java 8 and Java 9.<br class="calibre23"/>
What is the take-away from this? Be careful with <kbd class="calibre22">default</kbd> methods and also with <kbd class="calibre22">private</kbd> methods in interfaces. Use them wisely if at all.</div>
<p class="calibre2">The elements of this stream are <kbd class="calibre11">OrderItem</kbd> objects. We need <kbd class="calibre11">ProductInformation</kbd> for each <kbd class="calibre11">OrderItem</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Method references</h1>
            

            <article>
                
<p class="calibre2">Lucky that we have <kbd class="calibre11">Map</kbd>, which pairs order items with product information,Â so we can invoke <kbd class="calibre11">get</kbd> on <kbd class="calibre11">Map</kbd>:</p>
<pre class="calibre20">
.map(piMap::get)
</pre>
<p class="calibre2">The <kbd class="calibre11">map</kbd> method is again something that has the same name as something else in Java and should not be confused. While the <kbd class="calibre11">Map</kbd> class is a data structure, the <kbd class="calibre11">map</kbd> method in the <kbd class="calibre11">Stream</kbd> interface performs mapping of the stream elements. The argument of the method is a <kbd class="calibre11">Function</kbd> (recall that this is a functional interface we recently discussed). This function converts a value, <kbd class="calibre11">T</kbd>, which is available as the element of the original stream (<kbd class="calibre11">Stream&lt;T&gt;</kbd>) to a value, <kbd class="calibre11">R</kbd>, and the return value of the <kbd class="calibre11">map</kbd> method is <kbd class="calibre11">Stream&lt;R&gt;</kbd>. The <kbd class="calibre11">map</kbd> method converts <kbd class="calibre11">Stream&lt;T&gt;</kbd> to <kbd class="calibre11">Stream&lt;R&gt;</kbd> using the given <kbd class="calibre11">Function&lt;T,R&gt;</kbd>, calling it for each element of the original stream and creating a new stream from the converted elements.</p>
<p class="calibre2">We can say that theÂ <kbd class="calibre11">Map</kbd> interface maps keys to values in a data structure in a static way, and the <kbd class="calibre11">Stream</kbd> method,Â <kbd class="calibre11">map</kbd>, maps one type of values to another (or the same) type of values dynamically.</p>
<p class="calibre2">We have already seen that we can provide an instance of a functional interface in the form of a lambda expression. This argument is not a lambda expression. This is a method reference. It says that the <kbd class="calibre11">map</kbd> method should invoke the <kbd class="calibre11">get</kbd> method on <kbd class="calibre11">Map piMap</kbd> using the actual stream element as an argument. We are lucky that <kbd class="calibre11">get</kbd> also needs one argument, aren't we? We could also write as follows:</p>
<pre class="calibre20">
.map( orderItem -&gt;piMap.get(orderItem))
</pre>
<p class="calibre2">However, this would have been exactly the same as <kbd class="calibre11">piMap::get</kbd>.</p>
<p class="calibre2">This way, we can reference an instance method that works on a certain instance. In our example, the instance is the one referenced by the <kbd class="calibre11">piMap</kbd> variable. It is also possible to reference <kbd class="calibre11">static</kbd> methods. In this case, the name of the class should be written in front of the <kbd class="calibre11">::</kbd> characters. We will soon see an example of this when we will use the <kbd class="calibre11">static</kbd> method, <kbd class="calibre11">nonNull</kbd>, from the <kbd class="calibre11">Objects</kbd> class (note that the class name is in plural, and it is in the <kbd class="calibre11">java.util</kbd> package and not <kbd class="calibre11">java.lang</kbd>).</p>
<p class="calibre2">It is also possible to reference an instance method without giving the reference on which it should be invoked. This can be used in places where the functional interface method has an extra first parameter, which will be used as the instance. We have already used this in <a href="part0076.html" class="calibre6">C<span>hapter 3</span></a>, <em class="calibre12">Optimizing the Sort - Making Code Professional</em>, when we passed <kbd class="calibre11">String::compareTo</kbd>, when the expected argument was a <kbd class="calibre11">Comparator</kbd>. The <kbd class="calibre11">compareTo</kbd> method expects one argument, but the <kbd class="calibre11">compare</kbd> method in the <kbd class="calibre11">Comparator</kbd> interface needs two. In such a situation, the first argument will be used as the instance on which <kbd class="calibre11">compare</kbd> has to be invoked and the second argument is passed to <kbd class="calibre11">compare</kbd>. In this case, <kbd class="calibre11">String::compareTo</kbd> is the same as writing the lambda expression <kbd class="calibre11">(String a, String b) -&gt; a.compareTo(b)</kbd>.</p>
<p class="calibre2">Last but not least, we can use method references to constructors. When we need a <kbd class="calibre11">Supplier</kbd> of (let's be simple) <kbd class="calibre11">Object</kbd>, we can write <kbd class="calibre11">Object::new</kbd>.</p>
<p class="calibre2">The next step is to filter out the <kbd class="calibre11">null</kbd> elements from the stream. Note that, at this point, the stream has <kbd class="calibre11">ProductInformation</kbd> elements:</p>
<pre class="calibre20">
.filter(Objects::nonNull)
</pre>
<p class="calibre2">The <kbd class="calibre11">filter</kbd> method uses <kbd class="calibre11">Predicate</kbd> and creates a stream that contains only the elements that match the predicate. In this case, we used the reference to a <kbd class="calibre11">static</kbd> method. The <kbd class="calibre11">filter</kbd> method does not change the type of stream. It only filters out the elements.</p>
<p class="calibre2">The next method we apply is a bit anti-functional. Pure functional stream methods do not alter the state of any object. They create new objects that they return but, other than that, there is no side effect. <kbd class="calibre11">peek</kbd> itself is no different because it only returns a stream of the same elements as the one it is applied on. However, this <em class="calibre12">no-operation</em> feature lures the novice programmer to do something non-functional and write code with side-effects. After all, why use it if there is no (side) effect in calling it?</p>
<pre class="calibre20">
.peek(pi -&gt; { <br class="title-page-name"/>    if (pi.getCheck() == null) { <br class="title-page-name"/>        log.info("Product {} has no annotation", pi.getId()); <br class="title-page-name"/>    } <br class="title-page-name"/>})
</pre>
<p class="calibre2">While the Â <kbd class="calibre11">peek</kbd> method itself does not have any side effects, the execution of the lambda expression may have. However, this is also true for any of the other methods. It is just the fact that, in this case, it is more tempting to do something inadequate. Don't. We are disciplined adults. As the name of the method suggests, we may peek into the stream but we are not supposed to do anything else. With programming being a particular activity, in this case, peeking, is adequate. And that is what we actually do in our code: we log something.</p>
<p class="calibre2">After this, we get rid of the elements that have no <kbd class="calibre11">ProductInformation</kbd>; we also want to get rid of the elements that have, but there is no checker defined:</p>
<pre class="calibre20">
.filter(pi -&gt;pi.getCheck() != null)
</pre>
<p class="calibre2">In this case, we cannot use method references. Instead, we use a lambda expression. As an alternative solution, we may create a <kbd class="calibre11">boolean hasCheck</kbd> method in <kbd class="calibre11">ProductInformation</kbd>, which returns <kbd class="calibre11">true</kbd> if the <kbd class="calibre11">private</kbd> field check is not <kbd class="calibre11">null</kbd>. This would then read as follows:</p>
<pre class="calibre20">
.filter(ProductInformation::hasCheck)
</pre>
<p class="calibre2">This is totally valid and works, although the class does not implement any functional interface and has many methods, not only this one. However, the method reference is explicit and specifies which method to invoke.</p>
<p class="calibre2">After this second filter, we log the elements again:</p>
<pre class="calibre20">
.peek(pi -&gt; log.info( <br class="title-page-name"/>     "Product {} is annotated with class {}", pi.getId(), <br class="title-page-name"/>                                            pi.getCheck()))
</pre>
<p class="calibre2">The next method is <kbd class="calibre11">flatMap</kbd> and this is something special and not easy to comprehend. At least for me, it was a bit more difficult than understanding <kbd class="calibre11">map</kbd> and <kbd class="calibre11">filter</kbd> when I learned functional programming:</p>
<pre class="calibre20">
.flatMap(pi -&gt;pi.getCheck().stream())
</pre>
<p class="calibre2">This method expects that the lambda, method reference, or whatever is passed to it as an argument, creates a whole new stream of objects for each element of the original stream the method is invoked on. The result is, however, not a stream of streams, which also could be possible, but rather the returned streams are concatenated into one huge stream.</p>
<p class="calibre2">If the stream we apply it to is a stream of integer numbers, such as 1, 2, 3, ..., and the function for each number <em class="calibre12">n</em> returns a stream of three elements <em class="calibre12">n</em>, <em class="calibre12">n+1</em>, and <em class="calibre12">n+2</em>, then the resulting stream, <kbd class="calibre11">flatMap</kbd>, produces a stream containing 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, and so on.</p>
<p class="calibre2">Finally, the stream we have should be collected to a <kbd class="calibre11">Set</kbd>. This is done by calling the <kbd class="calibre11">collector</kbd> method:</p>
<pre class="calibre20">
.collect(Collectors.toSet());
</pre>
<p class="calibre2">The argument to the <kbd class="calibre11">collector</kbd> method is (again a name overuse) <kbd class="calibre11">Collector</kbd>. It can be used to collect the elements of the stream into some collection. Note that <kbd class="calibre11">Collector</kbd> is <em class="calibre12">not</em> a functional interface. You cannot just collect something using a lambda or a simple method. To collect the elements, we definitely need some place where the elements are collected as the ever-newer elements come from the stream. The <kbd class="calibre11">Collector</kbd> interface is not simple. Fortunately, the <kbd class="calibre11">java.util.streams.Collectors</kbd> class (again note the plural) has a lot of <kbd class="calibre11">static</kbd> methods that create and return <kbd class="calibre11">Object</kbd> that create and return <kbd class="calibre11">Collector</kbd>Â objects.</p>
<p class="calibre2">One of these is <kbd class="calibre11">toSet</kbd>, which returns a <kbd class="calibre11">Collector</kbd> that helps collect the elements of the stream into a <kbd class="calibre11">Set</kbd>. The <kbd class="calibre11">collect</kbd> method will return the <kbd class="calibre11">Set</kbd> when all the elements are there. There are other methods that help collect the stream elements by summing up the elements, calculating the average, or to a <kbd class="calibre11">List</kbd>, <kbd class="calibre11">Collection</kbd>, or to a <kbd class="calibre11">Map</kbd>. Collecting elements to a <kbd class="calibre11">Map</kbd> is a special thing, since each element of a <kbd class="calibre11">Map</kbd> is actually a key-value pair. We will see the example for that when we look at <kbd class="calibre11">ProductInformationCollector</kbd>.</p>
<p class="calibre2">The <a class="calibre6"><kbd class="calibre28">ProductInformationCollector</kbd></a> <a class="calibre6">class code contains the</a> <kbd class="calibre11">collectProductInformation</kbd> method, which we will use from the <kbd class="calibre11">Checker</kbd> class as well as from the <kbd class="calibre11">ProductsCheckerCollector</kbd> class:</p>
<pre class="calibre20">
private Map&lt;OrderItem, ProductInformation&gt; map = null; <br class="title-page-name"/><br class="title-page-name"/>public Map&lt;OrderItem, ProductInformation&gt;  <br class="title-page-name"/>                  collectProductInformation(Order order) { <br class="title-page-name"/>    if (map == null) { <br class="title-page-name"/>        map = new HashMap&lt;&gt;(); <br class="title-page-name"/>        for (OrderItem item : order.getItems()) { <br class="title-page-name"/>            final ProductInformation pi = <br class="title-page-name"/>                     lookup.byId(item.getProductId()); <br class="title-page-name"/>            if (!pi.isValid()) { <br class="title-page-name"/>                map = null; <br class="title-page-name"/>                return null; <br class="title-page-name"/>            } <br class="title-page-name"/>            map.put(item, pi); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return map; <br class="title-page-name"/>}
</pre>
<p class="calibre2">The simple trick is to store the collected value in <kbd class="calibre11">Map</kbd>, and if that is not <kbd class="calibre11">null</kbd>, then just return the already calculated value, which may save a lot of service calls in case this method is called more than once handling the same HTTP request.</p>
<div class="packttip">There are two ways of coding such a structure. One is checking the non-nullity of the <kbd class="calibre22">Map</kbd> and returning if the <kbd class="calibre22">Map</kbd> is already there. This pattern is widely used and has a name. This is called guarding <em class="calibre27">if</em>. In this case, there is more than one return statement in the method, which may be seen as a weakness or anti-pattern. On the other hand, the tabulation of the method is one tab shallower.<br class="calibre23"/>
It is a matter of taste and in case you find yourself in the middle of a debate about one or the other solution, just do yourself a favor and let your peer win on this topic and save your stamina for more important issues, for example, whether you should use streams or just plain old loops.</div>
<p class="calibre2">Now, let's see how we can convert this solution into a functional style:</p>
<pre class="calibre20">
public Map&lt;OrderItem, ProductInformation&gt; collectProductInformation(Order order) { <br class="title-page-name"/>    if (map == null) { <br class="title-page-name"/>        map = <br class="title-page-name"/>        order.getItems() <br class="title-page-name"/>                .stream() <br class="title-page-name"/>                .map(item -&gt; tuple(item, item.getProductId())) <br class="title-page-name"/>                .map(t -&gt; tuple(t.r, lookup.byId((String) t.s))) <br class="title-page-name"/>                .filter(t -&gt; ((ProductInformation)t.s).isValid()) <br class="title-page-name"/>                .collect( <br class="title-page-name"/>                    Collectors.toMap( t -&gt; (OrderItem)t.r, <br class="title-page-name"/>                                      t -&gt; (ProductInformation)t.s <br class="title-page-name"/>                                    ) <br class="title-page-name"/>                ); <br class="title-page-name"/>        if (map.keySet().size() != order.getItems().size()) { <br class="title-page-name"/>            log.error("Some of the products in the order do not have product information, {} != {} ",map.keySet().size(),order.getItems().size()); <br class="title-page-name"/>            map = null; <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return map; <br class="title-page-name"/>}
</pre>
<p class="calibre2">We use a helper class, <kbd class="calibre11">Tuple</kbd>, which is nothing but two <kbd class="calibre11">Object</kbd> instances named <kbd class="calibre11">r</kbd> and <kbd class="calibre11">s</kbd>. We will list the code for this class later. It is very simple.</p>
<p class="calibre2">In the streams expression, we first create the stream from the collection, and then we map the <kbd class="calibre11">OrderItem</kbd> elements to a stream of <kbd class="calibre11">OrderItem</kbd> and <kbd class="calibre11">productId</kbd> tuples. Then we map these tuples to tuples that now contain <kbd class="calibre11">OrderItem</kbd> and <kbd class="calibre11">ProductInformation</kbd>. These two mappings could be done in one mapping call, which would perform the two steps only in one. I decided to create the two to have simpler steps in each line in a vain hope that the resulting code will be easier to comprehend.</p>
<p class="calibre2">The filter step is also nothing new. It just filters out invalid product information elements. There should actually be none. It happens if the order contains an order ID to a non-existent product. This is checked in the next statement when we look at the number of collected product information elements to see that all the items have proper information.</p>
<p class="calibre2">The interesting code is how we collect the elements of the stream into a <kbd class="calibre11">Map</kbd>. To do so, we again use the <kbd class="calibre11">collect</kbd> method and also the <kbd class="calibre11">Collectors</kbd> class. This time, the <kbd class="calibre11">toMap</kbd> method creates the <kbd class="calibre11">Collector</kbd>. This needs two <kbd class="calibre11">Function</kbd> resulting expressions. The first one should convert the element of the stream to the key and the second should result in the value to be used in the <kbd class="calibre11">Map</kbd>. Because the actual type of the key and the value is calculated from the result of the passed lambda expressions, we explicitly have to cast the fields of the tuple to the needed types.</p>
<p class="calibre2">Finally, the simple <kbd class="calibre11">Tuple</kbd> class is as follows:</p>
<pre class="calibre20">
public class Tuple&lt;R, S&gt; { <br class="title-page-name"/>    final public R r; <br class="title-page-name"/>    final public S s; <br class="title-page-name"/><br class="title-page-name"/>    private Tuple(R r, S s) { <br class="title-page-name"/>        this.r = r; <br class="title-page-name"/>        this.s = s; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public static &lt;R, S&gt; Tuple tuple(R r, S s) { <br class="title-page-name"/>        return new Tuple&lt;&gt;(r, s); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">There are still some classes in our code that deserve to be converted to functional style. These are the <kbd class="calibre11">Checker</kbd> and <kbd class="calibre11">CheckerHelper</kbd> classes.</p>
<p class="calibre2">In the <kbd class="calibre11">Checker</kbd> class, we can rewrite the <kbd class="calibre11">isConsistent</kbd> method:</p>
<pre class="calibre20">
public boolean isConsistent(Order order) { <br class="title-page-name"/>    Map&lt;OrderItem, ProductInformation&gt; map = <br class="title-page-name"/>                  piCollector.collectProductInformation(order); <br class="title-page-name"/>    if (map == null) { return false; } <br class="title-page-name"/>    final Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <br class="title-page-name"/>                       pcCollector.getProductAnnotations(order); <br class="title-page-name"/>    return !checkers.stream().anyMatch( <br class="title-page-name"/>                 checker -&gt; Arrays.stream( <br class="title-page-name"/>                              checker.getClass().getAnnotations() <br class="title-page-name"/>                            ).filter( <br class="title-page-name"/>                              annotation -&gt; <br class="title-page-name"/>                                annotations.contains( <br class="title-page-name"/>                                      annotation.annotationType()) <br class="title-page-name"/>                            ).anyMatch( <br class="title-page-name"/>                              x -&gt;  <br class="title-page-name"/>                                checker.isInconsistent(order) <br class="title-page-name"/>                            )); <br class="title-page-name"/>}
</pre>
<p class="calibre2">Since you have already learnt most of the important stream methods, there is hardly any new issue here. We can mention the <kbd class="calibre11">anyMatch</kbd> method, which will return <kbd class="calibre11">true</kbd> if there is at least one element so that the <kbd class="calibre11">Predicate</kbd> parameter passed to <kbd class="calibre11">anyMatch</kbd> is <kbd class="calibre11">true</kbd>. It may also need some accommodation so that we could use a stream inside another stream. It very well may be an example when a stream expression is overcomplicated and needs to split up into smaller pieces using local variables.</p>
<p class="calibre2">Finally, before we leave the functional style, we rewrite the <kbd class="calibre11">containsOneOf</kbd> method in the <kbd class="calibre11">CheckHelper</kbd> class. This contains no new elements and will help you check what you have learned about <kbd class="calibre11">map</kbd>, <kbd class="calibre11">filter</kbd>, <kbd class="calibre11">flatMap</kbd>, and <kbd class="calibre11">Collector</kbd>. Note that this method, as we discussed, returns <kbd class="calibre11">true</kbd> if <kbd class="calibre11">order</kbd> contains at least one of the order IDs given as strings:</p>
<pre class="calibre20">
public boolean containsOneOf(String... ids) { <br class="title-page-name"/>    return order.getItems().stream() <br class="title-page-name"/>            .map(OrderItem::getProductId) <br class="title-page-name"/>            .flatMap(itemId -&gt; Arrays.stream(ids) <br class="title-page-name"/>                    .map(id -&gt; tuple(itemId, id))) <br class="title-page-name"/>            .filter(t -&gt; Objects.equals(t.s, t.r)) <br class="title-page-name"/>            .collect(Collectors.counting()) &gt; 0; <br class="title-page-name"/>}
</pre>
<p class="calibre2">We create the stream of the <kbd class="calibre11">OrderItem</kbd> objects, and then we map it to a stream of the IDs of the products contained in the stream. Then we create another stream for each of the IDs with the elements of the ID and one of the string IDs given as the argument. Then, we flatten these substreams into one stream. This stream will contain <kbd class="calibre11">order.getItems().size()</kbd> times <kbd class="calibre11">ids.length</kbd> elements: all possible pairs. We will filter out those pairs that contain the same ID twice, and finally, we will count the number of elements in the stream.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Scripting in Java 9</h1>
            

            <article>
                
<p class="calibre2">We are almost ready with our sample program for this chapter. There is one issue, though it is not professional. When we have a new product that needs a new checker, we have to create a new release of the code.</p>
<p class="calibre2">Programs in professional environments have releases. When the code is modified, bugs are fixed, or a new function is implemented, there are numerous steps that the organization requires before the application can go into production. These steps compose the release process. Some environments have lightweight release processes; others require rigorous and expensive checks. It is not because of the taste of the people in the organization, though. When the cost of a non-working production code is low and it does not matter if there is an outage or wrong functioning in the program, then the release process can be simple. This way, releases get out faster and cheaper. An example can be some chat program that is used for fun by the users. In such a situation, it may be more important to release new fancy features than ensuring bug-free working. On the other end of the palette, if you create code that controls an atomic power plant, the cost of failure can be pretty high. Serious testing and careful checking of all the features, even after the smallest change, can pay off.</p>
<p class="calibre2">In our example, simple checkers may be an area that is not likely to induce serious bugs. It is not impossible but the code is so simple...Yes, I know that such an argument is a bit fishy, but let's assume that these small routines could be changed with less testing and in an easier way than the other parts of the code. How to separate the code for these little scripts, then, so that they do not require a technical release, a new version of the application, and not even restarting the application? We have a new product that needs a new check and we want to have some way to inject this check into the application environment without any service disruption.</p>
<p class="calibre2">The solution we choose is scripting. Java programs can execute scripts written in <em class="calibre12">JavaScript</em>, <em class="calibre12">Groovy</em>, <em class="calibre12">Jython</em> (which is the <em class="calibre12">JVM</em> version of the language <em class="calibre12">Python</em>), and many other languages. Except <em class="calibre12">JavaScript</em>, the language interpreters of these languages are not a part of the JDK, but they all provide a standard interface, which is defined in the JDK. The consequence is that we can implement script execution in our code and the developers, who provide the scripts, are free to choose any of the available languages; we do not need to care to execute a <em class="calibre12">JavaScript</em> code. We will use the same API as to execute <em class="calibre12">Groovy</em> or <em class="calibre12">Jython</em>. The only thing we should know is what language the script is in. This is usually simple: we can guess that from the file extension, and if guessing is not enough, we can demand that the script developers put <em class="calibre12">JavaScript</em> into files with the <kbd class="calibre11">.js</kbd> extension, <em class="calibre12">Jython</em> into files with <kbd class="calibre11">.jy</kbd> or <kbd class="calibre11">.py</kbd>, <em class="calibre12">Groovy</em> into files with <kbd class="calibre11">.groovy</kbd>, and so on. It is also important to note that if we want our program to execute one of these languages, we should make sure that the interpreter is on the classpath. In the case of <em class="calibre12">JavaScript</em>, this is given; therefore, as a demonstration in this chapter, we will write our scripts in <em class="calibre12">JavaScript</em>. There will not be a lot; this is a Java book and not a <em class="calibre12">JavaScript</em> book after all.</p>
<p class="calibre2">Scripting is usually a good choice when we want to pass the ability of programmatically configuring or extending our application. This is our case now.</p>
<p class="calibre2">The first thing we have to do is to extend the production information. In case there is a script that checks the consistency of an order that a product is in, we need a field where we can specify the name of the script:</p>
<pre class="calibre20">
    private String checkScript; <br class="title-page-name"/>    public String getCheckScript() { <br class="title-page-name"/>        return checkScript; <br class="title-page-name"/>    } <br class="title-page-name"/>    public void setCheckScript(String checkScript) { <br class="title-page-name"/>        this.checkScript = checkScript; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">We do not want to specify more than one script per product; therefore, we do not need a list of script names. We have only one script specified by the name.</p>
<div class="packtinfobox">To be honest, the data structure for the checker classes and the annotations, allowing multiple annotations per product and also per checker class, was too complicated. We could not avoid that, though, to have a complex enough structure that could demonstrate the power and capability of stream expressions. Now that we are over that subject, we can go on using simpler data structures focusing on script execution.</div>
<p class="calibre2">We also have to modify the <kbd class="calibre11">Checker</kbd> class to not only use the checker classes but also the scripts. We cannot throw away the checker classes because, by the time we realize that we better need scripts for the purpose, we already have a lot of checker classes and we have no financing to rewrite them to be scripts. Well yes, we are in a book and not in real life, but in an enterprise, that would be the case. That is why you should be very careful while designing solutions for a corporate. The structures and the solutions will be there for a long time and it is not easy to throw a piece of code out just because it is technically not the best. If it works and is already there, the business will be extremely reluctant to spend money on code maintenance and refactoring.</p>
<p class="calibre2">Summary: we modify the <kbd class="calibre11">Checker</kbd> class. We need a new class that can execute our scripts; thus, the constructor is modified:</p>
<pre class="calibre20">
private final CheckerScriptExecutor executor; <br class="title-page-name"/><br class="title-page-name"/>    public Checker( <br class="title-page-name"/>        @Autowired Collection&lt;ConsistencyChecker&gt; checkers, <br class="title-page-name"/>        @Autowired ProductInformationCollector piCollector, <br class="title-page-name"/>        @Autowired ProductsCheckerCollector pcCollector, <br class="title-page-name"/>        @Autowired CheckerScriptExecutor executor ) { <br class="title-page-name"/>        this.checkers = checkers; <br class="title-page-name"/>        this.piCollector = piCollector; <br class="title-page-name"/>        this.pcCollector = pcCollector; <br class="title-page-name"/>        this.executor = executor; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">We also have to use this <kbd class="calibre11">executor</kbd> in the <kbd class="calibre11">isConsistent</kbd> method<kbd class="calibre11">:</kbd></p>
<pre class="calibre20">
public boolean isConsistent(Order order) { <br class="title-page-name"/>        final Map&lt;OrderItem, ProductInformation&gt; map = <br class="title-page-name"/>                piCollector.collectProductInformation(order); <br class="title-page-name"/>        if (map == null) { <br class="title-page-name"/>            return false; <br class="title-page-name"/>        } <br class="title-page-name"/>        final Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <br class="title-page-name"/>                pcCollector.getProductAnnotations(order); <br class="title-page-name"/>        Predicate&lt;Annotation&gt; annotationIsNeeded = annotation -&gt; <br class="title-page-name"/>                annotations.contains(annotation.annotationType()); <br class="title-page-name"/>        Predicate&lt;ConsistencyChecker&gt; productIsConsistent = <br class="title-page-name"/>                checker -&gt; <br class="title-page-name"/>                Arrays.stream(checker.getClass().getAnnotations()) <br class="title-page-name"/>                        .parallel().unordered() <br class="title-page-name"/>                        .filter(annotationIsNeeded) <br class="title-page-name"/>                        .anyMatch( <br class="title-page-name"/>                             x -&gt; checker.isInconsistent(order)); <br class="title-page-name"/>        final boolean checkersSayConsistent = !checkers.stream(). <br class="title-page-name"/>                anyMatch(productIsConsistent); <br class="title-page-name"/>        final boolean scriptsSayConsistent = <br class="title-page-name"/>                !map.values(). <br class="title-page-name"/>                        parallelStream(). <br class="title-page-name"/>                        map(ProductInformation::getCheckScript). <br class="title-page-name"/>                        filter(Objects::nonNull). <br class="title-page-name"/>                        anyMatch(s -&gt; <br class="title-page-name"/>                           executor.notConsistent(s,order)); <br class="title-page-name"/>        return checkersSayConsistent &amp;&amp; scriptsSayConsistent; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">Note that in this code, we use parallel streams because, why not? Whenever it is possible, we can use parallel streams, even unordered, to tell the underlying system and also to the programmer fellows maintaining the code that order is not important.</p>
<p class="calibre2">We also modify one of our product JSON files to reference a script instead of a checker class through some annotation:</p>
<pre class="calibre20">
{ <br class="title-page-name"/>  "id" : "124", <br class="title-page-name"/>  "title": "Desk Lamp", <br class="title-page-name"/>  "checkScript" : "powered_device", <br class="title-page-name"/>  "description": "this is a lamp that stands on my desk", <br class="title-page-name"/>  "weight": "600", <br class="title-page-name"/>  "size": [ "300", "20", "2" ] <br class="title-page-name"/>}
</pre>
<p class="calibre2">Even JSON is simpler. Note that as we decided to use JavaScript, we do not need to specify the file name extension when we name the script.</p>
<div class="packttip">We may later consider further development when we will allow the product checker script maintainers to use different scripting languages. In such a case, we may still require that they specify the extension, and in case there is no extension, it will be added by our program as <kbd class="calibre22">.js</kbd>. In our current solution, we do not check that, but we may devote a few seconds to think about it to be sure that the solution can be further developed. It is important that we do not develop extra code for the sake of further development. Developers are not fortunetellers and cannot tell reliably what the future needs will be. That is the task of the business people.</div>
<p class="calibre2">We put the script into the <kbd class="calibre11">resource</kbd> directory of our project under the <kbd class="calibre11">scripts</kbd> directory. The name of the file has to be <kbd class="calibre11">powered_device.js</kbd> because this is the name we specified in the JSON file:</p>
<pre class="calibre20">
function isInconsistent(order){ <br class="title-page-name"/>    isConsistent = false <br class="title-page-name"/>    items = order.getItems() <br class="title-page-name"/>    for( i in items ){ <br class="title-page-name"/>    item = items[i] <br class="title-page-name"/>    print( item ) <br class="title-page-name"/>        if( item.getProductId() == "126" || <br class="title-page-name"/>            item.getProductId() == "127" || <br class="title-page-name"/>            item.getProductId() == "128"  ){ <br class="title-page-name"/>            isConsistent = true <br class="title-page-name"/>            } <br class="title-page-name"/>    } <br class="title-page-name"/>    return ! isConsistent <br class="title-page-name"/>}
</pre>
<p class="calibre2">This is an extremely simple JavaScript program. As a side note, when you iterate over a list or an array in JavaScript, the loop variable will iterate over the indexes of the collection or the array. Since I rarely program in JavaScript, I fell into this trap and it took me more than half an hour to debug the error I made.</p>
<p class="calibre2">We have prepared everything we need to call the script. We still have to invoke it. To do so, we use the JDK scripting API. First, we need a <kbd class="calibre11">ScriptEngineManager</kbd>. This manager is used to get access to the JavaScript engine. Although the JavaScript interpreter has been a part of the JDK since Java 7, it is still managed in an abstract way. It is one of the many possible interpreters that a Java program can use to execute script. It just happens to be there in the JDK, so we do not need to add the interpreter JAR to the classpath. <kbd class="calibre11">ScriptEngineManager</kbd> discovers all the interpreters that are on the classpath and registers them.</p>
<p class="calibre2">It does so using the Service Provider specification, which has been a part of the JDK for a long time, and by Java 9, it also got extra support in module handling. This requires the script interpreters to implement the <kbd class="calibre11">ScriptEngineFactory</kbd> interface and also to list the class that does it in the <kbd class="calibre11">META-INF/services/javax.script.ScriptEngineFactory</kbd> file. These files, from all the JAR files that are part of the classpath, are read as resources by <kbd class="calibre11">ScriptEngineManager</kbd>, and through this, it knows which classes implement script interpreters. The <kbd class="calibre11">ScriptEngineFactory</kbd> interface requires that the interpreters provide methods such as <kbd class="calibre11">getNames</kbd>, <kbd class="calibre11">getExtensions</kbd>, and <kbd class="calibre11">getMimeTypes</kbd>. The manager calls these methods to collect the information about the interpreters. When we ask a JavaScript interpreter, the manager will return the one created by the factory that said that one of its names is <kbd class="calibre11">JavaScript</kbd>.</p>
<p class="calibre2">To get access to the interpreters through the name, file name extension or mime-type is only one of the functions of <kbd class="calibre11">ScriptEngineManager</kbd>. The other one is to manage <kbd class="calibre11">Bindings</kbd>.</p>
<p class="calibre2">When we execute a script from within the Java code, we don't do it because we want to increase our dopamine levels. In the case of scripts, it does not happen. We want some results. We want to pass parameters and after the execution of the script, we want values back from the script that we can use in the Java code. This can happen in two ways. One is by passing parameters to a method or function implemented in the script and getting the return value from the script. This usually works, but it may even happen that some scripting language does not even have the notion of the function or method. In such a case, it is not a possibility. What is possible is to pass some environment to the script and read values from the environment after the script is executed. This environment is represented by <kbd class="calibre11">Bindings</kbd>.</p>
<p class="calibre2"><kbd class="calibre11">Bindings</kbd> is a map that has <kbd class="calibre11">String</kbd> keys and <kbd class="calibre11">Object</kbd> values.</p>
<p class="calibre2">In the case of most scripting languages, for example, in JavaScript, <kbd class="calibre11">Bindings</kbd> is connected to global variables in the script we execute. In other words, if we execute the following command in our Java program before invoking the script, then the JavaScript global variable, <kbd class="calibre11">globalVariable</kbd>, will reference the <kbd class="calibre11">myObject</kbd> object:</p>
<pre class="calibre20">
myBindings.put("globalVariable",myObject)
</pre>
<p class="calibre2">We can create <kbd class="calibre11">Bindings</kbd> and pass it to <kbd class="calibre11">ScriptEngineManager</kbd> but just as well we can use the one that it creates automatically, and we can call the <kbd class="calibre11">put</kbd> method on the engine object directly.</p>
<p class="calibre2">There are two <kbd class="calibre11">Bindings</kbd> when we execute scripts. One is set on the <kbd class="calibre11">ScriptEngineManager</kbd> level. This is named global binding. There is also one managed by <kbd class="calibre11">ScriptEngine</kbd> itself. This is the local <kbd class="calibre11">Bindings</kbd>. From the script point of view, there is no difference. From the embedding side, there is some difference. In case we use the same <kbd class="calibre11">ScriptEngineManager</kbd> to create multiple <kbd class="calibre11">ScriptEngine</kbd>Â instances, then the global bindings are shared by them. If one gets a value, all of them see the same value; if one sets a value, all others will later see that changed value. The local binding is specific to the engine it is managed by. Since we only introduce Java scripting API in this book, we do not get into more details and we will not use <kbd class="calibre11">Bindings</kbd>. We are good with invoking a JavaScript function and to get the result from it.</p>
<p class="calibre2">The class that implements the script invocation is <kbd class="calibre11">CheckerScriptExecutor</kbd>:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.bulkorder.services; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>@Component <br class="title-page-name"/>public class CheckerScriptExecutor { <br class="title-page-name"/>    private static final Logger log = ... <br class="title-page-name"/><br class="title-page-name"/>    private final ScriptEngineManager manager = <br class="title-page-name"/>                             new ScriptEngineManager(); <br class="title-page-name"/><br class="title-page-name"/>    public boolean notConsistent(String script, Order order) { <br class="title-page-name"/><br class="title-page-name"/>        try { <br class="title-page-name"/>            final Reader scriptReader = getScriptReader(script); <br class="title-page-name"/>            final Object result =  <br class="title-page-name"/>                         evalScript(script, order, scriptReader); <br class="title-page-name"/>            assertResultIsBoolean(script, result); <br class="title-page-name"/>            log.info("Script {} was executed and returned {}", <br class="title-page-name"/>                                                 script, result); <br class="title-page-name"/>            return (boolean) result; <br class="title-page-name"/><br class="title-page-name"/>        } catch (Exception wasAlreadyHandled) { <br class="title-page-name"/>            return true; <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The only <kbd class="calibre11">public</kbd> method, <kbd class="calibre11">notConsistent</kbd>, gets the name of the script to execute and also <kbd class="calibre11">order</kbd>. The latter has to be passed to the script. First it gets <kbd class="calibre11">Reader</kbd>, which can read the script text, evaluates it, and finally returns the result in case it is <kbd class="calibre11">boolean</kbd> or can at least be converted to <kbd class="calibre11">boolean</kbd>. If any of the methods invoked from here that we implemented in this class is erroneous, it will throw an exception, but only after appropriately logging it. In such cases, the safe way is to refuse an order.</p>
<p class="calibre2">Actually, this is something that the business should decide. If there is a check script that cannot be executed, it is clearly an erroneous situation. In this case, accepting an order and later handling the problems manually has certain costs. Refusing an order or confirmation because of some internal bug is also not a happy path of the order process. We have to check which approach causes the least damage to the company. It is certainly not the duty of the programmer. In our situation, we are in an easy situation.</p>
<p class="calibre2">We assume that the business representatives said that the order in such a situation should be refused. In real life, similar decisions are many times refused by the business representatives saying that it just should not happen and the IT department has to ensure that the program and the whole operation is totally bug free. There is a psychological reason for such a response, but this really leads us extremely far from Java programming.</p>
<p class="calibre2">Engines can execute a script passed through <kbd class="calibre11">Reader</kbd> or as <kbd class="calibre11">String</kbd>. Because now we have the script code in a resource file, it seems to be a better idea to let the engine read the resource instead of reading it to a <kbd class="calibre11">String</kbd>:</p>
<pre class="calibre20">
 <br class="title-page-name"/>        private Reader getScriptReader(String script) <br class="title-page-name"/>                                throws IOException { <br class="title-page-name"/>        final Reader scriptReader; <br class="title-page-name"/>        try { <br class="title-page-name"/>            final InputStream scriptIS = new ClassPathResource( <br class="title-page-name"/>                    "scripts/" + script + ".js").getInputStream(); <br class="title-page-name"/>            scriptReader = new InputStreamReader(scriptIS); <br class="title-page-name"/>        } catch (IOException ioe) { <br class="title-page-name"/>            log.error("The script {} is not readable", script); <br class="title-page-name"/>            log.error("Script opening exception", ioe); <br class="title-page-name"/>            throw ioe; <br class="title-page-name"/>        } <br class="title-page-name"/>        return scriptReader; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">To read the script from a resource file, we use the Spring <kbd class="calibre11">ClassPathResource</kbd> class. The name of the script is prepended with the <kbd class="calibre11">scripts</kbd> directory and appended by the<kbd class="calibre11">.js</kbd> extension. The rest is fairly standard and nothing we have not seen in this book. The next method that evaluates the script is more interesting:</p>
<pre class="calibre20">
        private Object evalScript(String script, <br class="title-page-name"/>                              Order order, <br class="title-page-name"/>                              Reader scriptReader)  <br class="title-page-name"/>            throws ScriptException, NoSuchMethodException { <br class="title-page-name"/>        final Object result; <br class="title-page-name"/>        final ScriptEngine engine = <br class="title-page-name"/>                          manager.getEngineByName("JavaScript"); <br class="title-page-name"/>        try { <br class="title-page-name"/>            engine.eval(scriptReader); <br class="title-page-name"/>            Invocable inv = (Invocable) engine; <br class="title-page-name"/>            result = inv.invokeFunction("isInconsistent", order); <br class="title-page-name"/>        } catch (ScriptException | NoSuchMethodException se) { <br class="title-page-name"/>            log.error("The script {} thruw up", script); <br class="title-page-name"/>            log.error("Script executing exception", se); <br class="title-page-name"/>            throw se; <br class="title-page-name"/>        } <br class="title-page-name"/>        return result; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">To execute the method in the script, first of all, we need a script engine that is capable of handling <strong class="calibre1">JavaScript</strong>. We get the engine from the manager by its name. If it is not <strong class="calibre1">JavaScript</strong>, we should check that the returned <kbd class="calibre11">engine</kbd> is not <kbd class="calibre11">null</kbd>. In the case of <strong class="calibre1">JavaScript</strong>, the interpreter is part of the <strong class="calibre1">JDK</strong> and checking that the <strong class="calibre1">JDK</strong> conforms to the standard would be paranoid.</p>
<p class="calibre2">If ever we want to extend this class to handle not only <strong class="calibre1">JavaScript</strong> but also other types of scripts, this check has to be done, and also the script engine should probably be requested from the manager by the file name extension, which we do not have access to in this <kbd class="calibre11">private</kbd> method. But that is future development, not in this book.</p>
<p class="calibre2">When we have the engine, we have to evaluate the script. This will define the function in the script so that we can invoke it afterwards. To invoke it, we need some <kbd class="calibre11">Invocable</kbd> object. In the case of <strong class="calibre1">JavaScript</strong>, the engine also implements an <kbd class="calibre11">Invocable</kbd> interface. Not all script engines implement this interface. Some scripts do not have functions or methods, and there is nothing to invoke in them. Again, this is something to do later, when we want to allow not only <strong class="calibre1">JavaScript</strong> scripting but also other types of scripting.</p>
<p class="calibre2">To invoke the function, we pass its name to the <kbd class="calibre11">invokeFunction</kbd> method and also the arguments that we want to pass on. In this case, this is the <kbd class="calibre11">order</kbd>. In the case of <strong class="calibre1">JavaScript</strong>, the integration between the two languages is fairly developed. As in our example, we can access the field and the methods of the Java objects that are passed as arguments and the returned JavaScript <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd> value is also converted to <kbd class="calibre11">Boolean</kbd> magically. There are some situations when the access is not that simple though:</p>
<pre class="calibre20">
 <br class="title-page-name"/>private void assertResultIsBoolean(String script, <br class="title-page-name"/>                                       Object result) { <br class="title-page-name"/>        if (!(result instanceof Boolean)) { <br class="title-page-name"/>            log.error("The script {} returned non boolean", <br class="title-page-name"/>                                                    script); <br class="title-page-name"/>            if (result == null) { <br class="title-page-name"/>                log.error("returned value is null"); <br class="title-page-name"/>            } else { <br class="title-page-name"/>                log.error("returned type is {}", <br class="title-page-name"/>                                 result.getClass()); <br class="title-page-name"/>            } <br class="title-page-name"/>            throw new IllegalArgumentException(); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The last method of the class checks that the returned value, which can be anything since this is a script engine, is convertible to <kbd class="calibre11">boolean</kbd>.</p>
<p class="calibre2">It is important to note that the fact that some of the functionality is implemented in script does not guarantee that the application works seamlessly. There may be several issues and scripts may affect the inner working of the entire application. Some scripting engines provide special ways to protect the application from bad scripts, others do not. The fact that we do not pass but order to the script does not guarantee that a script cannot access other objects. Using reflection, <kbd class="calibre11">static</kbd> methods, and other techniques there can be ways to access just anything inside our Java program. We may be a bit easier with the testing cycle when only a script changes in our code base, but it does not mean that we should blindly trust any script.</p>
<p class="calibre2">In our example, it probably would be a very bad idea to let the producers of the products upload scripts to our system. They may provide their check scripts, but these scripts have to be reviewed from the security point of view before being deployed into the system. If this is properly done, then scripting is an extremely powerful extension to the Java ecosystem, giving great flexibility to our programs.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we have developed the ordering system of our enterprise application. Along with the development of the code, we met many new things. You learned about annotations and how they can be handled by reflections. Although not strongly related, you learned how to use lambda expressions and streams to express some programming constructs simpler than conventional loops. In the last part of the chapter, we extended the application using scripting, by invoking JavaScript functions from Java and also by invoking Java methods from JavaScript.</p>
<p class="calibre2">In fact, with all this knowledge, we matured to a Java level that is needed for enterprise programming. The rest of the topics the book covers are for the aces. But you want to be one, don't you? This is why I wrote the rest of the chapters. Read on!</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>