- en: Blogpress - A Simple Blog Management System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blogpress - 一个简单的博客管理系统
- en: Spring supports the development of enterprise-grade applications on the Java
    platform. There are numerous such application that come under its purview, popular
    among which are Spring **Model-View-Controller** (**MVC**), Spring Security, Spring
    Data, Spring Batch, and Spring Cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持在Java平台上开发企业级应用程序。在其范围内有许多这样的应用程序，其中最流行的是Spring **模型-视图-控制器**（**MVC**）、Spring
    Security、Spring Data、Spring Batch和Spring Cloud。
- en: In the previous two chapters, we started exploring Spring MVC framework along
    with other building blocks, like Spring Data and RestTemplate, along with JavaScript
    frameworks like Angular, Bootstrap, and jQuery to build the web-based application.
    We have also seen how to build a reactive web application with the help of WebFlux,
    a framework for creating reactive web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们开始探索Spring MVC框架，以及其他构建块，如Spring Data和RestTemplate，以及像Angular、Bootstrap和jQuery这样的JavaScript框架，以构建基于Web的应用程序。我们还看到了如何借助WebFlux（一个用于创建反应式Web应用程序的框架）来构建反应式Web应用程序。
- en: Creating an enterprise-ready Spring-based application requires heavy configuration,
    which makes the process of development quite tedious and cumbersome. On top of
    this, setting up the complex dependencies also needs lots of effort. Quite often,
    the libraries used in Spring-based web applications require common configuration
    to bind them together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个企业级基于Spring的应用程序需要大量的配置，这使得开发过程变得相当繁琐和复杂。除此之外，设置复杂的依赖关系也需要大量的努力。通常，在基于Spring的Web应用程序中使用的库需要一些常见的配置来将它们绑定在一起。
- en: Considering any standard Spring-based application, you might need to perform
    certain repetitive tasks, specifically for configuration, for example, importing
    required modules and libraries to resolve dependencies; doing configuration related
    to various layers of application, such as data source and transaction management
    at the DAO layer, and view resolver and resource management at the web layer,
    and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到任何基于Spring的应用程序，你可能需要执行某些重复性任务，特别是配置相关的任务，例如，导入所需的模块和库以解决依赖项；进行与应用程序各层相关的配置，例如，在DAO层的数据源和事务管理，以及在Web层的视图解析和资源管理等等。
- en: This is a mandated procedure that has to be followed while creating any Spring-based
    web application. In short, developers often resort to duplicating the configuration
    across application and may not following the best practices while integrating
    libraries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在创建任何基于Spring的Web应用程序时必须遵循的强制性程序。简而言之，开发人员通常会跨应用程序复制配置，并且在集成库时可能不会遵循最佳实践。
- en: All these factors inspired the Spring team to come up with a framework that
    provides integration for all the Spring libraries through auto-configuration, which
    basically eliminates the repetitive jobs for you. In addition to this, it provides
    production-ready features, such as application metrics and monitoring, and logging
    and deployment guidelines. This framework is known as Spring Boot.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素激发了Spring团队提出一个框架，该框架通过自动配置提供对所有Spring库的集成，这基本上消除了你的重复性工作。除此之外，它还提供了生产就绪功能，如应用程序指标和监控、日志记录和部署指南。这个框架被称为Spring
    Boot。
- en: In this chapter, we will continue our journey and look at building different
    components required for a blog management web application using Spring libraries
    and other third-party libraries all bound together with auto-configuration provided
    by Spring Boot and some overrides done by us to the auto-configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续我们的旅程，并探讨使用Spring库和其他第三方库构建博客管理Web应用程序的不同组件，所有这些库都通过Spring Boot提供的自动配置绑定在一起，以及我们对自动配置的一些覆盖。
- en: 'This chapter will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Project skeleton with Spring Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Spring Boot的项目骨架
- en: The main flow of the application in the Spring MVC framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC框架中应用程序的主要流程
- en: Presentation layer with **Thymeleaf** and `Mustache.js`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Thymeleaf**和`Mustache.js`的表示层
- en: Making the application secure with Spring Security—covering authentication and
    authorization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security使应用程序安全——涵盖身份验证和授权
- en: Developing the backend layer in Elasticsearch, which holds the application data
    and provides REST-based CRUD operations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Elasticsearch中开发后端层，它存储应用程序数据并提供基于REST的CRUD操作
- en: Developing Spring MVC REST service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Spring MVC REST服务
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress)。代码可以在任何操作系统上执行，尽管它只在Windows上进行了测试。
- en: Application overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序概述
- en: Taking a real-life example is the best approach to explore and understand the
    concepts of a given framework context. The idea is not to show how to build the
    web application; instead, we will show the important components which are part
    of the application so that anyone can just pick one component and use it in another
    application. You can always find the complete working solution in the code downloaded
    for the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以现实生活中的例子为最佳方法来探索和理解给定框架上下文的概念。目的是不展示如何构建Web应用程序；相反，我们将展示应用程序的重要组成部分，以便任何人都可以选择一个组件并在另一个应用程序中使用它。您可以在为本书下载的代码中找到完整的完整解决方案。
- en: 'Let''s jump into action. First, we will go through the brief about our application—blog.
    We will call it **Blogpress**. Please note that it will not be a full-fledged
    blogging application; instead, we will develop it with the following functionalities:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始行动。首先，我们将简要介绍我们的应用程序——博客。我们将称之为**Blogpress**。请注意，它不会是一个完整的博客应用程序；相反，我们将开发以下功能：
- en: Landing page—shows a list of blogs with the links to each blog.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面——显示博客列表及其链接。
- en: When a user clicks on any of the blogs, the system opens it in view mode along
    with all (approved) comments.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击任何博客时，系统将以查看模式打开它，以及所有（已批准）评论。
- en: A user can add comments to the same screen.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在同一屏幕上添加评论。
- en: Apart from this, a user can search for the blog with given search text, targeting
    the title or body of the blog.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，用户可以使用给定的搜索文本搜索博客，目标是博客的标题或正文。
- en: 'There is a login feature. Two people can log into the application—a blog user
    and an admin:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有登录功能。两个人可以登录到应用程序——博客用户和管理员：
- en: Blog user can add/update/delete the blog. He can only edit the blogs he created.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客用户可以添加/更新/删除博客。他只能编辑自己创建的博客。
- en: Admin user can perform all possible operations a blog user can do plus manage
    (approve or reject) the comments given by the anonymous user.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员用户可以执行博客用户可以执行的所有可能操作，以及管理（批准或拒绝）匿名用户给出的评论。
- en: When any user adds a comment, an email will be sent to the admin user to moderate
    it. Once the comment is approved, an email will be sent back to the user as a
    notification.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何用户添加评论时，将向管理员用户发送电子邮件以进行审核。一旦评论被批准，将向用户发送电子邮件作为通知。
- en: Project skeleton with Spring Boot
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Spring Boot的项目骨架
- en: Spring Boot automates the process of creating the configuration which speeds
    up the development process. In short, Spring Boot makes the development life cycle
    shorter, with minimal or no configuration for building production-ready applications
    or services. It uses the convention-over-configuration methodology to provide
    rapid application development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot自动化创建配置的过程，从而加快了开发过程。简而言之，Spring Boot使开发周期更短，对于构建生产就绪的应用程序或服务，配置最少或没有配置。它使用约定优于配置的方法来提供快速应用程序开发。
- en: Spring Boot is not meant to provide any new features; instead, as it is established
    on top of the Spring Framework, it uses existing Spring Framework features to
    provide a preconfigured application skeleton out of the box, which is a getting-started
    mode of development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot的目的不是提供任何新功能；相反，因为它建立在Spring框架之上，它使用现有的Spring框架功能来提供开箱即用的预配置应用程序骨架，这是一种开发入门模式。
- en: 'Spring Boot has various advantages over conventional ways of creating a Spring-based
    application, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot相较于传统的基于Spring的应用程序创建方式具有各种优势，如下所述：
- en: Has automated configuration
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有自动配置功能
- en: Manages dependency with ease
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松管理依赖关系
- en: Supports an embedded server to make the development process easy and straightforward
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持嵌入服务器以简化开发过程
- en: Provides support for building the application with Maven or Gradle out of the
    box
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了使用Maven或Gradle构建应用程序的支持
- en: Eases integration with other Spring modules
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化了与其他Spring模块的集成
- en: Speeds up the development process
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快开发过程
- en: Supports command lines and IDEs to develop and test the application with ease
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持命令行和IDEs轻松开发和测试应用程序
- en: Configuring IDE Spring Tool Suite
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置IDE Spring Tool Suite
- en: Let's start developing our blog application—Blogpress. As described, we will
    start creating the application with Spring Boot first. Developing an application
    with an IDE is the most straightforward, easy, convenient, and favorable approach
    preferred by the majority of developers today. We use IDEs to develop our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始开发我们的博客应用程序——Blogpress。如描述，我们将首先使用Spring Boot创建应用程序。使用IDE开发应用程序是目前大多数开发者首选的最直接、简单、方便和有利的方法。我们使用IDE来开发我们的应用程序。
- en: Spring provides an Eclipse-based IDE called **Spring Tool Suite** (**STS**)
    to develop any Spring-based application with ease. Download the latest version
    of STS from the link [https://spring.io/tools.](https://spring.io/tools)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个基于Eclipse的IDE，称为**Spring Tool Suite**（**STS**），可以轻松地开发任何基于Spring的应用程序。从以下链接下载STS的最新版本：[https://spring.io/tools.](https://spring.io/tools)
- en: The STS is available with Eclipse, along with Visual Studio and Atom-based code
    editors. You can use either of them for your convenience.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: STS与Eclipse、Visual Studio和基于Atom的代码编辑器一起提供。您可以根据需要使用其中任何一个。
- en: 'We will use the STS (an Eclipse-based IDE) to build the application in this
    chapter. Download STS, unzip it in your local folder, and open the `.exe` file
    to start the STS. Once started, create a new Spring Starter Project of the Spring
    Boot type with the following attributes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用基于Eclipse的IDE STS来构建应用程序。下载STS，将其解压缩到您的本地文件夹中，然后打开`.exe`文件以启动STS。启动后，创建一个具有以下属性的Spring
    Boot启动项目：
- en: 'Name: `blogpress`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`blogpress`
- en: 'Type: Maven (you can also select Gradle)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：Maven（您也可以选择Gradle）
- en: 'Packaging: Jar'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包：Jar
- en: 'Java Version: 8 (or above)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java版本：8（或更高）
- en: 'Language: Java'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言：Java
- en: 'Group: This would be a Maven `groupId`, so give the appropriate value'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：这将是一个Maven `groupId`，因此请给出适当的值
- en: 'Artifact: This would be a Maven `artifactId`, so give the appropriate value'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成物：这将是一个Maven `artifactId`，因此请给出适当的值
- en: 'Version: `0.0.1-SNAPSHOT`—the build version of our application build'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：`0.0.1-SNAPSHOT`—我们应用程序的构建版本
- en: 'Description: `A simple blog management system`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：`一个简单的博客管理系统`
- en: You can create a Spring Boot application from a command window as well. Spring
    provides a tool called Spring **command-line interface** (**CLI**) for this. Another
    way of creating a Spring Boot starter project is with [https://start.spring.io/](https://start.spring.io/).
    You need to define the dependencies and it will allow users to download the entire
    project structure from the web.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从命令窗口创建Spring Boot应用程序。Spring提供了一个名为Spring **命令行界面**（**CLI**）的工具来支持这一点。创建Spring
    Boot启动项目的另一种方法是使用[https://start.spring.io/](https://start.spring.io/)。您需要定义依赖项，它将允许用户从网络上下载整个项目结构。
- en: 'Keeping all default options, click Finish to create the Spring Boot application.
    You will see the following dependencies in `pom.xml`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 保持所有默认选项，点击完成以创建Spring Boot应用程序。您将在`pom.xml`中看到以下依赖项：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spring Boot provides various starters, specific for each dependency so that
    their JARs are available in the classpath. Since we want to develop a web application
    (Spring MVC), we keep the starter `spring-boot-starter-web` in the previous code
    (in fact, it is added while creating a project in the STS).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了各种针对每个依赖项的启动器，以便它们的JAR文件可以在类路径中找到。由于我们想要开发一个Web应用程序（Spring MVC），我们在之前的代码中保留了`spring-boot-starter-web`启动器（实际上，它是在创建STS项目时添加的）。
- en: Spring provides a set of dependencies for a specific functionality in the form
    of a starter. It is a convenient way of managing dependencies in a Spring Boot
    application. When you specify a particular starter, Spring Boot will pull all
    (recursive) dependencies in your application for you. For example, if you wish
    to add a data store to your application with JPA, simply add `spring-boot-starter-jpa`
    to `pom.xml` in your Spring Boot application. All dependency will be carried out
    by Spring Boot so that you can focus on business implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一系列用于特定功能的依赖项，以启动器的形式。这是在Spring Boot应用程序中管理依赖项的一种便捷方式。当您指定特定的启动器时，Spring
    Boot将为您自动拉取应用程序中的所有（递归）依赖项。例如，如果您希望使用JPA将数据存储添加到应用程序中，只需将`spring-boot-starter-jpa`添加到Spring
    Boot应用程序的`pom.xml`中。所有依赖项都将由Spring Boot处理，这样您就可以专注于业务实现。
- en: 'You will see `spring-boot-starter-parent` in the parent element of `pom.xml`.
    This is the magic of Spring Boot. Your application extends all Spring Boot capabilities
    by this declaration, as following snippet shows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在`pom.xml`的父元素中看到`spring-boot-starter-parent`。这是Spring Boot的魔力所在。通过这个声明，你的应用程序扩展了所有Spring
    Boot的能力，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Spring Model-View-Controller web flow
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Model-View-Controller（MVC）网络流程
- en: The next step is to add Spring MVC capabilities. In the previous step, the required
    starter dependencies for the web are added to the `pom.xml` file. Next, we will
    define Spring MVC artifacts in our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加Spring MVC功能。在上一步中，我们将所需的Web启动依赖项添加到`pom.xml`文件中。接下来，我们将在我们的应用程序中定义Spring
    MVC组件。
- en: 'Since this is a Spring Boot application, we are not required to declare everything
    from scratch. It is essential to define the controllers and view layer. First,
    we will declare a Spring MVC controller, as in the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个Spring Boot应用程序，我们不需要从头开始声明一切。定义控制器和视图层是至关重要的。首先，我们将声明一个Spring MVC控制器，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@Controller` annotation describes this class as a Spring MVC controller.
    It basically instructs the Spring Boot application that this component will serve
    a web-based request. It matches the correct URL pattern to call a specific controller
    and its method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Controller`注解描述了这个类作为Spring MVC控制器。它基本上指示Spring Boot应用程序，这个组件将服务于基于Web的请求。它匹配正确的URL模式以调用特定的控制器及其方法。'
- en: In the previous declaration, we only gave the URL pattern to the controller
    method. However, Spring allows you to declare URL patterns for the controller
    as well. Since our application requires only certain functionalities, one controller
    is sufficient, and hence, we haven’t declared the URL pattern for the controller.
    So, all web requests (with the `http://host/context/controllerUrlPattern` pattern)
    for the current application will be routed to this controller.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的声明中，我们只为控制器方法提供了URL模式。然而，Spring 允许你为控制器声明URL模式。由于我们的应用程序只需要某些功能，一个控制器就足够了，因此，我们没有为控制器声明URL模式。所以，所有当前应用程序的Web请求（具有`http://host/context/controllerUrlPattern`模式的请求）都将路由到这个控制器。
- en: The `@RequestMapping("/controllerUrlPattern")` annotation is used to describe
    URL patterns at the controller level. In this scenario, the `http://host/context/controllerUrlPattern`
    pattern will reach this controller. The URL pattern of all of its methods will
    be appended after `http://host/context/controllerUrlPattern`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/controllerUrlPattern")`注解用于在控制器级别描述URL模式。在这种情况下，`http://host/context/controllerUrlPattern`模式将到达这个控制器。它所有方法的URL模式都将附加在`http://host/context/controllerUrlPattern`之后。'
- en: It is always good practice to use a logger. Spring provides the `LoggerFactory`
    class to get a logger instance for the current class. You can call various methods
    like `info`, `debug`, `error`, and so on at appropriate places.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用记录器是一个好习惯。Spring提供了`LoggerFactory`类来获取当前类的记录器实例。你可以在适当的位置调用各种方法，如`info`、`debug`、`error`等。
- en: The Spring MVC controller method can be mapped with a distinct URL so that it
    can be triggered by a matching request URL pattern. The `showLandingPage()` method
    is a controller method in the previous case. It is mapped with the URL `/` and
    this means the `http://localhost:8080/blogpress/` URL (considering you run the
    application in your local with the `8080` port and `blogpress` is the name of
    your application) will call this method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC控制器方法可以通过一个独特的URL进行映射，以便它可以由匹配的请求URL模式触发。在之前的例子中，`showLandingPage()`方法是一个控制器方法。它被映射到URL`/`，这意味着`http://localhost:8080/blogpress/`
    URL（假设你在本地使用`8080`端口运行应用程序，并且`blogpress`是你的应用程序的名称）将调用此方法。
- en: This method returns a string, `home`, which represents the component from the
    presentation layer. Spring MVC is flexible enough to choose the desired presentation
    framework. So, it is absolutely unnecessary to use specific technology as your
    presentation layer. You can use **JavaServer Pages** (**JSP**s), Thymeleaf, or
    a UI framework such as Angular as your frontend for a Spring MVC web application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个字符串`home`，它表示表示层中的组件。Spring MVC足够灵活，可以选择所需的表示框架。因此，没有必要使用特定技术作为你的表示层。你可以使用**JavaServer
    Pages**（**JSP**s）、Thymeleaf或如Angular这样的UI框架作为Spring MVC Web应用程序的前端。
- en: In this chapter, we will use Thymeleaf to build the presentation layer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Thymeleaf来构建表示层。
- en: Presentation layer with Thymeleaf
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Thymeleaf的表示层
- en: 'Thymeleaf is a template engine used to process various templates in XML, HTML,
    JavaScript, CSS, and plain TEXT on the server side. You might have a question:
    why Thymeleaf? We already have JSP. What are the benefits of using Thymeleaf over
    JSP?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf是一个模板引擎，用于在服务器端处理XML、HTML、JavaScript、CSS和纯文本模板。你可能会有这样的疑问：为什么是Thymeleaf？我们已经有JSP了。使用Thymeleaf相对于JSP有什么好处？
- en: The answer is, Thymeleaf is designed with a natural templating concept and provides
    a design prototype support without affecting the use of the template. In other
    words, due to its nature, Thymeleaf can be used by both developers and design
    teams without being locked-in or having a dependency between either of them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，Thymeleaf是按照自然模板概念设计的，并提供设计原型支持，而不会影响模板的使用。换句话说，由于其本质，Thymeleaf可以被开发者和设计团队使用，而不会受到限制或两者之间有依赖关系。
- en: Another good thing about Thymeleaf is that it is designed in accordance with
    web standards, mainly HTML5\. This will make it easy for you to fully validate
    the templates if that is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf的另一个优点是它符合网络标准，主要是HTML5。这将使你在需要时能够完全验证模板。
- en: How Thymeleaf works
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thymeleaf的工作原理
- en: 'For our blogging application, we will use the Thymeleaf HTML template. The
    very first step for working with Thymeleaf is to instruct Spring Boot so that
    it can make all the necessary configurations specific to Thymeleaf readily available
    for our application. Add the following entry in `pom.xml`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的博客应用，我们将使用Thymeleaf HTML模板。使用Thymeleaf的第一步是指导Spring Boot，使其能够为我们应用提供所有必要的特定于Thymeleaf的配置。在`pom.xml`中添加以下条目：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thymeleaf provides certain tags (a kind of JSP tags) to embed dynamic values
    into the template. We will first go through the bare minimum tags that we intend
    to use in our Blogpress application. The mechanism of inserting a dynamic value
    into the Thymeleaf template is different than what you might have seen in JSP
    tags, so it is quite vital to be familiar with it before starting to use it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf提供某些标签（一种JSP标签）来将动态值嵌入到模板中。我们将首先介绍我们在Blogpress应用中打算使用的最基本标签。将动态值插入Thymeleaf模板的机制与你在JSP标签中看到的不同，因此在开始使用之前熟悉它是相当重要的。
- en: You can see another starter for Thymeleaf. This is how Spring Boot makes the
    developer's life easy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Thymeleaf的另一个启动器。这就是Spring Boot如何让开发者的生活变得简单。
- en: Dialects, processors, and expression objects
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方言、处理器和表达式对象
- en: Dialects are a set (or group) of features that you use in your template, including
    pre- and post-processing logic and expression objects. Processing logic (of embedding
    the dynamic HTML and value in the template) is carried out by objects called a
    processor, while expression objects are used to describe standard expression for
    performing a specific operation. In short, processor objects deal with the DOM
    node or element, while expression objects are used to evaluate the expression.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方言是一组你在模板中使用的功能，包括预处理和后处理逻辑以及表达式对象。处理逻辑（在模板中嵌入动态HTML和值）由称为处理器的对象执行，而表达式对象用于描述执行特定操作的标准表达式。简而言之，处理器对象处理DOM节点或元素，而表达式对象用于评估表达式。
- en: 'Dialects can be used along with processors, or expression objects, or both.
    Let''s see how a dialect can be declared and used in the template:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 方言可以与处理器或表达式对象一起使用，也可以两者都使用。让我们看看如何在模板中声明和使用方言：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In previous snippet, `th` is called the dialect prefix. It means that all attributes
    and tags provided by this dialect start with `th:`. This is a standard and out-of-the-box
    dialect, and it is just sufficient for most of our scenario. You can consider
    dialect similar to *Taglibs* in JSP.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，`th`被称为方言前缀。这意味着该方言提供的所有属性和标签都以`th:`开头。这是一个标准且开箱即用的方言，对于大多数场景来说已经足够了。你可以将方言视为JSP中的*Taglibs*。
- en: You can define more than one dialect in your template. Additionally, you can
    create your own custom dialect with custom processing logic in custom processors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板中定义多个方言。此外，你还可以创建自己的自定义方言，并在自定义处理器中添加自定义处理逻辑。
- en: 'The `text` attribute represents a processor that simply puts the value for
    the span while `${...}` describes the value expression object, which simply pulls
    the attribute value stored in the model. The following are the types of expression
    objects available in Thymeleaf:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`属性代表一个处理器，它只是将值放入span中，而`${...}`描述的是值表达式对象，它简单地从模型中拉取属性值。以下是在Thymeleaf中可用的表达式对象类型：'
- en: '**Variable expression objects:** They are used to show the value of the model
    attribute. They are in the form of Spring **expression language** (**EL**). They
    can be described with the `${...}` syntax.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量表达式对象**：它们用于显示模型属性的值。它们的形式是Spring **表达式语言**（**EL**）。它们可以用`${...}`语法来描述。'
- en: '**Selection expression object:** These are similar to expression objects but
    can only be applied to the previously selected object. They can be used with the `*{...}`
    syntax.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择表达式对象**：这些与表达式对象类似，但只能应用于之前选定的对象。它们可以与`*{...}`语法一起使用。'
- en: '**Message (i18n) expressions:** These are used for internationalization purposes
    and bringing language-specific messages. You can use the `#{...}` syntax.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息（国际化）表达式**：这些用于国际化目的和提供特定语言的短信。您可以使用`#{...}`语法。'
- en: '**Link (URL) expressions:** These are used to employ links dynamically. For
    example, form action, HREF, linking JS/CSS, or other static resources, and so
    on. Use the `@{...}` syntax for them.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接（URL）表达式**：这些用于动态应用链接。例如，表单操作、HREF、链接JS/CSS或其他静态资源等。使用`@{...}`语法。'
- en: '**Fragment expressions:** This represents a fragment of the template and can
    be reused in similar or other templates. They can be utilized with the `~{...}`
    syntax.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段表达式**：这代表模板的一部分，可以在类似或其他模板中重复使用。它们可以使用`~{...}`语法。'
- en: 'Next, we will see some of the processors that we are going to use in our following
    application. They can be used along with various expression objects listed as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到我们将在后续应用程序中使用的一些处理器。它们可以与以下列出的各种表达式对象一起使用：
- en: '`th:text`—This is used along with value expression objects to place dynamic
    text for HTML elements like `span`, `li`, `div`, and so on'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:text`—这用于与值表达式对象一起使用，为HTML元素如`span`、`li`、`div`等放置动态文本。'
- en: '`th:value`—The value of the input element can be supplied with this processor'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:value`—可以使用此处理器提供输入元素的值。'
- en: '`th:action`—This can be used to supply the action value to HTML form'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:action`—这可以用来向HTML表单提供操作值。'
- en: '`th:href`—As its name suggests, this is used to provide an URL in the link
    (to import CSS) and tags in HTML'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:href`—正如其名所示，这用于在链接中提供URL（导入CSS）和HTML中的标签。'
- en: '`th:src`—This is used to provide source URL for script (and other such) elements
    in HTML dynamically'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:src`—这用于在HTML中动态提供脚本（和其他类似）元素的源URL。'
- en: '`th:each`—This is used with `th:text` in the loop to construct repetitive HTML
    code, that is, rows of HTML tables'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:each`—这用于循环中的`th:text`，以构建重复的HTML代码，即HTML表格的行。'
- en: '`**th:if**` and `th:unless`—These are used to place dynamic values conditionally'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**th:if**`和`th:unless`—这些用于条件性地放置动态值。'
- en: Thymeleaf supports defining attributes and element names in HTML5 style. For
    example, instead of writing `th:text`, you can write `data-th-text` as an attribute
    in an HTML element, and it is considered a custom element in HTML5.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Thymeleaf支持在HTML5风格中定义属性和元素名称。例如，您可以用`data-th-text`作为HTML元素的属性来代替`th:text`，在HTML5中被视为自定义元素。
- en: Why Thymeleaf is a natural template
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Thymeleaf是一个自然的模板
- en: We have seen the processors of standard dialect are placed as an attribute of
    HTML element. Because of this arrangement, the browser can render the Thymeleaf
    template as a correct HTML file, even before they are processed by the template
    engine.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到标准方言的处理器被放置为HTML元素的属性。由于这种安排，即使在模板引擎处理之前，浏览器也可以正确渲染Thymeleaf模板。
- en: 'This is quite possibly because the browser simply ignores them, considering
    them custom attributes, so there is no issue in displaying them. The same cannot
    be possible in the case of JSP. For example, the JSP with the following tag is
    not rendered in the browser:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能是因为浏览器简单地忽略了它们，将它们视为自定义属性，因此在显示时没有问题。在JSP的情况下则不可能。例如，以下标签的JSP在浏览器中不会被渲染：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And if you write it with Thymeleaf, it will be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Thymeleaf编写，它将如下所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The browser will display the preceding code perfectly. Additionally, Thymeleaf
    allows you to supply the (optional) value attribute (`Nilang` in our case), which
    will be displayed statically when run on the browser. When the same code is processed
    by the Thymeleaf template engine, the value will be substituted by evaluation
    of the `${name}` expression on the fly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将完美地显示前面的代码。此外，Thymeleaf允许您提供（可选的）值属性（在我们的例子中是`Nilang`），当在浏览器上运行时将静态显示。当相同的代码由Thymeleaf模板引擎处理时，值将通过实时评估`${name}`表达式来替换。
- en: This is the reason why Thymeleaf is called a natural template engine. It allows
    the designer to work with the developer without producing dependency on either
    side.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Thymeleaf被称为自然模板引擎的原因。它允许设计师与开发者合作，而不会产生对任何一方的依赖。
- en: Now, let's discuss which Thymeleaf templates we are going to use in our blog
    application. When you create a Spring Boot application, you will see a `templates`
    file in the `src/main/resources` folder. All our Thymeleaf templates reside there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下我们将在我们的博客应用程序中使用的Thymeleaf模板。当你创建一个Spring Boot应用程序时，你将在`src/main/resources`文件夹中看到一个`templates`文件。我们所有的Thymeleaf模板都驻留在那里。
- en: 'We are going to use following templates in our application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中使用以下模板：
- en: '`header.html`: This template contains a common JS/CSS inclusion header, along
    with a navigation bar. It is included in all other templates.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header.html`: 这个模板包含一个常见的JS/CSS包含头部，以及一个导航栏。它包含在所有其他模板中。'
- en: '`home.html`: Shows home page content.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home.html`: 显示主页内容。'
- en: '`login.html`: Allows the user to login into the system.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login.html`: 允许用户登录到系统中。'
- en: '`user-page.html`: Once a blog user logs in, he will land on this page.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user-page.html`: 一旦博客用户登录，他将会进入这个页面。'
- en: '`view-blog.html`: Opens a particular blog in read-only mode.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view-blog.html`: 以只读模式打开特定的博客。'
- en: '`search.html`: Shows the search result.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search.html`: 显示搜索结果。'
- en: '`new-blog.html`: A blog user or admin can create a new blog through this template.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new-blog.html`: 博客用户或管理员可以通过这个模板创建一个新的博客。'
- en: '`manage-comments.html`: An admin user can approve/reject comments.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manage-comments.html`: 管理员用户可以批准/拒绝评论。'
- en: '`edit-blog.html`: Allows a blog user/admin user to edit the existing blog.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit-blog.html`: 允许博客用户/管理员编辑现有的博客。'
- en: '`admin-page.html`: Once an admin user logs in, they will land on this page.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin-page.html`: 一旦管理员用户登录，他们将会进入这个页面。'
- en: We will first add two templates—`home` and `header`. Before going further, let’s
    see one more cool feature of Thymeleaf that we will use in our application. Just
    like JSP, you can include a template into another template. Additionally, Thymeleaf
    allows you to include only some portion (fragment) of the template instead of
    the whole template, which is not possible with JSP.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加两个模板——`home`和`header`。在进一步操作之前，让我们看看Thymeleaf的一个酷炫特性，我们将在我们的应用程序中使用。就像JSP一样，你可以将一个模板包含到另一个模板中。此外，Thymeleaf还允许你只包含模板的一部分（片段），而不是整个模板，这是JSP所做不到的。
- en: 'This is a great feature, as you can define common fragments in one template
    and include them in others. In our case, we have defined common header items in
    a `header.html` template as in the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很棒的功能，因为你可以在一个模板中定义常见的片段，并在其他模板中包含它们。在我们的例子中，我们在`header.html`模板中定义了常见的头部元素，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fragment is defined by the `th:fragment` tag. You can see how Thymeleaf
    tags (with dialect prefix, processors, and expression objects) are used to import
    various static resources (JS/CSS) along, with adding a dynamic value to HTML elements
    (`${pageTitle}` , in our case).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该片段由`th:fragment`标签定义。你可以看到Thymeleaf标签（带有方言前缀、处理器和表达式对象）是如何用来导入各种静态资源（JS/CSS），并且向HTML元素添加动态值（在我们的例子中是`${pageTitle}`）。
- en: 'We can include this header (which is defined as the fragment) in other templates.
    For example, in our `home.html` template, we have used it as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个头部（定义为片段）包含在其他模板中。例如，在我们的`home.html`模板中，我们使用了它如下：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `th:replace` tag is used to refer the fragment code from other templates.
    You need to just put the name of the template (from where you are referring fragments)
    with two colons (`::`) and the name of the fragment (that you have defined with
    the `th:fragment` tag). This is how Thymeleaf allows you to refer a set of template
    codes as a fragment to other templates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`th:replace`标签用于从其他模板引用片段代码。你只需要将模板的名称（你从中引用片段的模板）用两个冒号（`::`）和片段的名称（你用`th:fragment`标签定义的）放在一起。这就是Thymeleaf允许你将一组模板代码作为片段引用到其他模板中的方式。'
- en: We have defined another fragment, called `header_navigation`, which is referred
    to in the home template in the previous code snippet. It is used to show a navigation
    menu for our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了另一个片段，称为`header_navigation`，在前面代码片段中的主页模板中引用。它用于显示我们应用程序的导航菜单。
- en: 'At this moment, we also need to put static resources (JS/CSS) into our application.
    You will see a static folder in the project structure where all static resources
    should be placed. Spring Boot will consider everything in the static folder as
    a static resource. Create `css`, `img`, and `js` folders under the static folder
    and place the following resources in them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，我们还需要将静态资源（JS/CSS）放入我们的应用程序中。你将在项目结构中看到一个静态文件夹，所有静态资源都应该放在那里。Spring Boot会将静态文件夹中的所有内容视为静态资源。在静态文件夹下创建`css`、`img`和`js`文件夹，并将以下资源放入其中：
- en: 'To the `css` folder, add the following:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`css`文件夹中，添加以下内容：
- en: '`bootstrap.min.css`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.min.css`'
- en: 'To the `js` folder, add the following:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`js`文件夹中，添加以下内容：
- en: '`Bootstrap.min.js`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bootstrap.min.js`'
- en: '`Jquery.min.js`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jquery.min.js`'
- en: '`popper.js`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popper.js`'
- en: Now it is time to run our application to see the home page. You can build and
    deploy it on a server and access it with the `http://localhost:8080/blogpress`
    URL, and you will see the home page with a header and navigation bar. Next, we
    have to make our application secure with Spring security. Security is an important
    aspect and core concern for any application today.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的应用程序以查看主页了。你可以在服务器上构建和部署它，并通过`http://localhost:8080/blogpress` URL访问它，你将看到一个带有页眉和导航栏的主页。接下来，我们必须使用Spring安全使我们的应用程序安全。安全性是任何应用程序今天的一个重要方面和核心关注点。
- en: Making the application secure with Spring Security
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security使应用程序安全
- en: Our Blogpress application has a login functionality to access certain pages
    and functionalities that are not accessible by a normal (anonymous) user. It requires
    a good amount of effort to incorporate it if we build authentication and authorization
    on our own from scratch. Spring provides a feature called Spring Security, which
    does exactly what we need here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Blogpress应用程序具有登录功能，用于访问普通（匿名）用户无法访问的某些页面和功能。如果我们从头开始自己构建认证和授权，则需要付出大量的努力。Spring提供了一个名为Spring
    Security的功能，它正好满足我们的需求。
- en: Spring Security is an open source, highly comprehensive, powerful, and customizable framework
    used to implement authentication and authorization in J2EE-based web applications.
    It is a sub-project (module) of the Spring Framework.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个开源的、高度综合的、强大且可定制的框架，用于在基于J2EE的Web应用程序中实现认证和授权。它是Spring框架的一个子项目（模块）。
- en: Before talking further, it is important to understand the difference between
    authentication and authorization.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论之前，了解认证和授权之间的区别非常重要。
- en: Authentication is the process of **validating** or determining someone or something
    in what it claims to be. There are several mechanisms to perform authentication.
    The most straightforward way of performing authentication is to provide a username
    and password. Other ways include through LDAP, single sign-on, OpenId, and OAuth.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是验证或确定某人或某物所声称身份的过程。执行认证有多种机制。执行认证最直接的方式是提供用户名和密码。其他方式包括通过LDAP、单点登录、OpenId和OAuth。
- en: On the other hand, authorization is more related to the **permission** of the
    actions you are allowed to do. In short, authentication means **who you are**
    and authorization means **what can you do** in the system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，授权更多地与你可以执行的动作的**权限**相关。简而言之，认证意味着**你是谁**，而授权意味着你在系统中**可以做什么**。
- en: Spring Security provides many features out of the box, including authentication,
    authorization, protection against CSRF attack, servlet API integration support,
    Spring MVC integration, remember-me features, SSO implementation support, LDAP
    authentication support, OpenID integration, web service security support, WebSocket
    security support, Spring Data integration, and many more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了许多开箱即用的功能，包括认证、授权、防止CSRF攻击、servlet API集成支持、Spring MVC集成、记住我功能、SSO实现支持、LDAP认证支持、OpenID集成、Web服务安全支持、WebSocket安全支持、Spring
    Data集成，等等。
- en: Though the latest version (at the time of writing this is 5.1.0) of Spring Security
    supports both XML and annotation support, you still need to do a good amount of
    configuration if you set it on your own. But you don’t have to worry, as Spring
    Boot is with you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管撰写本文时Spring Security的最新版本（5.1.0）支持XML和注解支持，但如果你自己设置它，仍然需要进行大量的配置。但不必担心，因为Spring
    Boot与你同在。
- en: 'Spring Boot also supports Spring Security integration. Just like integration
    with other modules, you need to add a required starter for Spring Security to
    work with Spring Boot. Add the following dependency in the `pom.xml` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 也支持 Spring Security 的集成。就像与其他模块的集成一样，你需要添加一个必需的启动器（starter）来使 Spring
    Security 与 Spring Boot 一起工作。在 `pom.xml` 文件中添加以下依赖项：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As soon as you put the previously mentioned configuration in place, Spring Security
    becomes active and will not allow accessing even public pages of the application
    without valid credentials. When you hit `http://localhost:8080/blogpress`, you
    will see a login screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了之前提到的配置，Spring Security 就会激活并阻止在没有有效凭证的情况下访问应用中的任何页面，即使是公开页面。当你访问 `http://localhost:8080/blogpress`
    时，你会看到一个登录界面。
- en: 'Spring Security with its default (auto) configuration, allows you to log in
    with a specific credential. The username will be `user` and password will be generated
    randomly by Spring Security and printed in the server log like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 及其默认（自动）配置允许你使用特定的凭证登录。用户名将是 `user`，密码将由 Spring Security 随机生成并在服务器日志中像这样打印出来：
- en: 'Using generated security password: 89ca7b55-6a5d-4dd9-9d02-ae462e21df81.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的安全密码：89ca7b55-6a5d-4dd9-9d02-ae462e21df81。
- en: 'You can override the username and password in a `property` file. In the project
    structure, you will see the `application.properties` file in the `src/main/resources`
    folder. Just add following two properties to it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `property` 文件中覆盖用户名和密码。在项目结构中，你将在 `src/main/resources` 文件夹中看到 `application.properties`
    文件。只需向其中添加以下两个属性：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you can access the application with the previously mentioned credentials,
    but you still need authentication for accessing even public pages. By default,
    Spring Security is activated with the default (or auto-) configuration, which
    secures all the endpoints. This is not we want. So we need to instruct Spring
    Security which endpoints (URLs) we want to make secure and which we do not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用之前提到的凭证访问应用，但你仍然需要认证才能访问公开页面。默认情况下，Spring Security 使用默认（或自动）配置激活，这保护了所有端点。这不是我们想要的。因此，我们需要指导
    Spring Security 我们想要使哪些端点（URL）安全，哪些不安全。
- en: For this, first, we need to disable the default security (auto-) configuration.
    There are two possible options here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先我们需要禁用默认的安全（自动）配置。这里有两种可能的选择。
- en: Excluding auto-configuration
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除自动配置
- en: 'Add an `exclude` attribute to the `@SpringBootApplication` annotation for the
    main `bootstrap` class, as in the following snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `bootstrap` 类的 `@SpringBootApplication` 注解中添加一个 `exclude` 属性，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can add the following property in the `application.properties`
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在 `application.properties` 文件中添加以下属性：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can take either of the previously described ways to disable or exclude the
    security (auto-) configuration. Excluding the auto-configuration is appropriate
    only in certain scenarios where you need to integrate the security provided by
    a custom provider.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择之前描述的任何一种方法来禁用或排除安全（自动）配置。排除自动配置仅在需要集成由自定义提供者提供的安全性的特定场景中适用。
- en: Substituting auto-configuration
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换自动配置
- en: Another way of disabling the auto-security configuration is to surpass it with
    our own custom configuration. Spring Security is a highly customizable framework
    and provides a fine-grained access mechanism based on URL and role.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种禁用自动安全配置的方法是用我们自己的自定义配置覆盖它。Spring Security 是一个高度可定制的框架，并提供了基于 URL 和角色的细粒度访问机制。
- en: 'To substitute auto-configuration with custom configuration, we need to specify
    the configuration class, as in the following snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要用自定义配置替换自动配置，我们需要指定配置类，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `WebSecurityConfig` custom configuration class extends the `WebSecurityConfigurerAdapter`
    abstract class. This abstract class has certain extension points (in the form
    of abstract methods for which you can provide your custom implementation) and
    default implementation for the common tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSecurityConfig` 自定义配置类扩展了 `WebSecurityConfigurerAdapter` 抽象类。这个抽象类有某些扩展点（以抽象方法的形式提供，你可以提供自己的自定义实现）和常见任务的默认实现。'
- en: Since our class (`WebSecurityConfig`) provides custom configuration, we have
    to define it with the `@Configuration` and `@ComponentScan("com.nilangpatel.blogpress")`
    annotations. You need to give the package (where the custom configuration class
    resides) name into the `@ComponentScan` annotation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的类 (`WebSecurityConfig`) 提供了自定义配置，我们必须使用 `@Configuration` 和 `@ComponentScan("com.nilangpatel.blogpress")`
    注解来定义它。你需要将自定义配置类所在的包名（`@ComponentScan` 注解中）提供进去。
- en: 'The `@EnableWebSecurity` annotation is also important because we are disabling
    the default security configuration. Without it, our application will not start.
    We will now override one method of the `WebSecurityConfigurerAdapter` class that
    will be used to define the web configuration and add one additional method that
    will be used to define user details:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableWebSecurity` 注解也很重要，因为我们正在禁用默认的安全配置。没有它，我们的应用程序将无法启动。我们现在将覆盖 `WebSecurityConfigurerAdapter`
    类的一个方法，该方法将用于定义网络配置，并添加一个额外的方法，用于定义用户详情：'
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Spring Security by default applies to all requests—including static resources
    as well. This method is used to define an escape sequence for static resources.
    Spring Security will block them by default if they are not configured to be ignored
    here. In the absence of the previously discussed configuration, the static resource
    will not be loaded into the browser so you will not see any `javascript`, `css`,
    or `images` files. Next, we will add user''s details to the same class as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 默认适用于所有请求——包括静态资源。此方法用于定义静态资源的转义序列。如果在这里没有配置为忽略，Spring Security
    将默认阻止它们。在没有之前讨论的配置的情况下，静态资源将不会被加载到浏览器中，因此你将看不到任何 `javascript`、`css` 或 `images`
    文件。接下来，我们将按照以下方式将用户详情添加到同一个类中：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `configureGlobal` method is used here to create a username with a password
    and role on the fly. It is declared with the `@Autowired` annotation so that Spring
    will inject the object of the `AuthenticationManagerBuilder` class in it. The `AuthenticationManagerBuilder`
    class is used to provide the implementation of `AuthenticationManager`. As we
    have seen, Spring Security allows various mechanisms for authentication, and provides
    an implementation of `AuthenticationManager` for each of those mechanisms, such
    as in-memory authentication, LDAP authentication, JDBC authentication, OAuth authentication,
    and so on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureGlobal` 方法在这里被用来动态创建一个带有密码和角色的用户名。它通过 `@Autowired` 注解声明，以便 Spring
    将 `AuthenticationManagerBuilder` 类的对象注入其中。`AuthenticationManagerBuilder` 类用于提供
    `AuthenticationManager` 的实现。正如我们所见，Spring Security 允许各种认证机制，并为这些机制中的每一个提供了 `AuthenticationManager`
    的实现，例如内存认证、LDAP认证、JDBC认证、OAuth认证等等。'
- en: To make the thing simple, we have used in-memory authentication, which simply
    puts the user details in memory. This is not ideal for production, however. You
    are supposed to create user details in a database, and Spring Security is flexible
    enough to support this scenario as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单，我们使用了内存认证，它只是简单地将用户详情存储在内存中。然而，这并不适合生产环境。你应该在数据库中创建用户详情，Spring Security
    足够灵活，也支持这种场景。
- en: Making the password secure is the most important, core part of any security
    framework, and hence Spring Security provides an encoding mechanism for this.
    It provides `BCryptPasswordEncoder` , which is an encoder class used to encode
    the password. It uses the **bcrpt** algorithm for encoding, which is a very strong
    password hashing routine widely used in Spring Security today.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使密码安全是任何安全框架最重要的核心部分，因此 Spring Security 提供了相应的编码机制。它提供了 `BCryptPasswordEncoder`，这是一个用于编码密码的编码类。它使用
    **bcrpt** 算法进行编码，这是一种在 Spring Security 中广泛使用的非常强大的密码散列程序。
- en: Spring Security also provides a class called `NoOpPasswordEncoder` in case you
    wish to store the password as it is (in plain text form). However, starting with
    version 5, Spring has decided to deprecate it and it may be removed in future
    releases. This is because putting passwords as plain text is not encouraged and
    can lead to a security breach. So you should never use the `NoOpPasswordEncoder`
    class (not even for any POC).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 还提供了一个名为 `NoOpPasswordEncoder` 的类，以防你希望以明文形式存储密码。然而，从版本 5 开始，Spring
    决定弃用它，并且它可能在未来的版本中被移除。这是因为将密码以明文形式存储是不被鼓励的，可能会导致安全漏洞。因此，你永远不应该使用 `NoOpPasswordEncoder`
    类（甚至对于任何原型验证都不应该使用）。
- en: We have used a method named `configureGlobal` , but you are absolutely free
    to choose the one you feel appropriate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了名为 `configureGlobal` 的方法，但你绝对可以自由选择你认为合适的方法。
- en: 'Next, we will override one more method, which is an extension point, to provide
    custom security settings for each of the endpoints we have in our application,
    as in the following snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将覆盖另一个方法，这是一个扩展点，为我们应用程序中的每个端点提供自定义安全设置，如下所示：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We override the configure method (having `HttpSecurity` as a method parameter)
    to provide custom security configuration. If you open the original configure method
    of the parent class (`WebSecurityConfigurerAdapter`), it looks like the following
    snippet. Just putting the reference of the original method side by side will help
    you to understand what custom configuration we provide for our Blogpress application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了具有`HttpSecurity`作为方法参数的configure方法，以提供自定义安全配置。如果您打开父类（`WebSecurityConfigurerAdapter`）的原始configure方法，它看起来如下所示。将原始方法的引用并排放置将有助于您理解我们为我们的Blogpress应用程序提供的自定义配置。
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default `configure` method simply authenticates all requests. It allows
    a user to authenticate with a form-based login and supports HTTP basic authentication.
    This is the reason we were getting a default login page as soon as Spring Security
    was activated in Spring Boot with no custom security configuration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`configure`方法简单地认证所有请求。它允许用户通过基于表单的登录进行认证，并支持HTTP基本认证。这就是为什么我们在Spring Boot中激活Spring
    Security而没有自定义安全配置时，会立即得到默认登录页面。
- en: In the Spring Security paradigm, `principal` refers to the username while `authorities`
    refers to the roles a user has. Keeping these terminologies in mind while working
    with Spring Security will help you understand the concepts better.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security范式中，`principal`指的是用户名，而`authorities`指的是用户拥有的角色。在处理Spring Security时牢记这些术语将有助于您更好地理解概念。
- en: 'Now, let''s see what customization we did in our overridden configure method
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在覆盖的configure方法中做了哪些自定义，如下所示：
- en: The `antMatchers("/", "/home").permitAll()` line will allow the listed URLs
    without any authentication. It means the `/` (default URL —`http://localhost:8080/blogpress`)
    URL is accessible publicly. You can provide any further URLs in comma-separated
    lists here.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antMatchers("/", "/home").permitAll()`这一行将允许列出的URL无需任何认证。这意味着`/`（默认URL — `http://localhost:8080/blogpress`）URL是公开可访问的。您可以在逗号分隔的列表中提供任何其他URL。'
- en: The next `antMatchers("/controlPage").hasAnyAuthority("ROLE_USER","ROLE_ADMIN")`
    line makes the `/controlPage` URL accessible to any user with the `ROLE_USER`
    or `ROLE_ADMIN` roles.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个`antMatchers("/controlPage").hasAnyAuthority("ROLE_USER","ROLE_ADMIN")`行使得`/controlPage`
    URL对具有`ROLE_USER`或`ROLE_ADMIN`角色的任何用户可访问。
- en: The next `formLogin().loginPage("/login").permitAll()` line allows us to set
    the login page URL. We kept the `/login` URL, but you can give any custom login
    URL. Since the login page should be accessible publicly, the `permitAll()` method
    will make the login URL accessible to all.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个`formLogin().loginPage("/login").permitAll()`行允许我们设置登录页面URL。我们保留了`/login`
    URL，但您可以提供任何自定义登录URL。由于登录页面应该是公开可访问的，`permitAll()`方法将使登录URL对所有用户可访问。
- en: Once Spring Security authenticates the user, it will send to a success page.
    You can configure the custom success page with `defaultSuccessUrl("/controlPage")`.
    In this case, the success URL is `/controlPage`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦Spring Security认证了用户，它将发送到成功页面。您可以使用`defaultSuccessUrl("/controlPage")`配置自定义成功页面。在这种情况下，成功URL是`/controlPage`。
- en: Similarly in case authentication fails, it should send to the error page. The
    `failureUrl("/login?error=true")` line will send the flow to the `/login` URL
    (along with parameters) on failed authentication.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，如果认证失败，它应该发送到错误页面。`failureUrl("/login?error=true")`这一行将在认证失败时将流程发送到`/login`
    URL（包括参数）。
- en: Finally, the `permitAll().logoutSuccessUrl("/login?logout=true")` line configured
    the logout page. Once a user logs out, the system will trigger the `/login` URL
    (along with parameters).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`permitAll().logoutSuccessUrl("/login?logout=true")`这一行配置了注销页面。一旦用户注销，系统将触发`/login`
    URL（包括参数）。
- en: 'We have added our custom security configuration; now it is time to add methods
    in Spring MVC corresponding to each URL we mentioned in the previous Spring configuration.
    Add the following methods in Spring MVC:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了我们的自定义安全配置；现在，是时候在Spring MVC中添加与之前在Spring配置中提到的每个URL相对应的方法。在Spring MVC中添加以下方法：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `showHomePage` method is responsible for showing the home page when a user
    clicks on the Home link from navigation. It is associated with `/` URL and will
    show the `home.html` (Thymeleaf) template. In addition, this method is also called
    when you hit the `http://localhost:8080/blogpress` URL.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`showHomePage` 方法负责在用户点击导航中的“主页”链接时显示主页。它与 `/` URL 关联，并将显示 `home.html`（Thymeleaf）模板。此外，当你访问
    `http://localhost:8080/blogpress` URL 时，此方法也会被调用。'
- en: The `showControlPage` method is associated with the `/controlPage` URL and will
    be called on successful authentication. This method drives the user to the `control-page.html`
    (Thymeleaf) template, which shows administrative links based on the role. For
    example, a user with the `ROLE_ADMIN` role can see the links for Manage Blogs
    and Manage Comments, while a user with the `ROLE_USER` role will see only the Manage
    Blogs link.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`showControlPage` 方法与 `/controlPage` URL 关联，并在成功认证后被调用。此方法将用户引导到 `control-page.html`（Thymeleaf）模板，该模板根据角色显示管理链接。例如，具有
    `ROLE_ADMIN` 角色的用户可以看到“管理博客”和“管理评论”的链接，而具有 `ROLE_USER` 角色的用户将只能看到“管理博客”链接。'
- en: The `showLoginPage` method represents the login functionality. It is associated
    with the `/login` URL. It stores messages based on parameter values along with
    the page title attribute, which is used to display a title of the page (in the
    `header.html` template). Finally, it opens the `login.html` template.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`showLoginPage` 方法代表登录功能。它与 `/login` URL 关联。它根据参数值存储消息以及页面标题属性，该属性用于显示页面标题（在
    `header.html` 模板中）。最后，它打开 `login.html` 模板。'
- en: 'Apart from these methods, the following methods are added, which stores model
    attributes that are available in Thymeleaf templates directly using the `${}`
    expression:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法之外，还添加了以下方法，这些方法直接使用 `${}` 表达式在 Thymeleaf 模板中存储可用的模型属性：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `isUserLoggedIn` method checks if any user is currently logged in. It will
    be called by the`${validUserLogin}` expression in the Thymeleaf template. The
    `getCurrentUserName` method simply provides the current logged-in username. The
    `checkIfUserHasUserRole` and `checkIfUserHasAdminRole` methods simply check the
    respective roles. You can see how the `SecurityContextHolder` class is used to
    fetch user login details. This class is responsible to store currently authenticated
    user's details, also known as principle.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`isUserLoggedIn` 方法检查是否有用户当前登录。它将由 Thymeleaf 模板中的 `${validUserLogin}` 表达式调用。`getCurrentUserName`
    方法简单地提供当前登录的用户名。`checkIfUserHasUserRole` 和 `checkIfUserHasAdminRole` 方法简单地检查相应的角色。你可以看到
    `SecurityContextHolder` 类是如何用来获取用户登录详情的。这个类负责存储当前认证用户的详情，也称为主体。'
- en: We have gradually shaped up the Blogpress application, and it is now equipped
    with Spring MVC, Thymeleaf, and Spring Security. All this rapid development is
    possible with the help of Spring Boot. The next part we are going to develop is
    a data layer, which is the most important and crucial part of our application.
    As we mentioned, we will construct the data layer in **Elasticsearch**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐渐完善了 Blogpress 应用程序，现在它已经配备了 Spring MVC、Thymeleaf 和 Spring Security。所有这些快速开发都是借助
    Spring Boot 实现的。接下来我们要开发的部分是一个数据层，这是我们应用中最重要和关键的部分。正如我们提到的，我们将使用 **Elasticsearch**
    构建数据层。
- en: Storing data with Elasticsearch
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elasticsearch 存储数据
- en: Elasticsearch is a highly scalable and full-text search open source RESTful
    searching, indexing, and analytics engine developed on top of **Lucene**. It is
    one of the most popular search engines for building enterprise applications today.
    It can save, search, and analyze data in big volumes very quickly. Mainly, it
    is used for applications where complex searching is required.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 是一个高度可扩展的全文搜索开源 RESTful 搜索、索引和分析引擎，它是在 **Lucene** 的基础上开发的。它是目前构建企业应用中最受欢迎的搜索引擎之一。它可以非常快速地保存、搜索和分析大量数据。主要，它用于需要复杂搜索的应用。
- en: It is developed in Java and provides near real-time results. It is designed
    to work in a distributed environment to provide high availability and scalability.
    It is document-oriented, stores complex entity structures in JSON format, and
    provides a web interface to interact with.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它是用 Java 开发的，提供近乎实时的结果。它设计用于在分布式环境中工作，以提供高可用性和可伸缩性。它是面向文档的，以 JSON 格式存储复杂的实体结构，并提供一个网络界面进行交互。
- en: Elasticsearch is mainly used in applications when searching for a large amount
    of matching products (for example, e-Commerce), using auto-complete features for
    partially typed input, or analyzing the huge quantities of raw data stored in
    a distributed fashion.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 主要用于在应用程序中搜索大量匹配产品（例如，电子商务）、使用自动完成功能进行部分输入或分析以分布式方式存储的大量原始数据。
- en: Artifacts
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 艺术品
- en: It is important to understand a few terminologies that are frequently used with
    Elasticsearch, which will help you to understand how Elasticsearch is built and
    how it works. They are the core of Elasticsearch. We will look at each of them
    in detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一些与 Elasticsearch 频繁使用的术语非常重要，这将帮助你了解 Elasticsearch 的构建方式和它的工作原理。它们是 Elasticsearch
    的核心。我们将详细查看每个术语。
- en: Documents
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: The basic unit of information that is stored in Elasticsearch is called a **document**.
    You can consider a document equivalent to an entity in the **relational database
    management system** (**RDBMS**). For example, a document can be created for an
    employee, another document is for a salary, and so forth. A document will be indexed
    by the Elasticsearch engine, and they are presented in JSON format. Each document
    is associated with the document type. You can relate a document type with a **Plain
    Old Java Object** (**POJO**) class while a document as an object of POJO class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Elasticsearch 中存储的基本信息单元被称为 **文档**。你可以将文档视为关系型数据库管理系统（**RDBMS**）中的一个实体。例如，可以为员工创建一个文档，另一个文档用于薪资，等等。文档将由
    Elasticsearch 引擎进行索引，并以 JSON 格式呈现。每个文档都与文档类型相关联。你可以将文档类型与 **Plain Old Java Object**（**POJO**）类相关联，而文档作为
    POJO 类的对象。
- en: Indexes
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: An index is a group of documents having a similar structure. You can define
    an **index** for employee data, another for salary data, and so on. An index can
    be identified by a name associated with it. An index name is used for indexing,
    searching along with CRUD operations for the documents it comprises. You can define
    as many indexes as you want. An index is always independent of another index.
    A group of indexes is referred to as indices in Elasticsearch.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '索引是一组具有相似结构的文档。你可以为员工数据定义一个 **索引**，另一个用于薪资数据，等等。索引可以通过与其关联的名称进行识别。索引名称用于索引、搜索以及包含文档的
    CRUD 操作。你可以定义尽可能多的索引。索引始终独立于其他索引。在 Elasticsearch 中，一组索引被称为 indices。 '
- en: Prior to version 6.0.0, Elasticsearch allowed the creation of multiple document
    types for a given index. For example, you can create document types for users
    and employees (or even more) for index organization. Starting with version 6,
    Elasticsearch put a restriction of allowing only one document type for a given
    index. So, you need to create a separate index for each of the document types.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 6.0.0 之前，Elasticsearch 允许为给定索引创建多个文档类型。例如，你可以为用户和员工（或更多）创建文档类型以进行索引组织。从版本
    6 开始，Elasticsearch 对给定索引只允许一个文档类型的创建。因此，你需要为每个文档类型创建一个单独的索引。
- en: Clusters and nodes
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群和节点
- en: Elasticsearch is a distributed system, means it can scale horizontally and runs
    on more than one server to handle a huge amount of data with optimal speed. The
    network of such servers is called a **cluster,** where as the single server is
    referred to as a node.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 是一个分布式系统，这意味着它可以水平扩展，并在多个服务器上运行以以最佳速度处理大量数据。这种服务器的网络被称为 **集群**，而单个服务器则被称为
    **节点**。
- en: Nodes and clusters are both identified by name. For nodes, Elasticsearch generates
    a default random **universally unique identifier** (**UUID**) on startup. If you
    wish, you can change the default name. The node name is important as it will help
    to administer the servers associated with the node name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 节点和集群都通过名称进行标识。对于节点，Elasticsearch 在启动时生成一个默认的随机 **全局唯一标识符**（**UUID**）。如果你愿意，你可以更改默认名称。节点名称很重要，因为它将有助于管理与节点名称关联的服务器。
- en: The cluster name is used by a node to join it. By default, all nodes are associated
    with the cluster with the `elasticsearch` name. You can create as many nodes as
    you want for a given cluster.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 节点使用集群名称来加入集群。默认情况下，所有节点都与名为 `elasticsearch` 的集群相关联。你可以为给定的集群创建尽可能多的节点。
- en: Shards and replicas
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片和副本
- en: Elasticsearch stores data in the form of documents, which are grouped into an
    index. In the case of a huge amount of data, the number of documents in a single
    index may cross the limit of the underlying hardware capacity. For example, more
    than a trillion documents stored in a single index may need up to **100 GB** of
    space, which it may not be possible to store in a single node.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch以文档的形式存储数据，这些文档被分组到一个索引中。在大量数据的情况下，单个索引中的文档数量可能会超过底层硬件容量的限制。例如，存储在单个索引中的超过万亿的文档可能需要高达**100
    GB**的空间，这可能无法在一个节点中存储。
- en: As a solution to this problem, Elasticsearch provides a mechanism to break the
    index into multiple pieces; each can be considered a separate index and can be
    stored in multiple nodes. The pieces of an index are called **shards**. This will
    also improve search performance as the search can be performed simultaneously
    on multiple shards.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决这个问题的一种方法，Elasticsearch提供了一个机制将索引分割成多个部分；每个部分都可以被视为一个单独的索引，并且可以存储在多个节点上。索引的部分被称为**分片**。这也会提高搜索性能，因为搜索可以在多个分片上同时进行。
- en: Replica, as its name suggest, is a copy of shards. They are created for fail
    over; in case one shard is down or goes offline, a replica will be used to provide
    service and make the system highly available.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 副本，正如其名所暗示的，是分片的副本。它们是为了故障转移而创建的；如果某个分片出现故障或离线，副本将被用来提供服务并使系统高度可用。
- en: In short, an index can be divided into multiple shards; each shard can have
    zero or more replicas. So each index has one primary shard, along with zero or
    more replica shards. By default, Elasticsearch associates five primary shards
    for each index along with one replica (as of the latest stable version 6.4.1).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个索引可以被分割成多个分片；每个分片可以有零个或多个副本。因此，每个索引都有一个主分片，以及零个或多个副本分片。默认情况下，Elasticsearch为每个索引关联五个主分片和一个副本（截至最新稳定版本6.4.1）。
- en: For our Blogpress application, we will keep the default values, a single node
    having an index with default shards and replica settings. The name of the index
    will be `blog`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Blogpress应用程序，我们将保持默认值，一个节点拥有默认分片和副本设置的索引。索引的名称将是`blog`。
- en: Interacting with Elasticsearch
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Elasticsearch交互
- en: Elasticsearch provides a way to interact with it for searching, indexing, and
    performing other CRUD operations. It provides a RESTful API for the interaction,
    so you can use various HTTP methods (`GET`, `POST`, `PUT`, `DELETE`, and so on)
    to deal with any operation on Elasticsearch.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch提供了一种用于搜索、索引和执行其他CRUD操作与之交互的方式。它提供了一个RESTful API用于交互，因此你可以使用各种HTTP方法（`GET`、`POST`、`PUT`、`DELETE`等）来处理对Elasticsearch的任何操作。
- en: Elasticsearch does not maintain the state of the request, and hence each request
    is independent, and information is exchanged in JSON format. Various HTTP methods
    are used to perform CRUD operations on Elasticsearch. For example, a `GET` method
    is used to retrieve the data, while `PUT`, `POST`, and `DELETE` are used to update
    or delete records.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch不维护请求的状态，因此每个请求都是独立的，信息以JSON格式交换。各种HTTP方法用于在Elasticsearch上执行CRUD操作。例如，使用`GET`方法检索数据，而`PUT`、`POST`和`DELETE`用于更新或删除记录。
- en: Since Elasticsearch exposes REST APIs, you can use any REST client (for example,
    **Postman**) to work with it. Furthermore, to analyze and visualize the data,
    Elasticsearch provides another free and open source tool called **Kibana**. It
    provides a simple browser-based interface to perform search, view, and other CRUD
    operations along with rich data analysis, presented in a variety of tables, charts,
    and map-like memory, as well as disk utilization, indices, and document information.
    It also helps to manage the indices and document types, perform CRUD operations
    for document data, and so on.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Elasticsearch公开了REST API，你可以使用任何REST客户端（例如，**Postman**）与之交互。此外，为了分析和可视化数据，Elasticsearch提供了一个名为**Kibana**的另一个免费开源工具。它提供了一个基于浏览器的简单界面来执行搜索、查看和其他CRUD操作，以及丰富的数据分析，以各种表格、图表和类似地图的内存形式呈现，以及磁盘利用率、索引和文档信息。它还帮助管理索引和文档类型，对文档数据进行CRUD操作等。
- en: Installation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: Let's first install Elasticsearch. Download the Elasticsearch ZIP bundle from
    [https://www.elastic.co/downloads](https://www.elastic.co/downloads). Unzip it
    in your local drive and run `bin/elasticsearch`. By default, it will be available
    on the `9200` port. Once up and running, you can access it with `http://localhost:9200`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装 Elasticsearch。从 [https://www.elastic.co/downloads](https://www.elastic.co/downloads)
    下载 Elasticsearch ZIP 套件。将其解压缩到您的本地驱动器中，并运行 `bin/elasticsearch`。默认情况下，它将在 `9200`
    端口上可用。一旦启动并运行，您就可以通过 `http://localhost:9200` 访问它。
- en: You can download and install Kibana from the same [https://www.elastic.co/downloads](https://www.elastic.co/downloads)
    URL. Unzip the bundle and run `bin/kibana`. You can access Kibana on the `5601`
    port, that is, `http://localhost:5601`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从相同的 [https://www.elastic.co/downloads](https://www.elastic.co/downloads)
    URL 下载并安装 Kibana。解压缩套件并运行 `bin/kibana`。您可以在 `5601` 端口上访问 Kibana，即 `http://localhost:5601`。
- en: Elasticsearch also provides MSI Installer for Windows, which is a straightforward
    way to install Elasticsearch on a Windows machine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 还为 Windows 提供了 MSI 安装程序，这是在 Windows 机器上安装 Elasticsearch 的简单方法。
- en: Elasticsearch RESTful API
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch RESTful API
- en: Next, we quickly look at some of the APIs to perform various activities on Elasticsearch.
    Since Elasticsearch provides REST interface to interact with, you can use any
    REST client, such as Postman. Alternatively, you can use **Kibana** Dev Tools
    to execute REST calls. There is a small difference between them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们快速查看一些用于在 Elasticsearch 上执行各种活动的 API。由于 Elasticsearch 提供了用于交互的 REST 接口，因此您可以使用任何
    REST 客户端，例如 Postman。或者，您可以使用 **Kibana** Dev Tools 执行 REST 调用。它们之间有一些小的区别。
- en: We will understand various RESTful API by taking an example of a `student` entity.
    The purpose is to explain how to create a `students` index; create the `student`
    document type; add, update, and delete `student` data; and delete the document
    type and index.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个 `student` 实体的例子来了解各种 RESTful API。目的是解释如何创建 `students` 索引；创建 `student`
    文档类型；添加、更新和删除 `student` 数据；以及删除文档类型和索引。
- en: Creating an index – students
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建索引 – students
- en: 'With your REST client (Postman), enter the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的 REST 客户端（Postman），输入以下内容：
- en: '**URL**: `http://localhost:9200/students`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students`'
- en: '**Method**: PUT'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：PUT'
- en: '**Type**: JSON (application/json)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：JSON（application/json）'
- en: 'Body:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With Kibana, go to the Dev Tools option in Kibana and type the following script:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，转到 Kibana 中的 Dev Tools 选项并输入以下脚本：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will see the following output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/6d85e406-033f-47e0-bc85-e9021ded34a2.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d85e406-033f-47e0-bc85-e9021ded34a2.png)'
- en: 'We have created a `student` index without any explicit settings, so Elasticsearch
    has created the index with default settings—five shards and one replica. You can
    see these details in Kibana from the Management option. In case you wish to give
    the precise number of shards and replicas (instead of the default five and one),
    you can add the JSON setting in the body while creating the `student` index as
    follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个没有明确设置的 `student` 索引，因此 Elasticsearch 使用默认设置创建了索引——五个分片和一个副本。您可以在 Kibana
    的管理选项中看到这些详细信息。如果您希望给出精确的分片和副本数量（而不是默认的五个和一个），您可以在创建 `student` 索引时在主体中添加 JSON
    设置，如下所示：
- en: 'With REST client (Postman), enter the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），输入以下内容：
- en: '**URL**: `http://localhost:9200/students`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students`'
- en: '**Method**: PUT'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：PUT'
- en: '**Type**: JSON (application/json)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：JSON（application/json）'
- en: 'Body:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With Kibana, go to Dev Tools and type the following script:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，转到 Dev Tools 并输入以下脚本：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous case, the index is created with three shards and two replicas.
    This is how you can specify particular settings while creating an index in Elasticsearch.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，索引是通过三个分片和两个副本创建的。这就是在 Elasticsearch 中创建索引时指定特定设置的方法。
- en: Creating a document type – student
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档类型 – 学生
- en: The very next thing in the sequence after creating an index is the creation
    of the document type. We will create a document type named `student` within the
    `students` index. Again, it can be done with REST client or with Kibana. We will
    see both options in detail.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建索引之后，序列中的下一个操作是创建文档类型。我们将在 `students` 索引内创建一个名为 `student` 的文档类型。同样，这可以通过
    REST 客户端或 Kibana 完成。我们将详细查看这两种选项。
- en: With REST client (Postman), enter the following**:**
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），输入以下内容**：**
- en: '**URL**: `http://localhost:9200/students/_mapping/student`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students/_mapping/student`'
- en: '**Method**: POST'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：POST'
- en: '**Type**: JSON (application/json)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：JSON（application/json）'
- en: 'Body:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With Kibana, go to Dev Tools option and add the following script:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，转到 Dev Tools 选项并添加以下脚本：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can use either of these options to create the document type. We have created
    the `student` document type with ID, name, standard, division, and gender properties
    within the `students` index*.* Our structure is ready to add the data into Elasticsearch.
    Next, we will see how to insert the data for `student` type that we have defined.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这两种选项中的任何一种来创建文档类型。我们在 `students` 索引中创建了具有 ID、姓名、标准、班级和性别属性的 `student`
    文档类型*.* 我们的结构已准备好将数据添加到 Elasticsearch。接下来，我们将看到如何插入我们定义的 `student` 类型的数据。
- en: Prior to version 6, Elasticsearch allows creating multiple document types in
    the same index. Starting with 6, they make a restriction of creating only one
    document type within that index.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 6 之前，Elasticsearch 允许在同一个索引中创建多个文档类型。从 6 版本开始，它们对创建文档类型做了限制，即在该索引中只能创建一个文档类型。
- en: Adding a document (student data)
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文档（学生数据）
- en: 'With REST client (Postman), enter the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），输入以下内容：
- en: '**URL**: `http://localhost:9200/students/student/1`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students/student/1`'
- en: '**Method**: PUT'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：PUT'
- en: '**Type**: JSON (application/json)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：JSON (application/json)'
- en: 'Body:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With Kibana, go to the Dev Tools option and type the following script:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，进入 Dev Tools 选项并输入以下脚本：
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can verify the inserted data with the following REST API.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 REST API 验证插入的数据。
- en: Reading a document (student data)
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文档（学生数据）
- en: With REST client, enter the following**:**
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端，输入以下内容**：
- en: '**URL**: `http://localhost:9200/students/student/1`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students/student/1`'
- en: '**Method**: GET'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：GET'
- en: 'With Kibana, enter the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，输入以下内容：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get the following JSON as an output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下 JSON 作为输出：
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, it shows the index and document type. The `_id` attribute represents
    the ID that we supplied in the `http:/localhost:9200/students/student/1` URL while
    creating the data. If you use any existing `_id`, Elasticsearch will simply update
    that record with current values. The `_version` attribute represents the number
    of times the records are updated. The `_source` attribute represents the data
    that we supplied.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它显示了索引和文档类型。`_id` 属性代表我们在创建数据时在 `http:/localhost:9200/students/student/1`
    URL 中提供的 ID。如果您使用任何现有的 `_id`，Elasticsearch 将简单地使用当前值更新该记录。`_version` 属性代表记录被更新的次数。`_source`
    属性代表我们提供的数据。
- en: Updating a document (student data)
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档（学生数据）
- en: To update the data, the same syntax is used as an add document. While adding,
    the ID is not present in the system, if present, the existing data will be updated
    with the value provided. For example, the following command will update existing
    students' record having `_id` equal to five.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新数据，使用的语法与添加文档相同。在添加时，如果系统中不存在 ID，则 Elasticsearch 将为您自动生成一个。例如，以下命令将更新具有 `_id`
    等于五的现有学生记录。
- en: With a REST client (Postman), use the following**:**
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），使用以下内容**：
- en: '**URL**: `http://localhost:9200/students/student/5`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students/student/5`'
- en: '**Method**: POST'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：POST'
- en: '**Type**: JSON (application/json)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：JSON (application/json)'
- en: 'Body:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With Kibana, go to the Dev Tools and execute the following query:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，进入 Dev Tools 并执行以下查询：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inserting and updating operations use similar syntax and if you try to add the
    record with an ID that already exists, then that record will be updated by mistake.
    To avoid this, you can use the `localhost:9200/students/student/1/_create` URL.
    This will throw an error if a record already exists with a `1` ID. Similarly,
    you can use `localhost:9200/students/student/1/_update` in case you wish to update
    the record. It will throw an error if a record does not exist while updating it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和更新操作使用类似的语法，如果您尝试添加具有已存在 ID 的记录，那么该记录可能会错误地被更新。为了避免这种情况，您可以使用 `localhost:9200/students/student/1/_create`
    URL。如果存在具有 `1` ID 的记录，这将引发错误。同样，如果您希望更新记录，可以使用 `localhost:9200/students/student/1/_update`。在更新记录时，如果记录不存在，它将引发错误。
- en: While adding the document record, if you do not provide `_id`, Elasticsearch
    will auto-generate one for you.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加文档记录时，如果您不提供 `_id`，Elasticsearch 将为您自动生成一个。
- en: Deleting a document (student data)
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档（学生数据）
- en: Deleting the document is straightforward. You need to use the HTTP `DELETE`
    method. Just specify `_id` of the document you wish to delete, as follows.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档很简单。您需要使用 HTTP `DELETE` 方法。只需指定要删除的文档的 `_id`，如下所示。
- en: 'With a REST client (Postman), do the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），执行以下操作：
- en: '**URL**: `http://localhost:9200/students/student/1`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：`http://localhost:9200/students/student/1`'
- en: '**Method**: DELETE'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：DELETE'
- en: 'With Kibana, use the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，使用以下内容：
- en: '[PRE32]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Searching a query
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索查询
- en: Elasticsearch provides a search facility by passing `/_search` at the end of
    the URL. It can be applied after the server URL, the index, or the type. For example,
    in our case, if we want to search a student document having name equals to `nilang`,
    we have to use the query as follows.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 通过在 URL 末尾传递 `/_search` 提供搜索功能。它可以在服务器 URL、索引或类型之后应用。例如，在我们的案例中，如果我们想搜索名为
    `nilang` 的学生文档，我们必须使用以下查询。
- en: 'With a REST client (Postman), use the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 客户端（Postman），使用以下方法：
- en: '**URL**: `http://localhost:9200/students/student/_search?q=name:nilang`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**: `http://localhost:9200/students/student/_search?q=name:nilang`'
- en: '**Method**: GET'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**: GET'
- en: With Kibana, use**:**
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kibana，使用**:**
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can use the following syntax for searching. It is quite
    useful for a complex search with multiple search criteria for multiple fields:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下语法进行搜索。这对于具有多个搜索标准的多字段复杂搜索非常有用：
- en: '[PRE34]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating index and document types for Blogpress
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Blogpress 创建索引和文档类型
- en: After getting the basics of how the index and document type are created, along
    with inserting document data in Elasticsearch, we will create these artifacts
    for a Blogpress application. In this application, we need to store the data for
    blogs and comments. The blog and comments have a one- to-many relationship (one
    blog has multiple comments), we will create an index structure in such a way that
    multiple comments will be associated with a single blog.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握如何创建索引和文档类型，以及如何在 Elasticsearch 中插入文档数据的基本知识后，我们将为 Blogpress 应用程序创建这些工件。在这个应用程序中，我们需要存储博客和评论的数据。博客和评论之间存在一对一的关系（一个博客有多个评论），我们将创建一个索引结构，以便多个评论与单个博客相关联。
- en: 'Elasticsearch provides nested data types to index arrays of objects and maintains
    them as an independent document. We will maintain an array of comments for a single
    blog. We will give the index name of `blog` and set the document type, to `blog`.
    The following is a script you can run to create a `blog` index:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 提供嵌套数据类型来索引对象数组，并将它们作为独立文档维护。我们将为单个博客维护一个评论数组。我们将给索引命名为 `blog`
    并设置文档类型为 `blog`。以下是一个可以运行的脚本，用于创建 `blog` 索引：
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous script, we created an index and document type together. The
    element next to `mappings` represents the name of the document type while the
    index name is with the `PUT` HTTP method (`blog` in our case). All properties
    are self-explanatory apart from the comments that are defined as the `nested`
    type, along with their properties. The format of the date can be set with a `format`
    attribute.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们同时创建了索引和文档类型。`mappings` 旁边的元素表示文档类型的名称，而索引名称与 `PUT` HTTP 方法（在我们的案例中为
    `blog`）一起使用。所有属性都是自解释的，除了定义为一个 `nested` 类型及其属性的评论。日期的格式可以通过 `format` 属性设置。
- en: Elasticsearch integration with Spring Data
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch 与 Spring Data 集成
- en: We will configure Elasticsearch as a database to provide various CRUD operations
    for Blogpress applications. We will use Spring Data for this integration. Spring
    Data provides an abstract layer for data access from various providers, such as
    a relational database, a non-relational database, a map-reduced framework, and
    cloud services.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置 Elasticsearch 作为数据库，为 Blogpress 应用程序提供各种 CRUD 操作。我们将使用 Spring Data 进行此集成。Spring
    Data 为从各种提供者（如关系数据库、非关系数据库、Map-Reduce 框架和云服务）进行数据访问提供了一个抽象层。
- en: For each of these data providers, Spring supplies a set of libraries to interact
    with, while maintaining the abstraction to interact with them in a symmetrical
    manner. Spring Data spans across various modules, including Spring Data Common,
    Spring Data JPA, Spring Data REST, Spring Data LDAP, Spring Data MongoDB, Spring
    Data JDBC, and many more. Spring Data Elasticsearch is one of them t provide data
    access with Elasticsearch search engines.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些数据提供者中的每一个，Spring 都提供了一套库来与之交互，同时保持以对称方式与之交互的抽象。Spring Data 涵盖了多个模块，包括 Spring
    Data Common、Spring Data JPA、Spring Data REST、Spring Data LDAP、Spring Data MongoDB、Spring
    Data JDBC 以及更多。Spring Data Elasticsearch 是其中之一，提供与 Elasticsearch 搜索引擎的数据访问。
- en: 'We will use the Spring Data Elasticsearch module for the Blogpress application.
    The very first thing is to make this module available in our application. Unsurprisingly,
    this can be done by defining a starter in `pom.xml` as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Blogpress 应用程序使用 Spring Data Elasticsearch 模块。首先要做的是使此模块在我们的应用程序中可用。不出所料，这可以通过在
    `pom.xml` 中定义一个启动器来完成，如下所示：
- en: '[PRE36]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Elasticsearch provides a Java API to interact with it programmatically. Soon
    after you activate the above starter, the required JARs will be added in the classpath
    to access the Elasticsearch Java API. At this moment, we need to instruct the
    Spring Data Elasticsearch module about the cluster name, port, and hostname on
    which the Elasticsearch server is running. You can define these configurations
    in the `application.properties` file (in the `src/main/resource` folder) as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch提供了一个Java API，可以以编程方式与之交互。在激活上述启动器后不久，所需的JAR文件将被添加到类路径中，以便访问Elasticsearch
    Java API。此时，我们需要指导Spring Data Elasticsearch模块关于Elasticsearch服务器正在运行的集群名称、端口和主机名。您可以在`application.properties`文件中（位于`src/main/resource`文件夹中）定义以下配置：
- en: '[PRE37]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is equivalent to defining a database URL, the driver class name, and credentials
    for database interaction with Spring Data. The next step is to define a configuration
    class, which basically uses the previous details and prepares the required artifacts
    to interact with Elasticsearch, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这与定义数据库URL、驱动类名称和数据库交互凭据的Spring Data相当。下一步是定义一个配置类，它基本上使用之前的信息并准备与Elasticsearch交互所需的工件，如下所示：
- en: '[PRE38]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This class reads the cluster name, port, and host values defined in the `application.properties`
    file with the `@Value` annotation. The `client()` method uses the `TransactionClientFactory`
    object to read the configuration data and return an object of the `TransportClient`
    class, which represents the client interface to interact with Elasticsearch.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用`@Value`注解读取在`application.properties`文件中定义的集群名称、端口和主机值。`client()`方法使用`TransactionClientFactory`对象读取配置数据，并返回一个`TransportClient`类的对象，该对象代表与Elasticsearch交互的客户端接口。
- en: The next `elasticsearchTemplate()` method uses this client object and creates
    the `ElasticsearchTemplate` object. Spring provides the data access template class
    for each of the data providers. The object of the `ElasticsearchTemplate` class
    is initialized with the object of the `TransportClient` class. This method is
    defined with the `@Bean` annotation so that the object of `ElasticsearchTemplate`
    is accessible with the `@Autowired` annotation to other classes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`elasticsearchTemplate()`方法使用此客户端对象并创建`ElasticsearchTemplate`对象。Spring为每个数据提供者提供了数据访问模板类。`ElasticsearchTemplate`类的对象使用`TransportClient`类的对象初始化。此方法使用`@Bean`注解定义，以便可以通过`@Autowired`注解在其他类中访问`ElasticsearchTemplate`对象。
- en: This initialization happens when starting an application. The `ElasticsearchTemplate`
    class is the single point of interaction of the Elasticsearch engine with Spring
    Data. The `@EnableElasticsearchRepositories` annotation in this class is used
    to point the Spring JPA repository package that we are going to define next. Before
    that, we will first define a model class that represents a document in Elasticsearch.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化发生在启动应用程序时。`ElasticsearchTemplate`类是Elasticsearch引擎与Spring Data交互的单一点。此类中的`@EnableElasticsearchRepositories`注解用于指向我们接下来要定义的Spring
    JPA仓库包。在此之前，我们首先定义一个表示Elasticsearch中文档的模型类。
- en: Spring Data Elasticsearch model class
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data Elasticsearch模型类
- en: Spring Data facilitate the **Data Access Object** (**DAO**) layer implementation
    for the various data providers. The DAO mechanism makes the system loosely coupled
    by providing data access abstraction, allowing the changes in the underlying data
    provider without affecting the business implementation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data简化了各种数据提供者的**数据访问对象（DAO**）层实现。DAO机制通过提供数据访问抽象，使系统松散耦合，允许在不影响业务实现的情况下更改底层数据提供者。
- en: 'It allows the interaction with the data layer in an object-oriented manner.
    It means you can create, read, update, and delete the data with an entity class
    object. This abstraction is also applicable for the Spring Data Elasticsearch
    module. You can access the data in the form of objects. For this, we need to define
    a model (entity) class that represents the data structure that we defined in Elasticsearch
    as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许以面向对象的方式与数据层进行交互。这意味着您可以使用实体类对象创建、读取、更新和删除数据。这种抽象也适用于Spring Data Elasticsearch模块。您可以用对象的形式访问数据。为此，我们需要定义一个模型（实体）类，它代表我们在Elasticsearch中定义的数据结构，如下所示：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The model class is a POJO with a `@Document` annotation, which defines the index
    and document type name this class is associated with. The objects of the `Blog`
    class previously represent the document data for the `blog` index and the `blog`
    document in Elasticsearch. The `@Id` annotation is used to define a unique id
    for blog documents. You can relate it to the primary key in the relational database.
    The date fields are defined with the `@JsonFormat` annotation, which is used to
    define the desired date format.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类是一个带有`@Document`注解的POJO，它定义了该类关联的索引和文档类型名称。`Blog`类的对象之前代表Elasticsearch中`blog`索引和`blog`文档的文档数据。`@Id`注解用于为博客文档定义一个唯一的ID。你可以将其与关系型数据库中的主键相关联。日期字段使用`@JsonFormat`注解定义，该注解用于定义所需的日期格式。
- en: The `@Field` annotation is used to define additional metadata about the field.
    For example, in the case of comments, it is defined as a `nested` type as there
    is no direct mapping of Elasticsearch `nested` types available in Java. For other
    properties, the Java types are directly mapped with Elasticsearch types. Next,
    we will define a DAO layer with Spring Data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Field`注解用于定义字段的额外元数据。例如，在评论的情况下，它被定义为`nested`类型，因为在Java中没有直接映射Elasticsearch
    `nested`类型的可用。对于其他属性，Java类型直接映射到Elasticsearch类型。接下来，我们将使用Spring Data定义一个DAO层。'
- en: The date format that we mentioned in the mapping script should be exactly matched
    with the date format defined in the POJO class with the `@JsonFormat` annotation.
    If not, the system will show an error while inserting the record.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射脚本中提到的日期格式应该与POJO类中用`@JsonFormat`注解定义的日期格式完全匹配。如果不匹配，系统在插入记录时会显示错误。
- en: Connecting Elasticsearch with Spring Data
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Elasticsearch与Spring Data连接
- en: Spring Data has a concept called a **repository** that is an abstraction of
    a data store. Designed to add an additional layer, it brings great power and flexibility
    by making the repository abstraction and providing the concrete implementation
    of repositories (with all boilerplate code) for each of the data providers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data有一个称为**仓库**的概念，它是数据存储的抽象。设计用来添加一个额外的层，通过提供仓库抽象和为每个数据提供者提供具体的仓库实现（包含所有样板代码），它带来了巨大的力量和灵活性。
- en: For Elasticsearch, Spring Data provides a repository interface called `ElasticsearchRepository`.
    This interface (and its parent interface) has all the required methods to interact
    with Elasticsearch. To reap the benefits of Spring Data, we need to extend this
    interface so that Spring Data supplies concrete implementation on the fly automatically.
    Apparently, all the required CRUD methods are available in standard DAO out of
    the box.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Elasticsearch，Spring Data提供了一个名为`ElasticsearchRepository`的仓库接口。此接口（及其父接口）具有与Elasticsearch交互所需的所有必需方法。为了获得Spring
    Data的好处，我们需要扩展此接口，以便Spring Data可以自动提供具体的实现。显然，所有必需的CRUD方法都包含在标准的DAO中。
- en: 'Let''s leverage Spring Data capabilities for Elasticsearch for the Blogpress
    application. First, let''s define the custom repository interface that extends
    `ElasticsearchRepository<T, ID extends Serializable>`, where `T` represents an
    entity class and `ID` represents a unique ID in the entity class as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用Spring Data为Blogpress应用程序提供Elasticsearch的能力。首先，让我们定义一个自定义的仓库接口，该接口扩展了`ElasticsearchRepository<T,
    ID extends Serializable>`，其中`T`代表实体类，`ID`代表实体类中的唯一ID，如下所示：
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Blog` entity class has `_Id` (a string) as a unique identifier (declared
    with the `@Id` annotation). Our DAO layer with all basic CRUD operations is ready.
    It is always a good idea to define the service class, presenting the service layer.
    So we will declare the `BlogService` service class as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blog`实体类有一个`_Id`（一个字符串）作为唯一标识符（使用`@Id`注解声明）。我们的DAO层已经准备好了所有基本的CRUD操作。始终定义服务类，展示服务层是一个好主意。因此，我们将声明`BlogService`服务类如下：'
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With the `@Autowired` annotation, Spring will inject the object of `BlogRepository`
    into our service class, which can be used to perform various CRUD operations.
    Next, we can start performing CRUD operations for blog data in Elasticsearch.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Autowired`注解，Spring会将`BlogRepository`对象注入到我们的服务类中，该对象可以用来执行各种CRUD操作。接下来，我们可以开始对Elasticsearch中的博客数据进行CRUD操作。
- en: CRUD operations in Elasticsearch with Spring Data
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data在Elasticsearch中执行CRUD操作
- en: The basic structure of DAO and the service layer is ready. We can now start
    performing CRUD operations. As we have seen, just by declaring a custom repository
    interface, Spring provides all basic CRUD operations in the DAO layer.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: DAO和服务层的基本结构已准备就绪。我们现在可以开始执行CRUD操作。正如我们所见，只需声明一个自定义仓库接口，Spring就在DAO层提供了所有基本的CRUD操作。
- en: Adding blog data
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加博客数据
- en: 'First, we will create a new blog record. For that, add method in `BlogService`
    class as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的博客记录。为此，在`BlogService`类中添加以下方法：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The object of `BlogRepository` is injected by Spring and can be used to perform
    an add operation. This service method should be called from Spring controller.
    Add the following methods in controller class to manage the functionality of adding
    (or updating) new blog:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlogRepository`对象由Spring注入，可用于执行添加操作。这个服务方法应该从Spring控制器中调用。在控制器类中添加以下方法来管理添加（或更新）新博客的功能：'
- en: '[PRE43]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `showAddNew()` method simply opens the `add-new.html` Thymeleaf template.When
    a user clicks on the Add New link from navigation, this method will be called
    and will show this template where the user can add a new blog with a title and
    body.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`showAddNew()`方法简单地打开`add-new.html` Thymeleaf模板。当用户点击导航中的“添加新内容”链接时，此方法将被调用，并显示此模板，用户可以在其中添加带有标题和正文的新的博客。'
- en: 'The second method—`addNew`, which is declared with the `@PostMapping` annotation
    takes a `title` and `body` as request parameters, creates an object of a `Blog`
    type, sets those values and call the `addNewBlog()` method of service class. You
    can execute the following query in Kibana to see the inserted data in Elasticsearch:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法——`addNew`，使用`@PostMapping`注解声明，它接受`title`和`body`作为请求参数，创建一个`Blog`类型的对象，设置这些值并调用服务类的`addNewBlog()`方法。你可以在Kibana中执行以下查询来查看插入到Elasticsearch中的数据：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Reading blog data
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取博客数据
- en: 'Next is to show the blog entries on the home page in a tabular format. When
    a user clicks on it, the system will open the blog in am detailed view (showing
    the title, full body, and all comments). To list blogs on the home page, we will
    fetch the blog data from Elasticsearch programmatically. Add the following method
    in the `BlogService` class:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是在主页上以表格格式显示博客条目。当用户点击它时，系统将打开博客的详细视图（显示标题、全文和所有评论）。为了在主页上列出博客，我们将以编程方式从Elasticsearch获取博客数据。在`BlogService`类中添加以下方法：
- en: '[PRE45]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `getAllBlogs()` method simply calls the `findAll()` method on `blogRepository`
    to get all blog entries. This service method can be called from the controller
    to show these data on the home page. Instead of a regular controller, we will
    use the REST controller to showcase how we can leverage the Spring REST controller
    to present the data. We will cover this in a short while, so keep reading.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAllBlogs()`方法简单地调用`blogRepository`上的`findAll()`方法来获取所有博客条目。这个服务方法可以从控制器中调用，以在主页上显示这些数据。我们将使用REST控制器来展示如何利用Spring
    REST控制器来展示数据。我们将在稍后介绍，所以请继续阅读。'
- en: It is always advisable to use the repository method with pagination. Since the
    purpose of this chapter is to showcase various components and how they work, I
    have not used the pagination to make things simple.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 总是建议使用带有分页的仓库方法。由于本章的目的是展示各种组件及其工作方式，我没有使用分页来简化内容。
- en: Searching blog data
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索博客数据
- en: Since this is a blog application, search is an obvious feature. We will allow
    a user to search the blogs by matching the search text with blog title and body.
    We can search the documents by passing `/_search` at the end of the URL. Elasticsearch
    provides a Boolean query to search the data based on various conditions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个博客应用程序，搜索是一个明显的功能。我们将允许用户通过匹配搜索文本与博客标题和正文来搜索博客。我们可以通过在URL末尾传递`/_search`来搜索文档。Elasticsearch提供布尔查询，可以根据各种条件搜索数据。
- en: 'In our case, the search text should be matched with either title or body or
    both. It can be achieved through a Boolean search query as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，搜索文本应该与标题或正文或两者匹配。这可以通过以下布尔搜索查询实现：
- en: '[PRE46]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `should` criteria is equivalent to the *OR* condition. Elasticsearch provides
    the `must` criteria, in case if you want to search with the *AND* condition. You
    can specify as many attributes as you want. The string `java` is the search text.
    This query can be written programmatically in Java as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`should`条件等同于*OR*条件。Elasticsearch提供了`must`条件，如果你想要使用*AND*条件进行搜索。你可以指定任意多的属性。字符串`java`是搜索文本。这个查询可以用以下方式在Java中编程实现：'
- en: '[PRE47]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are creating a Boolean query and configure the search text with the title
    and body attribute. The search result will be returned back in JSON format with
    the `response` object. You can parse the JSON to get the desired output.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个布尔查询，并配置搜索文本为标题和正文属性。搜索结果将以 JSON 格式返回，包含 `response` 对象。您可以解析 JSON 以获取所需输出。
- en: Adding comment data with Elasticsearch aggregation
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elasticsearch 聚合添加评论数据
- en: 'The blog has been added to the system. Now a user can add a comment. So next,
    we will see how to add a comment. As discussed, the `Comment` document type is
    defined as a `nested` type in the blog document. It means the blog document contains
    an array of comment objects, making a one-to-many relationship. We also need to
    create a comment model class as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 博客已被添加到系统中。现在用户可以添加评论。接下来，我们将看到如何添加评论。正如讨论的那样，`Comment` 文档类型被定义为博客文档中的一个 `nested`
    类型。这意味着博客文档包含一个评论对象的数组，形成一个一对多的关系。我们还需要创建一个如下所示的评论模型类：
- en: '[PRE48]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since this is nested within a blog, there is no need to define the `@Document`
    annotation as it is not directly associated with any document type. While adding
    the comment, there is certain metadata that needs to be taken care of, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个操作是在博客内部嵌套的，因此不需要定义 `@Document` 注解，因为它并不直接与任何文档类型相关联。在添加评论时，需要关注以下某些元数据：
- en: We are providing the comment with reply functionality. Once a user does reply
    to any comment, it will be added one level down, considering it as child comment.
    To maintain this, we use the `level` attribute, which simply shows at which level
    this comment is placed.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供了具有回复功能的评论。一旦用户对任何评论进行回复，它将被添加到下一级，将其视为子评论。为了维护这一点，我们使用 `level` 属性，它简单地显示了评论放置的级别。
- en: The `blogId` attribute simply holds the ID of a blog with which this comment
    is associated. Since this is a nested object, in most of the cases, it is not
    required to have a parent document ID. But we are going to show the comment list
    to an admin user to moderate and reply back. To make comment administration simple,
    we have just added `blogId` in the comment.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogId` 属性简单地持有与该评论关联的博客的 ID。由于这是一个嵌套对象，在大多数情况下，不需要父文档 ID。但我们将向管理员用户展示评论列表以进行审核和回复。为了使评论管理简单，我们只是在评论中添加了
    `blogId`。'
- en: The `parentId` attribute holds the ID of parent comment, if it is placed as
    a reply, or else it will be zero.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parentId` 属性持有父评论的 ID，如果它被放置为回复，否则它将为零。'
- en: The `childSequence` attribute simply shows the sequence number at a particular
    level. For example, if there are total two replies (at the second level) and a
    user tries to add a third reply (at the second level), then the `childSequence`
    attribute will be three. This attribute is used to construct a value of the `position`
    attribute.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`childSequence` 属性简单地显示了特定级别的序列号。例如，如果有总共两个回复（在第二级），并且用户尝试添加第三个回复（在第二级），那么
    `childSequence` 属性将为三。此属性用于构建 `position` 属性的值。'
- en: The `position` attribute will be combination of `level` and `childSequence`.
    This is used to sort the comments so that they are displayed in the correct order
    for a given blog.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position` 属性将是 `level` 和 `childSequence` 的组合。这用于对评论进行排序，以便它们以正确的顺序显示在给定的博客中。'
- en: 'Since a comment is a `nested` type of blog, there is no such method to save
    only comments. Instead, we need to fetch all comments, add the new one to the
    associated blog, and then save the whole blog. Everything is straightforward,
    except getting the value of `childSequence`. We will see how to get maximum `childSequence`
    in a given level with the following aggregate query:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 由于评论是博客的 `nested` 类型，没有这样的方法可以单独保存评论。相反，我们需要获取所有评论，将新的评论添加到相关的博客中，然后保存整个博客。一切都很直接，除了获取
    `childSequence` 的值。我们将通过以下聚合查询看到如何获取给定级别的最大 `childSequence`：
- en: '[PRE49]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Before we can understand the query, we need to look at what aggregation is.
    In Elasticsearch, an aggregation is a mechanism used to provide aggregated data
    on a search query. They are used to compose complex queries. They come under four
    categories, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解查询之前，我们需要看看什么是聚合。在 Elasticsearch 中，聚合是一种用于在搜索查询上提供聚合数据的机制。它们用于构建复杂查询。它们分为以下四个类别：
- en: Bucketing
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分桶
- en: Metric
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标
- en: Matrix
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: Pipeline
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Each of these aggregation types can be used in a nested fashion, meaning it
    can be used as a sub-aggregation to another, to solve very complex queries. Now,
    let's go back to the query to find `childSequence` and understand it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这些聚合类型都可以以嵌套的方式使用，这意味着它可以作为另一个聚合的子聚合来使用，以解决非常复杂的查询。现在，让我们回到查找 `childSequence`
    的查询，并理解它。
- en: The very first `query` criteria matches the value against `blogId` (`_id`).
    Any attribute given to the `query` criteria in the beginning will match its value
    against the `blog` attribute. The next is the aggregate query that is applied
    to the `nested` document—`comments`. Each aggregate query has a name. The first
    aggregate query has the `aggChild` name.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 首个 `query` 标准与 `blogId` (`_id`) 的值匹配。在 `query` 标准开始时给出的任何属性都将与 `blog` 属性的值匹配。接下来是应用于
    `nested` 文档的聚合查询——`comments`。每个聚合查询都有一个名称。第一个聚合查询的名称是 `aggChild`。
- en: 'Going further, the next aggregate query with the `filterParentId` name simply
    matches `parentId`, which is nothing but the parent comment ID. It is required
    to find `childSequence` under given a comment as a parent comment. For top-level
    comments, this must be zero. The last aggregate query with the `maxChildSeq` name
    simply finds the maximum of `childSequence`. It uses maximum criteria. Each `nested`
    aggregate query simply applies the search criteria to results given by the preceding
    aggregate query. You will get results of this query similar to the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，名为 `filterParentId` 的下一个聚合查询简单地匹配 `parentId`，这实际上就是父评论的 ID。这是为了在给定的评论作为父评论的情况下找到
    `childSequence`。对于顶级评论，这个值必须是零。最后一个名为 `maxChildSeq` 的聚合查询简单地找到 `childSequence`
    的最大值。它使用最大标准。每个 `nested` 聚合查询简单地应用前一个聚合查询给出的搜索标准。你将得到类似于以下查询的结果：
- en: '[PRE50]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The query result contains other information, but we will only focus on `aggregation`.
    The result shows a document count at each aggregate query. The value of `maxChildSeq`
    is three means there are three comments at level one (top-level comment), so when
    a user adds a new (top-level) comment, `childSequnce` will be four.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果包含其他信息，但我们只关注 `aggregation`。结果显示了每个聚合查询的文档计数。`maxChildSeq` 的值为三意味着在一级（顶级评论）有三个评论，所以当用户添加一个新的（顶级）评论时，`childSequence`
    将是四。
- en: This was the REST-based query. For the Blogpress application, we need to execute
    similar queries in the Java class. Elasticsearch provides Java APIs to perform
    anything that can be done through REST query. When we define a starter for Elasticsearch
    in Spring Boot, the required Elasticsearch JAR files are available in the classpath.
    To write the preceding query with Java APIs, we need to write a custom fetch method
    in our Elasticsearch repository.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于 REST 的查询。对于 Blogpress 应用程序，我们需要在 Java 类中执行类似的查询。Elasticsearch 提供了 Java
    API 来执行通过 REST 查询可以执行的所有操作。当我们定义 Spring Boot 中的 Elasticsearch 启动器时，所需的 Elasticsearch
    JAR 文件都位于类路径中。为了使用 Java API 编写前面的查询，我们需要在我们的 Elasticsearch 存储库中编写一个自定义的获取方法。
- en: Spring Data is an extensible framework, allowing us to provide customized implementation
    of a repository on top of what it provides out of the box. So first we will extend
    the Elasticsearch repository with following steps.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 是一个可扩展的框架，允许我们在它提供的开箱即用的存储库之上提供自定义实现。因此，我们首先将以下步骤扩展到 Elasticsearch
    存储库。
- en: Define a custom repository interface called `BlogRepositoryCustom`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `BlogRepositoryCustom` 的自定义存储库接口。
- en: 'The `BlogRepository` interface that we created initially should extend this
    interface, along with `ElasticsearchRepository<Blog, String>`, as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最初创建的 `BlogRepository` 接口应该扩展此接口，以及 `ElasticsearchRepository<Blog, String>`，如下所示：
- en: '[PRE51]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define the custom repository implementation class that implements the `BlogRepositoryCustom`
    interface as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个实现 `BlogRepositoryCustom` 接口的自定义存储库实现类，如下所示：
- en: '[PRE52]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This class must be declared with the `@Repository` annotation. We can define
    any custom method in this class. We want to write a method with an Elasticsearch
    Java API to find the maximum child sequence at a given level, so we will write
    it in this class as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此类必须使用 `@Repository` 注解声明。我们可以在此类中定义任何自定义方法。我们想要编写一个使用 Elasticsearch Java API
    来查找给定级别上最大子序列的方法，因此我们将它写在这个类中，如下所示：
- en: '[PRE53]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `AggregationBuilders` class is used to construct an aggregate query. The
    Elasticsearch Java API is self-explanatory and simple. You can easily relate this
    Java API query with a REST query. We first create a nested aggregate query and
    then add a filter aggregate query as a sub-aggregation followed by a `max` aggregation.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregationBuilders` 类用于构建聚合查询。Elasticsearch Java API 是自我解释的，简单易懂。您可以轻松地将此
    Java API 查询与 REST 查询相关联。我们首先创建一个嵌套聚合查询，然后添加一个作为子聚合的过滤聚合查询，之后是一个 `max` 聚合。'
- en: The value of `blogId` is added with a `TermQueryBuilder` class. Finally, we
    get an Elasticsearch client from `elasticsearchTemplate` and initiate search by
    providing an index name (`blog`), a document type (`blog`), a root level query
    (for `blogId`), and at the end setting the aggregations. This Java API returns
    the aggregation JSON that we got for REST query, which you can process with a
    JSON API to get the desired result.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`blogId` 的值是通过 `TermQueryBuilder` 类添加的。最后，我们从 `elasticsearchTemplate` 获取 Elasticsearch
    客户端，通过提供索引名称（`blog`）、文档类型（`blog`）、根级查询（针对 `blogId`）以及最后设置聚合来启动搜索。这个 Java API 返回我们为
    REST 查询获取的聚合 JSON，您可以使用 JSON API 处理以获取所需的结果。'
- en: Reading comment data with Elasticsearch aggregation
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elasticsearch 聚合读取评论数据
- en: 'Once comments are added, they must be visible when the user opens the blog.
    This scenario is straightforward. Since comments are nested objects of a blog,
    when we read a blog with the following API, all its comments are also available
    as part of the blog object:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了评论，当用户打开博客时它们必须可见。这种情况很简单。由于评论是博客的嵌套对象，当我们使用以下 API 读取博客时，所有评论也将作为博客对象的一部分提供：
- en: '[PRE54]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `findById` method is provided out of the box by a default repository implementation,
    available during runtime. We pass `blogId`, and it will fetch all details of the
    blog along with comments (as nested objects).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`findById` 方法是由默认的仓库实现提供的，在运行时可用。我们传递 `blogId`，它将获取博客的所有详细信息以及评论（作为嵌套对象）。'
- en: The second scenario for reading comment is the admin user opens the manage-comment
    page, where all comments are displayed for moderation purposes. In this case,
    the system will show all comments added to any of the blogs, so it is necessary
    to bring all comments from all blogs.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 读取评论的第二个场景是管理员用户打开管理评论页面，在此页面上显示所有评论以供审核。在这种情况下，系统将显示添加到任何博客的所有评论，因此有必要从所有博客中获取所有评论。
- en: 'The first way of achieving this is to fetch all blogs, take the comments, and
    append them to build the comments list. But this is not an ideal solution as it
    requires many things to be done manually. We can use Elasticsearch aggregation
    queries to do this. By default, the `nested` objects cannot be fetched directly
    as a parent object, so it requires aggregation:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的第一种方法是获取所有博客，提取评论，并将它们附加起来构建评论列表。但这种方法并不是理想的解决方案，因为它需要手动完成许多工作。我们可以使用
    Elasticsearch 聚合查询来完成这项任务。默认情况下，`nested` 对象不能直接作为父对象获取，因此需要聚合：
- en: '[PRE55]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This query has the `top_hits` aggregation, which simply lists all `nested` objects.
    We need the data in descending order of `createdDate` (recently added should be
    placed on top), so sorting criteria is added. The `from` and `size` criteria are
    used for pagination. The `from` criteria represents the offset from first record,
    while `size` shows the total record per page.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询具有 `top_hits` 聚合，它简单地列出所有 `nested` 对象。我们需要按 `createdDate` 的降序（最近添加的应放在顶部）排序数据，因此添加了排序标准。`from`
    和 `size` 标准用于分页。`from` 标准表示从第一条记录的偏移量，而 `size` 显示每页的记录总数。
- en: By default, `top_hits` will return three records if you have not provided the `size` value.
    Also, the maximum allowed size is 100 so while using `top_hits`, you have to use
    pagination.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果没有提供 `size` 值，`top_hits` 将返回三条记录。此外，允许的最大大小为 100，因此在使用 `top_hits` 时，您必须使用分页。
- en: 'This query returns the result. Aggregation data for full results is shown in
    the following snippet:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回结果。以下片段显示了完整结果的聚合数据：
- en: '[PRE56]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can write the previous query with the Elasticsearch Java API as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式使用 Elasticsearch Java API 编写之前的查询：
- en: '[PRE57]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, this is self-explanatory. First, we are creating a nested aggregation
    query with `AggregationBuilders` and adding the sub-aggregation of the `top_hits`
    type, along with sorting criteria with the `from` and `size` settings. The process
    of getting a response is identical to what we used in the method to get the maximum
    child sequence.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这一点是显而易见的。首先，我们使用`AggregationBuilders`创建一个嵌套聚合查询，并添加`top_hits`类型的子聚合，同时使用`from`和`size`设置添加排序条件。获取响应的过程与我们用于获取最大子序列的方法相同。
- en: 'In case we need to display comments with a specific status value, we can use
    the following query:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要显示具有特定状态值的评论，我们可以使用以下查询：
- en: '[PRE58]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The term aggregation query has been added which checks the value of the status
    field. You can use a wildcard (`*`) for matching criteria, for example, `A*` will
    match all statuses starting with `A`. The equivalent Java API appears as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加了检查状态字段值的聚合查询术语。您可以使用通配符（`*`）作为匹配条件，例如，`A*`将匹配所有以`A`开头的状态。等效的Java API如下所示：
- en: '[PRE59]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Updating and deleting comment data with Elasticsearch
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elasticsearch更新和删除评论数据
- en: 'Updating a `nested` object is straightforward. Elasticsearch does not provide
    a direct way to update a specific `nested` object. Instead, you need to fetch
    all the `nested` objects from the root document, find the particular `nested`
    object (possibly by some unique identifier), update it, assign the `nested` object
    list back to the root document, and save the root document. For example, we can
    update the status for specific comment (`nested`) objects of a blog with the following
    method. It is defined in the service class:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`nested`对象的过程很简单。Elasticsearch不提供直接更新特定`nested`对象的方法。相反，您需要从根文档中获取所有`nested`对象，找到特定的`nested`对象（可能通过某些唯一标识符），更新它，将`nested`对象列表分配回根文档，并保存根文档。例如，我们可以使用以下方法更新博客的特定评论（`nested`）对象的状态。该方法定义在服务类中：
- en: '[PRE60]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Deleting of a comment is similar. Just remove the required comment object from
    the list and save the blog object to delete the comment.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 删除评论的过程类似。只需从列表中移除所需的评论对象，并保存博客对象以删除评论。
- en: Another way of achieving a one-to-many relationship in Elasticsearch is through
    the parent-child structure. However, it is slower than the `nested` objects. The
    only drawback with the `nested` object is whenever any `nested` object is updated,
    the root document needs to be re-indexed. But due to retrieval of data, this is
    comparatively fast, and the `nested` objects are preferred to the parent-child
    structure.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在Elasticsearch中实现一对一关系的另一种方式是通过父子结构。然而，它比`nested`对象慢。`nested`对象的唯一缺点是，每当任何`nested`对象被更新时，根文档都需要重新索引。但由于数据的检索，这相对较快，因此`nested`对象比父子结构更受欢迎。
- en: We have understood how to interact with Elasticsearch and fetch data. Next we
    will see how to display those data at the frontend.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何与Elasticsearch交互并获取数据。接下来，我们将看到如何在前端显示这些数据。
- en: Displaying data with RESTful web services in Spring
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring中使用RESTful Web服务显示数据
- en: Spring provides RESTful web service implementations with its web MVC module.
    With each annotation, the creation of a REST web service is more or less like
    web MVC architecture. The RESTful web services can be built with the help of a
    REST controller. The noticeable difference between a web MVC and REST controller
    is the way they create the HTTP response.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过其web MVC模块提供RESTful Web服务的实现。每个注解的创建RESTful Web服务与Web MVC架构或多或少相似。RESTful
    Web服务可以通过REST控制器构建。Web MVC和REST控制器之间明显的区别是它们创建HTTP响应的方式。
- en: 'A traditional web MVC uses various view technologies (such as JSP, Thymeleaf,
    and so on) to build a response, while the REST controller returns objects that
    are converted into JSON (or XML, based on the configuration), and finally sent
    as a HTTP response. For our Blogpress application, we will use RESTful services
    in the following two use cases:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Web MVC使用各种视图技术（如JSP、Thymeleaf等）来构建响应，而REST控制器返回的对象被转换为JSON（或根据配置转换为XML），最终作为HTTP响应发送。对于我们的Blogpress应用程序，我们将在以下两个用例中使用RESTful服务：
- en: Showing blog lists on the home page
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主页上显示博客列表
- en: Showing blog comments when a particular blog is open for view
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当特定博客打开供查看时显示博客评论
- en: 'To achieve this, we will write new controller class as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们将编写如下所示的新控制器类：
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The REST controller must be defined with the `@RestController` annotation. Since
    we have two controllers now (one is the normal web MVC , and the second is the
    REST controller), we defined request mapping with `@RequestMapping` to differentiate
    the URL pattern.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: REST控制器必须使用`@RestController`注解进行定义。由于我们现在有两个控制器（一个是普通的Web MVC，另一个是REST控制器），我们使用`@RequestMapping`来定义请求映射以区分URL模式。
- en: The `@RequestMapping` annotation defines the method URL, HTTP method name and
    MIME type of the output this method produces. The `getAllBlogJSON()` method gets
    list of `Blog` objects and sends it with `ResponseEntity`, along with the HTTP
    response code. The `ResponseEntity` class represents the response body, header,
    and status code, and this class is used to prepare the HTTP response. To use it,
    the only thing required is to define it as return type of method (end point).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping`注解定义了方法URL、HTTP方法名称以及该方法生成的输出MIME类型。`getAllBlogJSON()`方法获取`Blog`对象的列表，并通过`ResponseEntity`发送它，同时附带HTTP响应代码。`ResponseEntity`类表示响应体、头部和状态码，并用于准备HTTP响应。要使用它，只需将其定义为方法的返回类型（端点）即可。'
- en: Alternatively, the `@ResponseBody` annotation (at method level) can be used
    to produce a HTTP response. `ResponseEntity` does exactly same as `@ResponseBody`
    , but provides some additional features, including setting the HTTP response code
    so it is better.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以在方法级别使用`@ResponseBody`注解来生成HTTP响应。`ResponseEntity`与`@ResponseBody`功能完全相同，但提供了额外的功能，包括设置HTTP响应代码，因此更好。
- en: The `ResponseEntity` type is generic, so you can send any type of object with
    it. Both methods return the objects of `Blog` and `Comment`, respectively. Spring
    automatically converts the object list into a JSON string and returns it as a
    HTTP body. The `MediaType` class provides various mime types. The first method
    is accessible with the`http://localhost:8080/api/listBlogs` URL, and the second
    method with `http://localhost:8080/api/listAllComments`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseEntity`类型是泛型的，因此你可以用它发送任何类型的对象。两个方法分别返回`Blog`和`Comment`的对象。Spring会自动将对象列表转换为JSON字符串，并将其作为HTTP体返回。`MediaType`类提供了各种MIME类型。第一个方法可以通过`http://localhost:8080/api/listBlogs`
    URL访问，第二个方法可以通过`http://localhost:8080/api/listAllComments`访问。'
- en: Next we will see how to present this data with a presentation layer. For our
    Blogpress application, we used the Thymeleaf template to construct a view layer.
    Thymeleaf templates are processed at server side. We will use another template
    engine called **Mustache** for client-side processing.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到如何通过表示层来展示这些数据。对于我们的Blogpress应用，我们使用了Thymeleaf模板来构建视图层。Thymeleaf模板在服务器端进行处理。我们将使用另一个名为**Mustache**的模板引擎来进行客户端处理。
- en: Building a UI with the Mustache template
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mustache模板构建UI
- en: The Mustache is a web template available for many languages, like JavaScript,
    Ruby, PHP, Python, Perl, Android, C++, Java, and so on, with a language-specific
    implementation. In our Blogpress application, we will use Mustache for JavaScript,
    so we need to include `Mustache.js` in the Blogpress application. Let's first
    understand the use case where `Mustache.js` is appropriate.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache是一个适用于多种语言的Web模板，如JavaScript、Ruby、PHP、Python、Perl、Android、C++、Java等，具有语言特定的实现。在我们的Blogpress应用中，我们将使用Mustache来处理JavaScript，因此我们需要在Blogpress应用中包含`Mustache.js`。让我们首先了解`Mustache.js`适用的用例。
- en: 'Quite often, to show dynamic values in HTML, we mix the data with HTML fragments
    and then update the DOM markup to show the final output. The following is the
    sample example for this approach:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，为了在HTML中显示动态值，我们会将数据与HTML片段混合，然后更新DOM标记以显示最终输出。以下是这个方法的示例：
- en: '[PRE62]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This kind of code not only creates a maintenance nightmare, but it mixes the
    UI and dynamic data logic together, thus causing tight coupling between them.
    This prevents the code being reused and breaks the separation of the concern principle.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码不仅会制造出维护噩梦，而且会将UI和动态数据逻辑混合在一起，从而导致它们之间紧密耦合。这阻止了代码的重用，并破坏了关注点分离原则。
- en: 'The best solution for this kind of problem is to use some sort of HTML template.
    There are many client-side HTML template engines available today, `Mustache.js`
    is one of them, and we have chosen it to construct a few of the pages for our
    Blogpress application. Let''s see how it works by taking a very simple example
    as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这类问题的最佳方案是使用某种HTML模板。目前有许多客户端HTML模板引擎可用，`Mustache.js`就是其中之一，我们选择了它来构建我们的Blogpress应用的一些页面。让我们通过以下一个非常简单的示例来看看它是如何工作的：
- en: '[PRE63]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This example is self-explanatory. The template has been defined with `<script>`
    of the `text/template` type. With `Mustache.js`, we are reading the template and
    passing the `student` object. In the template, the **`{{...}}`** notation is used
    to insert dynamic values. This not only makes the code clear, but can accommodate
    any future change with ease.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是自我解释的。模板已经使用`<script>`的`text/template`类型定义。使用`Mustache.js`，我们正在读取模板并传递`student`对象。在模板中，使用**`{{...}}`**注释插入动态值。这不仅使代码清晰，而且可以轻松适应未来的任何变化。
- en: '`Mustache.js` is a logic-less template, which means it does not contain procedural
    statements such as if-else, for, and so on, but we can use tags to achieve some
    sort of loop and conditional. For our Blogpress application, we are using `Mustache.js`
    in the following two pages:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mustache.js`是一个无逻辑模板，这意味着它不包含如if-else、for等过程性语句，但我们可以使用标签来实现某种循环和条件。对于我们的Blogpress应用程序，我们在以下两个页面中使用`Mustache.js`：'
- en: Home page to show all blogs in list format with minimal information
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页以列表格式显示所有博客，信息尽可能少
- en: Manage Comment page where all comments are listed for moderation and reply for
    the admin user
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理评论页面，其中列出所有评论供管理员用户审核和回复
- en: 'First, we will deal with the home page where all blogs are shown in list format.
    The following is the code for the Mustache template on the home page:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理主页，其中所有博客都以列表形式显示。以下是在主页上的Mustache模板的代码：
- en: '[PRE64]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first script tag defines the template with the `text/template` type. The
    `{{#blogs}}` and `{{/blogs}}` expressions are evaluated in two ways. If a blog
    key exists and has a false value or empty list (if it's a type of array), the
    HTML code in between will not be displayed. If it's true or a non-empty list (array),
    then it will render the in-between HTML.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本标签使用`text/template`类型定义模板。`{{#blogs}}`和`{{/blogs}}`表达式以两种方式评估。如果博客键存在并且具有false值或空列表（如果是数组类型），则之间的HTML代码将不会显示。如果是true或非空列表（数组），则将渲染之间的HTML。
- en: In our case, we want to show the blog list with the `Mustache.js` template.
    The data is populated from a REST web service (which eventually calls a REST controller)
    through Ajax. If successful, the data is stored in the `blogData` object with
    `blogs` as a key. This key is used in the `Mustache.js` template (`{{#blogs}}
    ....{{/blogs}}`) to iterate the blog array. The individual attribute is placed
    with the `{{...}}` expression. For example, `{{body}}` will display a value of
    a body attribute from the blog object. `Mustache.render` takes the template and
    data, and produces the final output that is appended in `div` with the `blogList`
    ID.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望使用`Mustache.js`模板显示博客列表。数据通过Ajax从REST Web服务（最终调用REST控制器）填充。如果成功，数据将存储在`blogData`对象中，以`blogs`作为键。这个键在`Mustache.js`模板（`{{#blogs}}
    ....{{/blogs}}`）中用于迭代博客数组。单个属性使用`{{...}}`表达式放置。例如，`{{body}}`将显示博客对象中body属性的价值。`Mustache.render`接受模板和数据，并生成最终输出，该输出附加到具有`blogList`
    ID的`div`中。
- en: 'We have used `th:inline` in the second script tag. This is a Thymeleaf tag.
    In case you need to substitute the value in the script tag, you need to define
    it with `th:inline`. The Thymeleaf value can be inserted with the `/*[[,,,]]*/`
    notation. In this case, we are passing a dynamic URL so we have used `@{/api/listBlogs}`
    inside `/*[ .. ]*/` (so that the final URL would be `http://localhost:8080/api/listBlogs`).
    This will look like the following screenshot:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二个脚本标签中使用了`th:inline`。这是一个Thymeleaf标签。如果你需要在脚本标签中替换值，你需要使用`th:inline`来定义它。Thymeleaf的值可以使用`/*[[,,,]]*/`注释来插入。在这种情况下，我们传递了一个动态URL，因此在`/*[
    .. ]*/`内部使用了`@{/api/listBlogs}`（这样最终的URL将是`http://localhost:8080/api/listBlogs`）。这看起来就像下面的截图：
- en: '![](img/c1a2c38c-d19c-4c64-893e-6d6686375599.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a2c38c-d19c-4c64-893e-6d6686375599.png)'
- en: 'Another page is the managed comment page where the comments are displayed with
    the `Mustache.js` template, as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个页面是管理评论页面，其中评论使用`Mustache.js`模板显示，如下所示：
- en: '[PRE65]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This template is similar to what we have seen for blog lists on the home page.
    The additional thing here is the population of the `showApproveReject` and `showReply`
    attributes with the `true` value. Since Mustache is a logic-less template, there
    is no direct provision for a conditional statement, such as if-else. The only
    way of adding a condition is with the `{{#attribute}} ... {{/attribute}}` expression,
    where it will check if an attribute key is available and set to `true`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板与我们在家页面上看到的博客列表模板类似。这里额外的一点是，`showApproveReject` 和 `showReply` 属性被设置为 `true`
    值。由于 Mustache 是一个无逻辑模板，没有直接的条件语句提供，例如 if-else。添加条件的唯一方法是使用 `{{#attribute}} ...
    {{/attribute}}` 表达式，它会检查属性键是否存在并设置为 `true`。
- en: In the Manage Comment page, each comment is listed for admin moderation. If
    a comment status is M (moderate), the system shows buttons—Approve and Reject.
    If it is approved (status A) then the system will show an option to Reply to the
    comment. With the `Mustache.js` template, we cannot directly check the status
    value. So, two additional keys (`showApproveReject` and `showReply`) are added
    in the comment object and set it to `true`, based on the value of the status.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理评论页面中，每个评论都会列出供管理员审核。如果评论状态为 M（审核中），系统会显示按钮——批准和拒绝。如果被批准（状态为 A），则系统会显示回复评论的选项。使用
    `Mustache.js` 模板，我们无法直接检查状态值。因此，在评论对象中添加了两个额外的键（`showApproveReject` 和 `showReply`），并将其设置为
    `true`，基于状态值。
- en: 'This will look like the following screenshot:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这将看起来像以下截图：
- en: '![](img/a4215b73-53c5-4a3d-8936-e85149e29746.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4215b73-53c5-4a3d-8936-e85149e29746.png)'
- en: Summary
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have been on a long journey. There is no better way to build an application
    than taking a real-life scenario and learning about the underlying concepts, tools,
    and technology. In this chapter, we took a blog application and built various
    layers with a set of frameworks.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了一段漫长的旅程。没有比通过真实场景学习底层概念、工具和技术更好的构建应用程序的方法了。在本章中，我们以博客应用程序为基础，使用一系列框架构建了各种层。
- en: Taking the Spring Framework as a foundation, we began our journey with Spring
    Boot—a rapid tool to propel the development, with all the underlying configuration
    to be done with a kind of auto-mode. We framed the first layer with the Spring
    MVC web framework in conjunction with Thymeleaf. Being a natural template engine,
    Thymeleaf is another way of constructing a view layer. We built the authentication
    and authorization, a very important part of the application, with Spring Security.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Spring 框架为基础，我们开始了我们的旅程——Spring Boot——一个快速开发工具，所有底层配置都可以通过一种自动模式完成。我们使用 Spring
    MVC 网络框架和 Thymeleaf 构建了第一层，Thymeleaf 是一种构建视图层的自然模板引擎。我们还使用 Spring Security 构建了认证和授权，这是应用程序的重要组成部分。
- en: We implemented the data source of the Blogpress application with Elasticsearch—an
    open source highly scalable search engine, mainly used for indexing and analyzing
    purposes. After exploring basic concepts, we learned how to create an index, document
    type, and add the document data, followed by how to search them in Elasticsearch,
    by taking a sample of a `student` entity.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Elasticsearch——一个开源的、高度可扩展的搜索引擎，主要用于索引和分析目的——实现了 Blogpress 应用程序的数据源。在探索基本概念之后，我们学习了如何创建索引、文档类型，并添加文档数据，然后通过一个
    `student` 实体的示例学习了如何在 Elasticsearch 中搜索它们。
- en: Moving on further, we learned to create the data structure with a nested object
    for our Blogpress application. Inserting data into and retrieving it from the
    nested object with various searching and aggregation mechanisms were the main
    crux of the data layer we implemented in Elasticsearch.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们学习了如何为 Blogpress 应用程序创建具有嵌套对象的数据结构。在嵌套对象中插入数据以及使用各种搜索和聚合机制检索数据是我们实现的数据层的主要核心。
- en: Taking a further step to bridge the persistence layer developed in Elasticsearch
    with the front-facing layer in Spring MVC, we used the Spring Data module. Then
    we leveraged the extension capabilities of the Spring Data framework to implement
    customized queries with the Elasticsearch Java API. In the end, we saw how the
    client-side template engine `Mustache.js` is useful to solve the problem of mixing
    the logic of dynamic data with HTML fragments.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步将 Elasticsearch 中开发的持久化层与 Spring MVC 的前端层连接起来，我们使用了 Spring Data 模块。然后，我们利用
    Spring Data 框架的扩展能力，使用 Elasticsearch Java API 实现了自定义查询。最后，我们看到了客户端模板引擎 `Mustache.js`
    如何有助于解决动态数据逻辑与 HTML 片段混合的问题。
- en: In the next chapter, we will focus on making the application secure with Spring
    Security. We will talk more about the integration of Spring Security with OAuth
    2—a widely used protocol for authorization. We will also look at **Lightweight
    Directory Access Protocol** (**LDAP**) integration with Spring Security to build
    a central application that supports authentication and authorization.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用 Spring Security 来确保应用程序的安全性。我们将更详细地讨论 Spring Security 与 OAuth
    2 的集成——这是一个广泛使用的授权协议。我们还将探讨 **轻量级目录访问协议**（**LDAP**）与 Spring Security 的集成，以构建一个支持身份验证和授权的中心应用程序。
