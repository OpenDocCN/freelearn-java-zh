- en: Blogpress - A Simple Blog Management System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring supports the development of enterprise-grade applications on the Java
    platform. There are numerous such application that come under its purview, popular
    among which are Spring **Model-View-Controller** (**MVC**), Spring Security, Spring
    Data, Spring Batch, and Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two chapters, we started exploring Spring MVC framework along
    with other building blocks, like Spring Data and RestTemplate, along with JavaScript
    frameworks like Angular, Bootstrap, and jQuery to build the web-based application.
    We have also seen how to build a reactive web application with the help of WebFlux,
    a framework for creating reactive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enterprise-ready Spring-based application requires heavy configuration,
    which makes the process of development quite tedious and cumbersome. On top of
    this, setting up the complex dependencies also needs lots of effort. Quite often,
    the libraries used in Spring-based web applications require common configuration
    to bind them together.
  prefs: []
  type: TYPE_NORMAL
- en: Considering any standard Spring-based application, you might need to perform
    certain repetitive tasks, specifically for configuration, for example, importing
    required modules and libraries to resolve dependencies; doing configuration related
    to various layers of application, such as data source and transaction management
    at the DAO layer, and view resolver and resource management at the web layer,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This is a mandated procedure that has to be followed while creating any Spring-based
    web application. In short, developers often resort to duplicating the configuration
    across application and may not following the best practices while integrating
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: All these factors inspired the Spring team to come up with a framework that
    provides integration for all the Spring libraries through auto-configuration, which
    basically eliminates the repetitive jobs for you. In addition to this, it provides
    production-ready features, such as application metrics and monitoring, and logging
    and deployment guidelines. This framework is known as Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue our journey and look at building different
    components required for a blog management web application using Spring libraries
    and other third-party libraries all bound together with auto-configuration provided
    by Spring Boot and some overrides done by us to the auto-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Project skeleton with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main flow of the application in the Spring MVC framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation layer with **Thymeleaf** and `Mustache.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the application secure with Spring Security—covering authentication and
    authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the backend layer in Elasticsearch, which holds the application data
    and provides REST-based CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Spring MVC REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter03/blogpress).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Application overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a real-life example is the best approach to explore and understand the
    concepts of a given framework context. The idea is not to show how to build the
    web application; instead, we will show the important components which are part
    of the application so that anyone can just pick one component and use it in another
    application. You can always find the complete working solution in the code downloaded
    for the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into action. First, we will go through the brief about our application—blog.
    We will call it **Blogpress**. Please note that it will not be a full-fledged
    blogging application; instead, we will develop it with the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Landing page—shows a list of blogs with the links to each blog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user clicks on any of the blogs, the system opens it in view mode along
    with all (approved) comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user can add comments to the same screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from this, a user can search for the blog with given search text, targeting
    the title or body of the blog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a login feature. Two people can log into the application—a blog user
    and an admin:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog user can add/update/delete the blog. He can only edit the blogs he created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Admin user can perform all possible operations a blog user can do plus manage
    (approve or reject) the comments given by the anonymous user.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When any user adds a comment, an email will be sent to the admin user to moderate
    it. Once the comment is approved, an email will be sent back to the user as a
    notification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project skeleton with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot automates the process of creating the configuration which speeds
    up the development process. In short, Spring Boot makes the development life cycle
    shorter, with minimal or no configuration for building production-ready applications
    or services. It uses the convention-over-configuration methodology to provide
    rapid application development.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is not meant to provide any new features; instead, as it is established
    on top of the Spring Framework, it uses existing Spring Framework features to
    provide a preconfigured application skeleton out of the box, which is a getting-started
    mode of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot has various advantages over conventional ways of creating a Spring-based
    application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Has automated configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages dependency with ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports an embedded server to make the development process easy and straightforward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides support for building the application with Maven or Gradle out of the
    box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eases integration with other Spring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeds up the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports command lines and IDEs to develop and test the application with ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring IDE Spring Tool Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start developing our blog application—Blogpress. As described, we will
    start creating the application with Spring Boot first. Developing an application
    with an IDE is the most straightforward, easy, convenient, and favorable approach
    preferred by the majority of developers today. We use IDEs to develop our application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides an Eclipse-based IDE called **Spring Tool Suite** (**STS**)
    to develop any Spring-based application with ease. Download the latest version
    of STS from the link [https://spring.io/tools.](https://spring.io/tools)
  prefs: []
  type: TYPE_NORMAL
- en: The STS is available with Eclipse, along with Visual Studio and Atom-based code
    editors. You can use either of them for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the STS (an Eclipse-based IDE) to build the application in this
    chapter. Download STS, unzip it in your local folder, and open the `.exe` file
    to start the STS. Once started, create a new Spring Starter Project of the Spring
    Boot type with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `blogpress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: Maven (you can also select Gradle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Packaging: Jar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java Version: 8 (or above)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language: Java'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Group: This would be a Maven `groupId`, so give the appropriate value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artifact: This would be a Maven `artifactId`, so give the appropriate value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version: `0.0.1-SNAPSHOT`—the build version of our application build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: `A simple blog management system`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create a Spring Boot application from a command window as well. Spring
    provides a tool called Spring **command-line interface** (**CLI**) for this. Another
    way of creating a Spring Boot starter project is with [https://start.spring.io/](https://start.spring.io/).
    You need to define the dependencies and it will allow users to download the entire
    project structure from the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping all default options, click Finish to create the Spring Boot application.
    You will see the following dependencies in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Spring Boot provides various starters, specific for each dependency so that
    their JARs are available in the classpath. Since we want to develop a web application
    (Spring MVC), we keep the starter `spring-boot-starter-web` in the previous code
    (in fact, it is added while creating a project in the STS).
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a set of dependencies for a specific functionality in the form
    of a starter. It is a convenient way of managing dependencies in a Spring Boot
    application. When you specify a particular starter, Spring Boot will pull all
    (recursive) dependencies in your application for you. For example, if you wish
    to add a data store to your application with JPA, simply add `spring-boot-starter-jpa`
    to `pom.xml` in your Spring Boot application. All dependency will be carried out
    by Spring Boot so that you can focus on business implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see `spring-boot-starter-parent` in the parent element of `pom.xml`.
    This is the magic of Spring Boot. Your application extends all Spring Boot capabilities
    by this declaration, as following snippet shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Spring Model-View-Controller web flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to add Spring MVC capabilities. In the previous step, the required
    starter dependencies for the web are added to the `pom.xml` file. Next, we will
    define Spring MVC artifacts in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a Spring Boot application, we are not required to declare everything
    from scratch. It is essential to define the controllers and view layer. First,
    we will declare a Spring MVC controller, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `@Controller` annotation describes this class as a Spring MVC controller.
    It basically instructs the Spring Boot application that this component will serve
    a web-based request. It matches the correct URL pattern to call a specific controller
    and its method.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous declaration, we only gave the URL pattern to the controller
    method. However, Spring allows you to declare URL patterns for the controller
    as well. Since our application requires only certain functionalities, one controller
    is sufficient, and hence, we haven’t declared the URL pattern for the controller.
    So, all web requests (with the `http://host/context/controllerUrlPattern` pattern)
    for the current application will be routed to this controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RequestMapping("/controllerUrlPattern")` annotation is used to describe
    URL patterns at the controller level. In this scenario, the `http://host/context/controllerUrlPattern`
    pattern will reach this controller. The URL pattern of all of its methods will
    be appended after `http://host/context/controllerUrlPattern`.
  prefs: []
  type: TYPE_NORMAL
- en: It is always good practice to use a logger. Spring provides the `LoggerFactory`
    class to get a logger instance for the current class. You can call various methods
    like `info`, `debug`, `error`, and so on at appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring MVC controller method can be mapped with a distinct URL so that it
    can be triggered by a matching request URL pattern. The `showLandingPage()` method
    is a controller method in the previous case. It is mapped with the URL `/` and
    this means the `http://localhost:8080/blogpress/` URL (considering you run the
    application in your local with the `8080` port and `blogpress` is the name of
    your application) will call this method.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a string, `home`, which represents the component from the
    presentation layer. Spring MVC is flexible enough to choose the desired presentation
    framework. So, it is absolutely unnecessary to use specific technology as your
    presentation layer. You can use **JavaServer Pages** (**JSP**s), Thymeleaf, or
    a UI framework such as Angular as your frontend for a Spring MVC web application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use Thymeleaf to build the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer with Thymeleaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thymeleaf is a template engine used to process various templates in XML, HTML,
    JavaScript, CSS, and plain TEXT on the server side. You might have a question:
    why Thymeleaf? We already have JSP. What are the benefits of using Thymeleaf over
    JSP?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, Thymeleaf is designed with a natural templating concept and provides
    a design prototype support without affecting the use of the template. In other
    words, due to its nature, Thymeleaf can be used by both developers and design
    teams without being locked-in or having a dependency between either of them.
  prefs: []
  type: TYPE_NORMAL
- en: Another good thing about Thymeleaf is that it is designed in accordance with
    web standards, mainly HTML5\. This will make it easy for you to fully validate
    the templates if that is required.
  prefs: []
  type: TYPE_NORMAL
- en: How Thymeleaf works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our blogging application, we will use the Thymeleaf HTML template. The
    very first step for working with Thymeleaf is to instruct Spring Boot so that
    it can make all the necessary configurations specific to Thymeleaf readily available
    for our application. Add the following entry in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thymeleaf provides certain tags (a kind of JSP tags) to embed dynamic values
    into the template. We will first go through the bare minimum tags that we intend
    to use in our Blogpress application. The mechanism of inserting a dynamic value
    into the Thymeleaf template is different than what you might have seen in JSP
    tags, so it is quite vital to be familiar with it before starting to use it.
  prefs: []
  type: TYPE_NORMAL
- en: You can see another starter for Thymeleaf. This is how Spring Boot makes the
    developer's life easy.
  prefs: []
  type: TYPE_NORMAL
- en: Dialects, processors, and expression objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dialects are a set (or group) of features that you use in your template, including
    pre- and post-processing logic and expression objects. Processing logic (of embedding
    the dynamic HTML and value in the template) is carried out by objects called a
    processor, while expression objects are used to describe standard expression for
    performing a specific operation. In short, processor objects deal with the DOM
    node or element, while expression objects are used to evaluate the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dialects can be used along with processors, or expression objects, or both.
    Let''s see how a dialect can be declared and used in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In previous snippet, `th` is called the dialect prefix. It means that all attributes
    and tags provided by this dialect start with `th:`. This is a standard and out-of-the-box
    dialect, and it is just sufficient for most of our scenario. You can consider
    dialect similar to *Taglibs* in JSP.
  prefs: []
  type: TYPE_NORMAL
- en: You can define more than one dialect in your template. Additionally, you can
    create your own custom dialect with custom processing logic in custom processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `text` attribute represents a processor that simply puts the value for
    the span while `${...}` describes the value expression object, which simply pulls
    the attribute value stored in the model. The following are the types of expression
    objects available in Thymeleaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable expression objects:** They are used to show the value of the model
    attribute. They are in the form of Spring **expression language** (**EL**). They
    can be described with the `${...}` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selection expression object:** These are similar to expression objects but
    can only be applied to the previously selected object. They can be used with the `*{...}`
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message (i18n) expressions:** These are used for internationalization purposes
    and bringing language-specific messages. You can use the `#{...}` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link (URL) expressions:** These are used to employ links dynamically. For
    example, form action, HREF, linking JS/CSS, or other static resources, and so
    on. Use the `@{...}` syntax for them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment expressions:** This represents a fragment of the template and can
    be reused in similar or other templates. They can be utilized with the `~{...}`
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will see some of the processors that we are going to use in our following
    application. They can be used along with various expression objects listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`th:text`—This is used along with value expression objects to place dynamic
    text for HTML elements like `span`, `li`, `div`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th:value`—The value of the input element can be supplied with this processor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th:action`—This can be used to supply the action value to HTML form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th:href`—As its name suggests, this is used to provide an URL in the link
    (to import CSS) and tags in HTML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th:src`—This is used to provide source URL for script (and other such) elements
    in HTML dynamically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`th:each`—This is used with `th:text` in the loop to construct repetitive HTML
    code, that is, rows of HTML tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**th:if**` and `th:unless`—These are used to place dynamic values conditionally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thymeleaf supports defining attributes and element names in HTML5 style. For
    example, instead of writing `th:text`, you can write `data-th-text` as an attribute
    in an HTML element, and it is considered a custom element in HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Why Thymeleaf is a natural template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the processors of standard dialect are placed as an attribute of
    HTML element. Because of this arrangement, the browser can render the Thymeleaf
    template as a correct HTML file, even before they are processed by the template
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is quite possibly because the browser simply ignores them, considering
    them custom attributes, so there is no issue in displaying them. The same cannot
    be possible in the case of JSP. For example, the JSP with the following tag is
    not rendered in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you write it with Thymeleaf, it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The browser will display the preceding code perfectly. Additionally, Thymeleaf
    allows you to supply the (optional) value attribute (`Nilang` in our case), which
    will be displayed statically when run on the browser. When the same code is processed
    by the Thymeleaf template engine, the value will be substituted by evaluation
    of the `${name}` expression on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why Thymeleaf is called a natural template engine. It allows
    the designer to work with the developer without producing dependency on either
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss which Thymeleaf templates we are going to use in our blog
    application. When you create a Spring Boot application, you will see a `templates`
    file in the `src/main/resources` folder. All our Thymeleaf templates reside there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use following templates in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header.html`: This template contains a common JS/CSS inclusion header, along
    with a navigation bar. It is included in all other templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home.html`: Shows home page content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login.html`: Allows the user to login into the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user-page.html`: Once a blog user logs in, he will land on this page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view-blog.html`: Opens a particular blog in read-only mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search.html`: Shows the search result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new-blog.html`: A blog user or admin can create a new blog through this template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage-comments.html`: An admin user can approve/reject comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit-blog.html`: Allows a blog user/admin user to edit the existing blog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin-page.html`: Once an admin user logs in, they will land on this page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first add two templates—`home` and `header`. Before going further, let’s
    see one more cool feature of Thymeleaf that we will use in our application. Just
    like JSP, you can include a template into another template. Additionally, Thymeleaf
    allows you to include only some portion (fragment) of the template instead of
    the whole template, which is not possible with JSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a great feature, as you can define common fragments in one template
    and include them in others. In our case, we have defined common header items in
    a `header.html` template as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fragment is defined by the `th:fragment` tag. You can see how Thymeleaf
    tags (with dialect prefix, processors, and expression objects) are used to import
    various static resources (JS/CSS) along, with adding a dynamic value to HTML elements
    (`${pageTitle}` , in our case).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can include this header (which is defined as the fragment) in other templates.
    For example, in our `home.html` template, we have used it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `th:replace` tag is used to refer the fragment code from other templates.
    You need to just put the name of the template (from where you are referring fragments)
    with two colons (`::`) and the name of the fragment (that you have defined with
    the `th:fragment` tag). This is how Thymeleaf allows you to refer a set of template
    codes as a fragment to other templates.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined another fragment, called `header_navigation`, which is referred
    to in the home template in the previous code snippet. It is used to show a navigation
    menu for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment, we also need to put static resources (JS/CSS) into our application.
    You will see a static folder in the project structure where all static resources
    should be placed. Spring Boot will consider everything in the static folder as
    a static resource. Create `css`, `img`, and `js` folders under the static folder
    and place the following resources in them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To the `css` folder, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap.min.css`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To the `js` folder, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bootstrap.min.js`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jquery.min.js`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`popper.js`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it is time to run our application to see the home page. You can build and
    deploy it on a server and access it with the `http://localhost:8080/blogpress`
    URL, and you will see the home page with a header and navigation bar. Next, we
    have to make our application secure with Spring security. Security is an important
    aspect and core concern for any application today.
  prefs: []
  type: TYPE_NORMAL
- en: Making the application secure with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Blogpress application has a login functionality to access certain pages
    and functionalities that are not accessible by a normal (anonymous) user. It requires
    a good amount of effort to incorporate it if we build authentication and authorization
    on our own from scratch. Spring provides a feature called Spring Security, which
    does exactly what we need here.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security is an open source, highly comprehensive, powerful, and customizable framework
    used to implement authentication and authorization in J2EE-based web applications.
    It is a sub-project (module) of the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Before talking further, it is important to understand the difference between
    authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the process of **validating** or determining someone or something
    in what it claims to be. There are several mechanisms to perform authentication.
    The most straightforward way of performing authentication is to provide a username
    and password. Other ways include through LDAP, single sign-on, OpenId, and OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, authorization is more related to the **permission** of the
    actions you are allowed to do. In short, authentication means **who you are**
    and authorization means **what can you do** in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security provides many features out of the box, including authentication,
    authorization, protection against CSRF attack, servlet API integration support,
    Spring MVC integration, remember-me features, SSO implementation support, LDAP
    authentication support, OpenID integration, web service security support, WebSocket
    security support, Spring Data integration, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Though the latest version (at the time of writing this is 5.1.0) of Spring Security
    supports both XML and annotation support, you still need to do a good amount of
    configuration if you set it on your own. But you don’t have to worry, as Spring
    Boot is with you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot also supports Spring Security integration. Just like integration
    with other modules, you need to add a required starter for Spring Security to
    work with Spring Boot. Add the following dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you put the previously mentioned configuration in place, Spring Security
    becomes active and will not allow accessing even public pages of the application
    without valid credentials. When you hit `http://localhost:8080/blogpress`, you
    will see a login screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security with its default (auto) configuration, allows you to log in
    with a specific credential. The username will be `user` and password will be generated
    randomly by Spring Security and printed in the server log like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using generated security password: 89ca7b55-6a5d-4dd9-9d02-ae462e21df81.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override the username and password in a `property` file. In the project
    structure, you will see the `application.properties` file in the `src/main/resources`
    folder. Just add following two properties to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you can access the application with the previously mentioned credentials,
    but you still need authentication for accessing even public pages. By default,
    Spring Security is activated with the default (or auto-) configuration, which
    secures all the endpoints. This is not we want. So we need to instruct Spring
    Security which endpoints (URLs) we want to make secure and which we do not.
  prefs: []
  type: TYPE_NORMAL
- en: For this, first, we need to disable the default security (auto-) configuration.
    There are two possible options here.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding auto-configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add an `exclude` attribute to the `@SpringBootApplication` annotation for the
    main `bootstrap` class, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can add the following property in the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can take either of the previously described ways to disable or exclude the
    security (auto-) configuration. Excluding the auto-configuration is appropriate
    only in certain scenarios where you need to integrate the security provided by
    a custom provider.
  prefs: []
  type: TYPE_NORMAL
- en: Substituting auto-configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of disabling the auto-security configuration is to surpass it with
    our own custom configuration. Spring Security is a highly customizable framework
    and provides a fine-grained access mechanism based on URL and role.
  prefs: []
  type: TYPE_NORMAL
- en: 'To substitute auto-configuration with custom configuration, we need to specify
    the configuration class, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `WebSecurityConfig` custom configuration class extends the `WebSecurityConfigurerAdapter`
    abstract class. This abstract class has certain extension points (in the form
    of abstract methods for which you can provide your custom implementation) and
    default implementation for the common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Since our class (`WebSecurityConfig`) provides custom configuration, we have
    to define it with the `@Configuration` and `@ComponentScan("com.nilangpatel.blogpress")`
    annotations. You need to give the package (where the custom configuration class
    resides) name into the `@ComponentScan` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@EnableWebSecurity` annotation is also important because we are disabling
    the default security configuration. Without it, our application will not start.
    We will now override one method of the `WebSecurityConfigurerAdapter` class that
    will be used to define the web configuration and add one additional method that
    will be used to define user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security by default applies to all requests—including static resources
    as well. This method is used to define an escape sequence for static resources.
    Spring Security will block them by default if they are not configured to be ignored
    here. In the absence of the previously discussed configuration, the static resource
    will not be loaded into the browser so you will not see any `javascript`, `css`,
    or `images` files. Next, we will add user''s details to the same class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `configureGlobal` method is used here to create a username with a password
    and role on the fly. It is declared with the `@Autowired` annotation so that Spring
    will inject the object of the `AuthenticationManagerBuilder` class in it. The `AuthenticationManagerBuilder`
    class is used to provide the implementation of `AuthenticationManager`. As we
    have seen, Spring Security allows various mechanisms for authentication, and provides
    an implementation of `AuthenticationManager` for each of those mechanisms, such
    as in-memory authentication, LDAP authentication, JDBC authentication, OAuth authentication,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To make the thing simple, we have used in-memory authentication, which simply
    puts the user details in memory. This is not ideal for production, however. You
    are supposed to create user details in a database, and Spring Security is flexible
    enough to support this scenario as well.
  prefs: []
  type: TYPE_NORMAL
- en: Making the password secure is the most important, core part of any security
    framework, and hence Spring Security provides an encoding mechanism for this.
    It provides `BCryptPasswordEncoder` , which is an encoder class used to encode
    the password. It uses the **bcrpt** algorithm for encoding, which is a very strong
    password hashing routine widely used in Spring Security today.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security also provides a class called `NoOpPasswordEncoder` in case you
    wish to store the password as it is (in plain text form). However, starting with
    version 5, Spring has decided to deprecate it and it may be removed in future
    releases. This is because putting passwords as plain text is not encouraged and
    can lead to a security breach. So you should never use the `NoOpPasswordEncoder`
    class (not even for any POC).
  prefs: []
  type: TYPE_NORMAL
- en: We have used a method named `configureGlobal` , but you are absolutely free
    to choose the one you feel appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will override one more method, which is an extension point, to provide
    custom security settings for each of the endpoints we have in our application,
    as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We override the configure method (having `HttpSecurity` as a method parameter)
    to provide custom security configuration. If you open the original configure method
    of the parent class (`WebSecurityConfigurerAdapter`), it looks like the following
    snippet. Just putting the reference of the original method side by side will help
    you to understand what custom configuration we provide for our Blogpress application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The default `configure` method simply authenticates all requests. It allows
    a user to authenticate with a form-based login and supports HTTP basic authentication.
    This is the reason we were getting a default login page as soon as Spring Security
    was activated in Spring Boot with no custom security configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the Spring Security paradigm, `principal` refers to the username while `authorities`
    refers to the roles a user has. Keeping these terminologies in mind while working
    with Spring Security will help you understand the concepts better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what customization we did in our overridden configure method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `antMatchers("/", "/home").permitAll()` line will allow the listed URLs
    without any authentication. It means the `/` (default URL —`http://localhost:8080/blogpress`)
    URL is accessible publicly. You can provide any further URLs in comma-separated
    lists here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next `antMatchers("/controlPage").hasAnyAuthority("ROLE_USER","ROLE_ADMIN")`
    line makes the `/controlPage` URL accessible to any user with the `ROLE_USER`
    or `ROLE_ADMIN` roles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next `formLogin().loginPage("/login").permitAll()` line allows us to set
    the login page URL. We kept the `/login` URL, but you can give any custom login
    URL. Since the login page should be accessible publicly, the `permitAll()` method
    will make the login URL accessible to all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once Spring Security authenticates the user, it will send to a success page.
    You can configure the custom success page with `defaultSuccessUrl("/controlPage")`.
    In this case, the success URL is `/controlPage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly in case authentication fails, it should send to the error page. The
    `failureUrl("/login?error=true")` line will send the flow to the `/login` URL
    (along with parameters) on failed authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `permitAll().logoutSuccessUrl("/login?logout=true")` line configured
    the logout page. Once a user logs out, the system will trigger the `/login` URL
    (along with parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have added our custom security configuration; now it is time to add methods
    in Spring MVC corresponding to each URL we mentioned in the previous Spring configuration.
    Add the following methods in Spring MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `showHomePage` method is responsible for showing the home page when a user
    clicks on the Home link from navigation. It is associated with `/` URL and will
    show the `home.html` (Thymeleaf) template. In addition, this method is also called
    when you hit the `http://localhost:8080/blogpress` URL.
  prefs: []
  type: TYPE_NORMAL
- en: The `showControlPage` method is associated with the `/controlPage` URL and will
    be called on successful authentication. This method drives the user to the `control-page.html`
    (Thymeleaf) template, which shows administrative links based on the role. For
    example, a user with the `ROLE_ADMIN` role can see the links for Manage Blogs
    and Manage Comments, while a user with the `ROLE_USER` role will see only the Manage
    Blogs link.
  prefs: []
  type: TYPE_NORMAL
- en: The `showLoginPage` method represents the login functionality. It is associated
    with the `/login` URL. It stores messages based on parameter values along with
    the page title attribute, which is used to display a title of the page (in the
    `header.html` template). Finally, it opens the `login.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these methods, the following methods are added, which stores model
    attributes that are available in Thymeleaf templates directly using the `${}`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `isUserLoggedIn` method checks if any user is currently logged in. It will
    be called by the`${validUserLogin}` expression in the Thymeleaf template. The
    `getCurrentUserName` method simply provides the current logged-in username. The
    `checkIfUserHasUserRole` and `checkIfUserHasAdminRole` methods simply check the
    respective roles. You can see how the `SecurityContextHolder` class is used to
    fetch user login details. This class is responsible to store currently authenticated
    user's details, also known as principle.
  prefs: []
  type: TYPE_NORMAL
- en: We have gradually shaped up the Blogpress application, and it is now equipped
    with Spring MVC, Thymeleaf, and Spring Security. All this rapid development is
    possible with the help of Spring Boot. The next part we are going to develop is
    a data layer, which is the most important and crucial part of our application.
    As we mentioned, we will construct the data layer in **Elasticsearch**.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch is a highly scalable and full-text search open source RESTful
    searching, indexing, and analytics engine developed on top of **Lucene**. It is
    one of the most popular search engines for building enterprise applications today.
    It can save, search, and analyze data in big volumes very quickly. Mainly, it
    is used for applications where complex searching is required.
  prefs: []
  type: TYPE_NORMAL
- en: It is developed in Java and provides near real-time results. It is designed
    to work in a distributed environment to provide high availability and scalability.
    It is document-oriented, stores complex entity structures in JSON format, and
    provides a web interface to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch is mainly used in applications when searching for a large amount
    of matching products (for example, e-Commerce), using auto-complete features for
    partially typed input, or analyzing the huge quantities of raw data stored in
    a distributed fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to understand a few terminologies that are frequently used with
    Elasticsearch, which will help you to understand how Elasticsearch is built and
    how it works. They are the core of Elasticsearch. We will look at each of them
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic unit of information that is stored in Elasticsearch is called a **document**.
    You can consider a document equivalent to an entity in the **relational database
    management system** (**RDBMS**). For example, a document can be created for an
    employee, another document is for a salary, and so forth. A document will be indexed
    by the Elasticsearch engine, and they are presented in JSON format. Each document
    is associated with the document type. You can relate a document type with a **Plain
    Old Java Object** (**POJO**) class while a document as an object of POJO class.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An index is a group of documents having a similar structure. You can define
    an **index** for employee data, another for salary data, and so on. An index can
    be identified by a name associated with it. An index name is used for indexing,
    searching along with CRUD operations for the documents it comprises. You can define
    as many indexes as you want. An index is always independent of another index.
    A group of indexes is referred to as indices in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to version 6.0.0, Elasticsearch allowed the creation of multiple document
    types for a given index. For example, you can create document types for users
    and employees (or even more) for index organization. Starting with version 6,
    Elasticsearch put a restriction of allowing only one document type for a given
    index. So, you need to create a separate index for each of the document types.
  prefs: []
  type: TYPE_NORMAL
- en: Clusters and nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch is a distributed system, means it can scale horizontally and runs
    on more than one server to handle a huge amount of data with optimal speed. The
    network of such servers is called a **cluster,** where as the single server is
    referred to as a node.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes and clusters are both identified by name. For nodes, Elasticsearch generates
    a default random **universally unique identifier** (**UUID**) on startup. If you
    wish, you can change the default name. The node name is important as it will help
    to administer the servers associated with the node name.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster name is used by a node to join it. By default, all nodes are associated
    with the cluster with the `elasticsearch` name. You can create as many nodes as
    you want for a given cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Shards and replicas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch stores data in the form of documents, which are grouped into an
    index. In the case of a huge amount of data, the number of documents in a single
    index may cross the limit of the underlying hardware capacity. For example, more
    than a trillion documents stored in a single index may need up to **100 GB** of
    space, which it may not be possible to store in a single node.
  prefs: []
  type: TYPE_NORMAL
- en: As a solution to this problem, Elasticsearch provides a mechanism to break the
    index into multiple pieces; each can be considered a separate index and can be
    stored in multiple nodes. The pieces of an index are called **shards**. This will
    also improve search performance as the search can be performed simultaneously
    on multiple shards.
  prefs: []
  type: TYPE_NORMAL
- en: Replica, as its name suggest, is a copy of shards. They are created for fail
    over; in case one shard is down or goes offline, a replica will be used to provide
    service and make the system highly available.
  prefs: []
  type: TYPE_NORMAL
- en: In short, an index can be divided into multiple shards; each shard can have
    zero or more replicas. So each index has one primary shard, along with zero or
    more replica shards. By default, Elasticsearch associates five primary shards
    for each index along with one replica (as of the latest stable version 6.4.1).
  prefs: []
  type: TYPE_NORMAL
- en: For our Blogpress application, we will keep the default values, a single node
    having an index with default shards and replica settings. The name of the index
    will be `blog`.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch provides a way to interact with it for searching, indexing, and
    performing other CRUD operations. It provides a RESTful API for the interaction,
    so you can use various HTTP methods (`GET`, `POST`, `PUT`, `DELETE`, and so on)
    to deal with any operation on Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch does not maintain the state of the request, and hence each request
    is independent, and information is exchanged in JSON format. Various HTTP methods
    are used to perform CRUD operations on Elasticsearch. For example, a `GET` method
    is used to retrieve the data, while `PUT`, `POST`, and `DELETE` are used to update
    or delete records.
  prefs: []
  type: TYPE_NORMAL
- en: Since Elasticsearch exposes REST APIs, you can use any REST client (for example,
    **Postman**) to work with it. Furthermore, to analyze and visualize the data,
    Elasticsearch provides another free and open source tool called **Kibana**. It
    provides a simple browser-based interface to perform search, view, and other CRUD
    operations along with rich data analysis, presented in a variety of tables, charts,
    and map-like memory, as well as disk utilization, indices, and document information.
    It also helps to manage the indices and document types, perform CRUD operations
    for document data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first install Elasticsearch. Download the Elasticsearch ZIP bundle from
    [https://www.elastic.co/downloads](https://www.elastic.co/downloads). Unzip it
    in your local drive and run `bin/elasticsearch`. By default, it will be available
    on the `9200` port. Once up and running, you can access it with `http://localhost:9200`.
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Kibana from the same [https://www.elastic.co/downloads](https://www.elastic.co/downloads)
    URL. Unzip the bundle and run `bin/kibana`. You can access Kibana on the `5601`
    port, that is, `http://localhost:5601`.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch also provides MSI Installer for Windows, which is a straightforward
    way to install Elasticsearch on a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we quickly look at some of the APIs to perform various activities on Elasticsearch.
    Since Elasticsearch provides REST interface to interact with, you can use any
    REST client, such as Postman. Alternatively, you can use **Kibana** Dev Tools
    to execute REST calls. There is a small difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: We will understand various RESTful API by taking an example of a `student` entity.
    The purpose is to explain how to create a `students` index; create the `student`
    document type; add, update, and delete `student` data; and delete the document
    type and index.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an index – students
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With your REST client (Postman), enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: PUT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: JSON (application/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With Kibana, go to the Dev Tools option in Kibana and type the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d85e406-033f-47e0-bc85-e9021ded34a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created a `student` index without any explicit settings, so Elasticsearch
    has created the index with default settings—five shards and one replica. You can
    see these details in Kibana from the Management option. In case you wish to give
    the precise number of shards and replicas (instead of the default five and one),
    you can add the JSON setting in the body while creating the `student` index as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With REST client (Postman), enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: PUT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: JSON (application/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With Kibana, go to Dev Tools and type the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous case, the index is created with three shards and two replicas.
    This is how you can specify particular settings while creating an index in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a document type – student
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very next thing in the sequence after creating an index is the creation
    of the document type. We will create a document type named `student` within the
    `students` index. Again, it can be done with REST client or with Kibana. We will
    see both options in detail.
  prefs: []
  type: TYPE_NORMAL
- en: With REST client (Postman), enter the following**:**
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/_mapping/student`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: POST'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: JSON (application/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With Kibana, go to Dev Tools option and add the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can use either of these options to create the document type. We have created
    the `student` document type with ID, name, standard, division, and gender properties
    within the `students` index*.* Our structure is ready to add the data into Elasticsearch.
    Next, we will see how to insert the data for `student` type that we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to version 6, Elasticsearch allows creating multiple document types in
    the same index. Starting with 6, they make a restriction of creating only one
    document type within that index.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a document (student data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With REST client (Postman), enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/student/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: PUT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: JSON (application/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With Kibana, go to the Dev Tools option and type the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can verify the inserted data with the following REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a document (student data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With REST client, enter the following**:**
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/student/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: GET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Kibana, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following JSON as an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, it shows the index and document type. The `_id` attribute represents
    the ID that we supplied in the `http:/localhost:9200/students/student/1` URL while
    creating the data. If you use any existing `_id`, Elasticsearch will simply update
    that record with current values. The `_version` attribute represents the number
    of times the records are updated. The `_source` attribute represents the data
    that we supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a document (student data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the data, the same syntax is used as an add document. While adding,
    the ID is not present in the system, if present, the existing data will be updated
    with the value provided. For example, the following command will update existing
    students' record having `_id` equal to five.
  prefs: []
  type: TYPE_NORMAL
- en: With a REST client (Postman), use the following**:**
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/student/5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: POST'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: JSON (application/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With Kibana, go to the Dev Tools and execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inserting and updating operations use similar syntax and if you try to add the
    record with an ID that already exists, then that record will be updated by mistake.
    To avoid this, you can use the `localhost:9200/students/student/1/_create` URL.
    This will throw an error if a record already exists with a `1` ID. Similarly,
    you can use `localhost:9200/students/student/1/_update` in case you wish to update
    the record. It will throw an error if a record does not exist while updating it.
  prefs: []
  type: TYPE_NORMAL
- en: While adding the document record, if you do not provide `_id`, Elasticsearch
    will auto-generate one for you.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a document (student data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting the document is straightforward. You need to use the HTTP `DELETE`
    method. Just specify `_id` of the document you wish to delete, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a REST client (Postman), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/student/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: DELETE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Kibana, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Searching a query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elasticsearch provides a search facility by passing `/_search` at the end of
    the URL. It can be applied after the server URL, the index, or the type. For example,
    in our case, if we want to search a student document having name equals to `nilang`,
    we have to use the query as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a REST client (Postman), use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: `http://localhost:9200/students/student/_search?q=name:nilang`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: GET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Kibana, use**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following syntax for searching. It is quite
    useful for a complex search with multiple search criteria for multiple fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating index and document types for Blogpress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After getting the basics of how the index and document type are created, along
    with inserting document data in Elasticsearch, we will create these artifacts
    for a Blogpress application. In this application, we need to store the data for
    blogs and comments. The blog and comments have a one- to-many relationship (one
    blog has multiple comments), we will create an index structure in such a way that
    multiple comments will be associated with a single blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elasticsearch provides nested data types to index arrays of objects and maintains
    them as an independent document. We will maintain an array of comments for a single
    blog. We will give the index name of `blog` and set the document type, to `blog`.
    The following is a script you can run to create a `blog` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the previous script, we created an index and document type together. The
    element next to `mappings` represents the name of the document type while the
    index name is with the `PUT` HTTP method (`blog` in our case). All properties
    are self-explanatory apart from the comments that are defined as the `nested`
    type, along with their properties. The format of the date can be set with a `format`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch integration with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will configure Elasticsearch as a database to provide various CRUD operations
    for Blogpress applications. We will use Spring Data for this integration. Spring
    Data provides an abstract layer for data access from various providers, such as
    a relational database, a non-relational database, a map-reduced framework, and
    cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these data providers, Spring supplies a set of libraries to interact
    with, while maintaining the abstraction to interact with them in a symmetrical
    manner. Spring Data spans across various modules, including Spring Data Common,
    Spring Data JPA, Spring Data REST, Spring Data LDAP, Spring Data MongoDB, Spring
    Data JDBC, and many more. Spring Data Elasticsearch is one of them t provide data
    access with Elasticsearch search engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Spring Data Elasticsearch module for the Blogpress application.
    The very first thing is to make this module available in our application. Unsurprisingly,
    this can be done by defining a starter in `pom.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Elasticsearch provides a Java API to interact with it programmatically. Soon
    after you activate the above starter, the required JARs will be added in the classpath
    to access the Elasticsearch Java API. At this moment, we need to instruct the
    Spring Data Elasticsearch module about the cluster name, port, and hostname on
    which the Elasticsearch server is running. You can define these configurations
    in the `application.properties` file (in the `src/main/resource` folder) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to defining a database URL, the driver class name, and credentials
    for database interaction with Spring Data. The next step is to define a configuration
    class, which basically uses the previous details and prepares the required artifacts
    to interact with Elasticsearch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This class reads the cluster name, port, and host values defined in the `application.properties`
    file with the `@Value` annotation. The `client()` method uses the `TransactionClientFactory`
    object to read the configuration data and return an object of the `TransportClient`
    class, which represents the client interface to interact with Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: The next `elasticsearchTemplate()` method uses this client object and creates
    the `ElasticsearchTemplate` object. Spring provides the data access template class
    for each of the data providers. The object of the `ElasticsearchTemplate` class
    is initialized with the object of the `TransportClient` class. This method is
    defined with the `@Bean` annotation so that the object of `ElasticsearchTemplate`
    is accessible with the `@Autowired` annotation to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: This initialization happens when starting an application. The `ElasticsearchTemplate`
    class is the single point of interaction of the Elasticsearch engine with Spring
    Data. The `@EnableElasticsearchRepositories` annotation in this class is used
    to point the Spring JPA repository package that we are going to define next. Before
    that, we will first define a model class that represents a document in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Elasticsearch model class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data facilitate the **Data Access Object** (**DAO**) layer implementation
    for the various data providers. The DAO mechanism makes the system loosely coupled
    by providing data access abstraction, allowing the changes in the underlying data
    provider without affecting the business implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows the interaction with the data layer in an object-oriented manner.
    It means you can create, read, update, and delete the data with an entity class
    object. This abstraction is also applicable for the Spring Data Elasticsearch
    module. You can access the data in the form of objects. For this, we need to define
    a model (entity) class that represents the data structure that we defined in Elasticsearch
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The model class is a POJO with a `@Document` annotation, which defines the index
    and document type name this class is associated with. The objects of the `Blog`
    class previously represent the document data for the `blog` index and the `blog`
    document in Elasticsearch. The `@Id` annotation is used to define a unique id
    for blog documents. You can relate it to the primary key in the relational database.
    The date fields are defined with the `@JsonFormat` annotation, which is used to
    define the desired date format.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Field` annotation is used to define additional metadata about the field.
    For example, in the case of comments, it is defined as a `nested` type as there
    is no direct mapping of Elasticsearch `nested` types available in Java. For other
    properties, the Java types are directly mapped with Elasticsearch types. Next,
    we will define a DAO layer with Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: The date format that we mentioned in the mapping script should be exactly matched
    with the date format defined in the POJO class with the `@JsonFormat` annotation.
    If not, the system will show an error while inserting the record.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Elasticsearch with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data has a concept called a **repository** that is an abstraction of
    a data store. Designed to add an additional layer, it brings great power and flexibility
    by making the repository abstraction and providing the concrete implementation
    of repositories (with all boilerplate code) for each of the data providers.
  prefs: []
  type: TYPE_NORMAL
- en: For Elasticsearch, Spring Data provides a repository interface called `ElasticsearchRepository`.
    This interface (and its parent interface) has all the required methods to interact
    with Elasticsearch. To reap the benefits of Spring Data, we need to extend this
    interface so that Spring Data supplies concrete implementation on the fly automatically.
    Apparently, all the required CRUD methods are available in standard DAO out of
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s leverage Spring Data capabilities for Elasticsearch for the Blogpress
    application. First, let''s define the custom repository interface that extends
    `ElasticsearchRepository<T, ID extends Serializable>`, where `T` represents an
    entity class and `ID` represents a unique ID in the entity class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Blog` entity class has `_Id` (a string) as a unique identifier (declared
    with the `@Id` annotation). Our DAO layer with all basic CRUD operations is ready.
    It is always a good idea to define the service class, presenting the service layer.
    So we will declare the `BlogService` service class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With the `@Autowired` annotation, Spring will inject the object of `BlogRepository`
    into our service class, which can be used to perform various CRUD operations.
    Next, we can start performing CRUD operations for blog data in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations in Elasticsearch with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic structure of DAO and the service layer is ready. We can now start
    performing CRUD operations. As we have seen, just by declaring a custom repository
    interface, Spring provides all basic CRUD operations in the DAO layer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding blog data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new blog record. For that, add method in `BlogService`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The object of `BlogRepository` is injected by Spring and can be used to perform
    an add operation. This service method should be called from Spring controller.
    Add the following methods in controller class to manage the functionality of adding
    (or updating) new blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `showAddNew()` method simply opens the `add-new.html` Thymeleaf template.When
    a user clicks on the Add New link from navigation, this method will be called
    and will show this template where the user can add a new blog with a title and
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method—`addNew`, which is declared with the `@PostMapping` annotation
    takes a `title` and `body` as request parameters, creates an object of a `Blog`
    type, sets those values and call the `addNewBlog()` method of service class. You
    can execute the following query in Kibana to see the inserted data in Elasticsearch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Reading blog data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next is to show the blog entries on the home page in a tabular format. When
    a user clicks on it, the system will open the blog in am detailed view (showing
    the title, full body, and all comments). To list blogs on the home page, we will
    fetch the blog data from Elasticsearch programmatically. Add the following method
    in the `BlogService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `getAllBlogs()` method simply calls the `findAll()` method on `blogRepository`
    to get all blog entries. This service method can be called from the controller
    to show these data on the home page. Instead of a regular controller, we will
    use the REST controller to showcase how we can leverage the Spring REST controller
    to present the data. We will cover this in a short while, so keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: It is always advisable to use the repository method with pagination. Since the
    purpose of this chapter is to showcase various components and how they work, I
    have not used the pagination to make things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Searching blog data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this is a blog application, search is an obvious feature. We will allow
    a user to search the blogs by matching the search text with blog title and body.
    We can search the documents by passing `/_search` at the end of the URL. Elasticsearch
    provides a Boolean query to search the data based on various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the search text should be matched with either title or body or
    both. It can be achieved through a Boolean search query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `should` criteria is equivalent to the *OR* condition. Elasticsearch provides
    the `must` criteria, in case if you want to search with the *AND* condition. You
    can specify as many attributes as you want. The string `java` is the search text.
    This query can be written programmatically in Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a Boolean query and configure the search text with the title
    and body attribute. The search result will be returned back in JSON format with
    the `response` object. You can parse the JSON to get the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comment data with Elasticsearch aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The blog has been added to the system. Now a user can add a comment. So next,
    we will see how to add a comment. As discussed, the `Comment` document type is
    defined as a `nested` type in the blog document. It means the blog document contains
    an array of comment objects, making a one-to-many relationship. We also need to
    create a comment model class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is nested within a blog, there is no need to define the `@Document`
    annotation as it is not directly associated with any document type. While adding
    the comment, there is certain metadata that needs to be taken care of, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are providing the comment with reply functionality. Once a user does reply
    to any comment, it will be added one level down, considering it as child comment.
    To maintain this, we use the `level` attribute, which simply shows at which level
    this comment is placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `blogId` attribute simply holds the ID of a blog with which this comment
    is associated. Since this is a nested object, in most of the cases, it is not
    required to have a parent document ID. But we are going to show the comment list
    to an admin user to moderate and reply back. To make comment administration simple,
    we have just added `blogId` in the comment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `parentId` attribute holds the ID of parent comment, if it is placed as
    a reply, or else it will be zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `childSequence` attribute simply shows the sequence number at a particular
    level. For example, if there are total two replies (at the second level) and a
    user tries to add a third reply (at the second level), then the `childSequence`
    attribute will be three. This attribute is used to construct a value of the `position`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position` attribute will be combination of `level` and `childSequence`.
    This is used to sort the comments so that they are displayed in the correct order
    for a given blog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since a comment is a `nested` type of blog, there is no such method to save
    only comments. Instead, we need to fetch all comments, add the new one to the
    associated blog, and then save the whole blog. Everything is straightforward,
    except getting the value of `childSequence`. We will see how to get maximum `childSequence`
    in a given level with the following aggregate query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can understand the query, we need to look at what aggregation is.
    In Elasticsearch, an aggregation is a mechanism used to provide aggregated data
    on a search query. They are used to compose complex queries. They come under four
    categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bucketing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these aggregation types can be used in a nested fashion, meaning it
    can be used as a sub-aggregation to another, to solve very complex queries. Now,
    let's go back to the query to find `childSequence` and understand it.
  prefs: []
  type: TYPE_NORMAL
- en: The very first `query` criteria matches the value against `blogId` (`_id`).
    Any attribute given to the `query` criteria in the beginning will match its value
    against the `blog` attribute. The next is the aggregate query that is applied
    to the `nested` document—`comments`. Each aggregate query has a name. The first
    aggregate query has the `aggChild` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, the next aggregate query with the `filterParentId` name simply
    matches `parentId`, which is nothing but the parent comment ID. It is required
    to find `childSequence` under given a comment as a parent comment. For top-level
    comments, this must be zero. The last aggregate query with the `maxChildSeq` name
    simply finds the maximum of `childSequence`. It uses maximum criteria. Each `nested`
    aggregate query simply applies the search criteria to results given by the preceding
    aggregate query. You will get results of this query similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The query result contains other information, but we will only focus on `aggregation`.
    The result shows a document count at each aggregate query. The value of `maxChildSeq`
    is three means there are three comments at level one (top-level comment), so when
    a user adds a new (top-level) comment, `childSequnce` will be four.
  prefs: []
  type: TYPE_NORMAL
- en: This was the REST-based query. For the Blogpress application, we need to execute
    similar queries in the Java class. Elasticsearch provides Java APIs to perform
    anything that can be done through REST query. When we define a starter for Elasticsearch
    in Spring Boot, the required Elasticsearch JAR files are available in the classpath.
    To write the preceding query with Java APIs, we need to write a custom fetch method
    in our Elasticsearch repository.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data is an extensible framework, allowing us to provide customized implementation
    of a repository on top of what it provides out of the box. So first we will extend
    the Elasticsearch repository with following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Define a custom repository interface called `BlogRepositoryCustom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `BlogRepository` interface that we created initially should extend this
    interface, along with `ElasticsearchRepository<Blog, String>`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the custom repository implementation class that implements the `BlogRepositoryCustom`
    interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This class must be declared with the `@Repository` annotation. We can define
    any custom method in this class. We want to write a method with an Elasticsearch
    Java API to find the maximum child sequence at a given level, so we will write
    it in this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `AggregationBuilders` class is used to construct an aggregate query. The
    Elasticsearch Java API is self-explanatory and simple. You can easily relate this
    Java API query with a REST query. We first create a nested aggregate query and
    then add a filter aggregate query as a sub-aggregation followed by a `max` aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `blogId` is added with a `TermQueryBuilder` class. Finally, we
    get an Elasticsearch client from `elasticsearchTemplate` and initiate search by
    providing an index name (`blog`), a document type (`blog`), a root level query
    (for `blogId`), and at the end setting the aggregations. This Java API returns
    the aggregation JSON that we got for REST query, which you can process with a
    JSON API to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Reading comment data with Elasticsearch aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once comments are added, they must be visible when the user opens the blog.
    This scenario is straightforward. Since comments are nested objects of a blog,
    when we read a blog with the following API, all its comments are also available
    as part of the blog object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `findById` method is provided out of the box by a default repository implementation,
    available during runtime. We pass `blogId`, and it will fetch all details of the
    blog along with comments (as nested objects).
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario for reading comment is the admin user opens the manage-comment
    page, where all comments are displayed for moderation purposes. In this case,
    the system will show all comments added to any of the blogs, so it is necessary
    to bring all comments from all blogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way of achieving this is to fetch all blogs, take the comments, and
    append them to build the comments list. But this is not an ideal solution as it
    requires many things to be done manually. We can use Elasticsearch aggregation
    queries to do this. By default, the `nested` objects cannot be fetched directly
    as a parent object, so it requires aggregation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This query has the `top_hits` aggregation, which simply lists all `nested` objects.
    We need the data in descending order of `createdDate` (recently added should be
    placed on top), so sorting criteria is added. The `from` and `size` criteria are
    used for pagination. The `from` criteria represents the offset from first record,
    while `size` shows the total record per page.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `top_hits` will return three records if you have not provided the `size` value.
    Also, the maximum allowed size is 100 so while using `top_hits`, you have to use
    pagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'This query returns the result. Aggregation data for full results is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write the previous query with the Elasticsearch Java API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is self-explanatory. First, we are creating a nested aggregation
    query with `AggregationBuilders` and adding the sub-aggregation of the `top_hits`
    type, along with sorting criteria with the `from` and `size` settings. The process
    of getting a response is identical to what we used in the method to get the maximum
    child sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we need to display comments with a specific status value, we can use
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The term aggregation query has been added which checks the value of the status
    field. You can use a wildcard (`*`) for matching criteria, for example, `A*` will
    match all statuses starting with `A`. The equivalent Java API appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Updating and deleting comment data with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating a `nested` object is straightforward. Elasticsearch does not provide
    a direct way to update a specific `nested` object. Instead, you need to fetch
    all the `nested` objects from the root document, find the particular `nested`
    object (possibly by some unique identifier), update it, assign the `nested` object
    list back to the root document, and save the root document. For example, we can
    update the status for specific comment (`nested`) objects of a blog with the following
    method. It is defined in the service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Deleting of a comment is similar. Just remove the required comment object from
    the list and save the blog object to delete the comment.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of achieving a one-to-many relationship in Elasticsearch is through
    the parent-child structure. However, it is slower than the `nested` objects. The
    only drawback with the `nested` object is whenever any `nested` object is updated,
    the root document needs to be re-indexed. But due to retrieval of data, this is
    comparatively fast, and the `nested` objects are preferred to the parent-child
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: We have understood how to interact with Elasticsearch and fetch data. Next we
    will see how to display those data at the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data with RESTful web services in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides RESTful web service implementations with its web MVC module.
    With each annotation, the creation of a REST web service is more or less like
    web MVC architecture. The RESTful web services can be built with the help of a
    REST controller. The noticeable difference between a web MVC and REST controller
    is the way they create the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A traditional web MVC uses various view technologies (such as JSP, Thymeleaf,
    and so on) to build a response, while the REST controller returns objects that
    are converted into JSON (or XML, based on the configuration), and finally sent
    as a HTTP response. For our Blogpress application, we will use RESTful services
    in the following two use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing blog lists on the home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing blog comments when a particular blog is open for view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this, we will write new controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The REST controller must be defined with the `@RestController` annotation. Since
    we have two controllers now (one is the normal web MVC , and the second is the
    REST controller), we defined request mapping with `@RequestMapping` to differentiate
    the URL pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RequestMapping` annotation defines the method URL, HTTP method name and
    MIME type of the output this method produces. The `getAllBlogJSON()` method gets
    list of `Blog` objects and sends it with `ResponseEntity`, along with the HTTP
    response code. The `ResponseEntity` class represents the response body, header,
    and status code, and this class is used to prepare the HTTP response. To use it,
    the only thing required is to define it as return type of method (end point).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the `@ResponseBody` annotation (at method level) can be used
    to produce a HTTP response. `ResponseEntity` does exactly same as `@ResponseBody`
    , but provides some additional features, including setting the HTTP response code
    so it is better.
  prefs: []
  type: TYPE_NORMAL
- en: The `ResponseEntity` type is generic, so you can send any type of object with
    it. Both methods return the objects of `Blog` and `Comment`, respectively. Spring
    automatically converts the object list into a JSON string and returns it as a
    HTTP body. The `MediaType` class provides various mime types. The first method
    is accessible with the`http://localhost:8080/api/listBlogs` URL, and the second
    method with `http://localhost:8080/api/listAllComments`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will see how to present this data with a presentation layer. For our
    Blogpress application, we used the Thymeleaf template to construct a view layer.
    Thymeleaf templates are processed at server side. We will use another template
    engine called **Mustache** for client-side processing.
  prefs: []
  type: TYPE_NORMAL
- en: Building a UI with the Mustache template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mustache is a web template available for many languages, like JavaScript,
    Ruby, PHP, Python, Perl, Android, C++, Java, and so on, with a language-specific
    implementation. In our Blogpress application, we will use Mustache for JavaScript,
    so we need to include `Mustache.js` in the Blogpress application. Let's first
    understand the use case where `Mustache.js` is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite often, to show dynamic values in HTML, we mix the data with HTML fragments
    and then update the DOM markup to show the final output. The following is the
    sample example for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This kind of code not only creates a maintenance nightmare, but it mixes the
    UI and dynamic data logic together, thus causing tight coupling between them.
    This prevents the code being reused and breaks the separation of the concern principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best solution for this kind of problem is to use some sort of HTML template.
    There are many client-side HTML template engines available today, `Mustache.js`
    is one of them, and we have chosen it to construct a few of the pages for our
    Blogpress application. Let''s see how it works by taking a very simple example
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This example is self-explanatory. The template has been defined with `<script>`
    of the `text/template` type. With `Mustache.js`, we are reading the template and
    passing the `student` object. In the template, the **`{{...}}`** notation is used
    to insert dynamic values. This not only makes the code clear, but can accommodate
    any future change with ease.
  prefs: []
  type: TYPE_NORMAL
- en: '`Mustache.js` is a logic-less template, which means it does not contain procedural
    statements such as if-else, for, and so on, but we can use tags to achieve some
    sort of loop and conditional. For our Blogpress application, we are using `Mustache.js`
    in the following two pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Home page to show all blogs in list format with minimal information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage Comment page where all comments are listed for moderation and reply for
    the admin user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we will deal with the home page where all blogs are shown in list format.
    The following is the code for the Mustache template on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first script tag defines the template with the `text/template` type. The
    `{{#blogs}}` and `{{/blogs}}` expressions are evaluated in two ways. If a blog
    key exists and has a false value or empty list (if it's a type of array), the
    HTML code in between will not be displayed. If it's true or a non-empty list (array),
    then it will render the in-between HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we want to show the blog list with the `Mustache.js` template.
    The data is populated from a REST web service (which eventually calls a REST controller)
    through Ajax. If successful, the data is stored in the `blogData` object with
    `blogs` as a key. This key is used in the `Mustache.js` template (`{{#blogs}}
    ....{{/blogs}}`) to iterate the blog array. The individual attribute is placed
    with the `{{...}}` expression. For example, `{{body}}` will display a value of
    a body attribute from the blog object. `Mustache.render` takes the template and
    data, and produces the final output that is appended in `div` with the `blogList`
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used `th:inline` in the second script tag. This is a Thymeleaf tag.
    In case you need to substitute the value in the script tag, you need to define
    it with `th:inline`. The Thymeleaf value can be inserted with the `/*[[,,,]]*/`
    notation. In this case, we are passing a dynamic URL so we have used `@{/api/listBlogs}`
    inside `/*[ .. ]*/` (so that the final URL would be `http://localhost:8080/api/listBlogs`).
    This will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1a2c38c-d19c-4c64-893e-6d6686375599.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another page is the managed comment page where the comments are displayed with
    the `Mustache.js` template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This template is similar to what we have seen for blog lists on the home page.
    The additional thing here is the population of the `showApproveReject` and `showReply`
    attributes with the `true` value. Since Mustache is a logic-less template, there
    is no direct provision for a conditional statement, such as if-else. The only
    way of adding a condition is with the `{{#attribute}} ... {{/attribute}}` expression,
    where it will check if an attribute key is available and set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In the Manage Comment page, each comment is listed for admin moderation. If
    a comment status is M (moderate), the system shows buttons—Approve and Reject.
    If it is approved (status A) then the system will show an option to Reply to the
    comment. With the `Mustache.js` template, we cannot directly check the status
    value. So, two additional keys (`showApproveReject` and `showReply`) are added
    in the comment object and set it to `true`, based on the value of the status.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4215b73-53c5-4a3d-8936-e85149e29746.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been on a long journey. There is no better way to build an application
    than taking a real-life scenario and learning about the underlying concepts, tools,
    and technology. In this chapter, we took a blog application and built various
    layers with a set of frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the Spring Framework as a foundation, we began our journey with Spring
    Boot—a rapid tool to propel the development, with all the underlying configuration
    to be done with a kind of auto-mode. We framed the first layer with the Spring
    MVC web framework in conjunction with Thymeleaf. Being a natural template engine,
    Thymeleaf is another way of constructing a view layer. We built the authentication
    and authorization, a very important part of the application, with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the data source of the Blogpress application with Elasticsearch—an
    open source highly scalable search engine, mainly used for indexing and analyzing
    purposes. After exploring basic concepts, we learned how to create an index, document
    type, and add the document data, followed by how to search them in Elasticsearch,
    by taking a sample of a `student` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on further, we learned to create the data structure with a nested object
    for our Blogpress application. Inserting data into and retrieving it from the
    nested object with various searching and aggregation mechanisms were the main
    crux of the data layer we implemented in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a further step to bridge the persistence layer developed in Elasticsearch
    with the front-facing layer in Spring MVC, we used the Spring Data module. Then
    we leveraged the extension capabilities of the Spring Data framework to implement
    customized queries with the Elasticsearch Java API. In the end, we saw how the
    client-side template engine `Mustache.js` is useful to solve the problem of mixing
    the logic of dynamic data with HTML fragments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on making the application secure with Spring
    Security. We will talk more about the integration of Spring Security with OAuth
    2—a widely used protocol for authorization. We will also look at **Lightweight
    Directory Access Protocol** (**LDAP**) integration with Spring Security to build
    a central application that supports authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
