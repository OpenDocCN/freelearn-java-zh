["```java\npublic class MovieTicketPro {\n\n public void book(Movie movie, ShowTime time, int noOfTickets) {\n  MovieDao dao = new MovieDao();\n  MovieHall hall = dao.findMovie(movie, time);\n  if (hall != null) {\n    List<String> seats = dao.getAvilableSeats(movie, time);\n    if (seats.size() < noOfTickets) {\n      BookingErrorController.createAndShowTicketNotAvailableError();\n      return;\n    }\n    int booked = 0;\n    String bookedSeats = \"\";\n    for (String aSeat : seats) {\n      try {\n        dao.book(hall, time, aSeat);\n        bookedSeats += \" \" + aSeat;\n        booked++;\n        if (booked == noOfTickets) {\n          BookingErrorController.createAndShowBookedMsg(bookedSeats);\n          break;\n        }\n      } catch (BookingException e) {\n        if (e.getType().equals(ErrorType.SeatAlreadyBooked)) {\n          BookingErrorController.createAndShowTicketNotAvailableError();\n          if (BookingErrorController.createAndShowAdjacentSeatsNotAvaialble()){\n            continue;\n          }\n          break;\n        }\n      } catch (Exception e) {\n        BookingErrorController.createAndShowDatabaseSaveError();\n        break;\n      }\n    }\n  }else{\n    BookingErrorController.createAndShowMovieOrShowTimeNotAvailableError();\n  }\n}\n```", "```java\npublic class BookingErrorController {\n  public static void createAndShowTicketNotAvailableError() {\n    JOptionPane.showMessageDialog(null, \"Ticket is not available\",\"Booking message\",  JOptionPane.WARNING_MESSAGE);\n  }\n\n  public static void createAndShowDatabaseSaveError() {\n    JOptionPane.showMessageDialog(null, \"Could not book ticket\",  \"Booking Error\", JOptionPane.ERROR_MESSAGE);\n  }\n\n  public static void createAndShowBookedMsg(String seats) {\n    JOptionPane.showMessageDialog(null, \"Following tickets\" + seats+ \" Booked\", \"Booking Info\", JOptionPane.ERROR_MESSAGE);\n  }\n  //other methods are ignored for brevity \n}\n```", "```java\nMovieDao dao = new MovieDao();\n```", "```java\npublic class MovieTicketProTest {\n  MovieTicketPro movieTicketPro= new MovieTicketPro();\n\n  @Test\n  public void sanity() throws Exception {\n    movieTicketPro.book(null, null, 1);\n  }\n\n}\n```", "```java\npackage com.packt.legacy;\n\npublic interface ErrorMessageDisplayer {\n  void showMessage(String title, String message, int messageType);\n  boolean showConfirmMessage(String title, String message);\n}\n```", "```java\npublic class BookingErrorController implements ErrorMessageDisplayer{\n\n  @Override\n  public void showMessage(String title, String message, int messageType) {\n    JOptionPane.showMessageDialog(null, message, title, messageType);\n  }\n\n  @Override\n  public boolean showConfirmMessage(String title, String message) {\n    int output = JOptionPane.showConfirmDialog(null,message, title, JOptionPane.YES_NO_OPTION);\n    return output == JOptionPane.YES_OPTION;\n  }\n  //other methods are ignored for brevity\n}\n```", "```java\n} catch (Exception e) {\n      JOptionPane.showMessageDialog(null, \"Could not book ticket\", \"Booking Error\", JOptionPane.ERROR_MESSAGE);\n      break;\n    }\n  }\n}else {\n  JOptionPane.showMessageDialog(null, \"Movie or showtime not available\",\"Booking message\", JOptionPane.WARNING_MESSAGE);\n}\n```", "```java\n  protected ErrorMessageDisplayer getErrorMessageDisplayer() {\n    return new BookingErrorController();\n  }\n```", "```java\npublic class MovieTicketPro {\n  public void book(Movie movie, ShowTime time, int noOfTickets) {\n    MovieDao dao = new MovieDao();\n    MovieHall hall = dao.findMovie(movie, time);\n    if (hall != null) {\n      List<String> seats = dao.getAvilableSeats(movie, time);\n      if (seats.size() < noOfTickets) {\n        getErrorMessageDisplayer().showMessage(\"Booking message\",          \"Ticket is not available\", JOptionPane.WARNING_MESSAGE);\n       return;\n      }\n      int booked = 0;\n      String bookedSeats = \"\";\n      for (String aSeat : seats) {\n        try {\n          dao.book(hall, time, aSeat);\n          bookedSeats += \" \" + aSeat;\n          booked++;\n          if (booked == noOfTickets) {\n            getErrorMessageDisplayer().showMessage(\"Booking Info\",             \"Following tickets\" + bookedSeats + \" Booked\",              JOptionPane.ERROR_MESSAGE);\n            break;\n          }\n        } catch (BookingException e) {\n          if (e.getType().equals(ErrorType.SeatAlreadyBooked)) {\n            getErrorMessageDisplayer().showMessage(              \"Booking message\", \"Ticket is not available\",              JOptionPane.WARNING_MESSAGE);\n            boolean yes = getErrorMessageDisplayer().showConfirmMessage(\"Booking message\",\"Adjacent seats not available.Can I book any other seat?\");\n\n            if (yes) {\n              getErrorMessageDisplayer().showMessage(\"Booking information\",\"Going to auto allocate seats.\", JOptionPane.INFORMATION_MESSAGE);\n              break;\n            }\n\n          }\n      } catch (Exception e) {\n        getErrorMessageDisplayer().showMessage(\"Booking Error\",\"Could not book ticket\", JOptionPane.ERROR_MESSAGE);\n        break;\n      }\n    }\n  } else {\n    getErrorMessageDisplayer().showMessage(\"Booking message\",\"Movie or showtime not available\",JOptionPane.WARNING_MESSAGE);\n    }\n  }\n\n  protected ErrorMessageDisplayer getErrorMessageDisplayer() {\n    return new BookingErrorController();\n  }\n}\n```", "```java\ngetErrorMessageDisplayer() method to return a ErrorMessageDisplayer mock. We can verify the error messages indirectly from the mock object arguments:\n```", "```java\n@RunWith(MockitoJUnitRunner.class)\npublic class MovieTicketProTest {\n  @Mock   ErrorMessageDisplayer messageDisplayer;\n\n  MovieTicketPro movieTicketPro = new MovieTicketPro() {\n    protected ErrorMessageDisplayer getErrorMessageDisplayer() {\n return messageDisplayer;\n }\n  };\n  @Test   public void when_invalid_movie_shows_error_message(){\n    movieTicketPro.book(null, null, 1);\n    ArgumentCaptor<String> stringArgCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<Integer> intArgCaptor = ArgumentCaptor.forClass(Integer.class);\n\n    verify(messageDisplayer).showMessage(stringArgCaptor.capture(), stringArgCaptor.capture(), intArgCaptor.capture());\n assertEquals(\"Movie or showtime not available\", stringArgCaptor.getAllValues().get(1));\n  }\n}\n```", "```java\n  protected MovieDao getMovieDao() {\n    return new MovieDao();\n  }\n  public void book(Movie movie, ShowTime time, int noOfTickets) {\n    MovieDao dao = getMovieDao();\n    //code ignored for brevity\n  }\n```", "```java\n@RunWith(MockitoJUnitRunner.class)\npublic class MovieTicketProTest {\n  @Mock ErrorMessageDisplayer messageDisplayer;\n @Mock MovieDao movieDao;\n\n  MovieTicketPro movieTicketPro = new MovieTicketPro() {\n    protected ErrorMessageDisplayer getErrorMessageDisplayer() {\n      return messageDisplayer;\n    }\n\n    protected MovieDao getMovieDao() {\n return movieDao;\n }\n  };\n  }\n\n```", "```java\npublic class TestingUnfavorableConstructor {\n  private DatabaseDependency dependency1;\n  private FileReadDependency dependency2;\n\n  public TestingUnfavorableConstructor() {\n    this.dependency1 = new DatabaseDependency();\n    this.dependency2 = new FileReadDependency();\n  }\n\n  public Object testMe(Object arg) {\n    return arg;\n  }\n\n}\n```", "```java\npublic class TestingUnfavorableConstructor {\n  private DatabaseDependency dependency1;\n  private FileReadDependency dependency2;\n\n  public TestingUnfavorableConstructor() {\n    createDependencies();\n  }\n\n  protected void createDependencies() {\n    this.dependency1 = new DatabaseDependency();\n    this.dependency2 = new FileReadDependency();\n  }\n\n  public void setDependency1(DatabaseDependency dependency1) {\n    this.dependency1 = dependency1;\n  }\n\n  public void setDependency2(FileReadDependency dependency2) {\n    this.dependency2 = dependency2;\n  }\n\n  public Object testMe(Object arg) {\n    return arg;\n  }\n}\n```", "```java\n@RunWith(MockitoJUnitRunner.class)\npublic class TestingUnfavorableConstructorTest {\n  @Mock DatabaseDependency dep1;\n  @Mock FileReadDependency dep2;\n  TestingUnfavorableConstructor unfavorableConstructor;\n  @Before  public void setUp() {\n    unfavorableConstructor= new TestingUnfavorableConstructor() {\n protected void createDependencies() {\n }\n };\n\n    unfavorableConstructor.setDependency1(dep1);\n    unfavorableConstructor.setDependency2(dep2);\n  }\n\n  @Test   public void sanity() throws Exception {\n  }\n}\n```", "```java\nPublic class VariableInitialization {\n  DatabaseDependency dependency1 = new DatabaseDependency();\n  public void testMe(Object obj) {\n\n  }\n}\n```", "```java\npublic class VariableInitializationTest {\n  VariableInitialization initialization;\n\n  @Before public void setUp() throws Exception {\n    initialization = new VariableInitialization();\n  }\n  @Test   public void sanity() throws Exception {\n  }\n}\n```", "```java\npublic class PrivateMethod {\n  public Object validate(Object arg) {\n    if(arg == null) {\n      showError(\"Null input\");\n    }\n    return arg;\n  }\n\n  private void showError(String msg) {\n    GraphicalInterface.showMessage(msg);\n  }\n}\n```", "```java\npublic class PrivateMethodRefactored {\n  public Object validate(Object arg) {\n    if(arg == null) {\n      showError(\"Null input\");\n    }\n\n    return arg;\n  }\n\n  protected void showError(String msg) {\n    GraphicalInterface.showMessage(msg);\n  }\n}\n```", "```java\npublic class PrivateMethodRefactoredTest {\n\n  PrivateMethodRefactored privateMethod;\n\n  @Before\n  public void setUp() {\n    privateMethod = new PrivateMethodRefactored() {\n      protected void showError(String msg) {\n\n      }\n    };\n  }\n\n  @Test\n  public void validate() throws Exception {\n    privateMethod.validate(null);\n  }\n}\n```", "```java\npublic class FinalDependency {\n\n  public final void doSomething() {\n    throw new TestingImpedimentException(\"Final methods cannot be overriden\");\n  }\n}\n```", "```java\npublic class FinalMethodDependency {\n\n  private final FinalDependency dependency;\n\n  public FinalMethodDependency(FinalDependency dependency) {\n    this.dependency = dependency;\n  }  \n  public void testMe() {\n    dependency.doSomething();\n  }\n}\n```", "```java\n@RunWith(MockitoJUnitRunner.class)\npublic class FinalMethodDependencyTest {\n  @Mock\n  FinalDependency finalDependency;\n  FinalMethodDependency methodDependency;\n\n  @Before\n  public void setUp() {\n    methodDependency = new FinalMethodDependency(finalDependency);\n  }\n\n  @Test\n  public void testSomething() throws Exception {\n    methodDependency.testMe();\n  }\n}\n```", "```java\n  @Test\n  public void testSomething() throws Exception {\n    doNothing().when(finalDependency).doSomething();\n    methodDependency.testMe();\n  }\n```", "```java\npublic class SingletonDependency {\n  private static SingletonDependency singletonDependency;\n\n  private SingletonDependency() {\n  }\n\n  public synchronized static SingletonDependency getInstance() {\n    if (singletonDependency == null) {\n      singletonDependency = new SingletonDependency();\n    }\n\n    return singletonDependency;\n  }\n\n  Public static void callMe() {\n    throw new TestingImpedimentException(\"we dont need singleton\");\n  }\n}\n```", "```java\npublic class VictimOfAPatternLover {\n  private final SingletonDependency dependency;\n\n  public VictimOfAPatternLover(SingletonDependency dependency) {\n    this.dependency = dependency;\n  }\n\n  public void testMe() {\n    dependency.callMe();\n  }\n}\n```", "```java\n  public static void callMe() {\n    throw new TestingImpedimentException(\"Common we dont need singleton\");\n  }\n\n  protected void wrapper() {\n    callMe();\n  }\n```", "```java\n  public void testMe() {\n    dependency.wrapper();\n  }\n```", "```java\n@Test\n  public void testMe() throws Exception {\n    Mockito.doNothing().when(dependency).wrapper();\n    aPatternLover.testMe();\n  }\n```", "```java\npublic final class FinalDepencyClass {\n\n  public void poison() {\n    throw new TestingImpedimentException(\"Finals cannot be mocked\");\n  }\n}\n```", "```java\npublic class FinalClassDependency {\n  private final FinalDepencyClass finalDepencyClass;\n\n  public FinalClassDependency(FinalDepencyClass     finalDepencyClass) {\n    this.finalDepencyClass = finalDepencyClass;\n  }\n\n  public void testMe() {\n    finalDepencyClass.poison();\n  }\n}\n```", "```java\n@RunWith(MockitoJUnitRunner.class)\npublic class FinalClassDependencyTest {\n  @Mock\n  FinalDepencyClass finalDependency;\n\n  FinalClassDependency test;\n\n  @Before\n  public void setUp() {\n    test = new FinalClassDependency(finalDependency);\n  }\n  @Test\n  public void testMe() throws Exception {\n    Mockito.doNothing().when(finalDependency).poison();\n    test.testMe();\n  }\n}\n```", "```java\npublic class PoisonIvy {\n\n  public PoisonIvy() {\n    throw new TestingImpedimentException(\n      \"Do not instantiate concrete class, use interfaces\");\n  }\n\n  public void poison() {\n\n  }\n}\n```", "```java\npublic class NewExpressionDependency {\n\n  public void testMe() {\n    PoisonIvy ivy = new PoisonIvy();\n    ivy.poison();\n  }\n}\n```", "```java\npublic class StaticBlockOwner {\n  private static StaticBlockDependency blockDependency;\n  static {\n    blockDependency = new StaticBlockDependency();\n    blockDependency.loadTime = new Date();\n  }\n  public void testMe() {\n  }\n}\n```", "```java\npublic class StaticBlockOwnerTest {\n  StaticBlockOwner owner;\n  @Before public void setUp()  {\n    owner = new StaticBlockOwner();\n  }\n  @Test   public void clean() throws Exception {\n    owner.testMe();\n  }\n}\n```", "```java\n      @Test\n      public void when_one_opinion_then_result_forecasts_the_opinion() {\n        new SurveyResultCompiler().willVoteFor(\"Party A\");\n      } \n    ```", "```java\n      @Test\n      public void when_one_opinion_then_result_forecasts_the_opinion() {\n        SurveyResultCompiler surveyResultCompiler = new     \n            SurveyResultCompiler();\n        surveyResultCompiler.willVoteFor(\"Party A\");\n        Map<String, BigDecimal> result \n          =surveyResultCompiler.forecastResult();\n      }\n    ```", "```java\n    public class SurveyResultCompiler {\n      public void willVoteFor(String opinion) {\n      }\n      public Map<String, BigDecimal> forecastResult() {\n        return null;\n      }\n    }\n    ```", "```java\n    @Test\n    public void when_one_opinion_then_result_forecasts_the_opinion() {\n      SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();\n      String opinion = \"Party A\";\n      surveyResultCompiler.willVoteFor(opinion);\n\n      Map<String, BigDecimal> result =surveyResultCompiler.forecastResult();\n\n     assertEquals(new BigDecimal(\"100\"), \n     result.get(opinion));\n    }\n    ```", "```java\n      public Map<String, BigDecimal> forecastResult() {\n        Map<String, BigDecimal> result = new HashMap<String, BigDecimal>();\n     return result;\n      }\n    ```", "```java\n      public Map<String, BigDecimal> forecastResult() {\n        Map<String, BigDecimal> result = new HashMap<String, BigDecimal>();\n        result.put(\"Party A\", new BigDecimal(\"100\"));\n        return result;\n      }\n    ```", "```java\n      @Test   public void when_different_opinions_then_forecasts_50_percent_chance_for_each_party() {\n        SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();\n        String opinionA = \"Party A\";\n        surveyResultCompiler.willVoteFor(opinionA);\n        String opinionB = \"Party B\";\n        surveyResultCompiler.willVoteFor(opinionB);\n        Map<String, BigDecimal> result = surveyResultCompiler.forecastResult();\n        assertEquals(new BigDecimal(\"50\"), result.get(opinionA));\n     assertEquals(new BigDecimal(\"50\"), \n     result.get(opinionB));\n      }\n    ```", "```java\n      public Map<String, BigDecimal> forecastResult() {\n        Map<String, BigDecimal> result = new HashMap<String, BigDecimal>();\n        result.put(\"Party A\", new BigDecimal(\"50\"));\n     result.put(\"Party B\", new BigDecimal(\"50\"));\n        return result;\n      }\n    ```", "```java\n    public class SurveyResultCompiler {\n      List<String> opinions = new ArrayList<String>();\n\n      public void willVoteFor(String opinion) {\n        opinions.add(opinion);\n      }\n      //the result method is ignored for brevity\n    }\n    ```", "```java\n    public Map<String, BigDecimal> forecastResult() {\n\n      Map<String, BigDecimal> result = new HashMap<String, BigDecimal>();\n      Map<String, Integer> countMap = new HashMap<String, Integer>();\n      for(String party:opinions) {\n        Integer count = countMap.get(party);\n        if(count == null) {\n          count = 1;\n        }else {\n          count++;\n        }\n        countMap.put(party, count);\n      }\n\n      for(String party:countMap.keySet()) {\n        Integer voteCount = countMap.get(party);\n        int totalVotes = opinions.size();\n        BigDecimal percentage = new BigDecimal((voteCount*100)/totalVotes);\n        result.put(party, percentage);\n      }\n\n       return result;\n    }\n    ```", "```java\n      @Test\n      public void when_three_different_opinions_then_forecasts_33_percent_chance_for_each_party() {\n        SurveyResultCompiler surveyResultCompiler = new SurveyResultCompiler();\n        String opinionA = \"Party A\";\n        surveyResultCompiler.willVoteFor(opinionA);\n        String opinionB = \"Party B\";\n        surveyResultCompiler.willVoteFor(opinionB);\n        String opinionC = \"Party C\";\n        surveyResultCompiler.willVoteFor(opinionC);\n        Map<String, BigDecimal> result =surveyResultCompiler.forecastResult();\n        assertEquals(new BigDecimal(\"33\"), result.get(opinionA));\n        assertEquals(new BigDecimal(\"33\"), result.get(opinionB));\n        assertEquals(new BigDecimal(\"33\"), result.get(opinionC));\n      }\n    ```", "```java\n    public class SurveyResultCompilerTest {\n\n      SurveyResultCompiler surveyResultCompiler;\n\n      @Before\n      public void setUp() {\n        surveyResultCompiler = new SurveyResultCompiler();\n      }\n\n      @Test public void when_one_opinion_then_result_forecasts_the_opinion() {\n\n        surveyResultCompiler.willVoteFor(\"Party A\");\n        Map<String, BigDecimal> result =surveyResultCompiler.forecastResult();\n        assertEquals(new BigDecimal(\"100\"), result.get(\"Party A\"));\n      }\n\n      @Test public void when_two_different_opinions_then_forecasts_50_percent_chance_for_each_party() {\n\n        surveyResultCompiler.willVoteFor(\"Party A\");\n        surveyResultCompiler.willVoteFor(\"Party B\");\n\n        Map<String, BigDecimal> result =surveyResultCompiler.forecastResult();\n\n        assertEquals(new BigDecimal(\"50\"), result.get(\"Party A\"));\n        assertEquals(new BigDecimal(\"50\"), result.get(\"Party B\"));\n      }\n\n      @Test public void when_three_different_opinions_then_forecasts_33_percent_chance_for_each_party() {\n\n        surveyResultCompiler.willVoteFor(\"Party A\");\n        surveyResultCompiler.willVoteFor(\"Party B\");\n        surveyResultCompiler.willVoteFor(\"Party C\");\n\n        Map<String, BigDecimal> result =surveyResultCompiler.forecastResult();\n\n        assertEquals(new BigDecimal(\"33\"), result.get(\"Party A\"));\n        assertEquals(new BigDecimal(\"33\"), result.get(\"Party B\"));\n        assertEquals(new BigDecimal(\"33\"), result.get(\"Party C\"));\n      }\n    }\n    ```", "```java\n    public class SurveyResultCompiler {\n      private Map<String, Integer> opinions = new HashMap<String, Integer>();\n      private long participationCount = 0;\n      public void willVoteFor(String opinion) {\n        Integer sameOpinionCount = opinions.get(opinion);\n        if (sameOpinionCount == null) {\n          sameOpinionCount = 1;\n        } else {\n          sameOpinionCount++;\n        }\n        opinions.put(opinion, sameOpinionCount);\n        participationCount++;\n      }\n\n      public Map<String, BigDecimal> forecastResult() {\n        Map<String, BigDecimal> result = new HashMap<String, BigDecimal>();\n\n        for (String opinion : opinions.keySet()) {\n          Integer sameOpinionCount = opinions.get(opinion);\n          BigDecimal opinionPercentage = new BigDecimal((sameOpinionCount * 100) / participationCount);\n          result.put(opinion, opinionPercentage);\n        }\n        return result;\n      }\n    }\n    ```"]