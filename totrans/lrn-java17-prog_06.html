<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-111"><em class="italic"><a id="_idTextAnchor110"/>Chapter 4</em>: Exception Handling</h1>
			<p>In <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, we briefly introduced exceptions. In this chapter, we will treat this topic more systematically. There are two kinds of exceptions in Java: checked and unchecked. We’ll demonstrate each of them, and the differences between the two will be explained. Additionally, you will learn about the syntax of the Java constructs related to exception handling and the best practices to address (that is, handle) those exceptions. The chapter will end on the related topic of assertion statements, which can be used to debug the code in production.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>The Java exceptions framework</li>
				<li>Checked and unchecked (runtime) exceptions</li>
				<li>The <strong class="source-inline">try</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong> blocks</li>
				<li>The <strong class="source-inline">throws</strong> statement</li>
				<li>The <strong class="source-inline">throw</strong> statement</li>
				<li>The <strong class="source-inline">assert</strong> statement</li>
				<li>Best practices of exception handling</li>
			</ul>
			<p>So, let’s begin!</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Technical requirements</h1>
			<p>To be able to execute the code examples that are provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17, or later</li>
				<li>An IDE or code editor that you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. The files with the code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository. Please search in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch04_exceptions</strong> folder.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>The Java exceptions framework</h1>
			<p>As described in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, an unexpected condition can cause the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) or the application code to create and throw an exception object. As soon <a id="_idIndexMarker491"/>as that happens, the<a id="_idIndexMarker492"/> control flow is transferred to the <strong class="source-inline">catch</strong> clause, that is, if the exception was thrown inside a <strong class="source-inline">try</strong> block. Let’s look at an example. Consider the following method:</p>
			<pre class="source-code">void method(String s){</pre>
			<pre class="source-code">    if(s.equals("abc")){</pre>
			<pre class="source-code">        System.out.println("Equals abc");</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        System.out.println("Not equal");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If the input parameter value is <strong class="source-inline">null</strong>, you could expect to see the output as <strong class="source-inline">Not equal</strong>. Unfortunately, that is not the case. The <strong class="source-inline">s.equals("abc")</strong> expression calls the <strong class="source-inline">equals()</strong> method on an object referred to by the <strong class="source-inline">s</strong> variable; however, if the <strong class="source-inline">s</strong> variable is <strong class="source-inline">null</strong>, it does not refer to any object. Let’s see what happens next.</p>
			<p>Let’s run the following code (that is, the <strong class="source-inline">catchException1()</strong> method in the <strong class="source-inline">Framework</strong> class): </p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    method(null);</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    System.out.println("catchException1():");</pre>
			<pre class="source-code">    System.out.println(ex.getClass().getCanonicalName());  </pre>
			<pre class="source-code">                       //prints: java.lang.NullPointerException</pre>
			<pre class="source-code">    waitForStackTrace();</pre>
			<pre class="source-code">    ex.printStackTrace();  //prints: see the screenshot</pre>
			<pre class="source-code">    if(ex instanceof NullPointerException){</pre>
			<pre class="source-code">        //do something</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        //do something else</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code includes the <strong class="source-inline">waitForStackTrace()</strong> method, allowing you to wait a bit until the stack trace has been generated. Otherwise, the output would be out of sequence. The output of this code appears as follows:</p>
			<p class="source-code">catchException1():                                                  </p>
			<p class="source-code">java.lang.NullPointerException                                      </p>
			<p class="source-code"><strong class="bold">java.lang.NullPointerException: Cannot invoke "String.equals(Object)" because "s" is null                                                 </strong></p>
			<p class="source-code"><strong class="bold">     at com.packt.learnjava.ch04_exceptions.Framework.method(Framework.java:14)</strong></p>
			<p class="source-code"><strong class="bold">     at com.packt.learnjava.ch04_exceptions.Framework.catchException1(Framework.java:24)</strong></p>
			<p class="source-code"><strong class="bold">     at com.packt.learnjava.ch04_exceptions.Framework.main(Framework.java:8)</strong></p>
			<p>As you can see, the method prints the<a id="_idIndexMarker493"/> name of the exception class, followed<a id="_idIndexMarker494"/> by a <strong class="bold">stack trace</strong>. The name of <strong class="bold">stack trace</strong> comes from the way the method calls are stored (as a stack) in JVM memory: one method calls another, which, in turn, calls another, and so on. After the most inner method returns, the stack is walked back, and the returned <a id="_idIndexMarker495"/>method (<strong class="bold">stack frame</strong>) is removed from the stack. We will talk about the JVM memory structure, in more detail, in <a href="B18388_09_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 9</em></a>, <em class="italic">JVM Structure and Garbage Collection</em>. When an exception happens, all the stack content (such as the stack frames) is returned as the stack trace. This allows us to track down the line of code that <a id="_idIndexMarker496"/>caused the problem.</p>
			<p>In the preceding code example, different blocks of code were executed depending on the type of the exception. In our case, it was <strong class="source-inline">java.lang.NullPointerException</strong>. If the application code does not catch it, this exception would propagate through the stack of the called methods into the JVM, which will then stop executing the application. To avoid this happening, the exception can be caught and code can be executed to recover from the exceptional condition.</p>
			<p>The purpose of the exception handling framework in Java is to protect the application code from an unexpected condition and, if possible, recover from it. In the following sections, we will dissect this concept in more detail and rewrite the given example using the framework capability.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Checked and unchecked exceptions</h1>
			<p>If you look up the <a id="_idIndexMarker497"/>documentation of the <strong class="source-inline">java.lang</strong> package API, you will discover that the package contains almost three dozen exception classes and a <a id="_idIndexMarker498"/>couple of dozen error classes. Both groups extend the <strong class="source-inline">java.lang.Throwable</strong> class, inherit all the methods from it, and <a id="_idIndexMarker499"/>do not add other methods. The methods that are most often used in the <strong class="source-inline">java.lang.Throwable</strong> class include the<a id="_idIndexMarker500"/> following:</p>
			<ul>
				<li><strong class="source-inline">void printStackTrace()</strong>: This outputs the stack trace (stack frames) of the method calls.</li>
				<li><strong class="source-inline">StackTraceElement[] getStackTrace()</strong>: This returns the same information as <strong class="source-inline">printStackTrace()</strong> but allows programmatic access of any frame of the stack trace.</li>
				<li><strong class="source-inline">String getMessage()</strong>: This retrieves the message that often contains a user-friendly explanation of the reason for the exception or error.</li>
				<li><strong class="source-inline">Throwable getCause()</strong>: This retrieves an optional object of <strong class="source-inline">java.lang.Throwable</strong> that was the original reason for the exception (but the author of the code decided to wrap it in another exception or error).</li>
			</ul>
			<p>All errors extend the <strong class="source-inline">java.lang.Error</strong> class, which, in turn, extends the <strong class="source-inline">java.lang.Throwable</strong> class. Typically, an error is<a id="_idIndexMarker501"/> thrown by JVM and, according to the official documentation, <em class="italic">indicates serious problems that a reasonable application should not try to catch</em>. Here are a few <a id="_idIndexMarker502"/>examples:</p>
			<ul>
				<li><strong class="source-inline">OutOfMemoryError</strong>: This is thrown when the JVM runs out of memory and cannot clean the memory using garbage collection.</li>
				<li><strong class="source-inline">StackOverflowError</strong>: This is thrown when the memory allocated for the stack of the method calls is not enough to store another stack frame.</li>
				<li><strong class="source-inline">NoClassDefFoundError</strong>: This is thrown when the JVM cannot find the definition of the class requested by the currently loaded class.</li>
			</ul>
			<p>The authors of the framework assumed that an application cannot recover from these errors automatically, which proved to be a largely correct assumption. That is why programmers, typically, do not catch errors, but that is beyond the scope of this book.</p>
			<p>On the other hand, exceptions are typically related to application-specific problems and often do not require us to shut down the application and allow recovery. Usually, that is why programmers catch them and implement an alternative (to the main flow) path of the application logic, or at least report the problem without shutting down the application. Here are a few examples:</p>
			<ul>
				<li><strong class="source-inline">ArrayIndexOutOfBoundsException</strong>: This is thrown when the code tries to access the element by the<a id="_idIndexMarker503"/> index that is equal to, or bigger than, the array length (remember that the first element of an array has an index of <strong class="source-inline">0</strong>, so the index is equal to the array length points outside of the array).</li>
				<li><strong class="source-inline">ClassCastException</strong>: This is thrown when the code casts a reference to a class or an interface not associated with the object referred to by the variable.</li>
				<li><strong class="source-inline">NumberFormatException</strong>: This is thrown when the code tries to convert a string into a numeric type, but the string does not contain the necessary number format.</li>
			</ul>
			<p>All exceptions extend the <strong class="source-inline">java.lang.Exception</strong> class, which, in turn, extends the <strong class="source-inline">java.lang.Throwable</strong> class. That is why, by catching an object of the <strong class="source-inline">java.lang.Exception</strong> class, the code catches an object of any exception type. In the <em class="italic">The Java exceptions framework</em> section, we demonstrated this by catching <strong class="source-inline">java.lang.NullPointerException</strong> in the same way.</p>
			<p>One of the exceptions is <strong class="source-inline">java.lang.RuntimeException</strong>. The exceptions that extend it are <a id="_idIndexMarker504"/>called <strong class="bold">runtime exceptions</strong> or <strong class="bold">unchecked exceptions</strong>. We have already mentioned some<a id="_idIndexMarker505"/> of them: <strong class="source-inline">NullPointerException</strong>, <strong class="source-inline">ArrayIndexOutOfBoundsException</strong>, <strong class="source-inline">ClassCastException</strong>, and <strong class="source-inline">NumberFormatException</strong>. The reason they are called runtime exceptions is clear; the reason they are called unchecked exceptions will become clear next.</p>
			<p>Those exceptions that do not have <strong class="source-inline">java.lang.RuntimeException</strong> among their ancestors are <a id="_idIndexMarker506"/>called <strong class="bold">checked exceptions</strong>. The reason for such a name is that the compiler makes sure (checks) that these exceptions have either been caught or listed in the <strong class="source-inline">throws</strong> clause of the method (please refer to the <em class="italic">The throws statement</em> section). This design forces the programmer to make a conscious decision, either to catch the checked exception or inform the client of the method that this exception might be thrown by the method and has to be processed (handled) by the client. Here are a few <a id="_idIndexMarker507"/>examples of checked exceptions:</p>
			<ul>
				<li><strong class="source-inline">ClassNotFoundException</strong>: This is thrown when an attempt to load a class using its string name with the <strong class="source-inline">forName()</strong> method of the <strong class="source-inline">Class</strong> class has failed.</li>
				<li><strong class="source-inline">CloneNotSupportedException</strong>: This is thrown when the code tries to clone an object that does not implement the <strong class="source-inline">Cloneable</strong> interface.</li>
				<li><strong class="source-inline">NoSuchMethodException</strong>: This is thrown when there is no method called by the code.</li>
			</ul>
			<p>Not all exceptions reside in the <strong class="source-inline">java.lang</strong> package. Many other packages contain exceptions related to the functionality that is supported by the package. For example, there is a <strong class="source-inline">java.util.MissingResourceException</strong> runtime exception and a <strong class="source-inline">java.io.IOException</strong> checked exception.</p>
			<p>Despite not being forced, programmers often catch runtime (unchecked) exceptions to have better control of the program flow, making the behavior of an application more stable and predictable. By the way, all errors are also runtime (unchecked) exceptions. However, as we mentioned already, typically, it is not possible to handle them programmatically, so there is no point in catching descendants of the <strong class="source-inline">java.lang.Error</strong> class.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>The try, catch, and finally blocks</h1>
			<p>When an exception is<a id="_idIndexMarker508"/> thrown inside a <strong class="source-inline">try</strong> block, it redirects the control flow to the first <strong class="source-inline">catch</strong> clause. If there is <a id="_idIndexMarker509"/>no <strong class="source-inline">catch</strong> block that can capture the exception (but the <strong class="source-inline">finally</strong> block has<a id="_idIndexMarker510"/> to be in place), the exception propagates up and out of the method. If there is more than one <strong class="source-inline">catch</strong> clause, the compiler forces you to arrange them so that the child exception is listed before the parent exception. Let’s look at the following example:</p>
			<pre class="source-code">void someMethod(String s){</pre>
			<pre class="source-code">    try {</pre>
			<pre class="source-code">       method(s);</pre>
			<pre class="source-code">    } catch (NullPointerException ex){</pre>
			<pre class="source-code">       //do something</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">       //do something else</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding example, a <strong class="source-inline">catch</strong> block with <strong class="source-inline">NullPointerException</strong> is placed before the block with <strong class="source-inline">Exception</strong> because <strong class="source-inline">NullPointerException</strong> extends <strong class="source-inline">RuntimeException</strong>, which, in turn, extends <strong class="source-inline">Exception</strong>. We could even implement this example, as follows:</p>
			<pre class="source-code">void someMethod(String s){</pre>
			<pre class="source-code">    try {</pre>
			<pre class="source-code">        method(s);</pre>
			<pre class="source-code">    } catch (NullPointerException ex){</pre>
			<pre class="source-code">        //do something</pre>
			<pre class="source-code">    } catch (RuntimeException ex){</pre>
			<pre class="source-code">        //do something else</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">        //do something different</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Note that the first <strong class="source-inline">catch</strong> clause only catches <strong class="source-inline">NullPointerException</strong>. Other exceptions that extend <strong class="source-inline">RuntimeException</strong> will be caught by the second <strong class="source-inline">catch</strong> clause. The rest of the exception types (that is, all of the checked exceptions) will be caught by the last <strong class="source-inline">catch</strong> block. Note that errors will not be caught by any of these <strong class="source-inline">catch</strong> clauses. To catch them, you should add a <strong class="source-inline">catch</strong> clause for <strong class="source-inline">Error</strong> (in any position) or <strong class="source-inline">Throwable</strong> (after the last <strong class="source-inline">catch</strong> clause in the previous example). However, usually, programmers do not do it and allow errors to propagate into the JVM.</p>
			<p>Having a <strong class="source-inline">catch</strong> block for each <a id="_idIndexMarker511"/>exception type allows us to provide specific exception type processing. However, if there is no difference in the exception processing, you can simply have one <strong class="source-inline">catch</strong> block with the <strong class="source-inline">Exception</strong> base class to catch all types of exceptions:</p>
			<pre class="source-code">void someMethod(String s){</pre>
			<pre class="source-code">    try {</pre>
			<pre class="source-code">        method(s);</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">        //do something</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If none of the clauses catch the exception, it is thrown further up until it is either handled by a <strong class="source-inline">try...catch</strong> statement in one of the method callers or propagates all the way out of the application code. In such a case, the JVM terminates the application and exits.</p>
			<p>Adding a <strong class="source-inline">finally</strong> block<a id="_idIndexMarker512"/> does not change the described behavior. If present, it is always executed, whether an exception has been generated or not. Usually, a <strong class="source-inline">finally</strong> block is used to release the resources, to close a database connection, a file, or similar. However, if the resource implements the <strong class="source-inline">Closeable</strong> interface, it is better to use the <strong class="source-inline">try-with-resources</strong> statement, which allows you to release the resources automatically. The following demonstrates how it can be done with Java 7:</p>
			<pre class="source-code">try (Connection conn = DriverManager</pre>
			<pre class="source-code">               .getConnection("dburl", "username", "password");</pre>
			<pre class="source-code">     ResultSet rs = conn.createStatement()</pre>
			<pre class="source-code">               .executeQuery("select * from some_table")) {</pre>
			<pre class="source-code">    while (rs.next()) {</pre>
			<pre class="source-code">        //process the retrieved data</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (SQLException ex) {</pre>
			<pre class="source-code">    //Do something</pre>
			<pre class="source-code">    //The exception was probably caused </pre>
			<pre class="source-code">    //by incorrect SQL statement</pre>
			<pre class="source-code">}</pre>
			<p>The preceding example <a id="_idIndexMarker513"/>creates the database connection, retrieves data and processes it, and then closes (calls the <strong class="source-inline">close()</strong> method) the <strong class="source-inline">conn</strong> and <strong class="source-inline">rs</strong> objects.</p>
			<p>Java 9 enhances the <strong class="source-inline">try-with-resources</strong> statement’s capabilities by allowing the creation of objects that represent resources outside<a id="_idIndexMarker514"/> the <strong class="source-inline">try</strong> block, along with the use of them in a <strong class="source-inline">try-with-resources</strong> statement, as follows:</p>
			<pre class="source-code">void method(Connection conn, ResultSet rs) {</pre>
			<pre class="source-code">    try (conn; rs) {</pre>
			<pre class="source-code">        while (rs.next()) {</pre>
			<pre class="source-code">            //process the retrieved data</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    } catch (SQLException ex) {</pre>
			<pre class="source-code">        //Do something</pre>
			<pre class="source-code">        //The exception was probably caused </pre>
			<pre class="source-code">        //by incorrect SQL statement</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code looks much cleaner, although, in<a id="_idIndexMarker515"/> practice, programmers prefer to create and release (close) resources in the same context. If that is your preference too, consider using the <strong class="source-inline">throws</strong> statement in conjunction with the <strong class="source-inline">try-with-resources</strong> statement.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>The throws statement</h1>
			<p>We have to deal with <strong class="source-inline">SQLException</strong> because it is a checked exception, and the <strong class="source-inline">getConnection()</strong>, <strong class="source-inline">createStatement()</strong>, <strong class="source-inline">executeQuery()</strong>, and <strong class="source-inline">next()</strong> methods declare<a id="_idIndexMarker516"/> it in their <strong class="source-inline">throws</strong> clause. Here is an example:</p>
			<pre class="source-code">Statement createStatement() throws SQLException;</pre>
			<p>This means that the method’s author warns the method’s users that it might throw such an exception, forcing them to either catch the exception or to declare it in the <strong class="source-inline">throws</strong> clause of their methods. In our preceding example, we have chosen to catch it using two <strong class="source-inline">try...catch</strong> statements. Alternatively, we can list the exception in the <strong class="source-inline">throws</strong> clause and, thus, remove the clutter by effectively pushing the burden of the exception handling onto the users of our method:</p>
			<pre class="source-code">void throwsDemo() throws SQLException {</pre>
			<pre class="source-code">    Connection conn = </pre>
			<pre class="source-code">      DriverManager.getConnection("url","user","pass");</pre>
			<pre class="source-code">    ResultSet rs = conn.createStatement().executeQuery(</pre>
			<pre class="source-code">      "select * ...");</pre>
			<pre class="source-code">    try (conn; rs) {</pre>
			<pre class="source-code">        while (rs.next()) {</pre>
			<pre class="source-code">            //process the retrieved data</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    } finally { </pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">           if(conn != null) {</pre>
			<pre class="source-code">              conn.close();</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">        } finally {</pre>
			<pre class="source-code">           if(rs != null) {</pre>
			<pre class="source-code">               rs.close();</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We got rid of the catch clause, but we need the finally block to close the created conn and rs objects. </p>
			<p>Please, notice how we included code that closes the conn object in a try block and we included the code that closes the rs object in the finally block. This way we make sure that an exception during closing of the conn object will not prevent us from closing the rs object.</p>
			<p>This code looks less clear than the try-with-resources statement we demonstrated in the previous section. We show it just to demonstrate all the possibilities and how to avoid possible danger (of not closing the resources) if you decide to do it yourself, not letting the try-with-resources statement do it for you automatically.</p>
			<p>But let us get back to the discussion of the throws statement. </p>
			<p>The <strong class="source-inline">throws</strong> clause allows but does not require us to list unchecked exceptions. Adding unchecked exceptions does not force the method’s users to handle them.</p>
			<p>Finally, if the method throws <a id="_idIndexMarker517"/>several different exceptions, it is possible to list the base <strong class="source-inline">Exception</strong> exception class instead of listing all of them. That will make the compiler happy; however, this is not considered a good practice because it hides the details of particular exceptions that a method’s user might expect.</p>
			<p>Please note that the compiler does not check what kind of exception the code in the method’s body can throw. So, it is possible to list any exception in the <strong class="source-inline">throws</strong> clause, which might lead to unnecessary overhead. If, by mistake, a programmer includes a checked exception in the <strong class="source-inline">throws</strong> clause that is never actually thrown by the method, the method’s user could write a <strong class="source-inline">catch</strong> block for it that is never executed. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>The throw statement</h1>
			<p>The <strong class="source-inline">throw</strong> statement allows the<a id="_idIndexMarker518"/> throwing of any exception that a programmer deems necessary. You can even create your own exception. To create a checked exception, extend the <strong class="source-inline">java.lang.Exception</strong> class as follows:</p>
			<pre class="source-code">class MyCheckedException extends Exception{</pre>
			<pre class="source-code">    public MyCheckedException(String message){</pre>
			<pre class="source-code">        super(message);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    //add code you need to have here</pre>
			<pre class="source-code">}</pre>
			<p>Also, to create an unchecked exception, extend the <strong class="source-inline">java.lang.RunitmeException</strong> class, as follows:</p>
			<pre class="source-code">class MyUncheckedException extends RuntimeException{</pre>
			<pre class="source-code">    public MyUncheckedException(String message){</pre>
			<pre class="source-code">        super(message);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    //add code you need to have here</pre>
			<pre class="source-code">}</pre>
			<p>Notice the <em class="italic">add code you need to have here</em> comment. You can add methods and properties to the custom exception as with any other regular class, but programmers rarely do it. In fact, the best practices explicitly recommend avoiding the use of exceptions for driving business logic. Exceptions should be what the name implies, covering only exceptional or very rare situations.</p>
			<p>However, if you <a id="_idIndexMarker519"/>need to announce an exceptional condition, use the <strong class="source-inline">throw</strong> keyword and the <strong class="source-inline">new</strong> operator to create and trigger the propagation of an exception object. Here are a few examples:</p>
			<pre class="source-code">throw new Exception("Something happened"); </pre>
			<pre class="source-code">throw new RuntimeException("Something happened");</pre>
			<pre class="source-code">throw new MyCheckedException("Something happened");</pre>
			<pre class="source-code">throw new MyUncheckedException("Something happened");</pre>
			<p>It is even possible to throw <strong class="source-inline">null</strong>, as follows:</p>
			<p class="source-code">throw null;</p>
			<p>The result of the preceding statement is the same as the result of this one:</p>
			<p class="source-code">throw new NullPointerException;</p>
			<p>In both cases, an object of an unchecked <strong class="source-inline">NullPointerException</strong> exception begins to propagate through the system, until it is caught either by the application or the JVM.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>The assert statement</h1>
			<p>Once in a while, a programmer needs to<a id="_idIndexMarker520"/> know whether a particular condition has happened in the code, even after the application has already been deployed to production. At the same time, there is no need to run this check all the time. That is where the <strong class="source-inline">assert</strong> branching statement comes in handy. Here is an example:</p>
			<pre class="source-code">public someMethod(String s){</pre>
			<pre class="source-code">    //any code goes here</pre>
			<pre class="source-code">    assert(assertSomething(x, y, z));</pre>
			<pre class="source-code">    //any code goes here</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">boolean assertSomething(int x, String y, double z){</pre>
			<pre class="source-code">    //do something and return boolean</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, the <strong class="source-inline">assert()</strong> method takes input from the <strong class="source-inline">assertSomething()</strong> method. If the <strong class="source-inline">assertSomething()</strong> method returns <strong class="source-inline">false</strong>, the program stops executing.</p>
			<p>The <strong class="source-inline">assert()</strong> method is executed only <a id="_idIndexMarker521"/>when the JVM is run using the <strong class="source-inline">-ea</strong> option. The <strong class="source-inline">-ea</strong> flag should not be used in production, except maybe temporarily for testing purposes. This is because it creates an overhead that affects the application performance.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Best practices of exception handling</h1>
			<p>Checked exceptions <a id="_idIndexMarker522"/>were designed to be used for recoverable conditions when an application can do something automatically to amend or work around the problem. In practice, this doesn’t happen very often. Typically, when an exception is caught, the application logs the stack trace and aborts the current action. Based on the logged information, the application support team modifies the code to address the condition that is unaccounted for or to prevent it from occurring in the future. </p>
			<p>Each application is different, so best practices depend on the particular application requirements, design, and context. In general, it seems that there is an agreement in the development community to avoid using checked exceptions and to minimize their propagation in the application code. The following is a list of a few other recommendations that have proved to be useful:</p>
			<ul>
				<li>Always catch all checked exceptions that are close to the source.</li>
				<li>If in doubt, catch unchecked exceptions that are also close to the source.</li>
				<li>Handle the exception as close to the source as possible because that is where the context is the most specific and where the root cause resides.</li>
				<li>Do not throw checked exceptions unless you have to because you force the building of extra code for a case that might never happen.</li>
				<li>Convert third-party checked exceptions into unchecked ones by re-throwing them as <strong class="source-inline">RuntimeException</strong> with the corresponding message if you have to.</li>
				<li>Do not create custom exceptions unless you have to.</li>
				<li>Do not drive business logic by using the exception handling mechanism unless you have to.</li>
				<li>Customize generic <strong class="source-inline">RuntimeException</strong> exceptions by using the system of messages and, optionally, the <strong class="source-inline">enum</strong> type instead of using the exception type to communicate the cause of the error.</li>
			</ul>
			<p>There are many other<a id="_idIndexMarker523"/> possible tips and recommendations; however, if you follow these, you are probably going to be fine in the vast majority of situations. With that, we conclude this chapter. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Summary</h1>
			<p>In this chapter, you were introduced to the Java exception handling framework, and you learned about two kinds of exceptions—checked and unchecked (runtime)—and how to handle them using <strong class="source-inline">try-catch-finally</strong> and <strong class="source-inline">throws</strong> statements. Also, you learned how to generate (throw) exceptions and how to create your own (custom) exceptions. The chapter concluded with the best practices of exception handling which, if followed consistently, will help you to write clean and clear code, which is pleasant to write and easy to understand and maintain.</p>
			<p>In the next chapter, we will talk about strings and their processing in detail, along with input/output streams and file reading and writing techniques.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Quiz</h1>
			<ol>
				<li>What is a stack trace? Select all that apply:<ol><li>A list of classes currently loaded</li><li>A list of methods currently executing</li><li>A list of code lines currently executing</li><li>A list of variables currently used</li></ol></li>
				<li>What kinds of exceptions are there? Select all that apply:<ol><li>Compilation exceptions</li><li>Runtime exceptions</li><li>Read exceptions</li><li>Write exceptions</li></ol></li>
				<li>What is the output of the following code?<p class="source-code">try {</p><p class="source-code">    throw null;</p><p class="source-code">} catch (RuntimeException ex) {</p><p class="source-code">    System.out.print("RuntimeException ");</p><p class="source-code">} catch (Exception ex) {</p><p class="source-code">    System.out.print("Exception ");</p><p class="source-code">} catch (Error ex) {</p><p class="source-code">    System.out.print("Error ");</p><p class="source-code">} catch (Throwable ex) {</p><p class="source-code">    System.out.print("Throwable ");</p><p class="source-code">} finally {</p><p class="source-code">    System.out.println("Finally ");</p><p class="source-code">}</p><ol><li>A <strong class="source-inline">RuntimeException</strong> error</li><li><strong class="source-inline">Exception Error Finally</strong></li><li><strong class="source-inline">RuntimeException Finally</strong></li><li><strong class="source-inline">Throwable Finally</strong></li></ol></li>
				<li>Which of the following methods will compile without an error?<p class="source-code">void method1() throws Exception { throw null; }</p><p class="source-code">void method2() throws RuntimeException { throw null; }</p><p class="source-code">void method3() throws Throwable { throw null; }</p><p class="source-code">void method4() throws Error { throw null; }</p><ol><li><strong class="source-inline">method1()</strong></li><li><strong class="source-inline">method2()</strong></li><li><strong class="source-inline">method3()</strong></li><li><strong class="source-inline">method4()</strong></li></ol></li>
				<li>Which of the following statements will compile without an error?<p class="source-code">throw new NullPointerException("Hi there!"); //1</p><p class="source-code">throws new Exception("Hi there!");          //2</p><p class="source-code">throw RuntimeException("Hi there!");       //3</p><p class="source-code">throws RuntimeException("Hi there!");     //4</p><ol><li>1</li><li>2</li><li>3</li><li>4</li></ol></li>
				<li>Assuming that <strong class="source-inline">int x = 4</strong>, which of the following statements will compile without an error?<p class="source-code">assert (x &gt; 3); //1</p><p class="source-code">assert (x = 3); //2</p><p class="source-code">assert (x &lt; 4); //3</p><p class="source-code">assert (x = 4); //4</p><ol><li>1</li><li>2</li><li>3</li><li>4</li></ol></li>
				<li>Which are the best practices from the following list?<ol><li>Always catch all exceptions and errors.</li><li>Always catch all exceptions.</li><li>Never throw unchecked exceptions.</li><li>Try not to throw checked exceptions unless you have to.</li></ol></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer042">
			</div>
		</div>
	</body></html>