<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Customizing Concurrency Classes</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Customizing the ThreadPoolExecutor class</li>
<li class="calibre18">Implementing a priority-based Executor class</li>
<li class="calibre18">Implementing the ThreadFactory interface to generate custom threads</li>
<li class="calibre18">Using our ThreadFactory in an Executor object</li>
<li class="calibre18">Customizing tasks running in a scheduled thread pool</li>
<li class="calibre18">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</li>
<li class="calibre18">Customizing tasks running in the fork/join framework</li>
<li class="calibre18">Implementing a custom Lock class</li>
<li class="calibre18">Implementing a transfer queue-based on priorities</li>
<li class="calibre18">Implementing your own atomic object</li>
<li class="calibre18">Implementing your own stream generator</li>
<li class="calibre18">Implementing your own asynchronous stream</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">The Java Concurrency API provides a lot of interfaces and classes to implement concurrent applications. They provide low-level mechanisms, such as the <kbd class="calibre15">Thread</kbd> class, the <kbd class="calibre15">Runnable</kbd> or <kbd class="calibre15">Callable</kbd> interfaces, or the <kbd class="calibre15">synchronized</kbd> keyword. They also provide high-level mechanisms, such as the <kbd class="calibre15">Executor</kbd> framework and the fork/join framework added in the Java 7 release, or the <kbd class="calibre15">Stream</kbd> framework added in Java 8, to process big sets of data. Despite this, you may find yourself developing a program where the default configuration and/or implementation of the Java API doesn't meet your needs.</p>
<p class="calibre4">In this case, you may need to implement your own custom concurrent utilities, based on the ones provided by Java. Basically, you can:</p>
<ul class="calibre17">
<li class="calibre18">Implement an interface to provide the functionality defined by that interface, for example, the <kbd class="calibre15">ThreadFactory</kbd> interface.</li>
<li class="calibre18">Override some methods of a class to adapt its behavior to your needs. For example, overriding the <kbd class="calibre15">onAdvance()</kbd> method of the <kbd class="calibre15">Phaser</kbd> class that, by default, does nothing useful and is supposed to be overridden to offer some functionality.</li>
</ul>
<p class="calibre4">Through the recipes of this chapter, you will learn how to change the behavior of some Java concurrency API classes without the need to design a concurrency framework from scratch. You can use these recipes as an initial point to implement your own customizations.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Customizing the ThreadPoolExecutor class</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework is a mechanism that allows you to separate thread creation from its execution. It's based on the <kbd class="calibre15">Executor</kbd> and <kbd class="calibre15">ExecutorService</kbd> interfaces with the <kbd class="calibre15">ThreadPoolExecutor</kbd> class that implements both the interfaces. It has an internal pool of threads and provides methods that allow you to send two kinds of tasks and execute them in the pooled threads. These tasks are:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">Runnable</kbd> interface to implement tasks that don't return a result</li>
<li class="calibre18">The <kbd class="calibre15">Callable</kbd> interface to implement tasks that return a result</li>
</ul>
<p class="calibre4">In both cases, you only send the task to the executor. The executor uses one of its pooled threads or creates a new one to execute those tasks. It also decides the moment in which the task is executed.</p>
<p class="calibre4">In this recipe, you will learn how to override some methods of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class to calculate the execution time of the tasks that you will execute in the executor and write about the executor in console statistics when it completes its execution.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyExecutor</kbd> that extends the <kbd class="calibre15">ThreadPoolExecutor</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyExecutor extends ThreadPoolExecutor {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">ConcurrentHashMap</kbd> attribute parameterized by the <kbd class="calibre15">String</kbd> and <kbd class="calibre15">Date</kbd> classes, named <kbd class="calibre15">startTimes</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ConcurrentHashMap&lt;Runnable, Date&gt; startTimes;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor for the class. Call a constructor of the parent class using the <kbd class="calibre15">super</kbd> keyword and initialize the <kbd class="calibre15">startTime</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public MyExecutor(int corePoolSize, int maximumPoolSize,<br class="title-page-name"/>                          long keepAliveTime, TimeUnit unit,<br class="title-page-name"/>                          BlockingQueue&lt;Runnable&gt; workQueue) {<br class="title-page-name"/>          super(corePoolSize, maximumPoolSize, keepAliveTime, unit,<br class="title-page-name"/>                workQueue);<br class="title-page-name"/>          startTimes=new ConcurrentHashMap&lt;&gt;();<br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Override the <kbd class="calibre15">shutdown()</kbd> method. Write in the console information about the executed, running, and pending tasks. Then, call the <kbd class="calibre15">shutdown()</kbd> method of the parent class using the <kbd class="calibre15">super</kbd> keyword:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void shutdown() { <br class="title-page-name"/>          System.out.printf("MyExecutor: Going to shutdown.\n"); <br class="title-page-name"/>          System.out.printf("MyExecutor: Executed tasks: %d\n",<br class="title-page-name"/>                            getCompletedTaskCount());
</pre>
<pre class="calibre23">
          System.out.printf("MyExecutor: Running tasks: %d\n",<br class="title-page-name"/>                            getActiveCount());                                      System.out.printf("MyExecutor: Pending tasks: %d\n",<br class="title-page-name"/>                            getQueue().size()); <br class="title-page-name"/>          super.shutdown(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Override the <kbd class="calibre15">shutdownNow()</kbd> method. Write in the console information about the executed, running, and pending tasks. Then, call the <kbd class="calibre15">shutdownNow()</kbd> method of the parent class using the <kbd class="calibre15">super</kbd> keyword:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public List&lt;Runnable&gt; shutdownNow() { <br class="title-page-name"/>          System.out.printf("MyExecutor: Going to immediately<br class="title-page-name"/>                            shutdown.\n"); <br class="title-page-name"/>          System.out.printf("MyExecutor: Executed tasks: %d\n",<br class="title-page-name"/>                            getCompletedTaskCount()); <br class="title-page-name"/>          System.out.printf("MyExecutor: Running tasks: %d\n",<br class="title-page-name"/>                            getActiveCount()); <br class="title-page-name"/>          System.out.printf("MyExecutor: Pending tasks: %d\n",<br class="title-page-name"/>                            getQueue().size()); <br class="title-page-name"/>          return super.shutdownNow(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Override the <kbd class="calibre15">beforeExecute()</kbd> method. Write a message in the console with the name of the thread that is going to execute the task and the hash code of the task. Store the start date in <kbd class="calibre15">HashMap</kbd> using the hash code of the task as the key:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void beforeExecute(Thread t, Runnable r) { <br class="title-page-name"/>          System.out.printf("MyExecutor: A task is beginning: %s : %s\n",<br class="title-page-name"/>                                t.getName(),r.hashCode()); <br class="title-page-name"/>          startTimes.put(r, new Date()); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Override the <kbd class="calibre15">afterExecute()</kbd> method. Write a message in the console with the result of the task and calculate the running time of the task after subtracting the start date of the task stored in <kbd class="calibre15">HashMap</kbd> of the current date:</li>
</ol>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          protected void afterExecute(Runnable r, Throwable t) { <br class="title-page-name"/>            Future&lt;?&gt; result=(Future&lt;?&gt;)r; <br class="title-page-name"/>            try { <br class="title-page-name"/>              System.out.printf("*********************************\n"); <br class="title-page-name"/>              System.out.printf("MyExecutor: A task is finishing.\n"); 
</pre>
<pre class="calibre23">
              System.out.printf("MyExecutor: Result: %s\n",<br class="title-page-name"/>                                result.get()); <br class="title-page-name"/>              Date startDate=startTimes.remove(r); <br class="title-page-name"/>              Date finishDate=new Date(); <br class="title-page-name"/>              long diff=finishDate.getTime()-startDate.getTime(); <br class="title-page-name"/>              System.out.printf("MyExecutor: Duration: %d\n",diff); <br class="title-page-name"/>              System.out.printf("*********************************\n"); <br class="title-page-name"/>            } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">SleepTwoSecondsTask</kbd> that implements the <kbd class="calibre15">Callable</kbd> interface parameterized by the <kbd class="calibre15">String</kbd> class. Implement the <kbd class="calibre15">call()</kbd> method. Put the current thread to sleep for 2 seconds and return the current date converted into a <kbd class="calibre15">String</kbd> type:</li>
</ol>
<pre class="calibre23">
        public class SleepTwoSecondsTask implements Callable&lt;String&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          public String call() throws Exception { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            return new Date().toString(); <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a <kbd class="calibre15">MyExecutor</kbd> object named <kbd class="calibre15">myExecutor</kbd>:</li>
</ol>
<pre class="calibre23">
        MyExecutor myExecutor=new MyExecutor(4, 8, 1000,<br class="title-page-name"/>                                  TimeUnit.MILLISECONDS,<br class="title-page-name"/>                                  new LinkedBlockingDeque&lt;Runnable&gt;());
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a list of <kbd class="calibre15">Future</kbd> objects parameterized by the <kbd class="calibre15">String</kbd> class to store the resultant objects of the tasks you're going to send to the executor:</li>
</ol>
<pre class="calibre23">
        List&lt;Future&lt;String&gt;&gt; results=new ArrayList&lt;&gt;();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Submit 10 <kbd class="calibre15">Task</kbd> objects:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>          SleepTwoSecondsTask task=new SleepTwoSecondsTask(); <br class="title-page-name"/>          Future&lt;String&gt; result=myExecutor.submit(task); <br class="title-page-name"/>          results.add(result); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Get the result of the execution of the first five tasks using the <kbd class="calibre15">get()</kbd> method. Write them in the console:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            String result=results.get(i).get(); <br class="title-page-name"/>            System.out.printf("Main: Result for Task %d : %s\n",<br class="title-page-name"/>                              i,result); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Finish the execution of the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        myExecutor.shutdown();
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Get the result of the execution of the last five tasks using the <kbd class="calibre15">get()</kbd> method. Write them in the console:</li>
</ol>
<pre class="calibre23">
        for (int i=5; i&lt;10; i++){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            String result=results.get(i).get(); <br class="title-page-name"/>            System.out.printf("Main: Result for Task %d : %s\n",<br class="title-page-name"/>                              i,result); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Wait for the completion of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          myExecutor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Write a message indicating the end of the execution of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented our custom executor by extending the <kbd class="calibre15">ThreadPoolExecutor</kbd> class and overriding four of its methods. The <kbd class="calibre15">beforeExecute()</kbd> and <kbd class="calibre15">afterExecute()</kbd> methods were used to calculate the execution time of a task. The <kbd class="calibre15">beforeExecute()</kbd> method is executed before the execution of a task; in this case, we used <kbd class="calibre15">HashMap</kbd> to store the start date of the task in it. The <kbd class="calibre15">afterExecute()</kbd> method is executed after the execution of the task. You got <kbd class="calibre15">startTime</kbd> of the task that had finished from <kbd class="calibre15">HashMap</kbd> and then calculate the difference between the actual date and and the <kbd class="calibre15">startTime</kbd> to get the execution time of the task. You also overrode the <kbd class="calibre15">shutdown()</kbd> and <kbd class="calibre15">shutdownNow()</kbd> methods to write statistics about the tasks executed in the executor to the console. These tasks included:</p>
<ul class="calibre17">
<li class="calibre18">The executed tasks, using the <kbd class="calibre15">getCompletedTaskCount()</kbd> method</li>
<li class="calibre18">The tasks that were running at the current time, using the <kbd class="calibre15">getActiveCount()</kbd> method</li>
<li class="calibre18">The pending tasks, using the <kbd class="calibre15">size()</kbd> method of the blocking queue where the executor stores the pending tasks</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">SleepTwoSecondsTask</kbd> class that implements the <kbd class="calibre15">Callable</kbd> interface puts its execution thread to sleep for 2 seconds and the <kbd class="calibre15">Main</kbd> class, where you send 10 tasks to your executor, uses it and the other classes to demo their features.</p>
<p class="calibre4">Execute the program and you will see how the program shows the time span of each task that is running and the statistics of the executor upon calling the <kbd class="calibre15">shutdown()</kbd> method.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em> recipe in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
<li class="calibre18">The <em class="calibre14">Using our ThreadFactory in an Executor object</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing a priority-based Executor class</h1>
            

            <article>
                
<p class="calibre4">In the first version of the Java Concurrency API, you had to create and run all the threads of your application. In Java version 5, with the appearance of the Executor framework, a new mechanism was introduced for the execution of concurrency tasks.</p>
<p class="calibre4">With the Executor framework, you only have to implement your tasks and send them to the executor. The executor is responsible for the creation and execution of the threads that execute your tasks.</p>
<p class="calibre4">Internally, an executor uses a blocking queue to store pending tasks. These are stored in the order of their arrival at the executor. One possible alternative is to use a priority queue to store new tasks. This way, if a new task with high priority arrives to the executor, it will be executed before all the other threads that have already been waiting but have comparatively lower priority.</p>
<p class="calibre4">In this recipe, you will learn how to adapt an executor that will use a priority queue to store the tasks you send for execution.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyPriorityTask</kbd> that implements the <kbd class="calibre15">Runnable</kbd> and <kbd class="calibre15">Comparable</kbd> interfaces parameterized by the <kbd class="calibre15">MyPriorityTask</kbd> class interface:</li>
</ol>
<pre class="calibre23">
        public class MyPriorityTask implements Runnable,<br class="title-page-name"/>                              Comparable&lt;MyPriorityTask&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">priority</kbd>:</li>
</ol>
<pre class="calibre23">
        private int priority;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private String attribute called name:</li>
</ol>
<pre class="calibre23">
        private String name;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public MyPriorityTask(String name, int priority) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          this.priority=priority; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement a method to return the value of the priority attribute:</li>
</ol>
<pre class="calibre23">
        public int getPriority(){ <br class="title-page-name"/>          return priority; <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">compareTo()</kbd> method declared in the <kbd class="calibre15">Comparable</kbd> interface. It receives a <kbd class="calibre15">MyPriorityTask</kbd> object as a parameter and compares the priorities of the two objects: the current one and the parameter. You let tasks with higher priority be executed before tasks with lower priority:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int compareTo(MyPriorityTask o) { <br class="title-page-name"/>          return Integer.compare(o.getPriority(), this.getPriority()); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Put the current thread to sleep for 2 seconds:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("MyPriorityTask: %s Priority : %d\n",<br class="title-page-name"/>                            name,priority); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>            Thread.currentThread().interrupt(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create a <kbd class="calibre15">ThreadPoolExecutor</kbd> object named <kbd class="calibre15">executor</kbd>. Use <kbd class="calibre15">PriorityBlockingQueue</kbd>, parameterized by the <kbd class="calibre15">Runnable</kbd> interface, as the queue that this executor will use to store its pending tasks:</li>
</ol>
<pre class="calibre23">
        ThreadPoolExecutor executor=new ThreadPoolExecutor(4,4,1,<br class="title-page-name"/>                                    TimeUnit.SECONDS,<br class="title-page-name"/>                                    new PriorityBlockingQueue&lt;Runnable&gt;());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Send 10 tasks to the executor using the counter of the loop as the priority of the tasks. Use the <kbd class="calibre15">execute()</kbd> method to send the tasks to the executor:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          MyPriorityTask task=new MyPriorityTask ("Task "+i,i); <br class="title-page-name"/>          executor.execute(task); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Put the current thread to sleep for 1 second:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Send 10 additional tasks to the executor using the counter of the loop as the priority of the tasks. Use the <kbd class="calibre15">execute()</kbd> method to send the tasks to the executor:</li>
</ol>
<pre class="calibre23">
        for (int i=10; i&lt;20; i++) { <br class="title-page-name"/>          MyPriorityTask task=new MyPriorityTask ("Task "+i,i); <br class="title-page-name"/>          executor.execute(task);       <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Shut down the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Wait for the finalization of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Write a message in the console indicating the finalization of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">Converting a regular executor into a priority-based executor is simple. You only have to pass a <kbd class="calibre15">PriorityBlockingQueue</kbd> object, parameterized by the <kbd class="calibre15">Runnable</kbd> interface, as a parameter. But with the executor, you should know that all the objects stored in a priority queue have to implement the <kbd class="calibre15">Comparable</kbd> interface.</p>
<p class="calibre4">You implemented the <kbd class="calibre15">MyPriorityTask</kbd> class that implements the <kbd class="calibre15">Runnable</kbd> interface, which will act as a task, and the <kbd class="calibre15">Comparable</kbd> interface to be stored in the priority queue. This class has a <kbd class="calibre15">Priority</kbd> attribute that is used to store the priority of the tasks. If a task has a higher value for this attribute, it will be executed earlier. The <kbd class="calibre15">compareTo()</kbd> method determines the order of the tasks in the priority queue. In the <kbd class="calibre15">Main</kbd> class, you sent 20 tasks to the executor with different priorities. The first tasks you sent to the executor were the first tasks to be executed. As the executor was idle waiting for the tasks, it executed the first tasks immediately, as soon as they arrived. You created the executor with four execution threads, so the first four tasks will be the first ones that are executed. Then, the rest of the tasks will be executed based on their priority.</p>
<p class="calibre4">The following screenshot shows one execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone34" src="../images/00050.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can configure <kbd class="calibre15">Executor</kbd> to use any implementation of the <kbd class="calibre15">BlockingQueue</kbd> interface. One interesting implementation is <kbd class="calibre15">DelayQueue</kbd>. This class is used to store elements with delayed activation. It provides methods that only return active objects. You can use this class to implement your own version of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em> recipe in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
<li class="calibre18">The <em class="calibre14">Customizing the ThreadPoolExecutor class</em> recipe in this chapter</li>
<li class="calibre18">The <em class="calibre14">Using blocking thread-safe queue ordered by priority</em> recipe in <a href="part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre14">Concurrent Collections</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing the ThreadFactory interface to generate custom threads</h1>
            

            <article>
                
<p class="calibre4">Factory pattern is a widely used design pattern in the object-oriented programming world. It is a creational pattern and its objective is to develop a class whose mission is to create objects of one or several classes. Then, when we want to create an object of one of those classes, we use the factory instead of using the new operator.</p>
<div class="packt_infobox">With this factory, we centralize the creation of objects, thereby gaining the advantage of easily changing the class of objects created or the way we create these objects, considering the limitations we have in creating objects with limited resources. For example, we can only have <em class="calibre28">N</em> objects of a type that has the ability to easily generate statistical data about the creation of objects.</div>
<p class="calibre4">Java provides the <kbd class="calibre15">ThreadFactory</kbd> interface to implement a <kbd class="calibre15">Thread</kbd> object factory. Some advanced utilities of the Java concurrency API, such as the <kbd class="calibre15">Executor</kbd> framework or the fork/join framework, use thread factories to create threads. Another example of the factory pattern in the Java Concurrency API is the <kbd class="calibre15">Executors</kbd> class. It provides a lot of methods to create different kinds of <kbd class="calibre15">Executor</kbd> objects. In this recipe, you will extend the <kbd class="calibre15">Thread</kbd> class by adding new functionalities, and you will implement a thread factory class to generate threads of this new class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyThread</kbd> that extends the <kbd class="calibre15">Thread</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyThread extends Thread {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare three private <kbd class="calibre15">Date</kbd> attributes named <kbd class="calibre15">creationDate</kbd>, <kbd class="calibre15">startDate</kbd>, and <kbd class="calibre15">finishDate</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Date creationDate; <br class="title-page-name"/>        private Date startDate; <br class="title-page-name"/>        private Date finishDate;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement a constructor of the class. It receives the name and the <kbd class="calibre15">Runnable</kbd> object to be executed as parameters. Initialize the creation date of the thread:</li>
</ol>
<pre class="calibre23">
        public MyThread(Runnable target, String name ){ <br class="title-page-name"/>          super(target,name); <br class="title-page-name"/>          creationDate = new Date(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Store the start date of the thread, call the <kbd class="calibre15">run()</kbd> method of the parent class, and store the finish date of the execution:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          setStartDate(); <br class="title-page-name"/>          super.run(); <br class="title-page-name"/>          setFinishDate(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement a method to establish the value of the <kbd class="calibre15">startDate</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public synchronized void setStartDate() { <br class="title-page-name"/>          startDate=new Date(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a method to establish the value of the <kbd class="calibre15">finishDate</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public synchronized void setFinishDate() { <br class="title-page-name"/>          finishDate=new Date(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement a method named <kbd class="calibre15">getExecutionTime()</kbd> that calculates the execution time of the thread as the difference between start and finish dates:</li>
</ol>
<pre class="calibre23">
        public synchronized long getExecutionTime() { <br class="title-page-name"/>          return finishDate.getTime()-startDate.getTime(); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Override the <kbd class="calibre15">toString()</kbd> method to return the creation date and execution time of the thread:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public synchronized String toString(){ <br class="title-page-name"/>          StringBuilder buffer=new StringBuilder(); <br class="title-page-name"/>          buffer.append(getName()); <br class="title-page-name"/>          buffer.append(": "); <br class="title-page-name"/>          buffer.append(" Creation Date: "); <br class="title-page-name"/>          buffer.append(creationDate); <br class="title-page-name"/>          buffer.append(" : Running time: "); <br class="title-page-name"/>          buffer.append(getExecutionTime()); <br class="title-page-name"/>          buffer.append(" Milliseconds."); <br class="title-page-name"/>          return buffer.toString(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create a class named <kbd class="calibre15">MyThreadFactory</kbd> that implements the <kbd class="calibre15">ThreadFactory</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class MyThreadFactory implements ThreadFactory {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">counter</kbd>:</li>
</ol>
<pre class="calibre23">
        private AtomicInteger counter;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">prefix</kbd>:</li>
</ol>
<pre class="calibre23">
        private String prefix;
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public MyThreadFactory (String prefix) { <br class="title-page-name"/>          this.prefix=prefix; <br class="title-page-name"/>          counter=new AtomicInteger(1); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">newThread()</kbd> method. Create a <kbd class="calibre15">MyThread</kbd> object and increment the <kbd class="calibre15">counter</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Thread newThread(Runnable r) { <br class="title-page-name"/>          MyThread myThread=new MyThread(r,prefix+"-"+counter<br class="title-page-name"/>                                                  .getAndIncrement()); <br class="title-page-name"/>          return myThread; <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a class named <kbd class="calibre15">MyTask</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface. Implement the <kbd class="calibre15">run()</kbd> method. Put the current thread to sleep for 2 seconds:</li>
</ol>
<pre class="calibre23">
        public class MyTask implements Runnable { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/>            try { <br class="title-page-name"/>              TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create a <kbd class="calibre15">MyThreadFactory</kbd> object:</li>
</ol>
<pre class="calibre23">
        MyThreadFactory myFactory=new MyThreadFactory<br class="title-page-name"/>                                               ("MyThreadFactory");
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object:</li>
</ol>
<pre class="calibre23">
        MyTask task=new MyTask();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a <kbd class="calibre15">MyThread</kbd> object to execute the task using the <kbd class="calibre15">newThread()</kbd> method of the factory:</li>
</ol>
<pre class="calibre23">
        Thread thread=myFactory.newThread(task);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Start the thread and wait for its finalization:</li>
</ol>
<pre class="calibre23">
        thread.start(); <br class="title-page-name"/>        thread.join();
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Write information about the thread using the <kbd class="calibre15">toString()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Thread information.\n"); <br class="title-page-name"/>        System.out.printf("%s\n",thread); <br class="title-page-name"/>        System.out.printf("Main: End of the example.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented a custom <kbd class="calibre15">MyThread</kbd> class extending the <kbd class="calibre15">Thread</kbd> class. This class has three attributes to store the creation date, the start date of its execution, and the end date of its execution. Using the start date and end date attributes, you implemented the <kbd class="calibre15">getExecutionTime()</kbd> method that returns the total time the thread spent in executing its task. Finally, you overrode the <kbd class="calibre15">toString()</kbd> method to generate information about a thread.</p>
<p class="calibre4">Once you had your own thread class, you implemented a factory to create objects of that class by implementing the <kbd class="calibre15">ThreadFactory</kbd> interface. It's not mandatory to make use of the interface if you're going to use your factory as an independent object, but if you want to use this factory with other classes of the Java Concurrency API, you must construct your factory by implementing this interface. The <kbd class="calibre15">ThreadFactory</kbd> interface has only one method: the <kbd class="calibre15">newThread()</kbd> method. This method receives a <kbd class="calibre15">Runnable</kbd> object as a parameter and returns a <kbd class="calibre15">Thread</kbd> object to execute the <kbd class="calibre15">Runnable</kbd> object. In your case, you returned a <kbd class="calibre15">MyThread</kbd> object.</p>
<p class="calibre4">To check these two classes, you implemented the <kbd class="calibre15">MyTask</kbd> class that implemented the <kbd class="calibre15">Runnable</kbd> object. This is the task to be executed in threads managed by the <kbd class="calibre15">MyThread</kbd> object. A <kbd class="calibre15">MyTask</kbd> instance puts its execution thread to sleep for 2 seconds.</p>
<p class="calibre4">In the main method of the example, you created a <kbd class="calibre15">MyThread</kbd> object using a <kbd class="calibre15">MyThreadFactory</kbd> factory to execute a <kbd class="calibre15">Task</kbd> object. If you execute the program, you will see a message with the start date and the execution time of the thread executed.<span>The following screenshot shows the output generated by this example:</span></p>
<div class="cdpaligncenter"><img class="alignnone35" src="../images/00051.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The Java Concurrency API provides the <kbd class="calibre15">Executors</kbd> class to generate thread executors, usually objects of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class. You can also use this class to obtain the most basic implementation of the <kbd class="calibre15">ThreadFactory</kbd> interface, using the <kbd class="calibre15">defaultThreadFactory()</kbd> method. The factory generated by this method generates basic <kbd class="calibre15">Thread</kbd> objects that belong to the same <kbd class="calibre15">ThreadGroup</kbd> object. You can use the <kbd class="calibre15">ThreadFactory</kbd> interface in your program for any purpose, not necessarily related only to the Executor framework.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using our ThreadFactory in an Executor object</h1>
            

            <article>
                
<p class="calibre4">In the previous recipe, we introduced the factory pattern and provided an example of how to implement a factory of threads implementing the <kbd class="calibre15">ThreadFactory</kbd> interface.</p>
<p class="calibre4">The Executor framework is a mechanism that allows you to separate thread creation and its execution. It's based on the <kbd class="calibre15">Executor</kbd> and <kbd class="calibre15">ExecutorService</kbd> interfaces and the <kbd class="calibre15">ThreadPoolExecutor</kbd> class that implements both these interfaces. It has an internal pool of threads and provides methods that allow you to send two kinds of tasks to execute them in the pooled threads. These two kinds of tasks are as follows:</p>
<ul class="calibre17">
<li class="calibre18">Classes that implement the <kbd class="calibre15">Runnable</kbd> interface, to implement tasks that don't return a result</li>
<li class="calibre18">Classes that implement the <kbd class="calibre15">Callable</kbd> interface, to implement tasks that return a result</li>
</ul>
<p class="calibre4">Internally, the <kbd class="calibre15">Executor</kbd> framework uses a <kbd class="calibre15">ThreadFactory</kbd> interface to create threads that it uses to generate new threads. In this recipe, you will learn how to implement your own thread class, a thread factory to create threads of this class, and how to use this factory in an executor so the executor will execute your threads.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">Read the previous recipe and implement its example.</p>
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Copy the <kbd class="calibre15">MyThread</kbd>, <kbd class="calibre15">MyThreadFactory</kbd>, and <kbd class="calibre15">MyTask</kbd> classes into the project. They were implemented in the <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</em> recipe. You are going to use them in this example.</li>
<li value="2" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a new <kbd class="calibre15">MyThreadFactory</kbd> object named <kbd class="calibre15">threadFactory</kbd>:</li>
</ol>
<pre class="calibre23">
        MyThreadFactory threadFactory=new MyThreadFactory<br class="title-page-name"/>                                                  ("MyThreadFactory");
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a new <kbd class="calibre15">Executor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class. Pass the factory object created earlier as a parameter. The new <kbd class="calibre15">Executor</kbd> object will use this factory to create the necessary threads, so it will execute <kbd class="calibre15">MyThread</kbd> threads:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor=Executors.newCachedThreadPool<br class="title-page-name"/>                                                     (threadFactory);
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a new <kbd class="calibre15">Task</kbd> <span>object and send it to the executor using the</span> <kbd class="calibre15">submit()</kbd> <span>method:</span></li>
</ol>
<pre class="calibre23">
        MyTask task=new MyTask(); <br class="title-page-name"/>        executor.submit(task);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Shut down the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Wait for the finalization of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.awaitTermination(1, TimeUnit.DAYS);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Write a message to indicate the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In the <em class="calibre14">How it works...</em> section of the previous recipe, you have a detailed explanation of how the <kbd class="calibre15">MyThread</kbd>, <kbd class="calibre15">MyThreadFactory</kbd>, and <kbd class="calibre15">MyTask</kbd> classes work.</p>
<p class="calibre4">In the <kbd class="calibre15">main()</kbd> method of the example, you created an <kbd class="calibre15">Executor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class. You passed the factory object created earlier as a parameter, so the <kbd class="calibre15">Executor</kbd> object created will use that factory to create the threads it needs and also execute threads of the <kbd class="calibre15">MyThread</kbd> class.</p>
<p class="calibre4">Execute the program and you will see a message with information about the thread's start date and its execution time. The following screenshot shows the output generated by this example:</p>
<div class="cdpaligncenter"><img class="alignnone36" src="../images/00052.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Customizing tasks running in a scheduled thread pool</h1>
            

            <article>
                
<p class="calibre4">Scheduled thread pool is an extension of the basic thread pool of the <kbd class="calibre15">Executor</kbd> framework that allows you to schedule the execution of tasks to be executed after a period of time. It's implemented by the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class, and it permits the execution of the following two kinds of tasks:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Delayed tasks</strong>: These kinds of tasks are executed only once after a period of time</li>
<li class="calibre18"><strong class="calibre1">Periodic tasks</strong>: These kinds of tasks are executed after a delay and then periodically, every so often</li>
</ul>
<p class="calibre4">Delayed tasks can execute both <kbd class="calibre15">Callable</kbd> and <kbd class="calibre15">Runnable</kbd> objects, but periodic tasks can only execute <kbd class="calibre15">Runnable</kbd> objects. All the tasks executed by a scheduled pool are an implementation of the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface. In this recipe, you will learn how to implement your own implementation of the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface to execute both delayed and periodic tasks.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyScheduledTask</kbd> parameterized by a generic type named <kbd class="calibre15">V</kbd>. It extends the <kbd class="calibre15">FutureTask</kbd> class and implements the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class MyScheduledTask&lt;V&gt; extends FutureTask&lt;V&gt;<br class="title-page-name"/>                                implements RunnableScheduledFuture&lt;V&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private<kbd class="calibre15">RunnableScheduledFuture</kbd> <span>attribute named</span> <kbd class="calibre15">task</kbd><span>:</span></li>
</ol>
<pre class="calibre23">
        private RunnableScheduledFuture&lt;V&gt; task;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private<kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class named <kbd class="calibre15">executor</kbd>:</li>
</ol>
<pre class="calibre23">
        private ScheduledThreadPoolExecutor executor;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Declare a private <kbd class="calibre15">long</kbd> attribute named <kbd class="calibre15">period</kbd>:</li>
</ol>
<pre class="calibre23">
        private long period;
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Declare a private <kbd class="calibre15">long</kbd> attribute named <kbd class="calibre15">startDate</kbd>:</li>
</ol>
<pre class="calibre23">
        private long startDate;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a constructor of the class. It receives the <kbd class="calibre15">Runnable</kbd> object that is going to be executed by a task, the result that will be returned by this task, the <kbd class="calibre15">RunnableScheduledFuture</kbd> task that will be used to create the <kbd class="calibre15">MyScheduledTask</kbd> object, and the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> object that is going to execute the task. Call the constructor of its parent class and store the task and <kbd class="calibre15">executor</kbd> attributes:</li>
</ol>
<pre class="calibre23">
        public MyScheduledTask(Runnable runnable, V result,<br class="title-page-name"/>                               RunnableScheduledFuture&lt;V&gt; task,<br class="title-page-name"/>                               ScheduledThreadPoolExecutor executor) { <br class="title-page-name"/>          super(runnable, result); <br class="title-page-name"/>          this.task=task; <br class="title-page-name"/>          this.executor=executor; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">getDelay()</kbd> method. If the task is periodic and the <kbd class="calibre15">startDate</kbd> attribute has a value other than zero, calculate the returned value as the difference between the <kbd class="calibre15">startDate</kbd> attribute and the actual date. Otherwise, return the delay of the original task stored in the task attribute. Don't forget that you have to return the result in the time unit passed as a parameter:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public long getDelay(TimeUnit unit) { <br class="title-page-name"/>          if (!isPeriodic()) { <br class="title-page-name"/>            return task.getDelay(unit); <br class="title-page-name"/>          } else { <br class="title-page-name"/>            if (startDate==0){ <br class="title-page-name"/>              return task.getDelay(unit); <br class="title-page-name"/>            } else { <br class="title-page-name"/>              Date now=new Date(); <br class="title-page-name"/>              long delay=startDate-now.getTime(); <br class="title-page-name"/>              return unit.convert(delay, TimeUnit.MILLISECONDS); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">compareTo()</kbd> method. Call the <kbd class="calibre15">compareTo()</kbd> method of the original task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int compareTo(Delayed o) { <br class="title-page-name"/>          return task.compareTo(o); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">isPeriodic()</kbd> method. Call the <kbd class="calibre15">isPeriodic()</kbd> method of the original task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean isPeriodic() { <br class="title-page-name"/>          return task.isPeriodic(); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. If it's a periodic task, you have to update its <kbd class="calibre15">startDate</kbd> attribute with the start date of the next execution of the task. Calculate it as the sum of the actual date and period. Then, add the task again to the queue of the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          if (isPeriodic() &amp;&amp; (!executor.isShutdown())) { <br class="title-page-name"/>            Date now=new Date(); <br class="title-page-name"/>            startDate=now.getTime()+period; <br class="title-page-name"/>            executor.getQueue().add(this); <br class="title-page-name"/>          }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Print a message to the console with the actual date. Execute the task calling the <kbd class="calibre15">runAndReset()</kbd> method and then print another message to the console with the actual date:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Pre-MyScheduledTask: %s\n",new Date()); <br class="title-page-name"/>          System.out.printf("MyScheduledTask: Is Periodic: %s\n",<br class="title-page-name"/>                            isPeriodic()); <br class="title-page-name"/>          super.runAndReset(); <br class="title-page-name"/>          System.out.printf("Post-MyScheduledTask: %s\n",new Date()); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the<kbd class="calibre15">setPeriod()</kbd> method to establish the period of this task:</li>
</ol>
<pre class="calibre23">
        public void setPeriod(long period) { <br class="title-page-name"/>          this.period=period; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a class named <kbd class="calibre15">MyScheduledThreadPoolExecutor</kbd> to implement a <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> object that executes <kbd class="calibre15">MyScheduledTask</kbd> tasks. Specify that this class extends the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyScheduledThreadPoolExecutor extends<br class="title-page-name"/>                                          ScheduledThreadPoolExecutor {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement a constructor of the class that merely calls the constructor of its parent class:</li>
</ol>
<pre class="calibre23">
        public MyScheduledThreadPoolExecutor(int corePoolSize) { <br class="title-page-name"/>          super(corePoolSize); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">decorateTask()</kbd> method. It receives the <kbd class="calibre15">Runnable</kbd> object that is going to be executed as a parameter and the <kbd class="calibre15">RunnableScheduledFuture</kbd> task that will execute this <kbd class="calibre15">Runnable</kbd> object. Create and return a <kbd class="calibre15">MyScheduledTask</kbd> task using these objects to construct them:</li>
</ol>
<pre class="calibre23">
        <br class="title-page-name"/>        @Override <br class="title-page-name"/>        protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(<br class="title-page-name"/>                                   Runnable runnable,<br class="title-page-name"/>                                   RunnableScheduledFuture&lt;V&gt; task) { <br class="title-page-name"/>          MyScheduledTask&lt;V&gt; myTask=new MyScheduledTask&lt;V&gt;(runnable,<br class="title-page-name"/>                                                    null, task,this);   <br class="title-page-name"/>          return myTask; <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Override the <kbd class="calibre15">scheduledAtFixedRate()</kbd> method. Call the method of its parent class, convert the returned object into a <kbd class="calibre15">MyScheduledTask</kbd> object, and establish the period of that task using the <kbd class="calibre15">setPeriod()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br class="title-page-name"/>                       long initialDelay, long period, TimeUnit unit) { <br class="title-page-name"/>          ScheduledFuture&lt;?&gt; task= super.scheduleAtFixedRate(command,<br class="title-page-name"/>                                        initialDelay, period, unit); <br class="title-page-name"/>          MyScheduledTask&lt;?&gt; myTask=(MyScheduledTask&lt;?&gt;)task; <br class="title-page-name"/>          myTask.setPeriod(TimeUnit.MILLISECONDS.convert(period,unit)); <br class="title-page-name"/>          return task; <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Print a message at the start of the task, put the current thread to sleep for 2 seconds, and print another message at the end of the task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("Task: Begin.\n"); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Task: End.\n"); <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception{
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create a <kbd class="calibre15">MyScheduledThreadPoolExecutor</kbd> object named executor. Use <kbd class="calibre15">4</kbd> as a parameter to have two threads in the pool:</li>
</ol>
<pre class="calibre23">
        MyScheduledThreadPoolExecutor executor=new<br class="title-page-name"/>                                 MyScheduledThreadPoolExecutor(4);
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object named <kbd class="calibre15">task</kbd>. Write the actual date in the console:</li>
</ol>
<pre class="calibre23">
        Task task=new Task(); <br class="title-page-name"/>        System.out.printf("Main: %s\n",new Date());
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Send a delayed task to the executor using the <kbd class="calibre15">schedule()</kbd> method. The task will be executed after a 1-second delay:</li>
</ol>
<pre class="calibre23">
        executor.schedule(task, 1, TimeUnit.SECONDS);
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Put the main thread to sleep for <kbd class="calibre15">3</kbd> seconds:</li>
</ol>
<pre class="calibre23">
        TimeUnit.SECONDS.sleep(3);
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Create another <kbd class="calibre15">Task</kbd> object. Print the actual date in the console again:</li>
</ol>
<pre class="calibre23">
        task=new Task(); <br class="title-page-name"/>        System.out.printf("Main: %s\n",new Date());
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Send a periodic task to the executor using the <kbd class="calibre15">scheduleAtFixedRate()</kbd> method. The task will be executed after a 1-second delay and then it will be executed every 3 seconds:</li>
</ol>
<pre class="calibre23">
        executor.scheduleAtFixedRate(task, 1, 3, TimeUnit.SECONDS);
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Put the main thread to sleep for 10 seconds:</li>
</ol>
<pre class="calibre23">
        TimeUnit.SECONDS.sleep(10);
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Shut down the executor using the <kbd class="calibre15">shutdown()</kbd> method. Wait for the finalization of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown(); <br class="title-page-name"/>        executor.awaitTermination(1, TimeUnit.DAYS);
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Write a message in the console indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented the <kbd class="calibre15">MyScheduledTask</kbd> class to implement a custom task that can be executed on a <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> executor. This class extends the <kbd class="calibre15">FutureTask</kbd> class and implements the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface. It implements the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface because all the tasks executed in a scheduled executor must implement this interface and extend the <kbd class="calibre15">FutureTask</kbd> class. This is because this class provides valid implementations of the methods declared in the <kbd class="calibre15">RunnableScheduledFuture</kbd> interface. All the interfaces and classes mentioned earlier are parameterized classes and they possess the type of data that will be returned by the tasks.</p>
<p class="calibre4">To use a <kbd class="calibre15">MyScheduledTask</kbd> task in a scheduled executor, you override the <kbd class="calibre15">decorateTask()</kbd> method in the <kbd class="calibre15">MyScheduledThreadPoolExecutor</kbd> class. This class extends the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> executor, and the method provides a mechanism to convert the default scheduled tasks implemented by the <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> executor into <kbd class="calibre15">MyScheduledTask</kbd> tasks. So, when you implement your own version of scheduled tasks, you have to implement your own version of a scheduled executor.</p>
<div class="packt_infobox">The <kbd class="calibre25">decorateTask()</kbd> method simply creates a new <kbd class="calibre25">MyScheduledTask</kbd> object with four parameters. The first one is a <kbd class="calibre25">Runnable</kbd> object that is going to be executed in the task. The second one is the object that is going to be returned by the task. In this case, the task won't return a result, so you used the null value. The third one is the task that the new object is going to replace in the pool and the latest is the executor that will execute the task. In this case, you use the this keyword to reference the executor that is creating the task.</div>
<p class="calibre4">The <kbd class="calibre15">MyScheduledTask</kbd> class can execute delayed and periodic tasks. You implemented two methods with all of the necessary logic to execute both kinds of tasks. They are the <kbd class="calibre15">getDelay()</kbd> and <kbd class="calibre15">run()</kbd> methods.</p>
<p class="calibre4">The <kbd class="calibre15">getDelay()</kbd> method is called by the scheduled executor to know whether it has to execute a task. The behavior of this method changes in delayed and periodic tasks. As mentioned earlier, the constructor of the <kbd class="calibre15">MyScheduledClass</kbd> class receives the original <kbd class="calibre15">ScheduledRunnableFuture</kbd> object that was going to execute the <kbd class="calibre15">Runnable</kbd> object and stores it as an attribute of the class to have access to its methods and data. When we execute a delayed task, the <kbd class="calibre15">getDelay()</kbd> method returns the delay of the original task; however, in the case of a periodic task, the <kbd class="calibre15">getDelay()</kbd> method returns the difference between the <kbd class="calibre15">startDate</kbd> attribute and the actual date.</p>
<p class="calibre4">The <kbd class="calibre15">run()</kbd> method is the one that executes the task. One particularity of periodic tasks is that you have to put the next execution of the task in the queue of the executor as a new task if you want the task to be executed again. So, if you're executing a periodic task, you establish the <kbd class="calibre15">startDate</kbd> attribute value and add it to the actual date and period of the execution of the task and store the task again in the queue of the executor. The <kbd class="calibre15">startDate</kbd> attribute stores the date when the next execution of the task will begin. Then, you execute the task using the <kbd class="calibre15">runAndReset()</kbd> method provided by the <kbd class="calibre15">FutureTask</kbd> class. In the case of delayed tasks, you don't have to put them in the queue of the executor because they can only be executed once.</p>
<div class="packt_infobox">You also have to take into account whether the executor has been shut down. If yes, you don't have to store the periodic tasks in the queue of the executor again.</div>
<p class="calibre4">Finally, you overrode the <kbd class="calibre15">scheduleAtFixedRate()</kbd> method in the <kbd class="calibre15">MyScheduledThreadPoolExecutor</kbd> class. We mentioned earlier that for periodic tasks, you establish the value of the <kbd class="calibre15">startDate</kbd> attribute using the period of the task, but you haven't initialized that period yet. You have to override this method that receives this period as a parameter; do this to pass it to the <kbd class="calibre15">MyScheduledTask</kbd> class so it can use it.</p>
<p class="calibre4">The example is complete with the <kbd class="calibre15">Task</kbd> class that implements the <kbd class="calibre15">Runnable</kbd> interface, and it is the task executed in the scheduled executor. The main class of the example creates a <kbd class="calibre15">MyScheduledThreadPoolExecutor</kbd> executor and sends the following two tasks to them:</p>
<ul class="calibre17">
<li class="calibre18">A delayed task, which is to be executed 1 second after the actual date</li>
<li class="calibre18">A periodic task, which is to be executed for the first time a second after the actual date and then every 3 seconds</li>
</ul>
<p class="calibre4">The following screenshot shows part of the execution of this example. You can check whether the two kinds of tasks are executed properly:</p>
<div class="cdpaligncenter"><img class="alignnone37" src="../images/00053.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ScheduledThreadPoolExecutor</kbd> class provides another version of the <kbd class="calibre15">decorateTask()</kbd> method that receives a <kbd class="calibre15">Callable</kbd> object as a parameter, instead of a <kbd class="calibre15">Runnable</kbd> object.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Running a task in an executor after a delay</em> and <em class="calibre14">Running a task in an executor periodically</em> recipes in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</h1>
            

            <article>
                
<p class="calibre4">One of the most interesting features of Java 9 is the fork/join framework. It's an implementation of the <kbd class="calibre15">Executor</kbd> and <kbd class="calibre15">ExecutorService</kbd> interfaces that allows you to execute the <kbd class="calibre15">Callable</kbd> and <kbd class="calibre15">Runnable</kbd> tasks without managing the threads that execute them.</p>
<p class="calibre4">This executor is oriented to execute tasks that can be divided into smaller parts. Its main components are as follows:</p>
<ul class="calibre17">
<li class="calibre18">It's a special kind of task, which is implemented by the <kbd class="calibre15">ForkJoinTask</kbd> class.</li>
<li class="calibre18">It provides two operations for dividing a task into subtasks (the fork operation) and to wait for the finalization of these subtasks (the join operation).</li>
<li class="calibre18">It's an algorithm, denominating the work-stealing algorithm, that optimizes the use of the threads of the pool. When a task waits for its subtasks, the thread that was executing it is used to execute another thread.</li>
</ul>
<p class="calibre4">The main class of the fork/join framework is the <kbd class="calibre15">ForkJoinPool</kbd> class. Internally, it has the following two elements:</p>
<ul class="calibre17">
<li class="calibre18">A queue of tasks that are waiting to be executed</li>
<li class="calibre18">A pool of threads that execute the tasks</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">ForkJoinWorkerThread</kbd> adds new methods to the <kbd class="calibre15">Thread</kbd> class, such as the <kbd class="calibre15">onStart()</kbd> method that's executed when the thread is created and the <kbd class="calibre15">onTermination()</kbd> method that's called to clean up the resources used by the thread. The <kbd class="calibre15">ForkJoinPool</kbd> class uses an implementation of the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface to create the worker threads it uses.</p>
<p class="calibre4">In this recipe, you will learn how to implement a customized worker thread to be used in a <kbd class="calibre15">ForkJoinPool</kbd> class and how to use it with a factory extending the <kbd class="calibre15">ForkJoinPool</kbd> class and implementing the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyWorkerThread</kbd> that extends the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyWorkerThread extends ForkJoinWorkerThread {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare and create a private <kbd class="calibre15">ThreadLocal</kbd> attribute parameterized by the <kbd class="calibre15">Integer</kbd> class named <kbd class="calibre15">taskCounter</kbd>:</li>
</ol>
<pre class="calibre23">
        private final static ThreadLocal&lt;Integer&gt; taskCounter=<br class="title-page-name"/>                                         new ThreadLocal&lt;Integer&gt;();
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement a constructor of the class:</li>
</ol>
<pre class="calibre23">
        protected MyWorkerThread(ForkJoinPool pool) { <br class="title-page-name"/>          super(pool); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Override the <kbd class="calibre15">onStart()</kbd> method. Call the method on its parent class, print a message to the console, and set the value of the <kbd class="calibre15">taskCounter</kbd> attribute of this thread to zero:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void onStart() { <br class="title-page-name"/>          super.onStart(); <br class="title-page-name"/>          System.out.printf("MyWorkerThread %d: Initializing task<br class="title-page-name"/>                             counter.\n", getId()); <br class="title-page-name"/>          taskCounter.set(0); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Override the <kbd class="calibre15">onTermination()</kbd> method. Write the value of the <kbd class="calibre15">taskCounter</kbd> attribute of this thread in the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void onTermination(Throwable exception) { <br class="title-page-name"/>          System.out.printf("MyWorkerThread %d: %d\n",<br class="title-page-name"/>                            getId(),taskCounter.get()); <br class="title-page-name"/>          super.onTermination(exception); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">addTask()</kbd> method. Increment the value of the <kbd class="calibre15">taskCounter</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public void addTask(){ <br class="title-page-name"/>          taskCounter.set(taskCounter.get() + 1);; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">MyWorkerThreadFactory</kbd> that implements the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface. Implement the <kbd class="calibre15">newThread()</kbd> method. Create and return a <kbd class="calibre15">MyWorkerThread</kbd> object:</li>
</ol>
<pre class="calibre23">
        public class MyWorkerThreadFactory implements<br class="title-page-name"/>                       ForkJoinWorkerThreadFactory { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public ForkJoinWorkerThread newThread(ForkJoinPool pool) { <br class="title-page-name"/>            return new MyWorkerThread(pool); <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">MyRecursiveTask</kbd> that extends the <kbd class="calibre15">RecursiveTask</kbd> class parameterized by the <kbd class="calibre15">Integer</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyRecursiveTask extends RecursiveTask&lt;Integer&gt; {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> array named <kbd class="calibre15">array</kbd>:</li>
</ol>
<pre class="calibre23">
        private int array[];
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>:</li>
</ol>
<pre class="calibre23">
        private int start, end;
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the constructor of the class that initializes its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(int array[],int start, int end) { <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method to sum all the elements of the array between the start and end positions. First, convert the thread that is executing the task into a <kbd class="calibre15">MyWorkerThread</kbd> object and use the <kbd class="calibre15">addTask()</kbd> method to increment the counter of tasks for that thread:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected Integer compute() { <br class="title-page-name"/>          Integer ret; <br class="title-page-name"/>          MyWorkerThread thread=(MyWorkerThread)Thread.currentThread(); <br class="title-page-name"/>          thread.addTask();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">If the difference between the start and end positions in the array is higher than 100 elements, we calculate the position in the middle and create two new <kbd class="calibre15">MyRecursiveTask</kbd> tasks to process the first and second halves, respectively. If the difference is equal to or lower than 100, we calculate the sum of all the elements between the start and end positions:</li>
</ol>
<pre class="calibre23">
        if (end-start&gt;100) { <br class="title-page-name"/>          int mid=(start+end)/2; <br class="title-page-name"/>          MyRecursiveTask task1=new MyRecursiveTask(array,start,mid); <br class="title-page-name"/>          MyRecursiveTask task2=new MyRecursiveTask(array,mid,end); <br class="title-page-name"/>          invokeAll(task1,task2); <br class="title-page-name"/>          ret=addResults(task1,task2); <br class="title-page-name"/>        } else { <br class="title-page-name"/>          int add=0; <br class="title-page-name"/>          for (int i=start; i&lt;end; i++) { <br class="title-page-name"/>            add+=array[i]; <br class="title-page-name"/>          } <br class="title-page-name"/>          ret=add; <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Put the thread to sleep for 10 milliseconds and return the result of the task:</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(10); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          return ret; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">addResults()</kbd> method. Calculate and return the sum of the results of the two tasks received as parameters:</li>
</ol>
<pre class="calibre23">
        private Integer addResults(Task task1, Task task2) { <br class="title-page-name"/>          int value; <br class="title-page-name"/>          try { <br class="title-page-name"/>            value = task1.get().intValue()+task2.get().intValue(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>            value=0; <br class="title-page-name"/>          } catch (ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>            value=0; <br class="title-page-name"/>          }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">MyWorkerThreadFactory</kbd> object named <kbd class="calibre15">factory</kbd>:</li>
</ol>
<pre class="calibre23">
        MyWorkerThreadFactory factory=new MyWorkerThreadFactory();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object named <kbd class="calibre15">pool</kbd>. Pass the <kbd class="calibre15">factory</kbd> object, created earlier, to the constructor:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(4, factory, null, false);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create an array of 100,000 integers. Initialize all the elements to 1:</li>
</ol>
<pre class="calibre23">
        int array[]=new int[100000]; <br class="title-page-name"/>        for (int i=0; i&lt;array.length; i++){ <br class="title-page-name"/>          array[i]=1; <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create a new <kbd class="calibre15">task</kbd> object to sum all the elements of the array:</li>
</ol>
<pre class="calibre23">
        MyRecursiveTask task=new MyRecursiveTask(array,0,array.length);
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Send the task to the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task);
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Wait for the end of the task using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        task.join();
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Shut down the pool using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown();
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Wait for the finalization of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.awaitTermination(1, TimeUnit.DAYS);
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Write the result of the task in the console, using the <kbd class="calibre15">get()</kbd> method:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Result: %d\n",task.get());
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Write a message in the console indicating the end of the example:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">Threads used by the fork/join framework are called worker threads. Java includes the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class that extends the <kbd class="calibre15">Thread</kbd> class and implements the worker threads used by the fork/join framework.</p>
<p class="calibre4">In this recipe, you implemented the <kbd class="calibre15">MyWorkerThread</kbd> class that extends the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class and overrides two methods of the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class. Your objective is to implement a counter of tasks in each worker thread so that you can know how many tasks a worker thread has executed. You implemented the counter with a <kbd class="calibre15">ThreadLocal</kbd> attribute. This way, each thread will have its own counter in a transparent way for you, the programmer.</p>
<p class="calibre4">You overrode the <kbd class="calibre15">onStart()</kbd> method of the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class to initialize the task counter. This method is called when the worker thread begins its execution. You also overrode the <kbd class="calibre15">onTermination()</kbd> method to print the value of the task counter to the console. This method is called when the worker thread finishes its execution. In addition, you implemented a method in the <kbd class="calibre15">MyWorkerThread</kbd> class. The <kbd class="calibre15">addTask()</kbd> method increments the task counter of each thread.</p>
<p class="calibre4">The <kbd class="calibre15">ForkJoinPool</kbd> class, like with all the executors in the Java Concurrency API, creates its threads using a factory. So, if you want to use the <kbd class="calibre15">MyWorkerThread</kbd> thread in a <kbd class="calibre15">ForkJoinPool</kbd> class, you have to implement your thread factory. For the fork/join framework, this factory has to implement the <kbd class="calibre15">ForkJoinPool.ForkJoinWorkerThreadFactory</kbd> class. You implemented the <kbd class="calibre15">MyWorkerThreadFactory</kbd> class for this purpose. This class only has one method that creates a new <kbd class="calibre15">MyWorkerThread</kbd> object.</p>
<p class="calibre4">Finally, you only have to initialize a <kbd class="calibre15">ForkJoinPool</kbd> class with the factory you have created. You did this in the <kbd class="calibre15">Main</kbd> class, using the constructor of the <kbd class="calibre15">ForkJoinPool</kbd> class.</p>
<p class="calibre4">The following screenshot shows part of the output of the program:</p>
<div class="cdpaligncenter"><img class="alignnone38" src="../images/00054.jpeg"/></div>
<p class="calibre4">You can see how the <kbd class="calibre15">ForkJoinPool</kbd> object has executed four worker threads and how many tasks have executed each one of them.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Take into account that the <kbd class="calibre15">onTermination()</kbd> method provided by the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class is called when a thread finishes normally or throws an exception. The method receives a <kbd class="calibre15">Throwable</kbd> object as a parameter. If the parameter takes the null value, the worker thread finishes normally; however, if the parameter takes a value, the thread throws an exception. You have to include the necessary code to process this situation.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in <a href="part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 5</span></a>, <em class="calibre14">Fork/Join Framework</em></li>
<li class="calibre18">The <em class="calibre14">Creating threads through a factory</em> recipe in <a href="part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre14">Thread Management</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Customizing tasks running in the fork/join framework</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework separates task creation and its execution. With it, you only have to implement the <kbd class="calibre15">Runnable</kbd> objects and use an <kbd class="calibre15">Executor</kbd> object. You just need to send the <kbd class="calibre15">Runnable</kbd> tasks to the executor and it creates, manages, and finalizes the necessary threads to execute these tasks.</p>
<p class="calibre4">Java 9 provides a special kind of executor in the fork/join framework (introduced in Java 7). This framework is designed to solve problems that can be broken down into smaller tasks using the divide and conquer technique. Inside a task, you have to check the size of the problem you want to resolve; if it's bigger than the established size, you divide the problem into two or more tasks and execute them using the framework. If the size of the problem is smaller than the established size, you resolve the problem directly in the task; optionally, it returns a result. The fork/join framework implements the work-stealing algorithm that improves the overall performance of these kinds of problems.</p>
<p class="calibre4">The <kbd class="calibre15">main</kbd> class of the fork/join framework is the <kbd class="calibre15">ForkJoinPool</kbd> class. Internally, it has the following two elements:</p>
<ul class="calibre17">
<li class="calibre18">A queue of tasks that are waiting to be executed</li>
<li class="calibre18">A pool of threads that execute the tasks</li>
</ul>
<p class="calibre4">By default, the tasks executed by a <kbd class="calibre15">ForkJoinPool</kbd> class are objects of the <kbd class="calibre15">ForkJoinTask</kbd> class. You can also send the <kbd class="calibre15">Runnable</kbd> and <kbd class="calibre15">Callable</kbd> objects to a <kbd class="calibre15">ForkJoinPool</kbd> class, but they can't take advantage of all the benefits of the fork/join framework. Normally, you will send one of two subclasses of the <kbd class="calibre15">ForkJoinTask</kbd> class to the <kbd class="calibre15">ForkJoinPool</kbd> object:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">RecursiveAction</kbd>: If your tasks don't return a result</li>
<li class="calibre18"><kbd class="calibre15">RecursiveTask</kbd>: If your tasks return a result</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to implement your own tasks for the fork/join framework by implementing a task that extends the <kbd class="calibre15">ForkJoinTask</kbd> class. The task you're going to implement measures and writes its execution time in the console so you can control its evolution. You can also implement your own fork/join task to write log information, to get resources used in the tasks, or to postprocess the results of the tasks.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyWorkerTask</kbd> and specify that it extends the <kbd class="calibre15">ForkJoinTask</kbd> class parameterized by the <kbd class="calibre15">Void</kbd> type:</li>
</ol>
<pre class="calibre23">
        public abstract class MyWorkerTask extends ForkJoinTask&lt;Void&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd> to store the name of the task:</li>
</ol>
<pre class="calibre23">
        private String name;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public MyWorkerTask(String name) { <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">getRawResult()</kbd> method. This is one of the abstract methods of the <kbd class="calibre15">ForkJoinTask</kbd> class. As the <kbd class="calibre15">MyWorkerTask</kbd> tasks won't return any results, this method must return null:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Void getRawResult() { <br class="title-page-name"/>          return null; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">setRawResult()</kbd> method. This is another abstract method of the <kbd class="calibre15">ForkJoinTask</kbd> class. As the <kbd class="calibre15">MyWorkerTask</kbd> tasks won't return any results, leave the body of this method empty:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void setRawResult(Void value) { <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">exec()</kbd> method. This is the <kbd class="calibre15">main</kbd> method of the task. In this case, delegate the logic of the task to the <kbd class="calibre15">compute()</kbd> method. Calculate the execution time of this method and write it in the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected boolean exec() { <br class="title-page-name"/>          Date startDate=new Date(); <br class="title-page-name"/>          compute(); <br class="title-page-name"/>          Date finishDate=new Date(); <br class="title-page-name"/>          long diff=finishDate.getTime()-startDate.getTime(); <br class="title-page-name"/>          System.out.printf("MyWorkerTask: %s : %d Milliseconds to<br class="title-page-name"/>                             complete.\n",name,diff); <br class="title-page-name"/>          return true; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">getName()</kbd> method to return the name of the task:</li>
</ol>
<pre class="calibre23">
        public String getName(){ <br class="title-page-name"/>          return name; <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare the abstract method <kbd class="calibre15">compute()</kbd>. As mentioned earlier, this method will implement the logic of the tasks, and it must be implemented by the child classes of the <kbd class="calibre15">MyWorkerTask</kbd> class:</li>
</ol>
<pre class="calibre23">
        protected abstract void compute();
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that extends the <kbd class="calibre15">MyWorkerTask</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task extends MyWorkerTask {
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private array of <kbd class="calibre15">int</kbd> values named <kbd class="calibre15">array</kbd>:</li>
</ol>
<pre class="calibre23">
        private int array[];
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement a constructor of the class that initializes its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(String name, int array[], int start, int end){ <br class="title-page-name"/>          super(name); <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. This method increments the block of elements of the array determined by the start and end attributes. If this block of elements has more than 100 elements, divide the block into two parts and create two <kbd class="calibre15">Task</kbd> objects to process each part. Send these tasks to the pool using the <kbd class="calibre15">invokeAll()</kbd> method:</li>
</ol>
<pre class="calibre23">
        protected void compute() { <br class="title-page-name"/>          if (end-start&gt;100){ <br class="title-page-name"/>            int mid=(end+start)/2; <br class="title-page-name"/>            Task task1=new Task(this.getName()+"1",array,start,mid); <br class="title-page-name"/>            Task task2=new Task(this.getName()+"2",array,mid,end); <br class="title-page-name"/>            invokeAll(task1,task2);
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">If the block of elements has less than 100 elements, increment all the elements using a <kbd class="calibre15">for</kbd> loop:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>        for (int i=start; i&lt;end; i++) { <br class="title-page-name"/>          array[i]++; <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Finally, put the thread that is executing the task to sleep for 50 milliseconds:</li>
</ol>
<pre class="calibre23">
            try { <br class="title-page-name"/>              Thread.sleep(50); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Next, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create an <kbd class="calibre15">int</kbd> array of 10,000 elements:</li>
</ol>
<pre class="calibre23">
        int array[]=new int[10000];
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object named <kbd class="calibre15">pool</kbd>:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object to increment all the elements of the array. The parameter of the constructor is given <kbd class="calibre15">Task</kbd> as the name of the task, the array object, and the values 0 and 10000 to indicate to this task that it has to process the entire array:</li>
</ol>
<pre class="calibre23">
        Task task=new Task("Task",array,0,array.length);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Send the task to the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.invoke(task);
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Shut down the <kbd class="calibre15">pool</kbd> using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown();
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Write a message in the console indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented the <kbd class="calibre15">MyWorkerTask</kbd> class that extends the <kbd class="calibre15">ForkJoinTask</kbd> class. It's your own base class to implement tasks that can be executed in a <kbd class="calibre15">ForkJoinPool</kbd> executor and that can take advantage of all the benefits of the executor, as it's a work-stealing algorithm. This class is equivalent to the <kbd class="calibre15">RecursiveAction</kbd> and <kbd class="calibre15">RecursiveTask</kbd> classes.</p>
<p class="calibre4">When you extend the <kbd class="calibre15">ForkJoinTask</kbd> class, you have to implement the following three methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">setRawResult()</kbd>: This method is used to establish the result of the task. As your tasks don't return any results, leave this method empty.</li>
<li class="calibre18"><kbd class="calibre15">getRawResult()</kbd>: This method is used to return the result of the task. As your tasks don't return any results, this method returns null.</li>
<li class="calibre18"><kbd class="calibre15">exec()</kbd>: This method implements the logic of the task. In this case, you delegated the logic to the abstract <kbd class="calibre15">compute()</kbd> method (as the <kbd class="calibre15">RecursiveAction</kbd> and <kbd class="calibre15">RecursiveTask</kbd> classes). However, in the <kbd class="calibre15">exec()</kbd> method, you measure the execution time of the method, writing it in the console.</li>
</ul>
<p class="calibre4">Finally, in the main class of the example, you created an array of 10,000 elements, a <kbd class="calibre15">ForkJoinPool</kbd> executor, and a <kbd class="calibre15">Task</kbd> object to process the whole array. Execute the program and you'll see how the different tasks that are executed write their execution time in the console.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in <a href="part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 5</span></a>, <em class="calibre14">Fork/Join Framework</em></li>
<li class="calibre18">The <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing a custom Lock class</h1>
            

            <article>
                
<p class="calibre4">Locks are one of the basic synchronization mechanisms provided by the Java Concurrency API. They allow programmers to protect a critical section of code so only one thread can execute that block of code at a time. It provides the following two operations:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">lock()</kbd>: You call this operation when you want to access a critical section. If there is another thread running this critical section, other threads are blocked until they're woken up by the lock to get access to the critical section.</li>
<li class="calibre18"><kbd class="calibre15">unlock()</kbd>: You call this operation at the end of a critical section to allow other threads to access it.</li>
</ul>
<p class="calibre4">In the Java Concurrency API, locks are declared in the <kbd class="calibre15">Lock</kbd> interface and implemented in some classes, for example, the <kbd class="calibre15">ReentrantLock</kbd> class.</p>
<p class="calibre4">In this recipe, you will learn how to implement your own <kbd class="calibre15">Lock</kbd> object by implementing a class that implements the <kbd class="calibre15">Lock</kbd> interface, which can be used to protect a critical section.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyAbstractQueuedSynchronizer</kbd> that extends the <kbd class="calibre15">AbstractQueuedSynchronizer</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyAbstractQueuedSynchronizer extends<br class="title-page-name"/>                                        AbstractQueuedSynchronizer {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">state</kbd>:</li>
</ol>
<pre class="calibre23">
        private final AtomicInteger state;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public MyAbstractQueuedSynchronizer() { <br class="title-page-name"/>          state=new AtomicInteger(0); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">tryAcquire()</kbd> method. This method tries to change the value of the state variable from zero to one. If it can, it returns the <kbd class="calibre15">true</kbd> value; else, it returns <kbd class="calibre15">false</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected boolean tryAcquire(int arg) { <br class="title-page-name"/>          return state.compareAndSet(0, 1); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">tryRelease()</kbd> method. This method tries to change the value of the state variable from one to zero. If it can, it returns <kbd class="calibre15">true</kbd>; else, it returns <kbd class="calibre15">false</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected boolean tryRelease(int arg) { <br class="title-page-name"/>          return state.compareAndSet(1, 0); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create a class named <kbd class="calibre15">MyLock</kbd> and specify that it implements the <kbd class="calibre15">Lock</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class MyLock implements Lock{
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare a private <kbd class="calibre15">AbstractQueuedSynchronizer</kbd> attribute named <kbd class="calibre15">sync</kbd>:</li>
</ol>
<pre class="calibre23">
        private final AbstractQueuedSynchronizer sync;
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the constructor of the class to initialize the <kbd class="calibre15">sync</kbd> attribute with a new <kbd class="calibre15">MyAbstractQueueSynchronizer</kbd> object:</li>
</ol>
<pre class="calibre23">
        public MyLock() { <br class="title-page-name"/>          sync=new MyAbstractQueuedSynchronizer(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">lock()</kbd> method. Call the <kbd class="calibre15">acquire()</kbd> method of the <kbd class="calibre15">sync</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void lock() { <br class="title-page-name"/>          sync.acquire(1); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">lockInterruptibly()</kbd> method. Call the <kbd class="calibre15">acquireInterruptibly()</kbd> method of the sync object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void lockInterruptibly() throws InterruptedException { <br class="title-page-name"/>          sync.acquireInterruptibly(1); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">tryLock()</kbd> method. Call the <kbd class="calibre15">tryAcquireNanos()</kbd> method of the <kbd class="calibre15">sync</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean tryLock() { <br class="title-page-name"/>          try { <br class="title-page-name"/>            return sync.tryAcquireNanos(1, 1000); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>            Thread.currentThread().interrupt(); <br class="title-page-name"/>            return false; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement another version of the <kbd class="calibre15">tryLock()</kbd> method with two parameters: a long parameter named time and a <kbd class="calibre15">TimeUnit</kbd> parameter named unit. Call the <kbd class="calibre15">tryAcquireNanos()</kbd> method of the sync object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean tryLock(long time, TimeUnit unit) throws<br class="title-page-name"/>                                         InterruptedException { <br class="title-page-name"/>          return sync.tryAcquireNanos(1, TimeUnit.NANOSECONDS<br class="title-page-name"/>                                             .convert(time, unit)); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">unlock()</kbd> method. Call the <kbd class="calibre15">release()</kbd> method of the <kbd class="calibre15">sync</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void unlock() { <br class="title-page-name"/>          sync.release(1); <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the <kbd class="calibre15">newCondition()</kbd> method. Create a new object of the internal class of the <kbd class="calibre15">sync</kbd> object, namely <kbd class="calibre15">ConditionObject</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Condition newCondition() { <br class="title-page-name"/>          return sync.new ConditionObject(); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Declare a private <kbd class="calibre15">MyLock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final MyLock lock;
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute called <kbd class="calibre15">name</kbd>:</li>
</ol>
<pre class="calibre23">
        private final String name;
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(String name, MyLock lock){ <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the class. Acquire the <kbd class="calibre15">lock</kbd>, put the thread to sleep for 2 seconds, and then release the lock object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          System.out.printf("Task: %s: Take the lock\n",name); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>            System.out.printf("Task: %s: Free the lock\n",name); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } finally { <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Create a <kbd class="calibre15">MyLock</kbd> object named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        MyLock lock=new MyLock();
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Create and execute 10 <kbd class="calibre15">Task</kbd> tasks:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>          Task task=new Task("Task-"+i,lock); <br class="title-page-name"/>          Thread thread=new Thread(task); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Try to get the lock using the <kbd class="calibre15">tryLock()</kbd> method. Wait for a second, and if you don't get the lock, write a message and try again:</li>
</ol>
<pre class="calibre23">
        boolean value; <br class="title-page-name"/>        do { <br class="title-page-name"/>          try { <br class="title-page-name"/>            value=lock.tryLock(1,TimeUnit.SECONDS); <br class="title-page-name"/>            if (!value) { <br class="title-page-name"/>              System.out.printf("Main: Trying to get the Lock\n"); <br class="title-page-name"/>            } <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>            value=false; <br class="title-page-name"/>          } <br class="title-page-name"/>        } while (!value);
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Write a message indicating that you got the lock and release it:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Got the lock\n"); <br class="title-page-name"/>        lock.unlock();
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Write a message indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The Java Concurrency API provides a class that can be used to implement synchronization mechanisms with features of locks or semaphores. It's called <kbd class="calibre15">AbstractQueuedSynchronizer</kbd>, and as the name suggests, it's an abstract class. It provides operations to control access to a critical section and manage a queue of threads that are blocked and are awaiting access to the section. The operations are based on two abstract methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">tryAcquire()</kbd>: This method is called to try and get access to a critical section. If the thread that calls it can access the critical section, the method returns the <kbd class="calibre15">true</kbd> value. Otherwise, it returns the <kbd class="calibre15">false</kbd> value.</li>
<li class="calibre18"><kbd class="calibre15">tryRelease()</kbd>: This method is called to try and release access to a critical section. If the thread that calls it can release access, the method returns the <kbd class="calibre15">true</kbd> value. Else, it returns the <kbd class="calibre15">false</kbd> value.</li>
</ul>
<p class="calibre4">In these methods, you have to implement the mechanism you use to control access to a critical section. In this case, you implemented the <kbd class="calibre15">MyAbstractQueuedSynchonizer</kbd> class that extends the <kbd class="calibre15">AbstractQueuedSyncrhonizer</kbd> class and implements the abstract methods using an <kbd class="calibre15">AtomicInteger</kbd> variable to control access to the critical section. This variable will store the value <kbd class="calibre15">0</kbd> if the lock is free, so a thread can have access to the critical section, and the value <kbd class="calibre15">1</kbd> if the lock is blocked, so a thread 'doesn't have access to the critical section.</p>
<p class="calibre4">You used the <kbd class="calibre15">compareAndSet()</kbd> method provided by the <kbd class="calibre15">AtomicInteger</kbd> class that tries to change the value you specify as the first parameter with the value you specify as the second parameter. To implement the <kbd class="calibre15">tryAcquire()</kbd> method, you try to change the value of the atomic variable from zero to one. Similarly, to implement the <kbd class="calibre15">tryRelease()</kbd> method, you try to change the value of the atomic variable from one to zero.</p>
<p class="calibre4">You have to implement <kbd class="calibre15">AtomicInteger</kbd> class because other implementations of the <kbd class="calibre15">AbstractQueuedSynchronizer</kbd> class (for example, the one used by <kbd class="calibre15">ReentrantLock</kbd>) are implemented as private classes internally. This is carried out in the class that uses it, so you don't have access to it.</p>
<p class="calibre4">Then, you implemented the <kbd class="calibre15">MyLock</kbd> class. This class implements the <kbd class="calibre15">Lock</kbd> interface and has a <kbd class="calibre15">MyQueuedSynchronizer</kbd> object as an attribute. To implement all the methods of the <kbd class="calibre15">Lock</kbd> interface, you used methods of the <kbd class="calibre15">MyQueuedSynchronizer</kbd> object.</p>
<p class="calibre4">Finally, you implemented the <kbd class="calibre15">Task</kbd> class that implements the <kbd class="calibre15">Runnable</kbd> interface and uses a <kbd class="calibre15">MyLock</kbd> object to get access to the critical section. This critical section puts the thread to sleep for 2 seconds. The <kbd class="calibre15">main</kbd> class creates a <kbd class="calibre15">MyLock</kbd> object and runs 10 <kbd class="calibre15">Task</kbd> objects that share the lock. The <kbd class="calibre15">main</kbd> class also tries to get access to the lock using the <kbd class="calibre15">tryLock()</kbd> method.</p>
<p class="calibre4">When you execute the example, you can see how only one thread has access to the critical section, and when that thread finishes, another one gets access to it.</p>
<p class="calibre4">You can use your own <kbd class="calibre15">Lock</kbd> interface to write log messages about its utilization, control the time that it's locked, or implement advanced synchronization mechanisms to control, for example, access to a resource so that it's only available at certain times.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">AbstractQueuedSynchronizer</kbd> class provides two methods that can be used to manage the state of the lock. They are the <kbd class="calibre15">getState()</kbd> and <kbd class="calibre15">setState()</kbd> methods. These methods receive and return an integer value with the state of the lock. You could have used them instead of the <kbd class="calibre15">AtomicInteger</kbd> attribute to store the state of the lock.</p>
<p class="calibre4">The Java Concurrency API provides another class to implement synchronization mechanisms. It's the <kbd class="calibre15">AbstractQueuedLongSynchronizer</kbd> class, which is equivalent to <kbd class="calibre15">AbstractQueuedSynchronizer</kbd> but uses a long attribute to store the state of the threads.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with locks</em> recipe in <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing a transfer queue-based on priorities</h1>
            

            <article>
                
<p class="calibre4">The Java 9 API provides several data structures to work with concurrent applications. From these, we want to highlight the following two data structures:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">LinkedTransferQueue</kbd>: This data structure is supposed to be used in programs that have a producer/consumer structure. In such applications, you have one or more producers of data and one or more consumers of data, and a data structure is shared by all of them. Producers put data in the data structure and consumers take it from there. If the data structure is empty, consumers are blocked until they have data to consume. If it is full, producers are blocked until they have space to put data.</li>
<li class="calibre18"><kbd class="calibre15">PriorityBlockingQueue</kbd>: In this data structure, elements are stored in an ordered way. They have to implement the <kbd class="calibre15">Comparable</kbd> interface with the <kbd class="calibre15">compareTo()</kbd> method. When you insert an element in the structure, it's compared to the elements of the structure until it finds its position.</li>
</ul>
<p class="calibre4">Elements of <kbd class="calibre15">LinkedTransferQueue</kbd> are stored in the same order as they arrive, so the ones that arrived earlier are consumed first. It may be the case when you want to develop a producer/consumer program, where data is consumed according to some priority instead of arrival time. In this recipe, you will learn how to implement a data structure to be used in the producer/consumer problem whose elements will be ordered by priority; elements with higher priority will be consumed first.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyPriorityTransferQueue</kbd> that extends the <kbd class="calibre15">PriorityBlockingQueue</kbd> class and implements the <kbd class="calibre15">TransferQueue</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class MyPriorityTransferQueue&lt;E&gt; extends<br class="title-page-name"/>                 PriorityBlockingQueue&lt;E&gt; implements TransferQueue&lt;E&gt; {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">counter</kbd> to store the number of consumers that are waiting to consume elements:</li>
</ol>
<pre class="calibre23">
        private final AtomicInteger counter;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">LinkedBlockingQueue</kbd> attribute named <kbd class="calibre15">transferred</kbd>:</li>
</ol>
<pre class="calibre23">
        private final LinkedBlockingQueue&lt;E&gt; transfered;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Declare a private <kbd class="calibre15">ReentrantLock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ReentrantLock lock;
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public MyPriorityTransferQueue() { <br class="title-page-name"/>          counter=new AtomicInteger(0); <br class="title-page-name"/>          lock=new ReentrantLock(); <br class="title-page-name"/>          transfered=new LinkedBlockingQueue&lt;E&gt;(); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">tryTransfer()</kbd> method. This method tries to send the element to a waiting consumer immediately, if possible. If there isn't any consumer waiting, the method returns <kbd class="calibre15">false</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean tryTransfer(E e) { <br class="title-page-name"/>          boolean value=false; <br class="title-page-name"/>          try { <br class="title-page-name"/>            lock.lock(); <br class="title-page-name"/>            if (counter.get() == 0) { <br class="title-page-name"/>              value = false; <br class="title-page-name"/>            } else { <br class="title-page-name"/>              put(e); <br class="title-page-name"/>              value = true; <br class="title-page-name"/>            } <br class="title-page-name"/>          } finally { <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>          return value;    <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">transfer()</kbd> method. This method tries to send the element to a waiting consumer immediately, if possible. If there is no consumer waiting, the method stores the element in a special queue to be sent to the first consumer that tries to get an element and blocks the thread until the element is consumed:</li>
</ol>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          public void transfer(E e) throws InterruptedException { <br class="title-page-name"/>            lock.lock(); <br class="title-page-name"/>            if (counter.get()!=0) { <br class="title-page-name"/>              try { <br class="title-page-name"/>                put(e); <br class="title-page-name"/>              } finally { <br class="title-page-name"/>                lock.unlock(); <br class="title-page-name"/>              } <br class="title-page-name"/>            } else { <br class="title-page-name"/>              try { <br class="title-page-name"/>                transfered.add(e); <br class="title-page-name"/>              } finally { <br class="title-page-name"/>                lock.unlock(); <br class="title-page-name"/>              } <br class="title-page-name"/>              synchronized (e) { <br class="title-page-name"/>              e.wait(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">tryTransfer()</kbd> method that receives three parameters: the element, the time to wait for a consumer if there is none, and the unit of time used to specify the wait. If there is a consumer waiting, it sends the element immediately. Otherwise, it converts the time specified into milliseconds and uses the <kbd class="calibre15">wait()</kbd> method to put the thread to sleep. When the consumer takes the element, if the thread is sleeping in the <kbd class="calibre15">wait()</kbd> method, you need to wake it up using the <kbd class="calibre15">notify()</kbd> method, as you'll see in a moment:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean tryTransfer(E e, long timeout, TimeUnit unit)<br class="title-page-name"/>                                       throws InterruptedException { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          if (counter.get() != 0) { <br class="title-page-name"/>            try { <br class="title-page-name"/>              put(e); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock.unlock(); <br class="title-page-name"/>            } <br class="title-page-name"/>            return true; <br class="title-page-name"/>          } else { <br class="title-page-name"/>            long newTimeout=0; <br class="title-page-name"/>            try { <br class="title-page-name"/>              transfered.add(e); <br class="title-page-name"/>              newTimeout = TimeUnit.MILLISECONDS.convert(timeout, unit); <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock.unlock(); <br class="title-page-name"/>            } <br class="title-page-name"/>            e.wait(newTimeout); <br class="title-page-name"/>            lock.lock(); <br class="title-page-name"/>            boolean value; <br class="title-page-name"/>            try { <br class="title-page-name"/>              if (transfered.contains(e)) { <br class="title-page-name"/>                transfered.remove(e); <br class="title-page-name"/>                value = false; <br class="title-page-name"/>              } else { <br class="title-page-name"/>                value = true; <br class="title-page-name"/>              } <br class="title-page-name"/>            } finally { <br class="title-page-name"/>              lock.unlock(); <br class="title-page-name"/>            } <br class="title-page-name"/>            return value; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">hasWaitingConsumer()</kbd> method. Use the value of the counter attribute to calculate the return value of this method. If the counter has a value that is bigger than zero, it returns <kbd class="calibre15">true</kbd>; else, it returns <kbd class="calibre15">false</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean hasWaitingConsumer() { <br class="title-page-name"/>          return (counter.get()!=0); <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">getWaitingConsumerCount()</kbd> method. Return the value of the <kbd class="calibre15">counter</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int getWaitingConsumerCount() { <br class="title-page-name"/>          return counter.get(); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">take()</kbd> method. This method is called by the consumers when they want to consume an element. First, get the lock defined earlier and increment the number of waiting consumers:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public E take() throws InterruptedException { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            counter.incrementAndGet();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">If there aren't any elements in the transferred queue, free the lock and try to get an element from the queue using the <kbd class="calibre15">take()</kbd> element and get the lock again. If there aren't any elements in the queue, this method will put the thread to sleep until there are elements to consume:</li>
</ol>
<pre class="calibre23">
        E value=transfered.poll(); <br class="title-page-name"/>        if (value==null) { <br class="title-page-name"/>          lock.unlock(); <br class="title-page-name"/>          value=super.take(); <br class="title-page-name"/>          lock.lock();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Otherwise, take the element from the transferred queue and wake up the thread that is waiting to consume that element, if there is one. Take into account that you are synchronizing an object coming to this class from the outside. You have to guarantee that the object wouldn't be used for locking in other parts of the application:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          synchronized (value) { <br class="title-page-name"/>            value.notify(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Finally, decrement the counter of waiting consumers and free the lock:</li>
</ol>
<pre class="calibre23">
            counter.decrementAndGet(); <br class="title-page-name"/>          } finally { <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } <br class="title-page-name"/>          return value; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Next, implement a class named <kbd class="calibre15">Event</kbd> that extends the <kbd class="calibre15">Comparable</kbd> interface parameterized by the <kbd class="calibre15">Event</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Event implements Comparable&lt;Event&gt; {
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">thread</kbd> to store the name of the thread that creates the event:</li>
</ol>
<pre class="calibre23">
        private final String thread;
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">priority</kbd> to store the priority of the event:</li>
</ol>
<pre class="calibre23">
        private final int priority;
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Event(String thread, int priority){ <br class="title-page-name"/>          this.thread=thread; <br class="title-page-name"/>          this.priority=priority; <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Implement a method to return the value of the <kbd class="calibre15">thread</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public String getThread() { <br class="title-page-name"/>          return thread; <br class="title-page-name"/>        }
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Implement a method to return the value of the <kbd class="calibre15">priority</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        public int getPriority() { <br class="title-page-name"/>          return priority; <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Implement the <kbd class="calibre15">compareTo()</kbd> method. This method compares the actual event with the event received as a parameter. Return <kbd class="calibre15">-1</kbd> if the actual event has a higher priority than the parameter, <kbd class="calibre15">1</kbd> if the actual event has a lower priority than the parameter, and <kbd class="calibre15">0</kbd> if both the events have the same priority. You will get the list ordered by priority in descending order. Events with a higher priority will be stored first in the queue:</li>
</ol>
<pre class="calibre23">
        public int compareTo(Event e) { <br class="title-page-name"/>          return Integer.compare(e.priority, this.getPriority()); <br class="title-page-name"/>        }
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Implement a class named <kbd class="calibre15">Producer</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Producer implements Runnable {
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Declare a private <kbd class="calibre15">MyPriorityTransferQueue</kbd> attribute parameterized by the <kbd class="calibre15">Event</kbd> class named <kbd class="calibre15">buffer</kbd> to store the events generated by this producer:</li>
</ol>
<pre class="calibre23">
        private final MyPriorityTransferQueue&lt;Event&gt; buffer;
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Producer(MyPriorityTransferQueue&lt;Event&gt; buffer) { <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>        }
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the class. Create 100 <kbd class="calibre15">Event</kbd> objects using its order of creation as priority (the latest event will have the highest priority) and insert them into the queue using the <kbd class="calibre15">put()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;100; i++) { <br class="title-page-name"/>            Event event=new Event(Thread.currentThread().getName(),i); <br class="title-page-name"/>            buffer.put(event); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Implement a class named <kbd class="calibre15">Consumer</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Runnable {
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Declare a private <kbd class="calibre15">MyPriorityTransferQueue</kbd> attribute parameterized by the <kbd class="calibre15">Event</kbd> class named <kbd class="calibre15">buffer</kbd> to get the events consumed by this class:</li>
</ol>
<pre class="calibre23">
        private final MyPriorityTransferQueue&lt;Event&gt; buffer;
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Consumer(MyPriorityTransferQueue&lt;Event&gt; buffer) { <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>        }
</pre>
<ol start="29" class="calibre19">
<li value="29" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It consumes 1,002 events (all the events generated in the example) using the <kbd class="calibre15">take()</kbd> method and writes the number of threads that generated the event and their priority in the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;1002; i++) { <br class="title-page-name"/>            try { <br class="title-page-name"/>              Event value=buffer.take(); <br class="title-page-name"/>              System.out.printf("Consumer: %s: %d\n",value.getThread(),<br class="title-page-name"/>                                value.getPriority()); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="30" class="calibre19">
<li value="30" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="31" class="calibre19">
<li value="31" class="calibre18">Create a <kbd class="calibre15">MyPriorityTransferQueue</kbd> object named <kbd class="calibre15">buffer</kbd>:</li>
</ol>
<pre class="calibre23">
        MyPriorityTransferQueue&lt;Event&gt; buffer=new<br class="title-page-name"/>                                MyPriorityTransferQueue&lt;Event&gt;();
</pre>
<ol start="32" class="calibre19">
<li value="32" class="calibre18">Create a <kbd class="calibre15">Producer</kbd> task and launch 10 threads to execute this task:</li>
</ol>
<pre class="calibre23">
        Producer producer=new Producer(buffer); <br class="title-page-name"/>        Thread producerThreads[]=new Thread[10]; <br class="title-page-name"/>        for (int i=0; i&lt;producerThreads.length; i++) { <br class="title-page-name"/>          producerThreads[i]=new Thread(producer); <br class="title-page-name"/>          producerThreads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="33" class="calibre19">
<li value="33" class="calibre18">Create and launch a <kbd class="calibre15">Consumer</kbd> task:</li>
</ol>
<pre class="calibre23">
        Consumer consumer=new Consumer(buffer); <br class="title-page-name"/>        Thread consumerThread=new Thread(consumer); <br class="title-page-name"/>        consumerThread.start();
</pre>
<ol start="34" class="calibre19">
<li value="34" class="calibre18">Write the actual consumer count in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Buffer: Consumer count: %d\n",<br class="title-page-name"/>                          buffer.getWaitingConsumerCount());
</pre>
<ol start="35" class="calibre19">
<li value="35" class="calibre18">Transfer an event to the consumer using the <kbd class="calibre15">transfer()</kbd> method:</li>
</ol>
<pre class="calibre23">
        Event myEvent=new Event("Core Event",0); <br class="title-page-name"/>        buffer.transfer(myEvent); <br class="title-page-name"/>        System.out.printf("Main: My Event has ben transfered.\n");
</pre>
<ol start="36" class="calibre19">
<li value="36" class="calibre18">Wait for the finalization of the producers using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;producerThreads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            producerThreads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="37" class="calibre19">
<li value="37" class="calibre18">Put the thread to sleep for 1 second:</li>
</ol>
<pre class="calibre23">
        TimeUnit.SECONDS.sleep(1);
</pre>
<ol start="38" class="calibre19">
<li value="38" class="calibre18">Write the actual consumer count:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Buffer: Consumer count: %d\n",<br class="title-page-name"/>                          buffer.getWaitingConsumerCount());
</pre>
<ol start="39" class="calibre19">
<li value="39" class="calibre18">Transfer another event using the <kbd class="calibre15">transfer()</kbd> method:</li>
</ol>
<pre class="calibre23">
        myEvent=new Event("Core Event 2",0); <br class="title-page-name"/>        buffer.transfer(myEvent);
</pre>
<ol start="40" class="calibre19">
<li value="40" class="calibre18">Wait for the finalization of the consumer using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        consumerThread.join();
</pre>
<ol start="41" class="calibre19">
<li value="41" class="calibre18">Write a message indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented the <kbd class="calibre15">MyPriorityTransferQueue</kbd> data structure. It's a data structure to be used in the producer/consumer problem, but its elements are ordered by priority, not by their order of arrival. As Java doesn't allow multiple inheritances, the first decision you took was in relation to the base class of the <kbd class="calibre15">MyPriorityTransferQueue</kbd> class. You extend the class to use the operations implemented in the <kbd class="calibre15">PriorityBlockingQueue,</kbd> not to implement them. You also implemented the <kbd class="calibre15">TransferQueue</kbd> interface to add the methods related to the producer/consumer. We made this choice because we think it is easier to implement the methods of the <kbd class="calibre15">TransferQueue</kbd> interface than the methods implemented in the <kbd class="calibre15">PriorityBlockingQueue</kbd> class. However, you can implement the class that extends from the <kbd class="calibre15">LinkedTransferQueue</kbd> class and implements the necessary methods to get your own version of the <kbd class="calibre15">PriorityBlockingQueue</kbd> class.</p>
<p class="calibre4">The <kbd class="calibre15">MyPriortyTransferQueue</kbd> class has the following three attributes:</p>
<ul class="calibre17">
<li class="calibre18">An <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">counter</kbd>: This attribute stores the number of consumers that are waiting to take an element from the data structure. When a consumer calls the <kbd class="calibre15">take()</kbd> operation to take an element from the data structure, the counter is incremented. When the consumer finishes the execution of the <kbd class="calibre15">take()</kbd> operation, the counter is decremented again. This counter is used in the implementation of the <kbd class="calibre15">hasWaitingConsumer()</kbd> and <kbd class="calibre15">getWaitingConsumerCount()</kbd> methods.</li>
<li class="calibre18">A <kbd class="calibre15">ReentrantLock</kbd> attribute named <kbd class="calibre15">lock</kbd>: This attribute is used to control access to implemented operations. Only one thread is allowed to work with the data structure, as per this attribute.</li>
<li class="calibre18">Finally, it has a <kbd class="calibre15">LinkedBlockingQueue</kbd> list to store transferred elements.</li>
</ul>
<p class="calibre4">You implemented some methods in <kbd class="calibre15">MyPriorityTransferQueue</kbd>. All the methods are declared in the <kbd class="calibre15">TransferQueue</kbd> interface, and the <kbd class="calibre15">take()</kbd> method is implemented in the <kbd class="calibre15">PriorityBlockingQueue</kbd> interface. Both of these were described earlier. Here is a description of the rest:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">tryTransfer(E e)</kbd>: This method tries to send an element directly to a consumer. If there is a consumer waiting, it stores the element in the priority queue to be consumed immediately by the consumer and then returns the <kbd class="calibre15">true</kbd> value. If no one's waiting, it returns the <kbd class="calibre15">false</kbd> value.</li>
<li class="calibre18"><kbd class="calibre15">transfer(E e)</kbd>: This method transfers an element directly to a consumer. If there is a consumer waiting, it stores the element in the priority queue to be consumed immediately by the consumer. Otherwise, the element is stored in the list of transferred elements, and the thread is blocked until the element is consumed. While the thread is put to sleep, you have to free the lock because, if you don't do this, you will block the queue.</li>
<li class="calibre18"><kbd class="calibre15">tryTransfer(E e, long timeout, TimeUnit unit)</kbd>: This method is similar to the <kbd class="calibre15">transfer()</kbd> method, but here, the thread blocks the period of time determined by its parameters. While the thread is put to sleep, you have to free the lock because, if you don't, you will block the queue.</li>
<li class="calibre18"><kbd class="calibre15">take()</kbd>: This method returns the next element to be consumed. If there are elements in the list of transferred elements, the element is taken from the list. Otherwise, it is taken from the priority queue.</li>
</ul>
<p class="calibre4">Once you implemented the data structure, you implemented the <kbd class="calibre15">Event</kbd> class. It is the class of the elements you have stored in the data structure. The <kbd class="calibre15">Event</kbd> class has two attributes to store the ID of the producer and the priority of the event, and it implements the <kbd class="calibre15">Comparable</kbd> interface because it is a requirement of your data structure.</p>
<p class="calibre4">Then, you implemented the <kbd class="calibre15">Producer</kbd> and <kbd class="calibre15">Consumer</kbd> classes. In the example, you had 10 producers and a consumer and they shared the same buffer. Each producer generated 100 events with incremental priority, so the events with a higher priority were the last generated ones.</p>
<p class="calibre4">The main class of the example created a <kbd class="calibre15">MyPriorityTransferQueue</kbd> object, 10 producers, and a consumer, and used the <kbd class="calibre15">transfer()</kbd> method of the <kbd class="calibre15">MyPriorityTransferQueue</kbd> buffer to transfer two events to the buffer.</p>
<p class="calibre4">The following screenshot shows part of the output of an execution of the program:</p>
<div class="cdpaligncenter"><img class="alignnone39" src="../images/00055.jpeg"/></div>
<p class="calibre4">You can see how events with a higher priority are consumed first and that a consumer consumes the transferred event.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using blocking thread-safe queue ordered by priority</em> and <em class="calibre14">Using blocking thread-safe deques</em> recipes in <a href="part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre14">Concurrent Collections</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing your own atomic object</h1>
            

            <article>
                
<p class="calibre4">Atomic variables were introduced in Java version 5; they provide atomic operations on single variables. When a thread does an operation with an atomic variable, the implementation of the class includes a mechanism to check that the operation is done atomically.</p>
<p class="calibre4">In this recipe, you will learn how to extend an atomic object and implement two operations that follow the mechanisms of the atomic objects to guarantee that all the operations are done in one step.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">ParkingCounter</kbd> and specify that it extends the <kbd class="calibre15">AtomicInteger</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ParkingCounter extends AtomicInteger {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">maxNumber</kbd> to store the maximum number of cars admitted into the parking lot:</li>
</ol>
<pre class="calibre23">
        private final int maxNumber;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public ParkingCounter(int maxNumber){ <br class="title-page-name"/>          set(0); <br class="title-page-name"/>          this.maxNumber=maxNumber; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">carIn()</kbd> method. This method increments the counter of cars if it has a value smaller than the established maximum value. Construct an infinite loop and get the value of the internal counter using the <kbd class="calibre15">get()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public boolean carIn() { <br class="title-page-name"/>          for (;;) { <br class="title-page-name"/>            int value=get();
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">If the value is equal to the <kbd class="calibre15">maxNumber</kbd> attribute, the counter can't be incremented (the parking lot is full and the car can't enter). In this case, the method returns the <kbd class="calibre15">false</kbd> value:</li>
</ol>
<pre class="calibre23">
        if (value==maxNumber) { <br class="title-page-name"/>          System.out.printf("ParkingCounter: The parking lot is full.\n"); <br class="title-page-name"/>          return false;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Otherwise, increment the value and use the <kbd class="calibre15">compareAndSet()</kbd> method to change the old value with the new one. This method returns the <kbd class="calibre15">false</kbd> value; the counter was not incremented, so you have to begin the loop again. If it returns <kbd class="calibre15">true</kbd>, it means the change was made and then you return the <kbd class="calibre15">true</kbd> value:</li>
</ol>
<pre class="calibre23">
            } else { <br class="title-page-name"/>              int newValue=value+1; <br class="title-page-name"/>              boolean changed=compareAndSet(value,newValue); <br class="title-page-name"/>              if (changed) { <br class="title-page-name"/>                System.out.printf("ParkingCounter: A car has entered.\n"); <br class="title-page-name"/>                return true; <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">carOut()</kbd> method. This method decrements the counter of cars if it has a value bigger than <kbd class="calibre15">0</kbd>. Construct an infinite loop and get the value of the internal counter using the <kbd class="calibre15">get()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public boolean carOut() { <br class="title-page-name"/>          for (;;) { <br class="title-page-name"/>            int value=get(); <br class="title-page-name"/>            if (value==0) { <br class="title-page-name"/>              System.out.printf("ParkingCounter: The parking lot is<br class="title-page-name"/>                                 empty.\n"); <br class="title-page-name"/>              return false; <br class="title-page-name"/>            } else { <br class="title-page-name"/>              int newValue=value-1; <br class="title-page-name"/>              boolean changed=compareAndSet(value,newValue); <br class="title-page-name"/>              if (changed) { <br class="title-page-name"/>                System.out.printf("ParkingCounter: A car has gone out.\n"); <br class="title-page-name"/>                return true; <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a class named <kbd class="calibre15">Sensor1</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Sensor1 implements Runnable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare a private <kbd class="calibre15">ParkingCounter</kbd> attribute named <kbd class="calibre15">counter</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ParkingCounter counter;
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Sensor1(ParkingCounter counter) { <br class="title-page-name"/>          this.counter=counter; <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Call the <kbd class="calibre15">carIn()</kbd> and <kbd class="calibre15">carOut()</kbd> operations several times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carOut(); <br class="title-page-name"/>          counter.carOut(); <br class="title-page-name"/>          counter.carOut(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a class named <kbd class="calibre15">Sensor2</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Sensor2 implements Runnable {
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Declare a private <kbd class="calibre15">ParkingCounter</kbd> attribute named <kbd class="calibre15">counter</kbd>:</li>
</ol>
<pre class="calibre23">
        private ParkingCounter counter;
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Sensor2(ParkingCounter counter) { <br class="title-page-name"/>          this.counter=counter; <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Call the <kbd class="calibre15">carIn()</kbd> and <kbd class="calibre15">carOut()</kbd> operations several times:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carOut(); <br class="title-page-name"/>          counter.carOut(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>          counter.carIn(); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a <kbd class="calibre15">ParkingCounter</kbd> object named <kbd class="calibre15">counter</kbd>:</li>
</ol>
<pre class="calibre23">
        ParkingCounter counter=new ParkingCounter(5);
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create and launch a <kbd class="calibre15">Sensor1</kbd> and <kbd class="calibre15">Sensor2</kbd> task:</li>
</ol>
<pre class="calibre23">
        Sensor1 sensor1=new Sensor1(counter); <br class="title-page-name"/>        Sensor2 sensor2=new Sensor2(counter); <br class="title-page-name"/> <br class="title-page-name"/>        Thread thread1=new Thread(sensor1); <br class="title-page-name"/>        Thread thread2=new Thread(sensor2); <br class="title-page-name"/> <br class="title-page-name"/>        thread1.start(); <br class="title-page-name"/>        thread2.start();
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Wait for the finalization of both the tasks:</li>
</ol>
<pre class="calibre23">
        thread1.join(); <br class="title-page-name"/>        thread2.join();
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Write the actual value of the counter in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Number of cars: %d\n",counter.get());
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Write a message indicating the end of the program in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: End of the program.\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ParkingCounter</kbd> class extends the <kbd class="calibre15">AtomicInteger</kbd> class with two atomic operations: <kbd class="calibre15">carIn()</kbd> and <kbd class="calibre15">carOut()</kbd>. The example simulates a system that controls the number of cars inside a parking lot. The parking lot can admit a number of cars, represented by the <kbd class="calibre15">maxNumber</kbd> attribute.</p>
<p class="calibre4">The <kbd class="calibre15">carIn()</kbd> operation compares the actual number of cars in the parking lot with the maximum value. If they are equal, the car can't enter the parking lot and the method returns the <kbd class="calibre15">false</kbd> value. Otherwise, it uses the following structure of the atomic operations:</p>
<ul class="calibre17">
<li class="calibre18">Get the value of the atomic object in a local variable.</li>
<li class="calibre18">Store the new value in a different variable.</li>
<li class="calibre18">Use the <kbd class="calibre15">compareAndSet()</kbd> method to try and replace the old value with the new one. If this method returns <kbd class="calibre15">true</kbd>, it means the old value you sent as a parameter was the value of the variable; therefore, it changes the values. The operation was made in an atomic way as the <kbd class="calibre15">carIn()</kbd> method returns <kbd class="calibre15">true</kbd>. If the <kbd class="calibre15">compareAndSet()</kbd> method returns <kbd class="calibre15">false</kbd>, it means the old value you sent as a parameter is not the value of the variable (the other thread modified it); therefore, the operation can't be done in an atomic way. The operation begins again until it can be done in an atomic way.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">carOut()</kbd> method is analogous to the <kbd class="calibre15">carIn()</kbd> method. You also implemented two <kbd class="calibre15">Runnable</kbd> objects that use the <kbd class="calibre15">carIn()</kbd> and <kbd class="calibre15">carOut()</kbd> methods to simulate the activity of parking. When you execute the program, you can see that the parking lot never exceeds the maximum value of cars.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using atomic variables</em> recipe in <a href="part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre14">Concurrent Collections</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing your own stream generator</h1>
            

            <article>
                
<p class="calibre4">A stream is a sequence of data that allows you to apply a sequence of operations (usually represented with lambda expressions) to it in a sequential or parallel way in order to filter, transform, sort, reduce, or construct a new data structure. It was introduced in Java 8 and was one of the most important features introduced in that version.</p>
<p class="calibre4">Streams are based on the <kbd class="calibre15">Stream</kbd> interface and some related classes and interfaces included in the <kbd class="calibre15">java.util.stream</kbd> package. They have also provoked the introduction of new methods in a lot of classes to generate streams from different data structures. You can create a <kbd class="calibre15">Stream</kbd> interface from every data structure that implements the <kbd class="calibre15">Collection</kbd> interface: from <kbd class="calibre15">File</kbd>, <kbd class="calibre15">Directory</kbd>, <kbd class="calibre15">Array</kbd>, and a lot of other sources.</p>
<p class="calibre4">Java also included different mechanisms to create streams from your own sources. The most important ones are:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">Supplier</kbd> interface: This interface defines the <kbd class="calibre15">get()</kbd> method. It will be called by <kbd class="calibre15">Stream</kbd> when it needs to process another object. You can create <kbd class="calibre15">Stream</kbd> from a <kbd class="calibre15">Supplier</kbd> interface using the <kbd class="calibre15">generate()</kbd> static method of the <kbd class="calibre15">Stream</kbd> class. Take into account that this source is potentially infinite, so you must use a method such as <kbd class="calibre15">limit()</kbd> or similar to limit the number of elements in <kbd class="calibre15">Stream</kbd>.</li>
<li class="calibre18">The <kbd class="calibre15">Stream.Builder</kbd> interface: This interface provides the <kbd class="calibre15">accept()</kbd> and <kbd class="calibre15">add()</kbd> elements to add elements to <kbd class="calibre15">Stream</kbd> and the <kbd class="calibre15">build()</kbd> method, which returns the <kbd class="calibre15">Stream</kbd> interface created with the elements added before.</li>
<li class="calibre18">The <kbd class="calibre15">Spliterator</kbd> interface: This interface defines the necessary methods to traverse and split the elements of a source. You can use the <kbd class="calibre15">stream()</kbd> method of the <kbd class="calibre15">StreamSupport</kbd> class to generate the <kbd class="calibre15">Stream</kbd> interface to process the elements of <kbd class="calibre15">Spliterator</kbd>.</li>
</ul>
<p class="calibre4">In this chapter, you will learn how to implement your own <kbd class="calibre15">Spliterator</kbd> interface and how to create a <kbd class="calibre15">Stream</kbd> interface to process its data. We will work with a matrix of elements. A normal <kbd class="calibre15">Stream</kbd> interface should process one element at a time, but we will use the <kbd class="calibre15">Spliterator</kbd> class to implement one row at a time.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Item</kbd> to store the information of each element of the matrix. It will have three private attributes: a <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">name</kbd> and two integer attributes named <kbd class="calibre15">row</kbd> and <kbd class="calibre15">column</kbd>. Create the methods to get and set the values of these attributes. The code of this class is very simple, so it won't be included here.</li>
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">MySpliterator</kbd>. Specify that it implements the <kbd class="calibre15">Spliterator</kbd> interface parameterized by the <kbd class="calibre15">Item</kbd> class. This class has four attributes: a matrix of <kbd class="calibre15">Item</kbd> objects named <kbd class="calibre15">items</kbd> and three integer attributes named <kbd class="calibre15">start</kbd>, <kbd class="calibre15">end</kbd>, and <kbd class="calibre15">current</kbd> to store the first and last elements that will be processed by this <kbd class="calibre15">Spliterator</kbd> interface and the current element that is being processed. Implement the constructor of the class to initialize all these attributes:</li>
</ol>
<pre class="calibre23">
        public class MySpliterator implements Spliterator&lt;Item&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          private Item[][] items; <br class="title-page-name"/>          private int start, end, current; <br class="title-page-name"/> <br class="title-page-name"/>          public MySpliterator(Item[][] items, int start, int end) { <br class="title-page-name"/>            this.items=items; <br class="title-page-name"/>            this.start=start; <br class="title-page-name"/>            this.end=end; <br class="title-page-name"/>            this.current=start; <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement <kbd class="calibre15">characteristics()</kbd>. This method will return an <kbd class="calibre15">int</kbd> value that describes the behavior of <kbd class="calibre15">Spliterator</kbd>. The meaning of this value will be explained later in the <em class="calibre14">How it Works...</em> section:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public int characteristics() { <br class="title-page-name"/>          return ORDERED | SIZED | SUBSIZED; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement <kbd class="calibre15">estimatedSize()</kbd>. This method will return the number of elements to be processed by this <kbd class="calibre15">Spliterator</kbd>. We will calculate it as the difference between the end and current attributes:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public long estimateSize() { <br class="title-page-name"/>          return end - current; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now implement <kbd class="calibre15">tryAdvance()</kbd>. This method will be called to try and process an element of the <kbd class="calibre15">Spliterator</kbd>. The input parameter of the <kbd class="calibre15">tryAdvance()</kbd> method is and object that implements the <kbd class="calibre15">Consumer</kbd> interface. It will be called by the Stream API, so we only have to worry about its implementation. In our case, as mentioned in the introduction to this chapter, we have a matrix of <kbd class="calibre15">Item</kbd> objects and we're going to process a row each time. The <kbd class="calibre15">Consumer</kbd> function received will process an <kbd class="calibre15">Item</kbd> object. Therefore, if the <kbd class="calibre15">Spliterator</kbd> interface still has elements to process, we will process all the items of the current row using the <kbd class="calibre15">accept()</kbd> method of the <kbd class="calibre15">Consumer</kbd> function:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean tryAdvance(Consumer&lt;? super Item&gt; consumer) { <br class="title-page-name"/>          System.out.printf("MySpliterator.tryAdvance.start: %d, %d, %d\n",<br class="title-page-name"/>                            start,end,current); <br class="title-page-name"/>            if (current &lt; end) { <br class="title-page-name"/>              for (int i=0; i&lt;items[current].length; i++) { <br class="title-page-name"/>                consumer.accept(items[current][i]); <br class="title-page-name"/>              } <br class="title-page-name"/>              current++; <br class="title-page-name"/>              System.out.printf("MySpliterator.tryAdvance.end:true\n"); <br class="title-page-name"/>              return true; <br class="title-page-name"/>            } <br class="title-page-name"/>            System.out.printf("MySpliterator.tryAdvance.end:false\n"); <br class="title-page-name"/>            return false; <br class="title-page-name"/>          }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now implement <kbd class="calibre15">forEachRemaining()</kbd>. This method will receive an implementation of the <kbd class="calibre15">Consumer</kbd> interface and will apply this function to the remaining elements of <kbd class="calibre15">Spliterator</kbd>. In our case, we will call the <kbd class="calibre15">tryAdvance()</kbd> method for all the remaining elements:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void forEachRemaining(Consumer&lt;? super Item&gt; consumer) { <br class="title-page-name"/>          System.out.printf("MySpliterator.forEachRemaining.start\n"); <br class="title-page-name"/>          boolean ret; <br class="title-page-name"/>          do { <br class="title-page-name"/>            ret=tryAdvance(consumer); <br class="title-page-name"/>          } while (ret); <br class="title-page-name"/>          System.out.printf("MySpliterator.forEachRemaining.end\n"); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, implement <kbd class="calibre15">trySplit()</kbd>. This method will be called by parallel streams to split <kbd class="calibre15">Spliterator</kbd> into two subsets. It will return a new <kbd class="calibre15">Spliterator</kbd> object with the elements that will be processed by another thread. The current thread will process the rest of the elements. If the <kbd class="calibre15">spliterator</kbd> object can't be split, you have to return a null value. In our case, we will calculate the element in the middle of the elements we have to process. The first half will be processed by the current thread, and the second half will be processed by another thread:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public Spliterator&lt;Item&gt; trySplit() { <br class="title-page-name"/>          System.out.printf("MySpliterator.trySplit.start\n"); <br class="title-page-name"/> <br class="title-page-name"/>          if (end-start&lt;=2) { <br class="title-page-name"/>            System.out.printf("MySpliterator.trySplit.end\n"); <br class="title-page-name"/>            return null; <br class="title-page-name"/>          } <br class="title-page-name"/>          int mid=start+((end-start)/2); <br class="title-page-name"/>          int newStart=mid; <br class="title-page-name"/>          int newEnd=end; <br class="title-page-name"/>          end=mid; <br class="title-page-name"/>          System.out.printf("MySpliterator.trySplit.end: %d, %d, %d,<br class="title-page-name"/>                            %d, %d, %d\n",start, mid, end, newStart,<br class="title-page-name"/>                            newEnd, current); <br class="title-page-name"/> <br class="title-page-name"/>          return new MySpliterator(items, newStart, newEnd); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Now implement the <kbd class="calibre15">Main</kbd> class of the project with the <kbd class="calibre15">main()</kbd> method. First, declare and initialize a matrix with 10 rows and 10 columns of <kbd class="calibre15">Item</kbd> objects:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            Item[][] items; <br class="title-page-name"/>            items= new Item[10][10]; <br class="title-page-name"/> <br class="title-page-name"/>            for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>              for (int j=0; j&lt;10; j++) { <br class="title-page-name"/>                items[i][j]=new Item(); <br class="title-page-name"/>                items[i][j].setRow(i); <br class="title-page-name"/>                items[i][j].setColumn(j); <br class="title-page-name"/>                items[i][j].setName("Item "+i+" "+j); <br class="title-page-name"/>              } <br class="title-page-name"/>            }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, create a <kbd class="calibre15">MySpliterator</kbd> object to process all the elements of the matrix:</li>
</ol>
<pre class="calibre23">
        MySpliterator mySpliterator=new MySpliterator(items, 0,<br class="title-page-name"/>                                                      items.length);
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Finally, use the <kbd class="calibre15">stream()</kbd> method of the <kbd class="calibre15">StreamSupport</kbd> class to create a stream from <kbd class="calibre15">Spliterator</kbd>. Pass the <kbd class="calibre15">true</kbd> value as the second parameter to indicate that our stream will be in parallel. Then, use the <kbd class="calibre15">forEach()</kbd> method of the <kbd class="calibre15">Stream</kbd> class to write information about each element:</li>
</ol>
<pre class="calibre23">
          StreamSupport.stream(mySpliterator, true).forEach( item -&gt; { <br class="title-page-name"/>            System.out.printf("%s: %s\n",Thread.currentThread()<br class="title-page-name"/>                              .getName(),item.getName()); <br class="title-page-name"/>          }); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The main element of this example is <kbd class="calibre15">Spliterator</kbd>. This interface defines methods that can be used to process and partition a source of elements to be used, for example, the source of a <kbd class="calibre15">Stream</kbd> object. You will rarely need to use a <kbd class="calibre15">Spliterator</kbd> object directly. Only if you want a different behavior--that is, if you want to implement your own data structure and create <kbd class="calibre15">Stream</kbd> from it--use a <kbd class="calibre15">Spliterator</kbd> object.</p>
<p class="calibre4"><kbd class="calibre15">Spliterator</kbd> has a set of characteristics that defines its behavior. They are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">CONCURRENT</kbd>: The data source can be safely modified concurrently</li>
<li class="calibre18"><kbd class="calibre15">DISTINCT</kbd>: All the elements of the data source are distinct</li>
<li class="calibre18"><kbd class="calibre15">IMMUTABLE</kbd>: Elements can be added, deleted, or replaced in the data source</li>
<li class="calibre18"><kbd class="calibre15">NONNULL</kbd>: There's no null element in the data source</li>
<li class="calibre18"><kbd class="calibre15">ORDERED</kbd>: There's an encounter ordered in the elements of the data source</li>
<li class="calibre18"><kbd class="calibre15">SIZED</kbd>: The value returned by the <kbd class="calibre15">estimateSize()</kbd> method is the exact size of the <kbd class="calibre15">Spliterator</kbd></li>
<li class="calibre18"><kbd class="calibre15">SORTED</kbd>: The elements of <kbd class="calibre15">Spliterator</kbd> are sorted</li>
<li class="calibre18"><kbd class="calibre15">SUBSIZED</kbd>: After you call the <kbd class="calibre15">trySplit()</kbd> method, you can obtain the exact size of both the parts of <kbd class="calibre15">Spliterator</kbd></li>
</ul>
<p class="calibre4">In our case, we defined <kbd class="calibre15">Spliterator</kbd> with the <kbd class="calibre15">DISTINCT</kbd>, <kbd class="calibre15">IMMUTABLE</kbd>, <kbd class="calibre15">NONNULL</kbd>, <kbd class="calibre15">ORDERED</kbd>, <kbd class="calibre15">SIZED</kbd>, and <kbd class="calibre15">SUBSIZED</kbd> characteristics.</p>
<p class="calibre4">Then, we implemented all the methods defined by the <kbd class="calibre15">Spliterator</kbd> interface that don't have a default implementation:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">characteristics()</kbd>: This method returns the characteristics of the <kbd class="calibre15">Spliterator</kbd> object. Specifically, it returns an integer value you calculate using the bitwise <kbd class="calibre15">or</kbd> operator (<kbd class="calibre15">|</kbd>) between the individual characteristics of your <kbd class="calibre15">Spliterator</kbd> object. Take into account that the value returned should be consistent with the real characteristics of your <kbd class="calibre15">Spliterator</kbd> object.</li>
<li class="calibre18"><kbd class="calibre15">estimatedSize()</kbd>: This method returns the number of elements that would be processed by the <kbd class="calibre15">forEachRemaining()</kbd> method if it were called at the current moment. In our case, we returned the exact value as we know it, but the definition of the method talks about the estimated size.</li>
<li class="calibre18"><kbd class="calibre15">tryAdvance()</kbd>: This method applies the function specified as a parameter to the next element to be processed, if there's one, and returns true. If there's no element to process, it will return false. In our case, this method received a <kbd class="calibre15">Consumer</kbd> that processed an Item object, but we processed a row of Item objects at a time. So we traversed all the items of the row and called the <kbd class="calibre15">accept()</kbd> method of <kbd class="calibre15">Consumer</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">trySplit()</kbd>: This method is used to divide the current <kbd class="calibre15">Spliterator</kbd> into two different parts so each one can be processed by different threads. In an ideal case, you should divide the data source into two halves with the same number of elements. But, in our case, we calculated the element in the middle between the start and end index and generated two blocks of elements. The start to the mid element part was processed by the current <kbd class="calibre15">Spliterator</kbd>, and the mid to the end element part was processed by the new <kbd class="calibre15">Spliterator</kbd> object. If you can't split the data source, this method returns a null value. In our case, the <kbd class="calibre15">Spliterator</kbd> had only two elements, so it won't be split.</li>
</ul>
<p class="calibre4">The other methods of the <kbd class="calibre15">Spliterator</kbd> interface have a default implementation, but we overrode the <kbd class="calibre15">forEachRemaining()</kbd> method. This method applies the function received as a parameter (an implementation of the <kbd class="calibre15">Consumer</kbd> interface) to the elements of the <kbd class="calibre15">Spliterator</kbd> that haven't been processed yet. We implemented our own version to write a message in the console. We used the <kbd class="calibre15">tryAdvance()</kbd> method to process each individual item.</p>
<p class="calibre4">The following screenshot shows part of the output of this example:</p>
<div class="cdpaligncenter"><img class="alignnone40" src="../images/00056.jpeg"/></div>
<p class="calibre4">First, the <kbd class="calibre15">trySplit()</kbd> method is called to divide the data source, then the <kbd class="calibre15">forEachRemaining()</kbd> method is called to process all the elements of each <kbd class="calibre15">Spliterator</kbd> generated by the <kbd class="calibre15">trySplit()</kbd> method.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can obtain an implementation of the <kbd class="calibre15">Spliterator</kbd> interface from different data sources. The <kbd class="calibre15">BaseStream</kbd> class provides the <kbd class="calibre15">spliterator()</kbd> method that returns a <kbd class="calibre15">Spliterator</kbd> from the elements of the <kbd class="calibre15">Stream</kbd>. Other data structures, such as <kbd class="calibre15">ConcurrentLinkedDeque</kbd>, <kbd class="calibre15">ConcurrentLinkedQueue</kbd>, or <kbd class="calibre15">Collection</kbd>, also provide the <kbd class="calibre15">spliterator()</kbd> method to get an implementation of that interface to process the elements of those data structures.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em> recipe in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 6</span></a>, <em class="calibre14">Parallel and Reactive Streams</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing your own asynchronous stream</h1>
            

            <article>
                
<p class="calibre4">Reactive streams (<a href="http://www.reactive-streams.org/" class="calibre9"><span>http://www.reactive-streams.org/</span></a>) defines a mechanism to provide asynchronous stream processing with non-blocking back pressure.</p>
<p class="calibre4">Reactive streams are based on three elements:</p>
<ul class="calibre17">
<li class="calibre18">It is a publisher of information</li>
<li class="calibre18">It has one or more subscribers of this information</li>
<li class="calibre18">It provides subscription between the publisher and a consumer</li>
</ul>
<p class="calibre4">Java 9 has included three interfaces--<kbd class="calibre15">Flow.Publisher</kbd>, <kbd class="calibre15">Flow.Subscriber</kbd>, and <kbd class="calibre15">Flow.Subscription</kbd>--and a utility class, <kbd class="calibre15">SubmissionPublisher</kbd>, to allow us to implement reactive stream applications.</p>
<p class="calibre4">In this recipe, you will learn how to implement your own reactive application using only three interfaces. Take into account that we will implement the expected behavior between the three elements. The publisher will only send elements to those subscribers who have requested them, and it will do this in a concurrent way. But you can modify this behavior easily by modifying the implementation of the methods.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or another IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Implement a class named <kbd class="calibre15">News</kbd>. This class implements the elements sent from the publisher to the subscriber. It will have two private <kbd class="calibre15">String</kbd> attributes, named <kbd class="calibre15">title</kbd> and <kbd class="calibre15">content</kbd>, and a <kbd class="calibre15">Date</kbd> attribute named <kbd class="calibre15">date</kbd>. It will also have the methods to get and set the values of these attributes. The source code of this class is very simple, so it won't be included here.</li>
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">Consumer</kbd> and specify that it implements the <kbd class="calibre15">Subscriber</kbd> interface parameterized by the <kbd class="calibre15">News</kbd> class. It will have two private attributes: a <kbd class="calibre15">Subscription</kbd> object named subscription and a <kbd class="calibre15">String</kbd> attribute called name. Implement the constructor of the class to initialize the name attribute:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Subscriber&lt;News&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          private Subscription subscription; <br class="title-page-name"/>          private String name; <br class="title-page-name"/> <br class="title-page-name"/>          public Consumer(String name) { <br class="title-page-name"/>            this.name=name; <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">onComplete()</kbd> method. This method should be called by the publisher when it doesn't send any additional elements. In our case, we only write a message in the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onComplete() { <br class="title-page-name"/>          System.out.printf("%s - %s: Consumer - Completed\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">onError()</kbd> method. This method should be called by the publisher when an error has occurred. In our case, we only write a message in the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onError(Throwable exception) { <br class="title-page-name"/>          System.out.printf("%s - %s: Consumer - Error: %s\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            exception.getMessage()); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, implement <kbd class="calibre15">onNext()</kbd>. This method receives a <kbd class="calibre15">News</kbd> object as a parameter, and it should be called by the publisher when he or she sends an item to the subscriber. In our case, we write the value of the attributes of the <kbd class="calibre15">News</kbd> object in the console, and we use the <kbd class="calibre15">request()</kbd> method of the <kbd class="calibre15">Subscription</kbd> object to request an additional item:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onNext(News item) { <br class="title-page-name"/>          System.out.printf("%s - %s: Consumer - News\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s - %s: Title: %s\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getTitle()); <br class="title-page-name"/>          System.out.printf("%s - %s: Content: %s\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getContent()); <br class="title-page-name"/>          System.out.printf("%s - %s: Date: %s\n", name,<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getDate()); <br class="title-page-name"/>          subscription.request(1); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Finally, implement <kbd class="calibre15">onSubscription()</kbd>. This method will be called by the publisher, and it will be the first method of <kbd class="calibre15">Subscriber</kbd> invoked by it. It receives the <kbd class="calibre15">Subscription</kbd> between the publisher and the subscriber. In our case, we store the <kbd class="calibre15">Subscription</kbd> object and request the first item to be processed by the subscriber using the <kbd class="calibre15">request()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onSubscribe(Subscription subscription) { <br class="title-page-name"/>          this.subscription = subscription; <br class="title-page-name"/>          subscription.request(1); <br class="title-page-name"/>          System.out.printf("%s: Consumer - Subscription\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement a class named <kbd class="calibre15">MySubscription</kbd> and specify that it implements the <kbd class="calibre15">Subscription</kbd> interface. It will have a private <kbd class="calibre15">Boolean</kbd> attribute named canceled and a private integer attribute named requested:</li>
</ol>
<pre class="calibre23">
        public class MySubscription implements Subscription { <br class="title-page-name"/> <br class="title-page-name"/>          private boolean canceled=false; <br class="title-page-name"/>          private long requested=0;
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the <kbd class="calibre15">cancel()</kbd> method provided by the <kbd class="calibre15">Subscription</kbd> interface to cancel the communication between the publisher and the subscriber. In our case, we set to <kbd class="calibre15">true</kbd> the canceled attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void cancel() { <br class="title-page-name"/>          canceled=true; <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">request()</kbd> method provided by the <kbd class="calibre15">Subscription</kbd> interface. This method is used by the subscriber to request elements from the publisher. It receives as parameter the number of elements requested by the subscriber. In our case, we increment the value of the requested attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void request(long value) { <br class="title-page-name"/>          requested+=value; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">isCanceled()</kbd> method to obtain the value of the canceled attribute, the <kbd class="calibre15">getRequested()</kbd> method to obtain the value of the requested attribute and the <kbd class="calibre15">decreaseRequested()</kbd> to decrease the value of the requested attribute:</li>
</ol>
<pre class="calibre23">
        public boolean isCanceled() { <br class="title-page-name"/>          return canceled; <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        public long getRequested() { <br class="title-page-name"/>          return requested; <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        public void decreaseRequested() { <br class="title-page-name"/>          requested--;      <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement a class named <kbd class="calibre15">ConsumerData</kbd>. This class will be used by the publisher to store the information of every subscriber. It will have a private <kbd class="calibre15">Consumer</kbd> attribute named consumer and a private <kbd class="calibre15">MySubscription</kbd> attribute named subscription. It will also have the methods to <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> the value of those attributes. The source code of this class is very simple, so it won't be included here.</li>
<li value="12" class="calibre18">Implement a class named <kbd class="calibre15">PublisherTask</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. It will have a private <kbd class="calibre15">ConsumerData</kbd> attribute named <kbd class="calibre15">consumerData</kbd> and a private <kbd class="calibre15">News</kbd> attribute named news. Implement a constructor to initialize both the attributes:</li>
</ol>
<pre class="calibre23">
        public class PublisherTask implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>        private ConsumerData consumerData; <br class="title-page-name"/>        private News news; <br class="title-page-name"/> <br class="title-page-name"/>        public PublisherTask(ConsumerData consumerData, News news) { <br class="title-page-name"/>          this.consumerData = consumerData; <br class="title-page-name"/>          this.news = news; <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. It will get the <kbd class="calibre15">MySubscription</kbd> object of the <kbd class="calibre15">ConsumerData</kbd> attribute. If the subscription is not canceled and it has requested elements (the value of the attribute is bigger than 0), we send the <kbd class="calibre15">News</kbd> object to the subscriber using its <kbd class="calibre15">onNext()</kbd> method and then decrement the value of the requested attribute:</li>
</ol>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/>            MySubscription subscription = consumerData.getSubscription(); <br class="title-page-name"/>            if (!(subscription.isCanceled() &amp;&amp; (subscription.getRequested()<br class="title-page-name"/>                                                               &gt; 0))) { <br class="title-page-name"/>              consumerData.getConsumer().onNext(news); <br class="title-page-name"/>              subscription.decreaseRequested(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Then, implement a class named <kbd class="calibre15">MyPublisher</kbd> and specify that it implements the <kbd class="calibre15">Publisher</kbd> interface parameterized by the <kbd class="calibre15">News</kbd> class. It will store a private <kbd class="calibre15">ConcurrentLinkedDeque</kbd> of <kbd class="calibre15">ConsumerData</kbd> objects and a <kbd class="calibre15">ThreadPoolExecutor</kbd> object named <kbd class="calibre15">executor</kbd>. Implement the constructor of the class to initialize both the attributes:</li>
</ol>
<pre class="calibre23">
        public class MyPublisher implements Publisher&lt;News&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          private ConcurrentLinkedDeque&lt;ConsumerData&gt; consumers; <br class="title-page-name"/>          private ThreadPoolExecutor executor; <br class="title-page-name"/> <br class="title-page-name"/>          public MyPublisher() { <br class="title-page-name"/>            consumers=new ConcurrentLinkedDeque&lt;&gt;(); <br class="title-page-name"/>            executor = (ThreadPoolExecutor)Executors.newFixedThreadPool<br class="title-page-name"/>                          (Runtime.getRuntime().availableProcessors()); <br class="title-page-name"/>          }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Now, implement <kbd class="calibre15">subscribe()</kbd>. This method will receive a <kbd class="calibre15">Subscriber</kbd> object that wants to receive the items of this publisher in the form of a parameter. We create <kbd class="calibre15">MySubscription</kbd> and <kbd class="calibre15">ConsumerData</kbd> objects, store <kbd class="calibre15">ConsumerData</kbd> in <kbd class="calibre15">ConcurrentLinkedDeque</kbd>, and call the <kbd class="calibre15">onSubscribe()</kbd> method of the subscriber to send the subscription object to the <kbd class="calibre15">Subscriber</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void subscribe(Subscriber&lt;? super News&gt; subscriber) { <br class="title-page-name"/> <br class="title-page-name"/>          ConsumerData consumerData=new ConsumerData(); <br class="title-page-name"/>          consumerData.setConsumer((Consumer)subscriber); <br class="title-page-name"/> <br class="title-page-name"/>          MySubscription subscription=new MySubscription(); <br class="title-page-name"/>          consumerData.setSubscription(subscription); <br class="title-page-name"/> <br class="title-page-name"/>          subscriber.onSubscribe(subscription); <br class="title-page-name"/> <br class="title-page-name"/>          consumers.add(consumerData); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Now implement the <kbd class="calibre15">publish()</kbd> method. This method receives a <kbd class="calibre15">News</kbd> parameter and sends it to the subscribers that meet the conditions explained before. To do this, we create a <kbd class="calibre15">PublisherTask</kbd> method per <kbd class="calibre15">Subscriber</kbd> and send these tasks to the executor:</li>
</ol>
<pre class="calibre23">
        public void publish(News news) { <br class="title-page-name"/>          consumers.forEach( consumerData -&gt; { <br class="title-page-name"/>            try { <br class="title-page-name"/>              executor.execute(new PublisherTask(consumerData, news)); <br class="title-page-name"/>            } catch (Exception e) { <br class="title-page-name"/>              consumerData.getConsumer().onError(e); <br class="title-page-name"/>            } <br class="title-page-name"/>          }); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Finally, implement the <kbd class="calibre15">Main</kbd> class of the example with its <kbd class="calibre15">main()</kbd> method. We create a publisher and two subscribers and subscribe them to the publisher:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/> <br class="title-page-name"/>            MyPublisher publisher=new MyPublisher(); <br class="title-page-name"/> <br class="title-page-name"/>            Subscriber&lt;News&gt; consumer1, consumer2; <br class="title-page-name"/>            consumer1=new Consumer("Consumer 1"); <br class="title-page-name"/>            consumer2=new Consumer("Consumer 2"); <br class="title-page-name"/> <br class="title-page-name"/>            publisher.subscribe(consumer1); <br class="title-page-name"/>            publisher.subscribe(consumer2);
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Then, create a <kbd class="calibre15">News</kbd> object, send it to the publisher, sleep the main thread for a second, create another <kbd class="calibre15">News</kbd> object, and send it to the publisher again:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Start\n"); <br class="title-page-name"/> <br class="title-page-name"/>          News news=new News(); <br class="title-page-name"/>          news.setTitle("My first news"); <br class="title-page-name"/>          news.setContent("This is the content"); <br class="title-page-name"/>          news.setDate(new Date()); <br class="title-page-name"/> <br class="title-page-name"/>          publisher.publish(news); <br class="title-page-name"/> <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/> <br class="title-page-name"/>          news=new News(); <br class="title-page-name"/>          news.setTitle("My second news"); <br class="title-page-name"/>          news.setContent("This is the content of the second news"); <br class="title-page-name"/>          news.setDate(new Date()); <br class="title-page-name"/>          publisher.publish(news); <br class="title-page-name"/> <br class="title-page-name"/>          System.out.printf("Main: End\n"); <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, we implemented a reactive streams communication between a publisher and a subscriber using the interfaces provided by the Java 9 API and just followed the expected behavior defined in the reactive streams' specification.</p>
<p class="calibre4">We had a publisher implemented by the <kbd class="calibre15">MyPublisher</kbd> class and subscribers implemented by the <kbd class="calibre15">Consumer</kbd> class. There are subscriptions between the publishers, and each subscriber is implemented by the <kbd class="calibre15">MySubscription</kbd> object.</p>
<p class="calibre4">The cycle of the communication starts when a subscriber calls the <kbd class="calibre15">subscribe()</kbd> method of a publisher. The publisher has to create the subscription between them and send that subscription to the subscriber using the <kbd class="calibre15">onSubscribe()</kbd> method. The subscriber must use the <kbd class="calibre15">request()</kbd> method of the subscription to indicate that it's ready to process more elements from the publisher. When the publisher publishes an item, it will send it to all its subscribers who have requested elements from the publisher using the subscription between them.</p>
<p class="calibre4">We added all the necessary elements to guarantee this behavior in a concurrent way.</p>
<p class="calibre4">The following screenshot shows the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="alignnone41" src="../images/00057.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The easiest way to create an application that uses reactive streams is to use the <kbd class="calibre15">SubsmissionPublisher</kbd> class. This class implements the <kbd class="calibre15">Publisher</kbd> interface and provides the necessary methods to use it as the publisher part of the application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Reactive programming with reactive streams</em> recipe in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 6</span></a>, <em class="calibre14">Parallel and Reactive Streams</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>