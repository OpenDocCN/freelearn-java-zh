- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing Strategies for Robust APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于健壮API的测试策略
- en: While researching and drafting this chapter, we had a completely different vision
    in mind. The original plan was to write a traditional piece on testing APIs, a
    structured, methodical exploration of established practices. The focus was going
    to be on the tools and techniques that have been staples of **API testing** for
    years, such as Postman, Bruno, and various mocking frameworks. These tools have
    been essential in helping engineers ensure API reliability and are still widely
    used, particularly in projects with legacy systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究和撰写本章时，我们心中有一个完全不同的愿景。最初的计划是写一篇关于测试API的传统文章，这是一篇结构化、系统性的对既定实践的探索。重点是那些多年来一直是**API测试**支柱的工具和技术，如Postman、Bruno和各种模拟框架。这些工具在帮助工程师确保API可靠性方面至关重要，并且仍然被广泛使用，尤其是在具有遗留系统的项目中。
- en: However, the more we thought about the topic, it became clear that the landscape
    of software testing has undergone a significant shift. The rise of **generative
    AI** and **large language models** ( **LLMs** )—such as ChatGPT, Gemini, and similar
    tools—has fundamentally transformed how we approach software development, including
    testing. What was once a slow and often repetitive process has now evolved into
    a dynamic, AI-enhanced workflow. Generative AI doesn’t just make writing tests
    faster; it makes the entire process more engaging, efficient, and effective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着我们对这个话题的思考越来越多，我们越来越清楚地意识到，软件测试的格局已经发生了显著的变化。**生成式AI**和**大型语言模型**（**LLMs**）——如ChatGPT、Gemini和类似工具——的出现，从根本上改变了我们对待软件开发（包括测试）的方式。曾经是缓慢且经常重复的过程，现在已经演变成一个动态的、AI增强的工作流程。生成式AI不仅使编写测试更快，而且使整个过程更加引人入胜、高效和有效。
- en: This transformation isn’t just about convenience. The integration of generative
    AI into API testing has far-reaching benefits for everyone involved in the software
    development lifecycle. Engineers can now focus on higher-level problem solving
    rather than being bogged down by tedious test creation. Product managers and owners
    gain greater confidence in the quality of their APIs, knowing that testing has
    become more thorough and adaptive. The results are more meaningful, ensuring that
    APIs meet real-world needs while maintaining the highest quality standards.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变不仅仅关乎便利性。将生成式AI集成到API测试中，对软件开发生命周期中所有相关人员都有深远的好处。工程师现在可以专注于更高层次的解决问题，而不是被繁琐的测试创建所困扰。产品经理和所有者对API的质量更有信心，因为他们知道测试已经变得更加全面和适应性。结果是更有意义的，确保API满足现实世界的需求，同时保持最高的质量标准。
- en: This chapter, therefore, is not the one originally set out to be written. We
    have shifted focus entirely to reflect this new reality. Here, we’ll explore how
    generative AI can revolutionize the way we write tests for APIs, providing insights
    and techniques to help you leverage this game-changing technology. By embracing
    these advancements, we can create better APIs, foster collaboration, and deliver
    software that exceeds expectations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章并非最初计划要写的。我们已经完全转变了焦点，以反映这一新现实。在这里，我们将探讨生成式AI如何彻底改变我们编写API测试的方式，提供见解和技术，帮助您利用这一颠覆性技术。通过拥抱这些进步，我们可以创建更好的API，促进协作，并交付超出预期的软件。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类型
- en: Test format and tooling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试格式和工具
- en: Prompt engineering for testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的提示工程
- en: Preparing a development environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: Running and evolving the code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和演进代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: One of the advantages of focusing on these new ideas for integration and regression
    tests is in tools and installations. If you can run a JavaJUnit test on your local
    machine, you already have everything needed to run a test.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于这些新的集成和回归测试想法的优势之一在于工具和安装。如果你能在本地机器上运行JavaJUnit测试，你已经拥有了运行测试所需的一切。
- en: We will also utilize Docker to deploy our applications and dependencies locally.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用Docker在本地部署我们的应用程序和依赖项。
- en: You will also need access to an LLM. Any of the freely available LLMs should
    work well (ChatGPT, Gemini, Claude, …).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要访问一个LLM。任何免费可用的LLM都应该工作得很好（ChatGPT、Gemini、Claude等）。
- en: Types of tests
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'With a few minutes of online search, one can identify 19 different types of
    tests commonly referenced in the industry, and I’m sure there are a few more:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几分钟的在线搜索，人们可以识别出行业内经常引用的19种不同类型的测试，我相信还有更多：
- en: '**Functional testing** : Validates that the API functions as expected by checking
    its behavior against specified requirements'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：通过检查其行为是否符合特定要求来验证API按预期工作'
- en: '**Integration testing** : Ensures the API interacts correctly with other software
    components, systems, or APIs'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：确保API与其他软件组件、系统或API正确交互'
- en: '**Unit testing** : Tests individual units or components of the API in isolation'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在隔离状态下测试API的各个单元或组件'
- en: '**Performance testing** : Evaluates the API’s responsiveness, scalability,
    and stability under different conditions'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：评估API在不同条件下的响应性、可扩展性和稳定性'
- en: '**Load testing** : Checks how the API handles expected user traffic'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：检查API如何处理预期的用户流量'
- en: '**Stress testing** : Pushes the API beyond its limits to find breaking points'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：将API推向极限以找到破坏点'
- en: '**Spike testing** : Assesses the API’s reaction to sudden traffic spikes'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**峰值测试**：评估API对突然流量激增的反应'
- en: '**Soak testing** : Monitors the API’s performance over an extended period under
    sustained load'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** soak测试**：在持续负载下监控API的长时间性能'
- en: '**Security testing** : Ensures the API is secure from vulnerabilities and unauthorized
    access'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**：确保API免受漏洞和未经授权的访问'
- en: '**Validation testing** : Verifies the API meets the expected system and business
    requirements as a whole'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证测试**：验证API作为一个整体满足预期的系统和企业需求'
- en: '**Usability testing** : Ensures the API is easy to understand and use by developers'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：确保API易于开发者理解和使用'
- en: '**Regression testing** : Ensures new changes or updates to the API do not break
    existing functionality'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：确保API的新更改或更新不会破坏现有功能'
- en: '**Compliance testing** : Verifies the API meets specific legal, regulatory,
    or industry standards'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性测试**：验证API符合特定的法律、法规或行业标准'
- en: '**Exploratory testing** : Performs unscripted interactions with the API to
    uncover unexpected issues'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索性测试**：通过与非脚本化的API交互来发现意外问题'
- en: '**Interoperability testing** : Verifies the API works correctly with different
    platforms, languages, and environments'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性测试**：验证API与不同平台、语言和环境正确工作'
- en: '**Fuzz testing** : Identifies vulnerabilities by sending random, malformed,
    or unexpected data to the API'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊测试**：通过向API发送随机、格式错误或意外的数据来识别漏洞'
- en: '**End-to-end testing** : Validates entire workflows or user scenarios involving
    the API'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：验证涉及API的整个工作流程或用户场景'
- en: '**Data testing** : Ensures the integrity and correctness of the data processed
    or stored by the API'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据测试**：确保API处理或存储的数据的完整性和正确性'
- en: '**Mock and sandbox testing** : Tests API functionality in isolation or simulates
    environments without impacting live systems'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟和沙箱测试**：在隔离状态下测试API功能或模拟不影响实时系统的环境'
- en: 'Clearly, a comprehensive discussion on all these types of testing would require
    an entire book or more. Therefore, in this chapter, we will focus on a few specific
    types of testing: functional, regression, and validation tests.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对所有这些测试类型的全面讨论需要一本书或更多。因此，在本章中，我们将重点关注几种特定的测试类型：功能测试、回归测试和验证测试。
- en: Why these specific types of tests? Well, as stated earlier, the main goal is
    to help software engineers create better APIs. Among the various types of tests,
    functional, regression, and validation provide the most value in achieving this
    goal. Their primary benefit is the confidence they instill when making changes.
    One of the biggest challenges software engineers face is the unpredictable consequences
    of modifying code. Changes needed to address one problem might inadvertently break
    something else. This problem is both common and paralyzing. How can we ensure
    that our changes won’t disrupt existing functionality? By prioritizing functional
    and regression testing, we can tackle this concern head-on, ensuring the API continues
    to meet its requirements while safeguarding against unintended consequences introduced
    by new changes. This is the essence of the **test-driven development** ( **TDD**
    ) methodology that started in the early 2000s.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择这些特定的测试类型？正如之前所述，主要目标是帮助软件工程师创建更好的API。在各种类型的测试中，功能测试、回归测试和验证测试在实现这一目标方面提供了最大的价值。它们的主要好处是它们在做出更改时提供的信心。软件工程师面临的最大挑战之一是修改代码可能带来的不可预测的后果。为了解决一个问题而需要的更改可能会无意中破坏其他东西。这个问题既普遍又令人瘫痪。我们如何确保我们的更改不会破坏现有的功能？通过优先考虑功能测试和回归测试，我们可以直接应对这一担忧，确保API继续满足其要求，同时保护不受新更改引入的不预期的后果。这正是始于2000年代初的**测试驱动开发**（**TDD**）方法的核心。
- en: However, creating and maintaining comprehensive test sets is a resource-intensive
    process, both in terms of time and cost. Writing effective tests requires a deep
    understanding of the system, careful planning, and meticulous implementation.
    Once written, these tests must be regularly updated and adapted to reflect changes
    in the system, which adds to the ongoing maintenance effort. This level of investment
    can be difficult for organizations to justify, especially in fast-paced environments
    where tight deadlines and budget constraints are common. As a result, many projects
    have historically deprioritized testing, often preventing development teams from
    dedicating the time and resources needed to build robust test suites. This short-sighted
    approach may save effort in the short term but often leads to higher costs later
    when defects surface, affecting system reliability and customer satisfaction.
    Also, let’s be honest—writing tests can be boring, and it’s a sentiment shared
    by many in the industry.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建和维护全面的测试集是一个资源密集型的过程，无论是从时间还是成本上讲。编写有效的测试需要深入理解系统、周密的规划和细致的实施。一旦编写完成，这些测试必须定期更新和调整，以反映系统中的变化，这增加了持续维护的工作量。这种程度的投资可能对组织来说很难证明其合理性，尤其是在快节奏的环境中，那里通常有严格的截止日期和预算限制。因此，许多项目历史上都降低了测试的优先级，这往往阻碍了开发团队投入所需的时间和资源来构建健壮的测试套件。这种短视的方法可能在短期内节省了精力，但往往会导致后期出现缺陷时成本更高，影响系统的可靠性和客户满意度。坦白说——编写测试可能很无聊，这在业界是许多人的共同感受。
- en: Then, in November of 2022, the introduction of generative AI completely transformed
    the creation of software tests. Generative AI has become an incredible asset in
    writing tests. While there’s an ongoing debate about its impact on developing
    actual business logic—a discussion for another time—for testing purposes, it’s
    a phenomenal tool. We will leverage generative AI extensively to write our tests
    and assist in their development. This innovation not only enhances the value of
    functional and regression testing for software engineers but also makes these
    tests much easier and cheaper to write.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在2022年11月，生成式AI的引入彻底改变了软件测试的创建。生成式AI在编写测试方面已成为一个难以置信的宝贵资产。虽然关于其对开发实际业务逻辑的影响的争论仍在进行中——这是一个留待以后讨论的话题——但对于测试目的而言，它是一个非凡的工具。我们将广泛利用生成式AI来编写我们的测试并协助其开发。这一创新不仅增强了功能测试和回归测试对软件工程师的价值，而且使这些测试的编写变得更加容易和便宜。
- en: Test format and tooling
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试格式和工具
- en: When it comes to testing APIs, we have access to a variety of tools and formats,
    each serving different needs and levels of expertise. Tools such as Postman and
    Bruno provide user-friendly interfaces for building, managing, and running API
    tests. These tools are especially useful for quick exploratory testing or for
    creating manual test workflows. They excel in environments where visual representation
    and non-technical collaboration are essential. However, when we shift our focus
    to automated, scalable, and pipeline-ready testing, tools such as JUnit, which
    are integrated directly into the development ecosystem, offer significant advantages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试 API 时，我们有各种工具和格式可供选择，每个都满足不同的需求和专业知识水平。例如，Postman 和 Bruno 等工具提供了用户友好的界面，用于构建、管理和运行
    API 测试。这些工具特别适用于需要视觉表示和非技术协作的环境。然而，当我们关注于自动化、可扩展和管道就绪的测试时，JUnit 等直接集成到开发生态系统的工具提供了显著的优势。
- en: Tools such as Postman allow users to design API tests with minimal coding, making
    them accessible to a broader audience. These tools often include features such
    as sharing test collections, generating test documentation, and providing real-time
    visual results. Despite these strengths, they fall short when integrated into
    sophisticated CI/CD pipelines. Exporting and running tests from Postman or Bruno
    often require additional tooling or manual steps, and they lack the seamless compatibility
    with source control systems such as Git that code-based testing frameworks offer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Postman 等工具允许用户以最少的编码设计 API 测试，使它们对更广泛的受众可访问。这些工具通常包括共享测试集合、生成测试文档和提供实时可视化结果等功能。尽管这些功能强大，但它们在集成到复杂的
    CI/CD 管道时存在不足。从 Postman 或 Bruno 导出和运行测试通常需要额外的工具或手动步骤，并且它们缺乏与代码测试框架提供的源代码控制系统（如
    Git）的无缝兼容性。
- en: 'In contrast, JUnit, a widely used testing framework for Java, provides a code-first
    approach to testing APIs. By writing API tests directly in Java using JUnit, developers
    can ensure their tests are treated as part of the source code. This approach brings
    several advantages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，JUnit 是一个广泛使用的 Java 测试框架，它采用代码优先的方法来测试 API。通过使用 JUnit 直接在 Java 中编写 API
    测试，开发者可以确保他们的测试被视为源代码的一部分。这种方法带来了几个优点：
- en: '**Integration into deployment pipelines** : JUnit tests are inherently compatible
    with CI/CD tools such as Jenkins, GitHub Actions, and GitLab CI. This allows API
    tests to run automatically during builds or deployments, ensuring that no changes
    go live without thorough testing.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成到部署管道中**：JUnit 测试与 CI/CD 工具（如 Jenkins、GitHub Actions 和 GitLab CI）具有内在的兼容性。这使得
    API 测试可以在构建或部署期间自动运行，确保没有经过彻底测试的更改被发布。'
- en: '**Leverage of source code infrastructure** : Because JUnit tests are written
    in pure code, they benefit from the same tools and workflows used for the application
    code itself—version control, peer reviews, static analysis, and more. This consistency
    reduces complexity and ensures tests are always in sync with the application.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用源代码基础设施**：由于 JUnit 测试是用纯代码编写的，因此它们受益于与应用程序代码本身相同的工具和工作流程——版本控制、同行评审、静态分析等等。这种一致性降低了复杂性，并确保测试始终与应用程序保持同步。'
- en: '**Scalability and maintainability** : Code-based tests are easier to maintain
    as they evolve alongside the application. Refactoring tools, IDE features, and
    linters help developers quickly adapt tests when APIs change, minimizing the risk
    of outdated or broken tests.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和可维护性**：基于代码的测试更容易维护，因为它们随着应用程序的演变而演变。重构工具、IDE 功能和代码检查器帮助开发者快速适应 API
    的变化，最大限度地减少过时或损坏测试的风险。'
- en: '**Reusability and customization** : JUnit enables developers to write reusable
    test helpers and utilities, providing greater flexibility for complex testing
    scenarios. It also supports advanced features such as parameterized tests, mock
    environments, and dependency injections.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性和定制性**：JUnit 允许开发者编写可重用的测试辅助工具和实用程序，为复杂测试场景提供更大的灵活性。它还支持诸如参数化测试、模拟环境和依赖注入等高级功能。'
- en: Additionally, JUnit’s ability to directly call real APIs—whether deployed locally
    or in a test environment—ensures that tests mimic real-world usage. This helps
    catch issues such as incorrect request formatting, unexpected responses, or performance
    bottlenecks, which can be missed in abstracted environments such as Postman or
    Bruno.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JUnit 能够直接调用真实 API——无论是本地部署还是在测试环境中——确保测试模仿真实世界的使用。这有助于捕捉到在抽象环境（如 Postman
    或 Bruno）中可能被忽略的问题，例如不正确的请求格式、意外的响应或性能瓶颈。
- en: While Postman and Bruno are excellent for quick, one-off testing or for collaborating
    with non-developers, JUnit (and similar code-first tools) is the superior option
    for teams aiming to achieve robust, automated, and pipeline-integrated testing.
    By treating API tests as first-class citizens within the code base, developers
    can maximize efficiency, scalability, and confidence in their APIs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Postman 和 Bruno 适用于快速的单次测试或与非开发者协作，但对于旨在实现稳健、自动化和管道集成测试的团队来说，JUnit（以及类似的代码优先工具）是更优的选择。通过将
    API 测试视为代码库中的第一类公民，开发者可以最大化效率、可扩展性和对 API 的信心。
- en: Leveraging the strengths of automated testing is essential, yet AI is beginning
    to redefine testing entirely and a new approach to testing has appeared.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用自动化测试的优势至关重要，然而人工智能正在开始完全重新定义测试，并出现了一种新的测试方法。
- en: The evolution of software development practices has always revolved around improving
    efficiency, quality, and collaboration. One such recent advancement is the integration
    of generative AI into Agile software development, particularly within the SCRUM
    framework (see [https://www.scrum.org/resources/what-scrum-module](https://www.scrum.org/resources/what-scrum-module)
    ). Some teams are already experimenting with a new practice where prompts for
    AI-driven testing become an integral part of the development process, transforming
    how teams define, implement, and validate new features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发实践的演变始终围绕着提高效率、质量和协作。最近的一项进步是将生成式人工智能集成到敏捷软件开发中，特别是在 SCRUM 框架内（见 [https://www.scrum.org/resources/what-scrum-module](https://www.scrum.org/resources/what-scrum-module)）。一些团队已经在尝试一种新的实践，即
    AI 驱动测试的提示成为开发过程的一个组成部分，从而改变团队定义、实施和验证新功能的方式。
- en: In this updated workflow, the Technical Lead, in collaboration with the Product
    Owner, plays a pivotal role in shaping the development and testing lifecycle.
    When a new story is defined, a feature or enhancement to an API is introduced,
    and the Technical Lead crafts detailed prompts designed for generative AI tools.
    These prompts serve as the blueprint for testing the story’s acceptance criteria.
    By leveraging the domain expertise of both the Technical Lead and the Product
    Owner, the prompts encapsulate not only the technical requirements but also the
    business context and expected outcomes of the feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的工作流程中，技术负责人与产品负责人合作，在塑造开发和测试生命周期中扮演关键角色。当定义一个新的故事，引入 API 的功能或增强时，技术负责人会为生成式人工智能工具制定详细的提示。这些提示作为测试故事验收标准的蓝图。通过利用技术负责人和产品负责人的领域专业知识，这些提示不仅封装了技术要求，还包括了业务背景和功能的预期结果。
- en: '![Figure 8.1 – Incorporating AI-driven prompts into Agile SCRUM workflows](img/B21843_08_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 将人工智能驱动的提示集成到敏捷 SCRUM 工作流程中](img/B21843_08_1.jpg)'
- en: Figure 8.1 – Incorporating AI-driven prompts into Agile SCRUM workflows
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 将人工智能驱动的提示集成到敏捷 SCRUM 工作流程中
- en: For example, if a new API endpoint is being added to return a customer’s transaction
    history, the prompt might specify the exact input parameters, the expected structure
    of the JSON response, and edge cases to test, such as handling invalid input or
    empty datasets. These prompts are more than just instructions—they’re a shared
    artifact that bridges technical and business perspectives, ensuring alignment
    and clarity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果正在添加一个新的 API 端点以返回客户的交易历史，提示可能指定确切的输入参数、预期的 JSON 响应结构以及测试边缘情况，例如处理无效输入或空数据集。这些提示不仅仅是指令——它们是连接技术和业务视角的共享工件，确保了对齐和清晰。
- en: 'This integration of generative AI into Agile workflows offers several significant
    advantages:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成式人工智能集成到敏捷工作流程中提供了几个显著的优势：
- en: '**Consistency** : Standardized prompts ensure a consistent approach to testing
    across stories, reducing variability and improving reliability'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：标准化的提示确保了在故事之间测试方法的一致性，减少了可变性并提高了可靠性'
- en: '**Efficiency** : By automating the generation of test cases, developers can
    focus on coding the feature itself, reducing repetitive tasks and freeing up time
    for innovation'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：通过自动化测试用例的生成，开发者可以专注于编写功能本身的代码，减少重复性任务，并为创新腾出时间'
- en: '**Collaboration** : The joint creation of prompts by Technical Leads and Product
    Owners fosters better communication and alignment between technical and business
    teams'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：技术负责人和产品负责人共同创建提示，促进了技术团队和业务团队之间更好的沟通和对齐'
- en: '**Quality assurance** : Prompts encourage the team to think critically about
    edge cases, error handling, and expected outcomes from the start, reducing bugs
    and rework down the line'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量保证**：提示鼓励团队从一开始就批判性地思考边缘情况、错误处理和预期结果，从而减少后续的缺陷和返工。'
- en: Storing prompts in the code base
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将提示存储在代码库中
- en: 'To solidify the importance of these prompts, they are stored in the project’s
    Git repository alongside the source code. This integration elevates prompts to
    a first-class citizen within the development lifecycle, treating them with the
    same rigor as the code itself. Storing prompts in Git provides several key benefits:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固这些提示的重要性，它们被存储在项目的Git仓库中，与源代码一起。这种集成将提示提升到开发生命周期中的第一公民地位，将它们与代码本身一样严格对待。将提示存储在Git中提供了几个关键好处：
- en: '**Version control** : Prompts evolve as features mature or requirements change.
    Storing them in Git ensures a complete history of modifications, enabling teams
    to trace changes over time.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：提示会随着功能的成熟或需求的变化而演变。将它们存储在Git中确保了修改的完整历史记录，使团队能够随着时间的推移追踪变化。'
- en: '**Collaboration** : Developers can review and refine prompts during code reviews,
    ensuring their accuracy and relevance before implementation begins.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：开发者在代码审查过程中可以审查和细化提示，确保在实施开始之前它们的准确性和相关性。'
- en: '**Traceability** : Linking prompts to specific stories, commits, and branches
    creates a transparent and auditable process that ties testing directly to development
    efforts.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可追溯性**：将提示与特定的故事、提交和分支链接，创建了一个透明且可审计的过程，将测试直接与开发工作联系起来。'
- en: '**Reusability** : Over time, prompts for similar features or scenarios can
    be repurposed, reducing redundancy and accelerating future development cycles.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：随着时间的推移，类似功能或场景的提示可以被重新利用，减少冗余并加速未来的开发周期。'
- en: AI-generated code as acceptance criteria
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI生成的代码作为验收标准
- en: Once the prompts are finalized and stored, they become an integral part of the
    story’s acceptance criteria. The assigned software engineer uses the prompt to
    generate test cases or other relevant code through generative AI tools. This generated
    code acts as a baseline for validating the new feature. The key requirement is
    that the generated code must pass successfully—be *green* —before the story is
    marked as complete.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提示被最终确定并存储，它们就成为故事验收标准的一个组成部分。指定的软件工程师使用提示通过生成式AI工具生成测试用例或其他相关代码。这些生成的代码作为验证新特性的基准。关键要求是生成的代码必须成功通过——必须是*绿色*——故事才能被标记为完成。
- en: This approach introduces a new layer of rigor to the definition of *done* in
    SCRUM. It ensures that testing is not an afterthought but a parallel process that
    evolves alongside the feature’s development. Additionally, by automating large
    portions of the testing process through AI, teams can deliver high-quality software
    faster, with fewer manual testing bottlenecks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为SCRUM中“完成”的定义引入了新的严谨性层次。它确保测试不是事后考虑的事情，而是一个与特性开发并行发展的过程。此外，通过AI自动化测试过程的大部分，团队可以更快地交付高质量的软件，减少手动测试瓶颈。
- en: Integrating AI-driven testing into Agile practices demands more than tools—it
    requires a cultural shift.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将AI驱动的测试集成到敏捷实践中不仅需要工具，还需要文化转变。
- en: Adopting a new Agile mindset
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用新的敏捷心态
- en: This practice represents a shift in mindset for Agile teams. The act of defining
    prompts moves testing considerations to earlier in the development process, aligning
    with the principles of TDD. It emphasizes the importance of testing not just as
    a verification step but as a collaborative, iterative process that enhances the
    overall quality of the software.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实践代表了敏捷团队心态的转变。定义提示的行为将测试考虑提前到开发过程的早期，与TDD的原则相一致。它强调了测试不仅作为验证步骤的重要性，而且作为一个协作、迭代的流程，可以增强软件的整体质量。
- en: 'By embedding AI-driven testing prompts into the Agile workflow, teams not only
    embrace the power of generative AI but also elevate their development practices
    to a new level of precision and efficiency. This approach aligns perfectly with
    the goals of Agile: to deliver value faster, adapt to change effectively, and
    maintain a high standard of quality throughout the development lifecycle.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将AI驱动的测试提示嵌入到敏捷工作流程中，团队不仅拥抱了生成式AI的力量，还将他们的开发实践提升到了新的精度和效率水平。这种方法完美地符合敏捷的目标：更快地交付价值、有效地适应变化，并在整个开发生命周期中保持高质量标准。
- en: The structure of an API test environment
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API测试环境的结构
- en: The goal of an API testing environment is to replicate all critical components
    of your application locally, facilitating comprehensive and realistic tests of
    your code. The following figure illustrates a typical setup for such an environment,
    emphasizing a self-contained system suitable for development and testing purposes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: API测试环境的目标是在本地复制应用程序的所有关键组件，以便对代码进行全面和现实的测试。以下图展示了此类环境的典型设置，强调了一个适合开发和测试的自包含系统。
- en: '![Figure 8.2 – Typical structure of a local API testing environment using Docker
    and cloud networks](img/B21843_08_2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 使用Docker和云网络构建的本地API测试环境的典型结构](img/B21843_08_2.jpg)'
- en: Figure 8.2 – Typical structure of a local API testing environment using Docker
    and cloud networks
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 使用Docker和云网络构建的本地API测试环境的典型结构
- en: In this diagram, **API App** represents the primary application whose APIs you
    are testing. This app connects directly to essential backend components such as
    databases, caching services, or messaging queues, all deployed within a containerized
    (Docker) or cloud-based, non-production network environment. The **API Tests**
    component directly interacts with **API App** , simulating real-world scenarios
    and ensuring thorough coverage and validation of API functionality.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，**API App**代表你正在测试的主要应用程序。此应用程序直接连接到关键的后端组件，如数据库、缓存服务或消息队列，所有这些都在容器化（Docker）或基于云的非生产网络环境中部署。**API
    Tests**组件直接与**API App**交互，模拟真实世界场景，确保API功能的全面覆盖和验证。
- en: 'The term “local” here is flexible: it can refer to an individual software engineer’s
    machine, typically using Docker containers, or any non-production cloud-based
    environment provisioned for development purposes. Ensuring every team member has
    access to such standardized, isolated environments is crucial, allowing consistent
    and repeatable tests across different workstations and reducing variability in
    test outcomes.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“本地”一词是灵活的：它可以指一个软件工程师的机器，通常使用Docker容器，或者任何为开发目的提供的非生产云环境。确保每个团队成员都能访问这种标准化的、隔离的环境至关重要，这允许在不同工作站之间进行一致和可重复的测试，并减少测试结果的变化性。
- en: There is an upfront effort involved in creating this local or development environment.
    However, making this investment early in the development lifecycle significantly
    enhances efficiency, reducing the risk of integration issues and accelerating
    overall development.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此本地或开发环境需要前期投入。然而，在开发生命周期早期进行这种投资可以显著提高效率，降低集成问题的风险，并加速整体开发。
- en: “Prompting” the LLMs
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “提示”LLMs
- en: '**Prompt engineering** is the practice of designing and refining prompts given
    to generative AI models to produce precise, accurate, and relevant outputs. It
    involves careful phrasing and iterative tuning to achieve desired responses efficiently.
    And now let’s look at some mechanisms needed to create effective prompts for test
    generation.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示工程**是设计和完善提供给生成式AI模型的提示，以产生精确、准确和相关的输出的实践。它涉及仔细措辞和迭代调整，以有效地实现期望的响应。现在让我们看看创建有效的测试生成提示所需的一些机制。'
- en: As was said before, the use of generative AI for software testing is a perfect
    application of this technology. Specifically, tests are generally less sensitive
    in terms of intellectual property and ownership concerns. Tests are primarily
    tools for validation, ensuring that your main code behaves as expected. Since
    the focus of tests is on functionality, edge cases, and coverage, generative AI
    can quickly generate a wide variety of test cases, saving developers time and
    effort. Moreover, tests are often repetitive and detail-oriented—tasks that AI
    excels at. The use of generative AI here can allow developers to focus on more
    creative or complex aspects of their work, while the AI takes care of the grunt
    work. This means better productivity, faster iteration, and higher test coverage
    with minimal manual effort.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用生成式AI进行软件测试是这项技术的完美应用。具体来说，测试在知识产权和所有权方面的敏感性较低。测试主要是验证工具，确保你的主要代码按预期运行。由于测试的重点是功能、边缘情况和覆盖率，生成式AI可以快速生成各种测试用例，节省开发者的时间和精力。此外，测试通常是重复性和细节导向的——这是AI擅长的任务。在这里使用生成式AI可以让开发者专注于工作中更具创造性和复杂性的方面，而AI则负责处理繁琐的工作。这意味着更高的生产力、更快的迭代和更全面的测试覆盖率，同时手动工作量最小化。
- en: In contrast, when it comes to using generative AI to write the main production
    code, the situation becomes a little more complex. A major concern is ownership
    of the generated code. Depending on the terms of the AI service, the code you
    use might still be partially owned or influenced by the AI provider. This can
    create legal or compliance issues, especially in industries where intellectual
    property is a critical asset. Additionally, there’s the concern that your code—or
    patterns from it—could be used to train future AI models. This could inadvertently
    expose proprietary algorithms, business logic, or sensitive methodologies to external
    entities. While this may not be a major issue for tests (which are often more
    generic and less confidential), it can be a significant risk for production code,
    where the intellectual property and security of the organization are at stake.
    At the time of writing, there are several legal decisions establishing that AI-generated
    content cannot be copyrighted *[3][4]* . Now, we will create the actual prompts
    for our test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当使用生成式 AI 编写主要的生产代码时，情况变得稍微复杂一些。一个主要的问题是生成代码的所有权。根据 AI 服务的条款，你使用的代码可能仍然部分归
    AI 提供商所有或受其影响。这可能会在知识产权是关键资产的行业中产生法律或合规问题。此外，还有担心你的代码——或者从它中提取的模式——可能被用来训练未来的
    AI 模型。这可能会无意中将专有算法、业务逻辑或敏感方法暴露给外部实体。虽然这可能不是测试（通常更通用且不太机密）的主要问题，但它对生产代码来说可能是一个重大风险，因为组织的知识产权和安全受到威胁。在撰写本文时，已有几个法律判决确立，AI
    生成的内容不能获得版权*[3][4]*。现在，我们将为我们的测试创建实际的提示。
- en: Testing the Products API
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Products API
- en: The Products API that we have been using in this book is a very good use case
    for this new testing strategy. Let’s look at a test-generating prompt for that
    API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用的 Products API 是这种新测试策略的一个非常好的用例。让我们看看为该 API 生成测试的提示。
- en: 'Let’s start by creating a test to validate the creation of new products with
    the `PUT` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个测试来验证使用 `PUT` 方法创建新产品：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s look at each part of this prompt in more detail:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个提示的每个部分：
- en: 'First, we define the LLM perspective. This is relevant to establish the role
    the LLM should play, and it does influence the answers. Sometimes it is clear
    in the resulting code when you tell the LLM to act as a senior or junior professional:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 LLM 的视角。这有助于确定 LLM 应扮演的角色，并且它确实会影响答案。有时，当你告诉 LLM 以资深或初级专业人士的身份行事时，这种影响在生成的代码中是明显的：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, give a clear request:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，给出一个清晰的请求：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The LLM’s output is heavily influenced by what you want as a result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 的输出受到你想要的结果的强烈影响。
- en: 'Next, explain the API behavior as clearly as possible. This is important because
    if the underlying behavior is not clear then the LLM will try to fill in the blanks,
    sometimes with invalid assumptions. The more details you add, the better the test
    cases created:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尽可能清晰地解释 API 的行为。这很重要，因为如果底层行为不清楚，LLM 就会尝试填补空白，有时会基于无效的假设。你添加的细节越多，创建的测试用例就越好：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Part of these details is the code that defines the data being tested. Either
    present the data structures used or the expected HTTP responses, but some form
    of unambiguous definition must be present.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节的一部分是定义被测试数据的代码。要么展示使用的数据结构，要么展示预期的 HTTP 响应，但必须以某种形式提供明确的定义。
- en: 'Finally, add any specific assertions we want the test to validate:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加任何我们希望测试验证的具体断言：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of this prompt is the following code and `pom.xml` dependency elements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示的结果是以下代码和 `pom.xml` 依赖元素：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is not in itself complex or hard to write, but it is time-consuming,
    and most software engineers don’t particularly enjoy writing it. Also, using an
    LLM to create the tests adds a lot of flexibility to the process. For example,
    if you want this test to be created in a different language—for example, in Go—we
    only need to change the expected results to have a new version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身并不复杂或难以编写，但它很耗时，大多数软件工程师都不太喜欢编写它。此外，使用 LLM 创建测试为这个过程增加了许多灵活性。例如，如果你想以不同的语言创建这个测试——例如，在
    Go 中——我们只需要更改预期的结果来获得一个新版本。
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Go ahead and play around with the code generation options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩转代码生成选项。
- en: In some projects, there is even the requirement that automated tests be written
    in a different language than the original code. There may not be a real technical
    reason for such a requirement, as an HTTP client is exactly like another, but
    it offers some extra psychological comfort to non-technical people in the project
    to have this extra layer of separation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些项目中，甚至有要求自动测试使用与原始代码不同的语言编写。可能没有真正的技术原因要求这样做，因为HTTP客户端与另一个完全一样，但它为项目中的非技术人员提供了额外的心理安慰，即有这一额外的隔离层。
- en: A more complex API to test
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更复杂的API进行测试
- en: 'In the previous exercise, we looked at testing an API in which we had complete
    access to the source code, and we were developing that API from scratch. Also,
    the example API was intentionally simple. But, there is another common situation
    that many software engineers face: An API that is already in production, with
    not many automated tests available, that is more complex and returns sophisticated
    responses. Let’s look at one such scenario.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们查看了一个API的测试，我们对其源代码有完全的访问权限，并且是从头开始开发该API的。此外，示例API故意很简单。但是，许多软件工程师面临另一个常见的情况：一个已经投入生产的API，可用的自动化测试不多，更复杂，并返回复杂的响应。让我们看看这样一个场景。
- en: For this section, we are going to use the HAPI FHIR APIs and write some tests
    for them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将使用HAPI FHIR API并为其编写一些测试。
- en: HAPI FHIR is a complete Java implementation of the HL7 FHIR standard for healthcare
    interoperability. We chose this example because the API is complex, there is a
    public test implementation available, and it is used extensively in the healthcare
    market. This implementation is used by many organizations worldwide, including
    large hospital complexes, healthcare organizations, and governmental health agencies.
    But what is interesting to us from a testing perspective is how complex these
    APIs are. It is not uncommon to receive a few thousand lines of JSON in the response
    to a search, which allows us to create more nuanced prompts and corresponding
    tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HAPI FHIR是HL7 FHIR标准在医疗保健互操作性方面的完整Java实现。我们选择这个例子是因为API很复杂，有可用的公共测试实现，并且在医疗保健市场中得到了广泛的应用。这个实现被全球许多组织使用，包括大型医院综合体、医疗保健组织和政府卫生机构。但从测试的角度来看，对我们来说有趣的是这些API的复杂性。在搜索的响应中收到数千行JSON并不罕见，这使我们能够创建更细致的提示和相应的测试。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: 'To know more about HAPI FHIR and HL7 FHIR, please refer to the following links:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于HAPI FHIR和HL7 FHIR的信息，请参阅以下链接：
- en: '[https://hapifhir.io/](https://hapifhir.io/)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hapifhir.io/](https://hapifhir.io/)'
- en: '[https://hl7.org/fhir/](https://hl7.org/fhir/)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hl7.org/fhir/](https://hl7.org/fhir/)'
- en: Because healthcare requirements are usually unique to each organization and
    dependent on many local regulations, there is a high level of customization required
    for any HAPI FHIR implementation. It is not uncommon to find several thousand
    lines of custom code in a specific implementation. A strong set of tests is crucial
    when customizing such a complex API. You don’t want to break any of the HAPI FHIR
    contracts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于医疗保健需求通常对每个组织都是独特的，并且依赖于许多地方性法规，因此任何HAPI FHIR实现都需要高度定制。在特定实现中找到数千行自定义代码并不罕见。在定制如此复杂的API时，有一套强大的测试至关重要。你不想破坏任何HAPI
    FHIR合约。
- en: 'Also, one great advantage of HAPI FHIR as a test example for us is the availability
    of a public test server: [https://hapi.fhir.org/baseR4](https://hapi.fhir.org/baseR4)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HAPI FHIR作为我们的测试示例的一个巨大优势是公共测试服务器的可用性：[https://hapi.fhir.org/baseR4](https://hapi.fhir.org/baseR4)
- en: 'Having prior knowledge of the HAPI FHIR APIs is not necessary to follow this
    section. We are interested only in looking at the API’s behavior and preparing
    tests to validate that such behavior does not change. Here are a couple of HAPI
    FHIR concepts we will use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本节之前，不需要事先了解HAPI FHIR API。我们只关注查看API的行为，并准备测试以验证这种行为不会改变。以下是我们将使用的几个HAPI
    FHIR概念：
- en: '**PATIENT** : HAPI FHIR is a healthcare system; therefore, PATIENT is a first-class
    element in it. We will write some tests to validate that searching for a patient
    returns the elements we want.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耐心**：HAPI FHIR是一个医疗保健系统；因此，PATIENT是其中的一个一等元素。我们将编写一些测试来验证搜索患者时返回的元素是我们想要的。'
- en: '**RESOURCE TYPE – BUNDLE** : In HAPI FHIR, all results of a search are bundles.
    This is just the name used to define a set of data, but we will validate this
    behavior as part of our tests.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源类型 – BUNDLE**：在HAPI FHIR中，所有搜索结果都是捆绑包。这只是用来定义一组数据的名称，但我们将验证此行为作为我们测试的一部分。'
- en: With that in mind, let’s assume you are a software engineer in the HAPI FHIR
    support team in a large hospital, and you just received the task of customizing
    the HAPI FHIR API to add a new element to a `Patient` record. This new element
    is used only in this hospital’s system. Assume that there are no test cases for
    the Patient API. What can you do?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们假设您是一家大型医院HAPI FHIR支持团队的软件工程师，您刚刚接到了定制HAPI FHIR API的任务，以向`Patient`记录添加一个新元素。这个新元素仅用于这家医院的系统。假设没有针对Patient
    API的测试用例。您能做什么？
- en: Well, you could start by looking at the source code and try to find all the
    relevant classes and all, but this is a time-consuming task and will delay the
    generation of the tests. Maybe a more pragmatic approach is needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，您可以从查看源代码开始，尝试找到所有相关的类，但这是一项耗时的工作，会延迟测试的生成。可能需要更实际的解决方案。
- en: So, start by looking at the API responses and prepare tests so your changes
    will not break the current contract.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先查看API响应并准备测试，以确保您的更改不会破坏当前合约。
- en: 'Here is a `GET` request that returns all the patients in the system, one at
    a time. All the data is synthetic and not related to any real individual:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个返回系统中所有患者的`GET`请求，一次一个。所有数据都是合成的，与任何真实个人无关：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s examine in detail the response we received (you will not get the same
    data when running this example, but the format and structure will be the same):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查我们收到的响应（您在运行此示例时将不会得到相同的数据，但格式和结构将是相同的）：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This result is already 70+ lines long and is a good start for our API analysis
    and to design our tests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果已经超过70行，是我们API分析和设计测试的好起点。
- en: Let’s look at the results. We can see that the result of a `GET` function has
    a `resourceType` , which in this case is `Bundle` . `Type` is a `searchset` .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果。我们可以看到`GET`函数的结果有一个`resourceType`，在这种情况下是`Bundle`。`Type`是`searchset`。
- en: There is an array of links (“link”) and an array of entries (“entry”) with the
    actual patient’s data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个链接数组（“链接”）和一个条目数组（“条目”），包含实际患者的数据。
- en: Good, this is a start.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个开始。
- en: Preparing your test prompt
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试提示
- en: 'Remember that your goal is to make changes to the code, without breaking the
    current state, so start by defining clearly what you want to validate with your
    test—for example, “Test that all `GET` searches will return a valid pagination
    JSON.” Now, let’s write a prompt to generate our first test. The results are from
    ChatGPT 4:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您的目标是修改代码，而不破坏当前状态，因此首先明确您想通过测试验证的内容——例如，“测试所有`GET`搜索将返回有效的分页JSON。”现在，让我们编写一个提示来生成我们的第一个测试。以下是ChatGPT
    4的结果：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Paste the whole JSON sample with the prompt.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个JSON示例与提示粘贴。
- en: 'The results are the following tests and `pom.xml` changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下测试和`pom.xml`更改：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code runs immediately without any modifications. This was not the case
    with the previous generation of LLMs. If you are using an older model, such as
    ChatGPT 3.5 for example, you may have to manually adjust the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码立即运行，无需任何修改。这与前一代LLM的情况不同。如果您使用的是较旧的模型，例如ChatGPT 3.5，例如，您可能需要手动调整代码。
- en: This whole test was completed in less than a minute by the LLM and it is actually
    fun to write and see the results so quickly—a very different experience from having
    to manually write tests by hand. The test can be improved, of course. For example,
    it could be changed to get the URL to be tested from a list or even a property
    file for added flexibility, but the core of the code is there and ready to be
    used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试由LLM在不到一分钟内完成，实际上快速编写和查看结果非常有趣——与手动编写测试完全不同的体验。当然，测试可以改进。例如，它可以改为从列表或属性文件中获取要测试的URL，以增加灵活性，但代码的核心是现成的，可以立即使用。
- en: Now, let’s move on to a more complex type of test and see how far we can go
    with our validations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行更复杂的测试类型，看看我们的验证能走多远。
- en: Validating more complex behavior
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证更复杂的行为
- en: 'Looking at the API’s response, we can see that the “link” array has two entries
    on this first page: “ `self"` and “ `next"` .'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 查看API的响应，我们可以看到“链接”数组在第一页上有两个条目：“`self`”和“`next`”。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A good test would be to validate that a response always has the `self` link.
    Let’s expand the prompt to include this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试是验证响应始终包含`self`链接。让我们扩展提示以包括这一点。
- en: 'Here’s the new prompt:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新的提示：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will add the following code to our test:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的测试添加以下代码：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, the code is not very complex, but it is already showing signs of increasing
    difficulty. Writing this by hand would not be hard, but would take some time and
    attention. LLMs can create it in 30 seconds or less.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码并不复杂，但它已经显示出难度增加的迹象。手动编写这个代码并不难，但需要一些时间和注意力。LLM可以在30秒或更短的时间内完成它。
- en: Now, let’s add even more complexity. This is a pagination exercise, so let’s
    ask the code to follow the `next` link for a few pages and validate that page.
    Then, validate if every entry in the result is unique, using `fullUrl` inside
    the `entry` array as a candidate key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们增加更多的复杂性。这是一个分页练习，所以让我们要求代码跟随几页的`next`链接并验证该页面。然后，验证结果中的每个条目是否唯一，使用`entry`数组中的`fullUrl`作为候选键。
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result is starting to look more sophisticated and interesting.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果开始看起来更加复杂和有趣。
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test is now a lot more complex. Look at how some helping functions are created
    ( `isValidUUID()` , `createConnection()` ). This test would take longer to write
    and be costlier to maintain. But with the use of LLMs, the whole test is ready
    to run in just a few minutes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在变得更加复杂。看看一些辅助函数是如何创建的（`isValidUUID()`，`createConnection()`）。编写这个测试会花费更长的时间和更高的维护成本。但是，使用LLM，整个测试只需几分钟就可以运行。
- en: I hope you are seeing the pattern at this point. As the API gets more complex,
    the tests also evolve. The LLM prompt itself is now stored in the Git repository
    and is an integral part of the code base, to the point that it can be seen as
    part of the software documentation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您现在已经看到了这个模式。随着API变得更加复杂，测试也在不断发展。LLM提示本身现在存储在Git仓库中，并且是代码库的组成部分，到了可以将其视为软件文档的一部分的程度。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The introduction of generative AI holds immense potential to reshape the landscape
    of software development, especially in the realm of testing. By automating test
    creation, streamlining complex processes, and enhancing adaptability, generative
    AI offers the promise of transforming testing into a more efficient, accessible,
    and cost-effective part of the development lifecycle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式AI的引入具有重塑软件开发领域，特别是在测试领域的潜力。通过自动化测试创建、简化复杂流程和增强适应性，生成式AI有望将测试转变为开发生命周期中更高效、更易于访问和成本效益更高的部分。
- en: Through the strategies and examples discussed in this chapter, we hope you have
    acquired the skills and inspiration to explore and extend the testing of your
    APIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章讨论的策略和示例，我们希望您已经获得了探索和扩展API测试的技能和灵感。
- en: Testing is a tool for validating behavior during the development and maintenance
    of our APIs, but for a truly robust service, we need to monitor these behaviors
    in production. That is what we will be looking at in the next chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是在我们API的开发和维护过程中验证行为的一种工具，但对于一个真正健壮的服务，我们需要在生产中监控这些行为。这就是我们在下一章将要探讨的内容。
- en: Further reading
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Test driven development* : [https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development
    )'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试驱动开发* : [https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development
    )'
- en: '*Prompt Engineering* : [https://en.wikipedia.org/wiki/Prompt_engineering](https://en.wikipedia.org/wiki/Prompt_engineering
    )'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提示工程* : [https://en.wikipedia.org/wiki/Prompt_engineering](https://en.wikipedia.org/wiki/Prompt_engineering
    )'
- en: '*Legal Ruling: AI-Generated Art and Copyright* : [https://www.reuters.com/legal/ai-generated-art-cannot-receive-copyrights-us-court-says-2023-08-21/](https://www.reuters.com/legal/ai-generated-art-cannot-receive-copyrights-us-court-says-2023-08-21/
    )'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*法律裁决：AI生成艺术与版权* : [https://www.reuters.com/legal/ai-generated-art-cannot-receive-copyrights-us-court-says-2023-08-21/](https://www.reuters.com/legal/ai-generated-art-cannot-receive-copyrights-us-court-says-2023-08-21/
    )'
- en: '*U.S. Copyright Office’s View on AI Prompts* : [https://www.theverge.com/news/602096/copyright-office-says-ai-prompting-doesnt-deserve-copyright-protection](https://www.theverge.com/news/602096/copyright-office-says-ai-prompting-doesnt-deserve-copyright-protection
    )'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*美国版权局对AI提示的看法* : [https://www.theverge.com/news/602096/copyright-office-says-ai-prompting-doesnt-deserve-copyright-protection](https://www.theverge.com/news/602096/copyright-office-says-ai-prompting-doesnt-deserve-copyright-protection
    )'
- en: '*HAPI FHIR: Open-Source Implementation of HL7 FHIR* : [https://hapifhir.io/](https://hapifhir.io/
    )'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HAPI FHIR：HL7 FHIR的开源实现* : [https://hapifhir.io/](https://hapifhir.io/ )'
- en: '*HL7 FHIR Official Specification* [https://hl7.org/fhir/](https://hl7.org/fhir/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HL7 FHIR官方规范* [https://hl7.org/fhir/](https://hl7.org/fhir/)'
