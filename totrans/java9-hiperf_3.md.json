["```java\nclass MyThread extends Thread {\n}\n```", "```java\nSystem.out.print(\"demo_thread_01(): \");\nMyThread t1 = new MyThread();\nt1.start();\nSystem.out.println(\"Thread name=\" + t1.getName());\n```", "```java\nclass MyThread extends Thread {\n    private double result;\n    public MyThread(String name){ super(name); }\n    public void calculateAverageSqrt(){\n        result =  IntStream.rangeClosed(1, 99999)\n                           .asDoubleStream()\n                           .map(Math::sqrt)\n                           .average()\n                           .getAsDouble();\n    }\n    public double getResult(){ return this.result; }\n}\n```", "```java\nSystem.out.print(\"demo_thread_02(): \");\nMyThread t1 = new MyThread(\"Thread01\");\nt1.calculateAverageSqrt();\nSystem.out.println(t1.getName() + \": result=\" + t1.getResult());\n```", "```java\nclass MyThread01 extends Thread {\n    private double result;\n    public MyThread01(String name){ super(name); }\n    public void run(){\n        result =  IntStream.rangeClosed(1, 99999)\n                           .asDoubleStream()\n                           .map(Math::sqrt)\n                           .average()\n                           .getAsDouble();\n    }\n    public double getResult(){ return this.result; }\n}\n```", "```java\nSystem.out.print(\"demo_thread_03(): \");\nMyThread01 t1 = new MyThread01(\"Thread01\");\nt1.start();\nSystem.out.println(t1.getName() + \": result=\" + t1.getResult());\n```", "```java\npublic void run() {\n    for (int i = 1; i < 100000; i++) {\n        double s = Math.sqrt(1\\. * i);\n        result = result + s;\n    }\n    result = result / 99999;\n}\n```", "```java\ntry {\n     t1.join();\n } catch (InterruptedException e) { \n     e.printStackTrace();\n }\n```", "```java\n@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     */\n    public abstract void run();\n```", "```java\nclass MyRunnable01 implements Runnable {\n    private String id;\n    private double result;\n    public MyRunnable01(int id) {\n        this.id = String.valueOf(id);\n    }\n    public String getId() { return this.id; }\n    public double getResult() { return this.result; }\n    public void run() {\n        result = IntStream.rangeClosed(1, 99999)\n                          .asDoubleStream()\n                          .map(Math::sqrt)\n                          .average()\n                          .getAsDouble();\n    }\n}\n```", "```java\nSystem.out.print(\"demo_runnable_01(): \");\nMyRunnable01 myRunnable = new MyRunnable01(1);\nThread t1 = new Thread(myRunnable);\nt1.start();\nSystem.out.println(\"Worker \" + myRunnable.getId() \n           + \": result=\" + myRunnable.getResult());\n```", "```java\nSystem.out.print(\"demo_runnable_02(): \");\nMyRunnable01 myRunnable = new MyRunnable01(1);\nThread t1 = new Thread(myRunnable);\nt1.start();\ntry {\n    t1.join();\n} catch (InterruptedException e) { \n    e.printStackTrace();\n}\nSystem.out.println(\"Worker \" + myRunnable.getId() \n           + \": result=\" + myRunnable.getResult());\n```", "```java\nSystem.out.print(\"demo_lambda_01(): \");\nString id = \"1\";\nThread t1 = \n    new Thread(() -> IntStream.rangeClosed(1, 99999)\n         .asDoubleStream().map(Math::sqrt).average()\n         .ifPresent(d -> System.out.println(\"Worker \" \n                            + id + \": result=\" + d)));\nt1.start();\ntry {\n    t1.join();\n} catch (InterruptedException e) { \n    e.printStackTrace();\n}\n```", "```java\nRunnable r = () -> IntStream.rangeClosed(1, 99999)\n       .asDoubleStream().map(Math::sqrt).average()\n      .ifPresent(d -> System.out.println(\"Worker \" \n                           + id + \": result=\" + d));\nThread t1 = new Thread(r);\n```", "```java\nvoid calculateAverage(String id) {\n    IntStream.rangeClosed(1, 99999)\n        .asDoubleStream().map(Math::sqrt).average()\n        .ifPresent(d -> System.out.println(\"Worker \" \n                            + id + \": result=\" + d));\n}\nvoid demo_lambda_03() {\n    System.out.print(\"demo_lambda_03(): \");\n    Thread t1 = new Thread(() -> calculateAverage(\"1\"));\n    ...\n}\n```", "```java\nRunnable r = ...;\n(new Thread(r)).start()\n```", "```java\nclass MyRunnable02 implements Runnable {\n    private String id;\n    public MyRunnable02(int id) {\n        this.id = String.valueOf(id);\n    }\n    public String getId(){ return this.id; }\n    public void run() {\n        double result = IntStream.rangeClosed(1, 100)\n           .flatMap(i -> IntStream.rangeClosed(1, 99999))\n           .takeWhile(i -> \n                 !Thread.currentThread().isInterrupted())\n           .asDoubleStream()\n           .map(Math::sqrt)\n           .average()\n           .getAsDouble();\n        if(Thread.currentThread().isInterrupted()){\n            System.out.println(\" Worker \" + getId() \n                       + \": result=ignored: \" + result);\n        } else {\n            System.out.println(\" Worker \" + getId() \n                                + \": result=\" + result);\n        }\n}\n```", "```java\ntry {\n    Thread.currentThread().wait();\n} catch (InterruptedException e) {}\n// Do what has to be done\n```", "```java\nThe better implementation is as follows:\n```", "```java\ntry {\n    Thread.currentThread().wait();\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n// Do what has to be done\n```", "```java\njoin() method, we did not need to do that because that was the main code (the highest level code) that had to be paused.\n```", "```java\nExecutorService pool = Executors.newCachedThreadPool();\nIntStream.rangeClosed(1, 3).\n       forEach(i -> pool.execute(new MyRunnable02(i)));\nSystem.out.println(\"Before shutdown: isShutdown()=\" \n          + pool.isShutdown() + \", isTerminated()=\" \n                                + pool.isTerminated());\npool.shutdown(); // New threads cannot be submitted\nSystem.out.println(\"After  shutdown: isShutdown()=\" \n          + pool.isShutdown() + \", isTerminated()=\" \n                                + pool.isTerminated());\n```", "```java\ntry {\n    pool.execute(new MyRunnable02(100));\n} catch(RejectedExecutionException ex){\n    System.err.println(\"Cannot add another worker-thread to the service queue:\\n\" + ex.getMessage());\n}\n```", "```java\nCannot add another worker-thread to the service queue:\nTask com.packt.java9hp.ch09_threads.MyRunnable02@6f7fd0e6 \n    rejected from java.util.concurrent.ThreadPoolExecutor\n    [Shutting down, pool size = 3, active threads = 3, \n    queued tasks = 0, completed tasks = 0]\n```", "```java\nlong timeout = 100;\nTimeUnit timeUnit = TimeUnit.MILLISECONDS;\nSystem.out.println(\"Waiting for all threads completion \" \n                     + timeout + \" \" + timeUnit + \"...\");\n// Blocks until timeout or all threads complete execution\nboolean isTerminated = \n                pool.awaitTermination(timeout, timeUnit);\nSystem.out.println(\"isTerminated()=\" + isTerminated);\nif (!isTerminated) {\n    System.out.println(\"Calling shutdownNow()...\");\n    List<Runnable> list = pool.shutdownNow(); \n    printRunningThreadIds(list);\n    System.out.println(\"Waiting for threads completion \" \n                     + timeout + \" \" + timeUnit + \"...\");\n    isTerminated = \n                pool.awaitTermination(timeout, timeUnit);\n    if (!isTerminated){\n        System.out.println(\"Some threads are running...\");\n    }\n    System.out.println(\"Exiting.\");\n}\n```", "```java\nvoid printRunningThreadIds(List<Runnable> l){\n    String list = l.stream()\n            .map(r -> (MyRunnable02)r)\n            .map(mr -> mr.getId())\n            .collect(Collectors.joining(\",\"));\n    System.out.println(l.size() + \" thread\"\n       + (l.size() == 1 ? \" is\" : \"s are\") + \" running\"\n            + (l.size() > 0 ? \": \" + list : \"\") + \".\");\n}\n```", "```java\nclass MyRunnable02 implements Runnable {\n    private String id;\n    public MyRunnable02(int id) {\n        this.id = String.valueOf(id);\n    }\n    public String getId(){ return this.id; }\n    public void run() {\n        double result = IntStream.rangeClosed(1, 100)\n           .flatMap(i -> IntStream.rangeClosed(1, 99999))\n           .asDoubleStream()\n           .map(Math::sqrt)\n           .average()\n           .getAsDouble();\n        System.out.println(\" Worker \" + getId() \n                                + \": result=\" + result);\n}\n```", "```java\nclass MyRunnable03 implements Runnable {\n  private String name;\n  private double result;\n  public String getName(){ return this.name; }\n  public double getResult() { return this.result; }\n  public void run() {\n    this.name = Thread.currentThread().getName();\n    double result = IntStream.rangeClosed(1, 100)\n      .flatMap(i -> IntStream.rangeClosed(1, 99999))\n      .takeWhile(i -> !Thread.currentThread().isInterrupted())\n      .asDoubleStream().map(Math::sqrt).average().getAsDouble();\n    if(!Thread.currentThread().isInterrupted()){\n      this.result = result;\n    }\n  }\n}\n```", "```java\nvoid demo_CheckResults() {\n    ExecutorService pool = Executors.newCachedThreadPool();\n    MyRunnable03 r1 = new MyRunnable03();\n    MyRunnable03 r2 = new MyRunnable03();\n    pool.execute(r1);\n    pool.execute(r2);\n    try {\n        t1.join();\n    } catch (InterruptedException e) { \n        e.printStackTrace();\n    }\n    System.out.println(\"Worker \" + r1.getName() + \": result=\" + r1.getResult());\n    System.out.println(\"Worker \" + r2.getName() + \": result=\" + r2.getResult());\n    shutdown(pool);\n}\n```", "```java\nvoid shutdown(ExecutorService pool) {\n    pool.shutdown();\n    try {\n        if(!pool.awaitTermination(1, TimeUnit.SECONDS)){\n            pool.shutdownNow();\n        }\n    } catch (InterruptedException ie) {}\n}\n```", "```java\nExecutorService pool = Executors.newCachedThreadPool();\nFuture f1 = pool.submit(new MyRunnable03());\nFuture f2 = pool.submit(new MyRunnable03());\nprintFuture(f1, 1);\nprintFuture(f2, 2);\nshutdown(pool);\n```", "```java\nvoid printFuture(Future future, int id) {\n    System.out.println(\"printFuture():\");\n    while (!future.isCancelled() && !future.isDone()){\n        System.out.println(\"    Waiting for worker \" \n                                + id + \" to complete...\");\n        sleepMs(10);\n    }\n    System.out.println(\"    Done...\");\n}\n```", "```java\nvoid sleepMs(int sleepMs) {\n    try {\n        TimeUnit.MILLISECONDS.sleep(sleepMs);\n    } catch (InterruptedException e) {}\n}\n```", "```java\nclass Result {\n    private double result;\n    private String workerName;\n    public Result(String workerName, double result) {\n        this.result = result;\n        this.workerName = workerName;\n    }\n    public String getWorkerName() { return workerName; }\n    public double getResult() { return result;}\n}\n```", "```java\nclass MyCallable01<T> implements Callable {\n  public Result call() {\n    double result = IntStream.rangeClosed(1, 100)\n       .flatMap(i -> IntStream.rangeClosed(1, 99999))\n       .takeWhile(i -> !Thread.currentThread().isInterrupted())\n       .asDoubleStream().map(Math::sqrt).average().getAsDouble();\n\n    String workerName = Thread.currentThread().getName();\n    if(Thread.currentThread().isInterrupted()){\n        return new Result(workerName, 0);\n    } else {\n        return new Result(workerName, result);\n    }\n  }\n}\n```", "```java\nExecutorService pool = Executors.newCachedThreadPool();\nFuture f1 = pool.submit(new MyCallable01<Result>());\nFuture f2 = pool.submit(new MyCallable01<Result>());\nprintResult(f1, 1);\nprintResult(f2, 2);\nshutdown(pool);\n```", "```java\nvoid printResult(Future<Result> future, int id) {\n    System.out.println(\"printResult():\");\n    while (!future.isCancelled() && !future.isDone()){\n        System.out.println(\"    Waiting for worker \" \n                              + id + \" to complete...\");\n        sleepMs(10);\n    }\n    try {\n        Result result = future.get(1, TimeUnit.SECONDS);\n        System.out.println(\"    Worker \" \n                + result.getWorkerName() + \": result = \" \n                                   + result.getResult());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n```", "```java\nExecutorService pool = Executors.newCachedThreadPool();\ntry {\n    List<Callable<Result>> callables = \n              List.of(new MyCallable01<Result>(), \n                           new MyCallable01<Result>());\n    List<Future<Result>> futures = \n                             pool.invokeAll(callables);\n    printResults(futures);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nshutdown(pool);\n```", "```java\nvoid printResults(List<Future<Result>> futures) {\n    System.out.println(\"printResults():\");\n    int i = 1;\n    for (Future<Result> future : futures) {\n        printResult(future, i++);\n    }\n}\n```", "```java\nSystem.out.println(\"demo_InvokeAny():\");\nExecutorService pool = Executors.newCachedThreadPool();\ntry {\n    List<Callable<Result>> callables = \n                   List.of(new MyCallable01<Result>(), \n                            new MyCallable01<Result>());\n    Result result = pool.invokeAny(callables);\n    System.out.println(\"    Worker \" \n                        + result.getWorkerName()\n                  + \": result = \" + result.getResult());\n} catch (InterruptedException | ExecutionException e) {\n    e.printStackTrace();\n}\nshutdown(pool);\n```", "```java\nvoid printAllThreads() {\n    System.out.println(\"printAllThreads():\");\n    Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();\n    for(Thread t: map.keySet()){\n        System.out.println(\"    \" + t);\n    }\n```", "```java\nvoid demo_CheckResults() {\n    ExecutorService pool = Executors.newCachedThreadPool();\n    MyRunnable03 r1 = new MyRunnable03();\n    MyRunnable03 r2 = new MyRunnable03();\n    pool.execute(r1);\n    pool.execute(r2);\n    sleepMs(1000);\n    printAllThreads();\n    shutdown(pool);\n}\n```", "```java\nvoid printAllThreads() {\n    System.out.println(\"printAllThreads():\");\n    Map<Thread, StackTraceElement[]> map \n                               = Thread.getAllStackTraces();\n    for(Thread t: map.keySet()){\n        System.out.println(\"   \" + t);\n        for(StackTraceElement ste: map.get(t)){\n            System.out.println(\"        \" + ste);\n        }\n    }\n}\n```", "```java\nvoid printThreadsInfo() {\n    System.out.println(\"printThreadsInfo():\");\n    ThreadMXBean threadBean = \n                      ManagementFactory.getThreadMXBean();\n    long ids[] = threadBean.getAllThreadIds();\n    Arrays.sort(ids);\n    ThreadInfo[] tis = threadBean.getThreadInfo(ids, 0);\n    for (ThreadInfo ti : tis) {\n        if (ti == null) continue;\n        System.out.println(\"    Id=\" + ti.getThreadId() \n                       + \", state=\" + ti.getThreadState() \n                          + \", name=\" + ti.getThreadName());\n    }\n}\n```", "```java\nThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n```", "```java\nclass MyRunnable04 implements Runnable {\n  private int id;\n  public MyRunnable04(int id) { this.id = id; }\n  public void run() {\n    IntStream.rangeClosed(1, 5)\n      .peek(i -> System.out.println(\"Thread \"+id+\": \"+ i))\n      .forEach(i -> Demo04Synchronization.result += i);\n    }\n}\n```", "```java\npublic class Demo04Synchronization {\n    public static int result;\n    public static void main(String... args) {\n        System.out.println();\n        demo_ThreadInterference();\n    }\n    private static void demo_ThreadInterference(){\n        System.out.println(\"demo_ThreadInterference: \");\n        MyRunnable04 r1 = new MyRunnable04(1);\n        Thread t1 = new Thread(r1);\n        MyRunnable04 r2 = new MyRunnable04(2);\n        Thread t2 = new Thread(r2);\n        t1.start();\n        sleepMs(100);\n        t2.start();\n        sleepMs(100);\n        System.out.println(\"Result=\" + result);\n    }\n    private static void sleepMs(int sleepMs) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(sleepMs);\n        } catch (InterruptedException e) {}\n    }\n}\n```", "```java\nprivate static int result;\npublic static synchronized void incrementResult(int i){\n    result += i;\n}\n```", "```java\npublic void run() {\n    IntStream.rangeClosed(1, 250)\n       .forEach(Demo04Synchronization::incrementResult);\n}\n```", "```java\npublic static void incrementResult(int i){\n    synchronized (Demo04Synchronization.class){\n        result += i;\n    }\n}\n```", "```java\nclass MyRunnable05 implements Runnable {\n    public synchronized void incrementResult(int i){\n        Demo04Synchronization.result += i;\n    }\n    public void run() {\n        IntStream.rangeClosed(1, 250)\n                .forEach(this::incrementResult);\n    }\n}\n```", "```java\nvoid demo_Synchronized(){\n    System.out.println(\"demo_Synchronized: \");\n    MyRunnable05 r1 = new MyRunnable05();\n    Thread t1 = new Thread(r1);\n    Thread t2 = new Thread(r1);\n    t1.start();\n    t2.start();\n    sleepMs(100);\n    System.out.println(\"Result=\" + result);\n}\n```", "```java\nLock lock = ...;\n...\n    lock.lock();\n    try {\n        // the fragment that is synchronized\n    } finally {\n        lock.unlock();\n    }\n...\n}\n```", "```java\n@FunctionalInterface\npublic static interface Flow.Publisher<T> {\n  public void subscribe(Flow.Subscriber<? super T> subscriber);\n}\n\npublic static interface Flow.Subscriber<T> {\n  public void onSubscribe(Flow.Subscription subscription);\n  public void onNext(T item);\n  public void onError(Throwable throwable);\n  public void onComplete();\n}\n\npublic static interface Flow.Subscription {\n  public void request(long numberOfItems);\n  public void cancel();\n}\n\npublic static interface Flow.Processor<T,R> \n               extends Flow.Subscriber<T>, Flow.Publisher<R> {\n}\n```", "```java\nvoid demo_ForLoop(){\n    List<Double> r = new ArrayList<>();\n    for(int i = 1; i < 6; i++){\n        System.out.println(i);\n        if(i%2 == 0){\n            System.out.println(i);\n            r.add(doSomething(i));\n        }\n    }\n    double sum = 0d;\n    for(double d: r){ sum += d; }\n    System.out.println(sum / r.size());\n}\nstatic double doSomething(int i){\n    return Math.sqrt(1.*i);\n}\n```", "```java\nvoid demo_Stream(){\n    double a = IntStream.rangeClosed(1, 5)\n        .peek(System.out::println)\n        .filter(i -> i%2 == 0)\n        .peek(System.out::println)\n        .mapToDouble(i -> doSomething(i))\n        .average().getAsDouble();\n    System.out.println(a);\n}\n```", "```java\nvoid demo_Observable1(){\n    Observable.just(1,2,3,4,5)\n        .doOnNext(System.out::println)\n        .filter(i -> i%2 == 0)\n        .doOnNext(System.out::println)\n        .map(i -> doSomething(i))\n        .reduce((r, d) -> r + d)\n        .map(r -> r / 2)\n        .subscribe(System.out::println);\n}\n```", "```java\nvoid demo_Observable2(){\n    Observable<Double> observable = Observable\n            .just(1,2,3,4,5)\n            .doOnNext(System.out::println)\n            .filter(i -> i%2 == 0)\n            .doOnNext(System.out::println)\n            .map(Demo05Reactive::doSomething);\n\n    observable\n            .reduce((r, d) -> r + d)\n            .map(r -> r / 2)\n            .subscribe(System.out::println);\n\n    observable\n            .reduce((r, d) -> r + d)\n            .subscribe(System.out::println);\n}\n```", "```java\nvoid demo_Observable2(){\n    Observable<Double> observable = Observable\n            .just(1,2,3,4,5)\n            .doOnNext(System.out::println)\n            .filter(i -> i%2 == 0)\n            .doOnNext(System.out::println)\n            .map(Demo05Reactive::doSomething)\n            .cache();\n\n    observable\n            .reduce((r, d) -> r + d)\n            .map(r -> r / 2)\n            .subscribe(System.out::println);\n\n    observable\n            .reduce((r, d) -> r + d)\n            .subscribe(System.out::println);\n}\n```", "```java\nsubscribe(v -> System.out.println(\"Result=\" + v),\n        e -> {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        },\n        () -> System.out.println(\"All the data processed\"));\n```", "```java\nobservable.subscribeOn(Schedulers.io())\n        .subscribe(System.out::println);\n```"]