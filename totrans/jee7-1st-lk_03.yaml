- en: Chapter 3. The Presentation Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will review the improvements in the Java EE platform for
    the presentation layer. In concrete terms, we are going to talk about the following
    specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Servlet 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression Language 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaServer Faces 2.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet 3.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Servlet 3.1 Specification was developed under JSR 340\. This section gives
    you only an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is a Servlet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There was a time in computer science when we could not create dynamic web pages.
    At that time, users had access only to static web pages, such as in a newspaper.
    Among the many proposed solutions, the first Java solution was the **Servlet**,
    a revolutionary technology used to extend the capabilities of servers based on
    the request-response programming model. It enabled web servers to handle http
    requests and dynamically generate web pages according to user parameters. Since
    then, technologies have advanced a lot in order to facilitate the development
    of web applications. However, the Servlet technology remains the most widely used
    Java solution for processing of HTTP requests/responses in the background.
  prefs: []
  type: TYPE_NORMAL
- en: That said, at the base of almost all Java frameworks dedicated to the HTTP protocol
    (JSF, Struts, Spring MVC, BIRT, web services solutions), you will find at least
    one Servlet (that is, you have `FacesServlet` in JSF, `ViewerServlet`, and the
    `BirtEngineServlet` for BIRT). You understand why this technology should attract
    our attention, because a change in the Servlet specification will have repercussions
    on a multitude of tools.
  prefs: []
  type: TYPE_NORMAL
- en: A login page with a Servlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concretely, a Servlet is a Java class that implements the Servlet interface
    directly or indirectly. The following code represents an example of a Servlet
    that returns a connection interface to the user and redirects it to another interface
    after validating its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our `ConnexionServlet` class extends `javax.servlet.http.`
    `HttpServlet`; this is an abstract class that implements the `Servlet` interface.
    It defines the lifecycle methods (`doGet` and `doPost`) of the `Servlet` object
    that allows us to handle HTTP service requests and send back a response. To access
    the page generated by this Servlet, you must enter an URL similar to this one:
    `http://localhost:8080/chapter03PresentationLayer/connexionServlet`. Here, `connexionServlet`
    is the name given in the `@WebServlet` annotation. On this page, you will have
    the **Sign it** button displayed by using the following instruction`:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A click on this button generates an HTTP request that will cause execution
    of the `processRequest(HttpServletRequest request, HttpServletResponse response)`
    method. Based on the results of the `connexion` parameters validation, you will
    be redirected to the error page or home page. In the case of a redirect to the
    home page, we will add to the URL a parameter containing the name of the user
    in order to adapt the greeting. The URL of the homepage is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/chapter03PresentationLayer/WelcomeServlet?name=arnoldp`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the `name` parameter, we execute the instruction: `out.println("<h1>Welcome
    Mr " + request.getParameter("name")+ "</h1>");` in the `WelcomeServlet` Servlet.'
  prefs: []
  type: TYPE_NORMAL
- en: Latest improvements of Servlet 3.1 in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following Servlet 3.0, which was focused on ease of development, pluggability,
    asynchronous processing, and security enhancements, Servlet 3.1 has brought a
    number of clarifications to features of the previous version and some changes;
    the main ones are: non blocking I/O API and protocol upgrade processing.'
  prefs: []
  type: TYPE_NORMAL
- en: Non blocking I/O API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The non blocking I/O API piggybacks on the asynchronous request processing and
    the upgrade processing to improve the scalability of the Web Container. Indeed,
    the introduction of asynchronous processing in Servlet 3.0 has made it possible
    to reduce waiting time between requests by enabling the thread responsible for
    processing the client's requests and delegating to other threads the execution
    of heavy processes in order to be ready to accept a new request. But, because
    of the traditional way to collect data input/output with a `while` loop (see the
    following code), the main thread responsible for request processing can be blocked
    due to pending data. For example, when you send a large amount of data to a very
    powerful server across a network, the time taken for data collection will be inversely
    proportional to the bandwidth of the network. The smaller the bandwidth, the more
    time the server will take to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To solve this problem, two listeners (`ReadListener` and `WriteListener`) have
    been added to the Java EE platform and new APIs were also introduced into `ServletInputStream`
    and `ServletOutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the new listeners for the non blocking I/O API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Listener** | **Callbacks** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadListener` | `void onDataAvailable()` | This method is called whenever
    data is available to read without blocking |'
  prefs: []
  type: TYPE_TB
- en: '| `void onAllDataRead()` | This method is called when all the data of `ServletRequest`
    has been read |'
  prefs: []
  type: TYPE_TB
- en: '| `void onError(Throwable t)` | This method is called when an error or exception
    occurs during request processing |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteListener` | `void onWritePossible()` | This method is called whenever
    it is possible to write data without blocking |'
  prefs: []
  type: TYPE_TB
- en: '| `void onError(Throwable t)` | This method is called when an error or exception
    occurs during response processing |'
  prefs: []
  type: TYPE_TB
- en: 'The table that follows describes the new APIs for the non blocking I/O API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletInputStream` | `void setReadListener(Readlistener ln)` | This associates
    `Readlistener` with the current `ServletInputStream` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean isFinished()` | This returns `true` when all the data of `ServletInputStream`
    has been read |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean isReady()` | This returns `true` if data can be read without blocking
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletOutputStream` | `boolean isReady()` | This returns `true` if data
    can be written successfully to `ServletOutputStream` |'
  prefs: []
  type: TYPE_TB
- en: '| `void setWriteListener(WriteListener ln)` | This associates `WriteListener`
    with the current `ServletOutputStream` |'
  prefs: []
  type: TYPE_TB
- en: By using the non blocking I/O API, the `doGet(HttpServletRequest request, HttpServletResponse
    response)` method of the `TraditionnalIOProcessing` class shown earlier may be
    transformed to the `doGet(HttpServletRequest request, HttpServletResponse response)`
    method represented in the following code. As you can see, the data reception has
    been delegated to a listener (`ReadListenerImpl`), which will be notified whenever
    a new package is available. This prevents the server from being blocked while
    waiting for new packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `ReadListenerImpl` used in the preceding code snippet
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Protocol upgrade processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protocol upgrade processing is a mechanism that was introduced in HTTP 1.1
    to provide the possibility of switching from HTTP protocol to another (one that
    is completely different). A concrete example of protocol upgrade processing usage
    is the migration from HTTP protocol to the WebSocket protocol where the client
    begins by sending a request for WebSocket to the server. The client request is
    sent via HTTP and if the server accepts the connection request, it will still
    respond through HTTP. From this moment, every other communication will be through
    the established WebSocket channel. Support for this mechanism in the Servlet 3.1
    Specification was done by adding the `upgrade` method to `HttpServletRequest`
    and two new interfaces: `javax.servlet.http.HttpUpgradeHandler` and `javax.servlet.http.WebConnection`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a description of protocol upgrade methods, interfaces,
    and classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class/Interface** | **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpServletRequest` | `HttpUpgradeHandler upgrade(Class handler)` | This
    method starts the upgrade processing, instantiates, and returns the handler class
    that implements the `HttpUpgradeHandler` interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpUpgradeHandler` | `void init(WebConnection wc)` | This method is called
    when the upgrade operation is accepted by the Servlet. It takes a `WebConnection`
    object to allow the protocol handler have access to the input/output streams.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void destroy()` | This method is called when the client disconnects. |'
  prefs: []
  type: TYPE_TB
- en: '| `WebConnection` | `ServletInputStream getInputStream()` | This method gives
    access to the input stream of the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `ServletOutputStream getOutputStream()` | This method gives access to the
    output stream of the connection. |'
  prefs: []
  type: TYPE_TB
- en: The two blocks of code that follow show us how the new method and new interfaces
    can be used in order to accept a given client protocol upgrade request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an upgrading request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of upgrade handler class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Expression Language 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Expression Language 3.0 Specification was developed under JSR 341\. This
    section gives you only an overview of improvement in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is Expression Language?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Expression Language** (**EL**) is a language used to access and manipulate
    data in your JSP or JSF web pages. It provides a simple way to:'
  prefs: []
  type: TYPE_NORMAL
- en: Read/write data from/to JavaBean component properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke static and public methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform arithmetic, relational, logical, and conditional operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An EL expression looks like `${expr}` or `#{expr}`. The former syntax is often
    used for immediate evaluation while the latter is used for deferred evaluation.
    The following code demonstrates how to access a JSF bean property from a JSF page
    and how to perform an operation between two integers using EL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The latest improvements of EL 3.0 in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EL was first designed for **JSP Standard Tag Library** (**JSTL**), before being
    associated with the JSP Specification and then to the JSF Specification. Since
    both specifications had different needs at the onset, each specification used
    a variant of the EL. The advent of JSP 2.1 EL led to unification of the EL used
    in JSP and JSF pages; this gave birth to a dedicated specification document for
    EL, although EL was always dependent on the same JSR as JSP. Version 3.0 is the
    first to be developed in a separate JSR: JSR 341\. This new specification comes
    with many changes; the most important are: an API for standalone environments,
    lambda expressions, collection object support, string concatenation operator,
    assignment operator, semi-colon operator, and static fields and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: API for standalone environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since EL 3.0, it is now possible to handle EL in a standalone environment. For
    this purpose, it provides the `ELProcessor` class, which allows direct evaluation
    of EL expressions and makes easier the definition of functions, variables, and
    local repository beans. The following code demonstrates how the `ELProcessor`
    class can be used in standalone environment. The present case is the content of
    a Servlet, but you can do the same in a Java SE application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Always in the context of the API for standalone environments, EL 3.0 has added
    the `ELManager` class to provide lower-level APIs that enable the management of
    the EL parsing and evaluation environment. With this class, you can import classes
    or add your own resolver to `ELProcessor`**.**
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lambda expression is an anonymous function that consists of one or more parameters
    in brackets (if there are several), the lambda operator (`->`), and the body of
    the lambda expression. The expression: `x-> x * x`, is a lambda expression used
    to determine the square of a number. Basically, lambda expressions save you from
    having to create a whole class for a single method or to declare a method for
    a very simple operation that will be used once. So, they can help to write more
    readable and maintainable code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression can take many forms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may involve a number of parameters and can be invoked immediately. The expression:
    `((x,y,z)->x+y*z)(3,2,4)`, returns 11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be associated with an identifier and invoked later. The expression:
    `diff = (x,y)-> x-y; diff(10,3)`, returns 7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be passed as an argument to a method or nested within another lambda
    expression. The expression: `diff=(x,y)->(x-y);diff(10,[ 2,6,4,5].stream().filter(s->s
    < 4).max().get())`, returns 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection object support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The support of collection objects in the EL 3.0 Specification is done in two
    ways: the construction of collection objects and implementation of operations
    that will be used to manipulate them.'
  prefs: []
  type: TYPE_NORMAL
- en: Collection object construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Concerning the creation of a collection, EL allow us to create objects of type
    `java.lang.util.Set`, `java.lang.util.List`, and `java.lang.util.Map` dynamically
    by using an expression or literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different types of object construction are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set object construction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The construction of `Set` collection type results in an instance of `Set <Object>`
    and it is done according to the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `elements` has the form `(expression (',' expression)* )?`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example: `{1, 2, 3, 4, 5},` `{''one'',''two'',''three'',''four''},` `{1.3,
    2, 3,{4.9, 5.1}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'List object construction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The construction of `List` collection type results in an instance of `List<Object>`
    and it is done according to the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `elements` has the form `(expression (',' expression)* )?`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example: `[one, ''two'', [''three'', ''four''],five], [1, 2, 3, [4,5]]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map object construction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The construction of `Map` object type results in an instance of `Map<Object>`
    and it is done according to the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `MapElements` has the form `(MapElement (',' MapElement)* )?` and `MapElement`
    the form `expression ':' expression`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example: `{1:''one'', 2:''two'', 3:''three'', 4:''four''}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Collection operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second aspect of the collection support in EL 3.0 concerns collection operations.
    For this aspect, the specification only defines the syntax and behavior of a standard
    set of collection operations to be implemented with `ELResolvers`. It has the
    advantage of allowing developers to modify the default behavior by providing their
    own `ELResolvers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution of a collection operation is done through a stream pipeline which
    is made up of:'
  prefs: []
  type: TYPE_NORMAL
- en: A `stream` object that represents the source of a pipeline; it is obtained from
    the `stream()` method of the collection or array. In the case of a map, the collection
    view of the map can be use as the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more intermediate `stream` methods that return a `stream` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terminal operation, which is a `stream` method that returns nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following codedemonstrates the construction of a pipeline by giving an
    example of collection operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: String concatenation operator (`+=`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `+=` operator returns the concatenation of operands located on either side
    of the operator. For example, `1 += 2` returns 12 while `1 + 2` returns 3\. To
    welcome a new connected student to our website we only need to locate the following
    expression somewhere in a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#{''Welcome'' += studentBean.lastName}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operator (`=`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `A = B` expression assigns the value of `B` to `A`. To make this possible,
    `A` must be a writable property. The assignment operator (`=`) can be used to
    change the value of a property. For example, the `#{studentBean.identity = '96312547'`}
    expression assigns the value `96312547` to property `studentBean.identity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assignment operator returns a value and it is right-associative. The expression
    `a = b = 8 * 3` is the same as `a = (b = 8 * 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Semi-colon operator (`;`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The semi-colon operator can be used like the comma operator in C or C++. When
    two expressions exp1 and exp2 are separated by a semi-colon operator, the first
    expression is evaluated before the second, and it is the result of the second
    expression that is returned. The first expression may be an intermediate operation,
    such as incrementation, whose result will be used in the last expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression: `a = 6+1; a*2` returns 14.'
  prefs: []
  type: TYPE_NORMAL
- en: Static fields and methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With EL 3.0, it is now possible to directly access static fields and methods
    of a Java class by using the syntax `MyClass.field` or `MyClass.method`, where
    `MyClass` is the name of the class that contains the static variable or method.
    The code that follows demonstrates how to access the `MIN_VALUE` field of the
    `Integer` class and how to parse the String `''2''` to `int` by using the static
    `parseInt` method of the `Integer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: JavaServer Faces 2.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaServer Faces 2.2 Specification was developed under JSR 344\. This section
    gives you only an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is JavaServer Faces?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaServer Faces** (**JSF**) is a component-based architecture with a set
    of standard UI widgets and helper tags (`convertDateTime`, `inputText`, `buttons`,
    `table`, `converter`, `inputFile`, `inputSecret`, `selectOneRadio`). It was released
    after the Servlet and JSP Specification in order to facilitate the development
    and maintenance of component-oriented web applications. In this light, it offers
    developers the ability to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create web applications that meet the design pattern of MVC(Model-View-Controller).
    This design pattern allows a clear separation of the presentation layer from the
    other layers and facilitates the maintenance of the whole application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create different types of components (widgets, validators, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse and customize multiple components provided by the specification according
    to need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind Java components to different views and manipulate them easily by using
    **Expression Language** (**EL**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate web pages in different formats (HTML, WML, and so on) through render
    kits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercept the various events that occur on a form and manage the lifecycle of
    Java components according to the request scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this possible, the lifecycle of JSF applications includes six phases
    (restore view phase, apply request values, process validations, update model values,
    invoke application, and render response), each of which manages a specific aspect
    while processing the form instead of just managing requests/responses, as is the
    case with Servlets.
  prefs: []
  type: TYPE_NORMAL
- en: An identification page with JSF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code shows an example of a JSF page to enter personal information,
    such as first name and nationality. It also contains components for selection
    lists and checkboxes. As you can see, it is not necessary to be a geek to make
    a good job. To manage the navigation after validation of parameters, we use the
    `action` attribute of the `commandButton` component that expects a return value
    from the method `onclickValidateListener`. The web page that follows displays
    relative to the value returned and is defined in the `faces-config.xml` file of
    the web application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The latest improvements of JSF 2.2 in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of the great improvements provided in HTML5, a priority of JSF 2.2 was
    to incorporate new features of the language; but this is not the only big change.
    Besides the integration of HTML5, the JSF 2.2 Specification comes with Resource
    Library Contracts, which announce multitemplate features, Faces Flow, and Stateless
    Views.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5-friendly markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw earlier, JSF is a component-based architecture. This justifies the
    fact that the creation of relatively complex user interface features is done by
    the development of JavaServer Faces components. These components are processed
    on the server side before delivering the right content to the browser. Although
    this approach saves the developer from the complexity of HTML, scripts, and other
    resources involved in each component, you have to know that the creation of a
    component is not always easy and the generated code is not always the lightest
    or most optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advent of HTML5 has greatly simplified the development of web applications
    with the introduction of new features, new elements, and new attributes. To avoid
    JSF component developers from reinventing the wheel, JSF 2.2 has integrated support
    of markup through two major concepts: pass-through attributes and pass-through
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Pass-through attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During the generation of web pages that will be sent to the browser, the attributes
    for each JSF component are interpreted and validated by the `UIComponent` or Renderer.
    Unlike adding HTML5 attributes into all JSF components so that they can be validated
    by the `UIComponent` or Renderer, pass-through attributes give developers the
    ability to list a set of attributes that will be passed straight through to the
    browser without being interpreted by the `UIComponent` or Renderer. This can be
    done with three different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: By introducing the namespace ``; this will be used to prefix all of the component
    attributes that must be copied without interpretation into the web page intended
    for the browser (see `Pass through attributes 1` in the code that follows)``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``By nesting the `<f:passThroughAttribute>` tag within a `UIComponent` tag
    for a single attribute (see `Pass through attributes 2` in the following code)``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15] <!-- namespace --> <html  ...       >  <h:form>     <!-- Pass through
    attributes 1 -->     <h:inputText pta:type="image" pta:src="img/img_submit.gif"                   value="image1"
    pta:width="58" pta:height="58" />      <!-- Pass through attributes 2 -->     <h:inputText
    value="image2" >         <f:passThroughAttribute name="type" value="image" />         <f:passThroughAttribute
    name="src" value="img_submit.gif" />         <f:passThroughAttribute name="width"
    value="68" />         <f:passThroughAttribute name="height" value="68" />     </h:inputText>      <!--
    Pass through attributes 3 -->     <h:inputText value="image3" >         <f:passThroughAttributes            value="#{html5Bean.mapOfParameters}"
    />                     </h:inputText> </h:form> [PRE16]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pass-through elements`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`In contrast to pass-through attributes that allow you to pass HTML attributes
    to the browser without interpretation, pass-through elements allow you to use
    the HTML tag as a JSF component. This gives you the opportunity to enrich the
    HTML tag with JSF features and take advantage of the JSF component lifecycle.
    To make this possible, the framework will establish a correspondence between the
    HTML markup specified by the developer, which is rendered to the browser, and
    an equivalent JSF component for server-side processing.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``To use pass-through elements in a given HTML tag, you must prefix at least
    one of its attributes with the short name assigned to the `http://xmlns.jcp.org/jsf`
    namespace.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`The following code snippet shows how to use pass-through elements:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Resource Library Contracts`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`The Resource Library Contracts provide a JSF mechanism for applying templates
    to different parts of your web application. This feature announces a major change:
    the ability to download a look and feel (theme) and apply it to your account or
    website by using a button or management console, as in Joomla!.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``For now, the Resource Library Contracts enable you to group resources (template
    files, JavaScript files, style sheets, and images) of your various templates in
    the `contracts` folder of your web application. To improve the maintainability
    of your application, resources for each template can be grouped into a subfolder
    called `contract`. The following code demonstrates a web application with three
    templates stored in three different `contracts`: `template1`, `template2`, and
    `template3`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '``In addition to the deployment in the `contracts` folder, your templates can
    be packaged in a JAR file; in this case, they must be stored in the `META-INF`/`contracts`
    folder of the JAR which will be deployed in the `WEB-INF`/`lib` folder of your
    application.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``Once defined, templates must be referenced within an application''s `faces-config.xml`
    file, with the `resource-library-contracts` element. The configurations of the
    following request mean that `template1` is applied to pages whose URLs respect
    the pattern `/templatepages/*`. And for other pages, the `template2` will be applied.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '``The following code snippet shows us what the header of `template1` looks
    like. It contains only a picture to be displayed in the header. You can add text,
    style, and color if you want.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`The following code demonstrates how a template can be used in a web page:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Faces Flow`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Faces Flow is used to define and perform processes that are split over several
    forms. If we take, for example, the case of online registration, the registration
    form can be split over several pages, each representing a step. In our case we
    have: the acceptance conditions, entering identification information, contact
    information, medical information, school information, and finally the validation.
    To implement this type of application with previous versions of JSF, it was necessary
    to use beans with session scope and declare hard links between pages that formed
    the flow. This reduces the usability of the flow in another application and does
    not give the possibility to open the same flow in many windows.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``A flow is made up of an entry called the starting point, an exit point called
    a return node and zero, or many other nodes. A node can be a JSF page (`ViewNode`),
    a navigation decision (`SwitchNode`), an application logic invocation (`MethodCallNode`),
    a call to another flow (`FlowCallNode`), or a return to the calling flow (`ReturnNode`).``'
  prefs: []
  type: TYPE_NORMAL
- en: '`A flow can be configured either with an XML configuration file or programmatically.
    It can be packaged in a JAR file or folder. The following example demonstrates
    how to implement an online preregistration website with Faces Flow (our flow is
    configured with an XML configuration file; for program configuration, please consult
    the Java EE 7 tutorial.)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`In the case of a flow packaged in a folder, the following conventions are
    followed by default:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`The package folder of the flow has the same name as the flow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`The starting node of the flow has the same name as the flow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`All pages of the flow are assumed to be in the same folder except the exit
    points`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` For a flow that is configured with an XML configuration file, the configuration
    file is a `faces-config` whose name is `<name_of_flow>-flow.xml` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``According to the rule we have just presented, the web application that the
    tree is showing contains a flow named `inscriptionFlow` with six views. This flow
    is configured in `inscriptionFlow-flow.xml` and its starting node is `inscriptionFlow.xhtml`.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '``In the configuration file, we must define the ID of the flow and the ID of
    exit points. The following code shows the contents of the file `inscriptionFlow-flow.xml`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '``Navigation between different views can be done through the `action` attribute
    of the tag that will actuate the display of the next view. In this attribute you
    put the name of the page to which you want to go after the current page. The following
    code shows the contents of the `inscriptionFlow1` view. This view corresponds
    to the input form for personal information; it contains a field for entering the
    name, a button to go to the next view (`inscriptionFlow2`), and a button to return
    to the previous view (`inscriptionFlow`).``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '``To end a flow, just pass to the `action` attribute of the dedicated tag for
    this action the ID of the exit point defined in the configuration file (`inscriptionFlowExit`).
    And to save data between different views, you must use a Flow-Scoped Managed Bean.
    The following code shows the skeleton of the `inscriptionFlowBean` managed bean
    that we use in our inscription flow:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Stateless views`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '``JSF 2.2 did not only add new widgets, it also improved memory usage. Prior
    to Version 2.0 of the specification, the whole component tree was saved and restored
    whenever there was any change in the view. This degraded system performance and
    stuffed the memory. With Version 2.0, the specification has introduced the partial
    state saving mechanism. This mechanism consists of saving only the state that
    has changed after the creation of the component tree and reduces the amount of
    data to be saved. In the same light, JSF 2.2 offers us the possibility to define
    stateless views. As the name suggests, no data about the `UIComponent` state of
    the view''s components will be saved.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``To transform a simple view into a stateless view, you just need to specify
    `true` as the value of the transient attribute of the `f:view` tag (see the following
    code).``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`# Summary    In this chapter, we discussed the specifications related to data
    presentation that have been improved in Java EE 7\. These are: Servlet, Expression
    Language, and the JSF Specification. Each presentation was followed by an analysis
    of the various improvements made and a small example to show how these new features
    can be implemented. In the next chapter, we will talk about Java APIs used to
    communicate with databases, which will lead us to another chapter that focuses
    on putting together all of the APIs that we have seen.`'
  prefs: []
  type: TYPE_NORMAL
