- en: Chapter 3. The Presentation Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 表示层
- en: 'In this chapter, we will review the improvements in the Java EE platform for
    the presentation layer. In concrete terms, we are going to talk about the following
    specifications:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾Java EE平台在表示层方面的改进。具体来说，我们将讨论以下规范：
- en: Servlet 3.1
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet 3.1
- en: Expression Language 3.0
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语言 3.0
- en: JavaServer Faces 2.2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaServer Faces 2.2
- en: Servlet 3.1
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet 3.1
- en: The Servlet 3.1 Specification was developed under JSR 340\. This section gives
    you only an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 3.1规范是在JSR 340下开发的。本节仅为您概述API的改进。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr340/index.html)下载。
- en: What is a Servlet?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Servlet？
- en: There was a time in computer science when we could not create dynamic web pages.
    At that time, users had access only to static web pages, such as in a newspaper.
    Among the many proposed solutions, the first Java solution was the **Servlet**,
    a revolutionary technology used to extend the capabilities of servers based on
    the request-response programming model. It enabled web servers to handle http
    requests and dynamically generate web pages according to user parameters. Since
    then, technologies have advanced a lot in order to facilitate the development
    of web applications. However, the Servlet technology remains the most widely used
    Java solution for processing of HTTP requests/responses in the background.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的历史上，曾经有一段时间我们无法创建动态网页。那时，用户只能访问静态网页，例如报纸上的网页。在众多解决方案中，第一个Java解决方案是**Servlet**，这是一种革命性的技术，用于扩展基于请求-响应编程模型的Web服务器功能。它使Web服务器能够处理HTTP请求并根据用户参数动态生成网页。从那时起，技术已经取得了很大的进步，以促进Web应用程序的开发。然而，Servlet技术仍然是处理HTTP请求/响应的Java解决方案中最广泛使用的。
- en: That said, at the base of almost all Java frameworks dedicated to the HTTP protocol
    (JSF, Struts, Spring MVC, BIRT, web services solutions), you will find at least
    one Servlet (that is, you have `FacesServlet` in JSF, `ViewerServlet`, and the
    `BirtEngineServlet` for BIRT). You understand why this technology should attract
    our attention, because a change in the Servlet specification will have repercussions
    on a multitude of tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在几乎所有针对HTTP协议的Java框架（如JSF、Struts、Spring MVC、BIRT、Web服务解决方案）的底层，你至少会找到一个Servlet（在JSF中是`FacesServlet`，在BIRT中是`ViewerServlet`和`BirtEngineServlet`）。你明白为什么这项技术应该引起我们的注意，因为Servlet规范的任何变化都会对众多工具产生影响。
- en: A login page with a Servlet
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有Servlet的登录页面
- en: 'Concretely, a Servlet is a Java class that implements the Servlet interface
    directly or indirectly. The following code represents an example of a Servlet
    that returns a connection interface to the user and redirects it to another interface
    after validating its input:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Servlet是一个直接或间接实现Servlet接口的Java类。以下代码代表了一个Servlet的示例，该Servlet向用户返回一个连接接口，并在验证其输入后将其重定向到另一个接口：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, our `ConnexionServlet` class extends `javax.servlet.http.`
    `HttpServlet`; this is an abstract class that implements the `Servlet` interface.
    It defines the lifecycle methods (`doGet` and `doPost`) of the `Servlet` object
    that allows us to handle HTTP service requests and send back a response. To access
    the page generated by this Servlet, you must enter an URL similar to this one:
    `http://localhost:8080/chapter03PresentationLayer/connexionServlet`. Here, `connexionServlet`
    is the name given in the `@WebServlet` annotation. On this page, you will have
    the **Sign it** button displayed by using the following instruction`:`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的`ConnexionServlet`类扩展了`javax.servlet.http.` `HttpServlet`；这是一个实现了`Servlet`接口的抽象类。它定义了`Servlet`对象的生命周期方法（`doGet`和`doPost`），这使我们能够处理HTTP服务请求并返回响应。要访问由这个Servlet生成的页面，你必须输入一个类似于以下的URL：`http://localhost:8080/chapter03PresentationLayer/connexionServlet`。在这里，`connexionServlet`是在`@WebServlet`注解中给出的名称。在这个页面上，你会看到使用以下指令显示的**登录**按钮：`
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A click on this button generates an HTTP request that will cause execution
    of the `processRequest(HttpServletRequest request, HttpServletResponse response)`
    method. Based on the results of the `connexion` parameters validation, you will
    be redirected to the error page or home page. In the case of a redirect to the
    home page, we will add to the URL a parameter containing the name of the user
    in order to adapt the greeting. The URL of the homepage is the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮会生成一个HTTP请求，该请求将执行`processRequest(HttpServletRequest request, HttpServletResponse
    response)`方法。根据`connexion`参数验证的结果，您将被重定向到错误页面或主页。在重定向到主页的情况下，我们将在URL中添加一个包含用户名的参数，以便适应问候语。主页的URL如下：
- en: '`http://localhost:8080/chapter03PresentationLayer/WelcomeServlet?name=arnoldp`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/chapter03PresentationLayer/WelcomeServlet?name=arnoldp`'
- en: 'To access the `name` parameter, we execute the instruction: `out.println("<h1>Welcome
    Mr " + request.getParameter("name")+ "</h1>");` in the `WelcomeServlet` Servlet.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WelcomeServlet` Servlet中，为了访问`name`参数，我们执行以下指令：`out.println("<h1>Welcome Mr
    " + request.getParameter("name")+ "</h1>");`。
- en: Latest improvements of Servlet 3.1 in action
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Servlet 3.1的最新改进实例
- en: 'Following Servlet 3.0, which was focused on ease of development, pluggability,
    asynchronous processing, and security enhancements, Servlet 3.1 has brought a
    number of clarifications to features of the previous version and some changes;
    the main ones are: non blocking I/O API and protocol upgrade processing.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着关注于开发便捷性、可插拔性、异步处理和安全增强的Servlet 3.0的推出，Servlet 3.1对上一版本的功能进行了一些澄清和修改；主要的变化包括：非阻塞I/O
    API和协议升级处理。
- en: Non blocking I/O API
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非阻塞I/O API
- en: The non blocking I/O API piggybacks on the asynchronous request processing and
    the upgrade processing to improve the scalability of the Web Container. Indeed,
    the introduction of asynchronous processing in Servlet 3.0 has made it possible
    to reduce waiting time between requests by enabling the thread responsible for
    processing the client's requests and delegating to other threads the execution
    of heavy processes in order to be ready to accept a new request. But, because
    of the traditional way to collect data input/output with a `while` loop (see the
    following code), the main thread responsible for request processing can be blocked
    due to pending data. For example, when you send a large amount of data to a very
    powerful server across a network, the time taken for data collection will be inversely
    proportional to the bandwidth of the network. The smaller the bandwidth, the more
    time the server will take to do the job.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞I/O API依赖于异步请求处理和升级处理来提高Web容器的可伸缩性。实际上，Servlet 3.0中异步处理的引入使得通过启用处理客户端请求的线程并委托其他线程执行重过程，以便准备好接受新的请求，从而减少了请求之间的等待时间。但是，由于传统的使用`while`循环收集数据输入/输出的方式（见以下代码），负责请求处理的主线程可能会因为待处理的数据而被阻塞。例如，当您通过网络向一个非常强大的服务器发送大量数据时，数据收集所需的时间将与网络的带宽成反比。带宽越小，服务器完成工作所需的时间越长。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To solve this problem, two listeners (`ReadListener` and `WriteListener`) have
    been added to the Java EE platform and new APIs were also introduced into `ServletInputStream`
    and `ServletOutputStream`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Java EE平台增加了两个监听器（`ReadListener`和`WriteListener`），并在`ServletInputStream`和`ServletOutputStream`中引入了新的API。
- en: 'The following table describes the new listeners for the non blocking I/O API:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了非阻塞I/O API的新监听器：
- en: '| **Listener** | **Callbacks** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **Listener** | **回调函数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ReadListener` | `void onDataAvailable()` | This method is called whenever
    data is available to read without blocking |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `ReadListener` | `void onDataAvailable()` | 当可以无阻塞地读取数据时调用此方法 |'
- en: '| `void onAllDataRead()` | This method is called when all the data of `ServletRequest`
    has been read |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `void onAllDataRead()` | 当`ServletRequest`的所有数据都被读取时调用此方法 |'
- en: '| `void onError(Throwable t)` | This method is called when an error or exception
    occurs during request processing |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `void onError(Throwable t)` | 当请求处理过程中发生错误或异常时调用此方法 |'
- en: '| `WriteListener` | `void onWritePossible()` | This method is called whenever
    it is possible to write data without blocking |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `WriteListener` | `void onWritePossible()` | 当可以无阻塞地写入数据时调用此方法 |'
- en: '| `void onError(Throwable t)` | This method is called when an error or exception
    occurs during response processing |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `void onError(Throwable t)` | 在响应处理过程中发生错误或异常时调用此方法 |'
- en: 'The table that follows describes the new APIs for the non blocking I/O API:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了非阻塞I/O API的新API：
- en: '| **Class** | **Method** | **Description** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **方法** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ServletInputStream` | `void setReadListener(Readlistener ln)` | This associates
    `Readlistener` with the current `ServletInputStream` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `ServletInputStream` | `void setReadListener(Readlistener ln)` | 此方法将`Readlistener`与当前的`ServletInputStream`关联|'
- en: '| `boolean isFinished()` | This returns `true` when all the data of `ServletInputStream`
    has been read |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isFinished()` | 当`ServletInputStream`的所有数据都已读取时返回`true`|'
- en: '| `boolean isReady()` | This returns `true` if data can be read without blocking
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isReady()` | 如果可以无阻塞地读取数据，则返回`true`|'
- en: '| `ServletOutputStream` | `boolean isReady()` | This returns `true` if data
    can be written successfully to `ServletOutputStream` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `ServletOutputStream` | `boolean isReady()` | 如果可以成功写入`ServletOutputStream`，则返回`true`|'
- en: '| `void setWriteListener(WriteListener ln)` | This associates `WriteListener`
    with the current `ServletOutputStream` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `void setWriteListener(WriteListener ln)` | 此方法将`WriteListener`与当前的`ServletOutputStream`关联|'
- en: By using the non blocking I/O API, the `doGet(HttpServletRequest request, HttpServletResponse
    response)` method of the `TraditionnalIOProcessing` class shown earlier may be
    transformed to the `doGet(HttpServletRequest request, HttpServletResponse response)`
    method represented in the following code. As you can see, the data reception has
    been delegated to a listener (`ReadListenerImpl`), which will be notified whenever
    a new package is available. This prevents the server from being blocked while
    waiting for new packages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用非阻塞I/O API，前面显示的`TraditionnalIOProcessing`类的`doGet(HttpServletRequest request,
    HttpServletResponse response)`方法可以转换为以下代码表示的`doGet(HttpServletRequest request,
    HttpServletResponse response)`方法。如您所见，数据接收已被委托给一个监听器（`ReadListenerImpl`），每当有新数据包可用时，它都会被通知。这防止了服务器在等待新数据包时被阻塞。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The implementation of `ReadListenerImpl` used in the preceding code snippet
    is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段中使用的`ReadListenerImpl`实现如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Protocol upgrade processing
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议升级处理
- en: 'Protocol upgrade processing is a mechanism that was introduced in HTTP 1.1
    to provide the possibility of switching from HTTP protocol to another (one that
    is completely different). A concrete example of protocol upgrade processing usage
    is the migration from HTTP protocol to the WebSocket protocol where the client
    begins by sending a request for WebSocket to the server. The client request is
    sent via HTTP and if the server accepts the connection request, it will still
    respond through HTTP. From this moment, every other communication will be through
    the established WebSocket channel. Support for this mechanism in the Servlet 3.1
    Specification was done by adding the `upgrade` method to `HttpServletRequest`
    and two new interfaces: `javax.servlet.http.HttpUpgradeHandler` and `javax.servlet.http.WebConnection`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 协议升级处理是HTTP 1.1中引入的一种机制，旨在提供从HTTP协议切换到另一个（完全不同的）协议的可能性。协议升级处理使用的具体示例是从HTTP协议迁移到WebSocket协议，客户端首先向服务器发送WebSocket请求。客户端请求通过HTTP发送，如果服务器接受连接请求，它将通过HTTP进行响应。从这一刻起，所有其他通信将通过建立的WebSocket通道进行。Servlet
    3.1规范中对该机制的支持是通过向`HttpServletRequest`添加`upgrade`方法以及两个新接口：`javax.servlet.http.HttpUpgradeHandler`和`javax.servlet.http.WebConnection`来实现的。
- en: 'The following table shows a description of protocol upgrade methods, interfaces,
    and classes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了协议升级方法、接口和类的描述：
- en: '| **Class/Interface** | **Method** | **Description** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **类/接口** | **方法** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `HttpServletRequest` | `HttpUpgradeHandler upgrade(Class handler)` | This
    method starts the upgrade processing, instantiates, and returns the handler class
    that implements the `HttpUpgradeHandler` interface. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `HttpServletRequest` | `HttpUpgradeHandler upgrade(Class handler)` | 此方法启动升级处理，实例化并返回实现`HttpUpgradeHandler`接口的处理程序类。|'
- en: '| `HttpUpgradeHandler` | `void init(WebConnection wc)` | This method is called
    when the upgrade operation is accepted by the Servlet. It takes a `WebConnection`
    object to allow the protocol handler have access to the input/output streams.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `HttpUpgradeHandler` | `void init(WebConnection wc)` | 当Servlet接受升级操作时调用此方法。它接受一个`WebConnection`对象，以便协议处理程序可以访问输入/输出流。|'
- en: '| `void destroy()` | This method is called when the client disconnects. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `void destroy()` | 当客户端断开连接时调用此方法。|'
- en: '| `WebConnection` | `ServletInputStream getInputStream()` | This method gives
    access to the input stream of the connection. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `WebConnection` | `ServletInputStream getInputStream()` | 此方法提供对连接输入流的访问。|'
- en: '| `ServletOutputStream getOutputStream()` | This method gives access to the
    output stream of the connection. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `ServletOutputStream getOutputStream()` | 此方法提供了对连接输出流的访问。|'
- en: The two blocks of code that follow show us how the new method and new interfaces
    can be used in order to accept a given client protocol upgrade request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两段代码展示了如何使用新方法和新接口来接受给定的客户端协议升级请求。
- en: 'The following is an example of an upgrading request:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个升级请求的示例：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is an example of upgrade handler class implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个升级处理类实现的示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Expression Language 3.0
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式语言 3.0
- en: The Expression Language 3.0 Specification was developed under JSR 341\. This
    section gives you only an overview of improvement in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式语言 3.0 规范是在 JSR 341 下开发的。本节仅为您提供了 API 改进的概述。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr341/index.html)
    下载。
- en: What is Expression Language?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是表达式语言？
- en: '**Expression Language** (**EL**) is a language used to access and manipulate
    data in your JSP or JSF web pages. It provides a simple way to:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式语言**（**EL**）是一种用于访问和操作 JSP 或 JSF 网页中数据的语言。它提供了一种简单的方法：'
- en: Read/write data from/to JavaBean component properties
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/向 JavaBean 组件属性读写数据
- en: Invoke static and public methods
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用静态和公共方法
- en: Perform arithmetic, relational, logical, and conditional operations
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行算术、关系、逻辑和条件操作
- en: 'An EL expression looks like `${expr}` or `#{expr}`. The former syntax is often
    used for immediate evaluation while the latter is used for deferred evaluation.
    The following code demonstrates how to access a JSF bean property from a JSF page
    and how to perform an operation between two integers using EL expressions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 EL 表达式看起来像 `${expr}` 或 `#{expr}`。前者语法通常用于即时评估，而后者用于延迟评估。以下代码演示了如何从 JSF 页面访问
    JSF 实例属性，以及如何使用 EL 表达式在两个整数之间执行操作：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The latest improvements of EL 3.0 in action
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EL 3.0 的最新改进实例
- en: 'EL was first designed for **JSP Standard Tag Library** (**JSTL**), before being
    associated with the JSP Specification and then to the JSF Specification. Since
    both specifications had different needs at the onset, each specification used
    a variant of the EL. The advent of JSP 2.1 EL led to unification of the EL used
    in JSP and JSF pages; this gave birth to a dedicated specification document for
    EL, although EL was always dependent on the same JSR as JSP. Version 3.0 is the
    first to be developed in a separate JSR: JSR 341\. This new specification comes
    with many changes; the most important are: an API for standalone environments,
    lambda expressions, collection object support, string concatenation operator,
    assignment operator, semi-colon operator, and static fields and methods.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: EL 最初是为 **JSP 标准标签库**（**JSTL**）设计的，后来与 JSP 规范相关联，然后是 JSF 规范。由于这两个规范在开始时有不同的需求，每个规范都使用了
    EL 的一个变体。JSP 2.1 EL 的出现导致了 JSP 和 JSF 页面中使用的 EL 的统一；这催生了一个专门的 EL 规范文档，尽管 EL 总是依赖于与
    JSP 相同的 JSR。3.0 版本是在一个独立的 JSR 下开发的：JSR 341。这个新规范带来了许多变化；其中最重要的是：独立环境的 API、lambda
    表达式、集合对象支持、字符串连接运算符、赋值运算符、分号运算符以及静态字段和方法。
- en: API for standalone environments
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立环境的 API
- en: Since EL 3.0, it is now possible to handle EL in a standalone environment. For
    this purpose, it provides the `ELProcessor` class, which allows direct evaluation
    of EL expressions and makes easier the definition of functions, variables, and
    local repository beans. The following code demonstrates how the `ELProcessor`
    class can be used in standalone environment. The present case is the content of
    a Servlet, but you can do the same in a Java SE application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自 EL 3.0 以来，现在可以在独立环境中处理 EL。为此，它提供了 `ELProcessor` 类，该类允许直接评估 EL 表达式，并简化了函数、变量和本地存储库实体的定义。以下代码演示了如何在独立环境中使用
    `ELProcessor` 类。当前案例是 Servlet 的内容，但您也可以在 Java SE 应用程序中做同样的事情。
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Always in the context of the API for standalone environments, EL 3.0 has added
    the `ELManager` class to provide lower-level APIs that enable the management of
    the EL parsing and evaluation environment. With this class, you can import classes
    or add your own resolver to `ELProcessor`**.**
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在独立环境的 API 上下文中，EL 3.0 添加了 `ELManager` 类来提供低级 API，这些 API 可以用于管理 EL 解析和评估环境。使用这个类，您可以导入类或向
    `ELProcessor`**** 添加自己的解析器。
- en: Lambda expressions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'A lambda expression is an anonymous function that consists of one or more parameters
    in brackets (if there are several), the lambda operator (`->`), and the body of
    the lambda expression. The expression: `x-> x * x`, is a lambda expression used
    to determine the square of a number. Basically, lambda expressions save you from
    having to create a whole class for a single method or to declare a method for
    a very simple operation that will be used once. So, they can help to write more
    readable and maintainable code.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是一个匿名函数，它由括号中的一个或多个参数（如果有多个）、Lambda 操作符（`->`）和 Lambda 表达式的主体组成。表达式：`x->
    x * x` 是一个用于确定数字平方的 Lambda 表达式。基本上，Lambda 表达式可以让你不必为单个方法创建整个类，或者为仅使用一次的非常简单的操作声明方法。因此，它们可以帮助编写更易于阅读和维护的代码。
- en: 'A lambda expression can take many forms, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式可以有多种形式，如下所示：
- en: 'It may involve a number of parameters and can be invoked immediately. The expression:
    `((x,y,z)->x+y*z)(3,2,4)`, returns 11.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能涉及多个参数，并且可以立即调用。表达式：`((x,y,z)->x+y*z)(3,2,4)` 返回 11。
- en: 'It can be associated with an identifier and invoked later. The expression:
    `diff = (x,y)-> x-y; diff(10,3)`, returns 7.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与一个标识符相关联，并在以后调用。表达式：`diff = (x,y)-> x-y; diff(10,3)` 返回 7。
- en: 'It can be passed as an argument to a method or nested within another lambda
    expression. The expression: `diff=(x,y)->(x-y);diff(10,[ 2,6,4,5].stream().filter(s->s
    < 4).max().get())`, returns 8.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为方法的一个参数传递，或者嵌套在另一个 Lambda 表达式中。表达式：`diff=(x,y)->(x-y);diff(10,[ 2,6,4,5].stream().filter(s->s
    < 4).max().get())` 返回 8。
- en: Collection object support
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合对象支持
- en: 'The support of collection objects in the EL 3.0 Specification is done in two
    ways: the construction of collection objects and implementation of operations
    that will be used to manipulate them.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: EL 3.0 规范中对集合对象的支持是通过两种方式实现的：集合对象的构建和实现用于操作它们的操作。
- en: Collection object construction
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合对象构建
- en: Concerning the creation of a collection, EL allow us to create objects of type
    `java.lang.util.Set`, `java.lang.util.List`, and `java.lang.util.Map` dynamically
    by using an expression or literals.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集合的创建，EL 允许我们通过表达式或字面量动态地创建 `java.lang.util.Set`、`java.lang.util.List` 和 `java.lang.util.Map`
    类型的对象。
- en: 'The different types of object construction are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构建的不同类型如下：
- en: 'Set object construction:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set 对象构建：
- en: 'The construction of `Set` collection type results in an instance of `Set <Object>`
    and it is done according to the following syntax:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Set` 集合类型的构建会产生一个 `Set<Object>` 的实例，并且按照以下语法进行：'
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `elements` has the form `(expression (',' expression)* )?`
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`elements` 的形式为 `(expression (',' expression)* )?`
- en: 'For example: `{1, 2, 3, 4, 5},` `{''one'',''two'',''three'',''four''},` `{1.3,
    2, 3,{4.9, 5.1}}`'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`{1, 2, 3, 4, 5},` `{'one','two','three','four'},` `{1.3, 2, 3,{4.9, 5.1}}`
- en: 'List object construction:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: List 对象构建：
- en: 'The construction of `List` collection type results in an instance of `List<Object>`
    and it is done according to the following syntax:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`List` 集合类型的构建会产生一个 `List<Object>` 的实例，并且按照以下语法进行：'
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `elements` has the form `(expression (',' expression)* )?`
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`elements` 的形式为 `(expression (',' expression)* )?`
- en: 'For example: `[one, ''two'', [''three'', ''four''],five], [1, 2, 3, [4,5]]`'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`[one, 'two', ['three', 'four'],five], [1, 2, 3, [4,5]]`
- en: 'Map object construction:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map 对象构建：
- en: 'The construction of `Map` object type results in an instance of `Map<Object>`
    and it is done according to the following syntax:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Map` 对象类型的构建会产生一个 `Map<Object>` 的实例，并且按照以下语法进行：'
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `MapElements` has the form `(MapElement (',' MapElement)* )?` and `MapElement`
    the form `expression ':' expression`
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`MapElements` 的形式为 `(MapElement (',' MapElement)* )?`，而 `MapElement` 的形式为
    `expression ':' expression`
- en: 'For example: `{1:''one'', 2:''two'', 3:''three'', 4:''four''}`'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：`{1:'one', 2:'two', 3:'three', 4:'four'}`
- en: Collection operations
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合操作
- en: The second aspect of the collection support in EL 3.0 concerns collection operations.
    For this aspect, the specification only defines the syntax and behavior of a standard
    set of collection operations to be implemented with `ELResolvers`. It has the
    advantage of allowing developers to modify the default behavior by providing their
    own `ELResolvers`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: EL 3.0中集合支持的第二个方面是集合操作。对于这个方面，规范仅定义了要使用`ELResolvers`实现的集合操作的标准集合的语法和行为。它具有允许开发者通过提供自己的`ELResolvers`来修改默认行为的优点。
- en: 'Execution of a collection operation is done through a stream pipeline which
    is made up of:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作的执行是通过一个由以下组成的流管道完成的：
- en: A `stream` object that represents the source of a pipeline; it is obtained from
    the `stream()` method of the collection or array. In the case of a map, the collection
    view of the map can be use as the source.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示管道源的`stream`对象；它从集合或数组的`stream()`方法中获取。在映射的情况下，映射的集合视图可以用作源。
- en: Zero or more intermediate `stream` methods that return a `stream` object.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个中间`stream`方法，这些方法返回一个`stream`对象。
- en: A terminal operation, which is a `stream` method that returns nothing.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个终端操作，它是一个返回无值的`stream`方法。
- en: 'The following codedemonstrates the construction of a pipeline by giving an
    example of collection operations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了通过给出集合操作的示例来构建管道的结构：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: String concatenation operator (`+=`)
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串连接运算符（`+=`）
- en: 'The `+=` operator returns the concatenation of operands located on either side
    of the operator. For example, `1 += 2` returns 12 while `1 + 2` returns 3\. To
    welcome a new connected student to our website we only need to locate the following
    expression somewhere in a web page:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=`运算符返回运算符两侧操作数的连接。例如，`1 += 2`返回12，而`1 + 2`返回3。为了欢迎一位新连接的学生到我们的网站，我们只需要在网页中找到以下表达式：'
- en: '`#{''Welcome'' += studentBean.lastName}`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`#{''Welcome'' += studentBean.lastName}`.'
- en: Assignment operator (`=`)
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 赋值运算符（`=`）
- en: The `A = B` expression assigns the value of `B` to `A`. To make this possible,
    `A` must be a writable property. The assignment operator (`=`) can be used to
    change the value of a property. For example, the `#{studentBean.identity = '96312547'`}
    expression assigns the value `96312547` to property `studentBean.identity`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`A = B`表达式将`B`的值赋给`A`。为了使这一点成为可能，`A`必须是一个可写属性。赋值运算符（`=`）可以用来更改属性值。例如，`#{studentBean.identity
    = ''96312547''}`表达式将值`96312547`赋给属性`studentBean.identity`。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The assignment operator returns a value and it is right-associative. The expression
    `a = b = 8 * 3` is the same as `a = (b = 8 * 3)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符返回一个值，它是右结合的。表达式`a = b = 8 * 3`与`a = (b = 8 * 3)`相同。
- en: Semi-colon operator (`;`)
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分号运算符（`;`）
- en: The semi-colon operator can be used like the comma operator in C or C++. When
    two expressions exp1 and exp2 are separated by a semi-colon operator, the first
    expression is evaluated before the second, and it is the result of the second
    expression that is returned. The first expression may be an intermediate operation,
    such as incrementation, whose result will be used in the last expression.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 分号运算符可以像C或C++中的逗号运算符一样使用。当两个表达式exp1和exp2由分号运算符分隔时，第一个表达式在第二个表达式之前被评估，并且返回的是第二个表达式的结果。第一个表达式可能是一个中间操作，例如增量，其结果将用于最后一个表达式。
- en: 'The expression: `a = 6+1; a*2` returns 14.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式：`a = 6+1; a*2`返回14。
- en: Static fields and methods
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态字段和方法
- en: 'With EL 3.0, it is now possible to directly access static fields and methods
    of a Java class by using the syntax `MyClass.field` or `MyClass.method`, where
    `MyClass` is the name of the class that contains the static variable or method.
    The code that follows demonstrates how to access the `MIN_VALUE` field of the
    `Integer` class and how to parse the String `''2''` to `int` by using the static
    `parseInt` method of the `Integer` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EL 3.0，现在可以通过使用语法`MyClass.field`或`MyClass.method`直接访问Java类的静态字段和方法，其中`MyClass`是包含静态变量或方法的类的名称。下面的代码演示了如何访问`Integer`类的`MIN_VALUE`字段，以及如何使用`Integer`类的静态`parseInt`方法将字符串`'2'`解析为`int`：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: JavaServer Faces 2.2
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaServer Faces 2.2
- en: The JavaServer Faces 2.2 Specification was developed under JSR 344\. This section
    gives you only an overview of improvements in the API. The complete document specification
    (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JavaServer Faces 2.2规范是在JSR 344下开发的。本节仅为您提供了API改进的概述。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr344/index.html)下载。
- en: What is JavaServer Faces?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是JavaServer Faces？
- en: '**JavaServer Faces** (**JSF**) is a component-based architecture with a set
    of standard UI widgets and helper tags (`convertDateTime`, `inputText`, `buttons`,
    `table`, `converter`, `inputFile`, `inputSecret`, `selectOneRadio`). It was released
    after the Servlet and JSP Specification in order to facilitate the development
    and maintenance of component-oriented web applications. In this light, it offers
    developers the ability to:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaServer Faces**（**JSF**）是一个基于组件的架构，提供了一套标准的UI小部件和辅助标签（`convertDateTime`、`inputText`、`buttons`、`table`、`converter`、`inputFile`、`inputSecret`、`selectOneRadio`）。它是在Servlet和JSP规范之后发布的，旨在促进面向组件的Web应用的开发和维护。在这方面，它为开发者提供了以下能力：'
- en: Create web applications that meet the design pattern of MVC(Model-View-Controller).
    This design pattern allows a clear separation of the presentation layer from the
    other layers and facilitates the maintenance of the whole application.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建符合MVC（模型-视图-控制器）设计模式的Web应用。这种设计模式允许将表示层与其他层清晰分离，并便于整个应用维护。
- en: Create different types of components (widgets, validators, and so on).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不同类型的组件（小部件、验证器等）。
- en: Reuse and customize multiple components provided by the specification according
    to need.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要重用和自定义规范提供的多个组件。
- en: Bind Java components to different views and manipulate them easily by using
    **Expression Language** (**EL**).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**表达式语言**（**EL**）将Java组件绑定到不同的视图，并通过EL轻松地操作它们。
- en: Generate web pages in different formats (HTML, WML, and so on) through render
    kits.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过渲染工具生成不同格式的网页（HTML、WML等）。
- en: Intercept the various events that occur on a form and manage the lifecycle of
    Java components according to the request scope.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截表单上发生的各种事件，并根据请求作用域管理Java组件的生命周期。
- en: To make this possible, the lifecycle of JSF applications includes six phases
    (restore view phase, apply request values, process validations, update model values,
    invoke application, and render response), each of which manages a specific aspect
    while processing the form instead of just managing requests/responses, as is the
    case with Servlets.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，JSF应用的生命周期包括六个阶段（恢复视图阶段、应用请求值、处理验证、更新模型值、调用应用和渲染响应），每个阶段在处理表单时管理一个特定的方面，而不是像Servlet那样仅仅管理请求/响应。
- en: An identification page with JSF
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSF的标识页面
- en: The following code shows an example of a JSF page to enter personal information,
    such as first name and nationality. It also contains components for selection
    lists and checkboxes. As you can see, it is not necessary to be a geek to make
    a good job. To manage the navigation after validation of parameters, we use the
    `action` attribute of the `commandButton` component that expects a return value
    from the method `onclickValidateListener`. The web page that follows displays
    relative to the value returned and is defined in the `faces-config.xml` file of
    the web application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用JSF页面输入个人信息，例如姓名和国籍。它还包含选择列表和复选框等组件。正如您所看到的，制作一个好的工作并不需要您是一个极客。为了在参数验证后管理导航，我们使用`commandButton`组件的`action`属性，该属性期望从`onclickValidateListener`方法返回一个值。接下来的网页将根据返回的值显示，并在Web应用的`faces-config.xml`文件中定义。
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The latest improvements of JSF 2.2 in action
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF 2.2的最新改进在行动中
- en: Because of the great improvements provided in HTML5, a priority of JSF 2.2 was
    to incorporate new features of the language; but this is not the only big change.
    Besides the integration of HTML5, the JSF 2.2 Specification comes with Resource
    Library Contracts, which announce multitemplate features, Faces Flow, and Stateless
    Views.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML5带来的巨大改进，JSF 2.2的一个重点是整合语言的新特性；但这并非唯一的大变化。除了整合HTML5之外，JSF 2.2规范还带来了资源库合同，宣布了多模板功能、Faces
    Flow和无状态视图。
- en: HTML5-friendly markup
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML5友好的标记
- en: As we saw earlier, JSF is a component-based architecture. This justifies the
    fact that the creation of relatively complex user interface features is done by
    the development of JavaServer Faces components. These components are processed
    on the server side before delivering the right content to the browser. Although
    this approach saves the developer from the complexity of HTML, scripts, and other
    resources involved in each component, you have to know that the creation of a
    component is not always easy and the generated code is not always the lightest
    or most optimal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，JSF 是一种基于组件的架构。这解释了为什么相对复杂用户界面特性的创建是通过开发 JavaServer Faces 组件来完成的。这些组件在将正确的内容发送到浏览器之前，在服务器端进行处理。尽管这种方法使开发者免于处理每个组件中涉及的
    HTML、脚本和其他资源的复杂性，但要知道，组件的创建并不总是容易的，生成的代码也不总是最轻量或最优化。
- en: 'The advent of HTML5 has greatly simplified the development of web applications
    with the introduction of new features, new elements, and new attributes. To avoid
    JSF component developers from reinventing the wheel, JSF 2.2 has integrated support
    of markup through two major concepts: pass-through attributes and pass-through
    elements.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 的出现通过引入新特性、新元素和新属性，极大地简化了 Web 应用程序的开发。为了避免 JSF 组件开发者重复造轮子，JSF 2.2 通过两个主要概念集成了对标记的支持：透传属性和透传元素。
- en: Pass-through attributes
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 透传属性
- en: 'During the generation of web pages that will be sent to the browser, the attributes
    for each JSF component are interpreted and validated by the `UIComponent` or Renderer.
    Unlike adding HTML5 attributes into all JSF components so that they can be validated
    by the `UIComponent` or Renderer, pass-through attributes give developers the
    ability to list a set of attributes that will be passed straight through to the
    browser without being interpreted by the `UIComponent` or Renderer. This can be
    done with three different approaches:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成将发送到浏览器的网页过程中，每个 JSF 组件的属性由 `UIComponent` 或 Renderer 进行解释和验证。与将 HTML5 属性添加到所有
    JSF 组件中以便它们可以被 `UIComponent` 或 Renderer 验证不同，透传属性使开发者能够列出将直接传递到浏览器而不会被 `UIComponent`
    或 Renderer 解释的一组属性。这可以通过三种不同的方法实现：
- en: By introducing the namespace ``; this will be used to prefix all of the component
    attributes that must be copied without interpretation into the web page intended
    for the browser (see `Pass through attributes 1` in the code that follows)``
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引入命名空间 ``；这将用于作为前缀，将所有必须无解释复制到浏览器网页中的组件属性（参见以下代码中的 `Pass through attributes
    1`）``
- en: '``By nesting the `<f:passThroughAttribute>` tag within a `UIComponent` tag
    for a single attribute (see `Pass through attributes 2` in the following code)``'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``通过在 `UIComponent` 标签内嵌套 `<f:passThroughAttribute>` 标签来为单个属性（参见以下代码中的 `Pass
    through attributes 2`）``'
- en: '[PRE15] <!-- namespace --> <html  ...       >  <h:form>     <!-- Pass through
    attributes 1 -->     <h:inputText pta:type="image" pta:src="img/img_submit.gif"                   value="image1"
    pta:width="58" pta:height="58" />      <!-- Pass through attributes 2 -->     <h:inputText
    value="image2" >         <f:passThroughAttribute name="type" value="image" />         <f:passThroughAttribute
    name="src" value="img_submit.gif" />         <f:passThroughAttribute name="width"
    value="68" />         <f:passThroughAttribute name="height" value="68" />     </h:inputText>      <!--
    Pass through attributes 3 -->     <h:inputText value="image3" >         <f:passThroughAttributes            value="#{html5Bean.mapOfParameters}"
    />                     </h:inputText> </h:form> [PRE16]`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PRE15] <!-- 命名空间 --> <html  ...       >  <h:form>     <!-- 透传属性 1 -->     <h:inputText
    pta:type="image" pta:src="img/img_submit.gif"                   value="image1"
    pta:width="58" pta:height="58" />      <!-- 透传属性 2 -->     <h:inputText value="image2"
    >         <f:passThroughAttribute name="type" value="image" />         <f:passThroughAttribute
    name="src" value="img_submit.gif" />         <f:passThroughAttribute name="width"
    value="68" />         <f:passThroughAttribute name="height" value="68" />     </h:inputText>      <!--
    透传属性 3 -->     <h:inputText value="image3" >         <f:passThroughAttributes            value="#{html5Bean.mapOfParameters}"
    />                     </h:inputText> </h:form> [PRE16]`'
- en: '`Pass-through elements`'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`透传元素`'
- en: '`In contrast to pass-through attributes that allow you to pass HTML attributes
    to the browser without interpretation, pass-through elements allow you to use
    the HTML tag as a JSF component. This gives you the opportunity to enrich the
    HTML tag with JSF features and take advantage of the JSF component lifecycle.
    To make this possible, the framework will establish a correspondence between the
    HTML markup specified by the developer, which is rendered to the browser, and
    an equivalent JSF component for server-side processing.`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`与允许你将HTML属性传递给浏览器而不进行解释的透传属性不同，透传元素允许你将HTML标签用作JSF组件。这为你提供了丰富HTML标签以包含JSF功能和利用JSF组件生命周期的机会。为了实现这一点，框架将在开发者为浏览器渲染的HTML标记和用于服务器端处理的等效JSF组件之间建立对应关系。`'
- en: '``To use pass-through elements in a given HTML tag, you must prefix at least
    one of its attributes with the short name assigned to the `http://xmlns.jcp.org/jsf`
    namespace.``'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '``要在给定的HTML标签中使用透传元素，你必须至少将其中一个属性的前缀设置为分配给`http://xmlns.jcp.org/jsf`命名空间的短名称。``'
- en: '`The following code snippet shows how to use pass-through elements:`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`以下代码片段显示了如何使用透传元素：`'
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Resource Library Contracts`'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`资源库合约`'
- en: '`The Resource Library Contracts provide a JSF mechanism for applying templates
    to different parts of your web application. This feature announces a major change:
    the ability to download a look and feel (theme) and apply it to your account or
    website by using a button or management console, as in Joomla!.`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`资源库合约提供了JSF机制，将模板应用于Web应用程序的不同部分。这个特性宣布了一个重大变化：能够通过按钮或管理控制台下载外观和感觉（主题），并将其应用于你的账户或网站，就像Joomla!一样。`'
- en: '``For now, the Resource Library Contracts enable you to group resources (template
    files, JavaScript files, style sheets, and images) of your various templates in
    the `contracts` folder of your web application. To improve the maintainability
    of your application, resources for each template can be grouped into a subfolder
    called `contract`. The following code demonstrates a web application with three
    templates stored in three different `contracts`: `template1`, `template2`, and
    `template3`:``'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '``目前，资源库合约允许你在你的Web应用程序的`contracts`文件夹中分组你的各种模板的资源（模板文件、JavaScript文件、样式表和图像）。为了提高应用程序的可维护性，每个模板的资源可以分组到一个名为`contract`的子文件夹中。以下代码演示了一个包含三个模板的Web应用程序，这些模板存储在三个不同的`contracts`中：`template1`、`template2`和`template3`。``'
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '``In addition to the deployment in the `contracts` folder, your templates can
    be packaged in a JAR file; in this case, they must be stored in the `META-INF`/`contracts`
    folder of the JAR which will be deployed in the `WEB-INF`/`lib` folder of your
    application.``'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '``除了在`contracts`文件夹中的部署之外，你的模板还可以打包到一个JAR文件中；在这种情况下，它们必须存储在JAR的`META-INF`/`contracts`文件夹中，该JAR将被部署到应用程序的`WEB-INF`/`lib`文件夹中。``'
- en: '``Once defined, templates must be referenced within an application''s `faces-config.xml`
    file, with the `resource-library-contracts` element. The configurations of the
    following request mean that `template1` is applied to pages whose URLs respect
    the pattern `/templatepages/*`. And for other pages, the `template2` will be applied.``'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '``一旦定义，模板必须在应用程序的`faces-config.xml`文件中使用`resource-library-contracts`元素进行引用。以下请求的配置意味着`template1`应用于URL符合模式`/templatepages/*`的页面。而对于其他页面，将应用`template2`。``'
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '``The following code snippet shows us what the header of `template1` looks
    like. It contains only a picture to be displayed in the header. You can add text,
    style, and color if you want.``'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '``以下代码片段显示了`template1`的头部看起来像什么。它只包含要在头部显示的图片。如果你想的话，可以添加文本、样式和颜色。``'
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`The following code demonstrates how a template can be used in a web page:`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`以下代码演示了如何在网页中使用模板：`'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Faces Flow`'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Faces Flow`'
- en: '`Faces Flow is used to define and perform processes that are split over several
    forms. If we take, for example, the case of online registration, the registration
    form can be split over several pages, each representing a step. In our case we
    have: the acceptance conditions, entering identification information, contact
    information, medical information, school information, and finally the validation.
    To implement this type of application with previous versions of JSF, it was necessary
    to use beans with session scope and declare hard links between pages that formed
    the flow. This reduces the usability of the flow in another application and does
    not give the possibility to open the same flow in many windows.`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Faces Flow用于定义和执行跨越多个表单的过程。如果我们以在线注册为例，注册表单可以分散在多个页面中，每个页面代表一个步骤。在我们的案例中，我们有：接受条件、输入身份信息、联系信息、医疗信息、学校信息，最后是验证。要使用JSF的早期版本实现此类应用程序，需要使用会话作用域的bean并声明构成流程的页面之间的硬链接。这降低了流程在另一个应用程序中的可用性，并且不提供在多个窗口中打开相同流程的可能性。`'
- en: '``A flow is made up of an entry called the starting point, an exit point called
    a return node and zero, or many other nodes. A node can be a JSF page (`ViewNode`),
    a navigation decision (`SwitchNode`), an application logic invocation (`MethodCallNode`),
    a call to another flow (`FlowCallNode`), or a return to the calling flow (`ReturnNode`).``'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '``一个流程由一个称为起始点的入口，一个称为返回节点的出口点以及零个或多个其他节点组成。一个节点可以是JSF页面（`ViewNode`），一个导航决策（`SwitchNode`），一个应用逻辑调用（`MethodCallNode`），对另一个流程的调用（`FlowCallNode`），或者返回到调用流程（`ReturnNode`）。``'
- en: '`A flow can be configured either with an XML configuration file or programmatically.
    It can be packaged in a JAR file or folder. The following example demonstrates
    how to implement an online preregistration website with Faces Flow (our flow is
    configured with an XML configuration file; for program configuration, please consult
    the Java EE 7 tutorial.)`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`一个流程可以通过XML配置文件或编程方式配置。它可以打包在一个JAR文件或文件夹中。以下示例演示了如何使用Faces Flow（我们的流程使用XML配置文件进行配置；对于程序配置，请参阅Java
    EE 7教程）实现一个在线预注册网站。`'
- en: '`In the case of a flow packaged in a folder, the following conventions are
    followed by default:`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`在将流程打包到文件夹中的情况下，默认遵循以下约定：`'
- en: '`The package folder of the flow has the same name as the flow`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`流程的包文件夹与流程的名称相同`'
- en: '`The starting node of the flow has the same name as the flow`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`流程的起始节点与流程的名称相同`'
- en: '`All pages of the flow are assumed to be in the same folder except the exit
    points`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`除了出口点外，假设流程的所有页面都在同一个文件夹中`'
- en: '`` For a flow that is configured with an XML configuration file, the configuration
    file is a `faces-config` whose name is `<name_of_flow>-flow.xml` ``'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``对于使用XML配置文件配置的流程，配置文件是一个名为`<name_of_flow>-flow.xml`的`faces-config`文件 ``'
- en: '``According to the rule we have just presented, the web application that the
    tree is showing contains a flow named `inscriptionFlow` with six views. This flow
    is configured in `inscriptionFlow-flow.xml` and its starting node is `inscriptionFlow.xhtml`.``'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '``根据我们刚刚提出的规则，显示的树状图中包含一个名为`inscriptionFlow`的流程，该流程有六个视图。此流程在`inscriptionFlow-flow.xml`中配置，其起始节点是`inscriptionFlow.xhtml`。``'
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '``In the configuration file, we must define the ID of the flow and the ID of
    exit points. The following code shows the contents of the file `inscriptionFlow-flow.xml`:``'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '``在配置文件中，我们必须定义流程的ID和出口点的ID。以下代码显示了文件`inscriptionFlow-flow.xml`的内容：`'
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '``Navigation between different views can be done through the `action` attribute
    of the tag that will actuate the display of the next view. In this attribute you
    put the name of the page to which you want to go after the current page. The following
    code shows the contents of the `inscriptionFlow1` view. This view corresponds
    to the input form for personal information; it contains a field for entering the
    name, a button to go to the next view (`inscriptionFlow2`), and a button to return
    to the previous view (`inscriptionFlow`).``'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '``在不同视图之间进行导航可以通过将要激活下一个视图的标签的`action`属性来完成。在这个属性中，你需要在当前页面之后输入你想要前往的页面的名称。以下代码显示了`inscriptionFlow1`视图的内容。这个视图对应于个人信息的输入表单；它包含一个用于输入名称的字段，一个前往下一个视图（`inscriptionFlow2`）的按钮，以及一个返回上一个视图（`inscriptionFlow`）的按钮。``'
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '``To end a flow, just pass to the `action` attribute of the dedicated tag for
    this action the ID of the exit point defined in the configuration file (`inscriptionFlowExit`).
    And to save data between different views, you must use a Flow-Scoped Managed Bean.
    The following code shows the skeleton of the `inscriptionFlowBean` managed bean
    that we use in our inscription flow:``'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '``要结束一个流程，只需将配置文件中定义的退出点ID（`inscriptionFlowExit`）传递给为此动作指定的标签的`action`属性。并且要在不同的视图之间保存数据，你必须使用一个Flow-Scoped
    Managed Bean。以下代码显示了我们在注册流程中使用的`inscriptionFlowBean`管理Bean的框架：``'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Stateless views`'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`无状态视图`'
- en: '``JSF 2.2 did not only add new widgets, it also improved memory usage. Prior
    to Version 2.0 of the specification, the whole component tree was saved and restored
    whenever there was any change in the view. This degraded system performance and
    stuffed the memory. With Version 2.0, the specification has introduced the partial
    state saving mechanism. This mechanism consists of saving only the state that
    has changed after the creation of the component tree and reduces the amount of
    data to be saved. In the same light, JSF 2.2 offers us the possibility to define
    stateless views. As the name suggests, no data about the `UIComponent` state of
    the view''s components will be saved.``'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '``JSF 2.2不仅添加了新的小部件，还提高了内存使用效率。在规范版本2.0之前，每当视图有任何变化时，整个组件树都会被保存和恢复。这降低了系统性能并填满了内存。从版本2.0开始，规范引入了部分状态保存机制。该机制仅保存组件树创建后发生变化的州，从而减少了需要保存的数据量。同样，JSF
    2.2为我们提供了定义无状态视图的可能性。正如其名所示，视图组件的`UIComponent`状态数据将不会被保存。``'
- en: '``To transform a simple view into a stateless view, you just need to specify
    `true` as the value of the transient attribute of the `f:view` tag (see the following
    code).``'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '``要将一个简单视图转换为无状态视图，你只需将`f:view`标签的transient属性值指定为`true`（见以下代码）。``'
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`# Summary    In this chapter, we discussed the specifications related to data
    presentation that have been improved in Java EE 7\. These are: Servlet, Expression
    Language, and the JSF Specification. Each presentation was followed by an analysis
    of the various improvements made and a small example to show how these new features
    can be implemented. In the next chapter, we will talk about Java APIs used to
    communicate with databases, which will lead us to another chapter that focuses
    on putting together all of the APIs that we have seen.`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 摘要    在本章中，我们讨论了Java EE 7中改进的数据展示相关规范。这些是：Servlet、表达式语言和JSF规范。每个展示都紧跟着对各种改进的分析以及一个小示例，以展示如何实现这些新功能。在下一章中，我们将讨论用于与数据库通信的Java
    API，这将引导我们进入另一章，该章将重点介绍如何组合我们已看到的所有API。`'
