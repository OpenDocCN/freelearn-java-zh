- en: 12\. Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses regular expressions and considers both how and why they
    are so useful in Java. To begin, you will first explore how to construct these
    expressions in order to search for information in your program—a fundamental skill
    for any developer. When you have a firm understanding of the nature and function
    of these regular expressions, you will be able to use them to perform simple full-body
    matches in your search, and, later in the chapter, to extract substrings from
    a text using groups and non-capturing groups. In the final exercise, you have
    to employ all of these skills to perform recursive matches and extract a set of
    similar elements (i.e. a pattern) from a text.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your career as a developer, you will often find a search for information
    to be a logical first step to problem-solving: searching for documentation, searching
    for a specific line of code, or just making a program that extracts information
    from a given body of text into data that the program can understand.'
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is a specific language for defining these search rules,
    much like Java is a language to construct programs. The syntax can be quite complex.
    When you see a regular expression for the first time, it can be daunting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a very basic pattern matcher for an email address construction,
    with many flaws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re seeing this for the first time, you might think that it''s a typographical
    error (or that a cat was involved). However, it''s perfectly legitimate code.
    We''ll dive deeper into the construction of this example shortly, but first, let''s
    take a look at a more thorough pattern-matcher that validates an email address''
    construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This looks like even more gibberish to the novice. Perhaps the same cat was
    making a nest on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we uncover the logic behind this madness. We will start with
    decrypting what regular expressions mean, then look at how this will come in handy
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way regular expressions are constructed follows some basic rules that are
    the same on every platform and implementation; however, there are some implementation-specific
    rules that might vary depending on the platform and implementation the regular
    expression was constructed for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit our initial email pattern matching `/.+\@.+\..+/` expression.
    We can see that it starts with a slash mark like this, `/` and ends with a `/`.
    These are the opening and closing markers for the expression; anything within
    these characters belongs to the actual expression.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are constructed from a few basic components; they are character
    classes, anchors, groups, and special escape characters. Then, we have the quantifiers
    that control how many of the preceding characters should be matched. Last but
    not least, we have the expression flags, which control certain behaviors for the
    whole expression. Let's look at them in more detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Character Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Character classes define the sets of characters that the pattern matcher will
    search for. The set is defined in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `[xyz]` will match an `x`, `a y`, or a `z`. These are case sensitive,
    so an `X` will not match. If you''re matching characters that follow alphabetically,
    you can replace the expression with a range. Instead of `[xyz]`, you can write
    `[x-z]`. This is very convenient if you want to cover many characters in your
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Regular expressions for character classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Regular expressions for character classes'
  prefs: []
  type: TYPE_NORMAL
- en: There are also predefined character classes. These allow you to search for specific
    sets of characters without having to type out the full character set. For example,
    the dot (`.`) shown earlier will match any character except for line breaks. Written
    out in full as a set, the expression for this search would look like `[^\n\r]`,
    so you can see how just using `.` is quicker and easier. You can see in the following
    tables what the `^`, `\n`, and `\r` symbols represent.
  prefs: []
  type: TYPE_NORMAL
- en: You can also search using negated sets. This will match everything that is not
    part of that set.
  prefs: []
  type: TYPE_NORMAL
- en: Character Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A character set matches any character defined in the set. The following figure
    shows a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Regular expressions for character sets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Regular expressions for character sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Predefined character sets help you build quick expressions. The following figure
    lists predefined character sets, which are useful for building quick expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Regular expressions for predefined character sets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Regular expressions for predefined character sets'
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quantifiers are simple rules that allow you to define how the preceding character
    sets should be matched. Should only one of the characters be allowed, or a range
    between one and three? See the following figure for acceptable quantifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Regular expressions for quantifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: Regular expressions for quantifiers'
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anchors give you one extra dimension of control so you can define the boundaries
    in a text rather than the text itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Regular expressions for anchors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: Regular expressions for anchors'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capturing groups allow you to group tokens in an expression to form sub-strings.
    Any capturing token can be used within a group, including nesting other groups.
    They also allow for reuse in the expression using references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Regular expressions for capturing groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Regular expressions for capturing groups'
  prefs: []
  type: TYPE_NORMAL
- en: Escaped Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `\` character to escape characters to match them in the string.
    It is useful for matching serialized data such as XML and JSON. It is also used
    to match non-text characters such as a tab and a newline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common escaped characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Regular expressions for escaped characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Regular expressions for escaped characters'
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any characters placed directly after the closing marker are called flags. There
    are five flags, which you may combine in any way, though you may avoid using flags
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Regular expressions for flags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: Regular expressions for flags'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how these regular expressions work,
    let's look at a full-fledged example in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Implementing Regular Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using an online regular expression checker, we'll build a regular expression
    that verifies whether a street address is correctly specified. The format that
    the address follows is the street name followed by the street number. The street
    name and the street number are separated by a single whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will check if the following common Swedish addresses are valid or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Strandvagen 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storgatan 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ringvagen3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storgatan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use [https://packt.live/2MYzyFq](https://packt.live/2MYzyFq) for this
    exercise because of its easy-to-use interface and modern feel. However, the regular
    expression should work on other platforms as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://packt.live/2MYzyFq](https://packt.live/2MYzyFq).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter three different local addresses of your choice in the space under the
    title `Text`, at least one should be incorrectly formatted. The addresses I''ve
    chosen are `Strandvagen 1`, `Storgatan 2`, and `Ringvagen3`. These are all very
    common street names in Sweden, the last of which is incorrectly formatted as it
    is lacking a whitespace between the street name and the number.![Figure 12.9:
    Inputting incorrectly formatted text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_12_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.9: Inputting incorrectly formatted text'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the simple rules we defined, we can extract the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the street address must start with a name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the street address should have a number
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the first rule. The name is an alphabetic-only word (i.e. contains only
    letters):![Figure 12.10: Adding the first rule'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_12_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.10: Adding the first rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let there be, at most, one empty space between the digit and the number. We
    can already see that one address is incorrectly formatted:![Figure 12.11: Modifying
    the rule to consider one empty space between digit and number'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_12_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.11: Modifying the rule to consider one empty space between digit
    and number'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add at least one digit to the address. Now one more address has disappeared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.12: Modifying the rule to add one digit to the address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: Modifying the rule to add one digit to the address'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a simple procedure to construct a regular expression to validate
    an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Regular Expressions to Check If the Entrance is Entered in the
    Desired Format'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add one more rule to the preceding regular expression; allow for one optional
    character after the number. This will define which entrance to use at an address
    that has multiple entrances—for example, `Strandvagen 1a` or `Ringvagen 2b`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 560.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an idea of how regular expressions can be used to match patterns,
    this topic will focus on how regular expressions can be used within Java applications.
    To use regular expressions in Java, the `java.util.regex` package is available.
    The two main classes there are called `Pattern` and `Matcher`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Pattern` class handles the actual pattern; it validates, compiles, and
    returns a `Pattern` object that you can store and reuse multiple times. It can
    also be used to perform quick validations against a supplied string.
  prefs: []
  type: TYPE_NORMAL
- en: The `Matcher` class allows us to extract more information, and to perform different
    kinds of matching on the supplied text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `Pattern` object is as simple as using the static `compile` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you would like to compile a pattern to ensure that a text contains
    at least one `a`. Your Java code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we shouldn't supply the starting and ending token of the regular expression.
    With the `Pattern` object, then, you can perform a match on a given string.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method will attempt to match the entire string to the regular
    expression; if only part of the string matches the regular expression, it will
    return false.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead, you just wish to make a quick validation, you can use the static
    `matches` method, which will return a Boolean; it is just a shorthand for doing
    exactly the same as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2: Extracting the Domain Using Pattern Matching'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will extract every part of a URL and store them in variables,
    starting with the protocol, then the domain, and then finally the path:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ IDEA is already started, but no project is open, select `Create
    New Project`. If IntelliJ already has a project open, select `File` -> `New` ->
    `Project` from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `New Project` dialog, select a Java project. Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`.
    Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Chapter12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will provide a default project location. You can enter any other desired
    location as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`. Your project will be created with the standard folder structure,
    and an entry point class for your program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename this file `Exercise2.java`. When you''re done, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare this book''s website `url`, which we''ll split into separate parts.
    If you haven''t visited the website yet, you can find it at [https://www.packtpub.com/application-development/mastering-java-9](https://www.packtpub.com/application-development/mastering-java-9):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll start by finding just the protocol using regular expressions. Declare
    a string to hold the regular expression and call it `regex`. It should contain
    at least the letters `http` and an optional `s`. Wrap the whole expression in
    a group to ensure you can extract it as a substring later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is, of course, just one example of extracting the protocol. You can experiment
    with finding strings before the first colon or other interesting expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compile the expression into a `pattern` object. Since we''re not performing
    a global match, we''ll not use the shorthand. Instead, we''ll create the `Matcher`
    for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attempt to find the first group, using the `find()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the number of available groups using the `groupCount()` method.
    This is very useful if you want to loop through all groups in order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If any matches were found, start extracting the groups into variables. For
    now, simply print the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before capturing the domain name, we need to ignore the useless characters
    between that and the protocol—the `://`. Add a non-capturing group for those characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a third group to the regular expression to find the domain. We''ll
    try to find the whole domain, letting the `www` application notation be optional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, collect the domain group and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, extract the `path` components and print them to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this exercise, you should see the following text in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to use capturing groups to extract only the vital information
    from a small string. However, you'll notice that the match is only performed once.
    In Java, it's easy to do a recursive match on a large body of text using similar
    techniques to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Extracting Links Using Pattern Matching'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you'll perform a recursive matching on the Packt website to
    extract all links, then print these links in the terminal. For simplicity, we'll
    use an already saved dump of the Packt website; of course you can go ahead and
    download the website on your own using curl, wget, or similar tools depending
    on the platform you're using. You can also view the source of the website in your
    favorite browser and copy it to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter12` project in IntelliJ IDEA if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class by going to `File` -> `New` -> `Java Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Exercise 3` as the name and click `OK`. IntelliJ IDEA will create a
    new class, which should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the main entry point for your program – the `static` `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the Packt website dump into your project's `res` folder. If the folder
    doesn't exist, create it as a sibling to `src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the contents of the file into a new string; call it `packtDump`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start creating a regular expression for capturing links from a website. They
    usually look something like this. We need to look for the starting and the ending
    tokens of the link, and capture anything in between:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by looking for the opening token, `"<a href=\"`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another non-capturing group for the ending token. The link ends with the
    next instance of double quotation marks (`"`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the only capturing group needed for this regular expression—the
    link group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the pattern and match it against the `packtDump` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list for storing the links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, loop through all matches and add them to the list. We only have one
    capturing group here, so there''s no need to check the number of groups and loop
    through them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can wrap the exercise up by printing the list to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Executing this exercise, you should see a long list of both relative and absolute
    links in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve successfully extracted the links from the Packt website. A real-world
    application may use this to build site-maps or otherwise document how websites
    are interconnected. The next step in this program is all up to you. The following
    steps will let you analyze the content of the Packt website more thoroughly:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove any non-functional links such as `#` and links back to `home /`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, remove all links that start with `http`; only the relative links should
    remain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first path of the relative links represents the category of that book. Divide
    the books on the website into different categories and see which category is the
    most popular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to use regular expressions to search and
    extract information from large bodies of text. This can be very handy when parsing
    structured or semi-structured data. Regular expressions are not specific to Java.
    The Java implementation may differ slightly from other platforms and languages;
    however, the general syntax remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll explore a programming paradigm that is growing in
    popularity. Functional programming, while not originally intended for Java, can
    help you to write programs that you can test more easily, which may limit the
    number of state-changing problems.
  prefs: []
  type: TYPE_NORMAL
