- en: Understanding the Collections Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解集合框架
- en: In this chapter, we will delve into the collections framework, which consists
    of interfaces and classes. We will have a look at the three major collections: `List`,
    `Set`, and `Map`. `ArrayList` from the `List` collection, `HashSet` from the `Set`
    collection, and `HashMap` and `HashTable` from the `Map` collection will be discussed
    in this chapter. We will go through each concept by looking at examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨集合框架，该框架由接口和类组成。我们将查看三个主要集合：`List`、`Set`和`Map`。本章将讨论来自`List`集合的`ArrayList`、来自`Set`集合的`HashSet`以及来自`Map`集合的`HashMap`和`HashTable`。我们将通过查看示例来逐一介绍每个概念。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The collections framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合框架
- en: The list collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表集合
- en: The set collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合集合
- en: The map collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射集合
- en: The collections framework
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合框架
- en: The Java collections framework is basically a collection of interfaces and classes.
    To program efficiently, or use the flexibility of Java methods, Java has designed
    a framework, which consists of different classes and interfaces. The collections
    framework helps in storing and processing data efficiently. This framework has
    several useful classes that have tons of useful functions, that make a programmer's
    task super easy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合框架基本上是一组接口和类的集合。为了高效编程或使用Java方法的灵活性，Java设计了一个框架，该框架由不同的类和接口组成。集合框架有助于高效地存储和处理数据。这个框架有几个非常有用的类，它们提供了大量的有用功能，使得程序员的任务变得非常简单。
- en: We have seen a lot of concepts about arrays and multidimensional arrays. For
    example, in an array, if we want to delete one of the indexes out of a new set
    of arrays, we can do that using the collections framework. Let's say in one array
    there are 10 values, and we want to remove the fifth value, or insert a value
    between the fifth and sixth values—there are some flexibility methods that you
    will get in the collections framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多关于数组和多维数组的概念。例如，在一个数组中，如果我们想从一个新的数组集中删除一个索引，我们可以使用集合框架来完成。假设在一个数组中有10个值，我们想删除第五个值，或者在第5个和第6个值之间插入一个值——在集合框架中，你将获得一些灵活的方法。
- en: The kinds of method available in this collection framework, and how they can
    be used effectively, will be discussed in further sections. So just to give you
    an idea, remember that a collection is a set of classes and interfaces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论这个集合框架中可用的方法类型，以及如何有效地使用它们。所以，为了给你一个概念，请记住，集合是一组类和接口。
- en: We will have a look at the collections this framework has to offer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看这个框架提供的集合。
- en: The List collection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表集合
- en: The first one is the `List` collection/interface. A list is an ordered collection,
    sometimes we call it as a sequence as well. Lists may contain duplicate elements,
    just like arrays, but there are lots of differences between an array and `ArrayList`.
    You can insert multiple values into this `List` container, and it might contain
    duplicate elements as well. You can actually add any value and remove any value
    from any index. Let's say you added 15 elements sequentially into the list, now
    you want to remove 6^(th) element, or you want to insert an element between the
    10^(th) and 11^(th )elements, or you want to know an element at what index it
    is out of those 15 elements. There are lots of helpful APIs to retrieve elements
    from the list container, which we don't get in arrays. Arrays can only be initialized;
    apart from that, you cannot perform any methods on an array, whereas with `ArrayList`
    you have lots of flexible methods to play around with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个集合是`List`集合/接口。列表是有序集合，有时我们也称其为序列。列表可以包含重复元素，就像数组一样，但数组与`ArrayList`之间有很多区别。你可以向这个`List`容器中插入多个值，它也可能包含重复元素。实际上，你可以从任何索引添加或删除任何值。比如说，你按顺序向列表中添加了15个元素，现在你想删除第6个元素，或者你想在第10个和第11个元素之间插入一个元素，或者你想知道一个元素在15个元素中的哪个索引。列表容器中有许多有用的API可以检索元素，而这些在数组中是得不到的。数组只能初始化；除此之外，你无法对数组执行任何方法，而使用`ArrayList`，你有很多灵活的方法可以操作。
- en: The `List` interface is a collection, and `ArrayList`, `LinkedList`, and `vector` are
    the three classes that implement this interface. This interface provides a set
    of methods. It exposes a few methods, whereas these three classes use these methods
    in their classes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口是一个集合，`ArrayList`、`LinkedList`和`vector`是实现了这个接口的三个类。这个接口提供了一组方法。它公开了一些方法，而这三个类在其类中使用这些方法。'
- en: Out of these three, let's discuss `ArrayList`. This is one of the most famous
    ones, and is used by most Java programmers. Once you understand `ArrayList`, you
    can easily figure out `LinkedLists` and `vector`. In the next section, we will
    create an `ArrayList` class and implement methods present in the `List` interface,
    to see how flexible these methods are at retrieving or organizing data. When you
    have a set of data in a container, you can easily organize that data with the
    help of the `List` interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个中，让我们讨论一下`ArrayList`。这是最著名的一个，被大多数Java程序员使用。一旦你理解了`ArrayList`，你就可以轻松地了解`LinkedLists`和`vector`。在下一节中，我们将创建一个`ArrayList`类并实现`List`接口中的方法，以查看这些方法在检索或组织数据时的灵活性。当你有一组数据在容器中时，你可以通过`List`接口轻松地组织这些数据。
- en: The ArrayList class
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ArrayList`类'
- en: Let's get started with the `ArrayList` class, which implements the `List` interface.
    Create a new class and name it `arrayListexample`. We will first look at the methods
    present in `ArrayList`, and then we'll discuss the difference between an array
    and `ArrayList`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ArrayList`类开始，它实现了`List`接口。创建一个新的类，命名为`arrayListexample`。我们将首先查看`ArrayList`中存在的方法，然后我们将讨论数组和`ArrayList`之间的区别。
- en: 'We start by declaring `ArrayList` as follows. If you hover over `ArrayList`
    in your IDE, you''ll see a suggestion telling you to import `java.util` for `ArrayList`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明`ArrayList`如下。如果你在你的IDE中悬停在`ArrayList`上，你会看到一个建议告诉你导入`java.util`以使用`ArrayList`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you do this, it''ll still show a suggestion for `ArrayList`, and if you
    hover over it, it will suggest adding argument types. To remove this suggestion,
    you can pass an argument type to `ArrayList`, such as `Integer` or `String`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，它仍然会显示关于`ArrayList`的建议，并且如果你悬停在它上面，它会建议添加参数类型。为了移除这个建议，你可以向`ArrayList`传递一个参数类型，例如`Integer`或`String`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After passing the argument type, you can easily add some string instances by
    using `a.` and it'll show you a list of different types supported by `ArrayList`.
    For `ArrayList`, we didn't define a specific array size, whereas when you see
    in arrays, we have explicitly defined a size. In arrays, once we define the size,
    you cannot decrease or increase the size. But in `ArrayList`, you could add or
    delete elements anytime from the list, it is a dynamic size array. This is one
    of the basic differences between array and `ArrayList`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递参数类型后，你可以通过使用`a.`轻松地添加一些字符串实例，它将显示`ArrayList`支持的不同类型列表。对于`ArrayList`，我们没有定义特定的数组大小，而当你看到数组时，我们明确地定义了大小。在数组中，一旦我们定义了大小，就不能增加或减少大小。但在`ArrayList`中，你可以随时从列表中添加或删除元素，它是一个动态大小的数组。这是数组和`ArrayList`之间最基本的区别之一。
- en: 'If we want to print this `ArrayList`, we can simply do that by adding the following
    line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要打印这个`ArrayList`，我们可以简单地通过添加以下代码行来实现：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On running, it prints `[rahul, java]`. But if you want to print this in arrays,
    we need to write a `for` loop. We add another object and this time we specify
    the index where we want the string to go:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，它将打印出`[rahul, java]`。但如果你想以数组的形式打印这个，我们需要写一个`for`循环。我们添加另一个对象，这次我们指定了字符串要放置的索引：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we print this, it gives the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印这个时，它会给出以下输出：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that in the second line, `student` is added before `rahul` in the
    list as we have specified its index as `0`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在第二行中，我们在列表中`rahul`之前添加了`student`，因为我们已经指定了它的索引为`0`。
- en: 'If we want to remove an entry from the list, we can do that by adding the following
    lines of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从列表中删除一个条目，我们可以通过添加以下几行代码来实现：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first line of code will remove the entry from the list present at the first
    index, whereas the second line will find the string in the list and remove it.
    If you want to get the entry for a specific index, you can do that using the `get`
    method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码将从列表的第一个索引处删除条目，而第二行将找到列表中的字符串并删除它。如果你想获取特定索引的条目，你可以使用`get`方法来实现：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding line of code will print `java` as the output, as it is the element
    present at index `2`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行将打印出`java`作为输出，因为它是在索引`2`处的元素。
- en: 'Let''s say you have a list of 50 elements, and you need to find out whether
    a particular string/integer is present in that list. If you were to go with arrays,
    you would have to create a `for` loop and find out whether the element is present,
    but in `ArrayList`, we have a `contains` method that checks the entire list for
    us and gives the output in the form of `true` or `false`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含50个元素的列表，你需要找出特定的字符串/整数是否存在于该列表中。如果你使用数组，你必须创建一个`for`循环来找出元素是否存在，但在`ArrayList`中，我们有一个`contains`方法会为我们检查整个列表，并以`true`或`false`的形式给出输出：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will print the output as `true` as the element is present in our list;
    if you change it to, for example, `testing`, it will return the value as `false`
    as it is not present in our list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`true`，因为元素存在于我们的列表中；如果你将其更改为，例如`testing`，它将返回`false`，因为它不在我们的列表中。
- en: 'Another useful method present in `ArrayList` is the `indexOf` method. If we
    want to find the index value of a particular element from the list, we can know
    that by using `indexOf`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`中另一个有用的方法是`indexOf`方法。如果我们想从列表中找到特定元素的索引值，我们可以通过使用`indexOf`来知道：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will return the index number of this string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回这个字符串的索引号。
- en: 'Now, if we want to check whether the array is empty, we can do that using the `isEmpty`
    method in `ArrayList`, which will return the value as `true` or `false`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想检查数组是否为空，我们可以使用`ArrayList`中的`isEmpty`方法来做，它将返回`true`或`false`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will return the value as `false` as our list is not empty.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`false`，因为我们的列表不是空的。
- en: 'The last and most important method in `ArrayList` is the `size` method, which
    returns the length of the list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`中最后一个且最重要的方法是`size`方法，它返回列表的长度：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One more thing you need to know about `ArrayList` is that all the classes that
    implement the `List` interface can accept duplicate values. We know the classes
    that extend `List` in the collection interface: `ArrayList`, `LinkedList`, and
    `vector`. And all these classes can accept duplicate values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ArrayList`的另一件事是你需要知道的是，实现`List`接口的所有类都可以接受重复的值。我们知道在集合接口中扩展`List`的类：`ArrayList`、`LinkedList`和`vector`。并且所有这些类都可以接受重复的值。
- en: Example of ArrayList
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayList的示例
- en: Let's say we have an array with duplicate numbers, such as `{4, 5, 5, 5, 4,
    6, 6, 9, 4}`, and we want to print out the unique number from this, and how many
    times this number is repeated in this array. Our output should be "four is repeated
    three times, five is repeated three times, six twice, nine once."
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含重复数字的数组，例如 `{4, 5, 5, 5, 4, 6, 6, 9, 4}`，我们想要从这个数组中打印出唯一的数字，以及这个数字在这个数组中重复了多少次。我们的输出应该是“四个数字重复了三次，五个数字重复了三次，六个数字重复了两次，九个数字重复了一次。”
- en: 'Let''s bring in the `ArrayList` concept here to solve this puzzle:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`ArrayList`的概念引入这里来解决这个谜题：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We're done with the `for` and `if` loops. We print out each element from the
    array and the number of instances each element is present in the array. To print
    the unique number, that is, the number that is not repeated in the array, we use
    an `if` loop and print it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`for`和`if`循环。我们打印出数组中的每个元素以及每个元素在数组中出现的次数。要打印唯一的数字，即不在数组中重复的数字，我们使用`if`循环并打印它。
- en: That's it for this example; you can try coding this example with your own logic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子就到这里了；你可以尝试用你自己的逻辑来编写这个例子。
- en: The Set collection
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的Set
- en: Another important collection present in Java is the `Set` collection/interface.
    `HashSet`, `TreeSet`, and `LinkedHashSet` are the three classes that implement
    the `Set` interface. The main difference between `Set` and `List` is that `Set`
    does not accept duplicate values. One more difference between the `Set` and `List`
    interfaces is that there is no guarantee that elements are stored in sequential
    order.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Java中另一个重要的集合是`Set`集合/接口。`HashSet`、`TreeSet`和`LinkedHashSet`是三个实现`Set`接口的类。`Set`和`List`之间的主要区别是`Set`不接受重复的值。`Set`和`List`接口之间的另一个区别是，没有保证元素按顺序存储。
- en: 'We will mainly be discussing `HashSet` in this section. We will take an example
    class and try to understand this concept. Create a class and name it `hashSetexample`
    for this section, and create an object within the class to use `HashSet`; it''ll
    suggest you add the argument type, which is `String` in our case:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将主要讨论`HashSet`。我们将举一个示例类来尝试理解这个概念。为这个部分创建一个类，命名为`hashSetexample`，并在类中创建一个对象以使用`HashSet`；它将建议你添加参数类型，在我们的例子中是`String`：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In your IDE when you type `hs.`, it''ll show you all the methods provided by
    `HashSet`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的集成开发环境（IDE）中，当你输入 `hs.` 时，它会显示 `HashSet` 提供的所有方法：
- en: '![](img/43eefee7-fe95-435d-a7c3-e83ec95f6ce2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43eefee7-fe95-435d-a7c3-e83ec95f6ce2.png)'
- en: 'Start by adding a few string instances of duplicate entries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一些重复条目的字符串实例：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you print this, the output will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印这个时，输出将如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We see that the duplicate entry for `INDIA` is rejected by `HashSet` and we
    only see one instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于 `INDIA` 的重复条目，`HashSet` 会拒绝并只显示一个实例。
- en: 'If we wish to remove any object, we can do so using the `remove` method, and
    to get the size of the list use the `size` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望删除任何对象，我们可以使用 `remove` 方法，要获取列表的大小，则使用 `size` 方法：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `isEmpty` method tells us whether the list is empty—if it's empty, it'll
    return `true`, otherwise it returns `false`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 方法告诉我们列表是否为空——如果为空，它将返回 `true`，否则返回 `false`。'
- en: Using iterator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: 'To iterate through each element present within a list, we use the `iterator`
    method. We need to create another object for this `Iterator` class, along with
    the `String` argument type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表中存在的每个元素，我们使用 `iterator` 方法。我们需要为这个 `Iterator` 类创建另一个对象，以及 `String` 参数类型：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Imagine that we have a set of elements and they are in order starting from
    zero, one, two, and so on. `iterator` goes through each element starting from
    zero and prints the element present at each value. We have created an object for
    iterator and we print the values as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一组元素，并且它们从零开始按顺序排列，一、二、三等等。`iterator` 从零开始遍历每个元素，并打印出每个值对应的元素。我们为 `iterator`
    创建了一个对象，并按以下方式打印值：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first instance of `i.next()` will print the values present at the zero
    index and the next `i.next()` instance prints the value at index one. If we have
    a set where we have around 100 values, we will have to use the `while` loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `i.next()` 将打印零索引处的值，下一次 `i.next()` 实例将打印一索引处的值。如果我们有一个包含大约 100 个值的集合，我们将不得不使用
    `while` 循环：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have used the `hasNext` method, which checks the set for next values.
    If there are values present in the next index, it'll return `true` and if not,
    it returns `false`. In our case, it'll return `true` for 100 values and `false`
    after that, and exit the `while` loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `hasNext` 方法，该方法检查集合中是否有下一个值。如果有下一个索引的值，它将返回 `true`，如果没有，则返回 `false`。在我们的例子中，它将返回
    `true` 100 个值，然后返回 `false`，并退出 `while` 循环。
- en: This is how you can iterate through the objects present in the `Set` interface
    using `iterator`. If you are working on automation testing, such as Selenium,
    you'll be using this `while` loop frequently.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `iterator` 迭代 `Set` 接口中存在的对象。如果你在做自动化测试，比如 Selenium，你将频繁地使用这个 `while`
    循环。
- en: The Map collection
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map 集合
- en: We have one more collection, called `Map`. We will take an example and discuss `Map`
    as we proceed with the code. This interface takes the values in the form of a
    key and value pair.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `Map` 的集合。我们将举一个例子，并在编写代码的过程中讨论 `Map`。此接口以键值对的形式接受值。
- en: 'We create a class, `hashMapexample`, and within that the we define `HashMap`.
    `HashMap` requires two types of argument, such as `Integer` and `String`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个类，`hashMapexample`，并在其中定义 `HashMap`。`HashMap` 需要两种类型的参数，例如 `Integer` 和
    `String`：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, `Integer` is the key and `String` is the value. Now if you type `hm.`
    in your IDE, you will see a few methods present in `HashMap`; let''s use the `put`
    method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Integer` 是键，`String` 是值。现在，如果你在 IDE 中输入 `hm.`，你会看到 `HashMap` 中的一些方法；让我们使用
    `put` 方法：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `put` method takes the input in the form of keys and values. Also, the
    value of the key needs to be an integer, it can be a string as well. The key is
    just something we define for the value. We can remove a value using the `remove`
    method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 方法以键和值的形式接收输入。此外，键的值需要是整数，也可以是字符串。键只是我们为值定义的东西。我们可以使用 `remove` 方法删除值：'
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `entrySet` method in `HashMap` stores each key and value in the form of
    a set index:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 中的 `entrySet` 方法以集合索引的形式存储每个键和值：'
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have now converted this `HashMap` into a set. To traverse through each index
    of this set, we use `iterator` and, just like in the previous section, we use
    the `while` loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将这个 `HashMap` 转换为集合。要遍历这个集合的每个索引，我们使用 `iterator`，就像在前一个部分中一样，我们使用 `while`
    循环：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to use `Map.Entry` here, as the element in each index consists of a
    key and a value, and `Map.Entry` helps us to separate out the keys and values.
    When you print this `while` loop, you should get the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要使用 `Map.Entry`，因为每个索引中的元素都包含一个键和一个值，`Map.Entry` 帮助我们分离出键和值。当你打印这个 `while`
    循环时，你应该得到以下输出：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Without using `Map.Entry`, it'll throw an error. This is how `HashMap` works.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `Map.Entry`，将会抛出错误。这就是 `HashMap` 的工作方式。
- en: HashTable
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashTable
- en: There is one more collection, called `HashTable`, but it lies along the same
    lines as `HashMap`. You just need to change `HashMap` to `HashTable`—that's it. There's
    a slight difference between `HashMap` and `HashTable` though.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `HashTable` 的集合，但它与 `HashMap` 的操作方式相同。你只需要将 `HashMap` 改为 `HashTable`——就是这样。不过，`HashMap`
    和 `HashTable` 之间还是有一点细微的差别。
- en: 'The differences between `HashMap` and `HashTable` are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 和 `HashTable` 之间的差异如下：'
- en: Synchronized or thread-safe
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步或线程安全
- en: Null keys and null values
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空键和空值
- en: Iterating values
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代值
- en: Synchronized or thread-safe
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步或线程安全
- en: This is the most important difference between the two. `HashMap` is non-synchronized
    and not thread-safe. So what is meant by non-synchronized? It means if multiple
    programs simultaneously access `HashMap`, it keeps on updating. Now let's say
    there are five threads working on `HashMap`. That means five different programs
    or threads can access `HashMap` at the same time, which means there is no synchronization.
    But in `HashTable`, if one program is accessing `HashTable`, the other program
    needs to wait until the first program releases the `HashTable` resources. That's
    the major difference. On the other hand, `HashTable` is thread-safe and synchronized.
    When should you use `HashMap`? If your application does not require a multithreading
    task—in other words, `HashMap` is better for non-threading applications. `HashTable` should
    be used in multithreading applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两者之间最重要的差异。`HashMap` 是非同步的，也不是线程安全的。那么非同步是什么意思呢？这意味着如果有多个程序同时访问 `HashMap`，它会持续更新。现在假设有五个线程在
    `HashMap` 上工作。这意味着五个不同的程序或线程可以同时访问 `HashMap`，这意味着没有同步。但在 `HashTable` 中，如果一个程序正在访问
    `HashTable`，其他程序需要等待第一个程序释放 `HashTable` 资源。这是主要差异。另一方面，`HashTable` 是线程安全的，也是同步的。你应该在什么时候使用
    `HashMap`？如果你的应用程序不需要多线程任务——换句话说，`HashMap` 更适合非线程应用程序。`HashTable` 应用于多线程应用程序。
- en: Null keys and null values
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空键和空值
- en: '`HashMap` allows one null key and any number of null values, while `HashTable`
    does not allow null keys and null values in the `HashTable` object. Let''s say
    you are entering employee records into a database and while uploading the employee
    details into your database, maybe you feel that you would not know their phone
    number, but you enter the field called phone number in a key value, and index
    value for now you would leave it as a null; you could update it later. This works
    in `HashMap`, but when you are working with `HashTable`, it will not allow any
    null keys and null values. If you feel that you want to make your program very
    secure and you want to block multiple threads from accessing it simultaneously,
    then you should go with `HashTable`. `HashTable` is thread-safe, and it will not
    release its object to another program until one program completes its operation
    on `HashTable`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 允许一个空键和任意数量的空值，而 `HashTable` 不允许在 `HashTable` 对象中存在空键和空值。假设你正在将员工记录输入到数据库中，当你在数据库中上传员工详细信息时，也许你不知道他们的电话号码，但你可以现在在键值和索引值中输入一个名为电话号码的字段；你现在可以将其留为空；你可以在以后更新它。这在
    `HashMap` 中是可行的，但当你在使用 `HashTable` 时，它将不允许任何空键和空值。如果你觉得你想让你的程序非常安全，并且你想阻止多个线程同时访问它，那么你应该选择
    `HashTable`。`HashTable` 是线程安全的，并且它不会在另一个程序完成对 `HashTable` 的操作之前释放其对象。'
- en: Iterating values
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代值
- en: '`HashMap` object values are iterated by using `iterator`. `HashTable` is the
    only class other than vector which uses enumerator to iterate the values of the
    `HashTable` object.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 对象的值通过使用 `iterator` 进行迭代。除了 `vector` 类之外，`HashTable` 是唯一一个使用枚举器来迭代
    `HashTable` 对象值的类。'
- en: The operations are the same across `HashMap` and `HashTable`, except for the
    three differences we've just described.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HashMap` 和 `HashTable` 之间，操作是相同的，除了我们刚刚描述的三个差异。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we had a look at the collections framework and the three types
    of collection: `List`, `Set`, and `Map`. We explored `ArrayList` in the `List`
    collection, and also explored an example of `ArrayList`. The `Set` collection
    is different from `ArrayList`—the major difference is that `Set` does not accept
    duplicate values. In the last collection, that is, the `Map` collection, we saw
    two types, `HashMap` and `HashTable`, and the differences between the two.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了集合框架和三种类型的集合：`List`、`Set`和`Map`。我们在`List`集合中探讨了`ArrayList`，并且还探讨了`ArrayList`的一个示例。`Set`集合与`ArrayList`不同——主要区别在于`Set`不接受重复的值。在最后一个集合，即`Map`集合中，我们看到了两种类型，`HashMap`和`HashTable`，以及两者之间的区别。
