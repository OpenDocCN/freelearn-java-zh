- en: Understanding the Collections Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the collections framework, which consists
    of interfaces and classes. We will have a look at the three major collections: `List`,
    `Set`, and `Map`. `ArrayList` from the `List` collection, `HashSet` from the `Set`
    collection, and `HashMap` and `HashTable` from the `Map` collection will be discussed
    in this chapter. We will go through each concept by looking at examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collections framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java collections framework is basically a collection of interfaces and classes.
    To program efficiently, or use the flexibility of Java methods, Java has designed
    a framework, which consists of different classes and interfaces. The collections
    framework helps in storing and processing data efficiently. This framework has
    several useful classes that have tons of useful functions, that make a programmer's
    task super easy.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a lot of concepts about arrays and multidimensional arrays. For
    example, in an array, if we want to delete one of the indexes out of a new set
    of arrays, we can do that using the collections framework. Let's say in one array
    there are 10 values, and we want to remove the fifth value, or insert a value
    between the fifth and sixth values—there are some flexibility methods that you
    will get in the collections framework.
  prefs: []
  type: TYPE_NORMAL
- en: The kinds of method available in this collection framework, and how they can
    be used effectively, will be discussed in further sections. So just to give you
    an idea, remember that a collection is a set of classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a look at the collections this framework has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: The List collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first one is the `List` collection/interface. A list is an ordered collection,
    sometimes we call it as a sequence as well. Lists may contain duplicate elements,
    just like arrays, but there are lots of differences between an array and `ArrayList`.
    You can insert multiple values into this `List` container, and it might contain
    duplicate elements as well. You can actually add any value and remove any value
    from any index. Let's say you added 15 elements sequentially into the list, now
    you want to remove 6^(th) element, or you want to insert an element between the
    10^(th) and 11^(th )elements, or you want to know an element at what index it
    is out of those 15 elements. There are lots of helpful APIs to retrieve elements
    from the list container, which we don't get in arrays. Arrays can only be initialized;
    apart from that, you cannot perform any methods on an array, whereas with `ArrayList`
    you have lots of flexible methods to play around with.
  prefs: []
  type: TYPE_NORMAL
- en: The `List` interface is a collection, and `ArrayList`, `LinkedList`, and `vector` are
    the three classes that implement this interface. This interface provides a set
    of methods. It exposes a few methods, whereas these three classes use these methods
    in their classes.
  prefs: []
  type: TYPE_NORMAL
- en: Out of these three, let's discuss `ArrayList`. This is one of the most famous
    ones, and is used by most Java programmers. Once you understand `ArrayList`, you
    can easily figure out `LinkedLists` and `vector`. In the next section, we will
    create an `ArrayList` class and implement methods present in the `List` interface,
    to see how flexible these methods are at retrieving or organizing data. When you
    have a set of data in a container, you can easily organize that data with the
    help of the `List` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The ArrayList class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with the `ArrayList` class, which implements the `List` interface.
    Create a new class and name it `arrayListexample`. We will first look at the methods
    present in `ArrayList`, and then we'll discuss the difference between an array
    and `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by declaring `ArrayList` as follows. If you hover over `ArrayList`
    in your IDE, you''ll see a suggestion telling you to import `java.util` for `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do this, it''ll still show a suggestion for `ArrayList`, and if you
    hover over it, it will suggest adding argument types. To remove this suggestion,
    you can pass an argument type to `ArrayList`, such as `Integer` or `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After passing the argument type, you can easily add some string instances by
    using `a.` and it'll show you a list of different types supported by `ArrayList`.
    For `ArrayList`, we didn't define a specific array size, whereas when you see
    in arrays, we have explicitly defined a size. In arrays, once we define the size,
    you cannot decrease or increase the size. But in `ArrayList`, you could add or
    delete elements anytime from the list, it is a dynamic size array. This is one
    of the basic differences between array and `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to print this `ArrayList`, we can simply do that by adding the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On running, it prints `[rahul, java]`. But if you want to print this in arrays,
    we need to write a `for` loop. We add another object and this time we specify
    the index where we want the string to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print this, it gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the second line, `student` is added before `rahul` in the
    list as we have specified its index as `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove an entry from the list, we can do that by adding the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code will remove the entry from the list present at the first
    index, whereas the second line will find the string in the list and remove it.
    If you want to get the entry for a specific index, you can do that using the `get`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code will print `java` as the output, as it is the element
    present at index `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a list of 50 elements, and you need to find out whether
    a particular string/integer is present in that list. If you were to go with arrays,
    you would have to create a `for` loop and find out whether the element is present,
    but in `ArrayList`, we have a `contains` method that checks the entire list for
    us and gives the output in the form of `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will print the output as `true` as the element is present in our list;
    if you change it to, for example, `testing`, it will return the value as `false`
    as it is not present in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful method present in `ArrayList` is the `indexOf` method. If we
    want to find the index value of a particular element from the list, we can know
    that by using `indexOf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will return the index number of this string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to check whether the array is empty, we can do that using the `isEmpty`
    method in `ArrayList`, which will return the value as `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will return the value as `false` as our list is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last and most important method in `ArrayList` is the `size` method, which
    returns the length of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One more thing you need to know about `ArrayList` is that all the classes that
    implement the `List` interface can accept duplicate values. We know the classes
    that extend `List` in the collection interface: `ArrayList`, `LinkedList`, and
    `vector`. And all these classes can accept duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: Example of ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we have an array with duplicate numbers, such as `{4, 5, 5, 5, 4,
    6, 6, 9, 4}`, and we want to print out the unique number from this, and how many
    times this number is repeated in this array. Our output should be "four is repeated
    three times, five is repeated three times, six twice, nine once."
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bring in the `ArrayList` concept here to solve this puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We're done with the `for` and `if` loops. We print out each element from the
    array and the number of instances each element is present in the array. To print
    the unique number, that is, the number that is not repeated in the array, we use
    an `if` loop and print it.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for this example; you can try coding this example with your own logic.
  prefs: []
  type: TYPE_NORMAL
- en: The Set collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important collection present in Java is the `Set` collection/interface.
    `HashSet`, `TreeSet`, and `LinkedHashSet` are the three classes that implement
    the `Set` interface. The main difference between `Set` and `List` is that `Set`
    does not accept duplicate values. One more difference between the `Set` and `List`
    interfaces is that there is no guarantee that elements are stored in sequential
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mainly be discussing `HashSet` in this section. We will take an example
    class and try to understand this concept. Create a class and name it `hashSetexample`
    for this section, and create an object within the class to use `HashSet`; it''ll
    suggest you add the argument type, which is `String` in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In your IDE when you type `hs.`, it''ll show you all the methods provided by
    `HashSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43eefee7-fe95-435d-a7c3-e83ec95f6ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start by adding a few string instances of duplicate entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you print this, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We see that the duplicate entry for `INDIA` is rejected by `HashSet` and we
    only see one instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to remove any object, we can do so using the `remove` method, and
    to get the size of the list use the `size` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `isEmpty` method tells us whether the list is empty—if it's empty, it'll
    return `true`, otherwise it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To iterate through each element present within a list, we use the `iterator`
    method. We need to create another object for this `Iterator` class, along with
    the `String` argument type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we have a set of elements and they are in order starting from
    zero, one, two, and so on. `iterator` goes through each element starting from
    zero and prints the element present at each value. We have created an object for
    iterator and we print the values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first instance of `i.next()` will print the values present at the zero
    index and the next `i.next()` instance prints the value at index one. If we have
    a set where we have around 100 values, we will have to use the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `hasNext` method, which checks the set for next values.
    If there are values present in the next index, it'll return `true` and if not,
    it returns `false`. In our case, it'll return `true` for 100 values and `false`
    after that, and exit the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: This is how you can iterate through the objects present in the `Set` interface
    using `iterator`. If you are working on automation testing, such as Selenium,
    you'll be using this `while` loop frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The Map collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have one more collection, called `Map`. We will take an example and discuss `Map`
    as we proceed with the code. This interface takes the values in the form of a
    key and value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class, `hashMapexample`, and within that the we define `HashMap`.
    `HashMap` requires two types of argument, such as `Integer` and `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Integer` is the key and `String` is the value. Now if you type `hm.`
    in your IDE, you will see a few methods present in `HashMap`; let''s use the `put`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `put` method takes the input in the form of keys and values. Also, the
    value of the key needs to be an integer, it can be a string as well. The key is
    just something we define for the value. We can remove a value using the `remove`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entrySet` method in `HashMap` stores each key and value in the form of
    a set index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now converted this `HashMap` into a set. To traverse through each index
    of this set, we use `iterator` and, just like in the previous section, we use
    the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use `Map.Entry` here, as the element in each index consists of a
    key and a value, and `Map.Entry` helps us to separate out the keys and values.
    When you print this `while` loop, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Without using `Map.Entry`, it'll throw an error. This is how `HashMap` works.
  prefs: []
  type: TYPE_NORMAL
- en: HashTable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one more collection, called `HashTable`, but it lies along the same
    lines as `HashMap`. You just need to change `HashMap` to `HashTable`—that's it. There's
    a slight difference between `HashMap` and `HashTable` though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between `HashMap` and `HashTable` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized or thread-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null keys and null values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronized or thread-safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most important difference between the two. `HashMap` is non-synchronized
    and not thread-safe. So what is meant by non-synchronized? It means if multiple
    programs simultaneously access `HashMap`, it keeps on updating. Now let's say
    there are five threads working on `HashMap`. That means five different programs
    or threads can access `HashMap` at the same time, which means there is no synchronization.
    But in `HashTable`, if one program is accessing `HashTable`, the other program
    needs to wait until the first program releases the `HashTable` resources. That's
    the major difference. On the other hand, `HashTable` is thread-safe and synchronized.
    When should you use `HashMap`? If your application does not require a multithreading
    task—in other words, `HashMap` is better for non-threading applications. `HashTable` should
    be used in multithreading applications.
  prefs: []
  type: TYPE_NORMAL
- en: Null keys and null values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HashMap` allows one null key and any number of null values, while `HashTable`
    does not allow null keys and null values in the `HashTable` object. Let''s say
    you are entering employee records into a database and while uploading the employee
    details into your database, maybe you feel that you would not know their phone
    number, but you enter the field called phone number in a key value, and index
    value for now you would leave it as a null; you could update it later. This works
    in `HashMap`, but when you are working with `HashTable`, it will not allow any
    null keys and null values. If you feel that you want to make your program very
    secure and you want to block multiple threads from accessing it simultaneously,
    then you should go with `HashTable`. `HashTable` is thread-safe, and it will not
    release its object to another program until one program completes its operation
    on `HashTable`.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HashMap` object values are iterated by using `iterator`. `HashTable` is the
    only class other than vector which uses enumerator to iterate the values of the
    `HashTable` object.'
  prefs: []
  type: TYPE_NORMAL
- en: The operations are the same across `HashMap` and `HashTable`, except for the
    three differences we've just described.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we had a look at the collections framework and the three types
    of collection: `List`, `Set`, and `Map`. We explored `ArrayList` in the `List`
    collection, and also explored an example of `ArrayList`. The `Set` collection
    is different from `ArrayList`—the major difference is that `Set` does not accept
    duplicate values. In the last collection, that is, the `Map` collection, we saw
    two types, `HashMap` and `HashTable`, and the differences between the two.'
  prefs: []
  type: TYPE_NORMAL
