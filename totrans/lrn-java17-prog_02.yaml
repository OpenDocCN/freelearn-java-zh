- en: '*Chapter 1*: Getting Started with Java 17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Java 17 入门'
- en: This chapter is about how to start learning Java 17 and Java in general. We
    will begin with the basics, first explaining what Java is and its main terms,
    followed by how to install the necessary tools to write and run (execute) a program.
    In this respect, Java 17 is not much different from the previous Java versions,
    so this chapter’s content applies to the older versions too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何开始学习 Java 17 以及 Java 的一般知识。我们将从基础知识开始，首先解释什么是 Java 以及其主要术语，然后介绍如何安装编写和运行（执行）程序所需的工具。在这方面，Java
    17 与之前的 Java 版本没有太大区别，因此本章的内容也适用于旧版本。
- en: We will describe and demonstrate all the necessary steps for building and configuring
    a Java programming environment. This is the bare minimum that should have on your
    computer to start programming. We also describe the basic Java language constructs
    and illustrate them with examples that can be executed immediately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述并演示构建和配置 Java 编程环境所需的所有必要步骤。这是您计算机上开始编程所需的最基本内容。我们还描述了基本的 Java 语言结构，并通过可以立即执行的示例来展示它们。
- en: 'The best way to learn a programming language—or any language, for that matter—is
    to use it, and this chapter guides readers on how they can do this with Java.
    We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一种编程语言——或者任何语言，最好的方式是使用它，本章将指导读者如何使用 Java 来实现这一点。在本章中，我们将涵盖以下主题：
- en: How to install and run Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和运行 Java
- en: How to install and run an **integrated development environment** (**IDE**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和运行集成开发环境（**IDE**）
- en: Java primitive types and operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 原始类型和运算符
- en: String types and literals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型和字面量
- en: '**Identifiers** (**IDs**) and variables'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**（**IDs**）和变量'
- en: Java statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 语句
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，您需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: An IDE or your preferred code editor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 IDE 或您偏好的代码编辑器
- en: The instructions for how to set up a Java `examples/src/main/java/com/packt/learnjava/ch01_start`
    folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置 Java `examples/src/main/java/com/packt/learnjava/ch01_start` 文件夹的说明。
- en: How to install and run Java
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装和运行 Java
- en: 'When somebody says “*Java*”, they may mean quite different things. They could
    be referring to any of the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人说“*Java*”时，他们可能意味着完全不同的事情。他们可能指的是以下任何一个：
- en: '**Java programming language**: A high-level programming language that allows
    an intent (a program) to be expressed in a human-readable format that can be translated
    into binary code that is executable by a computer'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 编程语言**：一种高级编程语言，允许用人类可读的格式表达意图（程序），该格式可以被翻译成计算机可执行的二进制代码'
- en: '**Java compiler**: A program that can read a text written in the Java programming
    language and translate it into bytecode that can be interpreted by the **Java
    Virtual Machine** (**JVM**) into binary code that is executable by a computer'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 编译器**：一个程序，可以读取用 Java 编程语言编写的文本，并将其翻译成可以被 Java 虚拟机（**JVM**）解释的二进制代码，该代码可以被计算机执行'
- en: '**JVM**: A program that reads bytecode of the compiled Java program and interprets
    it into binary code that is executable by a computer'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM**：一个程序，读取编译好的 Java 程序的字节码，并将其解释成计算机可执行的二进制代码'
- en: '**Java Development Kit** (**JDK**): A collection of programs (tools and utilities),
    including the Java compiler, the JVM, and supporting libraries, which allow the
    compilation and execution of a program written in the Java language'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）：一组程序（工具和实用程序），包括 Java 编译器、JVM 和支持库，允许用 Java 语言编写的程序进行编译和执行'
- en: The following section walks you through the installation of the JDK of Java
    17 and the basic related terms and commands.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将指导您安装 Java 17 的 JDK 以及相关的基本术语和命令。
- en: What is the JDK and why do we need it?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 是什么以及为什么我们需要它？
- en: As we have mentioned already, the JDK includes a Java compiler and the JVM.
    The task of the compiler is to read a `.java` file that contains the text of a
    program written in Java (called source code) and transform (compile) it into bytecode
    stored in a `.class` file. The JVM can then read the `.class` file, interpret
    the bytecode into binary code, and send it to the operating system for execution.
    Both the compiler and the JVM have to be invoked explicitly from the command line.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，JDK包括Java编译器和JVM。编译器的任务是读取包含用Java编写的程序文本的`.java`文件（称为源代码），并将其转换（编译）成存储在`.class`文件中的字节码。然后JVM可以读取`.class`文件，将字节码解释成二进制代码，并将其发送到操作系统执行。编译器和JVM都必须从命令行显式调用。
- en: 'The hierarchy of languages used by Java programs goes like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序使用的语言层次结构如下：
- en: You write Java code (`.java` file).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你编写Java代码（`.java`文件）。
- en: The compiler converts your Java code into bytecode (`.class` file).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器将你的Java代码转换成字节码（`.class`文件）。
- en: The JVM converts the bytecode into machine-level assembly instructions (run
    on hardware).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM将字节码转换成机器级汇编指令（在硬件上运行）。
- en: 'Have a look at the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '`int a = b + c;`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`int a = b + c;`'
- en: 'When you write the preceding code, the compiler adds the following bytecode
    to the `.class` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写前面的代码时，编译器会将以下字节码添加到`.class`文件中：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Write once, run anywhere* is the most famous programming marketing jingle
    driving worldwide adoption. Oracle claims more than 10 million developers use
    Java, which runs on 13 billion devices. You write Java and compile it into bytecode
    in `.class` files. There is a different JVM for Windows, Mac, Unix, Linux, and
    more, but the same `.class` file works on all of them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次编写，到处运行* 是最著名的编程营销口号，推动了全球的采用。Oracle声称超过1000万开发者使用Java，它在130亿台设备上运行。你编写Java代码，并将其编译成`.class`文件中的字节码。对于Windows、Mac、Unix、Linux等操作系统，都有不同的JVM，但相同的`.class`文件可以在所有这些操作系统上运行。'
- en: To support the `.java` file compilation and its bytecode execution, the JDK
    installation also includes standard Java libraries called the **Java Class Library**
    (**JCL**). If the program uses a third-party library, it has to be present during
    compilation and execution. It has to be referred from the same command line that
    invokes the compiler, and later when the bytecode is executed by the JVM. JCL,
    on the other hand, does not need to be referred to explicitly. It is assumed that
    the standard Java libraries reside in the default location of the JDK installation
    so that the compiler and the JVM know where to find them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`.java`文件的编译及其字节码执行，JDK安装还包括称为**Java类库**（**JCL**）的标准Java库。如果程序使用第三方库，它必须在编译和执行期间存在。它必须从调用编译器的相同命令行引用，后来当字节码由JVM执行时也是如此。另一方面，JCL不需要显式引用。假设标准Java库位于JDK安装的默认位置，以便编译器和JVM知道它们的位置。
- en: If you do not need to compile a Java program and would like to run only the
    already compiled `.class` files, you can download and install the **Java Runtime
    Environment** (**JRE**). For example, it consists of a subset of the JDK and does
    not include a compiler.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要编译Java程序，只想运行已经编译好的`.class`文件，你可以下载并安装**Java运行环境**（**JRE**）。例如，它包括JDK的一个子集，但不包括编译器。
- en: Sometimes, the JDK is referred to as a **software development kit** (**SDK**),
    which is a general name for a collection of software tools and supporting libraries
    that allow the creation of an executable version of source code written using
    a certain programming language. So, the JDK is an SDK for Java. This means it
    is possible to call the JDK an SDK.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，JDK被称为**软件开发工具包**（**SDK**），这是一个集合软件工具和支持库的通用名称，允许使用某种编程语言编写的源代码创建可执行版本。因此，JDK是Java的SDK。这意味着可以将JDK称为SDK。
- en: 'You may also hear the terms *Java platform* and *Java edition* applied to the
    JDK. A typical platform is an operating system that allows a software program
    to be developed and executed. Since the JDK provides its own operating environment,
    it is called a platform too. An edition is a variation of a Java platform (JDK)
    assembled for a specific purpose. There are four Java platform editions, as listed
    here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能听到将*Java平台*和*Java版本*应用于JDK的术语。一个典型的平台是一个操作系统，它允许软件开发和执行。由于JDK提供了自己的操作系统环境，因此它也被称为平台。版本是针对特定目的组装的Java平台（JDK）的变体。这里有四个Java平台版本，如下所示：
- en: '**Java Platform SE** (**Java SE**): This includes the JVM, JCL, and other tools
    and utilities.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台SE** (**Java SE**): 这包括JVM、JCL以及其他工具和实用程序。'
- en: '**Java Platform Enterprise Edition** (**Java EE**): This includes Java SE,
    servers (computer programs that provide services to the applications), JCL, other
    libraries, code samples, tutorials, and other documentation for developing and
    deploying large-scale, multi-tiered, and secure network applications.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台企业版** (**Java EE**): 这包括Java SE、服务器（为应用程序提供服务的计算机程序）、JCL、其他库、代码示例、教程和其他用于开发部署大规模、多层和安全的网络应用程序的文档。'
- en: '**Java Platform Micro Edition** (**Java ME**): This is a subset of Java SE
    with some specialized libraries for developing and deploying Java applications
    for embedded and mobile devices, such as phones, personal digital assistants,
    TV set-top boxes, printers, and sensors. A variation of Java ME (with its own
    JVM implementation) is called the Android SDK, which was developed by Google for
    Android programming.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java平台微型版** (**Java ME**): 这是Java SE的一个子集，包含一些用于开发并将Java应用程序部署到嵌入式和移动设备（如手机、个人数字助理、机顶盒、打印机和传感器）的专用库。Java
    ME的一个变体（具有自己的JVM实现）称为Android SDK，它是Google为Android编程开发的。'
- en: '**Java Card**: This is the smallest of the Java editions and is intended for
    developing and deploying Java applications onto small embedded devices such as
    smart cards. It has two editions: Java Card Classic Edition, for smart cards,
    (based on **International Organization for Standardization** (**ISO**) *7816*
    and ISO *14443* communication), and Java Card Connected Edition, which supports
    a web application model and **Transmission Control Protocol/Internet Protocol**
    (**TCP/IP**) as a basic protocol and runs on high-end secure microcontrollers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Card**: 这是Java版本中最小的一个，旨在开发并将Java应用程序部署到小型嵌入式设备上，例如智能卡。它有两个版本：Java Card经典版，用于智能卡（基于**国际标准化组织**
    (**ISO**) 7816和ISO 14443通信），以及Java Card连接版，它支持Web应用程序模型，并以**传输控制协议/互联网协议** (**TCP/IP**)作为基本协议，运行在高性能安全微控制器上。'
- en: So, to install Java means to install the JDK, which also means to install the
    Java platform on one of the listed editions. In this book, we are going to talk
    about and use only Java SE (which includes the JVM, JCL, and other tools and utilities
    necessary to compile your Java program into bytecode, interpret it into binary
    code, and automatically send it to your operating system for execution).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，安装Java意味着安装JDK，这也意味着在列出的版本之一上安装Java平台。在这本书中，我们将讨论并使用Java SE（它包括JVM、JCL以及其他将您的Java程序编译成字节码、解释成二进制代码并将其自动发送到您的操作系统以执行所需的工具和实用程序）。
- en: Installing Java SE
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Java SE
- en: All the recently released JDKs are listed on the official Oracle page at [https://www.oracle.com/java/technologies/downloads/#java17](https://www.oracle.com/java/technologies/downloads/#java17)
    (we will call this the *installation home page* for further references in later
    chapters).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最近发布的JDK都在官方Oracle页面上列出，请参阅[https://www.oracle.com/java/technologies/downloads/#java17](https://www.oracle.com/java/technologies/downloads/#java17)（我们将在后续章节中将其称为*安装主页*）。
- en: 'Here are the steps that need to be followed to install Java SE:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Java SE需要遵循以下步骤：
- en: Select the Java SE tab with your operating system.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的操作系统选择Java SE选项卡。
- en: Click on the link to the installer that fits your operating system and the format
    (extension) you are familiar with.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击适合您操作系统和熟悉格式的（扩展名）安装程序的链接。
- en: If in doubt, click the **Installation Instructions** link below and read the
    installation instructions for your operating system.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有疑问，请点击下面的**安装说明**链接，并阅读您操作系统的安装说明。
- en: Follow the steps that correspond to your operating system.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照与您的操作系统对应的步骤进行操作。
- en: 'The JDK is installed successfully when the `java -version` command on your
    computer displays the correct Java version, as demonstrated in the following example
    screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的计算机上的`java -version`命令显示正确的Java版本时，JDK安装成功，如下面的示例截图所示：
- en: '![](img/B18388_Figure_1.1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.1.jpg)'
- en: Commands, tools, and utilities
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令、工具和实用程序
- en: If you follow the installation instructions, you may have noticed a link (`bin`
    directory contains all executables that constitute Java commands, tools, and utilities.
    If the `bin` directory is not added to the `PATH` environment variable automatically,
    consider doing so manually so that you can launch a Java executable from any directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循安装说明，你可能已经注意到一个链接（`bin` 目录包含构成 Java 命令、工具和实用程序的 所有可执行程序。如果 `bin` 目录没有自动添加到
    `PATH` 环境变量中，请考虑手动添加，这样你就可以从任何目录启动 Java 可执行程序。
- en: In the previous section, we have already demonstrated the `java -version` Java
    command. A list of the other Java executables available (commands, tools, and
    utilities) can be found in the Java SE documentation ([https://www.oracle.com/technetwork/java/javase/documentation/index.html](https://www.oracle.com/technetwork/java/javase/documentation/index.html))
    by clicking the **Java Platform Standard Edition Technical Documentation** site
    link, and then the **Tools Reference link** on the next page. You can learn more
    about each executable tool by clicking its link.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经展示了 `java -version` Java 命令。其他可用的 Java 可执行程序（命令、工具和实用程序）的列表可以在 Java
    SE 文档中找到（[https://www.oracle.com/technetwork/java/javase/documentation/index.html](https://www.oracle.com/technetwork/java/javase/documentation/index.html)），通过点击
    **Java 平台标准版技术文档** 网站链接，然后点击下一页上的 **工具参考链接**。你可以通过点击其链接来了解更多关于每个可执行工具的信息。
- en: 'You can also run each of the listed executables on your computer using one
    of the following options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下选项之一在你的计算机上运行列出的每个可执行程序：
- en: '`-?`, `-h`, `--help`, or `-help`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`-?`, `-h`, `--help` 或 `-help`'
- en: These will display a brief description of the executable and all its options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将显示可执行程序的简要描述及其所有选项。
- en: 'The most important Java commands are listed here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了最重要的 Java 命令：
- en: '`javac`: This reads a `.java` file, compiles it, and creates one or more corresponding
    `.class` files, depending on how many Java classes are defined in the `.java`
    file.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`: 这将读取 `.java` 文件，编译它，并创建一个或多个相应的 `.class` 文件，具体取决于 `.java` 文件中定义了多少个
    Java 类。'
- en: '`java`: This executes a `.class` file.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`: 这将执行 `.class` 文件。'
- en: These are the commands that make programming possible. Every Java programmer
    must have a good understanding of their structure and capabilities, but if you
    are new to Java programming and use an IDE (see the *How to install and run an
    IDE* section), you do not need to master these commands immediately. A good IDE
    hides them from you by compiling a `.java` file automatically every time you make
    a change to it. It also provides a graphical element that runs the program every
    time you click it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使编程成为可能命令。每个 Java 程序员都必须对其结构和功能有良好的理解，但如果你是 Java 编程的新手并使用 IDE（见 *如何安装和运行
    IDE* 部分），你不需要立即掌握这些命令。一个好的 IDE 通过每次你对其 `.java` 文件进行更改时自动编译它来隐藏它们。它还提供了一个图形元素，每次你点击它时都会运行程序。
- en: Another very useful Java tool is jcmd. This facilitates communication with,
    and diagnosis of, any currently running Java processes (JVM) and has many options.
    But in its simplest form, without any option, it lists all currently running Java
    processes and their **process IDs** (**PIDs**). You can use it to see whether
    you have runaway Java processes. If you have, you can then kill such a process
    using the PID provided.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的 Java 工具是 jcmd。它便于与任何当前运行的 Java 进程（JVM）进行通信和诊断，并且有许多选项。但在最简单的形式下，不使用任何选项，它将列出所有当前运行的
    Java 进程及其 **进程 ID**（**PID**）。你可以用它来查看你是否存在失控的 Java 进程。如果有，你可以使用提供的 PID 来终止这样的进程。
- en: How to install and run an IDE
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装和运行 IDE
- en: What used to be just a specialized editor that allowed checking the syntax of
    a written program the same way a Word editor checks the syntax of an English sentence
    gradually evolved into an IDE. This bears its main function in the name. It integrates
    all the tools necessary for writing, compiling, and then executing a program under
    one **graphical user interface** (**GUI**). Using the power of Java compiler,
    the IDE identifies syntax errors immediately and then helps to improve code quality
    by providing context-dependent help and suggestions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最初只是一个专门编辑器，允许以与 Word 编辑器检查英语句子语法相同的方式检查编写程序的语法，逐渐演变成集成开发环境（IDE）。它的主要功能体现在名称上。它将编写、编译和执行程序所需的所有工具集成在一个
    **图形用户界面**（**GUI**）下。利用 Java 编译器的功能，IDE 可以立即识别语法错误，并通过提供上下文相关的帮助和建议来帮助提高代码质量。
- en: Selecting an IDE
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 IDE
- en: 'There are several IDEs available for a Java programmer, such as NetBeans, Eclipse,
    IntelliJ IDEA, BlueJ, DrJava, JDeveloper, JCreator, jEdit, JSource, and jCRASP,
    to name a few. You can read a review of the top Java IDEs and details about each
    by following this link: [https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers](https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers).
    The most popular ones are NetBeans, Eclipse, and IntelliJ IDEA.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 程序员来说，有多个 IDE 可用，例如 NetBeans、Eclipse、IntelliJ IDEA、BlueJ、DrJava、JDeveloper、JCreator、jEdit、JSource
    和 jCRASP 等。您可以通过以下链接阅读顶级 Java IDE 的评测和每个 IDE 的详细信息：[https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers](https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers)。最受欢迎的当属
    NetBeans、Eclipse 和 IntelliJ IDEA。
- en: NetBeans development started in 1996 as a Java IDE student project at Charles
    University in Prague. In 1999, the project and the company created around the
    project were acquired by Sun Microsystems. After Oracle acquired Sun Microsystems,
    NetBeans became open source, and many Java developers have since contributed to
    the project. It was bundled with JDK 8 and became an official IDE for Java development.
    In 2016, Oracle donated it to the Apache Software Foundation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的开发始于 1996 年，当时在布拉格的查尔斯大学作为 Java IDE 学生项目启动。1999 年，该项目及其周围的公司被 Sun
    Microsystems 收购。在 Oracle 收购 Sun Microsystems 之后，NetBeans 成为了开源项目，许多 Java 开发者随后为该项目做出了贡献。它随
    JDK 8 一起捆绑发布，并成为了 Java 开发的官方 IDE。2016 年，Oracle 将其捐赠给了 Apache 软件基金会。
- en: There is a NetBeans IDE for Windows, Linux, Mac, and Oracle Solaris. It supports
    multiple programming languages and can be extended with plugins. As of the time
    of writing, NetBeans is bundled only with JDK 8, but NetBeans 8.2 can work with
    JDK 9 too and uses features introduced with JDK 9 such as Jigsaw, for example.
    On [netbeans.apache.org](http://netbeans.apache.org), you can read more about
    the NetBeans IDE and download the latest version, which is 12.5 as of the time
    of this writing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans IDE 支持Windows、Linux、Mac 和 Oracle Solaris 系统。它支持多种编程语言，并且可以通过插件进行扩展。截至撰写本文时，NetBeans
    仅与 JDK 8 捆绑，但 NetBeans 8.2 也可以与 JDK 9 一起使用，并使用 JDK 9 引入的特性，例如 Jigsaw。在 [netbeans.apache.org](http://netbeans.apache.org)
    上，您可以了解更多关于 NetBeans IDE 的信息，并下载最新版本，撰写本文时版本为 12.5。
- en: '*Eclipse* is the most widely used Java IDE. The list of plugins that add new
    features to the IDE is constantly growing, so it is not possible to enumerate
    all the IDE’s capabilities. The Eclipse IDE project has been developed since 2001
    as **open source software** (**OSS**). A non-profit, member-supported corporation
    Eclipse Foundation was created in 2004 to provide the infrastructure (**version
    control systems** (**VCSs**), code review systems, build servers, download sites,
    and so on) and a structured process. None of the 30-something employees of the
    Eclipse Foundation is working on any of the 150 Eclipse-supported projects.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse* 是最广泛使用的 Java IDE。为 IDE 添加新功能的插件列表不断增长，因此无法一一列举 IDE 的所有功能。Eclipse
    IDE 项目自 2001 年以来作为 **开源软件**（**OSS**）进行开发。2004 年，成立了非营利性、会员支持的 Eclipse 基金会，以提供基础设施（**版本控制系统**（**VCSs**）、代码审查系统、构建服务器、下载站点等）和结构化流程。Eclipse
    基金会的 30 多名员工中没有人在 150 个 Eclipse 支持的项目上工作。'
- en: The sheer number and variety of Eclipse IDE plugins create a certain challenge
    for a beginner because you have to find your way around different implementations
    of the same—or similar—features that can, on occasion, be incompatible and may
    require deep investigation, as well as a clear understanding of all the dependencies.
    Nevertheless, the Eclipse IDE is very popular and has solid community support.
    You can read about the Eclipse IDE and download the latest release from [www.eclipse.org/ide](http://www.eclipse.org/ide).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse IDE 插件的数量和种类繁多，对于初学者来说构成了一定的挑战，因为您需要熟悉不同实现方式相同或类似的功能，这些功能有时可能不兼容，可能需要进行深入调查，并清楚了解所有依赖关系。尽管如此，Eclipse
    IDE 非常受欢迎，并且拥有坚实的社区支持。您可以在 [www.eclipse.org/ide](http://www.eclipse.org/ide) 上了解
    Eclipse IDE 并下载最新版本。
- en: 'IntelliJ IDEA has two versions: a paid one and a free community edition. The
    paid version is consistently ranked as the best Java IDE, but the community edition
    is listed among the three leading Java IDEs too. The JetBrains software company
    that develops the IDE has offices in Prague, Saint Petersburg, Moscow, Munich,
    Boston, and Novosibirsk. The IDE is known for its deep intelligence that is “*giving
    relevant suggestions in every context: instant and clever code completion, on-the-fly
    code analysis, and reliable refactoring tools*”, as stated by the authors while
    describing the product on their website ([www.jetbrains.com/idea](http://www.jetbrains.com/idea)).
    In the *Installing and configuring IntelliJ IDEA* section, we will walk you through
    the installation and configuration of IntelliJ IDEA’s community edition.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 有两个版本：付费版和免费社区版。付费版一直被评为最佳 Java IDE，但社区版也被列为三大领先 Java IDE 之一。开发该
    IDE 的 JetBrains 软件公司在布拉格、圣彼得堡、莫斯科、慕尼黑、波士顿和诺沃西比尔斯克设有办事处。该 IDE 以其深入智能而闻名，正如作者在网站上描述产品时所说：“*在任何上下文中提供相关建议：即时且聪明的代码补全、即时代码分析以及可靠的重构工具*”。在*安装和配置
    IntelliJ IDEA*部分，我们将向您介绍 IntelliJ IDEA 社区版的安装和配置过程。
- en: Installing and configuring IntelliJ IDEA
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 IntelliJ IDEA
- en: 'These are the steps you need to follow in order to download and install IntelliJ
    IDEA:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要遵循的步骤来下载和安装 IntelliJ IDEA：
- en: Download an installer of the IntelliJ community edition from [www.jetbrains.com/idea/download](http://www.jetbrains.com/idea/download).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [www.jetbrains.com/idea/download](http://www.jetbrains.com/idea/download)
    下载 IntelliJ IDEA 社区版的安装程序。
- en: Launch the installer and accept all the default values.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动安装程序并接受所有默认值。
- en: Select `.java` on the **Installation Options** screen. We assume you have installed
    the JDK already, so you do not check the **Download and install JRE** option.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**安装选项**屏幕上选择`.java`。我们假设你已经安装了 JDK，所以你不需要勾选**下载并安装 JRE**选项。
- en: The last installation screen has a **Run IntelliJ IDEA** checkbox that you can
    check to start the IDE automatically. Alternatively, you can leave the checkbox
    unchecked and launch the IDE manually once the installation is complete.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个安装屏幕有一个**运行 IntelliJ IDEA**复选框，你可以勾选以自动启动IDE。或者，你可以在安装完成后手动启动IDE，不勾选复选框。
- en: When the IDE starts for the first time, it provides you with an **Import IntelliJ
    IDEA settings** option. Check the **Do not import settings** checkbox if you have
    not used IntelliJ IDEA before.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当IDE首次启动时，它会提供一个**导入 IntelliJ IDEA 设置**选项。如果你之前没有使用过 IntelliJ IDEA，请勾选**不导入设置**复选框。
- en: The next couple of screens ask whether you accept the **JetBrains Privacy Policy**
    and whether you would like to pay for the license or prefer to continue to use
    the free community edition or free trial (this depends on the particular download
    you get).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几个屏幕会询问你是否接受**JetBrains隐私政策**，以及你是否愿意为许可证付费或更喜欢继续使用免费社区版或免费试用版（这取决于你下载的具体版本）。
- en: 'Answer the questions whichever way you prefer, and if you accept the privacy
    policy, the **Customize IntelliJ IDEA** screen will ask you to choose a theme:
    **white (IntelliJ)** or **dark (Darcula)**.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照你喜欢的任何方式回答问题，如果你接受隐私政策，**自定义 IntelliJ IDEA**屏幕将要求你选择一个主题：**白色（IntelliJ）**或**深色（Darcula）**。
- en: Accept the default settings.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受默认设置。
- en: If you decide to change the set values, you can do so later by selecting from
    the topmost menu, **File** | **Settings**, on Windows, or **Preferences** on Linux
    and macOS.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你决定更改设置值，你可以在稍后通过选择最顶部的菜单**文件** | **设置**（在 Windows 上）或**首选项**（在 Linux 和 macOS
    上）来更改。
- en: Creating a project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Before you start writing your program, you need to create a project. There
    are several ways to create a project in IntelliJ IDEA, which is the same for any
    IDE, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写程序之前，你需要创建一个项目。在 IntelliJ IDEA 中创建项目有几种方法，这与任何 IDE 都相同，如下所示：
- en: '**New Project**: This creates a new project from scratch.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新建项目**：这将从零开始创建一个新项目。'
- en: '**Open**: This facilitates reading of the existing project from the filesystem.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开**：这有助于从文件系统中读取现有项目。'
- en: '**Get from VCS**: This facilitates reading of the existing project from the
    VCS.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从版本控制系统获取**：这有助于从版本控制系统读取现有项目。'
- en: In this book, we will walk you through the first option only—using the sequence
    of guided steps provided by the IDE. Options *2* and *3* include many settings
    that are automatically set by importing an existing project that has those settings.
    Once you have learned how to create a new project from scratch, the other ways
    to bring up a project in the IDE will be very easy for you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by clicking the **New Project** link and proceed further as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Select **Maven** in the left panel and a value for **Project SDK** (Java Version
    17, if you have installed JDK 17 already), and click **Next**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Maven is a project configuration tool whose primary function is to manage project
    dependencies. We will talk about it shortly. For now, we will use its other responsibility:
    to define and hold the project code identity using three **Artifact Coordinates**
    properties (see next).'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the project name—for example, `myproject`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the desired project location in the **Location field** setting (this
    is where your new code will reside).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `GroupId`: This is the base package name that identifies a group of projects
    within an organization or an open source community. In our case, l et''s type
    `com.mywork`.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ArtifactId`: To identify a particular project within the group. Leave it as
    `myproject`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Version`: To identify the version of the project. Leave it as `1.0-SNAPSHOT`.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main goal is to make the identity of a project unique among all projects
    in the world. To help avoid a `GroupId` clash, the convention requires that you
    start building it from the organization domain name in reverse. For example, if
    a company has a `company.com` domain name, the `GroupId` properties of its projects
    should start with `com.company`. That is why for this demonstration we use `com.mywork`,
    and for the code in this book, we use the `com.packt.learnjava` `GroupID` value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following project structure and generated `pom.xml` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.2.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Now, if somebody would like to use the code of your project in their application,
    they would refer to it by the three values shown, and Maven (if they use it) will
    bring it in (if you upload your project to the publicly shared Maven repository,
    of course). Read more about Maven at [https://maven.apache.org/guides](https://maven.apache.org/guides).
    Another function of the `GroupId` value is to define the root directory of the
    folders tree that holds your project code. The `java` folder under `main` will
    hold the application code, while the `java` folder under `test` will hold the
    test code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our first program using the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on `java`, select **New**, and then click **Package**, as illustrated
    in the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.3.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: In the `com.mywork.myproject` and press *Enter*.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see in the left panel the following set of new folders:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.4.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on `com.mywork.myproject`, select **New**, and then click **Java
    Class**, as illustrated in the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`com.mywork.myproject`，选择**新建**，然后点击**Java类**，如下面的截图所示：
- en: '![](img/B18388_Figure_1.5.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.5.jpg)'
- en: In the input window provided, type `HelloWorld`, as follows:![](img/B18388_Figure_1.6.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的输入窗口中，键入`HelloWorld`，如下所示：![](img/B18388_Figure_1.6.jpg)
- en: 'Press *Enter* and you will see your first Java class, `HelloWorld`, created
    in the `com.mywork.myproject` package, as illustrated in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*键，您将看到在`com.mywork.myproject`包中创建的第一个Java类`HelloWorld`，如下面的截图所示：
- en: '![](img/B18388_Figure_1.7.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.7.jpg)'
- en: 'The package reflects the Java class location in the filesystem. We will talk
    about this more in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java
    Object-Oriented Programming (OOP)*. Now, in order to run a program, we create
    a `main()` method. If present, this method can be executed to serve as an entry
    point into the application. It has a certain format, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该包反映了Java类在文件系统中的位置。我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中更详细地讨论这一点。现在，为了运行一个程序，我们创建一个`main()`方法。如果存在，此方法可以被执行，作为进入应用程序的入口点。它具有特定的格式，如下所示：
- en: '![](img/B18388_Figure_1.8.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.8.jpg)'
- en: 'This has to have the following attributes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须具有以下属性：
- en: '`public`: Freely accessible from outside the package'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：可以从包外部自由访问'
- en: '`static`: Should be able to be called without creating an object of the class
    it belongs to'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`：应该能够在不创建它所属的类对象的情况下调用'
- en: 'It should also have the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它还应该有以下内容：
- en: Return `void` (nothing)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`void`（无）
- en: Accept a `String` array as an input, or `varargs`, as we have done. We will
    talk about `varargs` in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. For now, suffice to say that `String[]
    args` and `String... args` essentially define the same input format.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个`String`数组作为输入，或者`varargs`，正如我们所做的那样。我们将在[*第2章*](B18388_02_ePub.xhtml#_idTextAnchor045)，*Java面向对象编程（OOP）*中讨论`varargs`。现在，只需说`String[]
    args`和`String... args`基本上定义了相同的输入格式。
- en: We explain how to run the `main` class using a command line in the *Executing
    examples from the command line* section. You can read more about Java command-line
    arguments in the official Oracle documentation at [https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html](https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html).
    It is also possible to run the examples from IntelliJ IDEA.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用命令行执行示例*部分，我们解释了如何使用命令行运行`main`类。您可以在官方Oracle文档中了解更多关于Java命令行参数的信息：[https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html](https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html)。您也可以从IntelliJ
    IDEA中运行这些示例。
- en: Notice the two green triangles to the left in the screenshot shown next. By
    clicking any of them, you can execute the `main()` method. For example, let’s
    display `Hello, world!`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意下一张截图左侧的两个绿色三角形。通过单击其中的任何一个，您可以执行`main()`方法。例如，让我们显示`Hello, world!`。
- en: 'In order to do this, type the following line inside the `main()` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请在`main()`方法中键入以下行：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows how the program should look afterward:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序运行后的样子：
- en: '![](img/B18388_Figure_1.9.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.9.jpg)'
- en: 'Then, click one of the green triangles, and you should get the following output
    in the Terminal area:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击一个绿色三角形，您应该在终端区域得到以下输出：
- en: '![](img/B18388_Figure_1.10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_1.10.jpg)'
- en: 'From now on, every time we are going to discuss code examples, we will run
    them the same way, by using the `main()` method. While doing this, we will not
    capture a screenshot but put the result in comments, because such a style is easier
    to follow. For example, the following code snippet displays how the previous code
    demonstration would look in this style:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们将讨论代码示例时，我们都会以相同的方式运行它们，即使用`main()`方法。在这样做的时候，我们不会捕获截图，而是将结果放在注释中，因为这种风格更容易跟随。例如，以下代码片段显示了之前的代码演示将以这种方式看起来：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is possible to add a comment (any text) to the right of the code line separated
    by a double slash `//`. The compiler does not read this text and just keeps it
    as it is. The presence of a comment does not affect performance and is used to
    explain the programmer’s intent to humans.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在代码行的右侧添加注释（任何文本），用双斜杠`//`分隔。编译器不会读取此文本，只是将其保持原样。注释的存在不会影响性能，并且用于向人类解释程序员的意图。
- en: Importing a project
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入项目
- en: We are going to demonstrate project importing using the source code for this
    book. We assume that you have Maven installed ([https://maven.apache.org/install.html](https://maven.apache.org/install.html))
    on your computer and that you have Git ([https://gist.github.com/derhuerst/1b15ff4652a867391f03](https://gist.github.com/derhuerst/1b15ff4652a867391f03))
    installed too, and can use it. We also assume that you have installed JDK 17,
    as was described in the *Installing Java SE* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the project with the code examples for this book, follow these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Go to the source repository ([https://github.com/PacktPublishing/Learn-Java-17-Programming](https://github.com/PacktPublishing/Learn-Java-17-Programming))
    and click the **Code** drop-down menu, as shown in the following screenshot:![](img/B18388_Figure_1.11.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the provided **Uniform Resource Locator** (**URL**) (click the *copy*
    symbol to the right of the URL), as illustrated in the following screenshot:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Select a directory on your computer where you would like the source code to
    be placed and then run the `git clone https://github.com/PacktPublishing/Learn-Java-17-Programming.git`
    Git command and observe similar output to that shown in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: A new `Learn-Java-17-Programming` folder is created.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, instead of cloning, you can download the source as a `.zip` file
    using the `Download ZIP` link shown in the screenshot just before. Unarchive the
    downloaded source in a directory on your computer where you would like the source
    code to be placed, and then rename the newly created folder by removing the `-master`
    suffix from its name, making sure that the folder’s name is `Learn-Java-17-Programming`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The new `Learn-Java-17-Programming` folder contains the Maven project with all
    the source code from this book. If you prefer, you can rename this folder however
    you like. In our case, we renamed it `LearnJava` for brevity.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run IntelliJ IDEA and click `LearnJava`, in our case), then click the **Open**
    button.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the following popup shows in the bottom-right corner, click **Load**:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Also, click **Trust project...**, as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.15.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Then, click the **Trust Project** button on the following popup:![](img/B18388_Figure_1.16.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to **Project Structure** (cogwheel symbol in the upper-right corner)
    and make sure that Java 17 is selected as an SDK, as shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: Click **Apply** and make sure that the default **Project SDK** is set to Java
    **version 17** and **Project language level** is set to **17**, as in the following
    screenshot:![](img/B18388_Figure_1.18.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `LearnJava` module by selecting it and clicking `"-"`, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Confirm the `LearnJava` module removal on the popup by clicking **Yes**, as
    follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.20.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Here's how the final list of modules should look:![](img/B18388_Figure_1.21.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **OK** in the bottom-right corner and get back to your project. Click
    examples in the left pane and continue going down the source tree until you see
    the following list of classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.22.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Click on the green arrow in the right pane and execute the `main()` method
    of any class you want. For example, let’s execute the `main()` method of the `PrimitiveTypes`
    class. The result you will be able to see in the **Run** window should be similar
    to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.23.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Executing examples from the command line
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute the examples from the command line, go to the `examples` folder,
    where the `pom.xml` file is located, and run the `mvn clean package` command.
    If the command is executed successfully, you can run any `main()` method in any
    of the programs in the `examples` folder from the command line. For example, to
    execute the `main()` method in the `ControlFlow.java` file, run the following
    command as one line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see the following results:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.24.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: This way, you can run any class that has the `main()` method in it. The content
    of the `main()` method will be executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Java primitive types and operators
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the main programming tools in place, we can start talking about Java
    as a language. The language syntax is defined by the *Java Language Specification*,
    which you can find at [https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs).
    Don’t hesitate to refer to it every time you need some clarification—it is not
    as daunting as many people assume.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'All the values in Java are divided into two categories: reference types and
    primitive types. We start with primitive types and operators as the natural entry
    point to any programming language. In this chapter, we will also discuss one reference
    type called `String` (see the *String types and literals* section).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'All primitive types can be divided into two groups: Boolean types and numeric
    types.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Boolean types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only two Boolean type values in Java: `true` and `false`. Such a
    value can only be assigned to a variable of a `boolean` type, as in the following
    example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `boolean` variable is typically used in control flow statements, which we
    are going to discuss in the *Java statements* section. Here is one example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we assign to the `b` variable the result of the evaluation
    of the `x > 2` expression. If the value of `x` is greater than `2`, the `b` variable
    gets the assigned value, `true`. Then, the code inside the braces (`{}`) is executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Numeric types
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java numeric types form two groups: integral types (`byte`, `char`, `short`,
    `int`, and `long`) and floating-point types (`float` and `double`).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Integral types
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integral types consume the following amount of memory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: 8 bits'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: 16 bits'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: 16 bits'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32 bits'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64 bits'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `char` type is an unsigned integer that can hold a value (called a code
    point) from 0 to 65,535 inclusive. It represents a Unicode character, which means
    there are 65,536 Unicode characters. Here are three records from the basic Latin
    list of Unicode characters:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Table_1.1.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'The following code demonstrates the properties of the `char` type (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `charType()` method):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last two lines from the preceding code example explain why the `char` type
    is considered an integral type because `char` values can be used in arithmetic
    operations. In such a case, each `char` value is represented by its code point.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of values of other integral types is shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: from -128 to 127 inclusive'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: from -32,768 to 32,767 inclusive'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: from -2.147.483.648 to 2.147.483.647 inclusive'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can always retrieve the maximum and minimum value of each primitive type
    from a corresponding Java constant, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see the `minMax()` method):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The construct (`int`) in the last two lines is an example of cast operator usage.
    It forces the conversion of a value from one type to another in cases where such
    a conversion is not always guaranteed to be successful. As you can see from our
    examples, some types allow bigger values than other types. But a programmer may
    know that the value of a certain variable can never exceed the maximum value of
    the target type, and the cast operator is the way the programmer can force their
    opinion on the compiler. Otherwise, without a cast operator, the compiler would
    raise an error and would not allow the assignment. However, the programmer may
    be mistaken and the value may become bigger. In such a case, a runtime error will
    be raised during execution time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: There are types that, in principle, cannot be cast to other types, though, or
    at least not to all types—for example, a Boolean type value cannot be cast to
    an integral type value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types in this group of primitive types—`float` and `double`.
    These consume the following amount of memory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '`float`: 32 bit'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: 64 bit'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their positive maximum and minimum possible values are shown here (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `minMax()` method):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The maximum and minimum negative values are the same as those just shown, only
    with a minus sign (`-`) in front of them. So, effectively, the `Float.MIN_VALUE`
    and `Double.MIN_VALUE` values are not the minimal values, but the precision of
    the corresponding type. A zero value can be either 0.0 or -0.0 for each of the
    floating-point types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'A special feature of the floating-point type is the presence of a dot (`.`)
    that separates integer and fractional parts of the number. By default, in Java,
    a number with a dot is assumed to be a `double` type. For example, the following
    is assumed to be a `double` value:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`42.3`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the following assignment causes a compilation error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To indicate that you would like it to be treated as a `float` type, you need
    to add either `f` or `F`. For example, the following assignments do not cause
    an error (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `casting()` method):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you may have noticed from the preceding example, `d` and `D` indicate a `double`
    type, but we were able to cast them to the `float` type because we are confident
    that `42.3` is well inside the range of possible `float`-type values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Default values of primitive types
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, a variable has to be assigned a value even when a programmer
    did not want to do that. We will talk about such cases in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. The default primitive type value in
    such cases is outlined here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`, `short`, `int`, and `long` types have a default value of 0.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `char` type has a default value of `\u0000`, with the code point 0\.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` and `double` types have a default value of 0.0.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boolean` type has a default value of `false`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literals of primitive types
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The representation of a value is called a literal. The `boolean` type has two
    literals: `true` and `false`. Literals of `byte`, `short`, `int`, and `long` integral
    types have an `int` type by default, as illustrated here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In addition, to indicate a literal of a `long` type, you can append the letter
    `l` or `L` to the end, like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The letter `l` can be easily confused with the number `1`, so using `L` (instead
    of `l`) for this purpose is a good practice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have expressed integral literals in a decimal number system. Meanwhile,
    literals of `byte`, `short`, `int`, and `long` types can also be expressed in
    binary (base 2, digits 0-1), octal (base 8, digits 0-7), and hexadecimal (base
    16, digits 0-9, and a-f) number systems. A binary literal starts with 0b (or 0B),
    followed by the value expressed in a binary system. For example, the decimal 42
    is expressed as 101010 = 2^0*0 + 2^1*1 + 2^2*0 + 2^3 *1 + 2^4 *0 + 2^5 *1 (we
    start from the right 0). An octal literal starts with 0, followed by the value
    expressed in an octal system, so 42 is expressed as 52 = 8^0*2+ 8^1*5\. A hexadecimal
    literal starts with 0x (or with 0X), followed by a value expressed in a hexadecimal
    system. So, 42 is expressed as 2a = 16^0*a + 16^1*2 because, in the hexadecimal
    system, the symbols `a` to `f` (or `A` to `F`) map to the decimal values 10 to
    15\. Here is the demonstration code (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `literals()` method):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, Java provides methods that convert decimal system values to
    systems with different bases. All these expressions of numeric values are called
    literals.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'One feature of numeric literals makes them human-friendly. If the number is
    large, it is possible to break it into triples separated by an underscore (`_`)
    sign. Observe the following, for example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The compiler ignores an embedded underscore sign.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The `char` type has two kinds of literals: a single character or an escape
    sequence. We have seen examples of `char`-type literals when discussing numeric
    types, and you can see some others here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, the character has to be enclosed in single quotes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'An escape sequence starts with a backslash (`\`) followed by a letter or another
    character. Here is a full list of escape sequences:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`\`b: backspace BS, Unicode escape `\u0008`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\t: horizontal tab HT, Unicode escape `\u0009`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\n: line feed LF, Unicode escape `\u000a`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\f: form feed FF, Unicode escape `\u000c`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\r: carriage return CR, Unicode escape `\u000d`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\”: double quote “, Unicode escape `\u0022`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\’: single quote ‘, Unicode escape `\u0027`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\\: backslash \, Unicode escape `\u005c`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the eight escape sequences, only the last three are represented by a symbol.
    They are used when this symbol cannot be otherwise displayed. Observe the following,
    for example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The rest are used more as control codes that direct the output device to do
    something, as in the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, `\b` deletes a previous symbol, `\t` inserts a tab space, `\n`
    breaks the line and begins the new one, `\f` forces the printer to eject the current
    page and to continue printing at the top of another, and `\r` starts the current
    line anew.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: New compact number format
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.text.NumberFormat` class presents numbers in various formats. It also
    allows formats to be adjusted to those provided, including locales. A new feature
    added to this class in Java 12 is called a compact or short number format.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'It represents a number in a locale-specific, human-readable form. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `newNumberFormat()` method):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, to access this capability, you have to acquire a particular
    instance of the `NumberFormat` class, sometimes based on the locale and style
    provided.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are 44 operators in Java. These are listed in the following table:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Table_1.2.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: We will not describe the not-often-used `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`
    assignment operators and bitwise operators, but you can read about them in the
    Java specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Arrow ( `->`) and method reference (`::`) operators will be described in [*Chapter
    14*](B18388_14_ePub.xhtml#_idTextAnchor296), *Java Standard Streams*. The `new`
    instance creation operator, the `.` field access/method invocation operator, and
    the `instanceof` type comparison operator will be discussed in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. As for the cast operator, we have already
    described it in the *Integral types* section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic unary (+ and -) and binary (+, -, *, /, and %) operators
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of the arithmetic operators and positive and negative signs (unary operators)
    are quite familiar to us. The modulus operator (`%`) divides the left-hand operand
    by the right-hand operand and returns the remainder, as follows (execute the `main()`
    method of the `com.packt.learnjava.ch01_start.Operators` class—see the `integerDivision()`
    method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It is also worth mentioning that the division of two integer numbers in Java
    loses the fractional part because Java assumes the result should be an integer
    number `2`, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you need the fractional part of the result to be preserved, convert one
    of the operands into a floating-point type. Here are a few ways (among many) in
    which to do this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Increment and decrement unary operators (++ and --)
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `++` operator increases the value of an integral type by 1, while the `--`
    operator decreases it by 1\. If placed before the variable (prefix), it changes
    its value by 1 before the variable value is returned. But when placed after the
    variable (postfix), it changes its value by 1 after the variable value is returned.
    Here are a few examples (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `incrementDecrement()` method):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Equality operators (== and !=)
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `==` operator means equals, while the `!=` operator means not equals. They
    are used to compare values of the same type and return a `true` Boolean value
    if the operand’s values are `equal`, or `false` otherwise. Observe the following,
    for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`,
    class—see the `equality()` method):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Exercise caution, though, while comparing values of floating-point types, especially
    when you compare the results of calculations. Using relational operators (`<`,
    `>`, `<=`, and `>=`) in such cases is much more reliable, because calculations
    such as 1/3—for example—result in a never-ending fractional part 0.33333333...
    and ultimately depend on precision implementation (a complex topic that is beyond
    the scope of this book).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators (<, >, <=, and >=)
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relational operators compare values and return a Boolean value. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `relational()` method):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Logical operators (!, &, and |)
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Logical operators can be defined as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The `!` binary operator returns `true` if the operand is `false`; otherwise,
    it returns `false`.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `&` binary operator returns `true` if both of the operands are `true`.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `|` binary operator returns `true` if at least one of the operands is `true`.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `logical()` method):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Conditional operators (&&, ||, and ? :)
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `&&` and `||` operators produce the same results as the `&` and `|` logical
    operators we have just demonstrated, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.Operators` class—see the `conditional()` method):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The difference is that the `&&` and `||` operators do not always evaluate the
    second operand. For example, in the case of the `&&` operator, if the first operand
    is `false`, the second operand is not evaluated because the result of the whole
    expression will be `false` anyway. Similarly, in the case of the `||` operator,
    if the first operand is `true`, the whole expression will be clearly evaluated
    to `true` without evaluating the second operand. We can demonstrate this in the
    following code snippet:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `? :` operator is called a ternary operator. It evaluates a condition (before
    the `?` sign), and if it results in `true`, assigns to a variable the value calculated
    by the first expression (between the `?` and `:` signs); otherwise, it assigns
    a value calculated by the second expression (after the `:` sign), as illustrated
    in the following code snippet:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Assignment operators (=, +=, -=, *=, /=, and %=)
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `=` operator just assigns a specified value to a variable, like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Other assignment operators calculate a new value before assigning it, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '`x += 42` assigns to `x` the result of the `x = x + 42` addition operation.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -= 42` assigns to `x` the result of the `x = x - 42` subtraction operation.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x *= 42` assigns to `x` the result of the `x = x * 42` multiplication operation.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x /= 42` assigns to `x` the result of the `x = x / 42` division operation.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x %= 42` assigns the remainder of the `x = x + x % 42` division operation.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how these operators work (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `assignment()` method):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: String types and literals
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just described the primitive value types of the Java language. All the
    other value types in Java belong to a category of reference types. Each reference
    type is a more complex construct than just a value. It is described by a class,
    which serves as a template for creating an object, and a memory area that contains
    values and methods (the processing code) defined in the class. An object is created
    by the `new` operator. We will talk about classes and objects in more detail in
    [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about one of the reference types called `String`.
    It is represented by the `java.lang.String` class, which belongs, as you can see,
    to the most foundational package of the JDK, `java.lang`. The reason we’re introducing
    the `String` class so early is that it behaves in some respects very similar to
    primitive types, despite being a reference type.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: A reference type is so-called because, in the code, we do not deal with values
    of this type directly. A value of a reference type is more complex than a primitive-type
    value. It is called an object and requires more complex memory allocation, so
    a reference-type variable contains a memory reference. It points (refers) to the
    memory area where the object resides, hence the name.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: This nature of the reference type requires particular attention when a reference-type
    variable is passed into a method as a parameter. We will discuss this in more
    detail in [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*.
    For now, we will see how `String`, being a reference type, helps to optimize memory
    usage by storing each `String` value only once.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class represents character strings in Java programs. We have seen
    several such strings. We have seen `Hello, world!`, for example. That is a `String`
    literal.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a literal is `null`. Any reference class can refer to a
    `null` literal. It represents a reference value that does not point to any object.
    In the case of a `String` type, it looks like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'But a literal that consists of characters enclosed in double quotes (`"abc"`,
    `"123"`, and `"a42%$#"`, for example) can only be of a `String` type. In this
    respect, the `String` class, being a reference type, has something in common with
    primitive types. All `String` literals are stored in a dedicated section of memory
    called a string pool, and two literals are equally spelled to represent the same
    value from the pool (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `compareReferences()` method):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The JVM authors have chosen such an implementation to avoid duplication and
    improve memory usage. The previous code examples look very much like operations
    involving primitive types, don’t they? But when a `String` object is created using
    a `new` operator, the memory for the new object is allocated outside the string
    pool, so references of two `String` objects—or any other objects, for that matter—are
    always different, as we can see here:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'If necessary, it is possible to move the string value created with the `new`
    operator to the string pool using the `intern()` method, like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: In the previous code snippet, the `intern()` method attempted to move the newly
    created `"abc"` value into the string pool but discovered that such a literal
    exists there already, so it reused the literal from the string pool. That is why
    the references in the last line in the preceding example are equal.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that you probably will not need to create `String` objects
    using the `new` operator, and most Java programmers never do this. But when a
    `String` object is passed into your code as an input and you have no control over
    its origin, comparison by reference only may cause an incorrect result (if the
    strings have the same spelling but were created by the `new` operator). That is
    why, when the equality of two strings by spelling (and case) is necessary, to
    compare two literals or `String` objects, the `equals()` method is a better choice,
    as illustrated here:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: We will talk about the `equals()` method and other methods of the `String` class
    shortly.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that makes `String` literals and objects look like primitive
    values is that they can be added using the `+` arithmetic operator, like this
    (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `operatorAdd()` method):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: No other arithmetic operator can be applied to a `String` literal or an object.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'A new `String` literal, called a text block, was introduced with Java 15\.
    It facilitates the preservation of indents and multiple lines without adding white
    spaces in quotes. For example, here is how a programmer would add indentation
    before Java 15 and use `\n` to break the line:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'And here is how the same result is achieved with Java 15:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: To see how it works, execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `textBlock()` method.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: String immutability
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all `String` literals can be shared, the JVM authors make sure that, once
    stored, a `String` variable cannot be changed. This helps not only avoid the problem
    of concurrent modification of the same value from different places of the code
    but also prevents unauthorized modification of a `String` value, which often represents
    a username or password.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code looks like a `String` value modification:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'But, behind the scenes, the original `"abc"` literal remains intact. Instead,
    a few new literals were created: `"def"`, `"abcdef"`, `"123"`, and `"abcdef123"`.
    To prove this, we have executed the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: As you can see, the `r1` and `r2` variables refer to different memories, and
    the objects they refer to are spelled differently too.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about strings in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: IDs and variables
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our school days, we have an intuitive understanding of what a variable
    is. We think of it as a name that represents a value. We solve problems using
    such variables as *x* gallons of water or *n* miles of distance, and similar.
    In Java, the name of a variable is called an ID and can be constructed by certain
    rules. Using an ID, a variable can be declared (defined) and initialized.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: ID
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the *Java Language Specification* ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    an ID (a variable name) can be a sequence of Unicode characters that represent
    letters, digits 0-9, a dollar sign (`$`), or an underscore (`_`).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Other limitations are outlined here:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: The first symbol of an ID cannot be a digit.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ID cannot have the same spelling as a keyword (see the *Java keywords* section
    of [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*).
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be spelled as a `true` or `false` Boolean literal or as a `null` literal.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And since Java 9, an ID cannot be just an underscore (`_`).
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few unusual but legal examples of IDs:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Variable declaration (definition) and initialization
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable has a name (an ID) and a type. Typically, it refers to the memory
    where a value is stored, but may refer to nothing (`null`) or not refer to anything
    at all (then, it is not initialized). It can represent a class property, an array
    element, a method parameter, and a local variable. The last one is the most frequently
    used kind of variable.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Before a variable can be used, it has to be declared and initialized. In some
    other programming languages, a variable can also be defined, so Java programmers
    sometimes use the word *definition* as a synonym of declaration, which is not
    exactly correct.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a terminology review with examples:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Initialization and assignment look the same. The difference is in their sequence:
    the first assignment is called initialization. Without an initialization, a variable
    cannot be used.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration and initialization can be combined in a single statement. Observe
    the following, for example:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: var type holder
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java 10, a sort of type holder, `var`, was introduced. The *Java Language
    Specification* defines it thus: “*var is not a keyword, but an identifier with
    special meaning as the type of a local variable declaration*.”'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'In practical terms, it lets a compiler figure out the nature of the declared
    variable, as follows (see the `var()` method in the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: In the preceding example, the compiler can reasonably assume that `x` has the
    `int` primitive type.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, to accomplish that, a declaration on its own would
    not suffice, as we can see here:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: That is, without initialization, the compiler cannot figure out the type of
    the variable when `var` is used.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Java statements
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java statement is a minimal construct that can be executed. It describes
    an action and ends with a semicolon (`;`). We have seen many statements already.
    For example, here are three statements:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The first line is a declaration statement combined with an assignment statement.
    The second line is also a declaration statement combined with an assignment statement
    and method invocation statement. The third line is just a method invocation statement.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of Java statement types:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: An empty statement that consists of only one symbol, `;` (semicolon)
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class or interface declaration statement (we will talk about this in [*Chapter
    2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*)
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A local variable declaration statement: `int x`;'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A synchronized statement: this is beyond the scope of this book'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression statement
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control flow statement
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An expression statement can be one of the following:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'A method invocation statement: `someMethod();`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An assignment statement: `n = 23.42f;`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An object creation statement: `new String("abc");`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unary increment or decrement statement: `++x ; or --x; or x++; or x--;`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk more about expression statements in the *Expression statements*
    section.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'A control flow statement can be one of the following:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'A selection statement: `if-else` or `switch-case`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `or while`, or `do-while`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A branching statement: `break`, `continue`, or `return`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk more about control statements in the *Control flow statements*
    section.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Expression statements
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An expression statement consists of one or more expressions. An expression
    typically includes one or more operators. It can be evaluated, which means it
    can produce a result of one of the following types:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable: `x = 1`, for example'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A value: `2*2`, for example'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns nothing when the expression is an invocation of a method that returns
    `void`. Such a method is said to produce only a side effect: `void someMethod()`,
    for example.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following expression:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The preceding expression assigns a value to an `x` variable and has a side effect
    of adding 1 to the value of the `y` variable.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be a method that prints a line, like this:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The `println()` method returns nothing and has a side effect of printing something.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'By its form, an expression can be one of the following:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'A primary expression: a literal, a new object creation, a field or method access
    (invocation).'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unary operator expression: `x++`, for example.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary operator expression: `x*y`, for example.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ternary operator expression: `x > y ? true : false`, for example.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lambda expression: `x -> x + 1` (see [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*).'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an expression consists of other expressions, parentheses are often used to
    identify each of the expressions clearly. This way, it is easier to understand
    and to set the expressions’ precedence.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow statements
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Java program is executed, it is executed statement by statement. Some
    statements have to be executed conditionally, based on the result of an expression
    evaluation. Such statements are called control flow statements because, in computer
    science, a control flow (or flow of control) is the order in which individual
    statements are executed or evaluated.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'A control flow statement can be one of the following:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'A selection statement: `if-else` or `switch-case`'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A branching statement: `break`, `continue`, or `return`'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection statements
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Selection statements are based on an expression evaluation and have four variations,
    as outlined here:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '`if` (expression) {do something}'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` (expression) {do something} `else` {do something else}'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` (expression) {do something} `else if` {do something else} `else` {do something
    else}'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch...case` statement'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of `if` statements:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'A `switch...case` statement is a variation of an `if...else` statement, as
    illustrated here:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: As you can see, the `switch...case` statement forks the execution flow based
    on the value of the variable. The `break` statement allows the `switch...case`
    statement to be executed. Otherwise, all the following cases would be executed.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java 14, a new `switch...case` statement has been introduced in a less verbose
    form, as illustrated here:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: As you can see, it uses an arrow (`->`) and does not use a `break` statement.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `selection()` method that calls the `switchStatement()` method with
    different parameters, as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: You can see the results from the comments.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'If several lines of code have to be executed in each case, you can just put
    braces (`{}`) around the block of code, as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The Java 14 `switch...case` statement can even return a value, thus becoming
    in effect a `switch` expression. For example, here is a case when another variable
    has to be assigned based on the `switch...case` statement result:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'If we execute the `switchExpression1()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The following example of a `switch` expression is based on a constant:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'If we execute the `switchExpression2()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Here’s yet another example of a `switch` expression, this time based on the
    `enum` value:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'If we execute the `switchExpression3()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'In case a block of code has to be executed based on a particular input value,
    it is not possible to use a `return` statement because it is reserved already
    for the returning value from a method. That is why, to return a value from a block,
    we have to use a `yield` statement, as shown in the following example:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'If we execute the `switchExpression4()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: Iteration statements
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An iteration statement can take one of the following three forms:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: A `while` statement
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `do...while` statement
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `for` statement, also called a `loop` statement
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `while` statement looks like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Here is a specific example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `iteration()` method):'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: In some examples, instead of the `println()` method, we use the `print()` method,
    which does not feed another line (does not add a line feed control at the end
    of its output). The `print()` method displays the output in one line.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'A `do...while` statement has a very similar form, as we can see here:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'It differs from a `while` statement by always executing the block of statements
    at least once before evaluating the expression, as illustrated in the following
    code snippet:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'As you can see, it behaves the same way when the expression is `true` at the
    first iteration. But if the expression evaluates to `false`, the results are different,
    as we can see here:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '`for` statement syntax looks like this:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'Here is how a `for` statement works:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '`init` statements initialize a variable.'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Boolean expression is evaluated using the current variable value: if `true`,
    the block of statements is executed; otherwise, the `for` statement exits.'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`update` statements update the variable, and the Boolean expression is evaluated
    again with this new value: if `true`, the block of statements is executed; otherwise,
    the `for` statement exits.'
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless exited, the final step is repeated.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see here, if you aren’t careful, you can get into an infinite loop:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'So, you have to make sure that the Boolean expression guarantees eventual exit
    from the loop, like this:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'The following example demonstrates multiple initialization and `update` statements:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'And here is a variation of the preceding code for statements for demonstration
    purposes:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: If the `getInitialValue()` method is implemented like `int getInitialValue(){
    return -2; }`, then the preceding two `for` statements produce exactly the same
    results.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over an array of values, you can use an array index, like so:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Alternatively, you can use a more compact form of a `for` statement that produces
    the same result, as follows:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'This last form is especially useful with a collection, as shown here:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: We will talk about collections in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Exception-handling statements
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, there are classes called exceptions that represent events that disrupt
    the normal execution flow. They typically have names that end with `Exception`:
    `NullPointerException`, `ClassCastException`, `ArrayIndexOutOfBoundsException`,
    to name but a few.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: All the exception classes extend the `java.lang.Exception` class, which, in
    turn, extends the `java.lang.Throwable` class (we will explain what this means
    in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*). That’s why all exception objects have common behavior. They
    contain information about the cause of the exceptional condition and the location
    of its origination (line number of the source code).
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Each exception object can be generated (thrown) either automatically by the
    JVM or by the application code, using the `throw` keyword. If a block of code
    throws an exception, you can use a `try-catch` or `try-catch-finally` construct
    to capture the thrown exception object and redirect the execution flow to another
    branch of code. If the surrounding code does not catch the exception object, it
    propagates all the way out of the application into the JVM and forces it to exit
    (and abort the application execution). So, it is good practice to use `try-catch`
    or `try-catch-finally` in all the places where an exception can be raised and
    you do not want your application to abort execution.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical example of exception handling:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: In the preceding code snippet, normal processing flow will be not executed in
    the case of `x > 10`. Instead, the `do what has to be done` block will be executed.
    But, in the `x <= 10` case, the normal processing flow block will be run and the
    `do what has to be done` block will be ignored.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is necessary to execute a block of code anyway, whether an exception
    was thrown/caught or not. Instead of repeating the same code block in two places,
    you can put it in a `finally` block, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.ControlFlow` class—see the `exception()` method):'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: We will talk about exception handling in more detail in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110),
    *Exception Handling*.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: Branching statements
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Branching statements allow breaking of the current execution flow and continuation
    of execution from the first line after the current block or from a certain (labeled)
    point of the control flow.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'A branching statement can be one of the following:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have seen how `break` was used in `switch-case` statements. Here is another
    example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `branching()` method):'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: If we need to find the first list element that contains `"3"`, we can stop executing
    as soon as the `s.contains("3")` condition is evaluated to `true`. The remaining
    list elements are ignored.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more complicated scenario, with nested `for` statements, it is possible
    to set a label (with `a : column`) that indicates which `for` statement has to
    be exited, as follows:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: We have chosen a label name of `exit`, but we could call it any other name too.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'A `continue` statement works similarly, as follows:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: It differs from `break` by stating which of the `for` statements need to continue
    and not exit.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'A `return` statement is used to return a result from a method, as follows:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'As you can see, there can be several `return` statements in a method, each
    returning a different value in different circumstances. If the method returns
    nothing (`void`), a `return` statement is not required, although it is frequently
    used for better readability, as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Execute the `returnDemo()` method by running the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class (see the `branching()` method). The results are going to look like this:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Statements are the building blocks of Java programming. They are like sentences
    in English—complete expressions of intent that can be acted upon. They can be
    compiled and executed. Programming is like expressing an action plan in statements.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: With this, the explanation of the basics of Java is concluded. Congratulations
    on getting through it!
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-920
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the exciting world of Java programming. We started
    with explaining the main terms, and then explained how to install the necessary
    tools—the JDK and the IDE—and how to configure and use them.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: With a development environment in place, we have provided readers with the basics
    of Java as a programming language. We have described Java primitive types, the
    `String` type, and their literals. We have also defined what an ID is and what
    a variable is and finished with a description of the main types of Java statements.
    All the points of the discussion were illustrated by specific code examples.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about the `final` keyword.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  id: totrans-924
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does JDK stand for?
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Document Kronos
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: June Development Karate
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Development Kit
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Developer Kit
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does JCL stand for?
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Classical Library
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Class Library
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Junior Classical Liberty
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Class Libras
  id: totrans-934
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does Java SE stand for?
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Senior Edition
  id: totrans-936
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Star Edition
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Structural Elections
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Standard Edition
  id: totrans-939
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does IDE stand for?
  id: totrans-940
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initial Development Edition
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrated Development Environment
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: International Development Edition
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrated Development Edition
  id: totrans-944
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Maven's functions?
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project building
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project configuration
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project documentation
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project cancellation
  id: totrans-949
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java primitive types?
  id: totrans-950
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean`'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`numeric`'
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`integer`'
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`string`'
  id: totrans-954
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java numeric types?
  id: totrans-955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`long`'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bit`'
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`short`'
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`byte`'
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a *literal*?
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A letter-based string
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A number-based string
  id: totrans-962
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable representation
  id: totrans-963
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A value representation
  id: totrans-964
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are literals?
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\\`'
  id: totrans-966
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2_0`'
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2__0f`'
  id: totrans-968
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\f`'
  id: totrans-969
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java operators?
  id: totrans-970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%`'
  id: totrans-971
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  id: totrans-972
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&`'
  id: totrans-973
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`->`'
  id: totrans-974
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE486]'
  id: totrans-976
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '`0`'
  id: totrans-977
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  id: totrans-978
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  id: totrans-979
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  id: totrans-980
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-981
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE487]'
  id: totrans-982
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '`false true`'
  id: totrans-983
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false false`'
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true false`'
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true true`'
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-987
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE488]'
  id: totrans-988
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '`1`'
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  id: totrans-991
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`4`'
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of the following code snippet?
  id: totrans-993
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE489]'
  id: totrans-994
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '`a`'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`abc-bc`'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution error
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE490]'
  id: totrans-1000
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '`1`'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`4`'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are correct IDs?
  id: totrans-1005
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int __` (two underscores)'
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2a`'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a2`'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-1010
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE491]'
  id: totrans-1011
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '`20 -1 21 0`'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Endless loop
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`21 0`'
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`20 -1`'
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE492]'
  id: totrans-1017
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Compilation error
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `x` value is out of the range: 11'
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `x` value is within the range: 11'
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution time error
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  id: totrans-1022
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE493]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '`result = 22`'
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 23`'
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 32`'
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 33`'
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the following statements that are correct:'
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be declared.
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be assigned.
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be defined.
  id: totrans-1045
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be determined.
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct Java statement types from the following:'
  id: totrans-1047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An executable statement
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A selection statement
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A method end statement
  id: totrans-1050
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An increment statement
  id: totrans-1051
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
