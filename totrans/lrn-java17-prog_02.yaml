- en: '*Chapter 1*: Getting Started with Java 17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about how to start learning Java 17 and Java in general. We
    will begin with the basics, first explaining what Java is and its main terms,
    followed by how to install the necessary tools to write and run (execute) a program.
    In this respect, Java 17 is not much different from the previous Java versions,
    so this chapter’s content applies to the older versions too.
  prefs: []
  type: TYPE_NORMAL
- en: We will describe and demonstrate all the necessary steps for building and configuring
    a Java programming environment. This is the bare minimum that should have on your
    computer to start programming. We also describe the basic Java language constructs
    and illustrate them with examples that can be executed immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to learn a programming language—or any language, for that matter—is
    to use it, and this chapter guides readers on how they can do this with Java.
    We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install and run Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install and run an **integrated development environment** (**IDE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java primitive types and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String types and literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifiers** (**IDs**) and variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or your preferred code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java `examples/src/main/java/com/packt/learnjava/ch01_start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to install and run Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When somebody says “*Java*”, they may mean quite different things. They could
    be referring to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java programming language**: A high-level programming language that allows
    an intent (a program) to be expressed in a human-readable format that can be translated
    into binary code that is executable by a computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java compiler**: A program that can read a text written in the Java programming
    language and translate it into bytecode that can be interpreted by the **Java
    Virtual Machine** (**JVM**) into binary code that is executable by a computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVM**: A program that reads bytecode of the compiled Java program and interprets
    it into binary code that is executable by a computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**): A collection of programs (tools and utilities),
    including the Java compiler, the JVM, and supporting libraries, which allow the
    compilation and execution of a program written in the Java language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following section walks you through the installation of the JDK of Java
    17 and the basic related terms and commands.
  prefs: []
  type: TYPE_NORMAL
- en: What is the JDK and why do we need it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have mentioned already, the JDK includes a Java compiler and the JVM.
    The task of the compiler is to read a `.java` file that contains the text of a
    program written in Java (called source code) and transform (compile) it into bytecode
    stored in a `.class` file. The JVM can then read the `.class` file, interpret
    the bytecode into binary code, and send it to the operating system for execution.
    Both the compiler and the JVM have to be invoked explicitly from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchy of languages used by Java programs goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: You write Java code (`.java` file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler converts your Java code into bytecode (`.class` file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM converts the bytecode into machine-level assembly instructions (run
    on hardware).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int a = b + c;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write the preceding code, the compiler adds the following bytecode
    to the `.class` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Write once, run anywhere* is the most famous programming marketing jingle
    driving worldwide adoption. Oracle claims more than 10 million developers use
    Java, which runs on 13 billion devices. You write Java and compile it into bytecode
    in `.class` files. There is a different JVM for Windows, Mac, Unix, Linux, and
    more, but the same `.class` file works on all of them.'
  prefs: []
  type: TYPE_NORMAL
- en: To support the `.java` file compilation and its bytecode execution, the JDK
    installation also includes standard Java libraries called the **Java Class Library**
    (**JCL**). If the program uses a third-party library, it has to be present during
    compilation and execution. It has to be referred from the same command line that
    invokes the compiler, and later when the bytecode is executed by the JVM. JCL,
    on the other hand, does not need to be referred to explicitly. It is assumed that
    the standard Java libraries reside in the default location of the JDK installation
    so that the compiler and the JVM know where to find them.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not need to compile a Java program and would like to run only the
    already compiled `.class` files, you can download and install the **Java Runtime
    Environment** (**JRE**). For example, it consists of a subset of the JDK and does
    not include a compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the JDK is referred to as a **software development kit** (**SDK**),
    which is a general name for a collection of software tools and supporting libraries
    that allow the creation of an executable version of source code written using
    a certain programming language. So, the JDK is an SDK for Java. This means it
    is possible to call the JDK an SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also hear the terms *Java platform* and *Java edition* applied to the
    JDK. A typical platform is an operating system that allows a software program
    to be developed and executed. Since the JDK provides its own operating environment,
    it is called a platform too. An edition is a variation of a Java platform (JDK)
    assembled for a specific purpose. There are four Java platform editions, as listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Platform SE** (**Java SE**): This includes the JVM, JCL, and other tools
    and utilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Platform Enterprise Edition** (**Java EE**): This includes Java SE,
    servers (computer programs that provide services to the applications), JCL, other
    libraries, code samples, tutorials, and other documentation for developing and
    deploying large-scale, multi-tiered, and secure network applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Platform Micro Edition** (**Java ME**): This is a subset of Java SE
    with some specialized libraries for developing and deploying Java applications
    for embedded and mobile devices, such as phones, personal digital assistants,
    TV set-top boxes, printers, and sensors. A variation of Java ME (with its own
    JVM implementation) is called the Android SDK, which was developed by Google for
    Android programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Card**: This is the smallest of the Java editions and is intended for
    developing and deploying Java applications onto small embedded devices such as
    smart cards. It has two editions: Java Card Classic Edition, for smart cards,
    (based on **International Organization for Standardization** (**ISO**) *7816*
    and ISO *14443* communication), and Java Card Connected Edition, which supports
    a web application model and **Transmission Control Protocol/Internet Protocol**
    (**TCP/IP**) as a basic protocol and runs on high-end secure microcontrollers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, to install Java means to install the JDK, which also means to install the
    Java platform on one of the listed editions. In this book, we are going to talk
    about and use only Java SE (which includes the JVM, JCL, and other tools and utilities
    necessary to compile your Java program into bytecode, interpret it into binary
    code, and automatically send it to your operating system for execution).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Java SE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the recently released JDKs are listed on the official Oracle page at [https://www.oracle.com/java/technologies/downloads/#java17](https://www.oracle.com/java/technologies/downloads/#java17)
    (we will call this the *installation home page* for further references in later
    chapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps that need to be followed to install Java SE:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Java SE tab with your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the link to the installer that fits your operating system and the format
    (extension) you are familiar with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If in doubt, click the **Installation Instructions** link below and read the
    installation instructions for your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the steps that correspond to your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The JDK is installed successfully when the `java -version` command on your
    computer displays the correct Java version, as demonstrated in the following example
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Commands, tools, and utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you follow the installation instructions, you may have noticed a link (`bin`
    directory contains all executables that constitute Java commands, tools, and utilities.
    If the `bin` directory is not added to the `PATH` environment variable automatically,
    consider doing so manually so that you can launch a Java executable from any directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we have already demonstrated the `java -version` Java
    command. A list of the other Java executables available (commands, tools, and
    utilities) can be found in the Java SE documentation ([https://www.oracle.com/technetwork/java/javase/documentation/index.html](https://www.oracle.com/technetwork/java/javase/documentation/index.html))
    by clicking the **Java Platform Standard Edition Technical Documentation** site
    link, and then the **Tools Reference link** on the next page. You can learn more
    about each executable tool by clicking its link.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run each of the listed executables on your computer using one
    of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-?`, `-h`, `--help`, or `-help`'
  prefs: []
  type: TYPE_NORMAL
- en: These will display a brief description of the executable and all its options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important Java commands are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javac`: This reads a `.java` file, compiles it, and creates one or more corresponding
    `.class` files, depending on how many Java classes are defined in the `.java`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java`: This executes a `.class` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the commands that make programming possible. Every Java programmer
    must have a good understanding of their structure and capabilities, but if you
    are new to Java programming and use an IDE (see the *How to install and run an
    IDE* section), you do not need to master these commands immediately. A good IDE
    hides them from you by compiling a `.java` file automatically every time you make
    a change to it. It also provides a graphical element that runs the program every
    time you click it.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful Java tool is jcmd. This facilitates communication with,
    and diagnosis of, any currently running Java processes (JVM) and has many options.
    But in its simplest form, without any option, it lists all currently running Java
    processes and their **process IDs** (**PIDs**). You can use it to see whether
    you have runaway Java processes. If you have, you can then kill such a process
    using the PID provided.
  prefs: []
  type: TYPE_NORMAL
- en: How to install and run an IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What used to be just a specialized editor that allowed checking the syntax of
    a written program the same way a Word editor checks the syntax of an English sentence
    gradually evolved into an IDE. This bears its main function in the name. It integrates
    all the tools necessary for writing, compiling, and then executing a program under
    one **graphical user interface** (**GUI**). Using the power of Java compiler,
    the IDE identifies syntax errors immediately and then helps to improve code quality
    by providing context-dependent help and suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several IDEs available for a Java programmer, such as NetBeans, Eclipse,
    IntelliJ IDEA, BlueJ, DrJava, JDeveloper, JCreator, jEdit, JSource, and jCRASP,
    to name a few. You can read a review of the top Java IDEs and details about each
    by following this link: [https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers](https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers).
    The most popular ones are NetBeans, Eclipse, and IntelliJ IDEA.'
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans development started in 1996 as a Java IDE student project at Charles
    University in Prague. In 1999, the project and the company created around the
    project were acquired by Sun Microsystems. After Oracle acquired Sun Microsystems,
    NetBeans became open source, and many Java developers have since contributed to
    the project. It was bundled with JDK 8 and became an official IDE for Java development.
    In 2016, Oracle donated it to the Apache Software Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: There is a NetBeans IDE for Windows, Linux, Mac, and Oracle Solaris. It supports
    multiple programming languages and can be extended with plugins. As of the time
    of writing, NetBeans is bundled only with JDK 8, but NetBeans 8.2 can work with
    JDK 9 too and uses features introduced with JDK 9 such as Jigsaw, for example.
    On [netbeans.apache.org](http://netbeans.apache.org), you can read more about
    the NetBeans IDE and download the latest version, which is 12.5 as of the time
    of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Eclipse* is the most widely used Java IDE. The list of plugins that add new
    features to the IDE is constantly growing, so it is not possible to enumerate
    all the IDE’s capabilities. The Eclipse IDE project has been developed since 2001
    as **open source software** (**OSS**). A non-profit, member-supported corporation
    Eclipse Foundation was created in 2004 to provide the infrastructure (**version
    control systems** (**VCSs**), code review systems, build servers, download sites,
    and so on) and a structured process. None of the 30-something employees of the
    Eclipse Foundation is working on any of the 150 Eclipse-supported projects.'
  prefs: []
  type: TYPE_NORMAL
- en: The sheer number and variety of Eclipse IDE plugins create a certain challenge
    for a beginner because you have to find your way around different implementations
    of the same—or similar—features that can, on occasion, be incompatible and may
    require deep investigation, as well as a clear understanding of all the dependencies.
    Nevertheless, the Eclipse IDE is very popular and has solid community support.
    You can read about the Eclipse IDE and download the latest release from [www.eclipse.org/ide](http://www.eclipse.org/ide).
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliJ IDEA has two versions: a paid one and a free community edition. The
    paid version is consistently ranked as the best Java IDE, but the community edition
    is listed among the three leading Java IDEs too. The JetBrains software company
    that develops the IDE has offices in Prague, Saint Petersburg, Moscow, Munich,
    Boston, and Novosibirsk. The IDE is known for its deep intelligence that is “*giving
    relevant suggestions in every context: instant and clever code completion, on-the-fly
    code analysis, and reliable refactoring tools*”, as stated by the authors while
    describing the product on their website ([www.jetbrains.com/idea](http://www.jetbrains.com/idea)).
    In the *Installing and configuring IntelliJ IDEA* section, we will walk you through
    the installation and configuration of IntelliJ IDEA’s community edition.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring IntelliJ IDEA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps you need to follow in order to download and install IntelliJ
    IDEA:'
  prefs: []
  type: TYPE_NORMAL
- en: Download an installer of the IntelliJ community edition from [www.jetbrains.com/idea/download](http://www.jetbrains.com/idea/download).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the installer and accept all the default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `.java` on the **Installation Options** screen. We assume you have installed
    the JDK already, so you do not check the **Download and install JRE** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last installation screen has a **Run IntelliJ IDEA** checkbox that you can
    check to start the IDE automatically. Alternatively, you can leave the checkbox
    unchecked and launch the IDE manually once the installation is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the IDE starts for the first time, it provides you with an **Import IntelliJ
    IDEA settings** option. Check the **Do not import settings** checkbox if you have
    not used IntelliJ IDEA before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next couple of screens ask whether you accept the **JetBrains Privacy Policy**
    and whether you would like to pay for the license or prefer to continue to use
    the free community edition or free trial (this depends on the particular download
    you get).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer the questions whichever way you prefer, and if you accept the privacy
    policy, the **Customize IntelliJ IDEA** screen will ask you to choose a theme:
    **white (IntelliJ)** or **dark (Darcula)**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you decide to change the set values, you can do so later by selecting from
    the topmost menu, **File** | **Settings**, on Windows, or **Preferences** on Linux
    and macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start writing your program, you need to create a project. There
    are several ways to create a project in IntelliJ IDEA, which is the same for any
    IDE, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Project**: This creates a new project from scratch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Open**: This facilitates reading of the existing project from the filesystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get from VCS**: This facilitates reading of the existing project from the
    VCS.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this book, we will walk you through the first option only—using the sequence
    of guided steps provided by the IDE. Options *2* and *3* include many settings
    that are automatically set by importing an existing project that has those settings.
    Once you have learned how to create a new project from scratch, the other ways
    to bring up a project in the IDE will be very easy for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by clicking the **New Project** link and proceed further as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Maven** in the left panel and a value for **Project SDK** (Java Version
    17, if you have installed JDK 17 already), and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Maven is a project configuration tool whose primary function is to manage project
    dependencies. We will talk about it shortly. For now, we will use its other responsibility:
    to define and hold the project code identity using three **Artifact Coordinates**
    properties (see next).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the project name—for example, `myproject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the desired project location in the **Location field** setting (this
    is where your new code will reside).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `GroupId`: This is the base package name that identifies a group of projects
    within an organization or an open source community. In our case, l et''s type
    `com.mywork`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ArtifactId`: To identify a particular project within the group. Leave it as
    `myproject`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Version`: To identify the version of the project. Leave it as `1.0-SNAPSHOT`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main goal is to make the identity of a project unique among all projects
    in the world. To help avoid a `GroupId` clash, the convention requires that you
    start building it from the organization domain name in reverse. For example, if
    a company has a `company.com` domain name, the `GroupId` properties of its projects
    should start with `com.company`. That is why for this demonstration we use `com.mywork`,
    and for the code in this book, we use the `com.packt.learnjava` `GroupID` value.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following project structure and generated `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if somebody would like to use the code of your project in their application,
    they would refer to it by the three values shown, and Maven (if they use it) will
    bring it in (if you upload your project to the publicly shared Maven repository,
    of course). Read more about Maven at [https://maven.apache.org/guides](https://maven.apache.org/guides).
    Another function of the `GroupId` value is to define the root directory of the
    folders tree that holds your project code. The `java` folder under `main` will
    hold the application code, while the `java` folder under `test` will hold the
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our first program using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on `java`, select **New**, and then click **Package**, as illustrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `com.mywork.myproject` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see in the left panel the following set of new folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on `com.mywork.myproject`, select **New**, and then click **Java
    Class**, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the input window provided, type `HelloWorld`, as follows:![](img/B18388_Figure_1.6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *Enter* and you will see your first Java class, `HelloWorld`, created
    in the `com.mywork.myproject` package, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The package reflects the Java class location in the filesystem. We will talk
    about this more in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java
    Object-Oriented Programming (OOP)*. Now, in order to run a program, we create
    a `main()` method. If present, this method can be executed to serve as an entry
    point into the application. It has a certain format, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This has to have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: Freely accessible from outside the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static`: Should be able to be called without creating an object of the class
    it belongs to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return `void` (nothing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a `String` array as an input, or `varargs`, as we have done. We will
    talk about `varargs` in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. For now, suffice to say that `String[]
    args` and `String... args` essentially define the same input format.
  prefs: []
  type: TYPE_NORMAL
- en: We explain how to run the `main` class using a command line in the *Executing
    examples from the command line* section. You can read more about Java command-line
    arguments in the official Oracle documentation at [https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html](https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html).
    It is also possible to run the examples from IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the two green triangles to the left in the screenshot shown next. By
    clicking any of them, you can execute the `main()` method. For example, let’s
    display `Hello, world!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, type the following line inside the `main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the program should look afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click one of the green triangles, and you should get the following output
    in the Terminal area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From now on, every time we are going to discuss code examples, we will run
    them the same way, by using the `main()` method. While doing this, we will not
    capture a screenshot but put the result in comments, because such a style is easier
    to follow. For example, the following code snippet displays how the previous code
    demonstration would look in this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to add a comment (any text) to the right of the code line separated
    by a double slash `//`. The compiler does not read this text and just keeps it
    as it is. The presence of a comment does not affect performance and is used to
    explain the programmer’s intent to humans.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to demonstrate project importing using the source code for this
    book. We assume that you have Maven installed ([https://maven.apache.org/install.html](https://maven.apache.org/install.html))
    on your computer and that you have Git ([https://gist.github.com/derhuerst/1b15ff4652a867391f03](https://gist.github.com/derhuerst/1b15ff4652a867391f03))
    installed too, and can use it. We also assume that you have installed JDK 17,
    as was described in the *Installing Java SE* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the project with the code examples for this book, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the source repository ([https://github.com/PacktPublishing/Learn-Java-17-Programming](https://github.com/PacktPublishing/Learn-Java-17-Programming))
    and click the **Code** drop-down menu, as shown in the following screenshot:![](img/B18388_Figure_1.11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the provided **Uniform Resource Locator** (**URL**) (click the *copy*
    symbol to the right of the URL), as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select a directory on your computer where you would like the source code to
    be placed and then run the `git clone https://github.com/PacktPublishing/Learn-Java-17-Programming.git`
    Git command and observe similar output to that shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A new `Learn-Java-17-Programming` folder is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, instead of cloning, you can download the source as a `.zip` file
    using the `Download ZIP` link shown in the screenshot just before. Unarchive the
    downloaded source in a directory on your computer where you would like the source
    code to be placed, and then rename the newly created folder by removing the `-master`
    suffix from its name, making sure that the folder’s name is `Learn-Java-17-Programming`.
  prefs: []
  type: TYPE_NORMAL
- en: The new `Learn-Java-17-Programming` folder contains the Maven project with all
    the source code from this book. If you prefer, you can rename this folder however
    you like. In our case, we renamed it `LearnJava` for brevity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run IntelliJ IDEA and click `LearnJava`, in our case), then click the **Open**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the following popup shows in the bottom-right corner, click **Load**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, click **Trust project...**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, click the **Trust Project** button on the following popup:![](img/B18388_Figure_1.16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to **Project Structure** (cogwheel symbol in the upper-right corner)
    and make sure that Java 17 is selected as an SDK, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click **Apply** and make sure that the default **Project SDK** is set to Java
    **version 17** and **Project language level** is set to **17**, as in the following
    screenshot:![](img/B18388_Figure_1.18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click `LearnJava` module by selecting it and clicking `"-"`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Confirm the `LearnJava` module removal on the popup by clicking **Yes**, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here's how the final list of modules should look:![](img/B18388_Figure_1.21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **OK** in the bottom-right corner and get back to your project. Click
    examples in the left pane and continue going down the source tree until you see
    the following list of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the green arrow in the right pane and execute the `main()` method
    of any class you want. For example, let’s execute the `main()` method of the `PrimitiveTypes`
    class. The result you will be able to see in the **Run** window should be similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing examples from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute the examples from the command line, go to the `examples` folder,
    where the `pom.xml` file is located, and run the `mvn clean package` command.
    If the command is executed successfully, you can run any `main()` method in any
    of the programs in the `examples` folder from the command line. For example, to
    execute the `main()` method in the `ControlFlow.java` file, run the following
    command as one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_1.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This way, you can run any class that has the `main()` method in it. The content
    of the `main()` method will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Java primitive types and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the main programming tools in place, we can start talking about Java
    as a language. The language syntax is defined by the *Java Language Specification*,
    which you can find at [https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs).
    Don’t hesitate to refer to it every time you need some clarification—it is not
    as daunting as many people assume.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the values in Java are divided into two categories: reference types and
    primitive types. We start with primitive types and operators as the natural entry
    point to any programming language. In this chapter, we will also discuss one reference
    type called `String` (see the *String types and literals* section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'All primitive types can be divided into two groups: Boolean types and numeric
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only two Boolean type values in Java: `true` and `false`. Such a
    value can only be assigned to a variable of a `boolean` type, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A `boolean` variable is typically used in control flow statements, which we
    are going to discuss in the *Java statements* section. Here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we assign to the `b` variable the result of the evaluation
    of the `x > 2` expression. If the value of `x` is greater than `2`, the `b` variable
    gets the assigned value, `true`. Then, the code inside the braces (`{}`) is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java numeric types form two groups: integral types (`byte`, `char`, `short`,
    `int`, and `long`) and floating-point types (`float` and `double`).'
  prefs: []
  type: TYPE_NORMAL
- en: Integral types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integral types consume the following amount of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: 8 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`: 16 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: 16 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: 32 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: 64 bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `char` type is an unsigned integer that can hold a value (called a code
    point) from 0 to 65,535 inclusive. It represents a Unicode character, which means
    there are 65,536 Unicode characters. Here are three records from the basic Latin
    list of Unicode characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Table_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code demonstrates the properties of the `char` type (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `charType()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines from the preceding code example explain why the `char` type
    is considered an integral type because `char` values can be used in arithmetic
    operations. In such a case, each `char` value is represented by its code point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of values of other integral types is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`: from -128 to 127 inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: from -32,768 to 32,767 inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: from -2.147.483.648 to 2.147.483.647 inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can always retrieve the maximum and minimum value of each primitive type
    from a corresponding Java constant, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see the `minMax()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The construct (`int`) in the last two lines is an example of cast operator usage.
    It forces the conversion of a value from one type to another in cases where such
    a conversion is not always guaranteed to be successful. As you can see from our
    examples, some types allow bigger values than other types. But a programmer may
    know that the value of a certain variable can never exceed the maximum value of
    the target type, and the cast operator is the way the programmer can force their
    opinion on the compiler. Otherwise, without a cast operator, the compiler would
    raise an error and would not allow the assignment. However, the programmer may
    be mistaken and the value may become bigger. In such a case, a runtime error will
    be raised during execution time.
  prefs: []
  type: TYPE_NORMAL
- en: There are types that, in principle, cannot be cast to other types, though, or
    at least not to all types—for example, a Boolean type value cannot be cast to
    an integral type value.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types in this group of primitive types—`float` and `double`.
    These consume the following amount of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`: 32 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: 64 bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their positive maximum and minimum possible values are shown here (execute
    the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes` class—see
    the `minMax()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The maximum and minimum negative values are the same as those just shown, only
    with a minus sign (`-`) in front of them. So, effectively, the `Float.MIN_VALUE`
    and `Double.MIN_VALUE` values are not the minimal values, but the precision of
    the corresponding type. A zero value can be either 0.0 or -0.0 for each of the
    floating-point types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special feature of the floating-point type is the presence of a dot (`.`)
    that separates integer and fractional parts of the number. By default, in Java,
    a number with a dot is assumed to be a `double` type. For example, the following
    is assumed to be a `double` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`42.3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the following assignment causes a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate that you would like it to be treated as a `float` type, you need
    to add either `f` or `F`. For example, the following assignments do not cause
    an error (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `casting()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed from the preceding example, `d` and `D` indicate a `double`
    type, but we were able to cast them to the `float` type because we are confident
    that `42.3` is well inside the range of possible `float`-type values.
  prefs: []
  type: TYPE_NORMAL
- en: Default values of primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, a variable has to be assigned a value even when a programmer
    did not want to do that. We will talk about such cases in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. The default primitive type value in
    such cases is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`, `short`, `int`, and `long` types have a default value of 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `char` type has a default value of `\u0000`, with the code point 0\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` and `double` types have a default value of 0.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boolean` type has a default value of `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literals of primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The representation of a value is called a literal. The `boolean` type has two
    literals: `true` and `false`. Literals of `byte`, `short`, `int`, and `long` integral
    types have an `int` type by default, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, to indicate a literal of a `long` type, you can append the letter
    `l` or `L` to the end, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The letter `l` can be easily confused with the number `1`, so using `L` (instead
    of `l`) for this purpose is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have expressed integral literals in a decimal number system. Meanwhile,
    literals of `byte`, `short`, `int`, and `long` types can also be expressed in
    binary (base 2, digits 0-1), octal (base 8, digits 0-7), and hexadecimal (base
    16, digits 0-9, and a-f) number systems. A binary literal starts with 0b (or 0B),
    followed by the value expressed in a binary system. For example, the decimal 42
    is expressed as 101010 = 2^0*0 + 2^1*1 + 2^2*0 + 2^3 *1 + 2^4 *0 + 2^5 *1 (we
    start from the right 0). An octal literal starts with 0, followed by the value
    expressed in an octal system, so 42 is expressed as 52 = 8^0*2+ 8^1*5\. A hexadecimal
    literal starts with 0x (or with 0X), followed by a value expressed in a hexadecimal
    system. So, 42 is expressed as 2a = 16^0*a + 16^1*2 because, in the hexadecimal
    system, the symbols `a` to `f` (or `A` to `F`) map to the decimal values 10 to
    15\. Here is the demonstration code (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `literals()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Java provides methods that convert decimal system values to
    systems with different bases. All these expressions of numeric values are called
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'One feature of numeric literals makes them human-friendly. If the number is
    large, it is possible to break it into triples separated by an underscore (`_`)
    sign. Observe the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The compiler ignores an embedded underscore sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `char` type has two kinds of literals: a single character or an escape
    sequence. We have seen examples of `char`-type literals when discussing numeric
    types, and you can see some others here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the character has to be enclosed in single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An escape sequence starts with a backslash (`\`) followed by a letter or another
    character. Here is a full list of escape sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\`b: backspace BS, Unicode escape `\u0008`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\t: horizontal tab HT, Unicode escape `\u0009`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\n: line feed LF, Unicode escape `\u000a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\f: form feed FF, Unicode escape `\u000c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\r: carriage return CR, Unicode escape `\u000d`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\”: double quote “, Unicode escape `\u0022`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\’: single quote ‘, Unicode escape `\u0027`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '\\: backslash \, Unicode escape `\u005c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the eight escape sequences, only the last three are represented by a symbol.
    They are used when this symbol cannot be otherwise displayed. Observe the following,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest are used more as control codes that direct the output device to do
    something, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `\b` deletes a previous symbol, `\t` inserts a tab space, `\n`
    breaks the line and begins the new one, `\f` forces the printer to eject the current
    page and to continue printing at the top of another, and `\r` starts the current
    line anew.
  prefs: []
  type: TYPE_NORMAL
- en: New compact number format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.text.NumberFormat` class presents numbers in various formats. It also
    allows formats to be adjusted to those provided, including locales. A new feature
    added to this class in Java 12 is called a compact or short number format.
  prefs: []
  type: TYPE_NORMAL
- en: 'It represents a number in a locale-specific, human-readable form. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class—see the `newNumberFormat()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to access this capability, you have to acquire a particular
    instance of the `NumberFormat` class, sometimes based on the locale and style
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are 44 operators in Java. These are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Table_1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will not describe the not-often-used `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`
    assignment operators and bitwise operators, but you can read about them in the
    Java specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
    Arrow ( `->`) and method reference (`::`) operators will be described in [*Chapter
    14*](B18388_14_ePub.xhtml#_idTextAnchor296), *Java Standard Streams*. The `new`
    instance creation operator, the `.` field access/method invocation operator, and
    the `instanceof` type comparison operator will be discussed in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*. As for the cast operator, we have already
    described it in the *Integral types* section.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic unary (+ and -) and binary (+, -, *, /, and %) operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of the arithmetic operators and positive and negative signs (unary operators)
    are quite familiar to us. The modulus operator (`%`) divides the left-hand operand
    by the right-hand operand and returns the remainder, as follows (execute the `main()`
    method of the `com.packt.learnjava.ch01_start.Operators` class—see the `integerDivision()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also worth mentioning that the division of two integer numbers in Java
    loses the fractional part because Java assumes the result should be an integer
    number `2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need the fractional part of the result to be preserved, convert one
    of the operands into a floating-point type. Here are a few ways (among many) in
    which to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Increment and decrement unary operators (++ and --)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `++` operator increases the value of an integral type by 1, while the `--`
    operator decreases it by 1\. If placed before the variable (prefix), it changes
    its value by 1 before the variable value is returned. But when placed after the
    variable (postfix), it changes its value by 1 after the variable value is returned.
    Here are a few examples (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `incrementDecrement()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Equality operators (== and !=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `==` operator means equals, while the `!=` operator means not equals. They
    are used to compare values of the same type and return a `true` Boolean value
    if the operand’s values are `equal`, or `false` otherwise. Observe the following,
    for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`,
    class—see the `equality()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Exercise caution, though, while comparing values of floating-point types, especially
    when you compare the results of calculations. Using relational operators (`<`,
    `>`, `<=`, and `>=`) in such cases is much more reliable, because calculations
    such as 1/3—for example—result in a never-ending fractional part 0.33333333...
    and ultimately depend on precision implementation (a complex topic that is beyond
    the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators (<, >, <=, and >=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relational operators compare values and return a Boolean value. Observe the
    following, for example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `relational()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators (!, &, and |)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Logical operators can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `!` binary operator returns `true` if the operand is `false`; otherwise,
    it returns `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `&` binary operator returns `true` if both of the operands are `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `|` binary operator returns `true` if at least one of the operands is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `logical()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Conditional operators (&&, ||, and ? :)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `&&` and `||` operators produce the same results as the `&` and `|` logical
    operators we have just demonstrated, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.Operators` class—see the `conditional()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that the `&&` and `||` operators do not always evaluate the
    second operand. For example, in the case of the `&&` operator, if the first operand
    is `false`, the second operand is not evaluated because the result of the whole
    expression will be `false` anyway. Similarly, in the case of the `||` operator,
    if the first operand is `true`, the whole expression will be clearly evaluated
    to `true` without evaluating the second operand. We can demonstrate this in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The `? :` operator is called a ternary operator. It evaluates a condition (before
    the `?` sign), and if it results in `true`, assigns to a variable the value calculated
    by the first expression (between the `?` and `:` signs); otherwise, it assigns
    a value calculated by the second expression (after the `:` sign), as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Assignment operators (=, +=, -=, *=, /=, and %=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `=` operator just assigns a specified value to a variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Other assignment operators calculate a new value before assigning it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x += 42` assigns to `x` the result of the `x = x + 42` addition operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -= 42` assigns to `x` the result of the `x = x - 42` subtraction operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x *= 42` assigns to `x` the result of the `x = x * 42` multiplication operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x /= 42` assigns to `x` the result of the `x = x / 42` division operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x %= 42` assigns the remainder of the `x = x + x % 42` division operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how these operators work (execute the `main()` method of the `com.packt.learnjava.ch01_start.Operators`
    class—see the `assignment()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: String types and literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just described the primitive value types of the Java language. All the
    other value types in Java belong to a category of reference types. Each reference
    type is a more complex construct than just a value. It is described by a class,
    which serves as a template for creating an object, and a memory area that contains
    values and methods (the processing code) defined in the class. An object is created
    by the `new` operator. We will talk about classes and objects in more detail in
    [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about one of the reference types called `String`.
    It is represented by the `java.lang.String` class, which belongs, as you can see,
    to the most foundational package of the JDK, `java.lang`. The reason we’re introducing
    the `String` class so early is that it behaves in some respects very similar to
    primitive types, despite being a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: A reference type is so-called because, in the code, we do not deal with values
    of this type directly. A value of a reference type is more complex than a primitive-type
    value. It is called an object and requires more complex memory allocation, so
    a reference-type variable contains a memory reference. It points (refers) to the
    memory area where the object resides, hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: This nature of the reference type requires particular attention when a reference-type
    variable is passed into a method as a parameter. We will discuss this in more
    detail in [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*.
    For now, we will see how `String`, being a reference type, helps to optimize memory
    usage by storing each `String` value only once.
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class represents character strings in Java programs. We have seen
    several such strings. We have seen `Hello, world!`, for example. That is a `String`
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a literal is `null`. Any reference class can refer to a
    `null` literal. It represents a reference value that does not point to any object.
    In the case of a `String` type, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'But a literal that consists of characters enclosed in double quotes (`"abc"`,
    `"123"`, and `"a42%$#"`, for example) can only be of a `String` type. In this
    respect, the `String` class, being a reference type, has something in common with
    primitive types. All `String` literals are stored in a dedicated section of memory
    called a string pool, and two literals are equally spelled to represent the same
    value from the pool (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `compareReferences()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The JVM authors have chosen such an implementation to avoid duplication and
    improve memory usage. The previous code examples look very much like operations
    involving primitive types, don’t they? But when a `String` object is created using
    a `new` operator, the memory for the new object is allocated outside the string
    pool, so references of two `String` objects—or any other objects, for that matter—are
    always different, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'If necessary, it is possible to move the string value created with the `new`
    operator to the string pool using the `intern()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, the `intern()` method attempted to move the newly
    created `"abc"` value into the string pool but discovered that such a literal
    exists there already, so it reused the literal from the string pool. That is why
    the references in the last line in the preceding example are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that you probably will not need to create `String` objects
    using the `new` operator, and most Java programmers never do this. But when a
    `String` object is passed into your code as an input and you have no control over
    its origin, comparison by reference only may cause an incorrect result (if the
    strings have the same spelling but were created by the `new` operator). That is
    why, when the equality of two strings by spelling (and case) is necessary, to
    compare two literals or `String` objects, the `equals()` method is a better choice,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about the `equals()` method and other methods of the `String` class
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that makes `String` literals and objects look like primitive
    values is that they can be added using the `+` arithmetic operator, like this
    (execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `operatorAdd()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: No other arithmetic operator can be applied to a `String` literal or an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new `String` literal, called a text block, was introduced with Java 15\.
    It facilitates the preservation of indents and multiple lines without adding white
    spaces in quotes. For example, here is how a programmer would add indentation
    before Java 15 and use `\n` to break the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how the same result is achieved with Java 15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: To see how it works, execute the `main()` method of the `com.packt.learnjava.ch01_start.StringClass`
    class—see the `textBlock()` method.
  prefs: []
  type: TYPE_NORMAL
- en: String immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all `String` literals can be shared, the JVM authors make sure that, once
    stored, a `String` variable cannot be changed. This helps not only avoid the problem
    of concurrent modification of the same value from different places of the code
    but also prevents unauthorized modification of a `String` value, which often represents
    a username or password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code looks like a `String` value modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'But, behind the scenes, the original `"abc"` literal remains intact. Instead,
    a few new literals were created: `"def"`, `"abcdef"`, `"123"`, and `"abcdef123"`.
    To prove this, we have executed the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `r1` and `r2` variables refer to different memories, and
    the objects they refer to are spelled differently too.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about strings in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*.
  prefs: []
  type: TYPE_NORMAL
- en: IDs and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our school days, we have an intuitive understanding of what a variable
    is. We think of it as a name that represents a value. We solve problems using
    such variables as *x* gallons of water or *n* miles of distance, and similar.
    In Java, the name of a variable is called an ID and can be constructed by certain
    rules. Using an ID, a variable can be declared (defined) and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the *Java Language Specification* ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)),
    an ID (a variable name) can be a sequence of Unicode characters that represent
    letters, digits 0-9, a dollar sign (`$`), or an underscore (`_`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other limitations are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first symbol of an ID cannot be a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ID cannot have the same spelling as a keyword (see the *Java keywords* section
    of [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be spelled as a `true` or `false` Boolean literal or as a `null` literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And since Java 9, an ID cannot be just an underscore (`_`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few unusual but legal examples of IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Variable declaration (definition) and initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable has a name (an ID) and a type. Typically, it refers to the memory
    where a value is stored, but may refer to nothing (`null`) or not refer to anything
    at all (then, it is not initialized). It can represent a class property, an array
    element, a method parameter, and a local variable. The last one is the most frequently
    used kind of variable.
  prefs: []
  type: TYPE_NORMAL
- en: Before a variable can be used, it has to be declared and initialized. In some
    other programming languages, a variable can also be defined, so Java programmers
    sometimes use the word *definition* as a synonym of declaration, which is not
    exactly correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a terminology review with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialization and assignment look the same. The difference is in their sequence:
    the first assignment is called initialization. Without an initialization, a variable
    cannot be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration and initialization can be combined in a single statement. Observe
    the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: var type holder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java 10, a sort of type holder, `var`, was introduced. The *Java Language
    Specification* defines it thus: “*var is not a keyword, but an identifier with
    special meaning as the type of a local variable declaration*.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practical terms, it lets a compiler figure out the nature of the declared
    variable, as follows (see the `var()` method in the `com.packt.learnjava.ch01_start.PrimitiveTypes`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the compiler can reasonably assume that `x` has the
    `int` primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, to accomplish that, a declaration on its own would
    not suffice, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: That is, without initialization, the compiler cannot figure out the type of
    the variable when `var` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Java statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java statement is a minimal construct that can be executed. It describes
    an action and ends with a semicolon (`;`). We have seen many statements already.
    For example, here are three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a declaration statement combined with an assignment statement.
    The second line is also a declaration statement combined with an assignment statement
    and method invocation statement. The third line is just a method invocation statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of Java statement types:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty statement that consists of only one symbol, `;` (semicolon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class or interface declaration statement (we will talk about this in [*Chapter
    2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented Programming
    (OOP)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A local variable declaration statement: `int x`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A synchronized statement: this is beyond the scope of this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control flow statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An expression statement can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method invocation statement: `someMethod();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An assignment statement: `n = 23.42f;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An object creation statement: `new String("abc");`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unary increment or decrement statement: `++x ; or --x; or x++; or x--;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk more about expression statements in the *Expression statements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A control flow statement can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A selection statement: `if-else` or `switch-case`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `or while`, or `do-while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A branching statement: `break`, `continue`, or `return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk more about control statements in the *Control flow statements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Expression statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An expression statement consists of one or more expressions. An expression
    typically includes one or more operators. It can be evaluated, which means it
    can produce a result of one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable: `x = 1`, for example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A value: `2*2`, for example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns nothing when the expression is an invocation of a method that returns
    `void`. Such a method is said to produce only a side effect: `void someMethod()`,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression assigns a value to an `x` variable and has a side effect
    of adding 1 to the value of the `y` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be a method that prints a line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: The `println()` method returns nothing and has a side effect of printing something.
  prefs: []
  type: TYPE_NORMAL
- en: 'By its form, an expression can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A primary expression: a literal, a new object creation, a field or method access
    (invocation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unary operator expression: `x++`, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary operator expression: `x*y`, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ternary operator expression: `x > y ? true : false`, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lambda expression: `x -> x + 1` (see [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an expression consists of other expressions, parentheses are often used to
    identify each of the expressions clearly. This way, it is easier to understand
    and to set the expressions’ precedence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Java program is executed, it is executed statement by statement. Some
    statements have to be executed conditionally, based on the result of an expression
    evaluation. Such statements are called control flow statements because, in computer
    science, a control flow (or flow of control) is the order in which individual
    statements are executed or evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A control flow statement can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A selection statement: `if-else` or `switch-case`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exception-handling statement: `throw`, `try-catch`, or `try-catch-finally`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A branching statement: `break`, `continue`, or `return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Selection statements are based on an expression evaluation and have four variations,
    as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` (expression) {do something}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` (expression) {do something} `else` {do something else}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` (expression) {do something} `else if` {do something else} `else` {do something
    else}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch...case` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'A `switch...case` statement is a variation of an `if...else` statement, as
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `switch...case` statement forks the execution flow based
    on the value of the variable. The `break` statement allows the `switch...case`
    statement to be executed. Otherwise, all the following cases would be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java 14, a new `switch...case` statement has been introduced in a less verbose
    form, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it uses an arrow (`->`) and does not use a `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `selection()` method that calls the `switchStatement()` method with
    different parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: You can see the results from the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If several lines of code have to be executed in each case, you can just put
    braces (`{}`) around the block of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java 14 `switch...case` statement can even return a value, thus becoming
    in effect a `switch` expression. For example, here is a case when another variable
    has to be assigned based on the `switch...case` statement result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the `switchExpression1()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example of a `switch` expression is based on a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the `switchExpression2()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s yet another example of a `switch` expression, this time based on the
    `enum` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the `switchExpression3()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'In case a block of code has to be executed based on a particular input value,
    it is not possible to use a `return` statement because it is reserved already
    for the returning value from a method. That is why, to return a value from a block,
    we have to use a `yield` statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the `switchExpression4()` method (see the `selection()` method
    of the `com.packt.learnjava.ch01_start.ControlFlow` class), the results are going
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Iteration statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An iteration statement can take one of the following three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: A `while` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `do...while` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `for` statement, also called a `loop` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `while` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a specific example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `iteration()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: In some examples, instead of the `println()` method, we use the `print()` method,
    which does not feed another line (does not add a line feed control at the end
    of its output). The `print()` method displays the output in one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `do...while` statement has a very similar form, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'It differs from a `while` statement by always executing the block of statements
    at least once before evaluating the expression, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it behaves the same way when the expression is `true` at the
    first iteration. But if the expression evaluates to `false`, the results are different,
    as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '`for` statement syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how a `for` statement works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init` statements initialize a variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Boolean expression is evaluated using the current variable value: if `true`,
    the block of statements is executed; otherwise, the `for` statement exits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`update` statements update the variable, and the Boolean expression is evaluated
    again with this new value: if `true`, the block of statements is executed; otherwise,
    the `for` statement exits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless exited, the final step is repeated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see here, if you aren’t careful, you can get into an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you have to make sure that the Boolean expression guarantees eventual exit
    from the loop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates multiple initialization and `update` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a variation of the preceding code for statements for demonstration
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: If the `getInitialValue()` method is implemented like `int getInitialValue(){
    return -2; }`, then the preceding two `for` statements produce exactly the same
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over an array of values, you can use an array index, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use a more compact form of a `for` statement that produces
    the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'This last form is especially useful with a collection, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about collections in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*.
  prefs: []
  type: TYPE_NORMAL
- en: Exception-handling statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, there are classes called exceptions that represent events that disrupt
    the normal execution flow. They typically have names that end with `Exception`:
    `NullPointerException`, `ClassCastException`, `ArrayIndexOutOfBoundsException`,
    to name but a few.'
  prefs: []
  type: TYPE_NORMAL
- en: All the exception classes extend the `java.lang.Exception` class, which, in
    turn, extends the `java.lang.Throwable` class (we will explain what this means
    in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*). That’s why all exception objects have common behavior. They
    contain information about the cause of the exceptional condition and the location
    of its origination (line number of the source code).
  prefs: []
  type: TYPE_NORMAL
- en: Each exception object can be generated (thrown) either automatically by the
    JVM or by the application code, using the `throw` keyword. If a block of code
    throws an exception, you can use a `try-catch` or `try-catch-finally` construct
    to capture the thrown exception object and redirect the execution flow to another
    branch of code. If the surrounding code does not catch the exception object, it
    propagates all the way out of the application into the JVM and forces it to exit
    (and abort the application execution). So, it is good practice to use `try-catch`
    or `try-catch-finally` in all the places where an exception can be raised and
    you do not want your application to abort execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical example of exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, normal processing flow will be not executed in
    the case of `x > 10`. Instead, the `do what has to be done` block will be executed.
    But, in the `x <= 10` case, the normal processing flow block will be run and the
    `do what has to be done` block will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is necessary to execute a block of code anyway, whether an exception
    was thrown/caught or not. Instead of repeating the same code block in two places,
    you can put it in a `finally` block, as follows (execute the `main()` method of
    the `com.packt.learnjava.ch01_start.ControlFlow` class—see the `exception()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about exception handling in more detail in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110),
    *Exception Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: Branching statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Branching statements allow breaking of the current execution flow and continuation
    of execution from the first line after the current block or from a certain (labeled)
    point of the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'A branching statement can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have seen how `break` was used in `switch-case` statements. Here is another
    example (execute the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class—see the `branching()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: If we need to find the first list element that contains `"3"`, we can stop executing
    as soon as the `s.contains("3")` condition is evaluated to `true`. The remaining
    list elements are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more complicated scenario, with nested `for` statements, it is possible
    to set a label (with `a : column`) that indicates which `for` statement has to
    be exited, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: We have chosen a label name of `exit`, but we could call it any other name too.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `continue` statement works similarly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: It differs from `break` by stating which of the `for` statements need to continue
    and not exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `return` statement is used to return a result from a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there can be several `return` statements in a method, each
    returning a different value in different circumstances. If the method returns
    nothing (`void`), a `return` statement is not required, although it is frequently
    used for better readability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `returnDemo()` method by running the `main()` method of the `com.packt.learnjava.ch01_start.ControlFlow`
    class (see the `branching()` method). The results are going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Statements are the building blocks of Java programming. They are like sentences
    in English—complete expressions of intent that can be acted upon. They can be
    compiled and executed. Programming is like expressing an action plan in statements.
  prefs: []
  type: TYPE_NORMAL
- en: With this, the explanation of the basics of Java is concluded. Congratulations
    on getting through it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the exciting world of Java programming. We started
    with explaining the main terms, and then explained how to install the necessary
    tools—the JDK and the IDE—and how to configure and use them.
  prefs: []
  type: TYPE_NORMAL
- en: With a development environment in place, we have provided readers with the basics
    of Java as a programming language. We have described Java primitive types, the
    `String` type, and their literals. We have also defined what an ID is and what
    a variable is and finished with a description of the main types of Java statements.
    All the points of the discussion were illustrated by specific code examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about the `final` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does JDK stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Document Kronos
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: June Development Karate
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Development Kit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Developer Kit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does JCL stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Classical Library
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Class Library
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Junior Classical Liberty
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Class Libras
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does Java SE stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Senior Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Star Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Structural Elections
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Standard Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does IDE stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initial Development Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrated Development Environment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: International Development Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrated Development Edition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Maven's functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project building
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project configuration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project documentation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Project cancellation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java primitive types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`numeric`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`integer`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java numeric types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bit`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a *literal*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A letter-based string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A number-based string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable representation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A value representation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are literals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\\`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2_0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2__0f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are Java operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`->`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`4`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of the following code snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`a`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`abc-bc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compilation error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`3`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`4`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are correct IDs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int __` (two underscores)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2a`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a2`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`20 -1 21 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Endless loop
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`21 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`20 -1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compilation error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `x` value is out of the range: 11'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `x` value is within the range: 11'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution time error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code snippet print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '`result = 22`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 23`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 32`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result = 33`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the following statements that are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be declared.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be assigned.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be defined.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can be determined.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct Java statement types from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An executable statement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A selection statement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A method end statement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An increment statement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
