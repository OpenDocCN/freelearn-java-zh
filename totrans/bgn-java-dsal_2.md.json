["```java\nbubbleSort(array)\n  n = length(array)\n  for (k = 1 until n)\n    for (j = 0 until -1)\n      if(array[j] > array[j + 1])\n        swap(array, j, j + 1)  \n```", "```java\n public void sort(int[] numbers) \n```", "```java\npublic void sort(int[] numbers) {\n  for (int i = 1; i < numbers.length; i++) {\n    for (int j = 0; j < numbers.length - 1; j++) {\n      if (numbers[j] > numbers[j + 1]) {\n        int temp = numbers[j];\n        numbers[j] = numbers[j + 1];\n        numbers[j + 1] = temp;\n      }\n    }\n  }\n}  \n```", "```java\npublic void sortImprovement1(int[] numbers) {\n  for (int i = 1; i < numbers.length; i++) {\n    for (int j = 0; j < numbers.length - i; j++) {\n      if (numbers[j] > numbers[j + 1]) {\n        swap(numbers, j, j + 1);\n      }\n    }\n  }\n}  \n```", "```java\npublic void sortImprovement2(int[] numbers) {\n  int i = 0;\n  boolean swapOccured = true;\n  while (swapOccured) {\n     swapOccured = false;\n     i++;\n     for (int j = 0; j < numbers.length - i; j++) {\n          if (numbers[j] > numbers[j + 1]) {\n              swap(numbers, j, j + 1);\n              swapOccured = true;\n          }\n     }\n  }\n}  \n```", "```java\nbinarySearch(x, array, start, end)\n  if(start <= end)\n    mid = (end - start) / 2 + start\n    if (array[mid] == x) return true \n    if (array[mid] > x) return binarySearch(x, array, start, mid - 1)\n    return binarySearch(x, array, mid + 1, end)\n  return false  \n```", "```java\n public boolean binarySearch(int x, int[] sortedNumbers) \n```", "```java\npublic boolean binarySearch(int x, int[] sortedNumbers, int start,\nint end) {\n  if (start <= end) {\n    int mid = (end - start) / 2 + start;\n    if (sortedNumbers[mid] == x) return true;\n    if (sortedNumbers[mid] > x)\n    return binarySearch(x, sortedNumbers, start, mid - 1);\n    return binarySearch(x, sortedNumbers, mid + 1, end);\n  }\nreturn false;}  \n```", "```java\nprivate int partition(int[] numbers, int start, int end) {\n  int pivot = numbers[end];\n  int x = start - 1;\n  for (int i = start; i < end; i++) {\n    if (numbers[i] < pivot) {\n      x++;\n      swap(numbers, x, i);\n    }\n  }\n\n  swap(numbers, x + 1, end);\n  return x + 1;\n}  \n```", "```java\nquickSort(array, start, end)\n  if(start < end)\n    p = partition(array, start, end)\n    quickSort(array, start, p - 1)\n    quickSort(array, p + 1, end)  \n```", "```java\nprivate void sort(int[] numbers, int start, int end) {\n  if (start < end) {\n    int p = partition(numbers, start, end);\n      sort(numbers, start, p - 1);\n      sort(numbers, p + 1, end);\n  }\n}  \n```", "```java\nmergeSort(array, start, end)\n  if(_____________)\n    midPoint = _________\n    mergeSort(array, _____, _____)\n    mergeSort(array, _____, _____)\n    merge(array, start, midPoint, end)  \n```", "```java\nmergeSort(array, start, end)\n  if(start < end)\n    midPoint = (end - start) / 2 + start\n    mergeSort(array, start, midPoint)\n    mergeSort(array, midPoint + 1, start)\n    merge(array, start, midPoint, end) \n```", "```java\ncopyArray() function simply takes in a source array as a first argument and copies it to the target array, that is, the second argument. It makes use of the start variable as a pointer, indicating where to place the first element of the source array onto the target one. The pseudocode is as follows:\n```", "```java\nmerge(array, start, middle, end)\n  i = start\n  j = middle + 1\n  arrayTemp = initArrayOfSize(end - start + 1)\n  for (k = 0 until end-start)\n    if (i <= middle && (j > end || array[i] <= array[j]))\n      arrayTemp[k] = array[i]\n      i++\n    else\n      arrayTemp[k] = array[j]\n      j++\n  copyArray(arrayTemp, array, start)  \n```", "```java\npublic class LinkedListNode<V> {\n  private V value;\n  private LinkedListNode<V> next;  \n  public LinkedListNode(V value, LinkedListNode<V> next) {\n    this.value = value;\n    this.next = next;\n  }\n  public Optional<LinkedListNode<V>> getNext() {\n    return Optional.ofNullable(next);\n  }\n} \n```", "```java\npublic class DblLinkedListNode<V> {\n  private V value;\n  private DblLinkedListNode<V> next;\n  private DblLinkedListNode<V> previous;\n  public DblLinkedListNode(V value,\n  DblLinkedListNode<V> next,\n  DblLinkedListNode<V> previous) {\n    this.value = value;\n    this.next = next;\n    this.previous = previous;\n  }\n} \n```", "```java\npublic class LinkedList<V> {\n  private LinkedListNode<V> head;\n  public LinkedList() {\n    head = null;\n  }\n}  \n```", "```java\naddFront() and deleteFront() operations for a linked list. For the addFront() method, we simply create a new node with its next pointer set as the current head pointer. Then, we assign the head to the new node. Notice in the delete method how we make use of Java's Optional objects. If the head pointer is null, it will stay null and we don't change anything. Otherwise, we flatten it to the next pointer. Finally, we set the first node's next pointer as null. This last step is not necessary since the orphaned node will be garbage collected; however, we're including it for completeness.\n```", "```java\npublic void addFront(V item) {\n  this.head = new LinkedListNode<>(item, head);\n}\npublic void deleteFront() {\n  Optional<LinkedListNode<V>> firstNode = Optional.\n  ofNullable(this.head);\n  this.head = firstNode.flatMap(LinkedListNode::getNext).\n  orElse(null);\n  firstNode.ifPresent(n -> n.setNext(null));\n}  \n```", "```java\nOptional methods. We start a while loop from the head pointer and keep on moving to the next node as long as there is a node present and that node doesn't contain the item we're looking for. We then return the last pointer, which can be an empty optional or a node containing a match:\n```", "```java\npublic Optional<LinkedListNode<V>> find(V item) {\n  Optional<LinkedListNode<V>> node = Optional.ofNullable(this.head);\n```", "```java\n\n  while (node.filter(n -> n.getValue() != item).isPresent()) {\n    node = node.flatMap(LinkedListNode::getNext);\n  }\n  return node;\n}  \n```", "```java\npublic void addAfter(LinkedListNode<V> aNode, V item) {\n  aNode.setNext(new LinkedListNode<>(item, aNode.getNext().orElse(null)));\n}  \n```", "```java\npublic String toString() {\n}  \n```", "```java\ndequeue(head)\n  if (head != null)\n    node = head\n    head = head.next\n    if (head != null) head.previous = null\n    return node.value\n  return null\nenqueue(tail, item)\n  node = new Node(item)\n  node.previous = tail\n  if (tail != null) tail.next = node\n  if (head == null) head = node\n  tail = node  \n```", "```java\npublic class Queue<V> {\n  private DblLinkedListNode<V> head;\n  private DblLinkedListNode<V> tail;\n  public void enqueue(V item)\n  public Optional<V> dequeue()\n} \n```", "```java\npublic void enqueue(V item) {\n  DblLinkedListNode<V> node = new DblLinkedListNode<>(item, null, tail);\n  Optional.ofNullable(tail).ifPresent(n -> n.setNext(node));\n  tail = node;\n  if(head == null) head = node;\n}  \n```", "```java\npublic void push(V item) {\n  head = new LinkedListNode<V>(item, head);\n}\npublic Optional<V> pop() {\n  Optional<LinkedListNode<V>> node = Optional.ofNullable(head);\n  head = node.flatMap(LinkedListNode::getNext).orElse(null);\n  return node.map(LinkedListNode::getValue);\n}  \n```", "```java\npublic String reverse(String str) \n```", "```java\npublic String reverse(String str) {\n  StringBuilder result = new StringBuilder();\n  Stack<Character> stack = new Stack<>();\n  for (char c : str.toCharArray())\n  stack.push(c);\n  Optional<Character> optChar = stack.pop();\n  while (optChar.isPresent()) {\n    result.append(optChar.get());\n    optChar = stack.pop();\n  }\n  return result.toString();\n} \n```", "```java\npublic StackArray(int capacity) {\n  array = (V[]) new Object[capacity];\n}\npublic void push(V item) {\n  array[headPtr++] = item;\n}\npublic Optional<V> pop() {\n  if (headPtr > 0) return Optional.of(array[--headPtr]);\n  else return Optional.empty();\n}  \n```", "```java\nmod operator. When the pointer is larger or equal to the size of the array, it wraps around and starts again from zero. The same happens on the dequeue method, where we access and increment the head pointer in a similar fashion. The following code demonstrates it:\n```", "```java\npublic void enqueue(V item) {\n  array[tailPtr] = item;\n  tailPtr = (tailPtr + 1) % array.length;\n}\npublic Optional<V> dequeue() {\n  if (headPtr != tailPtr) {\n    Optional<V> item = Optional.of(array[headPtr]);\n    headPtr = (headPtr + 1) % array.length;\n    return item;\n  } else return Optional.empty();\n}  \n```", "```java\npublic boolean enqueueSafe(V item)\npublic Optional<V> dequeueSafe()  \n```", "```java\nprivate boolean full = false;\npublic boolean enqueueSafe(V item) {\n  if (!full) {\n    array[tailPtr] = item;\n    tailPtr = (tailPtr + 1) % array.length;\n    this.full = tailPtr == headPtr;\n    return true;\n  }\n  return false;\n}  \n```", "```java\n public double evaluate(String postfix) \n```"]