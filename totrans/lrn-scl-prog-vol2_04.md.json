["```java\nobject RESTFulAPIs extends App { \n    //List of Method and URI \n    val listOfAPIs = List((\"GET\", \"/user/:id\"), \n                          (\"GET\", \"user/:id/profile/:p_id\"), \n                          (\"POST\", \"/user\"), \n                          (\"POST\", \"/profile\"), \n                          (\"PUT\", \"/user/:id\")) \n\n    /* \n     * Returns a scala.collection.immutable.Map[String,  List[(String,String)]] \n     */ \n    val groupedListOfAPIs = listOfAPIs.groupBy(_._1) \n    println(s\"APIs grouped to a Map :: $groupedListOfAPIs\") \n\n    /* \n     * Returns a scala.collection.immutable.Map[String, List[String]] \n     */ \n    val apisByMethod = groupedListOfAPIs.mapValues(_.map(_._2)) \n    println(s\"APIs By Method :: $apisByMethod\") \n} \n```", "```java\nAPIs grouped to a Map :: Map(POST -> List((POST,/user), (POST,/profile)), GET -> List((GET,/user/:id), (GET,user/:id/profile/:p_id)), PUT -> List((PUT,/user/:id))) \nAPIs By Method :: Map(POST -> List(/user, /profile), GET -> List(/user/:id, user/:id/profile/:p_id), PUT -> List(/user/:id)) \n```", "```java\nMap(POST -> List((POST,/user), (POST,/profile)), GET -> List((GET,/user/:id), (GET,user/:id/profile/:p_id)), PUT -> List((PUT,/user/:id))) \n```", "```java\ndef mapValues[W](f: V => W): Map[K, W] \n```", "```java\nscala> val studentsPresent = List(\"Alex\", \"Bob\", \"Chris\") \n\nstudentsPresent: List[String] = List(Alex, Bob, Chris) \n```", "```java\ndef afunction(xs: scala.collection.Iterable[String]) = ??? \n```", "```java\ndef afunction(xs: scala.collection.Iterable[String]) \n```", "```java\ntrait Traversable[+A] extends TraversableLike[A, Traversable[A]] with GenTraversable[A] with TraversableOnce[A] with GenericTraversableTemplate[A, Traversable] \n```", "```java\ndef foreach[U](f: Elem => U) \n```", "```java\ndef iterator: Iterator[A] \n```", "```java\ntrait Iterable[+A] extends Traversable[A] with GenIterable[A] with GenericTraversableTemplate[A, Iterable] with IterableLike[A, Iterable[A]] \n```", "```java\ntrait Seq[+A] extends PartialFunction[Int, A] with Iterable[A] with GenSeq[A] with GenericTraversableTemplate[A, Seq] with SeqLike[A, Seq[A]]\n```", "```java\nscala> val aSeq = scala.collection.LinearSeq[Int](1,2,3,4) \naSeq: scala.collection.LinearSeq[Int] = List(1, 2, 3, 4) \n\nscala> aSeq(1) \nres0: Int = 2 \n```", "```java\nscala> aSeq(5) \njava.lang.IndexOutOfBoundsException: 5 \n  at scala.collection.LinearSeqOptimized.apply(LinearSeqOptimized.scala:63) \n  at scala.collection.LinearSeqOptimized.apply$(LinearSeqOptimized.scala:61) \n  at scala.collection.immutable.List.apply(List.scala:86) \n  ... 29 elided \n```", "```java\ntrait Map[K, +V] extends Iterable[(K, V)] with GenMap[K, V] with MapLike[K, V, Map[K, V]] \n```", "```java\nscala> val aMap = Map(\"country\" -> \"capital\", \"Poland\" -> \"Warsaw\") \n\naMap: scala.collection.immutable.Map[String, String] = Map(country -> capital, Poland -> Warsaw) \n```", "```java\ntrait Set[A] extends (A) ⇒ Boolean with Iterable[A] with GenSet[A] with GenericSetTemplate[A, Set] with SetLike[A, Set[A]] \n```", "```java\nscala> val aSet = Set(1,2,3,4) \naSet: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4) \n\nscala> aSet(2) \nres0: Boolean = true \n\nscala> aSet(5) \nres1: Boolean = false \n\nscala> aSet(0) \nres2: Boolean = false \n```", "```java\nval aList = List(1,2,3,4) \n```", "```java\n1 :: 2 :: 3 :: 4 :: Nil \n```", "```java\nscala> aList.::(5) \nres2: List[Int] = List(5, 1, 2, 3, 4) \n```", "```java\nscala> 5 :: aList\nres0: List[Int] = List(5, 1, 2, 3, 4)\n```", "```java\nscala> val aMap = Map(1 -> \"one\", 2 -> \"two\", 3 -> \"three\") \naMap: scala.collection.immutable.Map[Int,String] = Map(1 -> one, 2 -> two, 3 -> three) \n```", "```java\nscala> aMap.+(4 -> \"four\") \nres5: scala.collection.immutable.Map[Int, String] = Map(1 -> one, 2 -> two, 3 -> three, 4 -> four) \n```", "```java\nscala> println(aMap) \nMap(1 -> one, 2 -> two, 3 -> three) \n```", "```java\nscala> aMap.isDefinedAt(4) \nres8: Boolean = false \n\nscala> aMap.isDefinedAt(2) \nres9: Boolean = true \n```", "```java\nTreeSet()(implicit ordering: Ordering[A]) \n```", "```java\npackage chapter5 \n\nimport scala.collection.immutable.TreeSet \n\nobject TreeSetImpl extends App { \n\n  //implicit val ordering = Ordering.fromLessThan[Int](_ > _) \n\n  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) \n\n  println(treeSet) \n} \n```", "```java\nError:(9, 17) diverging implicit expansion for type scala.math.Ordering[T1] \nstarting with method Tuple9 in object Ordering \n  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) \nError:(9, 17) not enough arguments for constructor TreeSet: (implicit ordering: Ordering[A])scala.collection.immutable.TreeSet[A]. \nUnspecified value parameter ordering. \n  val treeSet = new TreeSet() + (1, 3, 12, 3, 5) \n```", "```java\nTreeSet(12, 5, 3, 1) \n```", "```java\nscala> val aStream = Stream(1,2,3,4,55,6) \naStream: scala.collection.immutable.Stream[Int] = Stream(1, ?) \n```", "```java\nscala.collection.immutable.Stream[Int] = Stream(1, ?) \n```", "```java\nscala> val anotherStream = 1 #:: 2 #:: 3 #:: Stream.empty \nanotherStream: scala.collection.immutable.Stream[Int] = Stream(1, ?) \n```", "```java\nscala> val vector = Vector(1,2,3) \nvector: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3) \n\nscala> println(vector) \nVector(1, 2, 3) \n```", "```java\nscala> vector :+ 4 \nres12: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4) \n\nscala> 4 +: vector  \nres15: scala.collection.immutable.Vector[Int] = Vector(4, 1, 2, 3) \n```", "```java\nscala> vector(2) \nres16: Int = 3 \n```", "```java\nscala> vector.isDefinedAt(5) \nres17: Boolean = false \n```", "```java\nscala> vector.updated(2,10) \nres19: scala.collection.immutable.Vector[Int] = Vector(1, 2, 10) \n```", "```java\nscala> println(vector) \nVector(1, 2, 3) \n```", "```java\nscala> val stack = Stack(1,2,3) \nstack: scala.collection.immutable.Stack[Int] = Stack(1, 2, 3) \n\nscala> stack.pop \nres24: scala.collection.immutable.Stack[Int] = Stack(2, 3) \n\nscala> stack.push(4) \nres26: scala.collection.immutable.Stack[Int] = Stack(4, 1, 2, 3) \n```", "```java\nscala> val queue = Queue(1,2,3) \nqueue: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3) \n\nscala> queue.enqueue(4) \nres27: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3, 4) \n\nscala> queue.dequeue \nres28: (Int, scala.collection.immutable.Queue[Int]) = (1,Queue(2, 3)) \n```", "```java\nscala> val oneTo10 = 1 to 10 \noneTo10: scala.collection.immutable.Range.Inclusive = Range 1 to 10 \n\nscala> val oneTo10By2 = 1 to 10 by 2 \noneTo10By2: scala.collection.immutable.Range = inexact Range 1 to 10 by 2 \n\nscala> oneTo10 foreach println \n1 \n2 \n3 \n4 \n. . . remaining elements \n\nscala> oneTo10By2 foreach println \n1 \n3 \n5 \n7 \n9 \n```", "```java\nscala> val oneUntil5 = 1 until 5 \noneUntil5:scala.collection.immutable.Range = Range 1 until 5 \n\nscala> oneUntil5 foreach println \n1 \n2 \n3 \n4 \n```", "```java\nscala> import scala.collection.mutable._ \nimport scala.collection.mutable._ \n\nscala> val buff = ArrayBuffer(1,2,3) \nbuff: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)  \n\nscala> println(buff) \nArrayBuffer(1, 2, 3) \n```", "```java\nscala> buff += 4 \nres35: buff.type = ArrayBuffer(1, 2, 3, 4) \n\nscala> println(buff) \nArrayBuffer(1, 2, 3, 4) \n\nscala> buff -= 4 \nres36: buff.type = ArrayBuffer(1, 2, 3) \n\nscala> println(buff) \nArrayBuffer(1, 2, 3) \n```", "```java\nscala> val listBuffer = ListBuffer(\"Alex\", \"Bob\", \"Charles\") \nlistBuffer: scala.collection.mutable.ListBuffer[String] = ListBuffer(Alex, Bob, Charles) \n\nscala> listBuffer += \"David\" \nres39: listBuffer.type = ListBuffer(Alex, Bob, Charles, David) \n\nscala> println(listBuffer) \nListBuffer(Alex, Bob, Charles, David) \n```", "```java\nscala> val builder = new StringBuilder \nbuilder: StringBuilder = \n\nscala> builder ++= \"aa\" \nres45: builder.type = aa \n\nscala> builder ++= \"b\" \nres46: builder.type = aab \n\nscala> builder.toString \nres48: String = aab \n```", "```java\nfinal class Array[T] extends java.io.Serializable with java.lang.Cloneable \n```", "```java\nscala> val array = Array(\"about\", \"to\", \"declare\") \narray: Array[String] = Array(about, to, declare) \n```", "```java\nscala> array(0) = \"Where\" \n\nscala> array foreach println \nWhere \nto \ndeclare \n```", "```java\npackage chapter5 \n\nobject CollectionOperations extends App { \n\n  val source = io.Source.fromFile(\"../src/chapter5/football_stats.csv\")   // Give pathString for the csv file \n\n} \n```", "```java\nio.Source.fromFile(\"filePath\") \n```", "```java\ncase class Player(name: String, nationality: String, age: String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) \n```", "```java\nsource.getLines().toList \n```", "```java\n2016,Up/down,2015,2014,2013,Name,Nationality, Club at Dec 20 2016,Domestic league, Age at 20 Dec 2016,RAW TOTAL,HIGHEST SCORE REMOVED,FINAL SCORE,VOTES CAST,No1 PICK \n```", "```java\ndef giveMePlayers(list: List[String]): List[Player] = list match { \n    case head :: tail => tail map {line => \n      val columns = line.split((\",\")).map(_.trim) \n      Player(columns(5),columns(6),columns(9),columns(7), \n        columns(8),columns(10), columns(12), columns(0),columns(2)) \n    } \n    case Nil => List[Player]() \n  } \n```", "```java\ndef map[B](f: (A) ⇒ B): Traversable[B] \n```", "```java\npackage chapter5 \n\nobject CollectionOperations extends App { \n\n  val source = io.Source.fromFile(\"/Users/vika/Documents/LSProg/LSPWorkspace/FirstProject/src/chapter5/football_stats.csv\") \n  val bufferedSourceToList: List[String] = { \n    val list = source.getLines().toList \n    source.close() \n    list \n  } \n\n  def giveMePlayers(list: List[String]): List[Player] = list match { \n      case head :: tail => tail map {line => \n        val columns = line.split((\",\")).map(_.trim) \n        Player(columns(5),columns(6),columns(9),columns(7), \n          columns(8),columns(10), columns(12), columns(0),columns(2)) \n      } \n      case Nil => List[Player]() \n    } \n\n  val players = giveMePlayers(bufferedSourceToList)} \n\ncase class Player(name: String, nationality: String, age:String, club: String, domesticLeague: String, rawTotal: String, finalScore: String, ranking2016: String, ranking2015: String) \n```", "```java\nval filterTop10 = players filter(_.ranking2016.toInt < 11)\n```", "```java\ndef filter(p: A => Boolean): Repr \n```", "```java\ndef showPlayers(players: List[Player]) = players.foreach{p => \n  println(s\"\"\"Player: ${p.name}    Country: ${p.nationality}   Ranking 2016: ${p.ranking2016}\n\n***** Other Information *****\nAge: ${p.age}  |  Club: ${p.club}  |  Domestic League: ${p.domesticLeague}\nRaw Total: ${p.rawTotal}  |  Final Score: ${p.finalScore}  |  Ranking 2015: ${p.ranking2015}\n##########################################################\"\"\")\n }\n```", "```java\nPlayer: Cristiano Ronaldo  Country: Portugal       Ranking 2016: 1  \n\n***** Other Information *****  \nAge: 32  |  Club: Real Madrid  |  Domestic League: Spain  \nRaw Total: 4829  |  Final Score: 4789  |  Ranking 2015: 2 \n########################################################## \n```", "```java\nval takeTop10 = players takeWhile(_.ranking2016.toInt < 11) \n```", "```java\ndef takeWhile(p: (A) ⇒ Boolean): Traversable[A] \n\ndef dropWhile(p: (A) ⇒ Boolean): Traversable[A] \n```", "```java\nval first50Players = players take 50 \nval (top20,least30) = first50Players partition(_.ranking2016.toInt < 21) \nshowPlayers(top20) \n```", "```java\ndef drop(n: Int): Traversable[A] \n\ndef take(n: Int): Traversable[A] \n\ndef partition(p: (A) ⇒ Boolean): (Traversable[A], Traversable[A]) \n```", "```java\ndef slice(from: Int, until: Int): Traversable[A] \n\ndef span(p: (A) ⇒ Boolean): (Traversable[A], Traversable[A]) \n\ndef splitAt(n: Int): (Traversable[A], Traversable[A]) \n```", "```java\nSelect Players from Germany who have ranking in Top 50\\. \n\nfirst50Players filter(_.nationality.equals(\"Germany\")) \n```", "```java\nval isGermanPlayer: (Player => Boolean) = _.nationality.equalsIgnoreCase(\"Germany\") \n\nval numberOfGermanPlayers = players count isGermanPlayer \nprintln(s\"German Players: $numberOfGermanPlayers\") \n\nRun: \nGerman Players: 17 \n```", "```java\nval isAnyPlayerAbove45 = players exists(p => p.age.toInt > 40) \nprintln(s\"isAnyPlayerAbove45: $isAnyPlayerAbove45\") \n\nRun: \nisAnyPlayerAbove45: false \n```", "```java\nval topPlayerWithAge35plus = players find(p => p.age.toInt > 35) \nprintPlayer(topPlayerWithAge35plus.get) \n\nRun: \nPlayer: Zlatan Ibrahimovic       Country: Sweden   Ranking 2016: 20  \n\n***** Other Information *****  \nAge: 36  |  Club: Manchester United  |  Domestic League: England  \nRaw Total: 1845  |  Final Score: 1809  |  Ranking 2015: 7 \n########################################################## \n```", "```java\nval top5PlayerWithAge35plus = players filter isAge35plus take 5 \nshowPlayers(top5PlayerWithAge35plus) \n\nRun: \nPlayer: Zlatan Ibrahimovic       Country: Sweden   Ranking 2016: 20  \n\n***** Other Information *****  \nAge: 36  |  Club: Manchester United  |  Domestic League: England  \nRaw Total: 1845  |  Final Score: 1809  |  Ranking 2015: 7 \n########################################################## \n. . . and next 4 player information \n```", "```java\ndef find(p: (A) ⇒ Boolean): Option[A] \n\ndef count(p: (A) ⇒ Boolean): Int \n\ndef exists(p: (A) ⇒ Boolean): Boolean \n\ndef forall(p: (A) ⇒ Boolean): Boolean \n```", "```java\nval Top20Countries = top20.foldLeft(List[String]())((b,a) => a.nationality :: b)\n```", "```java\nList(Sweden, England, Germany, France, France, Spain, Argentina, Belgium, Croatia, Argentina, Algeria, Chile, Gabon, Poland, Wales, Brazil, France, Uruguay, Argentina, Portugal)\n```", "```java\nval top20Countries = top20.foldRight(List[String]())((b,a) => b.nationality :: a) \n```", "```java\nList(Portugal, Argentina, Uruguay, France, Brazil, Wales, Poland, Gabon, Chile, Algeria, Argentina, Croatia, Belgium, Argentina, Spain, France, France, Germany, England, Sweden) \n```", "```java\ndef foldLeft[B](z: B)(op: (B, A) ⇒ B): B \n\ndef foldRight[B](z: B)(op: (A, B) => B): B \n```", "```java\ntop20Countries.par map(println(_)) \n```", "```java\nWales \nPortugal \nArgentina \nFrance \nCroatia \nArgentina \nPoland \nFrance \nUruguay \n. .. remaining elements \n```", "```java\nscala> import scala.collection.parallel.mutable._ \nimport scala.collection.parallel.mutable._ \n\nscala> val pararr = ParArray(1,2,3,4,5,6,7,8,9,10) \npararr: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \n```", "```java\nscala> pararr.seq \nres1: scala.collection.mutable.ArraySeq[Int] = ArraySeq(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \n```", "```java\nscala> val parvec = Vector(1,2,3,4,5,6,7,8,9,10) \nparvec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \n```", "```java\nscala> parvec.filter(_ > 5) \nres0: scala.collection.immutable.Vector[Int] = Vector(6, 7, 8, 9, 10) \n\nAnd yes we can anytime convert our collection to it's sequential version using seq method. \n\nscala> parvec.seq \nres1: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \n```", "```java\npackage chapter5\n\nimport java.time.LocalDate\nimport scala.collection.JavaConverters._\n\nobject CollectionConvertors extends App {\n    /*\n     We'll create a java collection of a couple of days and convert it to Scala Collection\n     */\n    val aJavaList = new java.util.ArrayList[LocalDate]()\n    aJavaList.add(LocalDate.now())\n    aJavaList.add(aJavaList.get(0).plusDays(1))\n\n    println(s\"Java List of today and tomorrow: $aJavaList\")\n\n    val scalaDates = aJavaList.asScala\n    scalaDates map { date =>\n      println(s\"Date :: $date\")\n    }\n\n    val backToJavaList = scalaDates.asJavaCollection\n    println(backToJavaList)\n}\n```", "```java\nJava List of today and tomorrow: [2017-10-01, 2017-10-02]\nDate :: 2017-10-01\nDate :: 2017-10-02\n[2017-10-01, 2017-10-02]\n```", "```java\nval backToJavaList = scalaDates.asJava \nprintln(backToJavaList) \n```"]