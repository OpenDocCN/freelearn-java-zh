- en: RxJava on Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 上的 RxJava
- en: If there is one domain that reactive programming has taken by storm, it is definitely
    mobile apps. As discussed throughout this book, ReactiveX is highly useful for
    many domains. But mobile apps are becoming increasingly complex, and users have
    a short tolerance for apps that are unresponsive, slow, or buggy. Therefore, mobile
    applications were quick to be early adopters of ReactiveX to solve these problems.
    RxSwift has quickly become popular on iOS after RxJava got a foothold on Android.
    There are also RxAndroid and RxBinding libraries to integrate RxJava easily with
    the Android environment, which we will cover in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个领域被反应式编程所席卷，那无疑是移动应用。正如本书中讨论的那样，ReactiveX 在许多领域都非常有用。但是，移动应用正变得越来越复杂，用户对无响应、缓慢或存在错误的应用的容忍度很低。因此，移动应用迅速成为
    ReactiveX 的早期采用者，以解决这些问题。RxJava 在 Android 上站稳脚跟后，RxSwift 迅速在 iOS 上流行起来。还有 RxAndroid
    和 RxBinding 库，可以将 RxJava 与 Android 环境轻松集成，我们将在本章中介绍。
- en: One of the pain points that Android developers have coped with for some time
    is being stuck with Java 6\. This means that many of the widely used versions
    of Android (KitKat, Lollipop, and Marshmallow) do not support Java 8 lambdas (although
    this changed in Android Nougat, which finally uses OpenJDK 8). At first glance,
    this means you are stuck using boilerplate-riddled anonymous classes to express
    your RxJava operators (refer to Appendix A for examples). However, by using Retrolambda,
    you can, in fact, use earlier versions of Android while using lambdas, which we
    will go through in this chapter. Another option you have is using the Kotlin language,
    which has become an increasingly popular platform for Android development. Kotlin
    is an arguably more modern and expressive language than Java and can compile to
    Java 6 bytecode. We will cover Kotlin with RxJava in the next chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android 开发者长期以来一直面临的一个痛点是困于 Java 6。这意味着许多广泛使用的 Android 版本（如 KitKat、Lollipop
    和 Marshmallow）不支持 Java 8 lambdas（尽管在 Android Nougat 中有所改变，它最终使用了 OpenJDK 8）。乍一看，这意味着你只能使用满是样板代码的匿名类来表达你的
    RxJava 操作符（有关示例，请参阅附录 A）。然而，通过使用 Retrolambda，你实际上可以在使用 lambda 的同时使用更早版本的 Android，我们将在本章中介绍这一点。你还有另一个选择，那就是使用
    Kotlin 语言，它已经成为 Android 开发的越来越受欢迎的平台。Kotlin 是一种可能比 Java 更现代、更具有表现力的语言，并且可以编译成
    Java 6 字节码。我们将在下一章中介绍 Kotlin 与 RxJava 的结合使用。
- en: If you have no interest in Android development, feel free to skip this chapter.
    But the rest of you reading this book are most likely Android developers, so it
    is assumed that you have done some Android development already.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有兴趣进行 Android 开发，请随意跳过本章。但本书的其余部分读者很可能是 Android 开发者，因此假设你已经进行了一些 Android
    开发。
- en: 'If you have little or no experience with Android and would like to learn, a
    great book to get started is *Android Programming: The Big Nerd Ranch Guide* by
    Bill Phillips, Chris Stewart, and Kristin Marsicano ([https://www.bignerdranch.com/books/android-programming/](https://www.bignerdranch.com/books/android-programming/)).
    It is an excellent book to become thoroughly proficient in Android development
    quickly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你几乎没有 Android 经验，但想学习，一本很好的入门书籍是 Bill Phillips、Chris Stewart 和 Kristin Marsicano
    所著的 *Android 编程：大牛牧场指南* ([https://www.bignerdranch.com/books/android-programming/](https://www.bignerdranch.com/books/android-programming/))。这是一本很好的书籍，可以帮助你快速精通
    Android 开发。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating an Android project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Android 项目
- en: Configuring RxJava for Android
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Android 配置 RxJava
- en: Using RxJava and RxAndroid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxJava 和 RxAndroid
- en: Using RxBinding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxBinding
- en: Other Android Rx libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 Android Rx 库
- en: Creating the Android project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Android 项目
- en: 'We are going to use Android Studio for the examples in this chapter, with Android
    5.1 Lollipop as our platform target. Launch Android Studio and create a new project,
    as shown in the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的示例中使用 Android Studio，以 Android 5.1 Lollipop 作为我们的平台目标。启动 Android Studio
    并创建一个新项目，如图所示：
- en: '![](img/4d596710-1de2-42c7-bf8f-72006de4d4a2.png)**Figure 11.1**: Creating
    a new Android project'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/4d596710-1de2-42c7-bf8f-72006de4d4a2.png)**图 11.1**：创建新的 Android 项目'
- en: 'In the next screen (shown in the following figure), name your project `RxJavaApp` with
    a Company domain of `packtpub.com` or whatever you prefer. Then, click on Next:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕（如图所示），将你的项目命名为 `RxJavaApp`，公司域为 `packtpub.com` 或你喜欢的任何名称。然后，点击“下一步”：
- en: '![](img/06bfe1a9-f210-4e34-bc1a-5e43f493a23f.png)**Figure 11.2**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/06bfe1a9-f210-4e34-bc1a-5e43f493a23f.png)**图 11.2**'
- en: 'We are going to target Phone and Tablet. Since we may want our app to be compatible
    with devices running earlier versions of Android, let''s select Android 5.1 (Lollipop) as
    our Minimum SDK. This will also give us an opportunity to practice using Retrolambda.
    After this, click on Next:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35755247-1c34-4a53-ac17-52b0703e7460.png)**Figure 11.3**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, choose Empty Activity as our your template, as shown in
    the following figure. Then, click on Next. As you probably know, an activity is
    one interactive screen containing controls. For the examples in this chapter,
    we will use one activity:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0273d2b-c1f9-40f6-9f8e-75aa208ad804.png)**Figure 11.4**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to the final screen to configure the Activity. Feel free to
    leave Activity Name as `MainActivity` and its corresponding Layout Name as `activity_main`.
    We will populate this Activity later. Then, click on Finish:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c67d61f-d913-4a1f-92f5-65540c7a2740.png)**Figure 11.5**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now come to a screen shortly with your entire Android project, and
    it should already be configured with Gradle. Open `build.gradle (Module: app)`
    so we can configure our required dependencies next, as shown in the following
    figure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f06ad898-3a2d-47ee-8724-50963125ead3.png)**Figure 11.6**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You will need to make a few changes to the `build.gradle` script targeting the
    app module so we can use RxJava and Retrolambda.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Retrolambda
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's get Retrolambda set up. We will also leverage a quick unit test
    to see whether it works correctly. Open the `ExampleUnitTest.java` file that was
    created with the project template. Remove the sample unit test method inside it
    and declare a new one called `lambdaTest()`. Inside it, try to declare a `Callable<Integer>`
    with a lambda, as shown in the following figure. Note that it throws a compiler
    error because we are not using Java 8 to support lambdas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d60d10f6-2e77-4130-ac3e-22a2c35bfbb9.png)**Figure 11.7** - Lambdas
    are not supported with this Android and Java version'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use Java 8 if we are targeting Android Lollipop, so we need Retrolambda
    to save us from creating boilerplate-riddled anonymous inner classes. It will
    compile our lambdas to anonymous classes at the bytecode level, so it supports
    Java 6.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'To get Retrolambda set up, we are going to use the gradle-retrolambda plugin
    to make the configuration process as seamless as possible. Go back to your `build.gradle
    (Module: app)` script and modify it like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Click on the Sync Now prompt after you save the script to rebuild the project.
    The big change to note in the preceding code is that we added a buildscript `{
    }` block that brings in Retrolambda 3.6.1 as a dependency from `mavenCentral()`.
    We can then apply the retrolambda plugin. Finally, we add a `compileOptions {
    }` block inside the android `{ }` one and set the source and target to be compatible
    with Java 8.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Run our unit test containing our lambda now. Score! As shown in the following
    figure, everything compiles and runs successfully, and we are now running lambdas
    on Java 6! Let''s take a look:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行包含我们lambda的单元测试。得分！如图所示，一切编译和运行都成功，我们现在可以在Java 6上运行lambda了！让我们看看：
- en: '![](img/a1f577b0-7768-4173-b27f-9b7c15c82d54.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1f577b0-7768-4173-b27f-9b7c15c82d54.png)'
- en: Figure 11.8 - We can now use lambdas with Java 6 on Android Lollipop with Retrolambda
    set up
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 现在我们可以使用Retrolambda在Android Lollipop上使用Java 6的lambda
- en: '**Retrolambda** is a brilliant tool for Android developers constrained to using
    Java 6\. It cleverly compiles lambdas as traditional anonymous classes, and you
    can save yourself some terrible boilerplate work when using RxJava.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Retrolambda** 是一个针对使用Java 6受限的Android开发者而言的绝佳工具。它巧妙地将lambda编译为传统的匿名类，使用RxJava时，你可以节省一些糟糕的样板工作。'
- en: To learn more about Retrolambda and additional tweaks and configurations you
    can make, check out its GitHub page at [https://github.com/evant/gradle-retrolambda](https://github.com/evant/gradle-retrolambda).
    At the time of writing this, there are also upcoming lambda tools on Android Studio
    ([https://developer.android.com/studio/preview/features/java8-support.html](https://developer.android.com/studio/preview/features/java8-support.html)).
    These features may serve as an alternative to Retrolambda.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Retrolambda以及你可以进行的额外调整和配置，请查看其GitHub页面[https://github.com/evant/gradle-retrolambda](https://github.com/evant/gradle-retrolambda)。在撰写本文时，Android
    Studio中也有即将推出的lambda工具([https://developer.android.com/studio/preview/features/java8-support.html](https://developer.android.com/studio/preview/features/java8-support.html))。这些功能可能作为Retrolambda的替代品。
- en: Configuring RxJava and friends
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置RxJava和相关库
- en: Now that the hard part is over and you have Retrolambda set up, all that is
    left for the configuration is bringing in RxJava and RxAndroid. Another set of
    libraries to add to your stack is Jake Wharton's RxBinding ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding)),
    which streamlines RxJava usage for Android UI controls.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在艰难的部分已经结束，你已经设置了Retrolambda，剩下的配置就是引入RxJava和RxAndroid。需要添加到你的堆栈中的另一组库是Jake
    Wharton的RxBinding ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding))，它简化了RxJava在Android
    UI控件中的使用。
- en: 'Add these three libraries to your dependencies `{ }` block for your module
    (not the one inside the buildscript `{ }` block!):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个库添加到你的模块（不是buildscript块内的模块）的依赖项 `{ }` 块中：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So these should now be your full `build.gradle (Module: app)` contents:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，现在应该是你的完整 `build.gradle (Module: app)` 内容：'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ensure that you click on the Sync Now prompt to rebuild the project with these
    dependencies in place. For the remainder of the chapter, we will touch on a few
    ways in which you can use RxJava, RxAndroid, and RxBinding together in your Android
    application. I could easily write a small book about different reactive features,
    bindings, and patterns you can use with Android, but in this chapter, we will
    take a minimalistic approach to focus on the core Rx features. We will touch on
    other libraries and resources you can research at the end of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你点击“立即同步”提示以使用这些依赖项重新构建项目。在本章的剩余部分，我们将讨论你可以在Android应用程序中使用RxJava、RxAndroid和RxBinding的几种方式。我可以轻松地写一本关于你可以与Android一起使用的不同响应式功能、绑定和模式的小书，但在这章中，我们将采用极简主义方法，专注于核心Rx功能。我们将在本章末尾讨论你可以研究的其他库和资源。
- en: Using RxJava and RxAndroid
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJava和RxAndroid
- en: The primary feature of the RxAndroid library ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid))
    is that it has Android Schedulers to help your concurrency goals for your Android
    app. It has a Scheduler for the Android main thread as well as an implementation
    that can target any message Looper. Striving to be a core library, RxAndroid does
    not have many other features. You will need specialized reactive binding libraries
    for Android to do more than that, which we will explore later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: RxAndroid库([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid))的主要功能是它具有Android
    Schedulers，可以帮助你实现Android应用程序的并发目标。它有一个针对Android主线程的Scheduler，以及一个可以针对任何消息Looper的实现。RxAndroid力求成为一个核心库，它没有许多其他功能。你需要专门的响应式绑定库来做更多的事情，我们将在稍后探讨。
- en: Let's start simple. We will modify `TextView` in the middle of our `MainActivity`
    (which already contains "`Hello World!`") to change to "`Goodbye World!`" after
    3 seconds. We will do all of this reactively using `Observable.delay()`. Because
    this will emit on a computational Scheduler, we will need to leverage `observeOn()`
    to safely switch the emission to the Android main thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始。我们将修改`MainActivity`中间的`TextView`（它已经包含"`Hello World!`"）在3秒后改为"`Goodbye
    World!`"。我们将使用`Observable.delay()`以响应式的方式完成所有这些。因为这将在一个计算调度器上发射，所以我们需要利用`observeOn()`来安全地将发射切换到Android主线程。
- en: 'First, in the `res/layout/activity_main.xml` file, modify the `TextView` block
    to have an ID property called `my_text_view` (as shown in the following code).
    This way, we can refer to it from our app code in a moment:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`res/layout/activity_main.xml`文件中，修改`TextView`块以具有一个ID属性名为`my_text_view`（如下所示）。这样，我们就可以在稍后从我们的应用程序代码中引用它：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, rebuild your project and go to the `MainActivity.java` file. In the
    `onCreate()` method implementation, we are going to look up our "`my_text_view`"
    component and save it to a variable called `myTextView` (and cast it to `TextView`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重新构建你的项目并转到`MainActivity.java`文件。在`onCreate()`方法实现中，我们将查找我们的"`my_text_view`"组件并将其保存到一个名为`myTextView`的变量中（并将其转换为`TextView`）。
- en: 'Then, immediately, we are going to create an `Observable` emitting just the
    string `Goodbye World!` and delay it for 3 seconds. Because `delay()` will put
    it on a computational Scheduler, we will use `observeOn()` to put that emission
    back in `AndroidSchedulers.mainThread()` once it is received. Implement all this,
    as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，立即，我们将创建一个只发出字符串`Goodbye World!`的`Observable`，并延迟3秒钟。因为`delay()`会将其放在计算调度器上，所以我们将使用`observeOn()`在接收到它后将那次发射放回`AndroidSchedulers.mainThread()`。按照以下代码所示实现所有这些：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run this application either on an emulated virtual device or an actual connected
    device. Sure enough, you will get an app that shows "`Hello World!`" for 3 seconds and
    then changes to "`Goodbye World!`". Here, I run this app on a virtual Pixel phone,
    as shown in the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的虚拟设备或实际连接的设备上运行此应用程序。确实，你将得到一个在3秒钟内显示"`Hello World!`"然后变为"`Goodbye World!`"的应用程序。在这里，我在一个虚拟Pixel手机上运行了这个应用程序，如图所示：
- en: '![](img/b79c18f5-bc1e-4ed6-b95b-a5497be77e98.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b79c18f5-bc1e-4ed6-b95b-a5497be77e98.png)'
- en: Figure 11.9 - An Android app that switches text from "Hello World!" to "Goodbye
    World!" after 3 seconds.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 一个在3秒后将文本从"Hello World!"切换到"Goodbye World!"的Android应用程序。
- en: If you do not use this `observeOn()` operation to switch back to the Android
    `mainThread()`, the app will likely crash. Therefore, it is important to make
    sure any emissions that modify the Android UI happen on the `mainThread()`. Thankfully,
    RxJava makes this easy to do compared to traditional concurrency tools.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不用这个`observeOn()`操作切换回Android的`mainThread()`，应用程序很可能会崩溃。因此，确保任何修改Android
    UI的发射都在`mainThread()`上执行是很重要的。幸运的是，与传统的并发工具相比，RxJava使这变得容易实现。
- en: Pretty much everything you learned earlier in this book can be applied to Android
    development, and you can mix RxJava and RxAndroid with your favorite Android utilities,
    libraries, and design patterns. However, if you want to create Observables off
    of Android widgets, you will need to use RxBinding and other libraries to augment
    your Rx capabilities on Android.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎你在本书中早期学到的所有内容都可以应用于Android开发，并且你可以将RxJava和RxAndroid与你的最爱Android实用工具、库和设计模式混合使用。然而，如果你想从Android小部件创建Observables，你将需要使用RxBinding和其他库来增强你在Android上的Rx能力。
- en: There is also an `AndroidSchedulers.from()` factory that accepts an event Looper
    and returns a Scheduler that will execute emissions on any Android Looper. This
    will operate the `Observable`/`Flowable` on a new thread and emit results through
    `onNext()` on the thread running a background operation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`AndroidSchedulers.from()`工厂，它接受一个事件循环器并返回一个调度器，该调度器将在任何Android循环器上执行发射。这将在这个运行后台操作线程的线程上操作`Observable`/`Flowable`并通过`onNext()`发射结果。
- en: Using RxBinding
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxBinding
- en: RxAndroid does not have any tools to create Observables off Android events,
    but there are many libraries that provide means to do this. The most popular library
    is RxBinding, which allows you to create Observables off of UI widgets and events.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: RxAndroid没有创建从Android事件Observables的工具，但有许多库提供了这样做的方法。最受欢迎的库是RxBinding，它允许你从UI小部件和事件创建Observables。
- en: 'There are many factories available in RxBinding. One static factory class you
    may use frequently is RxView, which allows you to create Observables off controls
    that extend View and broadcast different events as emissions. For instance, change
    your `activity_main.xml`to have a Button and TextView class, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We saved `Button` and `TextView` to `increment_button` and `my_text_view` IDs,
    respectively. Now let''s switch over to the `MainActivity.java` class and have
    the `Button` broadcast the number of times it was pressed to the `TextView`. Use
    the `RxView.clicks()` factory to emit each `Button` click as an Object and map it
    to a 1\. As we did in [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml),
    *Basic Operators*, we can use the `scan()` operator to emit a rolling count of
    emissions, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now run this app and press the button a few times. Each press will result in
    the number incrementing in the `TextView`, as shown in the following figure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e5ec5b-d05a-48fb-b3ad-8947a19f7f3c.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 - Reactively turning Button clicks into a scan() emitting the number
    of times it was pressed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Just in the RxView alone, there are dozens of factories to emit the states and
    events of a variety of properties on a View widget. Just to name a few, some of
    these other factories include `hover()`, `drag()`, and `visibility()`. There are
    also a large number of specialized factories for different widgets, such as `RxTextView`,
    `RxSearchView`, and `RxToolbar`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: There is so much functionality in RxBinding that it is difficult to cover all
    of it in this chapter. The most effective way to see what is available is to explore
    the RxBinding project source code on GitHub, which you can find at [https://github.com/JakeWharton/RxBinding/](https://github.com/JakeWharton/RxBinding/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Note that RxBinding has several "support" modules you can optionally bring in,
    including design bindings, RecyclerView bindings, and even Kotlin extensions.
    You can read more about these modules on GitHub README.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Other RxAndroid bindings libraries
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are fully embracing the reactive approach in making Android apps, there
    are many other specialized reactive bindings libraries you can leverage in your
    apps. They often deal with specific domains of Android but can be helpful nonetheless
    if you work with these domains. Outside of RxBinding, here are some notable bindings
    libraries you can use reactively with Android:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'SqlBrite ([https://github.com/square/sqlbrite](https://github.com/square/sqlbrite)):
    A SQLite wrapper that brings reactive semantics to SQL queries.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxLocation ([https://github.com/patloew/RxLocation](https://github.com/patloew/RxLocation)):
    A reactive location API'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'rx-preferences ([https://github.com/f2prateek/rx-preferences](https://github.com/f2prateek/rx-preferences)):
    A reactive SharedPreferences API'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxFit ([https://github.com/patloew/RxFit](https://github.com/patloew/RxFit)):
    Reactive fitness API for Android'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxWear ([https://github.com/patloew/RxWear](https://github.com/patloew/RxWear)):
    A reactive API for the Wearable library'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxWear ([https://github.com/patloew/RxWear](https://github.com/patloew/RxWear))：Wearable
    库的响应式 API
- en: 'ReactiveNetwork ([https://github.com/pwittchen/ReactiveNetwork](https://github.com/pwittchen/ReactiveNetwork)):
    Reactively listens for the network connectivity state'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactiveNetwork ([https://github.com/pwittchen/ReactiveNetwork](https://github.com/pwittchen/ReactiveNetwork))：响应式监听网络连接状态
- en: 'ReactiveBeacons ([https://github.com/pwittchen/ReactiveBeacons](https://github.com/pwittchen/ReactiveBeacons)):
    Reactively scans for **BLE** (**Bluetooth Low Energy**) beacons in proximity'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactiveBeacons ([https://github.com/pwittchen/ReactiveBeacons](https://github.com/pwittchen/ReactiveBeacons))：响应式扫描附近的
    **BLE**（**低功耗蓝牙**）信标
- en: As you can see, there is quite an RxJava ecosystem for Android, and you can
    view a fuller list on the RxAndroid wiki ([https://github.com/ReactiveX/RxAndroid/wiki](https://github.com/ReactiveX/RxAndroid/wiki)).
    Definitely leverage Google to see whether others exist for your specific task
    in mind. If you cannot find a library, there might be an OSS opportunity to start
    one!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Android 有一个相当完整的 RxJava 生态系统，你可以在 RxAndroid 维基页面上查看更完整的列表（[https://github.com/ReactiveX/RxAndroid/wiki](https://github.com/ReactiveX/RxAndroid/wiki)）。当然要利用
    Google 来查看是否有适合你特定任务的库。如果你找不到库，可能有一个开源的机会来创建一个！
- en: Life cycles and cautions using RxJava with Android
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJava 与 Android 的生命周期和注意事项
- en: As always, be deliberate and careful about how you manage the life cycle of
    your subscriptions. Make sure you do not rely on weak references in your Android
    app and assume reactive streams will dispose of themselves because they will not!
    So always call `dispose()` on your `disposables` when a piece of your Android
    application is no longer being used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 始终要谨慎地管理你的订阅生命周期。确保你的 Android 应用中不要依赖弱引用，并且不要假设响应式流会自动释放资源，因为它们不会！所以，当你的 Android
    应用的一部分不再被使用时，始终要调用 `dispose()` 方法来释放你的 `disposables`。
- en: 'For instance, say you create a simple app that displays the number of seconds
    since it was launched. For this exercise, set up your layout like this in order
    to have `timer_field` in the `TextView` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你创建了一个简单的应用，显示自启动以来的秒数。为了这个练习，设置你的布局如下，以便在 `TextView` 类中有 `timer_field`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can use an `Observable.interval()` to emit every second to a `TextField`.
    But we need to decide carefully how and if this counter persists when the app
    is no longer active. When `onPause()` is called, we might want to dispose of this
    timer operation. When `onResume()` is called, we can subscribe again and create
    a new disposable, effectively restarting the timer. For good measure, we should
    dispose of it when `onDestroy()` is called as well. Here is a simple implementation
    that manages these life cycle rules:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Observable.interval()` 来每秒向 `TextField` 发射一次。但我们需要仔细决定当应用不再活跃时，这个计数器如何以及是否持续。当
    `onPause()` 被调用时，我们可能想要释放这个计时器操作。当 `onResume()` 被调用时，我们可以再次订阅并创建一个新的可释放对象，从而重新启动计时器。为了保险起见，当
    `onDestroy()` 被调用时也应该释放它。以下是一个简单的实现，它管理了这些生命周期规则：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to persist or save the state of your app, you may have to get creative
    and find a way to dispose of your reactive operations when `onPause()` is called
    while allowing it to pick up where it left when `onResume()` happens. In the following
    code, I statefully hold the last value emitted from my timer an `inAtomicInteger`
    and use that as the starting value in the event that a pause/resume occurs with
    a new subscription:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要持久化或保存你应用的状态，你可能需要发挥创意，找到一种方法在 `onPause()` 被调用时释放你的响应式操作，同时允许它在 `onResume()`
    发生时从上次离开的地方继续。在下面的代码中，我持有一个来自计时器的最后一个值在 `inAtomicInteger` 中，并在发生暂停/恢复事件时使用它作为新的订阅的起始值：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So again, make sure you manage your reactive operations carefully and dispose of
    them deliberately with the life cycle of your app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次确保你仔细管理你的响应式操作，并随着你应用的生命周期有意识地释放它们。
- en: Also, make sure that you leverage multicasting for UI events when multiple Observers/Subscribers
    are listening. This prevents multiple listeners from being attached to widgets,
    which may not always be efficient. On the other hand, do not add the overhead
    of multicasting when there is only one `Observer`/`Subscriber` to a widget's events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保当有多个观察者/订阅者监听 UI 事件时，利用多播。这可以防止多个监听器附加到小部件上，这可能并不总是高效的。另一方面，当只有一个 `Observer`/`Subscriber`
    监听小部件的事件时，不要添加多播的开销。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched on various parts of the rich RxAndroid ecosystem
    to build reactive Android applications. We covered Retrolambda so we can leverage
    lambdas with earlier versions of Android that only support Java 6\. This way,
    we do not have to resort to anonymous inner classes to express our RxJava operators.
    We also touched on RxAndroid, which is the core of the reactive Android ecosystem,
    and it only contains Android Schedulers. To plug in your various Android widgets,
    controls, and domain-specific events, you will need to rely on other libraries,
    such as RxBinding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了丰富的 RxAndroid 生态系统中的各个部分，以构建响应式 Android 应用程序。我们介绍了 Retrolambda，这样我们就可以利用
    lambda 表达式来支持仅支持 Java 6 的早期 Android 版本。这样，我们就不必求助于匿名内部类来表达我们的 RxJava 操作符。我们还简要介绍了
    RxAndroid，它是响应式 Android 生态系统的核心，它只包含 Android 调度器。为了将各种 Android 小部件、控件和特定领域的事件连接起来，你将需要依赖其他库，例如
    RxBinding。
- en: In the next chapter, we will cover using RxJava with Kotlin. We will learn how
    to use this exciting new language, which has essentially become the Swift of Android,
    and why it works so well with RxJava.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何使用 Kotlin 与 RxJava 结合。我们将学习如何使用这一激动人心的新语言，它本质上已经成为了 Android 的 Swift，以及它为何与
    RxJava 配合得如此之好。
