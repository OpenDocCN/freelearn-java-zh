- en: RxJava on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is one domain that reactive programming has taken by storm, it is definitely
    mobile apps. As discussed throughout this book, ReactiveX is highly useful for
    many domains. But mobile apps are becoming increasingly complex, and users have
    a short tolerance for apps that are unresponsive, slow, or buggy. Therefore, mobile
    applications were quick to be early adopters of ReactiveX to solve these problems.
    RxSwift has quickly become popular on iOS after RxJava got a foothold on Android.
    There are also RxAndroid and RxBinding libraries to integrate RxJava easily with
    the Android environment, which we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One of the pain points that Android developers have coped with for some time
    is being stuck with Java 6\. This means that many of the widely used versions
    of Android (KitKat, Lollipop, and Marshmallow) do not support Java 8 lambdas (although
    this changed in Android Nougat, which finally uses OpenJDK 8). At first glance,
    this means you are stuck using boilerplate-riddled anonymous classes to express
    your RxJava operators (refer to Appendix A for examples). However, by using Retrolambda,
    you can, in fact, use earlier versions of Android while using lambdas, which we
    will go through in this chapter. Another option you have is using the Kotlin language,
    which has become an increasingly popular platform for Android development. Kotlin
    is an arguably more modern and expressive language than Java and can compile to
    Java 6 bytecode. We will cover Kotlin with RxJava in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no interest in Android development, feel free to skip this chapter.
    But the rest of you reading this book are most likely Android developers, so it
    is assumed that you have done some Android development already.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have little or no experience with Android and would like to learn, a
    great book to get started is *Android Programming: The Big Nerd Ranch Guide* by
    Bill Phillips, Chris Stewart, and Kristin Marsicano ([https://www.bignerdranch.com/books/android-programming/](https://www.bignerdranch.com/books/android-programming/)).
    It is an excellent book to become thoroughly proficient in Android development
    quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring RxJava for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxJava and RxAndroid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxBinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Android Rx libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Android project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use Android Studio for the examples in this chapter, with Android
    5.1 Lollipop as our platform target. Launch Android Studio and create a new project,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d596710-1de2-42c7-bf8f-72006de4d4a2.png)**Figure 11.1**: Creating
    a new Android project'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screen (shown in the following figure), name your project `RxJavaApp` with
    a Company domain of `packtpub.com` or whatever you prefer. Then, click on Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06bfe1a9-f210-4e34-bc1a-5e43f493a23f.png)**Figure 11.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to target Phone and Tablet. Since we may want our app to be compatible
    with devices running earlier versions of Android, let''s select Android 5.1 (Lollipop) as
    our Minimum SDK. This will also give us an opportunity to practice using Retrolambda.
    After this, click on Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35755247-1c34-4a53-ac17-52b0703e7460.png)**Figure 11.3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, choose Empty Activity as our your template, as shown in
    the following figure. Then, click on Next. As you probably know, an activity is
    one interactive screen containing controls. For the examples in this chapter,
    we will use one activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0273d2b-c1f9-40f6-9f8e-75aa208ad804.png)**Figure 11.4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to the final screen to configure the Activity. Feel free to
    leave Activity Name as `MainActivity` and its corresponding Layout Name as `activity_main`.
    We will populate this Activity later. Then, click on Finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c67d61f-d913-4a1f-92f5-65540c7a2740.png)**Figure 11.5**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now come to a screen shortly with your entire Android project, and
    it should already be configured with Gradle. Open `build.gradle (Module: app)`
    so we can configure our required dependencies next, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f06ad898-3a2d-47ee-8724-50963125ead3.png)**Figure 11.6**'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to make a few changes to the `build.gradle` script targeting the
    app module so we can use RxJava and Retrolambda.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Retrolambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's get Retrolambda set up. We will also leverage a quick unit test
    to see whether it works correctly. Open the `ExampleUnitTest.java` file that was
    created with the project template. Remove the sample unit test method inside it
    and declare a new one called `lambdaTest()`. Inside it, try to declare a `Callable<Integer>`
    with a lambda, as shown in the following figure. Note that it throws a compiler
    error because we are not using Java 8 to support lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d60d10f6-2e77-4130-ac3e-22a2c35bfbb9.png)**Figure 11.7** - Lambdas
    are not supported with this Android and Java version'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use Java 8 if we are targeting Android Lollipop, so we need Retrolambda
    to save us from creating boilerplate-riddled anonymous inner classes. It will
    compile our lambdas to anonymous classes at the bytecode level, so it supports
    Java 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get Retrolambda set up, we are going to use the gradle-retrolambda plugin
    to make the configuration process as seamless as possible. Go back to your `build.gradle
    (Module: app)` script and modify it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Click on the Sync Now prompt after you save the script to rebuild the project.
    The big change to note in the preceding code is that we added a buildscript `{
    }` block that brings in Retrolambda 3.6.1 as a dependency from `mavenCentral()`.
    We can then apply the retrolambda plugin. Finally, we add a `compileOptions {
    }` block inside the android `{ }` one and set the source and target to be compatible
    with Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run our unit test containing our lambda now. Score! As shown in the following
    figure, everything compiles and runs successfully, and we are now running lambdas
    on Java 6! Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f577b0-7768-4173-b27f-9b7c15c82d54.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 - We can now use lambdas with Java 6 on Android Lollipop with Retrolambda
    set up
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrolambda** is a brilliant tool for Android developers constrained to using
    Java 6\. It cleverly compiles lambdas as traditional anonymous classes, and you
    can save yourself some terrible boilerplate work when using RxJava.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Retrolambda and additional tweaks and configurations you
    can make, check out its GitHub page at [https://github.com/evant/gradle-retrolambda](https://github.com/evant/gradle-retrolambda).
    At the time of writing this, there are also upcoming lambda tools on Android Studio
    ([https://developer.android.com/studio/preview/features/java8-support.html](https://developer.android.com/studio/preview/features/java8-support.html)).
    These features may serve as an alternative to Retrolambda.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RxJava and friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the hard part is over and you have Retrolambda set up, all that is
    left for the configuration is bringing in RxJava and RxAndroid. Another set of
    libraries to add to your stack is Jake Wharton's RxBinding ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding)),
    which streamlines RxJava usage for Android UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these three libraries to your dependencies `{ }` block for your module
    (not the one inside the buildscript `{ }` block!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So these should now be your full `build.gradle (Module: app)` contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you click on the Sync Now prompt to rebuild the project with these
    dependencies in place. For the remainder of the chapter, we will touch on a few
    ways in which you can use RxJava, RxAndroid, and RxBinding together in your Android
    application. I could easily write a small book about different reactive features,
    bindings, and patterns you can use with Android, but in this chapter, we will
    take a minimalistic approach to focus on the core Rx features. We will touch on
    other libraries and resources you can research at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxJava and RxAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary feature of the RxAndroid library ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid))
    is that it has Android Schedulers to help your concurrency goals for your Android
    app. It has a Scheduler for the Android main thread as well as an implementation
    that can target any message Looper. Striving to be a core library, RxAndroid does
    not have many other features. You will need specialized reactive binding libraries
    for Android to do more than that, which we will explore later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start simple. We will modify `TextView` in the middle of our `MainActivity`
    (which already contains "`Hello World!`") to change to "`Goodbye World!`" after
    3 seconds. We will do all of this reactively using `Observable.delay()`. Because
    this will emit on a computational Scheduler, we will need to leverage `observeOn()`
    to safely switch the emission to the Android main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the `res/layout/activity_main.xml` file, modify the `TextView` block
    to have an ID property called `my_text_view` (as shown in the following code).
    This way, we can refer to it from our app code in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, rebuild your project and go to the `MainActivity.java` file. In the
    `onCreate()` method implementation, we are going to look up our "`my_text_view`"
    component and save it to a variable called `myTextView` (and cast it to `TextView`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, immediately, we are going to create an `Observable` emitting just the
    string `Goodbye World!` and delay it for 3 seconds. Because `delay()` will put
    it on a computational Scheduler, we will use `observeOn()` to put that emission
    back in `AndroidSchedulers.mainThread()` once it is received. Implement all this,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this application either on an emulated virtual device or an actual connected
    device. Sure enough, you will get an app that shows "`Hello World!`" for 3 seconds and
    then changes to "`Goodbye World!`". Here, I run this app on a virtual Pixel phone,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b79c18f5-bc1e-4ed6-b95b-a5497be77e98.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 - An Android app that switches text from "Hello World!" to "Goodbye
    World!" after 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not use this `observeOn()` operation to switch back to the Android
    `mainThread()`, the app will likely crash. Therefore, it is important to make
    sure any emissions that modify the Android UI happen on the `mainThread()`. Thankfully,
    RxJava makes this easy to do compared to traditional concurrency tools.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much everything you learned earlier in this book can be applied to Android
    development, and you can mix RxJava and RxAndroid with your favorite Android utilities,
    libraries, and design patterns. However, if you want to create Observables off
    of Android widgets, you will need to use RxBinding and other libraries to augment
    your Rx capabilities on Android.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an `AndroidSchedulers.from()` factory that accepts an event Looper
    and returns a Scheduler that will execute emissions on any Android Looper. This
    will operate the `Observable`/`Flowable` on a new thread and emit results through
    `onNext()` on the thread running a background operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxAndroid does not have any tools to create Observables off Android events,
    but there are many libraries that provide means to do this. The most popular library
    is RxBinding, which allows you to create Observables off of UI widgets and events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many factories available in RxBinding. One static factory class you
    may use frequently is RxView, which allows you to create Observables off controls
    that extend View and broadcast different events as emissions. For instance, change
    your `activity_main.xml`to have a Button and TextView class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We saved `Button` and `TextView` to `increment_button` and `my_text_view` IDs,
    respectively. Now let''s switch over to the `MainActivity.java` class and have
    the `Button` broadcast the number of times it was pressed to the `TextView`. Use
    the `RxView.clicks()` factory to emit each `Button` click as an Object and map it
    to a 1\. As we did in [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml),
    *Basic Operators*, we can use the `scan()` operator to emit a rolling count of
    emissions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run this app and press the button a few times. Each press will result in
    the number incrementing in the `TextView`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e5ec5b-d05a-48fb-b3ad-8947a19f7f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 - Reactively turning Button clicks into a scan() emitting the number
    of times it was pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Just in the RxView alone, there are dozens of factories to emit the states and
    events of a variety of properties on a View widget. Just to name a few, some of
    these other factories include `hover()`, `drag()`, and `visibility()`. There are
    also a large number of specialized factories for different widgets, such as `RxTextView`,
    `RxSearchView`, and `RxToolbar`.
  prefs: []
  type: TYPE_NORMAL
- en: There is so much functionality in RxBinding that it is difficult to cover all
    of it in this chapter. The most effective way to see what is available is to explore
    the RxBinding project source code on GitHub, which you can find at [https://github.com/JakeWharton/RxBinding/](https://github.com/JakeWharton/RxBinding/).
  prefs: []
  type: TYPE_NORMAL
- en: Note that RxBinding has several "support" modules you can optionally bring in,
    including design bindings, RecyclerView bindings, and even Kotlin extensions.
    You can read more about these modules on GitHub README.
  prefs: []
  type: TYPE_NORMAL
- en: Other RxAndroid bindings libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are fully embracing the reactive approach in making Android apps, there
    are many other specialized reactive bindings libraries you can leverage in your
    apps. They often deal with specific domains of Android but can be helpful nonetheless
    if you work with these domains. Outside of RxBinding, here are some notable bindings
    libraries you can use reactively with Android:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SqlBrite ([https://github.com/square/sqlbrite](https://github.com/square/sqlbrite)):
    A SQLite wrapper that brings reactive semantics to SQL queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxLocation ([https://github.com/patloew/RxLocation](https://github.com/patloew/RxLocation)):
    A reactive location API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'rx-preferences ([https://github.com/f2prateek/rx-preferences](https://github.com/f2prateek/rx-preferences)):
    A reactive SharedPreferences API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxFit ([https://github.com/patloew/RxFit](https://github.com/patloew/RxFit)):
    Reactive fitness API for Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RxWear ([https://github.com/patloew/RxWear](https://github.com/patloew/RxWear)):
    A reactive API for the Wearable library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ReactiveNetwork ([https://github.com/pwittchen/ReactiveNetwork](https://github.com/pwittchen/ReactiveNetwork)):
    Reactively listens for the network connectivity state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ReactiveBeacons ([https://github.com/pwittchen/ReactiveBeacons](https://github.com/pwittchen/ReactiveBeacons)):
    Reactively scans for **BLE** (**Bluetooth Low Energy**) beacons in proximity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is quite an RxJava ecosystem for Android, and you can
    view a fuller list on the RxAndroid wiki ([https://github.com/ReactiveX/RxAndroid/wiki](https://github.com/ReactiveX/RxAndroid/wiki)).
    Definitely leverage Google to see whether others exist for your specific task
    in mind. If you cannot find a library, there might be an OSS opportunity to start
    one!
  prefs: []
  type: TYPE_NORMAL
- en: Life cycles and cautions using RxJava with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, be deliberate and careful about how you manage the life cycle of
    your subscriptions. Make sure you do not rely on weak references in your Android
    app and assume reactive streams will dispose of themselves because they will not!
    So always call `dispose()` on your `disposables` when a piece of your Android
    application is no longer being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say you create a simple app that displays the number of seconds
    since it was launched. For this exercise, set up your layout like this in order
    to have `timer_field` in the `TextView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use an `Observable.interval()` to emit every second to a `TextField`.
    But we need to decide carefully how and if this counter persists when the app
    is no longer active. When `onPause()` is called, we might want to dispose of this
    timer operation. When `onResume()` is called, we can subscribe again and create
    a new disposable, effectively restarting the timer. For good measure, we should
    dispose of it when `onDestroy()` is called as well. Here is a simple implementation
    that manages these life cycle rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to persist or save the state of your app, you may have to get creative
    and find a way to dispose of your reactive operations when `onPause()` is called
    while allowing it to pick up where it left when `onResume()` happens. In the following
    code, I statefully hold the last value emitted from my timer an `inAtomicInteger`
    and use that as the starting value in the event that a pause/resume occurs with
    a new subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So again, make sure you manage your reactive operations carefully and dispose of
    them deliberately with the life cycle of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure that you leverage multicasting for UI events when multiple Observers/Subscribers
    are listening. This prevents multiple listeners from being attached to widgets,
    which may not always be efficient. On the other hand, do not add the overhead
    of multicasting when there is only one `Observer`/`Subscriber` to a widget's events.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on various parts of the rich RxAndroid ecosystem
    to build reactive Android applications. We covered Retrolambda so we can leverage
    lambdas with earlier versions of Android that only support Java 6\. This way,
    we do not have to resort to anonymous inner classes to express our RxJava operators.
    We also touched on RxAndroid, which is the core of the reactive Android ecosystem,
    and it only contains Android Schedulers. To plug in your various Android widgets,
    controls, and domain-specific events, you will need to rely on other libraries,
    such as RxBinding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover using RxJava with Kotlin. We will learn how
    to use this exciting new language, which has essentially become the Swift of Android,
    and why it works so well with RxJava.
  prefs: []
  type: TYPE_NORMAL
