<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data and Stream Processing</h1>
                </header>
            
            <article>
                
<p><span>In the previous chapter, we generated streams of data by using a Reactor Flux and then consumed it in a subscriber. Reactor also provides a diverse set of operators that can be used to manipulate data. These operators take a stream as input and then generate another stream of another type of data. In a nutshell, these operators provide a powerful way to compose readable data pipelines. There are various operators for filtering, mapping, and collecting data. All of them will be covered in this chapter.</span></p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Filtering data</li>
<li>Converting data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li class="western">Java Standard Edition, JDK 8 or above</li>
<li>IntelliJ IDEA IDE, 2018.1 or above</li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating data</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we jump into working with various operators, let's first generate a stream of data. In order to do this, let's revisit our Fibonacci series from <a href="56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml" target="_blank">Chapter 1</a>, <em><span>Getting Started with Reactive Streams</span></em>.</p>
<p>In number theory, Fibonacci numbers are characterized by the fact that every number after the first two numbers is the sum of the two preceding ones (that is, 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ,21 , 34 , 55 , 89 , 144, and so on).</p>
<p class="mce-root"/>
<p>The Flux generated API enables us to build a generator. These generators start the series from 0 and 1. All numbers are printed to the console by a subscriber, which listens to all of the generated events. This is shown in the following code:</p>
<pre>Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long, Long&gt;of(0L, 1L),(state, sink) -&gt; {<br/>  if (state.getT1() &lt; 0)<br/>     sink.complete();<br/>  else  <br/>     sink.next(state.getT1());<br/>  return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>});<br/>fibonacciGenerator.subscribe(t -&gt; {<br/>  System.out.println(t);<br/>});</pre>
<p>Let's recap what is happening here, as follows:</p>
<ul>
<li>We create the Fibonacci series as <kbd>Flux&lt;Long&gt;</kbd> by using the <kbd>Flux.generate()</kbd> call. The API has a state and sink.</li>
<li>The API takes a seed as <kbd>Tuple [0 , 1]</kbd>. It then emits the first argument of the pair by using the <kbd>Sink.next()</kbd> call.</li>
<li>The API also generates the next Fibonacci number, by aggregating the pair.</li>
<li>The publisher marks the stream as complete when we generate negative numbers. This is due to their being out of range of the long data type.</li>
<li>We subscribe to the published numbers, then print the received number to the console. This is shown in the following screenshot:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/7b04e524-ec34-4575-9f90-592b33ebcfb0.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering data</h1>
                </header>
            
            <article>
                
<p>Let's start with the most simple operator for selecting data. There are different analogies of data filtration, as follows:</p>
<ul>
<li>Select or reject data based on a given condition</li>
<li>Select or reject a subset of the generated data</li>
</ul>
<p>The preceding information is depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6fac3048-5c21-41fd-b2cc-17f964c00fbe.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The filter() operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>filter()</kbd> operator enables selection of the data on the passed condition. The API takes a Boolean predicate, which is evaluated for every emitted value, in order to determine whether it is selected. Filtering is quite common. Let's suppose that we want to select dates based on a month range, or we want to select employee data based on employee IDs. In those cases, the Boolean predicate passed to the filter holds the selection logic. This can be quite flexible, and can be adapted to different needs.</p>
<p>Let's extend our Fibonacci generator to only select even numbers, as follows:</p>
<pre class="western"><span><span><span>fibonacciGenerator.filter(a -&gt; a%<span>2 </span>== <span>0</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>In the preceding code, the predicate performs a divisibility check. If the number is divisible by <kbd>2</kbd>, the operator performs a<span> predicate evaluation in a synchronous manner. If the condition is satisfied, the value is </span>passed to the subscriber.</p>
<p>There is also a <kbd>FilterWhen</kbd>, which is an asynchronous manner of Boolean <span>evaluation</span>. This takes the input value and provides the Boolean publisher in return. This can be explained with the following code:</p>
<pre class="western"><span><span><span>fibonacciGenerator.filterWhen(a -&gt; Mono.just(a &lt; <span>10</span>)).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});<br/></span></span></span></pre>
<p>In the preceding code, the predicate performs a less-than check. This is a deferred evaluation, and the result is returned as a <kbd>Mono&lt;Boolean&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The take operator</h1>
                </header>
            
            <article>
                
<p>The filter methods discussed previously enable us to select data. If we want to select the top 10 elements, for example, we can use the <kbd>filter</kbd> operator, with a predicate that has a counter. Alternatively, there is a <kbd>take</kbd> operator for this purpose. The operator takes a number and selects the specified number of elements, as follows:</p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>The preceding code will select the first <kbd>10</kbd> values to form the Fibonacci generator.</p>
<p>Now, let's suppose that we want to select the last 10 elements. The <kbd>takeLast</kbd> operator is designed for this purpose. It also maintains a count and selects elements from the end of the series:</p>
<pre class="western"><span><span><span>fibonacciGenerator.takeLast(<span>10</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<div class="packt_tip">If the stream is truly unbounded, there will not be any last elements. The operator only works when there is a normal close of the stream.</div>
<p class="mce-root"/>
<p class="mce-root">If we only want to <span>select the last value, we can use the <kbd>takeLast(1)</kbd> operator. This operator will give back a Flux stream containing</span><span> just one value. Alternatively, there is a <kbd>last()</kbd> operator, which gives back a Mono publisher that consists of the last published element. The use of the <kbd>last</kbd> operator is shown as follows:</span></p>
<pre class="mce-root">fibonacciGenerator.last().subscribe(t -&gt; {<br/><span><span>    System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);<br/></span></span>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The skip operator</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we have found ways to select data, let's look at ways to reject data. The Reactor API offers diverse methods to reject data. There is a skip operator, with the following types:</p>
<ul>
<li><kbd>Skip(count)</kbd>: This will reject the specified number of elements from the beginning of the stream.</li>
<li><kbd>Skip(Duration)</kbd>: This will reject elements for the said duration from the beginning of the stream.</li>
<li><kbd>SkipLast(count)</kbd>: This will reject a specified number of elements from the end of the stream.</li>
<li><kbd>SkipUntil(Boolean Predicate)</kbd>: This will reject elements until the first occurrence of the said condition is true.</li>
</ul>
<p>The preceding commands are shown in the following code:</p>
<pre class="western"><span><span><span>fibonacciGenerator.skip(<span>10</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span>
<span><span><span>fibonacciGenerator.skip(Duration.ofMillis(<span>10</span>)).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span>
<span><span><span>fibonacciGenerator.skipUntil(t -&gt; t &gt; <span>100</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});<br/></span></span></span></pre>
<p><span>The preceding code sample has the following variants:</span></p>
<ul>
<li>The first subscriber rejects the first <kbd>10</kbd> elements and prints the rest of them</li>
<li>The second subscriber <span>prints the elements after rejecting the </span>elements for <kbd>10</kbd> milliseconds</li>
<li><span>The second subscriber </span><span>prints the elements after the first data element goes beyond <kbd>100</kbd></span></li>
</ul>
<p>The output is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64301bd5-b071-48a0-87d1-9ff5e043f4be.png" style=""/></div>
<p class="mce-root">Until now, we have discussed generic ways to select and reject data. However, the Flux interface offers the following special operators for filtering data in specific scenarios:</p>
<ul>
<li><kbd>distinct</kbd>: This operator is used to select unique elements of the passed data stream</li>
<li><kbd>distintUntilChanged</kbd>: <span>This operator is used to select the</span> first set of distinct items</li>
<li><kbd>ignoreElements</kbd>: This operator is used to completely ignore the data elements</li>
<li><kbd>single</kbd>: This operator is used to select only a single data element</li>
<li><kbd>elementAt</kbd>: This operator selects the element at the specified index of the stream</li>
</ul>
<p class="mce-root">In the preceding section, we discussed ways to select or reject data. Reactor offers many operators for this purpose. It is often a good idea to check the API and determine whether there is an operator for the intended purpose rather than customize the predicate with the filter and skip methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data</h1>
                </header>
            
            <article>
                
<p>It is often necessary to convert data from one format to another. The reactor provides a vast set of operators to achieve this. Not only can we convert data but we can modify the amount of data elements as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The map() operator</h1>
                </header>
            
            <article>
                
<p class="mce-root">From the preceding Fibonacci example that was used to explain the <kbd>skip()</kbd> operator, suppose that we want to convert the first 10 elements into Roman numeral equivalents.</p>
<p>Roman numerals are represented by seven letters: I, V, X, L, C, D, and M. These letters represent 1, 5, 10, 50, 100, 500, and 1,000, respectively. The seven letters can be combined to represent thousands of numbers. The Roman numeral scheme used letters as tally markers. Markers were combined to represent unit values.</p>
<p class="mce-root">We have a long number and we want to convert it to its Roman equivalent; this is where the <kbd>map()</kbd> operator is valuable. It applies a transformation to each and every value of the existing stream, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/780c0950-35bd-4673-8a36-36c4d7f00c52.png" style=""/></div>
<p>In order to achieve this transformation, we need a <kbd>RomanNumberConvertor</kbd>. In the following code, we have defined a conversion from integers to their Roman equivalents:</p>
<pre class="western"><span><span><span><span>class </span>RomanNumber {</span></span></span>
<span>    <span><span>TreeMap&lt;Integer, String&gt; </span></span><span><span><span>romanMap</span></span></span><span><span>= </span></span><span><span><span>new </span></span></span><span><span>TreeMap&lt;&gt;();</span></span></span>
<span>    <span><span>RomanNumber(){</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>1000</span></span></span><span><span>, </span></span><span><span><span>"M"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>900</span></span></span><span><span>, </span></span><span><span><span>"CM"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>500</span></span></span><span><span>, </span></span><span><span><span>"D"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>400</span></span></span><span><span>, </span></span><span><span><span>"CD"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>100</span></span></span><span><span>, </span></span><span><span><span>"C"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>90</span></span></span><span><span>, </span></span><span><span><span>"XC"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>50</span></span></span><span><span>, </span></span><span><span><span>"L"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>40</span></span></span><span><span>, </span></span><span><span><span>"XL"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>10</span></span></span><span><span>, </span></span><span><span><span>"X"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>9</span></span></span><span><span>, </span></span><span><span><span>"IX"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>5</span></span></span><span><span>, </span></span><span><span><span>"V"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>4</span></span></span><span><span>, </span></span><span><span><span>"IV"</span></span></span><span><span>);</span></span></span>
<span>        romanM<span><span><span>ap</span></span></span><span><span>.put(</span></span><span><span><span>1</span></span></span><span><span>, </span></span><span><span><span>"I"</span></span></span><span><span>);</span></span></span>
<span>    <span><span>}</span></span></span>
<span>    <span><span>String toRomanNumeral(</span></span><span><span><span>int </span></span></span><span><span>number) {</span></span></span>
<span>        <span><span><span>int </span></span></span><span><span>l =  </span></span><span><span><span>romanMap</span></span></span><span><span>.floorKey(number);</span></span></span>
<span>        <span><span><span>if </span></span></span><span><span>( number == l ) {</span></span></span>
<span>            <span><span><span>return romanM</span></span></span><span><span><span>ap</span></span></span><span><span>.get(number);</span></span></span>
<span>        <span><span>}</span></span></span>
<span>        <span><span><span>return romanM</span></span></span><span><span><span>ap</span></span></span><span><span>.get(l) + toRomanNumeral(number-l);</span></span></span>
<span>    <span><span>}</span></span></span>
<span><span><span>}</span></span></span></pre>
<p>Since we know how to convert an integer, we will define the <kbd>Map</kbd> function for our stream processor. The operator will take the long <kbd>Value</kbd> as an input and will then generate the Roman equivalent as a string:</p>
<pre class="western"><span><span><span>RomanNumber numberConvertor= <span>new </span>RomanNumber();</span></span></span>
<span><span><span>fibonacciGenerator.skip(<span>1</span>).take(<span>10</span>).map(t-&gt; <span>numberConvertor</span>.toRomanNumeral(t.intValue())).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>A couple of things are done in the preceding code, as follows:</p>
<ul>
<li>The <kbd>skip(1)</kbd> operator has been used. In the last section, we mentioned that this will skip the first element of the series. This happens because 0 has no Roman equivalent.</li>
<li>The <kbd>take(10)</kbd> operator has been used. This will select only 10 elements from the generated series. This is done to limit the number to less than 1,000.</li>
<li>The <kbd>map()</kbd> operator defines the conversion of <kbd>longValue</kbd> to the Roman-equivalent string.</li>
<li>All of the preceding operators have been chained together to generate one single stream. The output is shown in the following screenshot:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/4f6e72e7-d511-49bf-b8da-62cd79a3724e.png"/></div>
<p>As you can see in the preceding output, the value transformation from number to Roman numeral is applied to each item flowing through the stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The flatMap operator</h1>
                </header>
            
            <article>
                
<p>The preceding transformation example that used the <kbd>map()</kbd> operator was effective when we had a one-to-one value conversion, but it could not handle a one-to-<em>n</em> value conversion. We can show this premise by generating a stream of factors for our Fibonacci numbers. Let's first revise what factorization is.</p>
<p>In number theory, factorization is the breakup of a composite number into a product of smaller numbers. For 6, for example, the factors are 1, 2, 3, and 6.</p>
<p>Let's try to convert Fibonacci numbers to their corresponding factors. <span>Each number of the series must be converted to all possible factors. </span>First, let's build a simple function to compute factors:</p>
<pre class="western"><span><span><span><span>class </span>Factorization {</span></span></span>
<span>    <span><span>Collection&lt;Integer&gt; findfactor(</span></span><span><span><span>int </span></span></span><span><span>number) {</span></span></span>
<span>        <span><span>ArrayList&lt;Integer&gt; factors= </span></span><span><span><span>new </span></span></span><span><span>ArrayList&lt;&gt;();</span></span></span>
<span>        <span><span><span>for </span></span></span><span><span>(</span></span><span><span><span>int </span></span></span><span><span>i = </span></span><span><span><span>1</span></span></span><span><span>; i &lt;= number; i++) {</span></span></span>
<span>            <span><span><span>if </span></span></span><span><span>(number % i == </span></span><span><span><span>0</span></span></span><span><span>) {</span></span></span>
<span>                <span><span>factors.add(i);</span></span></span>
<span>            <span><span>}</span></span></span>
<span>        <span><span>}</span></span></span>
<span>        <span><span><span>return </span></span></span><span><span>factors;</span></span></span>
<span>    <span><span>}</span></span></span>
<span><span><span>}</span></span></span></pre>
<p>In the preceding code, we used the brute force method, which divides the specified number by all numbers less than or equal to the number. If the number is divisible, then the divisor is added to the list of factors. We can use this with a <kbd>map</kbd> operator, which is shown in the following code:</p>
<pre class="western"><span><span><span>fibonacciGenerator.skip(<span>1</span>).take(<span>10</span>).map(t-&gt; <span>numberConvertor</span>.findfactor(t.intValue())).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>The resulting output includes individual collections that contain factors of the Fibonacci number:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cde056ed-d1e7-4e13-96cb-26085c01d133.png"/></div>
<p>In order to make the generated factors a stream of integral factors, we must use the <kbd>flatMap</kbd> operator. This is shown in the following code:</p>
<pre class="western"><span><span><span>Factorization numberConvertor= <span>new </span>Factorization();</span></span></span>
<span><span><span>fibonacciGenerator.skip(<span>1</span>).take(<span>10</span>).flatMap(t-&gt; Flux.fromIterable(<span>numberConvertor</span>.findfactor(t.intValue()))).subscribe(t -&gt; {</span></span></span>
<span>   <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>In the preceding code, the following things are handled:</p>
<ul>
<li><kbd>flatMap</kbd> takes an integer and passes it to the factor generator. It expects a publisher of the other data type.</li>
<li>Factors are generated as a collection of integers.</li>
<li>These integers are converted into a Flux using the <kbd>fromIterable</kbd> methods to match the expectations of the <kbd>FlatMap</kbd> method.</li>
</ul>
<p>The preceding code generates the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d05bd4f4-d944-4686-ba87-db0e1e1b8a1b.png"/></div>
<div class="packt_tip">When using <kbd>flatMap</kbd>, it is essential to know what kind of Flux we are generating back. A simple change from <kbd>Flux.fromIterable</kbd> to <kbd>Flux.just</kbd> alters the complete behavior of the preceding code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The repeat operator</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reactor provides an operator to replay a stream of data. The <kbd>repeat</kbd> operator is designed for this purpose. It replays the steam upon receiving the completion event. Let's suppose that we want to output the Fibonacci series twice. We will use the <kbd>repeat()</kbd> operator, with <kbd>2</kbd> as the argument to the <kbd>repeat()</kbd> operator:</p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>).repeat(<span>2</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span> </pre>
<p class="western"><span>The preceding code generated the stream twice, as shown in the following output. It is important to note that the <kbd>repeat()</kbd> operator repeats a stream after receiving the completion event:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f497e3c7-8d02-493e-bb9f-635828ea9e13.png"/></div>
<p class="mce-root">Reactor also makes it possible to perform infinite repeats. The <kbd>repeat()</kbd> operator, invoked without any argument, replays the stream an infinite number of times:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/446a4439-972f-4885-80fa-c78956aa7099.png" style=""/></div>
<p>There is also a predicate variant in which a Boolean provider is passed to the repeat operator. Upon completion, the provider is evaluated every time in order to discover whether the stream needs to be repeated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The collect operator</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reactor also provides operators that make it possible to accumulate data streams as collections. The most basic of these is the <kbd>collectList()</kbd> operator. The operator accumulates the data as a list, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb2dce83-521a-4ec0-8b5a-9690ecc734dc.png" style=""/></div>
<p>Let's take our Fibonacci example and collect the data into a list. The collector method provides a Mono publisher that will emit a single list containing all of the published data:</p>
<div>
<pre class="western"><span><span><span><span>public void </span>testFibonacciCollect() {</span></span></span>
<span>    <span><span>Flux&lt;Long&gt; fibonacciGenerator = Flux.</span></span><span><span>generate</span></span><span><span>(</span></span></span>
<span>            <span><span>() -&gt; Tuples.&lt;Long, Long&gt;</span></span><span><span>of</span></span><span><span>(</span></span><span><span><span>0L</span></span></span><span><span>, </span></span><span><span><span>1L</span></span></span><span><span>),</span></span></span>
<span>            <span><span>(state, sink) -&gt; {</span></span></span>
<span>                <span><span>sink.next(state.getT1());</span></span></span>
<span>                <span><span><span>return </span></span></span><span><span>Tuples.</span></span><span><span>of</span></span><span><span>(state.getT2(), state.getT1() + state.getT2());</span></span></span>
<span>            <span><span>});</span></span></span>
<span>      <span><span>fibonacciGenerator.take(</span></span><span><span><span>10</span></span></span><span><span>).collectList().subscribe(t -&gt; {</span></span></span>
<span>         <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span>      <span><span>});<br/></span></span></span><span><span><span>}</span></span></span></pre></div>
<p class="mce-root">The preceding code performs the following actions:</p>
<ul>
<li>The <kbd>take</kbd> operator selects the first 10 elements of the stream</li>
<li>It then accumulates them into a list, giving back a Mono publisher</li>
<li>The list is provided to the subscriber, which prints it to the console</li>
</ul>
<p class="mce-root">The behavior is confirmed in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8bf35886-454e-47ef-90f9-c0921fc23a04.png"/></div>
<p>The <kbd>collectList()</kbd> operator aggregates the data in a list, but there is also a <kbd>CollectSortList</kbd> operator, which can collect data in a sorted list based on the natural order of the data. We can also provide a comparator to the <kbd>CollectSortedList</kbd> method to alter the order of the data, as shown in the following code:</p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>).</span></span></span>
<span><span><span>collectSortedList((x,y)-&gt; -<span>1</span>*Long.compare(x,y))</span></span></span>
<span><span><span>.subscribe(t -&gt; {</span></span></span>
<span>   <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p class="mce-root"/>
<p>The preceding code performs the following actions:</p>
<ul>
<li>The <kbd>take</kbd> operator selects the first 10 elements of the stream</li>
<li>It then accumulates them into a <kbd>SortedList</kbd> by using the passed <span>comparator </span>function, giving back a Mono publisher</li>
<li>The comparator function compares two long data types and reverses the evaluation</li>
<li>The list is provided to the subscriber, which prints it to the console</li>
</ul>
<p>Here, the subscriber receives a list in the reverse order of the data:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3b0451f7-6cb7-423e-b425-9be7d015773f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The collectMap operator</h1>
                </header>
            
            <article>
                
<p><span>Just like <kbd>collectlist()</kbd>, Reactor also provides <kbd>collectMap()</kbd> to accumulate data into a <kbd>java.util.Map</kbd>; <kbd>collectMap</kbd> takes a key generator function to create keys for the generated value elements. This is shown in the following code:</span></p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>)</span></span></span>
<span><span><span>.collectMap(t -&gt; t%<span>2</span>==<span>0 </span>? <span>"even"</span>: <span>"odd"</span>)</span></span></span>
<span><span><span>.subscribe(t -&gt; {</span></span></span>
<span>   <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p><span>The preceding code generates a <kbd>Map</kbd> with two keys that are represented as <kbd>even</kbd> and <kbd>odd</kbd>. It will keep the last even/odd number in the map. This is shown as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2bab627b-6bdd-40a6-bf5d-4ee43acde4b4.png"/></div>
<p>The <kbd>collectMap</kbd> command not only takes a <kbd>keyGeneator</kbd>, but also provides the option to pass a value <span>generator. The value generator alters the original value of the data stream.</span></p>
<p>There is also a <kbd>CollectMultiMap()</kbd> method, which collects data into a map of keys and lists them as values. Instead of overwriting the original value, it aggregates the values against the same key into a list. If executed with the <kbd>collectMultiMap</kbd> operator, the preceding code produces the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/04b9be62-26e1-4219-ba4d-2df87afd7cef.png" style=""/></div>
<p>In addition to the accumulators discussed previously, there is a generic <kbd>Collect</kbd> operator, which makes it possible to accumulate data into any format. This operator converts the Flux publisher <span>back</span><span> </span><span>to a Mono publisher, emitting a single accumulated value.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The reduce operator</h1>
                </header>
            
            <article>
                
<p><span>The preceding section covered value accumulation, whereas the reduce operation revolves around value consolidation. The reduce method makes it possible to aggregate the complete data stream into a single value. This is depicted as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b416e1ae-aa53-428c-beb9-8f70ea3b7805.png" style=""/></div>
<p><span>Suppose that we want to generate a sum of Fibonacci numbers, as follows:</span></p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>).reduce((x,y) -&gt; x+y).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>In the preceding code, we did the following things:</p>
<ul>
<li>The <kbd>take</kbd> operator selected the first 10 elements for the stream.</li>
<li>The <kbd>reduce</kbd> operator took a Bifunction of the long type. The lambda expression returns the sum of the long values to generate the back sum.</li>
<li>The <kbd>subscribe</kbd> operation received a <kbd>Mono&lt;Long&gt;</kbd>, which was printed on the console. This is depicted as follows:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/2a77eff6-a2a9-47c3-bc9b-aba8f8d6a5da.png"/></div>
<p>There is also an overloaded <kbd>reduce</kbd> method, which can take an initial value as the starting point of the aggregation.</p>
<div class="packt_tip">There is a special <kbd>count</kbd> operator that is responsible for returning the size of the stream.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional tests</h1>
                </header>
            
            <article>
                
<p>Until now, we been discussed operators that work on original data. The Reactor framework provides Boolean operators that enable the testing of each of the data elements in the stream. There are two types of operators, as follows:</p>
<ul>
<li><kbd>all</kbd>: This operator takes a predicate and confirms whether all of the elements meet the specified criteria. This is the logical <kbd>AND</kbd> operator for all data elements.</li>
<li><kbd>any</kbd>: This operator takes a predicate and confirms whether any single element meets the specified criteria. This is a logical <kbd>OR</kbd> for all data elements.</li>
</ul>
<p>The results of the preceding methods are consolidated into a single Boolean result, as follows:</p>
<pre class="western"><span><span><span>fibonacciGenerator.take(<span>10</span>).all(x -&gt; x &gt; <span>0</span>).subscribe(t -&gt; {</span></span></span>
<span>    <span><span>System.</span></span><span><span><span>out</span></span></span><span><span>.println(t);</span></span></span>
<span><span><span>});</span></span></span></pre>
<p>In the preceding code, we did the following things:</p>
<ul>
<li>The <kbd>take</kbd> operator selected the first <kbd>10</kbd> elements for the stream.</li>
<li>The <kbd>all</kbd> operator took a Boolean predicate to confirm that all of the elements are greater than <kbd>0</kbd>.</li>
<li>The <kbd>subscribe</kbd> operation received a <kbd>Mono&lt;Boolean&gt;</kbd>, which was printed on the console.</li>
</ul>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/35894b33-c4f3-4993-8d02-e1eb146101e0.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Appending data</h1>
                </header>
            
            <article>
                
<p>Until now, we have worked on data generated from a single Flux stream. Stream processing is not limited to one publisher. Reactor provides operators that make it possible to merge different publishers into one single stream of data. Values can be added either<span> before the specified published values or after the published values. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The concatWith operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>concatWith</kbd> operator makes it possible to append a value event after the published values. It takes a publisher as input and appends the published values after the <span>first publisher has completed, as shown in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bb94a19a-ab39-4d9d-bce4-09bd97b7f150.png" style=""/></div>
<p>Let's suppose that we want to append some negative values at the end of our Fibonacci stream:</p>
<div>
<pre>fibonacciGenerator.take(<span>10</span>)<br/> .concatWith(Flux.<span>just</span>( <span>new </span>Long[]{-<span>1L</span>,-<span>2L</span>,-<span>3L</span>,-<span>4L</span>}))<br/> .subscribe(t -&gt; {<br/>    System.<span>out</span>.println(t);<br/>});<br/><br/></pre></div>
<p>In the preceding code, we did the following things:</p>
<ul>
<li>The <kbd>take</kbd> operator selected the first <kbd>10</kbd> elements for the stream.</li>
<li>The <kbd>concatWith</kbd> operator took a publisher. It appended its values after the completion of the original stream, that is, after <kbd>10</kbd> elements.</li>
<li>The <kbd>subscribe</kbd> operation received a <kbd>Flux&lt;Long&gt;</kbd>, which was printed on the console.</li>
</ul>
<div class="packt_tip">Similar to <kbd>concatWith</kbd>, there is a <kbd>startWith</kbd> operator, which can be used to add values before the original stream values.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the wide range of operators available in Reactor. We started by looking at simple operators for selecting and rejecting data. We then looked at operators for converting data to other types. The converted data element does not need to be one-to-one mapped. There can be more than one element for each processed value. Next, we looked at operators that accumulate data. By the end of the chapter, we had covered aggregation and conditional tests for data. In a nutshell, we have covered the complete range of operators available in Reactor. In the next chapter we will look at the processors, which provide the necessary glue to bind Reactor components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What operator is used to select data elements from a stream?</li>
<li>What operator is used to reject data elements from a stream?</li>
<li>What operators does Reactor offer for data conversion? How are these operators different  from each other?</li>
<li>How can we perform data aggregation by using Reactor operators?</li>
<li>What conditional operators are offered by Reactor? </li>
</ol>


            </article>

            
        </section>
    </body></html>