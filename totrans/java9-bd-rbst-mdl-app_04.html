<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java 9 Language Enhancements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we gained insight into some exciting new features contained in Java 9. Our focus was on javac, the JDK libraries, and test suites. We learned about memory management improvements including memory allocation, heap optimizations, and enhanced garbage collection. We also covered changes to the compilation process, type testing, annotations, and runtime compiler tests.</p>
<p class="mce-root">This chapter covers some changes in Java 9 that impact variable handlers, depreciation warnings, improvements on Project Coin changes implemented in Java 7, and import statement processing. These represent changes to the Java language itself.</p>
<p class="mce-root">The topics we will cover here are:</p>
<ul class="calibre13">
<li class="calibre14">Variable handlers</li>
<li class="calibre14">Import statement depreciation warnings</li>
<li class="calibre14">Project Coin</li>
<li class="calibre14">Import statement processing</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Working with variable handlers [JEP 193]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Variable handlers are typed references to variables and are governed by the <kbd class="calibre16">java.lang.invoke.VarHandle</kbd> abstract class. <span class="calibre7">The</span> <kbd class="calibre16">VarHandle</kbd> <span class="calibre7">method's signature is polymorphic. This provides for great variability in both method signatures and return types. Here is a code sample demonstrating how a <kbd class="calibre16">VarHandle</kbd> might be used:</span></p>
<pre class="calibre21">    . . . <br class="calibre2"/><br class="calibre2"/>    class Example <br class="calibre2"/>    {<br class="calibre2"/>      int myInt;<br class="calibre2"/>      . . . <br class="calibre2"/>    }<br class="calibre2"/>    . . . <br class="calibre2"/>    class Sample <br class="calibre2"/>    {<br class="calibre2"/>      static final VarHandle VH_MYINT;<br class="calibre2"/><br class="calibre2"/>      static <br class="calibre2"/>      {<br class="calibre2"/>        try <br class="calibre2"/>        {<br class="calibre2"/>          VH_MYINT =  <br class="calibre2"/>            MethodHandles.lookup().in(Example.class)<br class="calibre2"/>            .findVarHandle(Example.class, "myInt", int.class);<br class="calibre2"/>        } <br class="calibre2"/>        catch (Exception e) <br class="calibre2"/>        {<br class="calibre2"/>          throw new Error(e);<br class="calibre2"/>        }<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    . . . </pre>
<p class="mce-root">As you can see in the preceding code snippet, the <kbd class="calibre16">VarHandle.lookup()</kbd> <span class="calibre7">performs the same operation as those</span> that are performed by a <kbd class="calibre16">MethodHandle.lookup()</kbd> method.</p>
<p class="mce-root">The aim of this JEP was to standardize the way in which methods of the following classes are invoked:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">java.util.concurrent.atomic</kbd></li>
<li class="calibre14"><kbd class="calibre16">sun.misc.Unsafe</kbd>&lt;/li&gt;</li>
</ul>
<p class="mce-root">Specifically, methods that:</p>
<ul class="calibre13">
<li class="calibre14">accessed/mutated object fields</li>
<li class="calibre14">accessed/mutated elements of an array</li>
</ul>
<p class="mce-root">In addition, this JEP resulted in two fence operations for memory ordering and object reachability. In the spirit of due diligence, special attention was given to ensure the JVM's safety. It was important to ensure that memory errors did not result from these changes. Data integrity, usability, and, of course, performance were key components of the aforementioned due diligence and are explained as follows:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Safety</strong>: Corrupt memory states must not be possible.</li>
<li class="calibre14"><strong class="calibre3">Data integrity</strong>: Ensure access to an object's field uses identical rules used by:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">getfield</kbd> byte code</li>
<li class="calibre14"><kbd class="calibre16">putfield</kbd> byte code</li>
</ul>
</li>
<li class="calibre14"><strong class="calibre3">Usability</strong>: The benchmark for usability was the <kbd class="calibre16">sun.misc.Unsafe</kbd> API. The goal was to make the new API easier to use than the benchmark.</li>
<li class="calibre14"><strong class="calibre3">Performance</strong>: There could be no degradation of performance compared to the use of the <kbd class="calibre16">sun.misc.Unsafe</kbd> API. The goal was to outperform that API.</li>
</ul>
<div class="packt_infobox">In Java, a fence operation is what javac does to force a constraint on memory in the form of a barrier instruction. These operations occur before and after the barrier instruction, essentially fencing them in.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Working with the AtoMiC Toolkit</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">java.util.concurrent.atomic</kbd> <span class="calibre7">package is a collection of 12 sub-classes that support operations on single variables that are thread-safe and lock-free. In this context, thread-safe refers to code that accesses or mutates a shared single variable without impeding on other threads executing on the variable at the same time. This superclass was introduced in Java 7.</span></p>
<p class="mce-root">Here is a list of the 12 sub-classes in the AtoMiC Toolkit. The class names, as you would expect, are self-descriptive:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Atomic subclass</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicBoolean</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicInteger</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicIntegerArray</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicIntegerFieldUpdater&lt;T&gt;</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicLong</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicLongArray</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;T&gt;</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicMarkableReference&lt;V&gt;</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">java.util.concurrent.atomic.AtomicReference&lt;V&gt;</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><span class="calibre5"><kbd class="calibre16">java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;</kbd></span></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><span class="calibre5"><kbd class="calibre16">java.util.concurrent.atomic.AtomicReferenceFieldUpdater&lt;T,V&gt;</kbd></span></td>
</tr>
<tr class="calibre41">
<td class="calibre33"><span class="calibre5"><kbd class="calibre16">java.util.concurrent.atomic.AtomicStampedReference&lt;V&gt;</kbd></span></td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root">Volatile variables, fields, and array elements can be asynchronously modified by concurrent threads.</p>
<div class="packt_infobox">In Java, the <kbd class="calibre39">volatile</kbd> keyword is used to inform the javac utility to read the value, field, or array element from the main memory and not to cache them.</div>
<p class="mce-root">Here is a code snippet that demonstrates the use of the volatile keyword for an instance variable:</p>
<pre class="calibre21">    public class Sample <br class="calibre2"/>    {<br class="calibre2"/>      private static volatile Sample myVolatileVariable; // a<br class="calibre2"/>       volatile instance variable<br class="calibre2"/><br class="calibre2"/>      public static Sample getVariable() // getter method<br class="calibre2"/>      {<br class="calibre2"/>        if (myVolatileVariable != null) <br class="calibre2"/>        {<br class="calibre2"/>          return myVolatileVariable;<br class="calibre2"/>        }<br class="calibre2"/>        // this section executes if myVolatileVariable == null<br class="calibre2"/>        synchronized(Sample.class)<br class="calibre2"/>        {<br class="calibre2"/>          if (myVolatileVariable == null)<br class="calibre2"/>          {<br class="calibre2"/>            myVolatileVariable =  new Sample();<br class="calibre2"/>          }<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using the sun.misc.Unsafe class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">sun.misc.Unsafe</kbd> class, like other <kbd class="calibre16">sun</kbd> classes, is not officially documented or supported. It has been used to circumvent some of Java's built-in memory management safety features. While this can be viewed as a window to greater control and flexibility in our code, it is a terrible programming practice.</p>
<p class="mce-root">The class had a single private constructor, so an instance of the class could not easily be instantiated. So, if we tried to instantiate an instance with <kbd class="calibre16"><span class="calibre5">myUnsafe = new Unsafe()</span></kbd>, a <kbd class="calibre16">SecurityException</kbd> would be thrown in most circumstances. This somewhat unreachable class has over 100 methods that permitted operations on arrays, classes, and objects. Here is a brief sampling of those methods:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Arrays</strong></td>
<td class="calibre33"><strong class="calibre3">Classes</strong></td>
<td class="calibre33"><strong class="calibre3">Objects</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">arrayBaseOffset</span></kbd></td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">defineAnonymousClass</span></kbd></td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">allocateInstance</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">arrayIndexScale</span></kbd></td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">defineClass</span></kbd></td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">objectFieldOffset</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">ensureClassInitialized</span></kbd></td>
<td class="calibre33"/>
</tr>
<tr class="calibre41">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">staticFieldOffset</span></kbd></td>
<td class="calibre33"/>
</tr>
</tbody>
</table>
<p class="mce-root"><span class="calibre7">Here is a secondary grouping of the <kbd class="calibre16">sun.misc.Unsafe</kbd> class method for information, memory, and synchronization:</span></p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Information</strong></td>
<td class="calibre33"><strong class="calibre3">Memory</strong></td>
<td class="calibre33"><strong class="calibre3">Synchronization</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">addressSize</kbd></td>
<td class="calibre33"><kbd class="calibre16">allocateMemory</kbd></td>
<td class="calibre33"><kbd class="calibre16">compareAndSwapInt</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"><kbd class="calibre16">pageSize</kbd></td>
<td class="calibre33"><kbd class="calibre16">copyMemory</kbd></td>
<td class="calibre33"><kbd class="calibre16">monitorEnter</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16">freeMemory</kbd></td>
<td class="calibre33"><kbd class="calibre16">monitorExit</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16">getAddress</kbd></td>
<td class="calibre33"><kbd class="calibre16">putOrderedEdit</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16">getInt</kbd></td>
<td class="calibre33"><kbd class="calibre16">tryMonitorEnter</kbd></td>
</tr>
<tr class="calibre41">
<td class="calibre33"/>
<td class="calibre33"><kbd class="calibre16">putInt</kbd></td>
<td class="calibre33"/>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">sun.misc.Unsafe</kbd> <span class="calibre7">class was earmarked for removal in Java 9. There was actually some opposition to this decision in the programming industry. To put their concerns to rest, the class has been depreciated, but will not be completely removed. A special flag can be sent to the JVM to utilize the original API.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Eliding depreciation warnings on import statements [JEP 211]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This is one of the more simplistic JEPs for Java 9. Quite often, when we compile our programs, we receive many warnings and errors. The compiler errors must be fixed as they are typically syntactical in nature. The warnings, on the other hand, should be reviewed and appropriately addressed. Some of the warning messages are ignored by developers.</p>
<p class="mce-root">This JEP provides slight relief in the number of warnings we receive. Specifically, depreciation warnings caused by import statements are no longer generated. Prior to Java 9, we could suppress deprecated warning messages with the following annotation:</p>
<pre class="calibre21">    @SupressWarnings</pre>
<p class="mce-root">Now, with Java 9, the compiler will suppress depreciated warnings if one or more of the following cases is true:</p>
<ul class="calibre13">
<li class="calibre14">If the <kbd class="calibre16">@Deprecated</kbd> annotation is used</li>
<li class="calibre14"><span class="calibre5">If the</span> <kbd class="calibre16">@SuppressWarnings</kbd> <span class="calibre5">annotation is used</span></li>
<li class="calibre14">If the use of the warning-generating code and the declaration are within the ancestor class</li>
<li class="calibre14">If the use of the warning-generating code is within an import statement</li>
</ul>
<p class="mce-root">The fourth condition listed was an addition in Java 9.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Milling Project Coin [JEP 213]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Project Coin was a feature set of minor changes introduced in Java 7. These changes are listed as follows:</p>
<ul class="calibre13">
<li class="calibre14">Strings in <kbd class="calibre16">switch</kbd> statements</li>
<li class="calibre14">Binary integral literals</li>
<li class="calibre14">Using underscores in numeric literals</li>
<li class="calibre14">Implementing multi-catch</li>
<li class="calibre14">Allowing for more precise re-throwing of exceptions</li>
<li class="calibre14">Generic instance creation improvements</li>
<li class="calibre14">Addition of the <kbd class="calibre16">try-with-resources</kbd> statement</li>
<li class="calibre14">Improvements to invoking <kbd class="calibre16">varargs</kbd> methods</li>
</ul>
<p class="mce-root">Detailed information can be found in the following Oracle presentation: <a href="http://www.oracle.com/us/technologies/java/project-coin-428201.pdf" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://www.oracle.com/us/technologies/java/project-coin-428201.pdf</a>.</p>
<p class="mce-root">JEP 213 focused on improvements to Project Coin's enhancements. There were five such enhancements, each detailed as follows.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using the @SafeVarargs annotation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In Java 9, we can use th<span class="calibre7">e</span> <kbd class="calibre16">@SafeVarargs</kbd> <span class="calibre7">annotation with private instance methods. When we use this annotation, we are asserting that the method does not contain any harmful operations on the <kbd class="calibre16">varargs</kbd> passed as parameters to the method.</span></p>
<p class="mce-root">The syntax for usage is:</p>
<pre class="calibre21">    @SafeVarargs // this is the annotation<br class="calibre2"/>    static void methodName(...) <br class="calibre2"/>    {<br class="calibre2"/><br class="calibre2"/>      /*<br class="calibre2"/>      The contents of the method or constructor must not <br class="calibre2"/>      perform any unsafe or potentially unsafe operations <br class="calibre2"/>      on the varargs parameter or parameters.<br class="calibre2"/>      */<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root"><span class="calibre7">Use of the <kbd class="calibre16">@SafeVarargs</kbd> annotation is restricted to:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Static methods</span></li>
<li class="calibre14"><span class="calibre5">Final instance methods</span></li>
<li class="calibre14"><span class="calibre5">Private instance methods</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The try-with-resource statement</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">try-with-resource</kbd> statement previously required a new variable to be declared for each resource in the statement when a final variable was used. Here is the syntax for the <kbd class="calibre16">try-with-resource</kbd> statement prior to Java 9 (in Java 7 or 8):</p>
<pre class="calibre21">    try ( // open resources ) <br class="calibre2"/>    {<br class="calibre2"/>      // use resources<br class="calibre2"/>    } catch (// error) <br class="calibre2"/>    {  // handle exceptions<br class="calibre2"/>    }<br class="calibre2"/>    // automatically close resources</pre>
<p class="mce-root">Here is a code snippet using the preceding syntax:</p>
<pre class="calibre21">    try ( Scanner xmlScanner = new Scanner(new File(xmlFile));<br class="calibre2"/>    {<br class="calibre2"/>       while (xmlScanner.hasNext())<br class="calibre2"/>       {<br class="calibre2"/>          // read the xml document and perform needed operations<br class="calibre2"/>       }<br class="calibre2"/>      xmlScanner.close();<br class="calibre2"/>    } catch (FileNotFoundException fnfe)<br class="calibre2"/>      {<br class="calibre2"/>         System.out.println("Your XML file was not found.");<br class="calibre2"/>      }</pre>
<p class="mce-root">Now, with Java 9, the <kbd class="calibre16">try-with-resource</kbd> statement can manage final variables without requiring a new variable declaration. So, we can now rewrite the earlier code, as shown here in Java 9:</p>
<pre class="calibre21">    Scanner xmlScanner = new Scanner(newFile(xmlFile));<br class="calibre2"/>    try ( while (xmlScanner.hasNext())<br class="calibre2"/>    {<br class="calibre2"/>       {<br class="calibre2"/>         // read the xml document and perform needed operations<br class="calibre2"/>       }<br class="calibre2"/>       xmlScanner.close();<br class="calibre2"/>    } catch (FileNotFoundException fnfe)<br class="calibre2"/>      {<br class="calibre2"/>         System.out.println("Your XML file was not found.");<br class="calibre2"/>      }</pre>
<p class="mce-root">As you can see, the <kbd class="calibre16">xmlScanner</kbd> object reference is contained inside the <kbd class="calibre16">try-with-resource</kbd> statement block, which provides for automatic resource management. The resource will automatically be closed as soon as the <kbd class="calibre16">try-with-resource</kbd> statement block is exited.</p>
<div class="packt_tip">You can also use <span class="calibre5">a</span> <kbd class="calibre39">finally</kbd> block as part of the <kbd class="calibre39">try-with-resource</kbd> statement.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using the diamond operator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Introduced in Java 9, the diamond operator can be used with anonymous classes if the inferred data type is denotable. When a data type is inferred, it suggests that the Java Compiler can determine the data types in a method's invocation. This includes the declaration and any included arguments.</p>
<div class="packt_infobox">The diamond operator is the less-than and greater-than symbol pair (<kbd class="calibre39">&lt;&gt;</kbd> ). It is not new to Java 9; rather, the specific use with anonymous classes is.</div>
<p class="mce-root">The diamond operator was introduced in Java 7 and made instantiating generic classes simpler. Here is a pre-Java 7 example:</p>
<pre class="calibre21">    ArrayList&lt;Student&gt; roster = new ArrayList&lt;Student&gt;();</pre>
<p class="mce-root">Then, in Java 7, we could rewrite it:</p>
<pre class="calibre21">    ArrayList&lt;Student&gt; roster = new ArrayList&lt;&gt;();</pre>
<p class="mce-root">The problem was that this method could not be used for anonymous classes. Here is an example in Java 8 that works fine:</p>
<pre class="calibre21">    public interface Example&lt;T&gt; <br class="calibre2"/>    {<br class="calibre2"/>      void aMethod()<br class="calibre2"/>      {<br class="calibre2"/>        // interface code goes here<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    Example example = new Example&lt;Integer&gt;() <br class="calibre2"/>    {<br class="calibre2"/>      @Override<br class="calibre2"/>      public void aMethod() <br class="calibre2"/>      {<br class="calibre2"/>        // code<br class="calibre2"/>      }<br class="calibre2"/>    };</pre>
<p class="mce-root">While the preceding code works fine, when we change it to use the diamond operator, as shown here, a compiler error will occur:</p>
<pre class="calibre21">    public interface Example&lt;T&gt; <br class="calibre2"/>    {<br class="calibre2"/>      void aMethod()<br class="calibre2"/>      {<br class="calibre2"/>        // interface code goes here<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    Example example = new Example&lt;&gt;() <br class="calibre2"/>    {<br class="calibre2"/>      @Override<br class="calibre2"/>      public void aMethod() <br class="calibre2"/>      {<br class="calibre2"/>        // code<br class="calibre2"/>      }<br class="calibre2"/>    };</pre>
<p class="mce-root">The error results from using the diamond operator with anonymous inner classes. Java 9 to the rescue. While the preceding code results in a compile time error in Java 8, it works fine in Java 9.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Discontinuing use of the underscore</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The underscore character ( <kbd class="calibre16">_</kbd> ) can no longer be used as a legal identifier name. Earlier attempts to remove the underscore in an identifier name were incomplete. The use of such would generate a combination of errors and warnings. With Java 9, the warnings are now errors. Consider the following sample code:</p>
<pre class="calibre21">    public class Java9Tests <br class="calibre2"/>    { <br class="calibre2"/>      public static void main(String[] args) <br class="calibre2"/>      {<br class="calibre2"/>        int _ = 319;<br class="calibre2"/>        if ( _ &gt; 300 )<br class="calibre2"/>        {<br class="calibre2"/>          System.out.println("Your value us greater than 300."); <br class="calibre2"/>        } <br class="calibre2"/>        else <br class="calibre2"/>        {<br class="calibre2"/>          System.out.println("Your value is not greater than 300.");<br class="calibre2"/>        }<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">The preceding code, in Java 8, will result in compiler warnings for <kbd class="calibre16">int _ = 319;</kbd> <span class="calibre7">and</span> <kbd class="calibre16">if ( _ &gt; 300 )</kbd> <span class="calibre7">statements. The warning is</span> <em class="calibre20">as of release 9, '_' is a keyword, and may not be used as an identifier</em><span class="calibre7">. So, in Java 9, you will not be able to use the underscore by itself as a legal identifier.</span></p>
<div class="packt_tip">It is considered bad programming practice to use identifier names that are not self-descriptive. So, the use of the underscore character by itself as an identifier name should not be a problematic change.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Making use of private interface methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Lambda expressions were a big part of the Java 8 release. As a follow-up to that improvement, private methods in interfaces are now feasible. Previously, we could not share data between non-abstract methods of an interface. With Java 9, this data sharing is possible. Interface methods can now be private. Let's look at some sample code.</p>
<p class="mce-root">This first code snippet is how we might code an interface in Java 8:</p>
<pre class="calibre21">    . . . <br class="calibre2"/>    public interface characterTravel<br class="calibre2"/>    {<br class="calibre2"/>      pubic default void walk()<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        p = p +1;<br class="calibre2"/>      }<br class="calibre2"/>      public default void run()<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        p = p +4;<br class="calibre2"/>      }<br class="calibre2"/>      public default void fastWalk()<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        p = p +2;<br class="calibre2"/>      }<br class="calibre2"/>      public default void retreat()<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        p = p - 1;<br class="calibre2"/>      }<br class="calibre2"/>      public default void fastRetreat()<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        p = p - 4;<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Now, in Java 9, we can rewrite this code. As you can see next, the redundant code has been moved into a single private method called <kbd class="calibre16">characterTravel</kbd>:</p>
<pre class="calibre21">    . . . <br class="calibre2"/>    public interface characterTravel<br class="calibre2"/>    {<br class="calibre2"/>      pubic default void walk()<br class="calibre2"/>      {<br class="calibre2"/>        characterTravel("walk");<br class="calibre2"/>      }<br class="calibre2"/>      public default void run()<br class="calibre2"/>      {<br class="calibre2"/>        characterTravel("run");<br class="calibre2"/>      }<br class="calibre2"/>      public default void fastWalk()<br class="calibre2"/>      {<br class="calibre2"/>        characterTravel("fastWalk");<br class="calibre2"/>      }<br class="calibre2"/>      public default void retreat()<br class="calibre2"/>      {<br class="calibre2"/>        characterTravel("retreat");<br class="calibre2"/>      }<br class="calibre2"/>      public default void fastRetreat()<br class="calibre2"/>      {<br class="calibre2"/>        characterTravel("fastRetreat");<br class="calibre2"/>      }<br class="calibre2"/>      private default void characterTravel(String pace)<br class="calibre2"/>      {<br class="calibre2"/>        Scanner scanner = new Scanner(System.in);<br class="calibre2"/>        System.out.println("Enter desired pacing: ");<br class="calibre2"/>        int p = scanner.nextInt();<br class="calibre2"/>        if (pace.equals("walk"))<br class="calibre2"/>        {<br class="calibre2"/>          p = p +1;<br class="calibre2"/>        }<br class="calibre2"/>        else if (pace.equals("run"))<br class="calibre2"/>        {<br class="calibre2"/>          p = p + 4;<br class="calibre2"/>        }<br class="calibre2"/>        else if (pace.equals("fastWalk"))<br class="calibre2"/>        {<br class="calibre2"/>          p = p + 2;<br class="calibre2"/>        }<br class="calibre2"/>        else if (pace.equals("retreat"))<br class="calibre2"/>        {<br class="calibre2"/>          p = p - 1;<br class="calibre2"/>        }<br class="calibre2"/>        else if (pace.equals("fastRetreat"))<br class="calibre2"/>        {<br class="calibre2"/>          p = p - 4;<br class="calibre2"/>        }<br class="calibre2"/>        else<br class="calibre2"/>        {<br class="calibre2"/>          //<br class="calibre2"/>        }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Processing import statements correctly [JEP 216]</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">JEP 216 was issued as a fix to javac in regards to how import statements are processed. Prior to Java 9, there were instances where the order of import statements would impact if the source code was accepted or not.</p>
<p class="mce-root">When we develop applications in Java, we typically add import statements as we need them, resulting in an unordered list of import statements. IDEs do a great job of color-coding import statements that are not used, as well as informing us of import statements we need but that have not been included. It should not matter what order the import statements are in; there is no applicable hierarchy.</p>
<p class="mce-root"><span class="calibre7">javac</span> <span class="calibre7">compiles classes in</span> <span class="calibre7">two primary</span> <span class="calibre7">steps. Specific to handling import statements, these steps are type resolution and member resolution. The type resolution consists of a review of the abstract syntax tree to identify declarations of classes and interfaces. The member resolution includes determining the class hierarchy and individual class variables and members.</span></p>
<p class="mce-root">With Java 9, the order we list import statements in our classes and files will no longer impact the compilation process. Let's look at an example:</p>
<pre class="calibre21">    package samplePackage;<br class="calibre2"/><br class="calibre2"/>    import static SamplePackage.OuterPackage.Nested.*;<br class="calibre2"/>    import SamplePackage.Thing.*;<br class="calibre2"/><br class="calibre2"/>    public class OuterPackage <br class="calibre2"/>    {<br class="calibre2"/>      public static class Nested implements Inner <br class="calibre2"/>      { <br class="calibre2"/>        // code<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    package SamplePackage.Thing;<br class="calibre2"/><br class="calibre2"/>    public interface Inner <br class="calibre2"/>    {<br class="calibre2"/>      // code<br class="calibre2"/>    }</pre>
<p class="mce-root">In the preceding example, type resolution occurs and results in the following realizations:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">SamplePackage.OuterPackage</kbd> exists</li>
<li class="calibre14"><kbd class="calibre16">SamplePackage.OuterPackage.Nested</kbd> exists</li>
<li class="calibre14"><kbd class="calibre16">SamplePackage.Thing.Innner</kbd> exists</li>
</ul>
<p class="mce-root">The next step is member resolution, and this is where the problem existed prior to Java 9. Here is an overview of the sequential steps javac would use to conduct the member resolution for our sample code:</p>
<ol class="calibre18">
<li class="chapter">Resolution of <kbd class="calibre16">SamplePackage.OuterPackage</kbd> begins.</li>
<li class="chapter">The <kbd class="calibre16">SamplePackage.OuterPackage.Nested</kbd> import is processed.</li>
<li class="chapter">Resolution of the <kbd class="calibre16">SamplePackage.Outer.Nested</kbd> class begins.</li>
<li class="chapter">The inner interface is type checked, although, because it is not in scope at this point, inner cannot be resolved.</li>
<li class="chapter">Resolution of <kbd class="calibre16">SamplePackage.Thing</kbd> begins. This step includes importing all member types of <kbd class="calibre16">SamplePackage.Thing</kbd> into scope.</li>
</ol>
<p class="mce-root">So the error occurs, in our example, because <kbd class="calibre16">Inner</kbd> is out of scope when resolution is attempted. If steps 4 and 5 were swapped, it would not have been a problem.</p>
<p class="mce-root">The solution to the problem, implemented in Java 9, was to break the member resolution steps into additional sub-steps. Here are those steps:</p>
<ol class="calibre18">
<li class="chapter">Analyze the import statements.</li>
<li class="chapter">Create the hierarchy (class and interfaces).</li>
<li class="chapter">Analyze class headers and type parameters.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we covered changes in Java 9 with regards to variable handlers and how they relate to the Atomic Toolkit. We also covered depreciation warnings and why they are now suppressed under specific circumstances. Five enhancements to changes introduced with Java 7 as part of Project Coin were also reviewed. Finally, we explored the improvements to import statement processing.</p>
<p class="mce-root">In the next chapter, we will examine the structure of a Java module as specified by Project Jigsaw. We will take a deep dive into how Project Jigsaw is implemented as part of the Java platform. Code snippets from a sample e-commerce application are used throughout the chapter to demonstrate Java 9's modular system. Internal changes to the Java platform, in regards to the modular system, are also discussed.</p>


            </article>

            
        </section>
    </div>



  </body></html>