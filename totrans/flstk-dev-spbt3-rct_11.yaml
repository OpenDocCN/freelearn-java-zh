- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Introduction to TypeScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 简介
- en: This chapter introduces TypeScript. We will cover the basic skills that are
    required to use TypeScript with React and create our first React app with TypeScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 TypeScript。我们将涵盖使用 TypeScript 与 React 一起使用所需的基本技能，并使用 TypeScript 创建我们的第一个
    React 应用程序。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding TypeScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 TypeScript
- en: Using TypeScript features with React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中使用 TypeScript 功能
- en: Creating a React app with TypeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript 创建 React 应用程序
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For our work, React version 18 or higher will be required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的工作，需要 React 版本 18 或更高版本。
- en: 'You can find more resources at the GitHub link for this chapter: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter09).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的 GitHub 链接中找到更多资源：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter09)。
- en: Understanding TypeScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 TypeScript
- en: '**TypeScript** ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    is a strongly typed superset of JavaScript, developed by Microsoft. TypeScript
    adoption has grown a lot in recent years and it is widely used in the industry.
    It has an active development community and is supported by most popular libraries.
    In the JetBrains 2022 Developer Ecosystem report, TypeScript was named the fastest-growing
    programming language ([https://www.jetbrains.com/lp/devecosystem-2022/](https://www.jetbrains.com/lp/devecosystem-2022/)).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript** ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    是由微软开发的 JavaScript 的强类型超集。近年来，TypeScript 的采用率增长了很多，并且在业界得到了广泛的应用。它有一个活跃的开发社区，并且得到了大多数流行库的支持。在
    JetBrains 2022 开发者生态系统报告中，TypeScript 被命名为增长最快的编程语言 ([https://www.jetbrains.com/lp/devecosystem-2022/](https://www.jetbrains.com/lp/devecosystem-2022/))。'
- en: 'TypeScript offers several advantages compared to JavaScript, mostly due to
    strong typing:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 相比，TypeScript 提供了几个优势，这主要归功于强类型：
- en: TypeScript allows you to define **types** for variables, functions, and classes.
    This allows you to catch errors early in the development process.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 允许您为变量、函数和类定义 **类型**。这允许您在开发过程中早期捕获错误。
- en: TypeScript improves the scalability of your app, as well as making your code
    easier to maintain.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 提高了您应用程序的可扩展性，并使您的代码更容易维护。
- en: TypeScript improves code readability and makes your code more self-documenting.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 提高了代码的可读性，并使您的代码更具自文档化特性。
- en: Compared to JavaScript, the TypeScript learning curve can be steeper if you
    are not familiar with static typing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 相比，如果您不熟悉静态类型，TypeScript 的学习曲线可能会更陡峭。
- en: The easiest way to try TypeScript is to use an online environment such as *TypeScript
    Playground* ([https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)).
    If you want to code TypeScript locally, you can install the TypeScript compiler
    on your computer using `npm`. This will not be needed for our React project because
    Vite comes with built-in TypeScript support. TypeScript is transpiled to plain
    JavaScript and can then be executed in a JavaScript engine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 TypeScript 最简单的方法是使用在线环境，例如 *TypeScript Playground* ([https://www.typescriptlang.org/play](https://www.typescriptlang.org/play))。如果您想在本地编写
    TypeScript 代码，可以使用 `npm` 在您的计算机上安装 TypeScript 编译器。这在我们 React 项目中不是必需的，因为 Vite
    内置了 TypeScript 支持。TypeScript 被转换为纯 JavaScript，然后可以在 JavaScript 引擎中执行。
- en: 'The following `npm` command installs the latest version of TypeScript globally,
    allowing you to use TypeScript anywhere in your terminal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `npm` 命令全局安装最新版本的 TypeScript，允许您在任何终端中使用 TypeScript：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can check the installation by checking the TypeScript version number:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查 TypeScript 版本号来验证安装：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using Windows PowerShell, you might get an error stating that **running
    scripts is disabled on this system**. In this case, you have to change the execution
    policy to be able to run the installation command. You can read more at [https://go.microsoft.com/fwlink/?LinkID=135170](https://go.microsoft.com/fwlink/?LinkID=135170).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Windows PowerShell，可能会收到一个错误，表明 **在此系统上已禁用脚本运行**。在这种情况下，您必须更改执行策略才能运行安装命令。您可以在
    [https://go.microsoft.com/fwlink/?LinkID=135170](https://go.microsoft.com/fwlink/?LinkID=135170)
    上了解更多信息。
- en: Like JavaScript, TypeScript has good IDE support that makes your coding more
    productive, with features like linting and code autocompletion – for example,
    IntelliSense in Visual Studio Code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript类似，TypeScript拥有良好的IDE支持，这使得你的编码更加高效，具有诸如代码检查和代码自动补全等特性——例如，Visual
    Studio Code中的IntelliSense。
- en: Common types
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见类型
- en: 'TypeScript will automatically define the type of a variable when you initialize
    it. This is called **type inference**. In the following example, we declare a
    `message` variable and assign it to a string value. If we try to reassign it with
    another type, we get an error, as shown in the following image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化变量时，TypeScript会自动定义变量的类型。这被称为**类型推断**。在以下示例中，我们声明了一个`message`变量并将其赋值为字符串值。如果我们尝试将其重新赋值为其他类型，我们会得到一个错误，如下面的图片所示：
- en: '![](img/B19818_09_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_01.png)'
- en: 'Figure 9.1: Type inference'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：类型推断
- en: 'TypeScript has the following primitive types: `string`, `number`, and `boolean`.
    The `number` type represents both integer and floating-point numbers. You can
    also set an explicit type for a variable using the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript有以下原始类型：`string`，`number`，和`boolean`。`number`类型代表整数和浮点数。你还可以使用以下语法为变量设置显式类型：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code demonstrates explicit typing:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了显式类型定义：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The variables’ types can be checked using the `typeof` keyword, which returns
    a string representing the type of the variable it is applied to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`typeof`关键字检查变量的类型，它返回一个表示应用到的变量类型的字符串：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you don’t know the type of a variable, you can use the `unknown` type. It
    can be used when you get a value, for example, from some external source, and
    you don’t know its type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道变量的类型，你可以使用`unknown`类型。当你从外部源获取值时，例如，你不知道它的类型，可以使用它：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When a value is assigned to the unknown variable, you can check the type using
    the `typeof` keyword.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值赋给未知变量时，你可以使用`typeof`关键字检查其类型。
- en: TypeScript also provides the `any` type. If you define a variable using the
    `any` type, TypeScript doesn’t perform a type check or inference on that variable.
    You should avoid using the `any` type whenever possible, since it negates the
    effectiveness of TypeScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还提供了`any`类型。如果你使用`any`类型定义一个变量，TypeScript不会对该变量执行类型检查或推断。你应该尽可能避免使用`any`类型，因为它会抵消TypeScript的效果。
- en: '**Arrays** can be declared in the same way as in JavaScript, but you have to
    define the type of the elements in the array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**可以像JavaScript中一样声明，但你必须定义数组中元素的类型：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the `Array` generic type (`Array<TypeOfElement>`) in the following
    way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以以下这种方式使用`Array`泛型类型（`Array<TypeOfElement>`）：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Type inference also works with objects. If you create the following object,
    TypeScript creates an object with these inferred types: `id: number`, `name: string`,
    and `email: string`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '类型推断也适用于对象。如果你创建以下对象，TypeScript会创建一个具有以下推断类型的对象：`id: number`，`name: string`，和`email:
    string`：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also define an object using the `interface` or `type` keyword, which
    describes the object’s shape. The `type` and `interface` are quite similar, and
    most of the time you are free to choose which one you use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`interface`或`type`关键字定义一个对象，它描述了对象的形状。`type`和`interface`非常相似，大多数情况下你可以自由选择使用哪一个：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, you can declare an object that conforms to the `Student` interface or
    type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以声明一个符合`Student`接口或类型的对象：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can read more about the difference between `type` and `interface` in the
    TypeScript documentation: [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在TypeScript文档中了解更多关于`type`和`interface`之间差异的信息：[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)。
- en: 'Now, if you try to create an object that doesn’t match the interface or type,
    you will get an error. In the next image, we create an object where the `id` property
    value is `string`, but it is defined as `number` in the interface:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试创建一个不符合接口或类型的对象，你会得到一个错误。在下一张图片中，我们创建了一个对象，其中`id`属性值是`string`，但在接口中定义为`number`：
- en: '![](img/B19818_09_02.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_02.png)'
- en: 'Figure 9.2: Interface'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：接口
- en: 'You can define optional properties by using the question mark (`?`) at the
    end of the property name. In the following example, we mark `email` to be optional.
    Now, you can create a student object without an email because it is an optional
    property:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在属性名末尾使用问号 (`?`) 来定义可选属性。在以下示例中，我们将 `email` 标记为可选。现在，你可以创建一个没有电子邮件的学生对象，因为它是一个可选属性：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The **optional chaining operator** (`?.`) can be used to safely access object
    properties and methods that can be `null` or `undefined` without causing an error.
    It is really useful with optional properties. Let’s look at the following type,
    where `address` is optional:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选链操作符** (`?.`) 可以用来安全地访问可能为 `null` 或 `undefined` 的对象属性和方法，而不会导致错误。这对于可选属性非常有用。让我们看看以下类型，其中
    `address` 是可选的：'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can create an object based on the `Person` type that doesn’t have the `address`
    property defined:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以基于 `Person` 类型创建一个没有定义 `address` 属性的对象：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if you try to access the `address` property, an error is thrown:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试访问 `address` 属性，将会抛出一个错误：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, if you use optional chaining, the value `undefined` is printed to
    the console and an error is not thrown:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用可选链，控制台将打印出值 `undefined`，而不会抛出错误：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are also many ways to compose types in TypeScript. You can use the `|`
    operator to create a **union type**, a type that handles different types. For
    example, the following example defines a type that can contain a string or number:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，有许多方式可以组合类型。你可以使用 `|` 运算符来创建一个 **联合类型**，它处理不同的类型。例如，以下示例定义了一个可以包含字符串或数字的类型：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also use union types to define sets of strings or numbers, as shown
    in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用联合类型来定义字符串或数字的集合，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can use our union types in the following way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以以下方式使用我们的联合类型：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you create a new `Car` object and try to assign some other value than what
    is defined in the `Fuel` or `NoOfGears` union types, you will get an error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个新的 `Car` 对象并尝试分配 `Fuel` 或 `NoOfGears` 联合类型中未定义的其他值，你会得到一个错误。
- en: Functions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'When you define functions, you can set parameter types in the following way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义函数时，你可以按以下方式设置参数类型：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you now try to call the function using a different parameter type, you will
    get an error:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试使用不同的参数类型来调用函数，你会得到一个错误：
- en: '![](img/B19818_09_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_03.png)'
- en: 'Figure 9.3: Function call'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：函数调用
- en: 'If a function parameter type is not defined, it implicitly has an `any` type.
    You can also use union types in function parameters:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数参数类型未定义，它隐式地具有 `any` 类型。你还可以在函数参数中使用联合类型：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A function’s return type can be declared in the following way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回类型可以声明如下：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Arrow functions work in the same way in TypeScript, for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数在 TypeScript 中的工作方式相同，例如：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the arrow function returns nothing, you can use the `void` keyword:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果箭头函数没有返回任何内容，你可以使用 `void` 关键字：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you have encountered some TypeScript basics, and we will learn how to apply
    these new skills in our React apps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经遇到了一些 TypeScript 基础知识，我们将学习如何在我们的 React 应用程序中应用这些新技能。
- en: Using TypeScript features with React
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中使用 TypeScript 功能
- en: TypeScript is a valuable addition to your React projects, especially when they
    grow in complexity. In this section, we will learn how we can get prop and state
    type validation in our React components and detect potential errors early in development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是你 React 项目的宝贵补充，尤其是在它们变得复杂时。在本节中，我们将学习如何在我们的 React 组件中获得属性和状态类型验证，并在开发早期检测潜在的错误。
- en: State and props
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态和属性
- en: In React, you have to define the type of component props. We have already learned
    that component props are JavaScript objects, so we can use `type` or `interface`
    to define the prop type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，你必须定义组件属性的类型。我们已经了解到组件属性是 JavaScript 对象，因此我们可以使用 `type` 或 `interface`
    来定义属性类型。
- en: 'Let’s look at one example where a component receives a `name` (`string`) and
    `age` (`number`) prop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中组件接收一个 `name` (`string`) 和 `age` (`number`) 属性：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can render our `HelloComponent` and pass props to it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以渲染我们的 `HelloComponent` 并将其属性传递给它：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we use TypeScript, we can first create a `type` that describes our props:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 TypeScript，我们可以首先创建一个 `type` 来描述我们的属性：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can use our `HelloProps` type in the component props:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在组件属性中使用我们的 `HelloProps` 类型：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if we pass props using the wrong type, we will get an error. This is great
    because, now, we can catch potential errors in the development phase:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用错误的类型传递属性，我们会得到一个错误。这很好，因为现在我们可以在开发阶段捕获潜在的错误：
- en: '![](img/B19818_09_04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_04.png)'
- en: 'Figure 9.4: Typing props'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：输入props
- en: If we had used JavaScript instead, we wouldn’t have seen an error in this phase.
    In JavaScript, if we had passed a string as the `age` prop instead of a number,
    it would still have worked, but we might have encountered unexpected behavior
    or errors if we had tried to perform numerical operations on it later on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了JavaScript，在这个阶段我们不会看到错误。在JavaScript中，如果我们把字符串作为`age`prop而不是数字传递，它仍然可以工作，但如果我们稍后尝试对其进行数值操作，可能会遇到意外的行为或错误。
- en: 'If there are optional props, you can mark these using the question mark in
    your type where you define the props – for example, if `age` is optional:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可选的props，你可以在定义props的类型时使用问号来标记这些props - 例如，如果`age`是可选的：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, you can use your component with or without `age` props.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用你的组件，带有或不带有`age`props。
- en: 'If you want to pass a function using the props, you can define it in your `type`
    using the following syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过props传递一个函数，你可以在你的`type`中定义它，使用以下语法：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Quite often, you will want to use the same `type` in multiple files in your
    app. In that case, it is a good practice to extract types into their own file
    and export them:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是你想在应用中的多个文件中使用相同的`type`。在这种情况下，将类型提取到它们自己的文件并导出它们是一个好习惯：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you can import the type into any component where you need it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将类型导入到任何需要它的组件中：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we touched on in *Chapter 8*, you can also use the arrow function to create
    a functional component. There is a standard React type, `FC` (**function component**),
    that we can use with arrow functions. This type takes a generic argument that
    specifies the prop type, which is `HelloProps` in our case:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第8章中提到的，你还可以使用箭头函数来创建一个函数组件。有一个标准的React类型，`FC`（**函数组件**），我们可以与箭头函数一起使用。这个类型接受一个泛型参数，指定了prop类型，在我们的例子中是`HelloProps`：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, you have learned how to define prop types in your React app, so we will
    move on to states. When you create states using the `useState` hook we learned
    about in *Chapter 8*, type inference handles typing when you are using common
    primitive types. For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何在你的React应用中定义prop类型，所以我们将继续到状态。当你使用我们在第8章中学习的`useState`钩子创建状态时，类型推断会在你使用常见原始类型时处理类型。例如：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you try to update the state using a different type, you will get an error:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用不同的类型来更新状态，你会得到一个错误：
- en: '![](img/B19818_09_05.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_05.png)'
- en: 'Figure 9.5: Typing state'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：输入状态
- en: 'You can also explicitly define state types. You have to do this if you want
    to initialize your state to `null` or `undefined`. In this case, you can use the
    union operator, and the syntax is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以显式地定义状态类型。如果你想将你的状态初始化为`null`或`undefined`，你必须这样做。在这种情况下，你可以使用联合操作符，语法如下：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you have a complex state, you can use a `type` or `interface`. In the following
    example, we create a type that describes a user. Then, we create a state and initialize
    it with an empty `User` object. If you want to allow `null` values, you can use
    a union to allow either a `User` object or a `null` value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个复杂的状态，你可以使用`type`或`interface`。在下面的例子中，我们创建了一个描述用户的类型。然后，我们创建了一个状态，并用一个空的`User`对象初始化它。如果你想允许`null`值，你可以使用联合来允许`User`对象或`null`值：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Events
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'In *Chapter 8*, we learned how to read user input in a React app. We used the
    input element’s `onChange` event handler to save typed data to the state. When
    using TypeScript, we have to define the types of events. In the following screenshot,
    you can see that we get an error if types are not defined:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们学习了如何在React应用中读取用户输入。我们使用了输入元素的`onChange`事件处理程序来将输入的数据保存到状态中。当使用TypeScript时，我们必须定义事件类型。在下面的屏幕截图中，你可以看到如果没有定义类型，我们会得到一个错误：
- en: '![](img/B19818_09_06.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_06.png)'
- en: 'Figure 9.6: Typing events'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：输入事件
- en: 'Let’s see how we can handle an input element’s change event. Let’s see one
    example where the input element code in the `return` statement looks like the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何处理一个输入元素的更改事件。让我们看一个例子，其中`return`语句中的输入元素代码如下：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The event handler function is called when the user types something into the
    input element, and the code looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在输入元素中输入某些内容时，会调用事件处理函数，代码如下：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have to define the type of the event. For this, we can use the predefined
    `React.ChangeEvent` type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义事件类型。为此，我们可以使用预定义的`React.ChangeEvent`类型。
- en: 'You can read the complete list of event types in the React TypeScript CheatSheet:
    [https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在React TypeScript Cheatsheet中阅读事件类型的完整列表：[https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/).
- en: 'We want to handle a change event on an input element, so the type is the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要处理一个输入元素的change事件，所以类型如下：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The form submission handler function handles the form submission. This function
    should take an event parameter of the type `React.FormEvent<HTMLFormElement>`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交处理函数处理表单提交。这个函数应该接受一个类型为`React.FormEvent<HTMLFormElement>`的事件参数：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we know how to handle events when using TypeScript in our React apps. Next,
    we will learn how to actually create a React app that uses TypeScript.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何在我们的React应用中使用TypeScript处理事件。接下来，我们将学习如何实际创建一个使用TypeScript的React应用。
- en: Creating a React app with TypeScript
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript创建React应用
- en: 'Now, we will create a React app using Vite, and we will use TypeScript instead
    of JavaScript. We will use TypeScript later when we develop the frontend for our
    car backend. As we mentioned earlier, Vite comes with built-in TypeScript support:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Vite创建一个React应用，我们将使用TypeScript而不是JavaScript。当我们在我们的汽车后端开发前端时，我们将使用TypeScript。正如我们之前提到的，Vite自带内置的TypeScript支持：
- en: 'Create a new React app using the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的React应用：
- en: '[PRE40]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, name your project `tsapp`, and select the **React** framework and the
    **TypeScript** variant:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将你的项目命名为`tsapp`，并选择**React**框架和**TypeScript**变体：
- en: '![](img/B19818_09_07.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_07.png)'
- en: 'Figure 9.7: React TypeScript app'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：React TypeScript应用
- en: 'Then, move to your app folder, install dependencies, and run your app using
    the following commands:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到你的应用文件夹，安装依赖项，并使用以下命令运行你的应用：
- en: '[PRE41]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open your app folder in VS Code, and you will see that the filename of our `App`
    component is `App.tsx`:![](img/B19818_09_08.png)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开你的应用文件夹，你会看到我们的`App`组件的文件名是`App.tsx`：![](img/B19818_09_08.png)
- en: 'Figure 9.8: App.tsx'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.8：App.tsx
- en: The file extension of TypeScript React files is `.tsx` (combining JSX with TypeScript).
    The regular file extension of TypeScript files is `.ts`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypeScript React文件的文件扩展名是`.tsx`（将JSX与TypeScript结合）。TypeScript文件的常规文件扩展名是`.ts`。
- en: Locate the `tsconfig.json` file in the root of your project. This is a configuration
    file used by TypeScript to specify compiler options, such as the target version
    of the compiled JavaScript output or the module system that is used. We can use
    the default settings defined by Vite.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录中找到`tsconfig.json`文件。这是一个由TypeScript使用的配置文件，用于指定编译器选项，例如编译输出的目标版本或使用的模块系统。我们可以使用Vite定义的默认设置。
- en: 'Let’s create the React app that we used as an example in an earlier section,
    when we defined types for events. The user can enter a name, and when the button
    is pressed, a hello message is shown using an alert:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们创建一个React应用，这是我们之前在定义事件类型时作为示例使用的。用户可以输入一个名字，当按钮被按下时，会使用alert显示hello消息：
- en: 'First, we will remove the code from the `App.tsx` file’s return statement and
    leave only fragments. After also removing all unused imports (except the `useState`
    import), your code should look like the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`App.tsx`文件的返回语句中删除代码，只留下片段。在删除所有未使用的导入（除了`useState`导入）之后，你的代码应该看起来像以下这样：
- en: '[PRE42]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, create a `state` to store the value that the user enters into the input
    element:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`state`来存储用户输入到输入元素中的值：
- en: '[PRE43]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, add two input elements to the `return` statement, one that collects
    user input and another that submits the form:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`return`语句中添加两个输入元素，一个用于收集用户输入，另一个用于提交表单：
- en: '[PRE44]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, create the event handler functions, `handleSubmit` and `handleChange`.
    Now, we also have to define the types of the events:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建事件处理函数，`handleSubmit`和`handleChange`。现在，我们还需要定义事件类型：
- en: '[PRE45]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the app using the `npm run dev` command.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`命令运行应用。
- en: 'Try typing your name into the input element and pressing the **Submit** button.
    You should see the hello message showing your name:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将你的名字输入到输入元素中，然后按下**提交**按钮。你应该能看到显示你名字的hello消息：
- en: '![](img/B19818_09_09.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_09_09.png)'
- en: 'Figure 9.9: React TypeScript app'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：React TypeScript应用
- en: Vite and TypeScript
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vite和TypeScript
- en: Vite transpiles TypeScript files to JavaScript, but it doesn’t perform type
    checking. Vite uses **esbuild** to transpile TypeScript files because that is
    much faster than the TypeScript compiler (`tsc`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 将 TypeScript 文件转换为 JavaScript，但它不执行类型检查。Vite 使用 **esbuild** 来转换 TypeScript
    文件，因为它的速度比 TypeScript 编译器 (`tsc`) 快得多。
- en: The VS Code IDE handles type checking for us, and you should fix all errors
    that are shown in the IDE. You can also use a Vite plugin called `vite-plugin-checker`
    ([https://github.com/fi3ework/vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker)).
    Type checking is done when we build a Vite app to production, and all errors should
    be fixed before the production build. We will build our Vite app later in this
    book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code IDE 为我们处理类型检查，你应该修复 IDE 中显示的所有错误。你还可以使用一个名为 `vite-plugin-checker` 的
    Vite 插件 ([https://github.com/fi3ework/vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker))。类型检查在我们构建
    Vite 应用到生产环境时进行，所有错误应在生产构建之前修复。我们将在本书的后面部分构建我们的 Vite 应用。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to learn TypeScript and how to use it in our React
    apps. Now, we know how to use common types in TypeScript and how to define types
    for React component props and states. We also learned to define types for events,
    and created our first React app with TypeScript using Vite.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习 TypeScript 以及如何在我们的 React 应用中使用它。现在，我们知道了如何在 TypeScript 中使用常见类型，以及如何为
    React 组件的 props 和 states 定义类型。我们还学习了如何为事件定义类型，并使用 Vite 创建了我们的第一个带有 TypeScript
    的 React 应用。
- en: In the next chapter, we will focus on networking with React. We will also use
    the GitHub REST API to learn how to consume a RESTful web service with React.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用 React 进行网络编程。我们还将使用 GitHub REST API 来学习如何使用 React 消费 RESTful
    网络服务。
- en: Questions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is TypeScript?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 TypeScript？
- en: How do we define variable types?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何定义变量类型？
- en: How do we define types in functions?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在函数中定义类型？
- en: How do we define types for React props and states?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为 React 的 props 和 states 定义类型？
- en: How do we define types for events?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何定义事件类型？
- en: How do we create a React TypeScript app using Vite?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 Vite 创建一个 React TypeScript 应用？
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some other useful resources for learning about React with TypeScript:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些学习 React 与 TypeScript 的其他有用资源：
- en: React TypeScript Cheatsheets ([https://react-typescript-cheatsheet.netlify.app/](https://react-typescript-cheatsheet.netlify.app/))
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React TypeScript Cheatsheets ([https://react-typescript-cheatsheet.netlify.app/](https://react-typescript-cheatsheet.netlify.app/))
- en: '*Learn React with TypeScript, Second Edition*, by Carl Rippon ([https://www.packtpub.com/product/learn-react-with-typescript-second-edition/9781804614204](https://www.packtpub.com/product/learn-react-with-typescript-second-edition/9781804614204))'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《用 TypeScript 学习 React，第二版》*，作者 Carl Rippon ([https://www.packtpub.com/product/learn-react-with-typescript-second-edition/9781804614204](https://www.packtpub.com/product/learn-react-with-typescript-second-edition/9781804614204))'
- en: '*Mastering TypeScript*, by Nathan Rozentals ([https://www.packtpub.com/product/mastering-typescript-fourth-edition/9781800564732](https://www.packtpub.com/product/mastering-typescript-fourth-edition/9781800564732))'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通 TypeScript》*，作者 Nathan Rozentals ([https://www.packtpub.com/product/mastering-typescript-fourth-edition/9781800564732](https://www.packtpub.com/product/mastering-typescript-fourth-edition/9781800564732))'
- en: Learn more on Discord
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10796108009382640.png)'
