- en: 'Chapter 11: Dealing with Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：处理数据
- en: You should know that no matter what your application does, you will end up dealing
    with persistence sooner or later. Whether it's a payment, a post on social media,
    or anything else, information has no value if it's not stored, retrieved, aggregated,
    modified, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，无论你的应用程序做什么，你最终都会迟早处理持久性问题。无论是支付、社交媒体上的帖子还是其他任何事情，如果信息没有被存储、检索、聚合、修改等，那么信息就没有价值。
- en: For this reason, data is very much a point of concern when designing an application.
    The wrong modeling (as we saw in [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089),
    *Best Practices for Design and Development*, when talking about **Domain-Driven
    Development**) can lead to a weak application, which will be hard to develop and
    maintain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计应用程序时，数据是一个非常值得关注的点。错误的建模（正如我们在[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)，*设计和开发最佳实践*，在讨论**领域驱动开发**时所见）可能导致一个弱化的应用程序，这将很难开发和维护。
- en: In this chapter, we are taking data modeling a step further and discussing the
    ways your objects and values can be stored (also known as *data at rest*, as opposed
    to *data in motion*, where objects are still being actively manipulated by your
    application code).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨数据建模，讨论你的对象和值可以存储的方式（也称为*静态数据*，与*动态数据*相对，其中对象仍然被你的应用程序代码积极操作）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring relational databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关系数据库
- en: Introducing key/value stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍键/值存储
- en: Exploring NoSQL repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索NoSQL存储库
- en: Looking at filesystem storage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看文件系统存储
- en: Modern approaches – a multi-tier storage strategy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代方法 - 多层存储策略
- en: As we have seen with many topics in this book so far, data persistence has also
    evolved a lot. Similar to what happened to the software development models and
    the **Java Enterprise Edition** (**JEE**) framework, when we deal with data, we
    also have a lot of different options to implement in several use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书迄今为止的许多主题中看到的那样，数据持久性也发生了很大的变化。类似于软件开发模型和**Java企业版**（**JEE**）框架所发生的情况，当我们处理数据时，我们也有许多不同的选项来实现多个用例。
- en: However, just as we have seen elsewhere (namely, in JEE applications versus
    cloud-native alternatives), the old ways have not been abandoned (because they
    are still relevant in some cases); instead, they are being complemented by more
    modern approaches that are suited for other use cases. And this is exactly what
    happened with the first technology that we are going to discuss – relational databases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在其他地方看到的那样（即在JEE应用程序与云原生替代方案之间），旧的方法并没有被放弃（因为它们在某些情况下仍然相关）；相反，它们正被更适合其他用例的更现代的方法所补充。这正是我们将要讨论的第一项技术——关系数据库。
- en: Exploring relational databases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索关系数据库
- en: '**Relational databases** are hardly a new idea. The idea was first introduced
    by Edgar F. Codd in 1970\. Omitting the mathematical concepts behind it (for brevity),
    it says that data in a relational database is, as everybody knows, arranged into
    *tables* (we had a quick look at this in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*, in the *Persistence* section).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据库**几乎不是一个新概念。这个想法最初由Edgar F. Codd在1970年提出。为了简洁起见，省略了其背后的数学概念，它说关系数据库中的数据，正如众所周知，是按*表格*（我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)，*探索中间件和框架*，*持久性*部分中快速浏览过）排列的。'
- en: Roughly speaking, each table can be seen as one of the objects in our business
    model, with the columns mapping to the object fields and the rows (also known
    as *records*) representing the different object instances.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，每个表格都可以看作是我们业务模型中的一个对象，列映射到对象字段，行（也称为*记录*）代表不同的对象实例。
- en: In the following sections, we are going to review the basics of relational databases,
    starting with keys and relationships, the concept of transactionality, and stored
    procedures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将回顾关系数据库的基本知识，从键和关系、事务性概念和存储过程开始。
- en: Keys and relationships
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键和关系
- en: Depending on the database technology, it's a common idea to have a way to identify
    each row. This is commonly done by identifying a field (or a set of fields) that
    is unique to each record. This is the concept of a **primary key**. Primary keys
    can be considered a constraint, meaning that they represent some rules with which
    the data inserted into the table must comply. Those rules need to be maintained
    for the table (and its records) to stay in a valid state (in this case, by having
    each record associated with a unique ID). However, other constraints are usually
    implemented in a relational database. Depending on the specific technology of
    the database system, these constraints may be really complex validation formulas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库技术，有一个识别每行的方法是常见的想法。这通常是通过识别一个（或一组）对每个记录都是唯一的字段来完成的。这就是**主键**的概念。主键可以被视为一种约束，意味着它们代表了一些规则，数据插入到表中必须遵守这些规则。这些规则需要得到维护，以便表（及其记录）保持有效状态（在这种情况下，通过每个记录关联一个唯一的ID）。然而，通常在关系型数据库中还会实现其他约束。根据数据库系统的具体技术，这些约束可能非常复杂。
- en: 'Another core concept of the database world is the concept of **relations**.
    This is, as you can imagine, a way to model links between different objects (similar
    to what happens in the world of **Object-Oriented Programming** (**OOP**), where
    an object can contain references to other objects). The relations can fall into
    one of the following three cardinalities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库世界的另一个核心概念是**关系**的概念。正如您可以想象的，这是一种建模不同对象之间链接的方式（类似于在**面向对象编程**（OOP）的世界中发生的情况，其中对象可以包含对其他对象的引用）。关系可以落入以下三种基数之一：
- en: A **one-to-one** relationship represents a mapping of each record to one, and
    only one, record from another table. This is usually referring to a relationship
    in which each row points to a row containing further information, such as a user
    record pointing to a row representing the user's living address in another table.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**关系表示每个记录映射到另一个表中的一个且仅有一个记录。这通常指的是一种关系，其中每一行指向包含更多信息的另一行，例如用户记录指向另一个表中代表用户居住地址的行。'
- en: A **one-to-many** relationship is where we model a relation in which each record
    maps to a set of records in another table. In this case, the relation between
    the two tables is unbalanced. One record in a table refers to a set of related
    records in another table, while the reverse is not valid (each record maps to
    one and only one record in the source table). A practical example is a user versus
    payment relationship. Each user is associated with one or more payments, while
    each payment is linked to only one user.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**关系是我们对一个关系进行建模，其中每个记录映射到另一个表中的一组记录。在这种情况下，两个表之间的关系是不平衡的。一个表中的一条记录指向另一个表中的一组相关记录，而反过来则不成立（每个记录映射到源表中的一个且仅有一个记录）。一个实际的例子是用户与支付的关系。每个用户关联一个或多个支付，而每个支付只关联一个用户。'
- en: A **many-to-many** relationship is the last option. Basically, in this case,
    multiple rows from a table can relate to multiple rows in the related tables,
    and vice versa. An example of this kind of relationship is movies and actors.
    A record in a movie table will link to more than one row in the actor table (implementing
    the relation of actors starring in a movie). And the reverse is true – a row in
    the actor table will link to many records in the movie table, as each actor will
    most likely be part of more than one movie.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**关系是最后一个选项。基本上，在这种情况下，一个表中的多行可以与相关表中的多行相关联，反之亦然。这种关系的一个例子是电影和演员。电影表中的一条记录将链接到演员表中的多行（实现演员在电影中的关系）。反之亦然——演员表中的一行将链接到电影表中的多条记录，因为每个演员很可能参与多部电影。'
- en: 'Here is a diagram of the three types of relationship cardinalities:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是三种关系基数类型的图示：
- en: '![Figure 11.1 – Table relationships'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 表关系'
- en: '](img/Figure_11.1_B16354.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16354.jpg)'
- en: Figure 11.1 – Table relationships
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 表关系
- en: 'As you can see in the preceding diagram, there is a graphical representation
    of three examples of relationships:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到的，有三个关系示例的图形表示：
- en: '**One to One**, as in a person with address – each person can have just one
    primary home address.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**，例如一个人与地址的关系——每个人只能有一个主要家庭地址。'
- en: '**One to Many**, as in a person with transactions – each person can be associated
    with more than one payment transaction.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**，例如一个人与交易的关系——每个人可以与多个支付交易相关联。'
- en: '**Many to Many**, as in people with devices – each person can have many devices,
    and a device can be used by more than one person.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**，例如人与设备的关系——每个人可以有多个设备，一个设备也可以被多个人使用。'
- en: 'These relationships are nothing new; the same is true for Java objects, with
    which you can model the same kinds of relationship:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系并不新鲜；对于Java对象来说也是如此，你可以用它们来模拟相同类型的关系：
- en: A class can be linked one-to-one with another one, by having a field of it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过包含它的字段，与另一个类一对一地链接。
- en: A class can be linked in a one-to-many scenario by having a field containing
    a list (or a set) of objects of the target class type.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过包含一个包含目标类类型对象列表（或集合）的字段，在一对一场景中与其他类链接。
- en: A class can implement a many-to-many scenario by extending the previous scenario
    and having the target class type with a field containing a list (or set) of objects
    of the source class type (hence linking back and forth).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过扩展之前的场景，并让目标类类型包含一个包含源类类型对象列表（或集合）的字段来实现多对多场景（因此可以双向链接）。
- en: All of those models can then be propagated into SQL databases, and this is indeed
    done by JPA, which we introduced in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模型都可以传播到SQL数据库中，这确实是通过JPA实现的，我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)，“探索中间件和框架”中介绍了JPA。
- en: It used to be common (and it still happens in some cases) to define the domain
    model of an application, starting with the design of the database that will store
    the data. It's quite a simplistic approach since it cannot easily model every
    aspect of object-oriented applications (such as inheritance, interfaces, and many
    other constructs), but it works for some simple scenarios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以前（在某些情况下仍然如此）通常从设计将存储数据的数据库开始，定义应用程序的领域模型。这是一个相当简单的方法，因为它不能轻松地模拟面向对象应用程序的每个方面（如继承、接口和许多其他结构），但对于一些简单场景来说它是有效的。
- en: Transactionality
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务性
- en: 'One of the more interesting (and widely used) capabilities of a relational
    database is related to **transactionality**. Transactionality refers to a set
    of characteristics of relational databases that are the basis for maintaining
    data integrity (especially in the case of failures). These characteristics are
    united under the **ACID** acronym (which stands for **Atomicity**, **Consistency**,
    **Isolation**, and **Durability**):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的一个更有趣（并且广泛使用）的功能与**事务性**相关。事务性指的是关系型数据库的某些特性，这些特性是维护数据完整性的基础（尤其是在出现故障的情况下）。这些特性在**ACID**缩写词下统一起来（代表**原子性**、**一致性**、**隔离性**和**持久性**）：
- en: '**Atomicity**: Each transaction (which is typically a set of different operations,
    such as the creation, modification, or deletion of records in one or more tables)
    is treated as a single unit; it will be successful as a whole, or it will fail
    completely (leaving all the tables as they were before the transaction started).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：每个事务（通常是一组不同的操作，如在一个或多个表中创建、修改或删除记录）被视为一个单一单元；它要么整体成功，要么完全失败（使所有表保持事务开始之前的状态）。'
- en: '**Consistency**: Each transaction can only change the database into a valid
    state by maintaining all the existing constraints (such as primary keys).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：每个事务只能通过维护所有现有约束（如主键）来将数据库更改为有效状态。'
- en: '**Isolation**: The concurrent transactions must be executed correctly with
    no interference from other transactions. This basically means that the final effect
    of a number of transactions executed in parallel should be the same as the same
    transactions being executed sequentially.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：并发事务必须在没有其他事务干扰的情况下正确执行。这基本上意味着并行执行的一系列事务的最终效果应该与这些事务顺序执行的效果相同。'
- en: '**Durability**: This simply refers to the guarantee that a persisted transaction
    will be maintained (and can be retrieved) after a failure of the database system.
    In other words, the database should persist the data into non-volatile storage
    (a disk or similar technology).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这简单指的是在数据库系统失败后，持久化的事务将被保持（并且可以检索）。换句话说，数据库应该将数据持久化到非易失性存储（磁盘或类似技术）。'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Consider that the concept of transactionality is usually not very well suited
    to heavily distributed environments, such as microservices and cloud-native architecture.
    We will discuss this more in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到事务性的概念通常不适合高度分布的环境，如微服务和云原生架构。我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*中进一步讨论这个问题。
- en: Last but not least, many different technologies allow us to execute custom code
    directly on the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，许多不同的技术允许我们在数据库上直接执行自定义代码。
- en: Stored procedures
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过程
- en: Many widely used databases can run complex programs. There is no standard for
    this kind of feature, even if the languages that are often used are similar to
    extensions of SQL, including conditions, loops, and similar statements. Occasionally,
    some general-purpose languages (such as **Java** and **.NET**) are available on
    some database systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多广泛使用的数据库可以运行复杂的程序。这类功能没有标准，即使常用的语言类似于SQL的扩展，包括条件、循环和类似语句。偶尔，一些通用语言（如**Java**和**.NET**）在某些数据库系统中可用。
- en: The reason for storing code in a database is mainly data locality. By executing
    code in a database, the system has complete control over execution and transactional
    behavior (such as locking mechanisms); hence, you may end up getting very good
    performance. This may be particularly useful if you are doing batch operations
    and calculations on a large amount of data. But if you ask me, the advantages
    stop here and are not very worthwhile anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码存储在数据库中的原因主要是数据局部性。通过在数据库中执行代码，系统对执行和事务行为（如锁定机制）有完全的控制；因此，你可能会获得非常好的性能。这在进行大量数据的批量操作和计算时可能特别有用。但如果你问我，优势就到这里为止，而且并不非常值得。
- en: When using stored procedures on a database system, you will observe small performance
    improvements, but the overall solution will be ugly from an architectural point
    of view and hard to maintain. Putting business logic in the data layer is never
    a good idea from a design point of view, and using special, procedural languages
    (such as the ones often available on such platforms) can only make things worse.
    Moreover, such languages are almost always impossible to port from one database
    system to another, hence strongly coupling your application with a specific technology
    and making it hard to change technology if needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据库系统上使用存储过程时，你会观察到轻微的性能提升，但从架构角度来看，整体解决方案将显得很糟糕，并且难以维护。从设计角度来看，将业务逻辑放在数据层从来都不是一个好主意，而使用特殊的过程性语言（如这些平台通常可用的语言）只会使问题变得更糟。此外，这类语言几乎总是无法从一个数据库系统移植到另一个数据库系统，因此会强烈地将应用程序与特定技术耦合在一起，使得在需要时更改技术变得困难。
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unless it's really needed, I advise avoiding stored procedures at all costs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是真的需要，我强烈建议不惜一切代价避免使用存储过程。
- en: Now that we have seen a summary of the basic features, let's see the commonly
    used implementations of relational databases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了基本功能的概述，让我们看看关系型数据库的常用实现。
- en: Commonly used implementations of relation databases
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用的关系型数据库实现
- en: 'Let''s quickly discuss some commonly used products that provide the relational
    database features we have seen so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论一些提供我们之前看到的关系型数据库功能的常用产品：
- en: We cannot talk about relational databases without mentioning **Oracle** ([https://www.oracle.com/database/](https://www.oracle.com/database/)).
    The name of this vendor has become synonymous with databases. They provide many
    variants, including versions with clustering and embedded caching. This database
    is considered a de facto standard in many enterprises, and most commercially available
    software packages are compatible with Oracle databases. Oracle databases support
    Java and PL/SQL (a proprietary language) as ways to define stored procedures.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在谈论关系型数据库时，不能不提**Oracle** ([https://www.oracle.com/database/](https://www.oracle.com/database/))。这个供应商的名字已经成为数据库的同义词。他们提供了许多变体，包括具有集群和嵌入式缓存的版本。这个数据库在许多企业中被视为事实上的标准，并且大多数商业软件包都与Oracle数据库兼容。Oracle数据库支持Java和PL/SQL（一种专有语言）作为定义存储过程的方式。
- en: '**Microsoft SQL Server** ([https://www.microsoft.com/sql-server/](https://www.microsoft.com/sql-server/))
    is another widely used database server. It became popular for its complete features
    and proximity with the Microsoft ecosystem, as many widespread Microsoft applications
    use it. It also offers extensions for running .NET languages as part of stored
    procedures. It''s worth noting that for a couple of years, SQL Server has also
    been supported on Linux servers, widening the use cases for SQL Server, especially
    in cloud environments.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft SQL Server** ([https://www.microsoft.com/sql-server/](https://www.microsoft.com/sql-server/))
    是另一种广泛使用的数据库服务器。由于其完整的功能和与微软生态系统的紧密联系，以及许多广泛使用的微软应用程序都使用它，因此它变得非常流行。它还提供了扩展功能，可以在存储过程中运行
    .NET 语言。值得注意的是，在过去的几年里，SQL Server 也开始支持 Linux 服务器，这扩大了 SQL Server 的使用场景，尤其是在云环境中。'
- en: '**MySQL** ([https://www.mysql.com/](https://www.mysql.com/)) is another widely
    used database technology. It''s one of the first examples of an open source database
    and provides advanced features comparable to commercial databases. After the MySQL
    project was acquired by Oracle, a couple of forks have been created in order to
    keep the project autonomous. The most important fork currently available is called
    **MariaDB**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL** ([https://www.mysql.com/](https://www.mysql.com/)) 是另一种广泛使用的数据库技术。它是开源数据库的早期例子之一，并提供了与商业数据库相媲美的先进功能。在
    MySQL 项目被甲骨文公司收购后，为了保持项目独立，已经创建了几个分支。目前可用的最重要的分支被称为 **MariaDB**。'
- en: '**PostgreSQL** ([https://www.postgresql.org/](https://www.postgresql.org/))
    is another open source relational database and has been available for a very long
    time (it was released shortly after the first release of MySQL). In contrast with
    MySQL, however, it''s still independent, meaning that it hasn''t been acquired
    by a major software vendor. For this reason and because of the completeness of
    its features, it is still a widely used option in many setups. Also, it''s worth
    noting that many different third-party vendors provide commercial support and
    extensions to cover some specific use cases (such as clustering and monitoring).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL** ([https://www.postgresql.org/](https://www.postgresql.org/))
    是另一种开源的关系型数据库，并且已经存在很长时间（它在 MySQL 首次发布后不久就发布了）。然而，与 MySQL 相比，它仍然是独立的，这意味着它没有被主要软件供应商收购。因此，由于它的功能完整，它仍然是许多设置中广泛使用的选项。此外，值得注意的是，许多不同的第三方供应商提供商业支持和扩展，以覆盖一些特定的用例（如集群和监控）。'
- en: '`.jar` file, it''s easy to use it in an *in-memory* setup as part of the development
    process of Java applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jar` 文件，在 Java 应用程序的开发过程中，作为内存设置的一部分使用它非常容易。'
- en: This includes scenarios such as embedding the database as part of a development
    pipeline or a Maven task, when it can be programmatically destroyed, created,
    and launched any time you want. This makes it particularly useful in testing scenarios.
    Despite more complex setups being available (such as client servers), H2 is usually
    considered unsuitable for production usage. The most common use case, other than
    testing and development, is to ship it embedded with applications in order to
    provide a demo mode when an application is first started, suggesting that a different
    database should be set up and used before going into production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括将数据库嵌入到开发管道或 Maven 任务中作为一部分的场景，当它可以在需要时程序化地销毁、创建和启动。这使得它在测试场景中特别有用。尽管有更复杂的设置（如客户端服务器），H2
    通常被认为不适合生产使用。除了测试和开发之外，最常见的用途是将它嵌入到应用程序中，以便在应用程序首次启动时提供演示模式，建议在进入生产之前设置并使用不同的数据库。
- en: '**SQLite** ([https://www.sqlite.org/](https://www.sqlite.org/)) is another
    type of embeddable database. In contrast with H2, it''s written in the **C** language
    and does not offer any setup other than embedded. Moreover, SQLite lacks some
    features (for example, it doesn''t support some advanced features of SQL). However,
    due to its robustness and exceptional performance, SQLite is widely used in production
    environments. The most widespread use case is to embed it as part of a client
    application. Many web browsers (such as Firefox and Chrome) and desktop applications
    (such as Adobe Photoshop) are known to use SQLite to store information. It''s
    also widely used in Android applications.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite** ([https://www.sqlite.org/](https://www.sqlite.org/)) 是另一种可嵌入的数据库。与
    H2 相比，它是用 **C** 语言编写的，并且除了嵌入之外不提供任何设置。此外，SQLite 缺少一些功能（例如，它不支持一些 SQL 的高级功能）。然而，由于其稳健性和卓越的性能，SQLite
    在生产环境中得到了广泛的应用。最普遍的使用案例是将它嵌入到客户端应用程序中。许多网络浏览器（如 Firefox 和 Chrome）和桌面应用程序（如 Adobe
    Photoshop）都已知使用 SQLite 存储信息。它也在 Android 应用程序中得到广泛应用。'
- en: Now that we have seen a brief selection of commonly used databases, let's have
    a look at the use cases where it's beneficial to use a relational database and
    when other options would be better.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些常用数据库的简要介绍，让我们来看看使用关系型数据库有益的用例，以及何时其他选项会更好。
- en: Advantages and disadvantages of relational databases
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库的优点和缺点
- en: '**Transactionality** is the key feature of relational databases and is one
    of the advantages of using the technology. While other storage technologies can
    be configured to offer features similar to ACID transactions, if you need to reliably
    store structured data consistently, it''s likely that a relational database is
    your best bet, both from a performance and a functionality standpoint. Moreover,
    through the SQL language, databases offer an expressive way to retrieve, combine,
    and manipulate data, which is critical for many use cases.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务性** 是关系型数据库的关键特性，也是使用该技术的优势之一。虽然其他存储技术可以配置以提供类似 ACID 事务的功能，但如果你需要可靠地持续存储结构化数据，那么从性能和功能的角度来看，关系型数据库可能是你的最佳选择。此外，通过
    SQL 语言，数据库提供了一种表达性强的方式来检索、组合和操作数据，这对于许多用例至关重要。'
- en: Of course, there are downsides too. A database needs a rigid structure to be
    defined upfront for tables, relations, and constraints (that's pretty much essential
    and inherent to the technology). Later changes are of course possible, but they
    can have a lot of side effects (typically in terms of performance and potential
    constraint violations), and for this reason, they are impactful and expensive.
    On the other hand, we will see that alternative technologies (such as NoSQL storage)
    can implement changes in the data structure more easily.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也存在一些缺点。数据库需要事先定义一个刚性的结构来定义表、关系和约束（这在很大程度上是技术和固有的）。后续的更改当然可能发生，但它们可能产生很多副作用（通常在性能和潜在的约束违规方面），因此它们具有影响力和成本。另一方面，我们将看到，替代技术（如
    NoSQL 存储）可以更容易地实现数据结构的更改。
- en: For this reason, a relational database may not be suitable in cases where we
    don't exactly know the shape of the data objects we are going to store. Another
    potential issue is that, given the complexity and rigidity of the technology,
    you may end up with performance and functional issues, which are not always easy
    to troubleshoot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不知道将要存储的数据对象形状的情况下，关系型数据库可能并不适合。另一个潜在问题是，鉴于技术的复杂性和刚性，你可能会遇到性能和功能问题，这些问题并不总是容易排查。
- en: A typical example relates to complex queries. A relational database typically
    uses indexes to achieve better performance (each specific implementation may use
    different techniques, but the core concepts are often the same). Indexes must
    be maintained over time, with operations such as defragmentation and other similar
    ones (depending on each specific database implementation). If we fail to properly
    perform such maintenances, this may end up impacting heavily on the performance.
    And even if our indexes are working correctly, complex queries may still perform
    poorly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子与复杂查询相关。关系型数据库通常使用索引来实现更好的性能（每个特定的实现可能使用不同的技术，但核心概念通常相同）。索引需要随着时间的推移进行维护，包括碎片整理和其他类似操作（取决于每个特定的数据库实现）。如果我们未能正确执行此类维护，这可能会对性能产生严重影响。即使我们的索引工作正常，复杂查询仍然可能表现不佳。
- en: This is because, in most practical implementations, you will need to combine
    and filter data from many different tables (an operation generally known as a
    join). These operations may be interpreted in many different ways by databases
    that will try to optimize the query times but will not guarantee good results
    in every case (especially when many tables and rows are involved).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在大多数实际应用中，你需要从许多不同的表中组合和筛选数据（这种操作通常被称为连接）。数据库可能会以许多不同的方式解释这些操作，试图优化查询时间，但并不能保证在所有情况下都能得到良好的结果（尤其是当涉及许多表和行时）。
- en: Moreover, when doing complex queries, you may end up not correctly using the
    indexes, and small changes in a working query may put you in the same situation.
    For this reason, my suggestion is, in complex application environments, to make
    sure to always double-check your queries in advance with the database administrators,
    who are likely to have tools and experience for identifying potential issues before
    they slip into production environments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在进行复杂查询时，你可能会错误地使用索引，而一个正在运行的查询中的微小变化也可能使你陷入同样的困境。因此，我的建议是在复杂的应用环境中，务必提前与数据库管理员进行双重检查，他们可能拥有工具和经验来识别潜在问题，防止这些问题在生产环境中出现。
- en: As we have seen in this section, relational databases, while not being the most
    modern option, are still a very widespread and useful technology for storing data,
    especially when you have requirements regarding data integrity and structure.
    However, this comes at the cost of needing to define the data structure upfront
    and in having some discipline in the maintenance and usage of the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，虽然关系型数据库不是最现代的选项，但它们仍然是存储数据的一个非常广泛和有用的技术，尤其是在你需要数据完整性和结构要求的情况下。然而，这需要你提前定义数据结构，并在数据库的维护和使用上保持一定的纪律。
- en: You should also consider that, sometimes, relational databases may simply be
    overkill for simple use cases, where you just need simple queries and maybe not
    even persistence. We are going to discuss this scenario in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑，有时，关系型数据库对于简单的用例来说可能过于强大，而你只需要简单的查询，甚至不需要持久化存储。我们将在下一节讨论这种情况。
- en: Introducing key/value stores
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入键/值存储
- en: There are scenarios in which you simply need temporary storage and are going
    to access it in a simple way, such as by a known **unique key**, which will be
    associated with your object. This scenario is the best for key/value stores. Within
    this concept, you can find a lot of different implementations, which usually share
    some common features. The basic one is the **access model** – almost every key/value
    store provides APIs for retrieving data by using a key. This is basically the
    same mechanism as **hash tables** in Java, which guarantee maximum performance.
    Data retrieved in this way can be serialized in many different ways. The most
    basic way, for simple values, is strings, but **Protobuf** is another common choice
    (see [*Chapter 8*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200), *Designing
    Application Integration and Business Automation*, where we discussed this and
    other serialization technologies).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景，你可能只需要临时存储，并以简单的方式访问它，例如通过一个已知的**唯一键**，这将与你的对象相关联。这种场景最适合键/值存储。在这个概念中，你可以找到许多不同的实现，它们通常有一些共同的特征。最基本的是**访问模型**——几乎每个键/值存储都提供了通过键检索数据的API。这基本上与Java中的**哈希表**机制相同，它保证了最佳性能。以这种方式检索到的数据可以以许多不同的方式序列化。对于简单值，最基本的方式是字符串，但**Protobuf**也是一个常见的选择（参见[*第8章*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200)，*设计应用程序集成和业务自动化*，我们在这里讨论了这一点和其他序列化技术）。
- en: A key/value store may not offer persistent storage options, as that is not the
    typical use case. Data is simply kept in memory to be optimized for performance.
    Modern implementations, however, compromise by serializing data on disk or in
    an external store (such as a relational database). This is commonly done asynchronously
    to reduce the impact on access and save times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储可能不提供持久化存储选项，因为这并不是典型的用例。数据只是保存在内存中以优化性能。然而，现代实现通过在磁盘或外部存储（如关系型数据库）上序列化数据来妥协。这通常以异步方式进行，以减少对访问和保存时间的影响。
- en: Whether the technology you are using is providing persistent storage or not,
    there are other features for enhancing the reliability of a system. The most common
    one is based on data replication. Basically, you will have more than one system
    (also called *nodes*) running in a clustered way (meaning that they are talking
    to each other). Such nodes may be running on the same machine or, better yet,
    in different locations (to increase the reliability even more).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的科技是否提供持久存储，都有其他功能可以增强系统的可靠性。最常见的一个是基于数据复制。基本上，你将拥有多个系统（也称为*节点*）以集群方式运行（这意味着它们在相互通信）。这些节点可能运行在同一台机器上，或者更好的是，在不同的位置（以进一步提高可靠性）。
- en: Then, the technology running your key/value store may be configured to propagate
    each change (adding, removing, or modifying data) into a number of different nodes
    (optionally, all of them). In this way, in case of the failure of a node, your
    data will still be present in one or more other nodes. This replication can be
    done synchronously (reducing the possibility of data loss but increasing the latency
    of each write operation) or asynchronously (the other way around).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行你的键/值存储的技术可能被配置为将每个更改（添加、删除或修改数据）传播到多个不同的节点（可选，所有节点）。这样，在节点失败的情况下，你的数据仍然存在于一个或多个其他节点中。这种复制可以是同步的（减少数据丢失的可能性但增加每次写操作的延迟）或异步的（反之亦然）。
- en: In the upcoming sections, we are going to see some common scenarios relating
    to caching data and the life cycle of records stored in the key/value store. Let's
    start looking at some techniques to implement data caching.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到一些与缓存数据和键/值存储中记录的生命周期相关的一些常见场景。让我们先看看实现数据缓存的一些技术。
- en: Data caching techniques
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据缓存技术
- en: A typical use case for key/value stores is **caching**. You can use a cache
    as a centralized location to store disposable data that's quickly accessible from
    your applications. Such data is typically considered disposable because it can
    be retrieved in other ways (such as from a relational database) if the key/value
    store is unavailable or doesn't have the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储的典型用例是**缓存**。你可以使用缓存作为一个集中位置来存储可丢弃的数据，这些数据可以从你的应用程序中快速访问。这种数据通常被认为是可丢弃的，因为如果键/值存储不可用或没有数据，可以通过其他方式（如从关系数据库）检索。
- en: So, in an average case (sometimes referred to as a *cache hit*), you will have
    better performance and will avoid going into other storage (such as relational
    databases), which may be slow, overloaded, or expensive to access. In a worst-case
    scenario (sometimes referred to as a *cache miss*), you will still have other
    ways to access your data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在平均情况下（有时被称为*缓存命中*），你将获得更好的性能，并避免进入其他存储（如关系数据库），这些存储可能较慢、过载或访问成本较高。在最坏的情况下（有时被称为*缓存未命中*），你仍然有其他方式访问你的数据。
- en: 'Some common scenarios are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的场景如下：
- en: '**Cache aside**: The key/value store is considered part of the application,
    which will decide programmatically which data should be stored on it, which data
    will go into persistent storage (such as a database), and how to keep the two
    in sync. This is, of course, the scenario providing the maximum flexibility, but
    it may be complex to manage.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存分离**：键/值存储被认为是应用程序的一部分，它将决定程序化地哪些数据应该存储在其上，哪些数据将进入持久存储（如数据库），以及如何保持两者同步。当然，这是提供最大灵活性的场景，但可能难以管理。'
- en: '**Read-through** and **write-through**: The synchronization between the key/value
    store and the persistent storage is done by the key/value store itself. This can
    be only for read operations (read-through), only for write operations (write-through),
    or for both. What happens from a practical point of view is that the application
    interacts with the key/value store only. Each change in the store is then propagated
    to the persistent storage.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读透**和**写透**：键/值存储与持久存储之间的同步是由键/值存储本身完成的。这可以仅用于读操作（读透），仅用于写操作（写透），或两者都用于。从实际角度来看，应用程序仅与键/值存储交互。存储中的每次更改随后都会传播到持久存储。'
- en: '**Read-behind** and **write-behind**: Basically, this is the same as read-through
    and write-through, but the sync with the persistent storage is not completed immediately
    (it''s asynchronous). Of course, some inconsistency may happen, especially if
    you have other applications accessing the persistent storage directly, which may
    see incorrect or old data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write-around**: In this scenario, your application reads from the key/value
    store (by using a read-through or read-behind approach) and directly writes on
    the persistence store, or maybe other applications perform the write on the persistence
    store. Of course, this scenario can be dangerous, as your application may end
    up reading incorrect things on the key/value store.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This scenario can be managed by notifying the key/value store about any change
    occurring in the persistent storage. This can be done by the application writing
    data, or it can be done directly by the persistent storage (if it is a feature
    provided by the technology) using a pattern known as **change data capture**.
    The key/value store may then decide to update the changed data or simply delete
    it from the cached view (forcing a retrieve from the persistent store when your
    application will look again for the same key).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Another common topic when talking about key/value stores is the life cycle of
    the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Data life cycle
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since they use memory heavily, with huge datasets you may want to avoid having
    everything in memory, especially if the access patterns are identifiable (for
    example, you can foresee with reasonable accuracy which data will be accessed
    by your application). Common patterns for deciding what to keep in memory and
    what to delete are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Least recently used**: The system keeps track of the time of last access
    for each record and ditches the records that haven''t been accessed for a set
    amount of time.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tenure**: A variant of the previous scenario that simply uses the creation
    time instead of the last access time.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least frequently used**: The system keeps a count of how many times a record
    is accessed and then, when it needs to free up some memory, it will delete the
    least accessed records.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most recently used**: The opposite of least recently used, this deletes the
    most recently accessed records. This can be particularly useful in some scenarios,
    such as when it''s unlikely that the same key will be accessed twice in a short
    amount of time.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key/value stores lack a standard language, such as SQL. It's also for this reason
    that key/value stores are a big family, including many different products and
    libraries, often offering more features than just key/value management. In the
    next section, we are going to see a few of the most famous implementations of
    key/value stores.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used implementations of key/value stores
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously mentioned, it''s not easy to build a list of key/value store
    technology implementations. As we will see in the next few sections, this way
    of operating a database is considered to be a subcategory of a bigger family of
    storage systems, called NoSQL databases, offering more options and alternatives
    than just key/value storage. However, for the purpose of this section, let''s
    see a list of what is commonly used in terms of key/value stores:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** is likely the most famous key/value store currently available. It''s
    open source, and one of the reasons for its success is that, despite offering
    a lot of advanced features and tunings, it just works well enough in its default
    setting, making adopting it very easy. It provides client libraries for almost
    every language, including Java. It offers a lot of advanced features, such as
    clustering, transactions, and embedded scripting (using the **Lua language**).
    It can operate on in-memory only, or persist the data on the filesystem using
    a configurable approach in order to balance performance impact and reliability.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle Coherence** is a widely used commercial key/value storage. It''s particularly
    used in conjunction with other Oracle products, in particular with the database.
    It offers a wide range of features, including a complete set of APIs and a custom
    query language. Since 2020, a community edition of Coherence is available as open
    source software.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memcached** is a simple key/value store that is light and easy to operate.
    However, it lacks some features, such as persistence. Moreover, it provides only
    the cache-aside use case, so other scenarios must be implemented manually.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinispan** is an open source key/value store that provides features such
    as persistence, events, querying, and caching. It''s worth noting that Infinispan
    can be used both in an embedded and a client/server setup. In the embedded setup,
    Infinispan is part of the **WildFly JEE application server**, providing caching
    services to Java Enterprise applications.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen some widespread key/value stores, let's see when they
    are a good fit and when they are not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of key/value stores
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important advantage of key/value stores is the performance. The access
    time can be incredibly fast, especially when used without any persistent storage
    (in-memory only). This makes them particularly suitable for low-latency applications.
    Another advantage is simplicity, both from an architectural and a usage point
    of view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Architecturally speaking, if your use case doesn't require clustering and other
    complex settings, a key/value store can be as simple as a single application exposing
    an API to retrieve and store records. From a usage point of view, most use cases
    can be implemented with primitives as simple as `get`, `put`, and `delete`. However,
    some of these points can become limitations of key/value stores, especially when
    you have different requirements. If your application needs to be reliable (as
    in losing as little data as possible when there's a failure), you may end up with
    complex multi-node setups and persistence techniques. This may, in turn, mean
    that in some cases, you can have inconsistency in data that may need to be managed
    from an application point of view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Another common issue is that, usually, data is not structured in key/value stores.
    This means that it is only possible to retrieve data searching by key (or at least,
    that's the most appropriate scenario). While some implementations allow it, it
    can be hard, performance-intensive, or in some cases impossible to retrieve data
    with complex queries on the object values, in contrast with what you can do with
    SQL in relational databases.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the basics of data caching and key/value stores.
    Such techniques are increasingly used in enterprise environments, for both their
    positive impact on performances and their scalability, which fit well with cloud-native
    architectures. Topics such as data caching techniques and the life cycles of objects
    are common considerations to be made when adopting key/value stores.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Key/value stores are considered to be part of a broader family of storage technologies
    that are alternatives to relational databases, called NoSQL. In the next section,
    we will go into more detail about this technology.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Exploring NoSQL repositories
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL is an umbrella term comprising a number of very different data storage
    technologies. The term was coined mostly for marketing purposes in order to distinguish
    them from relational databases. Some NoSQL databases even support SQL-like query
    languages. NoSQL databases claim to outdo relational databases in terms of performance.
    However, this assurance only exists because of some compromises, namely the lack
    of some features, usually in terms of transactionality and reliability. But to
    discuss these limitations, it is worth having an overview of the CAP theorem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The CAP theorem
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **CAP theorem** was theorized by Eric Brewer in 1998 and formally proven
    valid in 2002 by Seth Gilbert and Nancy Lynch. It refers to a distributed data
    store, regardless of the underlying technology, so it's also applicable to relational
    databases when instantiated in a multi-server setup (so, running in two or more
    different processes, communicating through a network, for clustering and high-availability
    purposes). The theorem focuses on the concept of a *network split*, when the system
    becomes partitioned into two (or more) subsets that are unable to communicate
    with each other due to connectivity loss.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The CAP theorem describes three core characteristics of distributed data stores:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency** refers to keeping the stored data complete, updated, and formally
    correct.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability** refers to providing access to all the functionalities of the
    data store, especially the reads and writes of the data itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition tolerance** refers to the system functioning correctly, even in
    a case of network failure between servers.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CAP theorem states that, when a partition occurs, you can only preserve
    consistency or availability. While a mathematical explanation is available (and
    beyond the scope of this book), the underlying idea can be understood easily:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If a system preserves availability, it may be that two conflicting operations
    (such as two writes with two different values) arrive in two different partitions
    of the system (such as two servers, unable to communicate between each other).
    With availability in mind, both servers will accept the operation, and the end
    result will be data being inconsistent.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a system preserves consistency, in case of a network split, it cannot accept
    operations that will change the status of the data (to avoid the risk of conflicts
    damaging the data consistency); hence, it will sacrifice availability.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it's worth noticing that this theorem, while being the basis for understanding
    the distributed data store limits, must be considered and contextualized in each
    particular scenario. In many enterprise contexts, it is possible to make the event
    of a network split extremely unlikely (for example, by providing multiple network
    connections between each server).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it's common to have mechanisms to elect a primary partition when there's
    a network split. This basically means that if you are able to define which part
    of the cluster is primary (typically, the one with the greater number of survival
    nodes, and this is why it's usually recommended to have an odd number of nodes),
    this partition can keep working as usual, while the remaining partition can shut
    down or switch to a degraded mode (such as read-only). So, basically, it's crucial
    to understand the basics of the CAP theorem, but it's also important to understand
    that there are a number of ways to work around the consequences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the reasoning behind NoSQL databases. These databases shift
    their point of view, *stretching* a bit over the CAP capabilities. This means
    that, while traditional relational databases focus on consistency and availability,
    they are often unreliable to operate in a heavily distributed fashion. Conversely,
    NoSQL databases can operate better in horizontally distributed architectures,
    favoring scalability, throughput, and performance at the expense of availability
    (as we saw, becoming read-only when there are network partitions) or consistency
    (not providing ACID transaction capabilities).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: And this brings us to another common point of NoSQL stores – the **eventual
    consistency**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, most NoSQL stores, while not providing full transactionality (compared
    to relational databases) can still offer some data integrity by using the pattern
    of eventual consistency. Digging into the details and impacts of this pattern
    would require a lot of time. For the sake of this section, it's sufficient to
    consider that a system implementing eventual consistency may have some periods
    of time in which data is not coherent (in particular, enquiring for the same data
    on two different nodes can lead to two different results).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: With that said, it's usually possible to tune a NoSQL store in order to preserve
    consistency and provide full transactionality as a traditional relational database
    does. But in my personal experience, the impacts in terms of reduced performance
    and availability are not a worthwhile compromise. In other words, if you are looking
    for transactionality and data consistency, it's usually better to rely on relational
    databases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let's have an overview of the different NoSQL database categories.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database categories
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed in the previous sections, NoSQL is an umbrella term. There
    are a number of different categories of NoSQL stores:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Key/value stores**: This is the easiest one, as we have already discussed
    the characteristics of this technology. As should be clear by now, key/value stores
    share some core characteristics with NoSQL databases – they are generally designed
    to be horizontally scalable, to focus on performance over transactionality, and
    to lack full SQL compliance.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document stores**: This is one of the most widespread categories of NoSQL
    databases. The core concept of a document store is that instead of rows, it stores
    documents, serialized into various formats (commonly JSON and XML). This often
    gives the flexibility of storing documents with a different set of fields or,
    in other words, it avoids defining a strict schema in advance for the data we
    are going to store. Documents then can be searched by their contents. Some notable
    examples of document stores include MongoDB, Couchbase, and Elasticsearch.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph databases**: This category of stores is modeled around the concept
    of a graph. It provides storage and querying capabilities optimized around graph
    concepts, such as nodes and vertex. In this way, concepts such as roads, links,
    and social relationships can be modeled, stored, and retrieved easily and efficiently.
    A famous implementation of a graph database is **Neo4j**.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide-column databases**: These stores are similar to relational databases,
    except that in a table, each row can have a different set of fields in terms of
    the number, name, and type of each one. Two known implementations of wide-column
    databases are Apache Cassandra and Apache Accumulo.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, as you can imagine, there is a lot more to say about NoSQL databases.
    I hope the pointers I gave in this section will help you quickly understand the
    major features of NoSQL databases, and I hope one of the examples I've provided
    will be useful for your software architecture. In the next section, we are going
    to have a look at filesystem storage.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Looking at filesystem storage
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Filesystems** are a bit of a borderline concept when it comes to data storage
    systems. To be clear, filesystem storage is a barely structured system providing
    APIs, schemas, and advanced features, like the other storage systems that we have
    seen so far. However, it is still a very relevant layer in many applications,
    and there are some new storage infrastructures that provide advanced features,
    so I think it''s worth having a quick overview of some core concepts.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem storage should not be an alien concept to most of us. It is a persistent
    storage system backed by specific hardware (spinning or solid-state disks). There
    are many different filesystems, which can be considered the protocol used to abstract
    the read and write operations from and to such specific hardware. Other than creating,
    updating, and deleting files, and the arrangement of these files into folders,
    filesystems can provide other advanced features, such as journaling (to reduce
    the risk of data corruption) and locking (in order to provide exclusive access
    to files).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Some common filesystems are the **New Technology File System** (**NTFS**) (used
    in Windows environments) and the **Extended File System** (**ext**) (used in Linux
    environments). However, these filesystems are designed for working on a single
    machine. A more important concept relates to the filesystems that allow interactions
    between different systems. One such widespread implementation is networked filesystems,
    which is a family of filesystem protocols providing access to files and directories
    over a network. The most notable example here is NFS, which is a protocol that
    provides multi-server access to a shared filesystem. The **File Transfer Protocol**
    (**FTP**) and the **SSH File Transfer Protocol** (**SFTP**) are other famous examples,
    and even if they are outdated, they are still widely used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: A recent addition to the family of network storage systems is **Amazon S3**.
    While it's technically an object filesystem, it's a way to interact with Amazon
    facilities using APIs in order to store and retrieve files. It started as a proprietary
    implementation for providing filesystem services on AWS infrastructure over the
    internet; since then, S3 has become a standard, and there are a lot of other implementations,
    both open source and commercial, aiming to provide S3-compliant storage on-premises
    and in the cloud.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and disadvantages of filesystems
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's hard to talk about the disadvantages of filesystems because they are an
    essential requirement in every application, and it will stay like this for a long
    time. However, it's important to contextualize and think logically about the pros
    and cons of filesystems to better understand where to use them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Application interaction over shared filesystems is particularly convenient when
    it comes to exchanging large amounts of data. In banking systems (especially legacy
    ones), it's common to exchange large numbers of operations (such as payments)
    to be performed in batches, in the form of huge `.csv` files. The advantage is
    that the files can be safely chunked, signed, and efficiently transferred over
    a network.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, filesystems don't usually offer native indexing and full-text
    search, so these capabilities must be implemented on top. Moreover, filesystems
    (especially networked filesystems) can perform badly, especially when it comes
    to concurrent access and the locking of files.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: With this section, we have completed our overview of storage systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to see how, in modern architecture, it is
    common to use more than one storage solution to address different use cases with
    the most suitable technology.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Modern approaches – a multi-tier storage strategy
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final section of the chapter, we'll be exploring a concept that may seem
    obvious, but it's still worth mentioning. **Modern architecture** tends to use
    multiple data storage solutions, and I think that this could be a particularly
    interesting solution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In the past, it was common to start by defining a persistence strategy (typically
    on a relational database or on another legacy persistence system) and build the
    application functionalities around it. This is no longer the case. Cloud-native
    technologies, through microservices, developed the idea that each microservice
    should own its own data, and we can extend this concept in that each microservice
    could choose its own persistent storage technology. This is better suited for
    the particular characteristics of that business domain and the related use cases.
    Some services may need to focus on performance, while others will have a strong
    need for transactionality and data consistency.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even if you are dealing with a less innovative architecture, it''s
    still worthwhile evaluating different ideas around data persistence solutions.
    Here are some discussion points about it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases are your best bet when data is structured upfront and such
    a structure doesn't change very often. Moreover, if you will need ACID-compliant
    transactions, relational databases are generally the most performant solution.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key/value stores, especially in their in-memory setup, are useful in a number
    of use cases. The more common scenarios include the storage of user sessions,
    which will demand high performance (as it's related to web and mobile use cases,
    where there is heavy user interaction and high expectation in terms of availability)
    and consistency/reliability is less of an issue (in a worst-case scenario, the
    user will be logged out and will need to log in again). Another widely used scenario
    is database offloading – implementing some of the described scenarios (read-through,
    write-through, and so on) where cached entries will boost the overall performance
    and reduce the load on the database.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases can be used for scenarios particularly suited to the specific
    technology of choice. In particular, if some entities in our architecture have
    a variable or unstructured representation, they can be suitable for document repositories.
    Graph databases can be useful for other scenarios in which algorithms on graphs
    are needed (such as the shortest path calculation).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As previously mentioned, filesystems are almost always a fundamental infrastructure.
    They may be needed by some middleware (such as message brokers) for writing journals,
    and they can be used explicitly by an application as a data exchange area for
    large amounts of information (especially when dealing with legacy systems).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, once again, choosing the right data storage technology can be crucial to
    have a performant and well-written application, and it's a common practice to
    rely on more than one technology to meet the different needs that different parts
    of our application will require.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen an overview of different possibilities on the
    data layer, ranging from traditional SQL databases to more modern alternatives.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: While most of us are already familiar with relational databases, we have had
    a useful examination of the pros and cons of using this technology. We then broadened
    our view with alternative, widespread storage technologies, such as key/value
    stores, NoSQL, and even filesystems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, we looked at how the choice of a particular way of storing data
    may affect both the application design and the performance of our system. Indeed,
    in modern architecture, we may want to pick the right storage solution for each
    use case by choosing different solutions where needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss some architectural cross-cutting
    concerns. Topics such as security, resilience, usability, and observability are
    crucial to successful application architecture and will be analyzed to see their
    impacts and best practices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Database Systems: Concepts, Languages, & Architectures*, by Paolo Atzeni,
    Stefano Ceri, Stefano Paraboschi, and Riccardo Torlone'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Relational Databases 101: Looking at the Whole Picture*, by Scott W. Ambler
    ([http://www.agiledata.org/essays/relationalDatabases.html](http://www.agiledata.org/essays/relationalDatabases.html))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL database list – Edlich ([https://hostingdata.co.uk/nosql-database/](https://hostingdata.co.uk/nosql-database/))
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making Sense of NoSQL: A guide for managers and the rest of us*, by Dan McCreary
    and Ann Kelly'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
