- en: 'Chapter 11: Dealing with Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：处理数据
- en: You should know that no matter what your application does, you will end up dealing
    with persistence sooner or later. Whether it's a payment, a post on social media,
    or anything else, information has no value if it's not stored, retrieved, aggregated,
    modified, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，无论你的应用程序做什么，你最终都会迟早处理持久性问题。无论是支付、社交媒体上的帖子还是其他任何事情，如果信息没有被存储、检索、聚合、修改等，那么信息就没有价值。
- en: For this reason, data is very much a point of concern when designing an application.
    The wrong modeling (as we saw in [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089),
    *Best Practices for Design and Development*, when talking about **Domain-Driven
    Development**) can lead to a weak application, which will be hard to develop and
    maintain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计应用程序时，数据是一个非常值得关注的点。错误的建模（正如我们在[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)，*设计和开发最佳实践*，在讨论**领域驱动开发**时所见）可能导致一个弱化的应用程序，这将很难开发和维护。
- en: In this chapter, we are taking data modeling a step further and discussing the
    ways your objects and values can be stored (also known as *data at rest*, as opposed
    to *data in motion*, where objects are still being actively manipulated by your
    application code).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨数据建模，讨论你的对象和值可以存储的方式（也称为*静态数据*，与*动态数据*相对，其中对象仍然被你的应用程序代码积极操作）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring relational databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关系数据库
- en: Introducing key/value stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍键/值存储
- en: Exploring NoSQL repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索NoSQL存储库
- en: Looking at filesystem storage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看文件系统存储
- en: Modern approaches – a multi-tier storage strategy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代方法 - 多层存储策略
- en: As we have seen with many topics in this book so far, data persistence has also
    evolved a lot. Similar to what happened to the software development models and
    the **Java Enterprise Edition** (**JEE**) framework, when we deal with data, we
    also have a lot of different options to implement in several use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书迄今为止的许多主题中看到的那样，数据持久性也发生了很大的变化。类似于软件开发模型和**Java企业版**（**JEE**）框架所发生的情况，当我们处理数据时，我们也有许多不同的选项来实现多个用例。
- en: However, just as we have seen elsewhere (namely, in JEE applications versus
    cloud-native alternatives), the old ways have not been abandoned (because they
    are still relevant in some cases); instead, they are being complemented by more
    modern approaches that are suited for other use cases. And this is exactly what
    happened with the first technology that we are going to discuss – relational databases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在其他地方看到的那样（即在JEE应用程序与云原生替代方案之间），旧的方法并没有被放弃（因为它们在某些情况下仍然相关）；相反，它们正被更适合其他用例的更现代的方法所补充。这正是我们将要讨论的第一项技术——关系数据库。
- en: Exploring relational databases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索关系数据库
- en: '**Relational databases** are hardly a new idea. The idea was first introduced
    by Edgar F. Codd in 1970\. Omitting the mathematical concepts behind it (for brevity),
    it says that data in a relational database is, as everybody knows, arranged into
    *tables* (we had a quick look at this in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*, in the *Persistence* section).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据库**几乎不是一个新概念。这个想法最初由Edgar F. Codd在1970年提出。为了简洁起见，省略了其背后的数学概念，它说关系数据库中的数据，正如众所周知，是按*表格*（我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)，*探索中间件和框架*，*持久性*部分中快速浏览过）排列的。'
- en: Roughly speaking, each table can be seen as one of the objects in our business
    model, with the columns mapping to the object fields and the rows (also known
    as *records*) representing the different object instances.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，每个表格都可以看作是我们业务模型中的一个对象，列映射到对象字段，行（也称为*记录*）代表不同的对象实例。
- en: In the following sections, we are going to review the basics of relational databases,
    starting with keys and relationships, the concept of transactionality, and stored
    procedures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将回顾关系数据库的基本知识，从键和关系、事务性概念和存储过程开始。
- en: Keys and relationships
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键和关系
- en: Depending on the database technology, it's a common idea to have a way to identify
    each row. This is commonly done by identifying a field (or a set of fields) that
    is unique to each record. This is the concept of a **primary key**. Primary keys
    can be considered a constraint, meaning that they represent some rules with which
    the data inserted into the table must comply. Those rules need to be maintained
    for the table (and its records) to stay in a valid state (in this case, by having
    each record associated with a unique ID). However, other constraints are usually
    implemented in a relational database. Depending on the specific technology of
    the database system, these constraints may be really complex validation formulas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库技术，有一个识别每行的方法是常见的想法。这通常是通过识别一个（或一组）对每个记录都是唯一的字段来完成的。这就是**主键**的概念。主键可以被视为一种约束，意味着它们代表了一些规则，数据插入到表中必须遵守这些规则。这些规则需要得到维护，以便表（及其记录）保持有效状态（在这种情况下，通过每个记录关联一个唯一的ID）。然而，通常在关系型数据库中还会实现其他约束。根据数据库系统的具体技术，这些约束可能非常复杂。
- en: 'Another core concept of the database world is the concept of **relations**.
    This is, as you can imagine, a way to model links between different objects (similar
    to what happens in the world of **Object-Oriented Programming** (**OOP**), where
    an object can contain references to other objects). The relations can fall into
    one of the following three cardinalities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库世界的另一个核心概念是**关系**的概念。正如您可以想象的，这是一种建模不同对象之间链接的方式（类似于在**面向对象编程**（OOP）的世界中发生的情况，其中对象可以包含对其他对象的引用）。关系可以落入以下三种基数之一：
- en: A **one-to-one** relationship represents a mapping of each record to one, and
    only one, record from another table. This is usually referring to a relationship
    in which each row points to a row containing further information, such as a user
    record pointing to a row representing the user's living address in another table.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**关系表示每个记录映射到另一个表中的一个且仅有一个记录。这通常指的是一种关系，其中每一行指向包含更多信息的另一行，例如用户记录指向另一个表中代表用户居住地址的行。'
- en: A **one-to-many** relationship is where we model a relation in which each record
    maps to a set of records in another table. In this case, the relation between
    the two tables is unbalanced. One record in a table refers to a set of related
    records in another table, while the reverse is not valid (each record maps to
    one and only one record in the source table). A practical example is a user versus
    payment relationship. Each user is associated with one or more payments, while
    each payment is linked to only one user.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**关系是我们对一个关系进行建模，其中每个记录映射到另一个表中的一组记录。在这种情况下，两个表之间的关系是不平衡的。一个表中的一条记录指向另一个表中的一组相关记录，而反过来则不成立（每个记录映射到源表中的一个且仅有一个记录）。一个实际的例子是用户与支付的关系。每个用户关联一个或多个支付，而每个支付只关联一个用户。'
- en: A **many-to-many** relationship is the last option. Basically, in this case,
    multiple rows from a table can relate to multiple rows in the related tables,
    and vice versa. An example of this kind of relationship is movies and actors.
    A record in a movie table will link to more than one row in the actor table (implementing
    the relation of actors starring in a movie). And the reverse is true – a row in
    the actor table will link to many records in the movie table, as each actor will
    most likely be part of more than one movie.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**关系是最后一个选项。基本上，在这种情况下，一个表中的多行可以与相关表中的多行相关联，反之亦然。这种关系的一个例子是电影和演员。电影表中的一条记录将链接到演员表中的多行（实现演员在电影中的关系）。反之亦然——演员表中的一行将链接到电影表中的多条记录，因为每个演员很可能参与多部电影。'
- en: 'Here is a diagram of the three types of relationship cardinalities:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是三种关系基数类型的图示：
- en: '![Figure 11.1 – Table relationships'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 表关系'
- en: '](img/Figure_11.1_B16354.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16354.jpg)'
- en: Figure 11.1 – Table relationships
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 表关系
- en: 'As you can see in the preceding diagram, there is a graphical representation
    of three examples of relationships:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到的，有三个关系示例的图形表示：
- en: '**One to One**, as in a person with address – each person can have just one
    primary home address.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**，例如一个人与地址的关系——每个人只能有一个主要家庭地址。'
- en: '**One to Many**, as in a person with transactions – each person can be associated
    with more than one payment transaction.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**，例如一个人与交易的关系——每个人可以与多个支付交易相关联。'
- en: '**Many to Many**, as in people with devices – each person can have many devices,
    and a device can be used by more than one person.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**，例如人与设备的关系——每个人可以有多个设备，一个设备也可以被多个人使用。'
- en: 'These relationships are nothing new; the same is true for Java objects, with
    which you can model the same kinds of relationship:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系并不新鲜；对于Java对象来说也是如此，你可以用它们来模拟相同类型的关系：
- en: A class can be linked one-to-one with another one, by having a field of it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过包含它的字段，与另一个类一对一地链接。
- en: A class can be linked in a one-to-many scenario by having a field containing
    a list (or a set) of objects of the target class type.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过包含一个包含目标类类型对象列表（或集合）的字段，在一对一场景中与其他类链接。
- en: A class can implement a many-to-many scenario by extending the previous scenario
    and having the target class type with a field containing a list (or set) of objects
    of the source class type (hence linking back and forth).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以通过扩展之前的场景，并让目标类类型包含一个包含源类类型对象列表（或集合）的字段来实现多对多场景（因此可以双向链接）。
- en: All of those models can then be propagated into SQL databases, and this is indeed
    done by JPA, which we introduced in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模型都可以传播到SQL数据库中，这确实是通过JPA实现的，我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)，“探索中间件和框架”中介绍了JPA。
- en: It used to be common (and it still happens in some cases) to define the domain
    model of an application, starting with the design of the database that will store
    the data. It's quite a simplistic approach since it cannot easily model every
    aspect of object-oriented applications (such as inheritance, interfaces, and many
    other constructs), but it works for some simple scenarios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以前（在某些情况下仍然如此）通常从设计将存储数据的数据库开始，定义应用程序的领域模型。这是一个相当简单的方法，因为它不能轻松地模拟面向对象应用程序的每个方面（如继承、接口和许多其他结构），但对于一些简单场景来说它是有效的。
- en: Transactionality
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务性
- en: 'One of the more interesting (and widely used) capabilities of a relational
    database is related to **transactionality**. Transactionality refers to a set
    of characteristics of relational databases that are the basis for maintaining
    data integrity (especially in the case of failures). These characteristics are
    united under the **ACID** acronym (which stands for **Atomicity**, **Consistency**,
    **Isolation**, and **Durability**):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的一个更有趣（并且广泛使用）的功能与**事务性**相关。事务性指的是关系型数据库的某些特性，这些特性是维护数据完整性的基础（尤其是在出现故障的情况下）。这些特性在**ACID**缩写词下统一起来（代表**原子性**、**一致性**、**隔离性**和**持久性**）：
- en: '**Atomicity**: Each transaction (which is typically a set of different operations,
    such as the creation, modification, or deletion of records in one or more tables)
    is treated as a single unit; it will be successful as a whole, or it will fail
    completely (leaving all the tables as they were before the transaction started).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：每个事务（通常是一组不同的操作，如在一个或多个表中创建、修改或删除记录）被视为一个单一单元；它要么整体成功，要么完全失败（使所有表保持事务开始之前的状态）。'
- en: '**Consistency**: Each transaction can only change the database into a valid
    state by maintaining all the existing constraints (such as primary keys).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：每个事务只能通过维护所有现有约束（如主键）来将数据库更改为有效状态。'
- en: '**Isolation**: The concurrent transactions must be executed correctly with
    no interference from other transactions. This basically means that the final effect
    of a number of transactions executed in parallel should be the same as the same
    transactions being executed sequentially.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：并发事务必须在没有其他事务干扰的情况下正确执行。这基本上意味着并行执行的一系列事务的最终效果应该与这些事务顺序执行的效果相同。'
- en: '**Durability**: This simply refers to the guarantee that a persisted transaction
    will be maintained (and can be retrieved) after a failure of the database system.
    In other words, the database should persist the data into non-volatile storage
    (a disk or similar technology).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这简单指的是在数据库系统失败后，持久化的事务将被保持（并且可以检索）。换句话说，数据库应该将数据持久化到非易失性存储（磁盘或类似技术）。'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Consider that the concept of transactionality is usually not very well suited
    to heavily distributed environments, such as microservices and cloud-native architecture.
    We will discuss this more in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到事务性的概念通常不适合高度分布的环境，如微服务和云原生架构。我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*中进一步讨论这个问题。
- en: Last but not least, many different technologies allow us to execute custom code
    directly on the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，许多不同的技术允许我们在数据库上直接执行自定义代码。
- en: Stored procedures
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过程
- en: Many widely used databases can run complex programs. There is no standard for
    this kind of feature, even if the languages that are often used are similar to
    extensions of SQL, including conditions, loops, and similar statements. Occasionally,
    some general-purpose languages (such as **Java** and **.NET**) are available on
    some database systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多广泛使用的数据库可以运行复杂的程序。这类功能没有标准，即使常用的语言类似于SQL的扩展，包括条件、循环和类似语句。偶尔，一些通用语言（如**Java**和**.NET**）在某些数据库系统中可用。
- en: The reason for storing code in a database is mainly data locality. By executing
    code in a database, the system has complete control over execution and transactional
    behavior (such as locking mechanisms); hence, you may end up getting very good
    performance. This may be particularly useful if you are doing batch operations
    and calculations on a large amount of data. But if you ask me, the advantages
    stop here and are not very worthwhile anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码存储在数据库中的原因主要是数据局部性。通过在数据库中执行代码，系统对执行和事务行为（如锁定机制）有完全的控制；因此，你可能会获得非常好的性能。这在进行大量数据的批量操作和计算时可能特别有用。但如果你问我，优势就到这里为止，而且并不非常值得。
- en: When using stored procedures on a database system, you will observe small performance
    improvements, but the overall solution will be ugly from an architectural point
    of view and hard to maintain. Putting business logic in the data layer is never
    a good idea from a design point of view, and using special, procedural languages
    (such as the ones often available on such platforms) can only make things worse.
    Moreover, such languages are almost always impossible to port from one database
    system to another, hence strongly coupling your application with a specific technology
    and making it hard to change technology if needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据库系统上使用存储过程时，你会观察到轻微的性能提升，但从架构角度来看，整体解决方案将显得很糟糕，并且难以维护。从设计角度来看，将业务逻辑放在数据层从来都不是一个好主意，而使用特殊的过程性语言（如这些平台通常可用的语言）只会使问题变得更糟。此外，这类语言几乎总是无法从一个数据库系统移植到另一个数据库系统，因此会强烈地将应用程序与特定技术耦合在一起，使得在需要时更改技术变得困难。
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unless it's really needed, I advise avoiding stored procedures at all costs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是真的需要，我强烈建议不惜一切代价避免使用存储过程。
- en: Now that we have seen a summary of the basic features, let's see the commonly
    used implementations of relational databases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了基本功能的概述，让我们看看关系型数据库的常用实现。
- en: Commonly used implementations of relation databases
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用的关系型数据库实现
- en: 'Let''s quickly discuss some commonly used products that provide the relational
    database features we have seen so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论一些提供我们之前看到的关系型数据库功能的常用产品：
- en: We cannot talk about relational databases without mentioning **Oracle** ([https://www.oracle.com/database/](https://www.oracle.com/database/)).
    The name of this vendor has become synonymous with databases. They provide many
    variants, including versions with clustering and embedded caching. This database
    is considered a de facto standard in many enterprises, and most commercially available
    software packages are compatible with Oracle databases. Oracle databases support
    Java and PL/SQL (a proprietary language) as ways to define stored procedures.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在谈论关系型数据库时，不能不提**Oracle** ([https://www.oracle.com/database/](https://www.oracle.com/database/))。这个供应商的名字已经成为数据库的同义词。他们提供了许多变体，包括具有集群和嵌入式缓存的版本。这个数据库在许多企业中被视为事实上的标准，并且大多数商业软件包都与Oracle数据库兼容。Oracle数据库支持Java和PL/SQL（一种专有语言）作为定义存储过程的方式。
- en: '**Microsoft SQL Server** ([https://www.microsoft.com/sql-server/](https://www.microsoft.com/sql-server/))
    is another widely used database server. It became popular for its complete features
    and proximity with the Microsoft ecosystem, as many widespread Microsoft applications
    use it. It also offers extensions for running .NET languages as part of stored
    procedures. It''s worth noting that for a couple of years, SQL Server has also
    been supported on Linux servers, widening the use cases for SQL Server, especially
    in cloud environments.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft SQL Server** ([https://www.microsoft.com/sql-server/](https://www.microsoft.com/sql-server/))
    是另一种广泛使用的数据库服务器。由于其完整的功能和与微软生态系统的紧密联系，以及许多广泛使用的微软应用程序都使用它，因此它变得非常流行。它还提供了扩展功能，可以在存储过程中运行
    .NET 语言。值得注意的是，在过去的几年里，SQL Server 也开始支持 Linux 服务器，这扩大了 SQL Server 的使用场景，尤其是在云环境中。'
- en: '**MySQL** ([https://www.mysql.com/](https://www.mysql.com/)) is another widely
    used database technology. It''s one of the first examples of an open source database
    and provides advanced features comparable to commercial databases. After the MySQL
    project was acquired by Oracle, a couple of forks have been created in order to
    keep the project autonomous. The most important fork currently available is called
    **MariaDB**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL** ([https://www.mysql.com/](https://www.mysql.com/)) 是另一种广泛使用的数据库技术。它是开源数据库的早期例子之一，并提供了与商业数据库相媲美的先进功能。在
    MySQL 项目被甲骨文公司收购后，为了保持项目独立，已经创建了几个分支。目前可用的最重要的分支被称为 **MariaDB**。'
- en: '**PostgreSQL** ([https://www.postgresql.org/](https://www.postgresql.org/))
    is another open source relational database and has been available for a very long
    time (it was released shortly after the first release of MySQL). In contrast with
    MySQL, however, it''s still independent, meaning that it hasn''t been acquired
    by a major software vendor. For this reason and because of the completeness of
    its features, it is still a widely used option in many setups. Also, it''s worth
    noting that many different third-party vendors provide commercial support and
    extensions to cover some specific use cases (such as clustering and monitoring).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL** ([https://www.postgresql.org/](https://www.postgresql.org/))
    是另一种开源的关系型数据库，并且已经存在很长时间（它在 MySQL 首次发布后不久就发布了）。然而，与 MySQL 相比，它仍然是独立的，这意味着它没有被主要软件供应商收购。因此，由于它的功能完整，它仍然是许多设置中广泛使用的选项。此外，值得注意的是，许多不同的第三方供应商提供商业支持和扩展，以覆盖一些特定的用例（如集群和监控）。'
- en: '`.jar` file, it''s easy to use it in an *in-memory* setup as part of the development
    process of Java applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jar` 文件，在 Java 应用程序的开发过程中，作为内存设置的一部分使用它非常容易。'
- en: This includes scenarios such as embedding the database as part of a development
    pipeline or a Maven task, when it can be programmatically destroyed, created,
    and launched any time you want. This makes it particularly useful in testing scenarios.
    Despite more complex setups being available (such as client servers), H2 is usually
    considered unsuitable for production usage. The most common use case, other than
    testing and development, is to ship it embedded with applications in order to
    provide a demo mode when an application is first started, suggesting that a different
    database should be set up and used before going into production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括将数据库嵌入到开发管道或 Maven 任务中作为一部分的场景，当它可以在需要时程序化地销毁、创建和启动。这使得它在测试场景中特别有用。尽管有更复杂的设置（如客户端服务器），H2
    通常被认为不适合生产使用。除了测试和开发之外，最常见的用途是将它嵌入到应用程序中，以便在应用程序首次启动时提供演示模式，建议在进入生产之前设置并使用不同的数据库。
- en: '**SQLite** ([https://www.sqlite.org/](https://www.sqlite.org/)) is another
    type of embeddable database. In contrast with H2, it''s written in the **C** language
    and does not offer any setup other than embedded. Moreover, SQLite lacks some
    features (for example, it doesn''t support some advanced features of SQL). However,
    due to its robustness and exceptional performance, SQLite is widely used in production
    environments. The most widespread use case is to embed it as part of a client
    application. Many web browsers (such as Firefox and Chrome) and desktop applications
    (such as Adobe Photoshop) are known to use SQLite to store information. It''s
    also widely used in Android applications.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite** ([https://www.sqlite.org/](https://www.sqlite.org/)) 是另一种可嵌入的数据库。与
    H2 相比，它是用 **C** 语言编写的，并且除了嵌入之外不提供任何设置。此外，SQLite 缺少一些功能（例如，它不支持一些 SQL 的高级功能）。然而，由于其稳健性和卓越的性能，SQLite
    在生产环境中得到了广泛的应用。最普遍的使用案例是将它嵌入到客户端应用程序中。许多网络浏览器（如 Firefox 和 Chrome）和桌面应用程序（如 Adobe
    Photoshop）都已知使用 SQLite 存储信息。它也在 Android 应用程序中得到广泛应用。'
- en: Now that we have seen a brief selection of commonly used databases, let's have
    a look at the use cases where it's beneficial to use a relational database and
    when other options would be better.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些常用数据库的简要介绍，让我们来看看使用关系型数据库有益的用例，以及何时其他选项会更好。
- en: Advantages and disadvantages of relational databases
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库的优点和缺点
- en: '**Transactionality** is the key feature of relational databases and is one
    of the advantages of using the technology. While other storage technologies can
    be configured to offer features similar to ACID transactions, if you need to reliably
    store structured data consistently, it''s likely that a relational database is
    your best bet, both from a performance and a functionality standpoint. Moreover,
    through the SQL language, databases offer an expressive way to retrieve, combine,
    and manipulate data, which is critical for many use cases.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务性** 是关系型数据库的关键特性，也是使用该技术的优势之一。虽然其他存储技术可以配置以提供类似 ACID 事务的功能，但如果你需要可靠地持续存储结构化数据，那么从性能和功能的角度来看，关系型数据库可能是你的最佳选择。此外，通过
    SQL 语言，数据库提供了一种表达性强的方式来检索、组合和操作数据，这对于许多用例至关重要。'
- en: Of course, there are downsides too. A database needs a rigid structure to be
    defined upfront for tables, relations, and constraints (that's pretty much essential
    and inherent to the technology). Later changes are of course possible, but they
    can have a lot of side effects (typically in terms of performance and potential
    constraint violations), and for this reason, they are impactful and expensive.
    On the other hand, we will see that alternative technologies (such as NoSQL storage)
    can implement changes in the data structure more easily.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也存在一些缺点。数据库需要事先定义一个刚性的结构来定义表、关系和约束（这在很大程度上是技术和固有的）。后续的更改当然可能发生，但它们可能产生很多副作用（通常在性能和潜在的约束违规方面），因此它们具有影响力和成本。另一方面，我们将看到，替代技术（如
    NoSQL 存储）可以更容易地实现数据结构的更改。
- en: For this reason, a relational database may not be suitable in cases where we
    don't exactly know the shape of the data objects we are going to store. Another
    potential issue is that, given the complexity and rigidity of the technology,
    you may end up with performance and functional issues, which are not always easy
    to troubleshoot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不知道将要存储的数据对象形状的情况下，关系型数据库可能并不适合。另一个潜在问题是，鉴于技术的复杂性和刚性，你可能会遇到性能和功能问题，这些问题并不总是容易排查。
- en: A typical example relates to complex queries. A relational database typically
    uses indexes to achieve better performance (each specific implementation may use
    different techniques, but the core concepts are often the same). Indexes must
    be maintained over time, with operations such as defragmentation and other similar
    ones (depending on each specific database implementation). If we fail to properly
    perform such maintenances, this may end up impacting heavily on the performance.
    And even if our indexes are working correctly, complex queries may still perform
    poorly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子与复杂查询相关。关系型数据库通常使用索引来实现更好的性能（每个特定的实现可能使用不同的技术，但核心概念通常相同）。索引需要随着时间的推移进行维护，包括碎片整理和其他类似操作（取决于每个特定的数据库实现）。如果我们未能正确执行此类维护，这可能会对性能产生严重影响。即使我们的索引工作正常，复杂查询仍然可能表现不佳。
- en: This is because, in most practical implementations, you will need to combine
    and filter data from many different tables (an operation generally known as a
    join). These operations may be interpreted in many different ways by databases
    that will try to optimize the query times but will not guarantee good results
    in every case (especially when many tables and rows are involved).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在大多数实际应用中，你需要从许多不同的表中组合和筛选数据（这种操作通常被称为连接）。数据库可能会以许多不同的方式解释这些操作，试图优化查询时间，但并不能保证在所有情况下都能得到良好的结果（尤其是当涉及许多表和行时）。
- en: Moreover, when doing complex queries, you may end up not correctly using the
    indexes, and small changes in a working query may put you in the same situation.
    For this reason, my suggestion is, in complex application environments, to make
    sure to always double-check your queries in advance with the database administrators,
    who are likely to have tools and experience for identifying potential issues before
    they slip into production environments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在进行复杂查询时，你可能会错误地使用索引，而一个正在运行的查询中的微小变化也可能使你陷入同样的困境。因此，我的建议是在复杂的应用环境中，务必提前与数据库管理员进行双重检查，他们可能拥有工具和经验来识别潜在问题，防止这些问题在生产环境中出现。
- en: As we have seen in this section, relational databases, while not being the most
    modern option, are still a very widespread and useful technology for storing data,
    especially when you have requirements regarding data integrity and structure.
    However, this comes at the cost of needing to define the data structure upfront
    and in having some discipline in the maintenance and usage of the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，虽然关系型数据库不是最现代的选项，但它们仍然是存储数据的一个非常广泛和有用的技术，尤其是在你需要数据完整性和结构要求的情况下。然而，这需要你提前定义数据结构，并在数据库的维护和使用上保持一定的纪律。
- en: You should also consider that, sometimes, relational databases may simply be
    overkill for simple use cases, where you just need simple queries and maybe not
    even persistence. We are going to discuss this scenario in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑，有时，关系型数据库对于简单的用例来说可能过于强大，而你只需要简单的查询，甚至不需要持久化存储。我们将在下一节讨论这种情况。
- en: Introducing key/value stores
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入键/值存储
- en: There are scenarios in which you simply need temporary storage and are going
    to access it in a simple way, such as by a known **unique key**, which will be
    associated with your object. This scenario is the best for key/value stores. Within
    this concept, you can find a lot of different implementations, which usually share
    some common features. The basic one is the **access model** – almost every key/value
    store provides APIs for retrieving data by using a key. This is basically the
    same mechanism as **hash tables** in Java, which guarantee maximum performance.
    Data retrieved in this way can be serialized in many different ways. The most
    basic way, for simple values, is strings, but **Protobuf** is another common choice
    (see [*Chapter 8*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200), *Designing
    Application Integration and Business Automation*, where we discussed this and
    other serialization technologies).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景，你可能只需要临时存储，并以简单的方式访问它，例如通过一个已知的**唯一键**，这将与你的对象相关联。这种场景最适合键/值存储。在这个概念中，你可以找到许多不同的实现，它们通常有一些共同的特征。最基本的是**访问模型**——几乎每个键/值存储都提供了通过键检索数据的API。这基本上与Java中的**哈希表**机制相同，它保证了最佳性能。以这种方式检索到的数据可以以许多不同的方式序列化。对于简单值，最基本的方式是字符串，但**Protobuf**也是一个常见的选择（参见[*第8章*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200)，*设计应用程序集成和业务自动化*，我们在这里讨论了这一点和其他序列化技术）。
- en: A key/value store may not offer persistent storage options, as that is not the
    typical use case. Data is simply kept in memory to be optimized for performance.
    Modern implementations, however, compromise by serializing data on disk or in
    an external store (such as a relational database). This is commonly done asynchronously
    to reduce the impact on access and save times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储可能不提供持久化存储选项，因为这并不是典型的用例。数据只是保存在内存中以优化性能。然而，现代实现通过在磁盘或外部存储（如关系型数据库）上序列化数据来妥协。这通常以异步方式进行，以减少对访问和保存时间的影响。
- en: Whether the technology you are using is providing persistent storage or not,
    there are other features for enhancing the reliability of a system. The most common
    one is based on data replication. Basically, you will have more than one system
    (also called *nodes*) running in a clustered way (meaning that they are talking
    to each other). Such nodes may be running on the same machine or, better yet,
    in different locations (to increase the reliability even more).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的科技是否提供持久存储，都有其他功能可以增强系统的可靠性。最常见的一个是基于数据复制。基本上，你将拥有多个系统（也称为*节点*）以集群方式运行（这意味着它们在相互通信）。这些节点可能运行在同一台机器上，或者更好的是，在不同的位置（以进一步提高可靠性）。
- en: Then, the technology running your key/value store may be configured to propagate
    each change (adding, removing, or modifying data) into a number of different nodes
    (optionally, all of them). In this way, in case of the failure of a node, your
    data will still be present in one or more other nodes. This replication can be
    done synchronously (reducing the possibility of data loss but increasing the latency
    of each write operation) or asynchronously (the other way around).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行你的键/值存储的技术可能被配置为将每个更改（添加、删除或修改数据）传播到多个不同的节点（可选，所有节点）。这样，在节点失败的情况下，你的数据仍然存在于一个或多个其他节点中。这种复制可以是同步的（减少数据丢失的可能性但增加每次写操作的延迟）或异步的（反之亦然）。
- en: In the upcoming sections, we are going to see some common scenarios relating
    to caching data and the life cycle of records stored in the key/value store. Let's
    start looking at some techniques to implement data caching.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到一些与缓存数据和键/值存储中记录的生命周期相关的一些常见场景。让我们先看看实现数据缓存的一些技术。
- en: Data caching techniques
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据缓存技术
- en: A typical use case for key/value stores is **caching**. You can use a cache
    as a centralized location to store disposable data that's quickly accessible from
    your applications. Such data is typically considered disposable because it can
    be retrieved in other ways (such as from a relational database) if the key/value
    store is unavailable or doesn't have the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储的典型用例是**缓存**。你可以使用缓存作为一个集中位置来存储可丢弃的数据，这些数据可以从你的应用程序中快速访问。这种数据通常被认为是可丢弃的，因为如果键/值存储不可用或没有数据，可以通过其他方式（如从关系数据库）检索。
- en: So, in an average case (sometimes referred to as a *cache hit*), you will have
    better performance and will avoid going into other storage (such as relational
    databases), which may be slow, overloaded, or expensive to access. In a worst-case
    scenario (sometimes referred to as a *cache miss*), you will still have other
    ways to access your data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在平均情况下（有时被称为*缓存命中*），你将获得更好的性能，并避免进入其他存储（如关系数据库），这些存储可能较慢、过载或访问成本较高。在最坏的情况下（有时被称为*缓存未命中*），你仍然有其他方式访问你的数据。
- en: 'Some common scenarios are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的场景如下：
- en: '**Cache aside**: The key/value store is considered part of the application,
    which will decide programmatically which data should be stored on it, which data
    will go into persistent storage (such as a database), and how to keep the two
    in sync. This is, of course, the scenario providing the maximum flexibility, but
    it may be complex to manage.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存分离**：键/值存储被认为是应用程序的一部分，它将决定程序化地哪些数据应该存储在其上，哪些数据将进入持久存储（如数据库），以及如何保持两者同步。当然，这是提供最大灵活性的场景，但可能难以管理。'
- en: '**Read-through** and **write-through**: The synchronization between the key/value
    store and the persistent storage is done by the key/value store itself. This can
    be only for read operations (read-through), only for write operations (write-through),
    or for both. What happens from a practical point of view is that the application
    interacts with the key/value store only. Each change in the store is then propagated
    to the persistent storage.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读透**和**写透**：键/值存储与持久存储之间的同步是由键/值存储本身完成的。这可以仅用于读操作（读透），仅用于写操作（写透），或两者都用于。从实际角度来看，应用程序仅与键/值存储交互。存储中的每次更改随后都会传播到持久存储。'
- en: '**Read-behind** and **write-behind**: Basically, this is the same as read-through
    and write-through, but the sync with the persistent storage is not completed immediately
    (it''s asynchronous). Of course, some inconsistency may happen, especially if
    you have other applications accessing the persistent storage directly, which may
    see incorrect or old data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取后跟**和**写入后跟**：基本上，这与读取穿透和写入穿透相同，但与持久存储的同步不是立即完成的（它是异步的）。当然，可能会发生一些不一致，特别是如果您有其他应用程序直接访问持久存储，它们可能会看到不正确或旧的数据。'
- en: '**Write-around**: In this scenario, your application reads from the key/value
    store (by using a read-through or read-behind approach) and directly writes on
    the persistence store, or maybe other applications perform the write on the persistence
    store. Of course, this scenario can be dangerous, as your application may end
    up reading incorrect things on the key/value store.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绕过写入**：在这种情况下，您的应用程序从键/值存储中读取（通过使用读取穿透或读取后跟方法）并直接写入持久存储，或者可能是其他应用程序在持久存储上执行写入。当然，这种场景可能很危险，因为您的应用程序最终可能在键/值存储上读取到不正确的内容。'
- en: This scenario can be managed by notifying the key/value store about any change
    occurring in the persistent storage. This can be done by the application writing
    data, or it can be done directly by the persistent storage (if it is a feature
    provided by the technology) using a pattern known as **change data capture**.
    The key/value store may then decide to update the changed data or simply delete
    it from the cached view (forcing a retrieve from the persistent store when your
    application will look again for the same key).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景可以通过通知键/值存储关于持久存储中发生的任何变化来管理。这可以通过应用程序写入数据来完成，或者如果该技术提供了这种功能，也可以直接通过持久存储来完成。然后键/值存储可能会决定更新更改的数据，或者简单地从缓存视图中删除它（当您的应用程序再次查找相同的键时，将强制从持久存储中检索）。
- en: Another common topic when talking about key/value stores is the life cycle of
    the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论键/值存储时，另一个常见的话题是数据的生命周期。
- en: Data life cycle
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据生命周期
- en: 'Since they use memory heavily, with huge datasets you may want to avoid having
    everything in memory, especially if the access patterns are identifiable (for
    example, you can foresee with reasonable accuracy which data will be accessed
    by your application). Common patterns for deciding what to keep in memory and
    what to delete are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们大量使用内存，对于大数据集，您可能想避免将所有内容都放在内存中，尤其是如果访问模式是可识别的（例如，您可以用合理的准确性预测您的应用程序将访问哪些数据）。决定在内存中保留什么和删除什么的一些常见模式如下：
- en: '**Least recently used**: The system keeps track of the time of last access
    for each record and ditches the records that haven''t been accessed for a set
    amount of time.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近最少使用**：系统跟踪每个记录的最后访问时间，并丢弃在设定时间内未访问的记录。'
- en: '**Tenure**: A variant of the previous scenario that simply uses the creation
    time instead of the last access time.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任期**：这是之前场景的一种变体，它简单地使用创建时间而不是最后访问时间。'
- en: '**Least frequently used**: The system keeps a count of how many times a record
    is accessed and then, when it needs to free up some memory, it will delete the
    least accessed records.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最少频繁使用**：系统记录记录被访问的次数，然后在需要释放一些内存时，它将删除最不常访问的记录。'
- en: '**Most recently used**: The opposite of least recently used, this deletes the
    most recently accessed records. This can be particularly useful in some scenarios,
    such as when it''s unlikely that the same key will be accessed twice in a short
    amount of time.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近最少使用**：与最近最少使用相反，它删除最近访问的记录。这在某些场景中可能特别有用，例如，当在短时间内不太可能两次访问相同的键时。'
- en: Key/value stores lack a standard language, such as SQL. It's also for this reason
    that key/value stores are a big family, including many different products and
    libraries, often offering more features than just key/value management. In the
    next section, we are going to see a few of the most famous implementations of
    key/value stores.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储缺乏标准语言，如SQL。这也是为什么键/值存储是一个大家庭，包括许多不同的产品库，通常提供比仅仅键/值管理更多的功能。在下一节中，我们将看到一些最著名的键/值存储实现。
- en: Commonly used implementations of key/value stores
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用的键/值存储实现
- en: 'As previously mentioned, it''s not easy to build a list of key/value store
    technology implementations. As we will see in the next few sections, this way
    of operating a database is considered to be a subcategory of a bigger family of
    storage systems, called NoSQL databases, offering more options and alternatives
    than just key/value storage. However, for the purpose of this section, let''s
    see a list of what is commonly used in terms of key/value stores:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，构建键值存储技术实现列表并不容易。正如我们将在接下来的几节中看到的那样，这种数据库操作方式被视为一个更大的存储系统家族的子类别，即 NoSQL
    数据库，它提供了比键值存储更多的选项和替代方案。然而，为了本节的目的，让我们看看在键值存储方面通常使用的一些列表：
- en: '**Redis** is likely the most famous key/value store currently available. It''s
    open source, and one of the reasons for its success is that, despite offering
    a lot of advanced features and tunings, it just works well enough in its default
    setting, making adopting it very easy. It provides client libraries for almost
    every language, including Java. It offers a lot of advanced features, such as
    clustering, transactions, and embedded scripting (using the **Lua language**).
    It can operate on in-memory only, or persist the data on the filesystem using
    a configurable approach in order to balance performance impact and reliability.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis** 可能是目前最著名的键值存储。它是开源的，其成功的一个原因在于，尽管它提供了许多高级功能和调优，但在默认设置下它仍然工作得很好，这使得采用它变得非常容易。它为几乎所有语言提供了客户端库，包括
    Java。它提供了许多高级功能，如集群、事务和嵌入式脚本（使用 **Lua 语言**）。它可以在内存中操作，也可以使用可配置的方法将数据持久化到文件系统，以平衡性能影响和可靠性。'
- en: '**Oracle Coherence** is a widely used commercial key/value storage. It''s particularly
    used in conjunction with other Oracle products, in particular with the database.
    It offers a wide range of features, including a complete set of APIs and a custom
    query language. Since 2020, a community edition of Coherence is available as open
    source software.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle Coherence** 是一个广泛使用的商业键值存储。它特别用于与其他 Oracle 产品结合使用，尤其是与数据库结合使用。它提供了一系列功能，包括一套完整的
    API 和自定义查询语言。自 2020 年以来，Coherence 的社区版作为开源软件提供。'
- en: '**Memcached** is a simple key/value store that is light and easy to operate.
    However, it lacks some features, such as persistence. Moreover, it provides only
    the cache-aside use case, so other scenarios must be implemented manually.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memcached** 是一个简单、轻量级且易于操作的键值存储。然而，它缺少一些功能，例如持久性。此外，它仅提供缓存旁路用例，因此其他场景必须手动实现。'
- en: '**Infinispan** is an open source key/value store that provides features such
    as persistence, events, querying, and caching. It''s worth noting that Infinispan
    can be used both in an embedded and a client/server setup. In the embedded setup,
    Infinispan is part of the **WildFly JEE application server**, providing caching
    services to Java Enterprise applications.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Infinispan** 是一个开源的键值存储，它提供了持久性、事件、查询和缓存等功能。值得注意的是，Infinispan 可以在嵌入式和客户端/服务器设置中使用。在嵌入式设置中，Infinispan
    是 **WildFly JEE 应用服务器** 的一部分，为 Java 企业应用程序提供缓存服务。'
- en: Now that we have seen some widespread key/value stores, let's see when they
    are a good fit and when they are not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些广泛使用的键值存储，让我们看看它们何时适用，何时不适用。
- en: The pros and cons of key/value stores
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键值存储的优缺点
- en: The most important advantage of key/value stores is the performance. The access
    time can be incredibly fast, especially when used without any persistent storage
    (in-memory only). This makes them particularly suitable for low-latency applications.
    Another advantage is simplicity, both from an architectural and a usage point
    of view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储最重要的优势是性能。访问时间可以非常快，尤其是在不使用任何持久存储（仅内存）的情况下。这使得它们特别适合低延迟应用程序。另一个优势是简单性，无论是从架构还是使用角度来看。
- en: Architecturally speaking, if your use case doesn't require clustering and other
    complex settings, a key/value store can be as simple as a single application exposing
    an API to retrieve and store records. From a usage point of view, most use cases
    can be implemented with primitives as simple as `get`, `put`, and `delete`. However,
    some of these points can become limitations of key/value stores, especially when
    you have different requirements. If your application needs to be reliable (as
    in losing as little data as possible when there's a failure), you may end up with
    complex multi-node setups and persistence techniques. This may, in turn, mean
    that in some cases, you can have inconsistency in data that may need to be managed
    from an application point of view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构的角度来看，如果你的用例不需要集群和其他复杂设置，键值存储可以简单到只是一个应用程序，它通过API公开来检索和存储记录。从使用角度来看，大多数用例都可以使用像`get`、`put`和`delete`这样简单的原语来实现。然而，其中一些点可能成为键值存储的限制，尤其是在你有不同要求的情况下。如果你的应用程序需要可靠性（即在出现故障时尽可能少地丢失数据），你可能会陷入复杂的多个节点设置和持久化技术。这反过来可能意味着在某些情况下，你可能会在数据上出现不一致性，这可能需要从应用程序的角度进行管理。
- en: Another common issue is that, usually, data is not structured in key/value stores.
    This means that it is only possible to retrieve data searching by key (or at least,
    that's the most appropriate scenario). While some implementations allow it, it
    can be hard, performance-intensive, or in some cases impossible to retrieve data
    with complex queries on the object values, in contrast with what you can do with
    SQL in relational databases.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是，通常数据在键值存储中不是结构化的。这意味着只能通过键（或者至少，这是最合适的场景）来检索数据。虽然一些实现允许这样做，但使用复杂查询检索数据可能很困难、性能密集，或者在某些情况下不可能，这与你在关系型数据库中使用SQL所能做到的相比。
- en: In this section, we have covered the basics of data caching and key/value stores.
    Such techniques are increasingly used in enterprise environments, for both their
    positive impact on performances and their scalability, which fit well with cloud-native
    architectures. Topics such as data caching techniques and the life cycles of objects
    are common considerations to be made when adopting key/value stores.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了数据缓存和键值存储的基础知识。这些技术在企业环境中越来越受欢迎，因为它们对性能的积极影响和可扩展性，非常适合云原生架构。在采用键值存储时，数据缓存技术和对象的生命周期是常见的考虑因素。
- en: Key/value stores are considered to be part of a broader family of storage technologies
    that are alternatives to relational databases, called NoSQL. In the next section,
    we will go into more detail about this technology.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储被认为是更广泛存储技术家族的一部分，这些技术是关系型数据库的替代品，被称为NoSQL。在下一节中，我们将更详细地介绍这项技术。
- en: Exploring NoSQL repositories
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索NoSQL存储库
- en: NoSQL is an umbrella term comprising a number of very different data storage
    technologies. The term was coined mostly for marketing purposes in order to distinguish
    them from relational databases. Some NoSQL databases even support SQL-like query
    languages. NoSQL databases claim to outdo relational databases in terms of performance.
    However, this assurance only exists because of some compromises, namely the lack
    of some features, usually in terms of transactionality and reliability. But to
    discuss these limitations, it is worth having an overview of the CAP theorem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是一个包含许多非常不同的数据存储技术的总称。这个术语主要是为了营销目的而创造的，目的是将它们与关系型数据库区分开来。一些NoSQL数据库甚至支持类似SQL的查询语言。NoSQL数据库声称在性能方面优于关系型数据库。然而，这种保证仅存在于一些妥协的基础上，即缺乏一些功能，通常是在事务性和可靠性方面。但为了讨论这些限制，了解CAP定理的概述是值得的。
- en: The CAP theorem
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CAP定理
- en: The **CAP theorem** was theorized by Eric Brewer in 1998 and formally proven
    valid in 2002 by Seth Gilbert and Nancy Lynch. It refers to a distributed data
    store, regardless of the underlying technology, so it's also applicable to relational
    databases when instantiated in a multi-server setup (so, running in two or more
    different processes, communicating through a network, for clustering and high-availability
    purposes). The theorem focuses on the concept of a *network split*, when the system
    becomes partitioned into two (or more) subsets that are unable to communicate
    with each other due to connectivity loss.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP定理**由埃里克·布卢尔（Eric Brewer）于1998年提出，并由塞思·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy
    Lynch）于2002年正式证明有效。它指的是分布式数据存储，无论底层技术如何，因此当在多服务器设置中实现时（即在两个或更多不同的进程中运行，通过网络进行通信，用于集群和高可用性目的）也适用于关系数据库。该定理关注的是*网络分裂*的概念，当系统因连接丢失而分为两个（或更多）无法相互通信的子集时。'
- en: 'The CAP theorem describes three core characteristics of distributed data stores:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理描述了分布式数据存储的三个核心特性：
- en: '**Consistency** refers to keeping the stored data complete, updated, and formally
    correct.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**指的是保持存储数据的完整性、更新性和形式正确性。'
- en: '**Availability** refers to providing access to all the functionalities of the
    data store, especially the reads and writes of the data itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**指的是提供对数据存储所有功能的访问，特别是对数据本身的读写操作。'
- en: '**Partition tolerance** refers to the system functioning correctly, even in
    a case of network failure between servers.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容错性**指的是即使在服务器之间发生网络故障的情况下，系统也能正常工作。'
- en: 'The CAP theorem states that, when a partition occurs, you can only preserve
    consistency or availability. While a mathematical explanation is available (and
    beyond the scope of this book), the underlying idea can be understood easily:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理指出，当发生分区时，你只能保持一致性或可用性。虽然有一个数学解释（且超出了本书的范围），但基本思想可以很容易地理解：
- en: If a system preserves availability, it may be that two conflicting operations
    (such as two writes with two different values) arrive in two different partitions
    of the system (such as two servers, unable to communicate between each other).
    With availability in mind, both servers will accept the operation, and the end
    result will be data being inconsistent.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个系统保持可用性，可能会出现两个冲突的操作（例如，两个具有不同值的写操作）到达系统的两个不同的分区（例如，两个服务器，无法相互通信）。考虑到可用性，两个服务器都将接受操作，最终结果将是数据不一致。
- en: If a system preserves consistency, in case of a network split, it cannot accept
    operations that will change the status of the data (to avoid the risk of conflicts
    damaging the data consistency); hence, it will sacrifice availability.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个系统保持一致性，在网络分裂的情况下，它不能接受会改变数据状态的操作（以避免冲突风险损害数据一致性）；因此，它将牺牲可用性。
- en: However, it's worth noticing that this theorem, while being the basis for understanding
    the distributed data store limits, must be considered and contextualized in each
    particular scenario. In many enterprise contexts, it is possible to make the event
    of a network split extremely unlikely (for example, by providing multiple network
    connections between each server).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，这个定理，虽然它是理解分布式数据存储限制的基础，但必须在每个特定场景中考虑和具体化。在许多企业环境中，有可能使网络分裂事件极为不可能（例如，通过在每台服务器之间提供多个网络连接）。
- en: Moreover, it's common to have mechanisms to elect a primary partition when there's
    a network split. This basically means that if you are able to define which part
    of the cluster is primary (typically, the one with the greater number of survival
    nodes, and this is why it's usually recommended to have an odd number of nodes),
    this partition can keep working as usual, while the remaining partition can shut
    down or switch to a degraded mode (such as read-only). So, basically, it's crucial
    to understand the basics of the CAP theorem, but it's also important to understand
    that there are a number of ways to work around the consequences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当网络分裂时，通常会有机制来选举一个主分区。这基本上意味着如果你能够定义集群的哪个部分是主分区（通常，拥有更多生存节点的那个，这也是为什么通常建议节点数为奇数的原因），这个分区可以像往常一样继续工作，而剩余的分区可以关闭或切换到降级模式（如只读）。因此，理解CAP定理的基本原理至关重要，但同样重要的是要了解有几种方法可以绕过其后果。
- en: This is exactly the reasoning behind NoSQL databases. These databases shift
    their point of view, *stretching* a bit over the CAP capabilities. This means
    that, while traditional relational databases focus on consistency and availability,
    they are often unreliable to operate in a heavily distributed fashion. Conversely,
    NoSQL databases can operate better in horizontally distributed architectures,
    favoring scalability, throughput, and performance at the expense of availability
    (as we saw, becoming read-only when there are network partitions) or consistency
    (not providing ACID transaction capabilities).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是NoSQL数据库背后的推理。这些数据库改变了它们的视角，*拉伸*了CAP能力。这意味着，虽然传统的关系数据库侧重于一致性和可用性，但它们在高度分布式的方式下操作时往往不可靠。相反，NoSQL数据库可以在水平分布式架构中运行得更好，以可扩展性、吞吐量和性能为代价，牺牲可用性（正如我们所见，在出现网络分区时变为只读）或一致性（不提供ACID事务能力）。
- en: And this brings us to another common point of NoSQL stores – the **eventual
    consistency**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也让我们来到了NoSQL存储的另一个常见点——**最终一致性**。
- en: Indeed, most NoSQL stores, while not providing full transactionality (compared
    to relational databases) can still offer some data integrity by using the pattern
    of eventual consistency. Digging into the details and impacts of this pattern
    would require a lot of time. For the sake of this section, it's sufficient to
    consider that a system implementing eventual consistency may have some periods
    of time in which data is not coherent (in particular, enquiring for the same data
    on two different nodes can lead to two different results).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数NoSQL存储，虽然不提供完整的事务性（与关系数据库相比），但仍然可以通过使用最终一致性模式提供一些数据完整性。深入探讨这个模式的细节和影响需要很多时间。为了本节的目的，我们只需考虑一个实现最终一致性的系统可能有一些时间数据是不一致的（特别是，在两个不同的节点上查询相同的数据可能导致两个不同的结果）。
- en: With that said, it's usually possible to tune a NoSQL store in order to preserve
    consistency and provide full transactionality as a traditional relational database
    does. But in my personal experience, the impacts in terms of reduced performance
    and availability are not a worthwhile compromise. In other words, if you are looking
    for transactionality and data consistency, it's usually better to rely on relational
    databases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，通常可以调整NoSQL存储以保持一致性并提供与传统关系数据库相同的完整事务性。但根据我的个人经验，在性能和可用性方面的影响并不是值得妥协的。换句话说，如果你在寻找事务性和数据一致性，通常最好依赖于关系数据库。
- en: With that said, let's have an overview of the different NoSQL database categories.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们概述一下不同的NoSQL数据库分类。
- en: NoSQL database categories
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据库分类
- en: 'As we discussed in the previous sections, NoSQL is an umbrella term. There
    are a number of different categories of NoSQL stores:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的那样，NoSQL是一个总称。存在许多不同的NoSQL存储分类：
- en: '**Key/value stores**: This is the easiest one, as we have already discussed
    the characteristics of this technology. As should be clear by now, key/value stores
    share some core characteristics with NoSQL databases – they are generally designed
    to be horizontally scalable, to focus on performance over transactionality, and
    to lack full SQL compliance.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键/值存储**：这是最容易的一种，因为我们已经讨论了这种技术的特点。现在应该很清楚，键/值存储与NoSQL数据库共享一些核心特性——它们通常被设计为水平可扩展的，侧重于性能而非事务性，并且缺乏完整的SQL兼容性。'
- en: '**Document stores**: This is one of the most widespread categories of NoSQL
    databases. The core concept of a document store is that instead of rows, it stores
    documents, serialized into various formats (commonly JSON and XML). This often
    gives the flexibility of storing documents with a different set of fields or,
    in other words, it avoids defining a strict schema in advance for the data we
    are going to store. Documents then can be searched by their contents. Some notable
    examples of document stores include MongoDB, Couchbase, and Elasticsearch.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档存储**：这是NoSQL数据库中最广泛的分类之一。文档存储的核心概念是，它存储的不是行，而是文档，这些文档被序列化为各种格式（通常是JSON和XML）。这通常提供了存储具有不同字段集的文档的灵活性，换句话说，它避免了预先为将要存储的数据定义严格的模式。文档可以通过其内容进行搜索。一些著名的文档存储示例包括MongoDB、Couchbase和Elasticsearch。'
- en: '**Graph databases**: This category of stores is modeled around the concept
    of a graph. It provides storage and querying capabilities optimized around graph
    concepts, such as nodes and vertex. In this way, concepts such as roads, links,
    and social relationships can be modeled, stored, and retrieved easily and efficiently.
    A famous implementation of a graph database is **Neo4j**.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：这类存储是基于图的概念构建的。它提供了针对图概念（如节点和顶点）优化的存储和查询功能。通过这种方式，可以轻松高效地建模、存储和检索诸如道路、链接和社会关系等概念。图数据库的一个著名实现是**Neo4j**。'
- en: '**Wide-column databases**: These stores are similar to relational databases,
    except that in a table, each row can have a different set of fields in terms of
    the number, name, and type of each one. Two known implementations of wide-column
    databases are Apache Cassandra and Apache Accumulo.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽列数据库**：这些存储类似于关系数据库，只是在表中，每一行可以根据数量、名称和类型的不同而拥有不同的字段集。两个已知的宽列数据库实现是Apache
    Cassandra和Apache Accumulo。'
- en: Of course, as you can imagine, there is a lot more to say about NoSQL databases.
    I hope the pointers I gave in this section will help you quickly understand the
    major features of NoSQL databases, and I hope one of the examples I've provided
    will be useful for your software architecture. In the next section, we are going
    to have a look at filesystem storage.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如你可以想象的那样，关于NoSQL数据库还有很多可以说的。我希望我在本节中给出的提示能帮助你快速了解NoSQL数据库的主要功能，并且希望我提供的其中一个示例对你的软件架构有所帮助。在下一节中，我们将探讨文件系统存储。
- en: Looking at filesystem storage
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看文件系统存储
- en: '**Filesystems** are a bit of a borderline concept when it comes to data storage
    systems. To be clear, filesystem storage is a barely structured system providing
    APIs, schemas, and advanced features, like the other storage systems that we have
    seen so far. However, it is still a very relevant layer in many applications,
    and there are some new storage infrastructures that provide advanced features,
    so I think it''s worth having a quick overview of some core concepts.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统**在数据存储系统中是一个有点模糊的概念。为了明确，文件系统存储是一个几乎无结构的系统，提供API、模式和像我们之前看到的其他存储系统一样的高级功能。然而，它仍然是许多应用中的一个非常相关的层，并且有一些新的存储基础设施提供了高级功能，因此我认为快速概述一些核心概念是值得的。'
- en: Filesystem storage should not be an alien concept to most of us. It is a persistent
    storage system backed by specific hardware (spinning or solid-state disks). There
    are many different filesystems, which can be considered the protocol used to abstract
    the read and write operations from and to such specific hardware. Other than creating,
    updating, and deleting files, and the arrangement of these files into folders,
    filesystems can provide other advanced features, such as journaling (to reduce
    the risk of data corruption) and locking (in order to provide exclusive access
    to files).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统存储对于大多数人来说不应该是一个陌生的概念。它是一个由特定硬件（旋转或固态磁盘）支持的持久存储系统。存在许多不同的文件系统，可以被认为是用于从和这些特定硬件抽象读取和写入操作的协议。除了创建、更新和删除文件，以及将这些文件组织到文件夹中之外，文件系统还可以提供其他高级功能，例如日志记录（以减少数据损坏的风险）和锁定（为了提供对文件的独占访问）。
- en: Some common filesystems are the **New Technology File System** (**NTFS**) (used
    in Windows environments) and the **Extended File System** (**ext**) (used in Linux
    environments). However, these filesystems are designed for working on a single
    machine. A more important concept relates to the filesystems that allow interactions
    between different systems. One such widespread implementation is networked filesystems,
    which is a family of filesystem protocols providing access to files and directories
    over a network. The most notable example here is NFS, which is a protocol that
    provides multi-server access to a shared filesystem. The **File Transfer Protocol**
    (**FTP**) and the **SSH File Transfer Protocol** (**SFTP**) are other famous examples,
    and even if they are outdated, they are still widely used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的文件系统包括**新技术文件系统**（**NTFS**）（用于Windows环境）和**扩展文件系统**（**ext**）（用于Linux环境）。然而，这些文件系统是为在单台机器上工作而设计的。一个更重要的概念是与不同系统之间交互的文件系统。其中一个广泛实现的例子是网络文件系统，这是一组文件系统协议，提供通过网络访问文件和目录。这里最显著的例子是NFS，这是一个提供对共享文件系统多服务器访问的协议。**文件传输协议**（**FTP**）和**SSH文件传输协议**（**SFTP**）也是其他著名的例子，即使它们已经过时，但仍然被广泛使用。
- en: A recent addition to the family of network storage systems is **Amazon S3**.
    While it's technically an object filesystem, it's a way to interact with Amazon
    facilities using APIs in order to store and retrieve files. It started as a proprietary
    implementation for providing filesystem services on AWS infrastructure over the
    internet; since then, S3 has become a standard, and there are a lot of other implementations,
    both open source and commercial, aiming to provide S3-compliant storage on-premises
    and in the cloud.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 网络存储系统家族的最新成员是**Amazon S3**。虽然它技术上是一个对象文件系统，但它是一种使用API与亚马逊设施交互以存储和检索文件的方式。它最初是为在互联网上提供AWS基础设施上的文件系统服务而提供的专有实现；从那时起，S3已经成为一个标准，并且有许多其他实现，包括开源和商业的，旨在在本地和云中提供符合S3规范的存储。
- en: The advantages and disadvantages of filesystems
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统的优缺点
- en: It's hard to talk about the disadvantages of filesystems because they are an
    essential requirement in every application, and it will stay like this for a long
    time. However, it's important to contextualize and think logically about the pros
    and cons of filesystems to better understand where to use them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论文件系统的缺点有些困难，因为它们是每个应用程序的基本需求，并且这种情况在很长时间内都不会改变。然而，重要的是要具体化并逻辑地思考文件系统的优缺点，以便更好地理解在哪里使用它们。
- en: Application interaction over shared filesystems is particularly convenient when
    it comes to exchanging large amounts of data. In banking systems (especially legacy
    ones), it's common to exchange large numbers of operations (such as payments)
    to be performed in batches, in the form of huge `.csv` files. The advantage is
    that the files can be safely chunked, signed, and efficiently transferred over
    a network.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享文件系统上进行的应用程序交互在交换大量数据时尤其方便。在银行系统（尤其是遗留系统）中，通常会将大量操作（如支付）批量交换，以巨大的`.csv`文件形式执行。其优势在于文件可以安全地分块、签名，并通过网络高效传输。
- en: On the other hand, filesystems don't usually offer native indexing and full-text
    search, so these capabilities must be implemented on top. Moreover, filesystems
    (especially networked filesystems) can perform badly, especially when it comes
    to concurrent access and the locking of files.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，文件系统通常不提供原生索引和全文搜索功能，因此这些功能必须在之上实现。此外，文件系统（尤其是网络文件系统）可能表现不佳，尤其是在并发访问和文件锁定方面。
- en: With this section, we have completed our overview of storage systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节，我们完成了对存储系统的概述。
- en: In the next section, we are going to see how, in modern architecture, it is
    common to use more than one storage solution to address different use cases with
    the most suitable technology.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到在现代架构中，使用多个存储解决方案以最合适的技术应对不同的用例是常见的。
- en: Modern approaches – a multi-tier storage strategy
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代方法——多级存储策略
- en: In the final section of the chapter, we'll be exploring a concept that may seem
    obvious, but it's still worth mentioning. **Modern architecture** tends to use
    multiple data storage solutions, and I think that this could be a particularly
    interesting solution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨一个可能看似明显但仍有必要提及的概念。**现代架构**倾向于使用多种数据存储解决方案，我认为这可能会是一个特别有趣的解决方案。
- en: In the past, it was common to start by defining a persistence strategy (typically
    on a relational database or on another legacy persistence system) and build the
    application functionalities around it. This is no longer the case. Cloud-native
    technologies, through microservices, developed the idea that each microservice
    should own its own data, and we can extend this concept in that each microservice
    could choose its own persistent storage technology. This is better suited for
    the particular characteristics of that business domain and the related use cases.
    Some services may need to focus on performance, while others will have a strong
    need for transactionality and data consistency.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，通常首先定义持久化策略（通常是关系数据库或另一个遗留持久化系统），然后围绕它构建应用程序功能。这种情况已经不再存在。通过微服务，云原生技术发展了这样一个理念：每个微服务应该拥有自己的数据，并且我们可以将这个概念扩展到每个微服务可以选择自己的持久化存储技术。这更适合特定业务领域和相关用例的特点。一些服务可能需要关注性能，而其他服务则可能对事务性和数据一致性有强烈的需求。
- en: 'However, even if you are dealing with a less innovative architecture, it''s
    still worthwhile evaluating different ideas around data persistence solutions.
    Here are some discussion points about it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使你处理的是不太创新的架构，评估数据持久性解决方案的不同想法仍然是有价值的。以下是一些关于它的讨论点：
- en: Relational databases are your best bet when data is structured upfront and such
    a structure doesn't change very often. Moreover, if you will need ACID-compliant
    transactions, relational databases are generally the most performant solution.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据在开始时是结构化的，并且这种结构不经常改变时，关系型数据库是你的最佳选择。此外，如果你需要ACID兼容的事务，关系型数据库通常是性能最好的解决方案。
- en: Key/value stores, especially in their in-memory setup, are useful in a number
    of use cases. The more common scenarios include the storage of user sessions,
    which will demand high performance (as it's related to web and mobile use cases,
    where there is heavy user interaction and high expectation in terms of availability)
    and consistency/reliability is less of an issue (in a worst-case scenario, the
    user will be logged out and will need to log in again). Another widely used scenario
    is database offloading – implementing some of the described scenarios (read-through,
    write-through, and so on) where cached entries will boost the overall performance
    and reduce the load on the database.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储，尤其是在它们的内存设置中，在许多用例中都很有用。更常见的场景包括用户会话的存储，这将需要高性能（因为它与Web和移动用例相关，在这些用例中，用户交互频繁，对可用性和一致性的期望很高），并且一致性和可靠性不是问题（在最坏的情况下，用户将被注销并需要重新登录）。另一个广泛使用的场景是数据库卸载——实现一些描述的场景（如读取通过、写入通过等），其中缓存的条目将提高整体性能并减少对数据库的负载。
- en: NoSQL databases can be used for scenarios particularly suited to the specific
    technology of choice. In particular, if some entities in our architecture have
    a variable or unstructured representation, they can be suitable for document repositories.
    Graph databases can be useful for other scenarios in which algorithms on graphs
    are needed (such as the shortest path calculation).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库可以用于特别适合所选特定技术的场景。特别是，如果我们的架构中某些实体具有可变或不规则的表现形式，它们可能适合用于文档存储库。图数据库在其他需要图算法的场景中可能很有用（例如最短路径计算）。
- en: As previously mentioned, filesystems are almost always a fundamental infrastructure.
    They may be needed by some middleware (such as message brokers) for writing journals,
    and they can be used explicitly by an application as a data exchange area for
    large amounts of information (especially when dealing with legacy systems).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，文件系统几乎是基本的基础设施。它们可能被某些中间件（如消息代理）需要用于写入日志，并且应用程序可以明确地将其用作大量信息的数据交换区域（尤其是在处理遗留系统时）。
- en: So, once again, choosing the right data storage technology can be crucial to
    have a performant and well-written application, and it's a common practice to
    rely on more than one technology to meet the different needs that different parts
    of our application will require.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，选择正确的数据存储技术对于拥有性能良好和编写良好的应用程序至关重要，并且依赖于一种以上的技术来满足我们应用程序不同部分的不同需求是一种常见的做法。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen an overview of different possibilities on the
    data layer, ranging from traditional SQL databases to more modern alternatives.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了数据层不同可能性的概述，从传统的SQL数据库到更现代的替代品。
- en: While most of us are already familiar with relational databases, we have had
    a useful examination of the pros and cons of using this technology. We then broadened
    our view with alternative, widespread storage technologies, such as key/value
    stores, NoSQL, and even filesystems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们大多数人已经熟悉关系型数据库，但我们已经对使用这种技术的优缺点进行了有益的审视。然后，我们通过替代的、广泛使用的存储技术拓宽了我们的视野，例如键值存储、NoSQL，甚至文件系统。
- en: Eventually, we looked at how the choice of a particular way of storing data
    may affect both the application design and the performance of our system. Indeed,
    in modern architecture, we may want to pick the right storage solution for each
    use case by choosing different solutions where needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们探讨了选择特定数据存储方式可能如何影响应用程序设计和我们系统的性能。确实，在现代架构中，我们可能需要根据每个用例选择合适的存储解决方案，并在需要时选择不同的解决方案。
- en: In the next chapter, we are going to discuss some architectural cross-cutting
    concerns. Topics such as security, resilience, usability, and observability are
    crucial to successful application architecture and will be analyzed to see their
    impacts and best practices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些架构性的跨领域问题。诸如安全性、弹性、可用性和可观察性等主题对于成功应用架构至关重要，并将被分析以了解它们的影响和最佳实践。
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Database Systems: Concepts, Languages, & Architectures*, by Paolo Atzeni,
    Stefano Ceri, Stefano Paraboschi, and Riccardo Torlone'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库系统：概念、语言与架构*，由Paolo Atzeni、Stefano Ceri、Stefano Paraboschi和Riccardo Torlone合著'
- en: '*Relational Databases 101: Looking at the Whole Picture*, by Scott W. Ambler
    ([http://www.agiledata.org/essays/relationalDatabases.html](http://www.agiledata.org/essays/relationalDatabases.html))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关系型数据库101：全面观察*，由Scott W. Ambler著 ([http://www.agiledata.org/essays/relationalDatabases.html](http://www.agiledata.org/essays/relationalDatabases.html))'
- en: NoSQL database list – Edlich ([https://hostingdata.co.uk/nosql-database/](https://hostingdata.co.uk/nosql-database/))
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库列表 – Edlich ([https://hostingdata.co.uk/nosql-database/](https://hostingdata.co.uk/nosql-database/))
- en: '*Making Sense of NoSQL: A guide for managers and the rest of us*, by Dan McCreary
    and Ann Kelly'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解NoSQL：管理者和我们的指南*，由Dan McCreary和Ann Kelly合著'
