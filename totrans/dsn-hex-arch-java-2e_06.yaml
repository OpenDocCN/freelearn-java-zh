- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Domain Hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we had the opportunity to employ **Domain-Driven Design**
    (**DDD**) techniques, such as entities and value objects, to create a domain model.
    However, until now, we haven’t touched on organizing packages, classes, and modules
    to fit the hexagonal architecture purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The **Domain hexagon** is the place to start developing a hexagonal application.
    Based on the domain, we derive all other hexagons. We can say that the Domain
    hexagon is the brain of hexagonal systems because the core fundamental business
    logic resides in such a hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will start to explore how to structure a hexagonal application
    project from the bottom using a Java module approach. This will help us ensure
    better encapsulation and unit testing to validate our code as we develop the Domain
    hexagon components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the Domain hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the problem domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining value objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining entities and specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining domain services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Domain hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired a hands-on perspective on
    the development of all the Domain hexagon components. This knowledge will enable
    you to take care of all the details regarding the structure and arrangement of
    classes and packages in the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the Domain hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hexagonal application project that we will start in this chapter is actually
    a continuation of the topology and inventory system that we’ve developed in the
    last few chapters. However, the difference here is that we will augment some of
    the system’s capabilities and use the **Java Platform Module System** (**JPMS**)
    to encapsulate the Domain hexagon in a Java module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with bootstrapping the Domain hexagon, let’s create a multi-module
    Maven project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a parent project called `topology-inventory` by executing
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a module for the Domain hexagon, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the `mvn` commands to create a `topology-inventory` Maven root
    project and then the `domain` module, you’ll have a directory tree similar to
    the one shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The directory structure of the Domain hexagon](img/B19777_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The directory structure of the Domain hexagon
  prefs: []
  type: TYPE_NORMAL
- en: Since the release of `module-info.java` module descriptor file into a Java project
    root directory. When you create a Java module using this file, you close the access
    to all public packages in that module. To make public packages accessible to other
    modules, you need to export the desired packages in the module descriptor file.
    There are other interesting things to say about Java modules, but we have reserved
    them for [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency
    Inversion with* *Java Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the Domain hexagon in a Java module, you need to create a module
    descriptor file at `topology-inventory/domain/src/java/module-info.java`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re not yet allowing access to any public packages, nor depending
    on other modules, we will leave the `module-info.java` file with no entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make not just the Domain but also all other hexagons with less
    verbose classes, we’ll add the `lombok` library to the `pom.xml` project root,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also important to configure the annotation processing paths for `lombok`;
    otherwise, there will be compilation failures. You can do this by running the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s inside the `maven-compile-plugin` plugin block that we add the configuration
    for `annotationProcessorPaths`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we add the lombok dependency, we need to update the domain’s `module-info.java`
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start developing the Domain hexagon on top of our fully
    modularized structure. Let’s move on to understand the problem domain of our enhanced
    topology and inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start modeling the problem domain by considering the fact that a core
    router can connect to both core and edge routers. Edge routers, in turn, connect
    to switches and their networks. The following diagram depicts this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – A use case for the topology and inventory network system](img/B19777_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A use case for the topology and inventory network system
  prefs: []
  type: TYPE_NORMAL
- en: Core routers are faster and deal with high traffic loads, and they don’t deal
    directly with the traffic generated from a switch and its networks. Conversely,
    edge routers deal directly with traffic generated by a switch and its networks.
    In our scenario, an edge router is not allowed to connect to other edge routers;
    it can only connect to core routers and switches. A switch can have multiple networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that’s a particular arrangement established for our scenario.
    By no means does it represent a strict rule of how to organize network components.
    Here is a diagram showing the arrangement of our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A use case for the topology and inventory network system (continued)](img/B19777_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A use case for the topology and inventory network system (continued)
  prefs: []
  type: TYPE_NORMAL
- en: The topology and inventory system’s purpose is to allow users to view and manage
    network assets. By network assets, we mean routers, switches, and networks – routers
    and switches being physical assets, and networks being logical assets provided
    by switches. Those assets are spread across different locations, and the system
    should show the interconnectivity between assets and their sites. A location is
    composed of the complete address, along with its latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: The management part is based on nothing more than **Create, Read, Update, Delete**
    (**CRUD**)-like operations, allowing users to exert control over the topology
    and inventory systems’ data.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach to building such a system is to first create a Domain hexagon,
    using a domain model containing the operations and rules required to fulfill the
    system’s purpose at its highest level. Our intention at the highest level is to
    validate business ideas straight on the Domain hexagon without the aid of things
    present on the Application and Framework hexagons. As things move onto these hexagons,
    they tend to become more technology-specific, operating at a lower level, because
    technology-specific things are far away from the Domain hexagon. The degree to
    which we maintain the core system functionalities within the Domain hexagon heavily
    influences how loosely coupled the hexagonal system will be.
  prefs: []
  type: TYPE_NORMAL
- en: To validate the methods and classes of the Domain hexagon, we’ll create unit
    tests to ensure domain operations work as expected. This will give us a degree
    of assurance to move forward and use these operations on the Application hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will start to build the hexagonal system foundation with value objects,
    the architecture components that lets us create a domain model to better express
    the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Defining value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038),
    *Wrapping Business Rules inside Domain Hexagon*, entities are the elements we
    use to classify system components that have an identity. Conversely, the value
    objects don’t have an identity. We use value objects to describe those system
    parts where there is no need to define an identity. Then, we have aggregates that
    serve to encapsulate the objects’ related entities and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend starting by creating value objects first because they are like
    the building blocks, the raw material we’ll use to build more elaborate value
    objects, and – most importantly – the entities. Now, we’ll add all the volume
    object classes on the Domain hexagon module, which were created in the previous
    section when we bootstrapped the Domain hexagon. We’ll use the following steps
    to define the value objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `Id` value object class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is very straightforward, with just one `UUID` attribute that
    we use to store the `id` value. We will use the `withId` static method to create
    `Id` instances with a given string. If we want to create something new, we should
    use the `withoutId` static method, which randomly generates IDs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Vendor` `enum` value object class, as we’ll see in the *Defining entities
    and specifications* section, is used on both router and switch entity classes.
    You can see this class in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will model the `Vendor` class as `enum` to let us easily illustrate the system
    features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will do the same thing with the `Model` `enum`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `Protocol`, we create an `enum` value object to represent both the **Internet
    Protocol version 4** (**IPv4**) and **IP version 6** (**IPv6**) protocols, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To help us clearly define which kind of router we’re dealing with, we’ll create
    a `RouterType` `enum`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same idea is also applied to available switch types, as we can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As every router and switch has a location, we have to create a `Location` value
    object class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We introduce the `Location` value object with attributes that allow us to identify
    an address uniquely. That’s why we also have `latitude` and `longitude` as class
    attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The value objects we just created are the most important ones because they
    are the basic building blocks for the other value objects and entities that comprise
    the entire system. Next, we can create more elaborate value objects based on those
    we just created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `IP` value object, as illustrated in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `IP` value object class, we can create both IPv4 and IPv6 addresses.
    The constraint that checks which protocol to use is within the value object constructor.
    The logic we use to validate the IP address is a simple one, just for the sake
    of our example. For a more comprehensive validation, we can use the `InetAddressValidator`
    class from the `commons-validator` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we create a value object to represent networks that will be added to
    a switch, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We model the `Network` value object to store the IP address, network name, and
    `10.0.0.0`) is the network base IP address. The second number (for example, `24`)
    is used to determine the network subnet mask and how many IP addresses will be
    available in this network. In the `Network` class, we refer to the second CIDR
    number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the `Network` constructor, we add the constraint to validate whether
    the CIDR value is valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you’ll have a package and class structure similar to the one shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The directory structure of the value objects](img/B19777_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The directory structure of the value objects
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at value objects, which are our Domain hexagon’s building
    blocks, we can move on to creating entities and their specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities and specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have created all the value objects, we can start to think about how
    to represent the elements in entities that have an identity. Also, we need to
    develop specifications to define business rules that govern constraints that the
    entities should obey.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that what characterizes an entity is its identity and the presence
    of business rules and data. In the topology and inventory system, we have as entities
    `Equipment`, `Router`, and `Switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `domain` Java module we created previously, we’ll add the entity
    classes within a package called `entity`.
  prefs: []
  type: TYPE_NORMAL
- en: The Equipment and Router abstract entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routers and switches are different types of network equipment, so we’ll start
    by creating an `Equipment` abstract class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Most of the value objects created in the previous section are present here in
    the `Equipment` entity. We use the predicate provided by `getVendorTypePredicate`
    to apply the filters that only retrieve a specific vendor’s equipment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving from `Equipment`, we create a `Router` abstract class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Router` abstract class defines predicates common to either core or edge
    routers. We use the predicate provided by `getRouterTypePredicate` to apply filters
    that retrieve only routers of a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have more two predicates from the `Router` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getModelPredicate` and `getCountryPredicate` predicates to retrieve
    routers of a specific model or particular country.
  prefs: []
  type: TYPE_NORMAL
- en: The `Router` abstract class provides the common attributes shared by core and
    edge routers. It’s in the `Router` class that we introduce the predicates to serve
    as filters when querying lists of routers.
  prefs: []
  type: TYPE_NORMAL
- en: The core router entity and its specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving ahead, let’s implement the `CoreRouter` entity class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Core routers can be connected to other core and edge routers. To allow such
    behavior in the `CoreRouter` class, we create an `addRouter` method receiving
    the `Router` abstract type as a parameter. We also use the `SameCountrySpec` specification
    to make sure that edge routers are in the same country as the core router. This
    rule doesn’t apply when we try to connect a core router to another core router.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `SameIPSpec` specification to confirm that routers don’t have
    the same IP address. We make the business rules more explicit and the code easier
    to read and understand by using specifications. You can write this code without
    any specification and just throw `if`-`else` conditions with the necessary variables,
    but the mental load required to understand the code for anyone not acquainted
    with it would probably be higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the `removeRouter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For the `removeRouter` method, we have the `EmptyRouterSpec` specification,
    which prevents us from removing a router that has any other routers connected
    to it. The `EmptySwitchSpec` specification checks whether a router has any switch
    connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: Core routers deal only with other routers. That’s why there is no reference
    to switches in the `CoreRouter` entity class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two methods, `addRouter` and `removeRouter`, operate directly
    on a `Router` type parameter, using domain specifications to check that there
    are no constraint violations before making any changes. Let’s closely examine
    the specifications used by the `CoreRouter` entity, starting with the `SameCountrySpec`
    specification. This specification makes sure that edge routers are always from
    the same country as their core routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `package` specification is where we’ll put all the specifications, so that’s
    the package in which we’ll put the `SameCountrySpec` specification, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `SameCountrySpec` constructor receives an `Equipment` object, which we use
    to initialize the `equipment` private field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the `SameCountrySpec` implementation, we override the `isSatisfiedBy`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `SameCountrySpec` implementation does not apply to core routers. That’s
    why we always return `true` when the object is a `CoreRouter` entity. Otherwise,
    we proceed with the validation to check that the equipment is not in a different
    country.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we override the `check` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We use the `check` method to run the specification. Other classes can call this
    method to verify whether the specification is met or not.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to connect two core routers from different countries. What’s not
    possible, as stated previously, is to connect edge and core routers that are not
    present in the same country. Note that this specification is based on the `Equipment`
    type, allowing us to reuse this specification not just with routers but also on
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `SameIpSpec` specification ensures that no equipment has the
    same IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `SameCountrySpec` and `SameIpSpec` specifications are used by the `addRouter`
    method to ensure that no constraints are violated before adding any router to
    a core router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we have the `EmptyRouterSpec` and `EmptySwitchSpec` specifications.
    Before a router is removed, we must make sure that no other routers or switches
    are connected to such a router. These are very simple specifications. Let’s start
    by looking at the `EmptyRouterSpec` specification, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This specification is based on the `CoreRouter` type because only core routers
    can be connected to other core and edge routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EmptySwitchSpec` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `EmptySwitchSpec` class is very similar to the `EmptyRouterSpec` class.
    The difference, though, is that only edge routers can have switches. That’s why
    this specification is based on the `EdgeRouter` type.
  prefs: []
  type: TYPE_NORMAL
- en: Edge router entity and its specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’re done with the `CoreRouter` entity and its specifications, we
    can move on to create an `EdgeRouter` entity class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `addSwitch` method’s purpose is to connect switches to edge routers. Also,
    in the `EdgeRouter` class, we reuse the same `SameCountrySpec` and `SameIpSpec`
    specifications used when implementing the `CoreRouter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `removeSwitch` method from the `EdgeRouter` class, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For the `removeSwitch` method, we have the `EmptyNetworkSpec` specification
    to ensure that a switch has no networks connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the `CoreRouter` class, we use the `SameCountrySpec` and `SameIpSpec`
    specifications. However, the context is different because we’re adding a switch
    to a router. The only new specification used in the `EdgeRouter` class is the
    `EmptyNetworkSpec` specification, which is used to ensure all networks are removed
    from a switch before it can be removed from an edge router.
  prefs: []
  type: TYPE_NORMAL
- en: Switch entity and its specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What’s left now is the implementation of the `Switch` entity class and its
    related specifications. The ideas we use here are similar to what we applied in
    core and edge router entities. Let’s start by creating a `Switch` entity class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We start the `Switch` class implementation by creating a `getSwitchTypePredicate`
    method predicate, which we used to filter switch collections by the switch type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create an `addNetworkToSwitch` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `addNetworkToSwitch` method receives a `Network` type parameter, which we
    use to add a network to a switch. However, before adding the network, we need
    to check some constraints expressed by the specifications. The first one is the
    `NetworkAvailabilitySpec` specification, which verifies whether the network already
    exists on the switch. Then, we use the `CIDRSpecification` specification to check
    whether the network CIDR is valid. Finally, we use the `NetworkAmountSpec` specification
    to validate whether we have surpassed the maximum networks allowed on the switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `removeNetworkFromSwitch` method, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As there are no constraints to remove networks from a switch, this method does
    not use any specifications.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, right at the beginning of the `Switch` class, we declared a predicate
    to allow us to filter switch collections based on switch types (`LAYER2` and `LAYER3`).
    The `addNetworktoSwitch` method uses the `NetworkAvailabilitySpec`, `NetworkAmountSpec`,
    and `CIDRSpecification` specifications that we already defined in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038),
    *Wrapping Business Rules inside Domain Hexagon*. If none of these specifications’
    constraints are violated, a `Network` object will be added to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `removeNetworkFromSwitch` method, which doesn’t look at
    any specification to remove networks from a switch.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Switch` entity implementation, we conclude the modeling of the entities
    and specifications required to fulfill the topology and inventory system’s purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all the entities, you should have a package and class structure similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The directory structure of entities](img/B19777_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The directory structure of entities
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding screenshot, we put all the entities inside the
    `entity` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'And for all the specifications, the package and class structure should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The directory structure of specifications](img/B19777_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The directory structure of specifications
  prefs: []
  type: TYPE_NORMAL
- en: Some of the specifications used by the topology and inventory system were already
    created in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038), *Wrapping Business
    Rules inside Domain Hexagon*. The remaining specifications are the ones we created
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the entities we have just created, we can now think of tasks that are
    not directly related to such entities. That is the case of services that work
    as an alternative to providing capabilities outside domain entities. Let’s now
    see how to implement services that let us find, filter, and retrieve data from
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Defining domain services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topology and inventory system is about the visualization and management
    of network assets, so we need to enable a user to handle collections of such network
    assets. One way to do that is through services. With services, we can define behaviors
    to deal with system entities and value objects.
  prefs: []
  type: TYPE_NORMAL
- en: All the services that we’ll create in this section reside in the `service` package.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a service to deal with collections of routers.
  prefs: []
  type: TYPE_NORMAL
- en: Router service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, when implementing the `Router`, `CoreRouter`, and
    `EdgeRouter` entities, we also created some methods to return predicates to aid
    us in filtering collections of routers. With a domain service, we can use these
    predicates to filter such collections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For the `filterAndRetrieveRouter` method, we pass a list of routers and a predicate,
    to filter the list, as parameters. Then, we define a `findById` method to retrieve
    a router, using an `Id` type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see the service operations we can use to handle switches.
  prefs: []
  type: TYPE_NORMAL
- en: Switch service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This service follows the same idea we applied to the router service. It’s primarily
    based on the predicate provided by the `getSwitchTypePredicate` method to filter
    collections of switches based on their type. As new predicates arise, we can use
    them as new criteria to filter switch collections. Also, note that the `findById`
    method is used again to allow switch retrieval based on the `Id` type parameter.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although we don’t model the network as entities in the domain model, there is
    no issue in creating service classes to handle collections of network value objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a last service class for the topology and inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: Network service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This service is based primarily on a need to filter network collections based
    on the IP protocol. We can have collections of both IPv4 and IPv6 networks. This
    service provides the capacity to filter such collections based on the network
    IP protocol. The following code is used to create a `NetworkService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `filterAndRetrieveNetworks` method receives a list of networks and a predicate,
    to filter the list, as parameters. It returns a filtered list of networks.
  prefs: []
  type: TYPE_NORMAL
- en: With `NetworkService`, we conclude creating domain services.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating all these services, you’ll have a package and class structure
    like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The directory structure of domain services](img/B19777_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The directory structure of domain services
  prefs: []
  type: TYPE_NORMAL
- en: To drive the development of value objects, entities, specifications, and services,
    you can adopt a **Test-Driven Development** (**TDD**) approach, where you can
    start creating broken tests and then implement the correct classes and methods
    to make those tests pass. We did the contrary here to provide a big picture of
    the components we needed to create to build the Domain hexagon for the topology
    and inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created services that operate under the Domain hexagon level.
    Instead of putting more behaviors directly on entities, we created separate service
    classes to enable behaviors that we don’t consider inherently part of the entities.
    These services allow us to handle collections of routers, switches, and networks.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the development of the Application hexagon, we need to
    ensure the operations we created in the Domain hexagon work as expected; otherwise,
    the upstream hexagons will break when performing these operations. So, in the
    next section, we’ll see how to test the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Domain hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the Domain hexagon appropriately, we should rely only on its components,
    ignoring anything coming from other hexagons. After all, these hexagons should
    depend on the Domain hexagon and not the other way around. As we have already
    seen, the Domain hexagon concentrates on the core system logic. It is from that
    logic that we derive the structure and behavior of the Application and Framework
    hexagons. By building a robust and well-tested Domain hexagon, we build a solid
    foundation for the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the operations performed by the topology and inventory system, we can
    consider adding, removing, and searching network assets as the most important
    ones. We’ll use the following steps to test these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by seeing how we can test the addition of network equipment, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `addNetworkToSwitch` method checks the successful path when the system
    can add a network to a switch. The following test checks the unhappy path for
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addNetworkToSwitch_failBecauseSameNetworkAddress` method checks the unsuccessful
    path when we try to add a network that already exists in the switch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have test scenarios where we want to add a switch to an edge router,
    as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we try to add a switch that is for a different country than the edge router,
    the `addSwitchToEdgeRouter` method checks the successful path while the `addSwitchToEdgeRouter_failBecauseEquipmentOfDifferentCountries`
    method checks the unsuccessful one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have test scenarios where we want to add an edge router to a core
    router, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addEdgeToCoreRouter_failBecauseRoutersOfDifferentCountries` method checks
    the unsuccessful path when the edge and core routers are in different countries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have test scenarios where we want to add a core router to another
    core router, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `addCoreToCoreRouter` method checks the successful path when we can add
    a core router to another one. In the following code snippet, we have the unhappy
    path for this method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addCoreToCoreRouter_failBecauseRoutersOfSameIp` method checks the unsuccessful
    path when we try to add core routers with the same IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these tests, we can also check whether the specifications work as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, there are other scenarios where it’s necessary to remove any router from
    a core router, a switch from an edge router, and a network from a switch, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `removeRouter` test method checks whether we can remove an edge router
    from a core router. In the following code snippet, we test the removal with a
    switch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `removeSwitch` test method checks whether we can remove a switch from an
    edge router. In the following code snippet, we test removal with a network:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `removeNetwork` test method checks whether we can remove a network from
    a switch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the adding and removing operations, we have to test the filter and retrieve
    operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To filter routers by type, we implement the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `filterRouterByType` method tests the operations available on the `RouterService`
    class. In the preceding case, we check whether the `filterAndRetrieveRouter` method
    can really filter and retrieve `CORE` or `EDGE` routers from a list containing
    different types of routers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To filter routers by vendor, we have the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using a predicate provided by the `getVendorPredicate` method, we call `filterAndRetrieveRouter`
    from the `RouterService` class. Then, we check whether the retrieved router model
    is what we are looking for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we test the same `filterRouterByLocation` method but with a different
    predicate, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling the `getCountryPredicate` method, we receive the predicate to filter
    routers by country. The result of this method is stored in the `actualCountry`
    variable, which we use in the test assertion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we test the `filterRouterByModel` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The goal here is to confirm whether the `filterAndRetrieveRouter` method works
    as expected when we need to filter router lists based on the router model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we have a test for the `filterAndRetrieveSwitch` method from the `SwitchService`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The goal here is to check whether it is possible to filter switch lists using
    the predicate provided by the `getSwitchTypePredicate` method. This is the predicate
    we use to filter switch lists by type. Finally, the `assertEquals` method checks
    whether the expected switch type matches what we expect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we test the operations to retrieve routers and switches by using their
    IDs, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `findRouterById`, we test the `findById` method from `RouterService`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we implement the `findSwitchById` method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `findSwitchById`, we test the `findById` method from `SwitchService`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After implementing and executing these tests, you should see the following
    output, showing that `19` tests were executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The successful execution of these tests assures us that the most fundamental
    operations from the Domain hexagon work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the green light we need to move ahead and start the development of the
    Application hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the topology and inventory system we developed in previous chapters,
    this chapter provided a hands-on approach to the early steps of developing a hexagonal
    system. We started by bootstrapping the Domain hexagon as a modularized Maven
    project and using the JPMS.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly analyzed and understood the problem domain as it relates to the management
    of network assets. Then, we translated the problem domain into a domain model
    based on value objects, entities, specifications, and services. Finally, we tested
    everything we’ve done to ensure things won’t break when we start to develop the
    Application hexagon on top of the Domain one.
  prefs: []
  type: TYPE_NORMAL
- en: By learning how to develop a robust Domain hexagon, we lay a solid foundation
    that the Application and Framework hexagons can rely on. In the next chapter,
    we will learn how to build the Application hexagon by assembling the useful features
    and everything else we’ve created on the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which technologies are used to bootstrap the Domain hexagon as a modularized
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we start developing the Domain hexagon by creating value objects first?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we understand the problem domain, what’s the next step?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it so important to develop a robust and well-tested Domain hexagon?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven and the JPMS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because value objects are used to compose other value objects and entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to translate that problem domain into a domain model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because a robust Domain hexagon provides a solid foundation to develop the Application
    and Framework hexagons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
