<html><head></head><body>
		<div id="_idContainer100">
			<h1 class="chapter-number" id="_idParaDest-294"><a id="_idTextAnchor326"/>7</h1>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor327"/>Finding Bottlenecks and Optimizing Your Application</h1>
			<p>Finding what makes your application perform below your expectations can be difficult if you don’t follow a systematic approach. When optimizing an application, it’s important to focus your efforts on facts, not guesses. For that reason, in this chapter, we’ll leverage the tools and learnings from <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and we’ll tackle some common challenges by analyzing the footprints of the <span class="No-Break">changes applied.</span></p>
			<p>In this chapter, you will learn how to use observability tools to find the bottlenecks of your application and apply some common techniques of application optimization, such as caching and runtime tuning. You will also learn how to improve your application’s startup time and resource consumption by using native applications, which have been supported since Spring Boot <span class="No-Break">3’s release.</span></p>
			<p>We’ll run some load tests to apply stress to our application, and we’ll learn how to analyze <span class="No-Break">the results.</span></p>
			<p>In this chapter, we will go through the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Tuning the database <span class="No-Break">connection pool</span></li>
				<li><span class="No-Break">Caching dependencies</span></li>
				<li>Using <span class="No-Break">shared cache</span></li>
				<li>Using Testcontainers with <span class="No-Break">Redis cache</span></li>
				<li>Creating a native image using <span class="No-Break">Spring Boot</span></li>
				<li>Using GraalVM Tracing Agent to configure the <span class="No-Break">native application</span></li>
				<li>Creating a native executable using <span class="No-Break">Spring Boot</span></li>
				<li>Creating a native executable from <span class="No-Break">a JAR</span></li>
			</ul>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor328"/>Technical requirements</h1>
			<p>I created an application that we’ll optimize during this chapter. This application provides some RESTful APIs to manage football data. The application uses PostgreSQL as a data repository. You can find it on https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the <strong class="source-inline">chapter7/football</strong> folder. This application is already configured for observability, exposing a Prometheus endpoint with Actuator. To monitor the application, you can use Prometheus <span class="No-Break">and Grafana.</span></p>
			<p class="callout-heading">Prometheus configuration</p>
			<p class="callout">You will need to configure Prometheus, as explained in the <em class="italic">Integrating your application with Prometheus and Grafana</em> recipe in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. I have already prepared the <strong class="source-inline">prometheus.yml</strong> file. You will need to get the IP address of your computer and set the value in the <span class="No-Break"><strong class="source-inline">prometheus.yml</strong></span><span class="No-Break"> file.</span></p>
			<p>I created a Grafana dashboard to monitor the application’s performance. To make it, I used the following dashboard as a starting point and adapted it for our <span class="No-Break">purposes: </span><a href="https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/"><span class="No-Break">https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/</span></a><span class="No-Break">.</span></p>
			<p>In addition to PostgreSQL, Prometheus, and Grafana, we’ll also use Redis for some recipes. As usual, the simplest way to run all these services on your computer is using Docker. You can get Docker from the product page: <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>. I will explain how to deploy each tool in its <span class="No-Break">corresponding recipe.</span></p>
			<p>You may need a tool to execute SQL scripts in PostgreSQL. You can use the <strong class="source-inline">psql</strong> command-line tool or the more user-friendly <em class="italic">PgAdmin</em> tool. You can check the <em class="italic">Connect your application to PostgreSQL</em> recipe in <a href="B21646_05.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> for <span class="No-Break">more details.</span></p>
			<p>I prepared some JMeter tests to generate some load over the application. You can download JMeter from the project website <span class="No-Break">at </span><a href="https://jmeter.apache.org"><span class="No-Break">https://jmeter.apache.org</span></a><span class="No-Break">.</span></p>
			<p>For some of the recipes related to native applications, you will need the <strong class="bold">GraalVM</strong> JDK. You can follow the instructions to install it from the official website <span class="No-Break">at </span><a href="https://www.graalvm.org/downloads/"><span class="No-Break">https://www.graalvm.org/downloads/</span></a><span class="No-Break">.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7</span></a></p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor329"/>Tuning the database connection pool</h1>
			<p>Database connections are an expensive resource<a id="_idIndexMarker775"/> that can take some time when they’re created for the first time. For that reason, Spring Boot uses a technique known as connection pooling. When a connection pool<a id="_idIndexMarker776"/> is used, the application doesn’t create a direct connection to the database; instead, it requests an available connection to the connection pool. When the application doesn’t need a connection, it returns it to the pool. The connection pool usually creates some connections at the start of the application. When the connections are returned to the pool, they are not closed but reused by other parts of <span class="No-Break">the application.</span></p>
			<p>A common challenge when operating applications is deciding on the connection pool size. If the size is too small, under a certain load, some requests will take longer as they wait for a connection to become available in the pool. If the connection pool is too large, it will waste resources in the database server, as open connections <span class="No-Break">are expensive.</span></p>
			<p>In this recipe, we’ll learn how to monitor the database connection pool in a Spring Boot application using standard metrics and monitoring tools. We’ll use the techniques and tools learned in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor330"/>Getting ready</h2>
			<p>In this recipe, you will optimize an application that I have already prepared for this purpose. You can find the application in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <strong class="source-inline">chapter7/football</strong> folder. I recommend copying the folder’s content to your working directory, as we’ll apply different optimizations over the base project on <span class="No-Break">each recipe.</span></p>
			<p>The application uses PostgreSQL as a database engine and is configured for monitoring using Zipkin, Prometheus, and Grafana. You can run all these dependent services in Docker; for that purpose, I have prepared a <strong class="source-inline">docker-compose-base.yml</strong> file that you can find in the <strong class="source-inline">chapter7/docker</strong> folder. You can run this <strong class="source-inline">docker-compose-base.yml</strong> file by opening a terminal in the directory containing the file and executing the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker-compose -f docker-compose-base.yml up</pre>			<p>The Prometheus service has a configuration file named <strong class="source-inline">prometheus.yml</strong> that contains the application scrapping configuration. It points to my computer’s IP, but you will need to change it to your IP configuration. You should configure the Prometheus data source and the <em class="italic">SpringBoot APM Dashboard</em>. See the <em class="italic">Integrating your application with Prometheus and Grafana</em> recipe in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, for <span class="No-Break">more details.</span></p>
			<p>I have prepared a JMeter test<a id="_idIndexMarker777"/> to generate workload on the application. You can find it in <strong class="source-inline">chapter7/jmeter/Football.jmx</strong>. This test simulates a common use case for the sample Football Trading application. The test performs the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>One user buys <span class="No-Break">some cards.</span></li>
				<li>Another user buys <span class="No-Break">some cards.</span></li>
				<li>Both users try to use the cards in <span class="No-Break">their albums.</span></li>
				<li>Then, the first user gets all available cards from the second user and vice versa, the second user gets all available cards from the <span class="No-Break">first user.</span></li>
				<li>Both users examine the players on the cards from the <span class="No-Break">other user.</span></li>
				<li>They trade between them their <span class="No-Break">available cards.</span></li>
			</ol>
			<p>The test has 10 threads running simultaneously with no think time <span class="No-Break">between requests.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor331"/>How to do it…</h2>
			<p>We’ll launch the application and ensure we see the application metrics in Grafana. Ready to find the application bottleneck and optimize it? Let’s go <span class="No-Break">for it!</span></p>
			<ol>
				<li>First, we’ll start the application, and we’ll check that we see the application metrics in Grafana. I’ll assume you have already started all dependent services as explained in the <em class="italic">Getting </em><span class="No-Break"><em class="italic">ready</em></span><span class="No-Break"> section:</span><ul><li>Open Grafana at <strong class="source-inline">http://localhost:3000</strong>, then open the SpringBoot <span class="No-Break">APM Dashboard.</span></li><li>Check that you can see data in the <strong class="bold">Basic Statics</strong> and <strong class="bold">HikariCP </strong><span class="No-Break"><strong class="bold">Statics</strong></span><span class="No-Break"> sections.</span></li></ul></li>
				<li>Start the JMeter application and open the <strong class="source-inline">football.jmx</strong> file, which you can find in the <span class="No-Break"><strong class="source-inline">chapter7/jmeter</strong></span><span class="No-Break"> folder.</span></li>
				<li>Execute the JMeter test<a id="_idIndexMarker778"/> and wait until it finishes. The test execution can take some minutes <span class="No-Break">to complete:</span><ul><li>During the execution of the test, check<a id="_idIndexMarker779"/> the connection metrics in the <strong class="bold">HikariCP Statistics</strong> section <span class="No-Break">in Grafana.</span></li><li>You will see that there are <span class="No-Break">pending connections:</span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer089">
					<img alt="Figure 7.1: Hikari connection metrics" src="image/B21646_07_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Hikari connection metrics</p>
			<p class="list-inset">You can also see that the <strong class="bold">Connection Acquire Time</strong> value is over 4 ms all <span class="No-Break">the time.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer090">
					<img alt="Figure 7.2: Connection Acquire Time" src="image/B21646_07_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Connection Acquire Time</p>
			<ul>
				<li>You can see the results summary<a id="_idIndexMarker780"/> by opening the <strong class="bold">Summary </strong><span class="No-Break"><strong class="bold">Report</strong></span><span class="No-Break"> item.</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 7.3: Summary Report" src="image/B21646_07_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Summary Report</p>
			<p class="list-inset">You can also see them while the test<a id="_idIndexMarker781"/> runs, but the baseline will be taken <span class="No-Break">once completed.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 7.4: Summary Report results – baseline results" src="image/B21646_07_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Summary Report results – baseline results</p>
			<p class="list-inset">In my environment, the total throughput is 987.5 <strong class="bold">requests per second</strong> (<strong class="bold">RPS</strong>), and the most used request<a id="_idIndexMarker782"/> is <strong class="bold">get-user-player</strong>, with a total of 145,142 requests and a throughput of 798 RPS. Note that the average time of the <strong class="bold">get-user-player</strong> operation is 6 milliseconds. Save the results of executing this test on your computer, as we’ll compare them after <span class="No-Break">the optimizations.</span></p>
			<ol>
				<li value="4">Now, we’ll change the HikariCP settings by increasing the maximum number of database connections. For that, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and modify the <strong class="source-inline">spring.datasource.hikari.maximum-pool-size</strong> setting by increasing it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">.</span></li>
				<li>Let’s repeat the same performance<a id="_idIndexMarker783"/> test and see the difference. But before that, let’s do a clean-up of the data to execute the test in the <span class="No-Break">same conditions:</span><ol><li class="upper-roman">I prepared a script named <strong class="source-inline">cleanup.sql</strong> that you can run to clean up the database. You can find it in the <span class="No-Break"><strong class="source-inline">chapter7/dbscripts</strong></span><span class="No-Break"> folder.</span></li><li class="upper-roman">In JMeter, use the <strong class="bold">Clear all</strong> button to reset <span class="No-Break">the results.</span></li></ol></li>
				<li>Once the test is done, compare the results with the baseline. The results on my computer are <span class="No-Break">the following:</span><ul><li>The total throughput is 1,315 RPS. That is approximately a 33% performance increase compared to the baseline <span class="No-Break">987.5 RPS.</span></li><li>The <strong class="bold">get-user-player</strong> request throughput is 1,085.3 RPS. That is approximately a 36% performance increase compared to the baseline <span class="No-Break">798 RPS.</span></li><li>The average response time of the <strong class="bold">get-user-player</strong> operation is 2 milliseconds. In the baseline, it was 6 milliseconds. That is three <span class="No-Break">times faster.</span></li></ul><p class="list-inset">If you look at <strong class="bold">HikariCP Statistics</strong> in Grafana, you will see that there are no connections pending and the connection-acquire time has reduced. The connection acquire time metric on my computer is always below <span class="No-Break">10 microseconds.</span></p></li>
			</ol>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor332"/>How it works…</h2>
			<p>Spring Boot uses HikariCP as a JDBC<a id="_idIndexMarker784"/> data source connection pool. If you don’t specify any pool size, the default is 10. I configured the initial example with a maximum of four connections for learning purposes. During the initial load test, we observed in Grafana that the number of pending connections remained consistently above zero throughout the entire testing period. That means that there is always a request that is waiting for an available <span class="No-Break">database connection.</span></p>
			<p>As we saw with the connection acquire time metric, on average, the time waited to acquire a connection is 4 milliseconds. That means that for every request, we need to add 4 milliseconds for each database operation involved. For fast operations, such as <strong class="bold">get-user-player</strong>, that is two times the time required when there’s a connection available. Once we increased the size of the connection pool, this operation boosted its performance, and it was the most used operation in <span class="No-Break">this scenario.</span></p>
			<p>The rest of the operations also benefited from this new configuration, but as the request time with available connections is longer, the relative performance improvement is not <span class="No-Break">that high.</span></p>
			<p>In this recipe, we focused on the number of database connections. But the same approach can be applied to other types of application metrics, for instance, the number of Tomcat concurrent threads. You can use the observability data exposed by the application and tune your settings accordingly to adjust to <span class="No-Break">your workload.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor333"/>There’s more…</h2>
			<p>In this recipe, we fixed the connection availability by adding the maximum number of connections used simultaneously at a given moment, that is, 10 connections. As mentioned, database connections are an expensive resource that should be used wisely. Let’s consider a scenario with multiple instances of your service. Every additional connection for your application should be multiplied by the number of instances. Say you have 10 application instances; then, any additional connection should be multiplied <span class="No-Break">by 10.</span></p>
			<p>During the execution of the baseline test, we detected a maximum of six pending connections, so we added those six connections to the four initial connections. If the maximum number of pending connections happens only during a few spikes, we can adjust the number of maximum connections to 1 or 2 fewer connections than the maximum detected. For instance, in our scenario, we could adjust the number of maximum connections to 9, repeat the load test, and observe <span class="No-Break">the impact.</span></p>
			<p>Another potential adjustment is configuring the minimum and maximum number of connections. Then, if there is a spike and no available connections, HikariCP will create a connection to the database. Remember the time required to create the connection to the database and the time this connection will be idle. When the minimum and maximum connections are defined, HikariCP can close physical connections when idle. If the spike is too short, you may create a connection that will take longer than just waiting for an available connection, and then you will have an idle connection consuming resources in the <span class="No-Break">database server.</span></p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor334"/>Caching dependencies</h1>
			<p>The most common flow in the Football Trading application<a id="_idIndexMarker785"/> that we want to optimize is the following: sometimes, the users buy some cards, and after using them in their albums, they try to exchange the redundant cards they already have with other users. Before starting the exchange process, the users see which players are available from other users. There can be thousands and even millions of cards, but the total number of football players is around 700, and they are constantly retrieved from the Football <span class="No-Break">Trading application.</span></p>
			<p>Now, you want to optimize the application’s performance. So, you are considering using a cache mechanism to avoid retrieving data from the database that is accessed frequently but changes <span class="No-Break">very infrequently.</span></p>
			<p>In this recipe, you will learn how to identify a database bottleneck and how to apply the caching mechanisms provided by Spring Boot. You will learn how to measure the improvement using the observability tools you learned about in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor335"/>Getting ready</h2>
			<p>In this recipe, you will continue optimizing the application that I prepared for this purpose. You can use the version resulting from the <em class="italic">Tuning the database connection pool</em> recipe. You can find the application in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>As we explained in the previous recipe, you can run all dependent services in Docker by running the <strong class="source-inline">docker-compose-base.yml</strong> Docker Compose file that you can find in the <strong class="source-inline">chapter7/docker</strong> folder. For that, open a terminal and execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker-compose -f docker-compose-base.yml up</pre>			<p>We’ll use the same JMeter test we used in the previous recipe. You can find it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter7/jmeter/football.jmx</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor336"/>How to do it…</h2>
			<p>Let’s start by executing the JMeter load test<a id="_idIndexMarker786"/> to determine the performance baseline. Then, we’ll apply caching on different parts of the application, and we’ll measure <span class="No-Break">the improvements:</span></p>
			<ol>
				<li>We can use the results of the JMeter execution from the <em class="italic">Tuning database connection pool</em> <span class="No-Break">recipe test.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 7.5: JMeter summary report – baseline requests throughput detail" src="image/B21646_07_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: JMeter summary report – baseline requests throughput detail</p>
			<p class="list-inset">In my environment, the total throughput is 1,340.3 RPS, and the most used request is <strong class="bold">get-user-player</strong>, with a total of 145,683 requests and a throughput of 1,085.3 RPS. Save the results of executing this test on your computer, as we’ll compare them after <span class="No-Break">the optimizations.</span></p>
			<ol>
				<li value="2">Now that we have our application baseline, we’ll <span class="No-Break">enable caching:</span><ol><li class="upper-roman">First, add the <em class="italic">Spring Cache Abstraction</em> starter to the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></li></ol><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><ol><li class="upper-roman" value="2">Next, in the <strong class="source-inline">FootballApplication</strong> class, add the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">EnableCaching</strong></span><span class="No-Break"> annotation:</span></li></ol><pre class="source-code"><strong class="bold">@EnableCaching</strong>
@SpringBootApplication
public class FootballApplication {</pre></li>				<li>Next, we’ll modify<a id="_idIndexMarker787"/> the <strong class="source-inline">getPlayer</strong> method of the <strong class="source-inline">FootballService</strong> class to cache the responses. This is the method called in the <strong class="bold">get-user-players</strong> step in JMeter. For that, you only need to annotate the method with <strong class="source-inline">@Cacheable</strong> <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">@Cacheable(value = "players")</strong>
public Player getPlayer(Integer id) {
    return playerRepository.findById(id).map(p -&gt; playerMapper.map(p)).orElse(null);
}</pre></li>				<li>Let’s execute the JMeter test again. But before that, let’s do a cleanup of the data to execute the test in the <span class="No-Break">same conditions:</span><ol><li class="upper-roman">I prepared a script named <strong class="source-inline">cleanup.sql</strong> that you can run to clean up the database. You can find it in the <span class="No-Break"><strong class="source-inline">chapter7/dbscripts</strong></span><span class="No-Break"> folder.</span></li><li class="upper-roman">In JMeter, use the <strong class="bold">Clear all</strong> button to reset <span class="No-Break">the results.</span></li></ol></li>
				<li>Once the test is done, check the results and compare them with the baseline. The results on my computer are <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 7.6: Summary report after applying caching on the FootballService" src="image/B21646_07_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Summary report after applying caching on the FootballService</p>
			<ul>
				<li>The total throughput jumped to 1,806.7 RPS from 1,340.3 RPS, approximately a 34% <span class="No-Break">performance increase.</span></li>
				<li><strong class="bold">get-user-player</strong> requests are 1,458.5 RPS, and the baseline was 1,085.3 RPS, which means around a 34% performance increase <span class="No-Break">as well.</span></li>
				<li>The rest of the requests also increased by around 34% of the overall throughput. For instance, <strong class="bold">get-user-cards</strong> rose to 100.1 RPS from 74.5 RPS, and the other requests went from 37.2 RPS to <span class="No-Break">50.1 RPS.</span></li>
			</ul>
			<ol>
				<li value="6">Let’s use the caching in a different place<a id="_idIndexMarker788"/> in our application. Instead of applying the <strong class="source-inline">@Cacheable</strong> annotation in <strong class="source-inline">FootballService</strong>, apply the annotation in the <strong class="source-inline">PlayersController</strong> class in the <span class="No-Break"><strong class="source-inline">getPlayer</strong></span><span class="No-Break"> method:</span><pre class="source-code">
<strong class="bold">@Cacheable(value = "players")</strong>
@GetMapping("/{id}")
public Player getPlayer(@PathVariable Integer id) {
    return footballService.getPlayer(id);
}</pre></li>			</ol>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor337"/>How it works…</h2>
			<p>By adding the <em class="italic">Spring Cache Abstraction</em> starter and using the <strong class="source-inline">@EnableCaching</strong> annotation, Spring Boot inspects the Beans for the presence of caching annotations on public methods, and a proxy is created to intercept the method call and handle the caching behavior accordingly; in our case, the methods annotated with <strong class="source-inline">@Cacheable</strong>. Spring Boot registers a <strong class="source-inline">CacheManager</strong> Bean to handle the cached items, as we didn’t specify any specific <strong class="source-inline">CacheManager</strong>. Spring Boot uses the default implementation, a <strong class="source-inline">ConcurrentHashMap</strong> object, and it’s handled in the process. This approach is valid for elements that do not change and where the dataset is small. Otherwise, you may want to use an external shared cache. In the next recipe, we’ll tackle <span class="No-Break">this scenario.</span></p>
			<p>In this recipe, we optimized only <strong class="source-inline">get-user-player</strong>. It’s the best candidate for all operations performed in this recipe. The reason is that the operations that modify data frequently are not candidates for caching, so <strong class="source-inline">buy-cards</strong>, <strong class="source-inline">use-cards</strong>, and <strong class="source-inline">trade-cards</strong> cannot be cached as they modify the data and are frequently used. The only operations that read just data are <strong class="source-inline">get-user-cards</strong> and <strong class="source-inline">get-user-player</strong>. <strong class="source-inline">get-user-cards</strong> is not a good candidate as the cards available owned by a user change every time they buy cards, exchange cards, or use them in an album. That means that the cache will be updated frequently. In addition, the number of users is high, around 100,000, so adding all those elements to the application memory can be counterproductive. On the other hand, <strong class="source-inline">get-user-player</strong> just retrieves the player’s information. That information changes very infrequently, and there are just a few hundred players. For that reason, <strong class="source-inline">get-user-player</strong> is the best candidate <span class="No-Break">for caching.</span></p>
			<p>By adding the cache in the <strong class="source-inline">FootballService</strong> class, the throughput of that operation improved significantly, but it also benefited the rest of the operations. The reason is that even though it is a quick request on the database, it is the most frequent operation. The number of database connections available is defined by the <strong class="source-inline">hikaricp</strong> connection pool; we configured 10 connections. All operations should acquire a connection from <strong class="source-inline">hikaricp</strong>. As the most frequent operation is reduced, it’s easier for the rest of the operations<a id="_idIndexMarker789"/> to acquire a <span class="No-Break">connection faster.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor338"/>There’s more…</h2>
			<p>I recommend you check the metrics exposed by the application in Grafana while you run the tests. There are two main areas to observe in <span class="No-Break">this scenario:</span></p>
			<ul>
				<li><strong class="bold">Basic statistics</strong>: Here we can find the classic<a id="_idIndexMarker790"/> metrics for <span class="No-Break">every application:</span><ul><li><strong class="bold">CPU Usage</strong>: This is often the limiting factor for demanding computing applications. During the tests on my computer, it was always <span class="No-Break">under 70%.</span></li><li><strong class="bold">Heap Used</strong>: This is the heap memory used by our application. It could limit the performance of <span class="No-Break">our application.</span></li><li><strong class="bold">Non-heap Used</strong>: This is all other memory used by our application. It usually accounts for less than 30% of the total memory used by the application, and its usage remains<a id="_idIndexMarker791"/> more stable than <span class="No-Break">heap memory.</span></li></ul></li>
				<li><strong class="bold">HikariCP </strong><strong class="bold">S</strong><strong class="bold">tatistics</strong>: As we saw in the previous recipe, HikariCP is<a id="_idIndexMarker792"/> the default database connection pool in Spring Boot. Creating a database connection to PostgreSQL or any other database engine is expensive. You can check the following metrics related <span class="No-Break">to HikariCP:</span><ul><li><strong class="bold">Active</strong>: This is the number of connections out of the pool actively used to perform an operation in <span class="No-Break">the database.</span></li><li><strong class="bold">Idle</strong>: This is the number of available connections in the pool ready to be used <span class="No-Break">when needed.</span></li><li><strong class="bold">Pending</strong>: This is the number of operations waiting for an available connection to access the database. Ideally, this metric should <span class="No-Break">be 0.</span></li><li><strong class="bold">Connection creation time</strong>: This is the time spent creating the physical connection to <span class="No-Break">the database.</span></li><li><strong class="bold">Connection usage time</strong>: This is how long a connection is used before being returned to <span class="No-Break">the pool.</span></li><li><strong class="bold">Connection acquire time</strong>: This is the time required to get a connection. When there are idle connections, the time required will be very low. When there are pending connections, the time required will <span class="No-Break">be higher.</span></li></ul></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 7.7: HikariCP metrics in Grafana" src="image/B21646_07_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: HikariCP metrics in Grafana</p>
			<p>You may want to cache<a id="_idIndexMarker793"/> operations, as we did in this recipe, to reduce the number of connections to <span class="No-Break">the database.</span></p>
			<p>In the next recipe, we’ll learn how to use Redis as an external cache and how to <span class="No-Break">update it.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor339"/>Using shared cache</h1>
			<p>The sample Football Trading<a id="_idIndexMarker794"/> application needs to cover a new scenario. Some football players can play in different positions, sometimes as defenders and sometimes as midfielders. Players do not change their position frequently, but it may happen. As we learned in the previous recipe, caching the players can improve the application’s performance significantly. We assume it’s possible and recommended to have more than one application instance running simultaneously. When a player is updated, all the application instances should return the latest version of <span class="No-Break">the player.</span></p>
			<p>In this recipe, we’ll learn how to use an external cache shared among all application instances and how to update the cache when the underlying data <span class="No-Break">is modified.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor340"/>Getting ready</h2>
			<p>In this recipe, we’ll reuse the application resulting from the previous recipe, as it has already been configured for caching. I have prepared a working version in the GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It is in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>The application uses PostgreSQL<a id="_idIndexMarker795"/> as a database engine, configured for observability with Zipkin, Prometheus, <span class="No-Break">and Grafana.</span></p>
			<p>As we’ll add support for caching using Redis, we’ll need a Redis server. The easiest way to run Redis on your computer is <span class="No-Break">using Docker.</span></p>
			<p>I prepared a Docker Compose file named <strong class="source-inline">docker-compose-redis.yml</strong>, with all dependent services, that is, PostgreSQL, Zipkin, Prometheus, Grafana, and Redis. You can find that file in the <strong class="source-inline">chapter7/docker</strong> folder. To run all dependent services, open a terminal in the <strong class="source-inline">chapter7/docker</strong> folder and run the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker-compose -f docker-compose-redis.yml up</pre>			<p>I prepared a JMeter test to generate load for this recipe. You can find it in <strong class="source-inline">chapter7/jmeter/Football-updates.jmx</strong>. In addition to the flow implemented in the previous recipe, it updates the position of a football player from time <span class="No-Break">to time.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor341"/>How to do it…</h2>
			<p>We’ll start by preparing the application to use Redis, and later, we’ll ensure that the cache is updated when the players <span class="No-Break">are modified:</span></p>
			<ol>
				<li>First, we’ll add the <em class="italic">Spring Data Redis</em> starter dependency. For that, just add the following dependency in the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>You will need to add the following dependency to manage <span class="No-Break"><strong class="source-inline">LocalDate</strong></span><span class="No-Break"> fields:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.16.1&lt;/version&gt;
&lt;/dependency&gt;</pre></li>				<li>Next, we need to configure<a id="_idIndexMarker796"/> Redis. For that, we will register a <strong class="source-inline">RedisCacheConfiguration</strong> Bean. Let’s create a new configuration class; you can name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">RedisConfig</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@Configuration</strong>
public class RedisConfig {
    @Bean
    public <strong class="bold">RedisCacheConfiguration</strong> cacheConfiguration() {
        <strong class="bold">ObjectMapper mapper = new ObjectMapper();</strong>
<strong class="bold">        mapper.registerModule(new JavaTimeModule());</strong>
<strong class="bold">        Jackson2JsonRedisSerializer&lt;Player&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(mapper, Player.class);</strong>
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .disableCachingNullValues()
                <strong class="bold">.serializeValuesWith(SerializationPair.fromSerializer(serializer))</strong>;
    }
}</pre></li>				<li>Finally, you must ensure that the cache is updated when the underlying data is updated. Let’s modify the <strong class="source-inline">updatePlayerPosition</strong> method in the <strong class="source-inline">FootballService</strong> class by adding the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">CacheEvict</strong></span><span class="No-Break"> annotation:</span><pre class="source-code">
<strong class="bold">@CacheEvict(value = "players", key = "#id")</strong>
public Player updatePlayerPosition(Integer id,
                                   String position)</pre></li>				<li>Now, you can run the JMeter<a id="_idIndexMarker797"/> test to validate the application and measure the performance footprint. I prepared a test named <strong class="source-inline">Football-updates.jmx</strong> for that purpose. You can find it in the <strong class="source-inline">chapter7/jmeter</strong> folder. This test updates the player’s position randomly but very infrequently, then retrieves the player to validate that it has the <span class="No-Break">position updated.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 7.8: JMeter test, showing the details of the player update" src="image/B21646_07_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: JMeter test, showing the details of the player update</p>
			<p>On my computer, the total throughput is 1,497.5 RPS, and <strong class="source-inline">get-user-players</strong> is 1,210.6 RPS. The performance of Redis caching is slightly lower than in-process caching. However, externalizing the cache makes it possible to scale horizontally by adding <span class="No-Break">additional instances.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor342"/>How it works…</h2>
			<p>When adding an external caching<a id="_idIndexMarker798"/> implementation, the application needs to serialize the objects to be cached to send them over the network and save them in Redis. The default Redis configuration can manage basic types such as <strong class="source-inline">String</strong> or <strong class="source-inline">int</strong> with no additional configuration. However, in this sample application, we need to cache <strong class="source-inline">Player</strong> objects. To use the default configuration, the <strong class="source-inline">Player</strong> class should implement the <span class="No-Break"><strong class="source-inline">Serializable</strong></span><span class="No-Break"> interface.</span></p>
			<p>To avoid modifying our domain classes, we configured a <strong class="source-inline">Jackson2JsonRedisSerializer</strong> serializer. This serializer represents the objects as JSON strings. The player has a catch with the <strong class="source-inline">birthDate</strong> field, as it is of the <strong class="source-inline">LocalDate</strong> type and cannot be managed with the default implementation. That is the reason we added the <strong class="source-inline">com.fasterxml.jackson.datatype:jackson-datatype-jsr310</strong> dependency and registered <strong class="source-inline">JavaTimeModule</strong> in <strong class="source-inline">ObjectMapper</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">RedisCacheConfiguration</strong></span><span class="No-Break">.</span></p>
			<p>It’s important to consider the implications of using an external <span class="No-Break">cache repository:</span></p>
			<ul>
				<li>As we just learned, we must ensure the cached objects can <span class="No-Break">be serialized.</span></li>
				<li>You need to consider the network latency as well. I executed all load tests locally on my computer, so there was no network latency. In real environments, it can also impact the performance of <span class="No-Break">the application.</span></li>
				<li>The caching server may become the new bottleneck. Redis is very performant, but it may imply adding new resources to your solution, such as <span class="No-Break">new servers.</span></li>
			</ul>
			<p>I didn’t notice significant performance differences in my load test results because everything ran on the same computer; however, you may expect slight differences in a production environment with services distributed across <span class="No-Break">different servers.</span></p>
			<p>You must configure the server address if you run Redis on a different server. By default, the <em class="italic">Spring Data Redis</em> starter assumes that Redis runs on <strong class="source-inline">localhost</strong> and listens to <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">6379</strong></span><span class="No-Break">.</span></p>
			<p>In this recipe, we used the <strong class="source-inline">@CacheEvict</strong> annotation to update the cache. This annotation deletes the entry using a key. By default, this annotation uses all method parameters as the cache entry key. However, the <strong class="source-inline">updatePlayerPosition</strong> method has two parameters: the player <strong class="source-inline">id</strong> and the new <strong class="source-inline">position</strong>. As the key is just the player <strong class="source-inline">id</strong>, we specified that in the <strong class="source-inline">position</strong> field of the <strong class="source-inline">@CacheEvict</strong> annotation. Other options, such as clearing<a id="_idIndexMarker799"/> all entries, don’t apply to <span class="No-Break">our scenario.</span></p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor343"/>Using Testcontainers with Redis cache</h1>
			<p>If you have executed<a id="_idIndexMarker800"/> the automated<a id="_idIndexMarker801"/> tests available in the sample project in the previous recipe, you may have noticed that the tests using methods that require Redis are failing. The reason is that Redis is not available during the execution of <span class="No-Break">the tests.</span></p>
			<p>In this recipe, we’ll learn how to set up a Redis server hosted as a Docker container <span class="No-Break">using Testcontainers.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor344"/>Getting ready</h2>
			<p>In this recipe, we’ll create the tests for the project created in the <em class="italic">Using shared cache</em> recipe. If you haven’t completed it yet, use the version I prepared as a starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>As we use Testcontainers, you will need Docker installed on <span class="No-Break">your computer.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor345"/>How to do it…</h2>
			<p>We like reliable applications. Let’s make our <span class="No-Break">tests work!</span></p>
			<ol>
				<li>We’ll make all changes in the <strong class="source-inline">FootballServiceTest</strong> class. So, open it and add a new static field of type <strong class="source-inline">GenericContainer</strong>. We’ll expose the default Redis port at <strong class="source-inline">6379</strong>, and we’ll use the latest <span class="No-Break"><strong class="source-inline">redis</strong></span><span class="No-Break"> image:</span><pre class="source-code">
static GenericContainer&lt;?&gt; redisContainer = new GenericContainer&lt;&gt;("<strong class="bold">redis:latest</strong>").withExposedPorts(<strong class="bold">6379</strong>);</pre></li>				<li>Next, we’ll modify<a id="_idIndexMarker802"/> the <strong class="source-inline">FootballServiceTest.Initializer</strong> class, by adding<a id="_idIndexMarker803"/> the properties to configure the connection <span class="No-Break">to Redis:</span><pre class="source-code">
static class Initializer
            implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    public void initialize(ConfigurableApplicationContext configurableApplicationContext) {
        TestPropertyValues.of(
           "spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),
           "spring.datasource.username=" + postgreSQLContainer.getUsername(),
           "spring.datasource.password=" + postgreSQLContainer.getPassword(),
           "<strong class="bold">spring.data.redis.host=" + redisContainer.getHost()</strong>,
           <strong class="bold">"spring.data.redis.port=" + redisContainer.getMappedPort(6379))</strong>
                    .applyTo(configurableApplicationContext.getEnvironment());
    }
}</pre></li>				<li>Finally, start the container before executing <span class="No-Break">the tests:</span><pre class="source-code">
@BeforeAll
public static void startContainer() {
    postgreSQLContainer.start();
    <strong class="bold">redisContainer.start();</strong>
}</pre></li>				<li>You can run the tests now. They should <span class="No-Break">work fine!</span></li>
			</ol>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor346"/>How it works…</h2>
			<p>To integrate Redis<a id="_idIndexMarker804"/> into our tests, we only need an available Redis<a id="_idIndexMarker805"/> server. There is a specialized Redis module<a id="_idIndexMarker806"/> in Testcontainers. You can find it at <a href="https://testcontainers.com/modules/redis/">https://testcontainers.com/modules/redis/</a>. As the integration is pretty simple, we can use just <strong class="source-inline">GenericContainer</strong> instead of the <span class="No-Break">specialized </span><span class="No-Break"><strong class="source-inline">RedisContainer</strong></span><span class="No-Break">.</span></p>
			<p>As we learned in previous recipes, by adding the <strong class="source-inline">@Testcontainers</strong> annotation in our test class, it automatically scans all container fields and integrates them into the test. <strong class="source-inline">FootballServiceTest</strong> was already annotated with <strong class="source-inline">@Testcontainers</strong> as it integrated PostgreSQL. We only needed to add a new container, in this case just <strong class="source-inline">GenericContainer</strong>, and perform the basic configuration to set it up. That is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Configure the container with the minimum configuration: image and <span class="No-Break">exposed port.</span></li>
				<li>Set the Redis configuration connection data in the application context. We did this in the <strong class="source-inline">FootballServiceTest.Initializer</strong> class. The Redis starter expects the configuration under <strong class="source-inline">spring.data.redis</strong>. We added the host and port, but only the port is required. By default, it expects the host <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">localhost</strong></span><span class="No-Break">.</span></li>
				<li>Start the container before<a id="_idIndexMarker807"/> the test execution. We did it in the method<a id="_idIndexMarker808"/> annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@BeforeAll</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor347"/>Creating a native image using Spring Boot</h1>
			<p>Usually, when we design solutions<a id="_idIndexMarker809"/> using a microservice-oriented<a id="_idIndexMarker810"/> approach, we imagine that we can easily scale our applications by adding and removing new instances of our application, and we also imagine that this process happens immediately. However, starting new instances of our application can take longer than we initially expected. Spring Boot orchestrates Bean initialization, dependency injection, and event handling during application startup, and most of these steps happen dynamically. This is not a major issue for small applications, but for complex applications, this process can take up to minutes <span class="No-Break">to complete.</span></p>
			<p>Another important factor when designing applications is the efficient use of computing resources. We want the applications to consume as little memory as possible and process the <span class="No-Break">workload efficiently.</span></p>
			<p>For this kind of scenario, we can consider creating native applications, that is, applications that are built as final binaries for a specific processor family and operating system. A normal Java application generates intermediate code<a id="_idIndexMarker811"/> that is processed by the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) and converted into binary code during the application runtime. In a native application, this process happens during <span class="No-Break">build time.</span></p>
			<p>In this recipe, we’ll learn how to create a new Spring Boot <span class="No-Break">native application.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor348"/>Getting ready</h2>
			<p>For this recipe, we’ll need Docker. You can check the <em class="italic">Technical requirements</em> section of this chapter for <span class="No-Break">more information.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor349"/>How to do it…</h2>
			<p>Let’s create a native application using <span class="No-Break">Spring Boot!</span></p>
			<ol>
				<li>Open the <em class="italic">Spring Boot Initializr</em> tool at <a href="https://start.spring.io">https://start.spring.io</a> and use the same options as you did in the <em class="italic">Create a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, and use the same parameters, except the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballnative</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">GraalVM </strong><span class="No-Break"><strong class="bold">Native Support</strong></span></li></ul></li>
				<li>Next, create a sample RESTful<a id="_idIndexMarker812"/> controller; for instance, create a <strong class="source-inline">TeamController</strong> controller<a id="_idIndexMarker813"/> and a method that returns a list <span class="No-Break">of teams:</span><pre class="source-code">
@RequestMapping("/teams")
@RestController
public class TeamController {
    @GetMapping
    public List&lt;String&gt; getTeams() {
        return List.of("Spain", "Zambia", "Brazil");
    }
}</pre></li>				<li>You can run the application on the JVM as usual, but what we’ll do now is create a native Docker image. For that, open your terminal and execute the following <span class="No-Break">Maven command:</span><pre class="source-code">
mvnw -Pnative spring-boot:build-image</pre><p class="list-inset">Be patient, as this step can take up to a few minutes to complete depending on the resources of <span class="No-Break">your computer.</span></p></li>				<li>Once the build completes, you can run the Docker image with our native application by executing the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
docker run --rm -p 8080:8080 footballnative:0.0.1-SNAPSHOT</pre></li>				<li>Now, you can perform a request to the RESTful application normally; for instance, you can use the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> command:</span><pre class="source-code">
curl http://localhost:8080/teams</pre></li>			</ol>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor350"/>How it works…</h2>
			<p>The GraalVM Native Support dependency adds a new <strong class="source-inline">native</strong> profile that can be used with the standard Spring Boot <strong class="source-inline">build-image</strong> goal to generate<a id="_idIndexMarker814"/> an image that targets <strong class="bold">GraalVM</strong>. GraalVM is a Java runtime that can compile your applications <strong class="bold">Ahead of Time</strong> (<strong class="bold">AOT</strong>) into native executables with low<a id="_idIndexMarker815"/> resource usage, fast startup, and improved security. To create the native image, the Maven plugin builds the native GraalVM executable in a Docker container using <strong class="bold">Paketo Buildpacks</strong>. Paketo Buildpacks are a set of community-driven<a id="_idIndexMarker816"/> tools that simplify the process of building and deploying applications as container images. That is the reason you don’t need to download GraalVM tools on <span class="No-Break">your computer.</span></p>
			<p>The result is a Docker image<a id="_idIndexMarker817"/> that contains our application<a id="_idIndexMarker818"/> as a native executable. Just as a reference for performance improvements, the application takes around 1.5 seconds to start on my computer running on the JVM, while the native image takes 0.07 seconds to do the same. That is around 21 times faster. However, when running 10,000 requests, the total throughput of both versions is pretty similar, with the JVM version being a bit better performant. That could be because the native version runs on Docker, while the JVM runs directly on my computer. I prepared a JMeter test that you can use to compare the results on your computer. You can find a test named <strong class="source-inline">teams-native.jmx</strong> in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter7/jmeter</strong></span><span class="No-Break"> folder.</span></p>
			<p>A native application is not a silver bullet that fits all scenarios. You need to consider that some features require dynamic processing during runtime, and they are difficult to handle with native applications. If your application doesn’t have a quick boot-time requirement, native applications do not add many benefits and there can be many inconveniences. In terms of performance, a JVM application performs as well as a native application in the long term. That is, after warming up, it works as well as a native one; there can be some gains in terms<a id="_idIndexMarker819"/> of memory management, but in terms<a id="_idIndexMarker820"/> of performance, they are <span class="No-Break">quite similar.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor351"/>Using GraalVM Tracing Agent to configure the native application</h1>
			<p>The small native application<a id="_idIndexMarker821"/> we created in the previous recipe<a id="_idIndexMarker822"/> looks so promising that we’ve decided to build a bigger football application as a <span class="No-Break">native app.</span></p>
			<p>The application we created in the <em class="italic">Creating a native image using Spring Boot</em> recipe didn’t require any special configuration. But native applications are built AOT. That means the compiler needs to analyze all code statically and detect the code reached during runtime. There are <a id="_idIndexMarker823"/>some Java technologies, such as the <strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>), <strong class="bold">Reflection</strong>, <strong class="bold">dynamic proxy</strong> objects, and class-path<a id="_idIndexMarker824"/> resources, that are very<a id="_idIndexMarker825"/> difficult to detect just by using static code analysis. The native compiler can use configuration files to include the required components in the final binary. As you may have figured out, the difficult part is configuring those files by detecting the components to be included in the final binary. For that purpose, GraalVM provides an agent that traces all usages to those types of technologies during the execution of an application on a regular <span class="No-Break">JVM application.</span></p>
			<p>In this recipe, we will build as a native image the sample application provided in this chapter. If you try to build the application as a native image as is, you will find some errors during runtime. In this recipe, we’ll learn how to use GraalVM Tracing Agent to find all the required components and build a native image for an existing application. Then, you will be able to run your application <span class="No-Break">in Docker.</span></p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor352"/>Getting ready</h2>
			<p>In this recipe, we’ll adapt the application you created in the <em class="italic">Using Testcontainers with Redis cache</em> recipe. If you haven’t finished it yet, you can use a functional project I’ve provided as a starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a> in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You will need the GraalVM JDK installed on your computer. You can install it following the instructions<a id="_idIndexMarker826"/> from the official website <span class="No-Break">at </span><a href="https://www.graalvm.org/downloads/"><span class="No-Break">https://www.graalvm.org/downloads/</span></a><span class="No-Break">.</span></p>
			<p>The application depends on PostgreSQL, Redis, and other services. As we’ll see in the <em class="italic">How to do it…</em> section, we’ll run the application as a Docker container. To facilitate the execution in your development computer, I prepared a Docker Compose file named <strong class="source-inline">docker-compose-all.yml</strong> with the application and all <span class="No-Break">dependent services.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor353"/>How to do it…</h2>
			<p>Let’s build a native executable<a id="_idIndexMarker827"/> image of our Spring Boot<a id="_idIndexMarker828"/> application. We’ll see how fast it runs now! Remember that we initially created this application as a regular <span class="No-Break">JVM application:</span></p>
			<ol>
				<li>First, we’ll add the <em class="italic">GraalVM Native Support</em> plugin to our <strong class="source-inline">pom.xml</strong> application. You should include the following configuration in the <span class="No-Break"><strong class="source-inline">build/plugins</strong></span><span class="No-Break"> element:</span><pre class="source-code">
&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;</pre></li>				<li>Next, we’ll need to add the Hibernate Enhance plugin as well. You should include the following configuration in the <span class="No-Break"><strong class="source-inline">build/plugins</strong></span><span class="No-Break"> element:</span><pre class="source-code">
&lt;plugin&gt;
    &lt;groupId&gt;org.hibernate.orm.tooling&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-enhance-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${hibernate.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;enhance&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;enhance&lt;/goal&gt;
            &lt;/goals&gt;
             &lt;configuration&gt;
                 &lt;enableLazyInitialization&gt;true&lt;/enableLazyInitialization&gt;
                 &lt;enableDirtyTracking&gt;true&lt;/enableDirtyTracking&gt;
                 &lt;enableAssociationManagement&gt;true&lt;/enableAssociationManagement&gt;
             &lt;/configuration&gt;
         &lt;/execution&gt;
     &lt;/executions&gt;
&lt;/plugin&gt;</pre></li>				<li>In this step, we’ll run the application<a id="_idIndexMarker829"/> using the GraalVM JVM<a id="_idIndexMarker830"/> with a special setting to trace the components that our application uses at runtime. The native compiler will use these traces to include those components in the final <span class="No-Break">binary executable:</span><ul><li>This step requires that you use the GraalVM JVM. Depending on which installation method you used, switching Java versions may differ. I used the <em class="italic">SDKMAN!</em> tool, which just executes the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
sdk use java 21-graalce</pre></li><li>To ensure you use the right JVM version, execute the following command in <span class="No-Break">your terminal:</span><pre class="source-code">java -version</pre></li><li>Check that the response includes GraalVM. As a reference, this is the output when I execute this command on <span class="No-Break">my computer:</span></li></ul></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 7.9: Sample java -version output for GraalVM JVM" src="image/B21646_07_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: Sample java -version output for GraalVM JVM</p>
			<ul>
				<li>Build the application<a id="_idIndexMarker831"/> normally, that is, by executing<a id="_idIndexMarker832"/> the <strong class="source-inline">package</strong> goal in Maven. Execute this command on a terminal in the application <span class="No-Break">root folder:</span><pre class="source-code">
./mvnw package</pre></li>				<li>This command creates the JAR file for your application. By default, the filename will be <strong class="source-inline">football-0.0.1-SNAPSHOT.jar</strong>, and it will be created in the <span class="No-Break"><strong class="source-inline">target</strong></span><span class="No-Break"> directory.</span></li>
				<li>Now, run the GraalVM tracing tool. That is achieved by executing the application specifying an agent for the JVM, that is, specifying the <strong class="source-inline">-agentlib:native-image-agent</strong> parameter and passing the folder to save the configuration output. We’ll set the folder where the native compiler expects the special configuration, that is, in <strong class="source-inline">src/main/resources/META-INF/native-image</strong>. This is how to execute your application specifying the GraalVM <span class="No-Break">tracing tool:</span><pre class="source-code">
java -Dspring.aot.enabled=true <strong class="bold">-agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image</strong> -jar target/football-0.0.1-SNAPSHOT.jar</pre></li>			</ul>
			<ol>
				<li value="4">Now that our application is up and running, let’s make sure that we cover all our bases. It’s important that we execute every path of the application so that we can trace all the dynamic components and ensure everything is ready to build the native application. You’ll see that the <strong class="source-inline">src/main/resources/META-INF/native-image</strong> folder contains several <span class="No-Break">JSON files.</span><p class="list-inset">When you complete the execution of all application paths, you can stop <span class="No-Break">the application.</span></p></li>
				<li>It’s time to build the native application! You can do it by executing the following <span class="No-Break">Maven command:</span><pre class="source-code">
mvn <strong class="bold">-Pnative</strong> spring-boot:build-image</pre><p class="list-inset">The native build is way longer than the JVM one as it requires a deep static code analysis. It can take several minutes to complete. Be patient, it’s worth <span class="No-Break">the time!</span></p></li>				<li>Finally, you can run the application by executing a Docker container. As the application references other services that can no longer be located using <strong class="source-inline">localhost</strong>, you will need to specify some settings as environment variables. To make it easier for you, I’ve prepared a Docker Compose file. I named it <strong class="source-inline">docker-compose-all.yml</strong>, and you can find it in the book’s <span class="No-Break">GitHub repository.</span><p class="list-inset">On my computer, the native<a id="_idIndexMarker833"/> version takes just 1.29 seconds to be ready<a id="_idIndexMarker834"/> to accept requests, compared to 6.62 seconds for the <span class="No-Break">JVM version.</span></p></li>
			</ol>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor354"/>How it works…</h2>
			<p>As explained in the <em class="italic">Creating a native image using Spring Boot</em> recipe, adding <em class="italic">GraalVM Native Support</em> to our application creates a new Spring Boot profile that we can use to build a Docker image with a native version of <span class="No-Break">our application.</span></p>
			<p>Some Hibernate operations generate Hibernate Proxy instances at runtime. If we don’t include the Hibernate Enhance plugin, the native compiler doesn’t have the required references at build time. For that reason, we need to include this plugin in <span class="No-Break">our application.</span></p>
			<p>In a simple application like the one created in the <em class="italic">Creating a native image using Spring Boot</em> recipe, we could skip <em class="italic">steps 3</em> and <em class="italic">4</em> and build the native application directly. However, we would realize that many operations do not work. That happens because the static build analysis doesn’t detect some dynamic loading components, mostly related to Hibernate. To tackle this issue, GraalVM provides the Tracing Agent tool. This tool traces all usages of JNI, Java Reflection, dynamic proxy objects (<strong class="source-inline">java.lang.reflect.Proxy</strong>), or class-path resources and saves them in the specified folder. The files generated are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">jni-config.json</strong>: This contains <span class="No-Break">JNI-related information</span></li>
				<li><strong class="source-inline">reflect-config.json</strong>: This contains <span class="No-Break">reflection-related details</span></li>
				<li><strong class="source-inline">proxy-config.json</strong>: This contains dynamic proxy <span class="No-Break">object details</span></li>
				<li><strong class="source-inline">resource-config.json</strong>: This contains class-path <span class="No-Break">resource information</span></li>
				<li><strong class="source-inline">predefined-classes-config.json</strong>: This contains metadata for <span class="No-Break">predefined classes</span></li>
				<li><strong class="source-inline">serialization-config.json</strong>: This contains <span class="No-Break">serialization-related data</span></li>
			</ul>
			<p>Then, the native compiler can use this configuration to include the referenced components in the final native executable. With this approach, we may find most of the components used at runtime, but some components may not be detected. In that case, we will need to include <span class="No-Break">them manually.</span></p>
			<p>As we run the application as a container, it’s executed in the context of Docker. This means that to locate the dependent services, such as PostgreSQL, it’s necessary to specify the internal Docker DNS name. In the previous recipes, all dependent services were accessible using <strong class="source-inline">localhost</strong>. For that reason, it’s necessary to specify the address of all dependent components, for instance, by setting the environment variables, and the easiest<a id="_idIndexMarker835"/> way to set these environment<a id="_idIndexMarker836"/> variables is by creating a Docker <span class="No-Break">Compose file.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor355"/>There’s more…</h2>
			<p>I executed the same JMeter tests we used in the <em class="italic">Using shared cache</em> recipe to compare the results of executing the same application running on a JVM and as a native application. In the following figure, you can see<a id="_idIndexMarker837"/> the results of running as a <span class="No-Break">native application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="Figure 7.10: JMeter throughput for native image running on Docker" src="image/B21646_07_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: JMeter throughput for native image running on Docker</p>
			<p>The results may seem surprising, as the application running as a native application performs significantly worse than the <span class="No-Break">JVM version.</span></p>
			<p>There are two factors to keep <span class="No-Break">in mind:</span></p>
			<ul>
				<li>The application now runs on Docker, while the application running on a JVM was executed directly on <span class="No-Break">my computer</span></li>
				<li>Once the application<a id="_idIndexMarker838"/> running on a JVM did the <strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) compilation, there were no significant gains in performance compared <span class="No-Break">to running</span></li>
			</ul>
			<p>In the next recipe, we’ll build the application natively instead of running on a container. Then, we’ll be able to compare the applications running with <span class="No-Break">similar conditions.</span></p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor356"/>Creating a native executable using Spring Boot</h1>
			<p>In the previous recipes, we built<a id="_idIndexMarker839"/> the native application<a id="_idIndexMarker840"/> to run as a container. Even if that is a convenient solution for most modern cloud-native scenarios, we may need to build a native executable to be executed directly without a <span class="No-Break">container engine.</span></p>
			<p>In this recipe, we’ll learn how to configure our computer to build native applications using the <span class="No-Break">GraalVM JDK.</span></p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor357"/>Getting ready</h2>
			<p>In this recipe, we’ll reuse the result of the <em class="italic">Using GraalVM Tracing Agent to configure the native application</em> recipe. I prepared a version of the application that you can use as a starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You will need the GraalVM JDK version 21 installed on your computer. You can follow the instructions from the official website <span class="No-Break">at </span><a href="https://www.graalvm.org/downloads/"><span class="No-Break">https://www.graalvm.org/downloads/</span></a><span class="No-Break">.</span></p>
			<p>The application depends on some services, such as PostgreSQL and Redis. To facilitate the execution of these services on your computer, you can reuse the <strong class="source-inline">docker-compose-redis.yml</strong> file prepared in the <em class="italic">Using shared </em><span class="No-Break"><em class="italic">cache</em></span><span class="No-Break"> recipe.</span></p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor358"/>How to do it…</h2>
			<p>Now, we’ll build our application<a id="_idIndexMarker841"/> as a native image that can be executed<a id="_idIndexMarker842"/> directly on <span class="No-Break">our computer:</span></p>
			<ol>
				<li>Ensure that you are using the GraalVM JVM for this process. For that, execute the <span class="No-Break">following command:</span><pre class="source-code">
java -version</pre><p class="list-inset">Verify that the message contains GraalVM, as shown in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p></li>				<li>Next, we’ll build the native executable. For that, open a terminal, change the directory to the root application folder, and execute the <span class="No-Break">following command:</span><pre class="source-code">
mvn -Pnative native:compile</pre><p class="list-inset">The native build takes longer than a regular JVM build, even up to a <span class="No-Break">few minutes.</span></p></li>				<li>Now, we have our binary executable in the <strong class="source-inline">target</strong> folder. Its name is the same as the project, this time without a version suffix. If you use Windows, it will be <strong class="source-inline">football.exe</strong>; in Unix-like systems, it will be just <strong class="source-inline">football</strong>. It’s time to run the application. As I’m using Linux, I’ll execute the following commands in <span class="No-Break">my terminal:</span><pre class="source-code">
cd target
./football</pre><p class="list-inset">Be sure that the dependent services, such as PostgreSQL and Redis, are up and running. As explained in the <em class="italic">Getting ready</em> section, you can use the <strong class="source-inline">docker-compose-redis.yml</strong> Docker Compose file to run all <span class="No-Break">dependent services.</span></p></li>			</ol>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor359"/>How it works…</h2>
			<p>As we did in the <em class="italic">Using GraalVM Tracing Agent to configure the native application</em> recipe, we must prepare our application for the native build. In this recipe, we reused the application, and we already had the hints for the dynamic components that GraalVM needs to generate the native application. However, if you start from scratch, you will need to prepare the configuration as we did in the <em class="italic">Using GraalVM Tracing Agent to configure the native </em><span class="No-Break"><em class="italic">application</em></span><span class="No-Break"> recipe.</span></p>
			<p>The Spring Boot <em class="italic">GraalVM Native Support</em> starter includes the native profile and the <strong class="source-inline">native:compile</strong> goal. This starter was already included in the application we reused in this recipe. This time, the compilation<a id="_idIndexMarker843"/> process runs on your computer instead<a id="_idIndexMarker844"/> of being executed in <span class="No-Break">a container.</span></p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor360"/>There’s more…</h2>
			<p>We can execute the load test using JMeter. This scenario is comparable to the one tested in the <em class="italic">Using Testcontainers with Redis cache</em> recipe, as both applications run directly on the computer and the dependent services run on Docker. These are the results of executing the same JMeter test on <span class="No-Break">my computer:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 7.11: JMeter summary for a native application" src="image/B21646_07_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: JMeter summary for a native application</p>
			<p>The throughput for <strong class="source-inline">get-user-player</strong> is 622.1 RPS, compared<a id="_idIndexMarker845"/> to the 566.3 RPS achieved using a JVM version. That is approximately a 9.86% increase. For the total requests, it is 773.5 RPS compared to 699.2 RPS, which is approximately a <span class="No-Break">10.6% increase.</span></p>
			<p>You must consider the benefits and trade-offs of using a native image. The main benefits are quick start-up time and better memory management and performance. The main trade-offs are the complexities of preparing the build image with all hints required to avoid runtime errors due to dynamic components. This configuration can be very painful and difficult to detect. You also need to consider the time required to build your application, which can be significantly longer than the <span class="No-Break">JVM counterpart.</span></p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor361"/>Creating a native executable from a JAR</h1>
			<p>As we realized during the completion<a id="_idIndexMarker846"/> of the previous recipes, building a native image<a id="_idIndexMarker847"/> takes way more time than building a regular JVM application. Another important consideration in certain environments is that GraalVM currently doesn’t support cross-platform builds. That means if we need to build an application for Linux, as it’s the most popular platform for server environments, but our development computer is a Windows or macOS computer, we cannot build the application directly. For these reasons, it could be a good choice to keep working with a regular JVM<a id="_idIndexMarker848"/> development process and create the native executable in a <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) platform. For instance, you can create a GitHub action for the native executable creation. In that way, we maintain the productivity for our development processes, we don’t need to change our development platform, and we can target platforms for <span class="No-Break">our application.</span></p>
			<p>In this recipe, we’ll generate a native executable for our football application using the <em class="italic">native-image</em> tool from the <span class="No-Break">GraalVM JDK.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor362"/>Getting ready</h2>
			<p>For this recipe, we’ll use<a id="_idIndexMarker849"/> the outcome<a id="_idIndexMarker850"/> from the <em class="italic">Creating a native executable using Spring Boot</em> recipe. Creating a native executable using a <em class="italic">native-image</em> tool requires an AOT-processed JAR. If you plan to convert another application into a native executable, follow the instructions from the previous recipe to generate the AOT-processed JAR file. If you haven’t completed the previous recipe yet, I prepared a working version that you can use as the starting point for this recipe. You can find it in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter7/recipe7-8/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You will need the <em class="italic">native-image</em> tool. This tool is part of the <span class="No-Break">GraalVM JDK.</span></p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor363"/>How to do it…</h2>
			<p>You can work normally with a JVM and keep the native build for CI. Let’s see what you will need to <span class="No-Break">do then!</span></p>
			<ol>
				<li>The first step is ensuring that you generate a JAR with AOT processed. For that, open your terminal at the root of your project and package the JAR file using the <strong class="source-inline">native</strong> profile with Maven. To do so, execute the <span class="No-Break">following command:</span><pre class="source-code">
./mvnw -Pnative package</pre></li>				<li>Next, we’ll create a new directory for our native executable. Let’s name it <strong class="source-inline">native</strong>. We’ll create this directory inside the <span class="No-Break"><strong class="source-inline">target</strong></span><span class="No-Break"> directory:</span><pre class="source-code">
mkdir target/native</pre><p class="list-inset">Change your current directory to the new <span class="No-Break">directory created:</span></p><pre class="source-code">cd target/native</pre></li>				<li>Now, we’ll extract the classes from the JAR file created in <em class="italic">step 1</em>. We’ll use the JAR tool, which is part of <span class="No-Break">the JDK:</span><pre class="source-code">
jar -xvf ../football-0.0.1-SNAPSHOT.jar</pre></li>				<li>We can build the native application. For that, we’ll use the <strong class="source-inline">native-image</strong> tool. We need to set the <span class="No-Break">following arguments:</span><ul><li><strong class="source-inline">-H:name=football</strong>: This is the executable filename; in our case, it will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">@META-INF/native-image/argfile</strong>: The <strong class="source-inline">@</strong> symbol indicates that the argument is read from a file. The specified file (<strong class="source-inline">argfile</strong>) likely contains additional configuration options or arguments for the native image <span class="No-Break">generation process.</span></li><li><strong class="source-inline">-cp</strong>: This argument sets the class path for the native image. We must pass the current directory, the <strong class="source-inline">BOOT-INF/classes</strong> directory, and all files contained in <strong class="source-inline">BOOT-INF/lib</strong>. This argument will look like this: <strong class="source-inline">-cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\</strong><span class="No-Break"><strong class="source-inline">n' ':'`</strong></span><span class="No-Break">.</span></li></ul><p class="list-inset">Then, to execute the <strong class="source-inline">native-image</strong> tool, you should<a id="_idIndexMarker851"/> execute the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker852"/></span><span class="No-Break"> command:</span></p><pre class="source-code">
<strong class="bold">native-image</strong> -H:Name=football @META-INF/native-image/argfile \
-cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'`</pre></li>				<li>Now, you have our application built as a native executable. You can execute it just by executing the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
./football</pre></li>			</ol>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor364"/>How it works…</h2>
			<p>As we reused the application from the previous recipes, we have already defined the hints. See the <em class="italic">Using GraalVM Tracing Agent to configure the native application</em> recipe for more details. To make them available for the native build, we must package our application using the <span class="No-Break"><strong class="source-inline">native</strong></span><span class="No-Break"> profile.</span></p>
			<p>A JAR file contains the classes and resources of our application in a ZIP file. We could use a standard ZIP tool, but the JAR tool is more convenient for our purposes. We passed the <strong class="source-inline">-xvf</strong> arguments with the JAR file to be processed. The <strong class="source-inline">x</strong> argument instructs the tool to extract the content. <strong class="source-inline">f</strong> means that it will get the content from a file that is passed as an argument as well. Finally, <strong class="source-inline">v</strong> is just to generate a verbose output; we could get rid of <span class="No-Break">this parameter.</span></p>
			<p>For the <strong class="source-inline">native-image</strong> tool, we need to pass all files contained in the <strong class="source-inline">BOOT-INF/lib</strong> directory. Unfortunately, the <strong class="source-inline">cp</strong> argument<a id="_idIndexMarker853"/> doesn’t admit<a id="_idIndexMarker854"/> wildcards. In Unix-like systems, you can use the <strong class="source-inline">find</strong> and <strong class="source-inline">tr</strong> tools. <strong class="source-inline">find</strong> lists the files in the directory, and <strong class="source-inline">tr</strong> removes <strong class="source-inline">\n</strong> and<strong class="source-inline">:</strong> characters. <strong class="source-inline">\n</strong> is the new <span class="No-Break">line character.</span></p>
		</div>
	</body></html>