<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Observables and Subscribers</h1>
                </header>
            
            <article>
                
<p>We already got a glimpse into the <kbd>Observable</kbd> and how it works in <a href="aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml" target="_blank">Chapter 1</a>, <em>Thinking Reactively</em>. You probably have many questions on how exactly it operates and what practical applications it holds. This chapter will provide a foundation for understanding how an <kbd>Observable</kbd> works as well as the critical relationship it has with the <kbd>Observer</kbd><strong>.</strong> We will also cover several ways to create an <kbd>Observable</kbd> as well make it useful by covering a few operators. To make the rest of the book flow smoothly, we will also cover all critical nuances head-on to build a solid foundation and not leave you with surprises later.</p>
<p>Here is what we will cover in this chapter:</p>
<ul>
<li>The <kbd>Observable</kbd></li>
<li>The <kbd>Observer</kbd></li>
<li>Other <kbd>Observable</kbd> factories</li>
<li><kbd>Single</kbd>, <kbd>Completable</kbd>, and <kbd>Maybe</kbd></li>
<li><kbd>Disposable</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Observable</h1>
                </header>
            
            <article>
                
<p>As introduced in <a href="aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml" target="_blank">Chapter 1</a>, <em>Thinking Reactively</em>, the <kbd>Observable</kbd> is a push-based<strong>,</strong> composable iterator. For a given <kbd>Observable&lt;T&gt;</kbd>, it pushes items (called emissions) of type <kbd>T</kbd> through a series of operators until it finally arrives at a final Observer, which consumes the items. We will cover several ways to create an <kbd>Observable</kbd>, but first, let's dive into how an <kbd>Observable</kbd> works through its <kbd>onNext()</kbd>, <kbd>onCompleted()</kbd>, and <kbd>onError()</kbd> calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Observables work</h1>
                </header>
            
            <article>
                
<p>Before we do anything else, we need to study how an <kbd>Observable</kbd> sequentially passes items down a chain to an <kbd>Observer</kbd>. At the highest level, an <kbd>Observable</kbd> works by passing three types of events:</p>
<ul>
<li><kbd>onNext()</kbd>: This passes each item one at a time from the source <kbd>Observable</kbd> all the way down to the <kbd>Observer</kbd>.</li>
<li><kbd>onComplete()</kbd>: This communicates a completion event all the way down to the <kbd>Observer</kbd>, indicating that no more <kbd>onNext()</kbd> calls will occur.</li>
<li><kbd>onError()</kbd>: This communicates an error up the chain to the <kbd>Observer</kbd>, where the <kbd>Observer</kbd> typically defines how to handle it. Unless a <kbd>retry()</kbd> operator is used to intercept the error, the <kbd>Observable</kbd> chain typically terminates, and no more emissions will occur.</li>
</ul>
<p>These three events are abstract methods in the <kbd>Observer</kbd> type, and we will cover some of the implementation later. For now, we will focus pragmatically on how they work in everyday usage.</p>
<div class="packt_infobox">In RxJava 1.0, the <kbd>onComplete()</kbd> event is actually called <kbd>onCompleted()</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Observable.create()</h1>
                </header>
            
            <article>
                
<p>Let's start with creating a source <kbd>Observable</kbd> using <kbd>Observable.create()</kbd>. Relatively speaking, a source <kbd>Observable</kbd> is an <kbd>Observable</kbd> where emissions originate from and is the starting point of our <kbd>Observable</kbd> chain.</p>
<p>The <kbd>Observable.create()</kbd> factory allows us to create an <kbd>Observable</kbd> by providing a lambda receiving an <kbd>Observable</kbd> emitter<strong>.</strong> We can call the <kbd>Observable</kbd> emitter's <kbd>onNext()</kbd> method to pass emissions  (one a time) up the chain as well as <kbd>onComplete()</kbd> to signal completion and communicate that there will be no more items. These <kbd>onNext()</kbd> calls will pass these items up the chain towards the <kbd>Observer</kbd>, where it will print each item, as shown in the following code snippet:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>emitter </span>-&gt; <span>{<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Delta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Epsilon"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onComplete</span><span>();<br/></span><span>        });<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>    }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma<br/>    RECEIVED: Delta<br/>    RECEIVED: Epsilon</pre>
<div class="packt_tip">In RxJava 1.0, ensure that you use <kbd>Observable.fromEmitter()</kbd> instead of <kbd>Observable.create()</kbd>. The latter is something entirely different in RxJava 1.0 and is only for advanced RxJava users.</div>
<p>The <kbd>onNext()</kbd> method is a way to hand each item, starting with <kbd>Alpha</kbd>, to the next step in the chain. In this example, the next step is the Observer, which prints the item using the <strong><kbd>s -&gt; System.out.println("RECEIVED: " + s)</kbd></strong> lambda. This lambda is invoked in the <kbd>onNext()</kbd> call of <kbd>Observer</kbd>, and we will  look at <kbd>Observer</kbd> more closely in a moment.</p>
<div class="packt_infobox">Note that the <kbd>Observable</kbd> contract (<a href="http://reactivex.io/documentation/contract.html" target="_blank">http://reactivex.io/documentation/contract.html</a>) dictates that emissions must be passed sequentially and one at a time. Emissions cannot be passed by an <kbd>Observable</kbd> concurrently or in parallel. This may seem like a limitation, but it does in fact simplify programs and make Rx easier to reason with. We will learn some powerful tricks to effectively leverage concurrency and parallelization in <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml" target="_blank">Chapter 6</a>, <em>Concurrency and Parallelization</em> , without breaking the <kbd>Observable</kbd> contract.</div>
<p>The <kbd>onComplete()</kbd> method is used to communicate up the chain to the <kbd>Observer</kbd> that no more items are coming. Observables can indeed be infinite, and if this is the case, the <kbd>onComplete()</kbd> event will never be called. Technically, a source could stop emitting <kbd>onNext()</kbd> calls and never call <kbd>onComplete()</kbd>. This would likely be bad design, though, if the source no longer plans to send emissions.</p>
<p>Although this particular example is unlikely to throw an error, we can catch errors that may occur within our <kbd>Observable.create()</kbd> block and emit them through <kbd>onError()</kbd>.<strong> </strong>This way, the error can be pushed up the chain and handled by th<strong>e</strong> <kbd>Observer</kbd>. This particular <kbd>Observer</kbd> that we have set up does not handle exceptions, but you can do that, as shown here:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>      public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source</span> <span>= </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>emitter </span>-&gt; <span>{<br/></span><span>          </span><span>try </span><span>{<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Delta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Epsilon"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onComplete</span><span>();<br/></span><span>          } </span><span>catch </span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>            </span><span>emitter</span><span>.</span><span>onError</span><span>(</span><span>e</span><span>);<br/></span><span>          }<br/></span><span>        });<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>),      Throwable::printStackTrace);<br/></span><span>      }<br/></span><span>   }</span></pre>
<p>Note that <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd> do not necessarily push directly to the final Observer. They can also push to an operator serving as the next step in the chain. In the following code, we derive new Observables with the <kbd>map()</kbd> and <kbd>filter()</kbd> operators, which will act between the source <kbd>Observable</kbd> and final <kbd>Observer</kbd> printing the items:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>      </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>emitter </span>-&gt; <span>{<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>          </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>          </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>          </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Delta"</span><span>);<br/></span><span>          </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Epsilon"</span><span>);<br/></span><span>          </span><span>emitter</span><span>.</span><span>onComplete</span><span>();<br/></span><span>        } </span><span>catch </span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>          </span><span>emitter</span><span>.</span><span>onError</span><span>(</span><span>e</span><span>);<br/></span><span>        }<br/></span><span>      });<br/></span><span>      </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>lengths </span><span>= </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>);<br/></span><span><br/></span><span>      </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>filtered </span><span>= </span><span>lengths</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>);<br/></span><span><br/></span><span>      </span><span>filtered</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+  <br/></span><span>      s</span><span>));    <br/></span><span>     }<br/></span><span>    }</span></pre>
<p>This is the output after running the code: </p>
<pre style="padding-left: 30px">    RECEIVED<span>: </span><span>5</span><span><br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>7</span></pre>
<p>With the <kbd>map()</kbd> and <kbd>filter()</kbd> operators between the source <kbd>Observable</kbd> and Observer, <kbd> onNext()</kbd> will hand each item to the  <kbd>map()</kbd> operator. Internally, it will act as an intermediary Observer and convert each string to its <kbd>length()</kbd>. This, in turn, will call <kbd>onNext()</kbd> on <kbd>filter()</kbd> to pass that integer, and the lambda condition <kbd>i -&gt; i &gt;= 5</kbd> will suppress emissions that fail to be at least five characters in length. Finally, the <kbd>filter()</kbd> operator will call <kbd>onNext()</kbd> to hand each item to the final <kbd>Observer</kbd> where they will be printed.</p>
<p>It is critical to note that the <kbd>map()</kbd> operator will yield a new <kbd>Observable&lt;Integer&gt;</kbd> derived off the original <kbd>Observable&lt;String&gt;</kbd>. The <kbd>filter()</kbd>will also return an <kbd>Observable&lt;Integer&gt;</kbd> but ignore emissions that fail to meet the criteria. Since operators such as <kbd>map()</kbd> and <kbd>filter()</kbd> yield new Observables (which internally use <kbd>Observer</kbd> implementations to receive emissions), we can chain all our returned Observables with the next operator rather than unnecessarily saving each one to an intermediary variable:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>      public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>emitter </span>-&gt; <span>{<br/></span><span>          </span><span>try </span><span>{<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Delta"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onNext</span><span>(</span><span>"Epsilon"</span><span>);<br/></span><span>            </span><span>emitter</span><span>.</span><span>onComplete</span><span>();<br/></span><span>          } </span><span>catch </span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>            </span><span>emitter</span><span>.</span><span>onError</span><span>(</span><span>e</span><span>);<br/></span><span>          }<br/></span><span>        });<br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>        .</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>       }<br/></span><span>    }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED<span>: </span><span>5</span><span><br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>7</span></pre>
<p>Chaining operators in this way is common (and encouraged) in reactive programming. It has a nice quality of being readable from left to right and top to bottom much like a book, and this helps in maintainability and legibility.</p>
<div class="packt_infobox">In RxJava 2.0, Observables no longer support emitting null values. You will immediately get a non-null exception if you create an <kbd>Observable</kbd> that attempts to emit a null value. If you need to emit a null, consider wrapping it in a Java 8 or Google Guava Optional.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Observable.just()</h1>
                </header>
            
            <article>
                
<p>Before we look at the <kbd>subscribe()</kbd> method a bit more, note that you likely will not need to use <kbd>Observable.create()</kbd> often. It can be helpful in hooking into certain sources that are not reactive, and we will see this in a couple of places later in this chapter. But typically, we use streamlined factories to create Observables for common sources.</p>
<p>In our previous example with <kbd>Observable.create()</kbd>, we could have used <kbd>Observable.just()</kbd> to accomplish this. We can pass it up to 10 items that we want to emit. It will invoke the <kbd>onNext()</kbd> call for each one and then invoke <kbd>onComplete()</kbd> when they all have been pushed:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>       </span><span> </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>          "Epsilon"</span><span>);<br/></span><span>        <br/></span><span>    source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>    }</span></pre>
<p>We can also use <kbd>Observable.fromIterable()</kbd> to emit the items from any Iterable type, such as a <kbd>List</kbd>. It also will call <kbd>onNext()</kbd> for each element and then call <kbd>onComplete()</kbd> after the iteration is complete. You will likely use this factory frequently since Iterables in Java are common and can easily be made reactive:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>java.util.Arrays</span><span>;<br/></span><span>    import </span><span>java.util.</span><span>List</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/><br/></span><span>        </span><span>List</span><span>&lt;</span><span>String</span><span>&gt; </span><span>items </span><span>=<br/></span><span>          </span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>fromIterable</span><span>(</span><span>items</span><span>);<br/></span><span>       </span><span> </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>   }</span></pre>
<p>We will explore other factories to create Observables later in this chapter, but for now, let's put that on hold and learn more about Observers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Observer interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd> methods actually define the Observer type, an abstract interface implemented throughout RxJava to communicate these events. This is the Observer definition in RxJava shown in the code snippet. Do not bother yourself about <kbd>onSubscribe()</kbd> for now, as we will cover it at the end of this chapter. Just bring your attention to the other three methods:</p>
<pre style="padding-left: 30px"><span>    package </span>io<span>.</span>reactivex<span>;<br/></span><span><br/></span><span>    import </span>io<span>.</span>reactivex<span>.</span>disposables<span>.</span>Disposable<span>;<br/></span><span><br/></span><span>    public interface </span><span>Observer</span><span>&lt;</span><span>T</span><span>&gt; </span><span>{</span><span><br/></span><span>      </span><span>void </span><span>onSubscribe</span><span>(</span>Disposable d<span>);<br/></span><span>      </span><span>void </span><span>onNext</span><span>(</span><span>T </span><span>value</span><span>);<br/></span><span>      </span><span>void </span><span>onError</span><span>(</span><span>Throwable </span><span>e</span><span>);<br/></span><span>      </span><span>void </span><span>onComplete</span><span>();</span><span><br/></span><span>   }</span></pre>
<p>Observers and source Observables are somewhat relative. In one context, a source Observable is where your <kbd>Observable</kbd> chain starts and where emissions originate. In our previous examples, you could say that the <kbd>Observable</kbd> returned from our <kbd>Observable.create()</kbd><strong> </strong>method or <kbd>Observable.just()</kbd> is the source <kbd>Observable</kbd>. But to the <kbd>filter()</kbd> operator, the <kbd>Observable</kbd> returned from the <kbd>map()</kbd> operator is the source. It has no idea where the emissions are originating from, and it just knows that it is receiving emissions from the operator immediately upstream from it, which come from <kbd>map()</kbd>.</p>
<p>Conversely, each <kbd>Observable</kbd> returned by an operator is internally an Observer that receives, transforms, and relays emissions to the next <kbd>Observer</kbd> downstream. It does not know whether the next <kbd>Observer</kbd> is another operator or the final Observer at the end of the chain. When we talk about the <kbd>Observer</kbd>, we are often talking about the final Observer at the end of the <kbd>Observable</kbd> chain that consumes the emissions. But each operator, such as <kbd>map()</kbd> and <kbd>filter()</kbd>, also implements <kbd>Observer</kbd> internally.</p>
<p>We will learn in detail about how operators are built in <a href="3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml">Chapter 9</a>, <em>Transformers and Custom Operators</em>. For now, we will focus on using an <kbd>Observer</kbd> for the <kbd>subscribe()</kbd> method.</p>
<div class="packt_infobox">In RxJava 1.0, the Subscriber essentially became a Observer in RxJava 2.0. There is an <kbd>Observer</kbd> type in RxJava 1.0 that defines the three event methods, but the Subscriber is what you passed to the <kbd>subscribe()</kbd> method, and it is implemented <kbd>Observer</kbd>. In RxJava 2.0, a Subscriber only exists when talking about Flowables, which we will discuss in <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing and subscribing to an Observer</h1>
                </header>
            
            <article>
                
<p>When you call the <kbd>subscribe()</kbd> method on an <kbd>Observable</kbd>, an <kbd>Observer</kbd> is used to consume these three events by implementing its methods. Instead of specifying lambda arguments like we were doing earlier, we can implement an <kbd>Observer</kbd> and pass an instance of it to the <kbd>subscribe()</kbd> method. Do not bother yourself about <kbd>onSubscribe()</kbd> at the moment. Just leave its implementation empty until we discuss it at the end of this chapter:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.</span><span>Observer</span><span>;<br/></span><span>    import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>          "Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observer</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>myObserver </span><span>= </span><span>new </span><span>Observer</span><span>&lt;</span><span>Integer</span><span>&gt;</span><span>() {<br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onSubscribe</span><span>(</span><span>Disposable </span><span>d</span><span>) {<br/>            //do nothing with Disposable, disregard for now </span><span><br/></span><span>          }<br/></span><span><br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onNext</span><span>(</span><span>Integer</span> <span>value</span><span>) {<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>value</span><span>);<br/></span><span>          }<br/></span><span><br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onError</span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>          }<br/></span><span><br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onComplete</span><span>() {<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>);<br/></span><span>          }<br/></span><span>         };<br/></span><span><br/></span><span>         </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>           .</span><span>subscribe</span><span>(</span><span>myObserver</span><span>);<br/></span><span>       }<br/></span><span>    }<br/></span><span><br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 5<br/>    RECEIVED: 5<br/>    RECEIVED: 5<br/>    RECEIVED: 7<br/>    Done!</pre>
<p>We quickly create an <kbd>Observer&lt;Integer&gt;</kbd> that serves as our <kbd>Observer</kbd>, and it will receive integer length emissions. Our <kbd>Observer</kbd> receives emissions at the end of an <kbd>Observable</kbd> chain and serves as the endpoint where the emissions are consumed. By consumed, this means they reach the end of the process where they are written to a database, text file, a server response, displayed in a UI, or (in this case) just printed to the console.</p>
<p>To further explain this example in detail, we start with string emissions at our source. We declare our <kbd>Observer</kbd> in advance and pass it to the <kbd>subscribe()</kbd> method at the end of our <kbd>Observable</kbd> chain. Note that each string is transformed to its length. The <kbd>onNext()</kbd> method receives each integer length emission and prints it using <kbd>System.out.println("RECEIVED: " + value)</kbd><span>. We will not get any errors running this simple process, but if one did occur anywhere in our <kbd>Observable</kbd> chain, it will be pushed to our  <kbd>onError()</kbd> implementation on <kbd>Observer</kbd>, where the stack trace of </span><kbd>Throwable</kbd><span> will be printed. Finally, when the source has no more emissions (after pushing</span> "<kbd>Epsilon</kbd>"<span>), it will call <kbd>onComplete()</kbd></span> <span>up the chain all the way to the Observer, where its <kbd>onComplete()</kbd> method will be called and print</span> <span class="packt_screen"><kbd>Done!</kbd></span><span> to the console.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shorthand Observers with lambdas</h1>
                </header>
            
            <article>
                
<p>Implementing an <kbd>Observer</kbd> is a bit verbose and cumbersome. Thankfully, the <kbd>subscribe()</kbd> method is overloaded to accept lambda arguments for our three events. This is likely what we will want to use for most cases, and we can specify three lambda parameters separated by commas: the <kbd>onNext</kbd> lambda, the <kbd>onError</kbd> lambda, and the <kbd>onComplete</kbd> lambda. For our previous example, we can consolidate our three method implementations using these three lambdas:</p>
<pre style="padding-left: 30px"><span>    Consumer</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>onNext </span><span>= </span><span>i </span>-&gt;  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: "          </span><span>+ </span><span>i</span><span>);<br/></span><span><br/></span><span>    Action </span><span>onComplete </span><span>= </span><span>() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>);<br/></span><span><br/></span><span>    Consumer</span><span>&lt;</span><span>Throwable</span><span>&gt; </span><span>onError </span><span>= </span><span>Throwable</span>::<span>printStackTrace</span><span>;</span><br/><br/></pre>
<p>We can pass these three lambdas as arguments to the <kbd>subscribe()</kbd> method, and it will use them to implement an <kbd>Observer</kbd> for us. This is much more concise and requires far less boilerplate code:</p>
<p> </p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>,<br/></span><span>          "Epsilon"</span><span>);<br/></span><span>        <br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>() </span>-&gt;  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span>      }<br/></span><span>   }</span><span><br/></span></pre>
<p>The output is as follows:</p>
<p> </p>
<pre style="padding-left: 30px">    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>7<br/></span>    Done<span>!</span></pre>
<p> </p>
<p>Note that there are other overloads for <kbd>subscribe()</kbd>. You can omit <kbd>onComplete()</kbd> and only implement <kbd>onNext()</kbd> and <kbd>onError()</kbd>. This will no longer perform any action for <kbd>onComplete()</kbd>, but there will likely be cases where you do not need one:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>          "Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>            </span><span>Throwable</span>::<span>printStackTrace</span><span>);<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>5<br/></span>    RECEIVED<span>: </span><span>7<br/></span></pre>
<p>As you have seen in earlier examples, you can even omit <kbd>onError</kbd> and just specify <kbd>onNext</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>,<br/></span><span>          "Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>   }<br/></span></pre>
<p>However, not implementing <kbd>onError()</kbd> is something you want to avoid doing in production. Errors that happen anywhere in the <kbd>Observable</kbd> chain will be propagated to <kbd>onError()</kbd> to be handled and then terminate the <kbd>Observable</kbd> with no more emissions. If you do not specify an action for <kbd>onError</kbd>, the error will go unhandled.</p>
<div class="packt_tip">You can use <kbd>retry()</kbd> operators to attempt recovery and resubscribe to an <kbd>Observable</kbd> if an error occurs. We will cover how to do that in the next chapter.</div>
<p>It is critical to note that most of the <kbd>subscribe()</kbd> overload variants (including the shorthand lambda ones we just covered) return a <kbd>Disposable</kbd> that we did not do anything with. <kbd>disposables</kbd> allow us to disconnect an <kbd>Observable</kbd> from an <kbd>Observer</kbd> so emissions are terminated early, which is critical for infinite or long-running Observables. We will cover <kbd>disposables</kbd> at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cold versus hot Observables</h1>
                </header>
            
            <article>
                
<p>There are subtle behaviors in a relationship between an <kbd>Observable</kbd> and an <kbd>Observer</kbd> depending on how the <kbd>Observable</kbd> is implemented. A major characteristic to be aware of is cold versus hot Observables, which defines how Observables behave when there are multiple Observers. First, we will cover cold Observables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cold Observables</h1>
                </header>
            
            <article>
                
<p>Cold Observables are much like a music CD that can be replayed to each listener, so each person can hear all the tracks at any time. In the same manner, cold Observables will replay the emissions to each <kbd>Observer</kbd>, ensuring that all Observers get all the data. Most data-driven Observables are cold, and this includes the <kbd>Observable.just()</kbd> and <kbd>Observable.fromIterable()</kbd> factories.</p>
<p>In the following example, we have two Observers subscribed to one <kbd>Observable</kbd>. The <kbd>Observable</kbd> will first play all the emissions to the first <kbd>Observer</kbd> and then call <kbd>onComplete()</kbd>. Then, it will play all the emissions again to the second <kbd>Observer</kbd> and call <kbd>onComplete()</kbd>. They both receive the same datasets by getting two separate streams each, which is typical behavior for a cold <kbd>Observable</kbd>:</p>
<pre style="padding-left: 30px"><span>      import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>      public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>,</span><span>"Delta"</span><span>,</span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>//first observer<br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1 Received: <br/>          " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>//second observer<br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2 Received:<br/>          " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>    }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    Observer 1 Received: Alpha<br/>    Observer 1 Received: Beta<br/>    Observer 1 Received: Gamma<br/>    Observer 1 Received: Delta<br/>    Observer 1 Received: Epsilon<br/>    Observer 2 Received: Alpha<br/>    Observer 2 Received: Beta<br/>    Observer 2 Received: Gamma<br/>    Observer 2 Received: Delta<br/>    Observer 2 Received: Epsilon</pre>
<p>Even if the second <kbd>Observer</kbd> transforms its emissions with operators, it will still get its own stream of emissions. Using operators such as <kbd>map()</kbd> and <kbd>filter()</kbd> against a cold <kbd>Observable</kbd> will still maintain the cold nature of the yielded Observables:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io</span><span>.reactivex.Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>,</span><span>"Delta"</span><span>,</span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>//first observer<br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1 Received:<br/>          " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>//second observer<br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt;= </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2 Received: " </span><span>+ <br/></span><span>        s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>   }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Observer 1 Received: Alpha<br/>    Observer 1 Received: Beta<br/>    Observer 1 Received: Gamma<br/>    Observer 1 Received: Delta<br/>    Observer 1 Received: Epsilon<br/>    Observer 2 Received: 5<br/>    Observer 2 Received: 5<br/>    Observer 2 Received: 5<br/>    Observer 2 Received: 7</pre>
<p>As stated earlier, <kbd>Observable</kbd> sources that emit finite datasets are usually cold.</p>
<p>Here is a more real-world example: Dave Moten's RxJava-JDBC (<a href="https://github.com/davidmoten/rxjava-jdbc">https://github.com/davidmoten/rxjava-jdbc</a>) allows you to create cold Observables built off of SQL database queries. We will not digress into this library for too long, but if you want to query a SQLite database, for instance, include the <strong>SQLite JDBC</strong> driver and <strong>RxJava-JDBC</strong> libraries in your project. You can then query a database table reactively, as shown in the following code snippet:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>com.github.davidmoten.rx.jdbc.ConnectionProviderFromUrl</span><span>;<br/></span><span>    import </span><span>com.github.davidmoten.rx.jdbc.Database</span><span>;<br/></span><span>    import </span><span>rx.Observable</span><span>;</span><span><br/></span><span>    import </span><span>java.sql.</span><span>Connection</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args)</span><span> {</span><span><br/></span><span>        </span><span>Connection </span><span>conn </span><span>= <br/></span><span>      new </span><span>ConnectionProviderFromUrl</span><span>(</span><span>"jdbc:sqlite:/home/thomas <br/>            /rexon_metals.db"</span><span>).</span><span>get</span><span>();<br/></span><span>        <br/></span><span>      Database </span><span>db </span><span>= </span><span>Database</span><span>.</span><span>from</span><span>(</span><span>conn</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>customerNames </span><span>=<br/></span><span>          </span><span>db</span><span>.</span><span>select</span><span>(</span><span>"SELECT NAME FROM CUSTOMER"</span><span>)<br/></span><span>          .</span><span>getAs</span><span>(</span><span>String.class</span><span>);<br/></span><span><br/></span><span>        </span><span>customerNames</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>));<br/></span><span>      }<br/></span><span>   }<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    LITE Industrial<br/>    Rex Tooling Inc<br/>    Re-Barre Construction<br/>    Prairie Construction<br/>    Marsh Lane Metal Works</pre>
<p>This SQL-driven <kbd>Observable</kbd> is cold. Many Observables emitting from finite data sources such as databases, text files, or JSON are cold. It is still important to note how the source <kbd>Observable</kbd> is architected. RxJava-JDBC will run the query each time for each <kbd>Observer</kbd>. This means that if the data changes in between two subscriptions, the second <kbd>Observer</kbd> will get different emissions than the first one. But the <kbd>Observable</kbd> is still cold since it is <em>r</em>eplaying the query even if the resulting data changes from the underlying tables.</p>
<p>Again, cold Observables will, in some shape or form, repeat the operation to generate these emissions to each <kbd>Observer</kbd>. Next, we will cover <strong>hot Observables</strong> that resemble events more than data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot Observables</h1>
                </header>
            
            <article>
                
<p>You just learned about the cold <kbd>Observable</kbd>, which works much like a music CD. A hot <kbd>Observable</kbd> is more like a radio station. It broadcasts the same emissions to all Observers at the same time. If an <kbd>Observer</kbd> subscribes to a hot <kbd>Observable</kbd>, receives some emissions, and then another <kbd>Observer</kbd> comes in afterwards, that second <kbd>Observer</kbd> will have missed those emissions. Just like a radio station, if you tune in too late, you will have missed that song.</p>
<p>Logically, hot Observables often represent events rather than finite datasets. The events can carry data with them, but there is a time-sensitive component where late observers can miss previously emitted data.</p>
<p>For instance, a JavaFX or Android UI event can be represented as a hot <kbd>Observable</kbd>. In JavaFX, you can create an <kbd>Observable&lt;Boolean&gt;</kbd> off a <kbd>selectedProperty()</kbd> operator of a  <kbd>ToggleButton</kbd> using <kbd>Observable.create()</kbd>. You can then transform the Boolean emissions into strings indicating whether the <kbd>ToggleButton</kbd> is <kbd>UP</kbd> or <kbd>DOWN</kbd> and then use an <kbd>Observer</kbd> to display them in <kbd>Label</kbd>, as shown in the following code snippet:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>javafx.application.</span><span>Application</span><span>;<br/></span><span>    import </span><span>javafx.beans.value.</span><span>ChangeListener</span><span>;<br/></span><span>    import </span><span>javafx.beans.value.</span><span>ObservableValue</span><span>;<br/></span><span>    import </span><span>javafx.scene.Scene</span><span>;<br/></span><span>    import </span><span>javafx.scene.control.Label</span><span>;<br/></span><span>    import </span><span>javafx.scene.control.ToggleButton</span><span>;<br/></span><span>    import </span><span>javafx.scene.layout.VBox</span><span>;<br/></span><span>    import </span><span>javafx.stage.Stage</span><span>;<br/></span><span><br/></span><span>     public class </span><span>MyJavaFxApp </span><span>extends </span><span>Application </span><span>{<br/></span><span><br/></span><span>      </span><span>@Override<br/></span><span>     </span><span>public void </span><span>start</span><span>(</span><span>Stage </span><span>stage</span><span>) </span><span>throws </span><span>Exception </span><span>{<br/></span><span><br/></span><span>      </span><span>ToggleButton </span><span>toggleButton </span><span>= </span><span>new </span><span>ToggleButton</span><span>(</span><span>"TOGGLE ME"</span><span>);<br/></span><span>      </span><span>Label </span><span>label </span><span>= </span><span>new </span><span>Label</span><span>();<br/></span><span><br/></span><span>      </span><span>Observable</span><span>&lt;</span><span>Boolean</span><span>&gt; </span><span>selectedStates </span><span>=<br/></span><span>        </span><span>valuesOf</span><span>(</span><span>toggleButton</span><span>.</span><span>selectedProperty</span><span>());<br/></span><span><br/></span><span>      </span><span>selectedStates</span><span>.</span><span>map</span><span>(</span><span>selected </span>-&gt; <span>selected </span><span>? </span><span>"DOWN" </span><span>: </span><span>"UP"</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>label</span>::<span>setText</span><span>);<br/></span><span><br/></span><span>      </span><span>VBox </span><span>vBox </span><span>= </span><span>new </span><span>VBox</span><span>(</span><span>toggleButton</span><span>, </span><span>label</span><span>);<br/></span><span><br/></span><span>      </span><span>stage</span><span>.</span><span>setScene</span><span>(</span><span>new </span><span>Scene</span><span>(</span><span>vBox</span><span>));<br/></span><span>      </span><span>stage</span><span>.</span><span>show</span><span>();<br/></span><span>     }<br/></span><span><br/></span><span>     </span><span>private static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>Observable</span><span>&lt;</span><span>T</span><span>&gt; </span><span>valuesOf</span><span>(</span><span>final<br/></span><span>     ObservableValue</span><span>&lt;</span><span>T</span><span>&gt; </span><span>fxObservable</span><span>) {<br/></span><span>       </span><span>return </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>observableEmitter </span>-&gt; <span>{<br/></span><span><br/></span><span>         </span><span>//emit initial state<br/></span><span>         </span><span>observableEmitter</span><span>.</span><span>onNext</span><span>(</span><span>fxObservable</span><span>.</span><span>getValue</span><span>());<br/></span><span><br/></span><span>         </span><span>//emit value changes uses a listener<br/></span><span>         </span><span>final </span><span>ChangeListener</span><span>&lt;</span><span>T</span><span>&gt; </span><span>listener </span><span>=</span><span> </span><span>(</span><span>observableValue</span><span>, </span><span>prev</span><span>,<br/></span><span>         current</span><span>) </span>-&gt; <span>observableEmitter</span><span>.</span><span>onNext</span><span>(</span><span>current</span><span>);<br/></span><span><br/></span><span>         </span><span>fxObservable</span><span>.</span><span>addListener</span><span>(</span><span>listener</span><span>);<br/></span><span>       });<br/></span><span>     }<br/></span><span>   }</span></pre>
<div class="CDPAlignCenter CDPAlign"><img height="120" width="156" class="image-border" src="assets/bfa2c770-eb35-4685-93bf-ad6f70c10966.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A JavaFX app backed by a hot <strong>Observable&lt;Boolean&gt;</strong> created off a <strong>ToggleButton</strong>'s selection state</div>
<div class="CDPAlignLeft CDPAlign packt_infobox">Note that if you are using OpenJDK, you will need to get the JavaFX library separately. It is easiest to use Oracle's official JDK, which includes JavaFX and is available at <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</div>
<p>A JavaFX <kbd>ObservableValue</kbd> has nothing to do with an RxJava <kbd>Observable</kbd>. It is proprietary to JavaFX, but we can easily turn it into an RxJava <kbd>Observable</kbd> using the <kbd>valuesOf()</kbd> factory implemented earlier to hook <kbd>ChangeListener</kbd> as an <kbd>onNext()</kbd> call. Every time you click on the <kbd>ToggleButton</kbd>, the  <kbd>Observable&lt;Boolean&gt;</kbd> will emit a <kbd>true</kbd> or <kbd>false</kbd> reflecting the selection state. This is a simple example, showing that this <kbd>Observable</kbd> is emitting events but is also emitting data in the form of <kbd>true</kbd> or <kbd>false</kbd>. It will transform that boolean into a string and have an Observer modify a text of <kbd>Label</kbd>.</p>
<p>We only have one Observer in this JavaFX example. If we were to bring in more Observers to this <kbd>ToggleButton</kbd>'s events after emissions have occurred, those new Observers will have missed these emissions.</p>
<p>UI events on JavaFX and Android are prime examples of hot Observables, but you can also use hot Observables to reflect server requests. If you created an <kbd>Observable</kbd> off a live Twitter stream emitting tweets for a certain topic, that also would be a hot <kbd>Observable</kbd><strong>.</strong> All of these sources are likely infinite, and while many hot Observables are indeed infinite, they do not have to be. They just have to share emissions to all Observers simultaneously and not replay missed emissions for tardy Observers.</p>
<div class="packt_tip">Note that RxJavaFX (as well as RxAndroid, covered in <a href="4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml">Chapter 11</a>, <em>RxJava on Android</em>) has factories to turn various UI events into Observables and bindings for you. Using RxJavaFX, you can simplify the previous example using the <kbd>valuesOf()</kbd> factory.</div>
<p>Note that we did leave a loose end with this JavaFX example, as we never handled disposal. We will revisit this when we cover Disposables at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ConnectableObservable</h1>
                </header>
            
            <article>
                
<p>A helpful form of hot <kbd>Observable</kbd> is <kbd>ConnectableObservable</kbd>. It will take any <kbd>Observable</kbd>, even if it is cold, and make it hot so that all emissions are played to all Observers at once. To do this conversion, you simply need to call <kbd>publish()</kbd> on any <kbd>Observable</kbd>, and it will yield a <kbd>ConnectableObservable</kbd>. But subscribing will not start the emissions yet. You need to call its <kbd>connect()</kbd> method to start firing the emissions. This allows you to set up all your Observers beforehand. Take a look at the following code snippet:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                    <br/></span><span>         Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>,</span><span>"Delta"</span><span>,</span><span>"Epsilon"</span><span>)<br/>         .</span><span>publish</span><span>();<br/></span><span><br/></span><span>         </span><span>//Set up observer 1<br/></span><span>         </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>//Set up observer 2<br/></span><span>        </span><span>source</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//Fire!<br/></span><span>        </span><span>source</span><span>.</span><span>connect</span><span>();<br/></span><span>      }<br/></span><span>}</span></pre>
<p>Take a look at the following code:</p>
<pre style="padding-left: 30px">    Observer 1: Alpha<br/>    Observer 2: 5<br/>    Observer 1: Beta<br/>    Observer 2: 4<br/>    Observer 1: Gamma<br/>    Observer 2: 5<br/>    Observer 1: Delta<br/>    Observer 2: 5<br/>    Observer 1: Epsilon<br/>    Observer 2: 7</pre>
<p>Note how one Observer is receiving the string while the other is receiving the length and the two are printing them in an interleaved fashion. Both subscriptions are set up beforehand, and then <kbd>connect()</kbd> is called to fire the emissions. Rather than <kbd>Observer 1</kbd> processing all the emissions before <kbd>Observer 2</kbd>, each emission goes to each Observer simultaneously. <kbd>Observer 1</kbd> receives <kbd>Alpha</kbd> and <kbd>Observer 2</kbd> receives <kbd>5</kbd> and then <kbd>Beta</kbd> and <kbd>4</kbd>, and so on. Using <kbd>ConnectableObservable</kbd> to force each emission to go to all Observers simultaneously is known as <strong>multicasting</strong>, which we will cover in detail in <a href="4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml" target="_blank">Chapter 5</a>, <em>Multicasting</em>.</p>
<p><kbd>ConnectableObservable</kbd> is helpful in preventing the replay of data to each Observer. You may want to do this if replaying emissions is expensive and you would rather emit them to all Observers at once. You may also do it simply to force the operators upstream to use a single stream instance even if there are multiple Observers downstream. Multiple Observers normally result in multiple stream instances upstream, but using <kbd>publish()</kbd> to return <kbd>ConnectableObservable</kbd> consolidates all the upstream operations before <kbd>publish()</kbd> into a single stream. Again, these nuances will be covered more in <a href="4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml" target="_blank">Chapter 5</a>, <em>Multicasting</em>.</p>
<p>For now, remember that <kbd>ConnectableObservable</kbd> is hot, and therefore, if new subscriptions occur after <kbd>connect()</kbd> is called, they will miss emissions that were fired previously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other Observable sources</h1>
                </header>
            
            <article>
                
<p>We already covered a few factories to create <kbd>Observable</kbd> sources, including <kbd>Observable.create()</kbd>, <kbd>Observable.just()</kbd>, and <kbd>Observable.fromIterable()</kbd>. After our detour covering Observers and their nuances, let's pick up where we left off and cover a few more <kbd>Observable</kbd> factories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.range()</h1>
                </header>
            
            <article>
                
<p>To emit a consecutive range of integers, you can use <kbd>Observable.range()</kbd>. This will emit each number from a start value and increment each emission until the specified count is reached. These numbers are all passed through the <kbd>onNext()</kbd> event, followed by the  <kbd>onComplete()</kbd> event:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>10</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>   }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 1<br/>    RECEIVED: 2<br/>    RECEIVED: 3<br/>    RECEIVED: 4<br/>    RECEIVED: 5<br/>    RECEIVED: 6<br/>    RECEIVED: 7<br/>    RECEIVED: 8<br/>    RECEIVED: 9<br/>    RECEIVED: 10</pre>
<p>Note closely that the two arguments for <strong><kbd>Observable.range()</kbd></strong> are not lower/upper bounds. The first argument is the starting value. The second argument is the total count of emissions, which will include both the initial value and incremented values. Try emitting <kbd>Observable.range(5,10)</kbd>, and you will notice that it emits <kbd>5</kbd> followed by the next nine consecutive integers following it (for a grand total of 10 emissions):</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>5</span><span>,</span><span>10</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>     }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    RECEIVED: 5<br/>    RECEIVED: 6<br/>    RECEIVED: 7<br/>    RECEIVED: 8<br/>    RECEIVED: 9<br/>    RECEIVED: 10<br/>    RECEIVED: 11<br/>    RECEIVED: 12<br/>    RECEIVED: 13<br/>    RECEIVED: 14</pre>
<div class="packt_infobox">Note that there is also a long equivalent called <kbd>Observable.rangeLong()</kbd> if you need to emit larger numbers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.interval()</h1>
                </header>
            
            <article>
                
<p>As we have seen, Observables have a concept of emissions over time. Emissions are handed from the source up to the Observer sequentially. But these emissions can be spaced out over time depending on when the source provides them. Our JavaFX example with <kbd>ToggleButton</kbd> demonstrated this, as each click resulted in an emission of <kbd>true</kbd> or <kbd>false</kbd>.</p>
<p>But let's look at a simple example of a time-based <kbd>Observable</kbd> using <kbd>Observable.interval()</kbd>. It will emit a consecutive long emission (starting at <kbd>0</kbd>) at every specified time interval. Here, we have an <kbd>Observable&lt;Long&gt;</kbd> that emits every second:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>     public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[]</span><span>args</span><span>) {<br/><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s </span><span>+ </span><span>" Mississippi"</span><span>));<br/></span><span>          </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    0 Mississippi<br/>    1 Mississippi<br/>    2 Mississippi<br/>    3 Mississippi<br/>    4 Mississippi</pre>
<p><kbd>Observable.interval()</kbd> will emit infinitely at the specified interval (which is 1 second in this case). However, because it operates on a timer, it needs to run on a separate thread and will run on the computation <strong>Scheduler</strong> by default. We will cover concurrency in <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml">Chapter 6</a>, <em>Concurrency and Parallelization</em> and learn about schedulers. For now, just note that our  <kbd>main()</kbd> method is going to kick off this <kbd>Observable</kbd>, but it will not wait for it to finish. It is now emitting on a separate thread. To keep our <kbd>main()</kbd> method from finishing and exiting the application before our <kbd>Observable</kbd> has a chance to fire, we use a <kbd>sleep()</kbd> method to keep this application alive for five seconds. This gives our <kbd>Observable</kbd> five seconds to fire emissions before the application quits. When you create production applications, you likely will not run into this issue often as non-daemon threads for tasks such as web services, Android apps, or JavaFX will keep the application alive.</p>
<p>Trick question: does <kbd>Observable.interval()</kbd> return a hot or a cold <kbd>Observable</kbd>? Because it is event-driven (and infinite), you may be tempted to say it is hot. But put a second <kbd>Observer</kbd> on it, wait for five seconds, and then add another Observer. What happens? Let's take a look:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;</span><span><br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>= </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>,   <br/></span><span>        TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);</span><span><br/></span><span>       }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>       }<br/></span><span>    }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px">    Observer 1: 0<br/>    Observer 1: 1<br/>    Observer 1: 2<br/>    Observer 1: 3<br/>    Observer 1: 4<br/>    Observer 1: 5<br/>    Observer 2: 0<br/>    Observer 1: 6<br/>    Observer 2: 1<br/>    Observer 1: 7<br/>    Observer 2: 2<br/>    Observer 1: 8<br/>    Observer 2: 3<br/>    Observer 1: 9<br/>    Observer 2: 4</pre>
<p>Look what happened after <span>five</span> seconds elapsed, when <kbd>Observer 2</kbd> came in. Note that it is on its own separate timer and starting at <kbd>0</kbd>! These two observers are actually getting their own emissions, each starting at <kbd>0</kbd>. So this <kbd>Observable</kbd> is actually cold. To put all observers on the same timer with the same emissions, you will want to use <kbd>ConnectableObservable</kbd> to force these emissions to become hot:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>     public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>).</span><span>publish</span><span>();<br/></span><span><br/></span><span>        </span><span>//observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));<br/></span><span>        </span><span>seconds</span><span>.</span><span>connect</span><span>();<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>        </span><span>//observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Observer 1: 0<br/>    Observer 1: 1<br/>    Observer 1: 2<br/>    Observer 1: 3<br/>    Observer 1: 4<br/>    Observer 1: 5<br/>    Observer 2: 5<br/>    Observer 1: 6<br/>    Observer 2: 6<br/>    Observer 1: 7<br/>    Observer 2: 7<br/>    Observer 1: 8<br/>    Observer 2: 8<br/>    Observer 1: 9<br/>    Observer 2: 9</pre>
<p>Now <kbd>Observer 2</kbd>, although 5 seconds late and having missed the previous emissions, will at least be completely in sync with <kbd>Observer 1</kbd> and receive the same emissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.future()</h1>
                </header>
            
            <article>
                
<p>RxJava Observables are much more robust and expressive than <kbd>Futures</kbd>, but if you have existing libraries that yield <kbd>Futures</kbd>, you can easily turn them into Observables via <kbd>Observable.future()</kbd>:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>java.util.concurrent.</span><span>Future</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Future</span><span>&lt;</span><span>String</span><span>&gt; </span><span>futureValue </span><span>= </span><span>...</span><span>;<br/></span><span>        <br/></span><span>        </span><span>Observable</span><span>.</span><span>fromFuture</span><span>(</span><span>futureValue</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.empty()</h1>
                </header>
            
            <article>
                
<p>Although this may not seem useful yet, it is sometimes helpful to create an <kbd>Observable</kbd> that emits nothing and calls <kbd>onComplete()</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>empty </span><span>= </span><span>Observable</span><span>.</span><span>empty</span><span>();<br/></span><span><br/></span><span>        </span><span>empty</span><span>.</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>, <br/></span><span>          </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>          () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span>       }<br/></span><span>     }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Done!</pre>
<p>Note that no emissions were printed because there were none. It went straight to calling <kbd>onComplete</kbd> , which printed the <kbd><span class="packt_screen">Done!</span></kbd> message in the Observer. Empty observables are common to represent empty datasets. They can also result from operators such as <kbd>filter()</kbd> when all emissions fail to meet a condition. Sometimes, you will deliberately create empty Observables using <kbd>Observable.empty()</kbd>, and we will see examples of this in a few places throughout this book.</p>
<p>An empty Observable is essentially RxJava's concept of null. It is the absence of a value (or technically, "values"). Empty Observables are much more elegant than nulls because operations will simply continue empty rather than throw <kbd>NullPointerExceptions</kbd>. But when things go wrong in RxJava programs, sometimes it is because observers are receiving no emissions. When this happens, you have to trace through your Observable's chain of operators to find which one caused emissions to become empty.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.never()</h1>
                </header>
            
            <article>
                
<p>A close cousin of <kbd>Observable.empty()</kbd> is <kbd>Observable.never()</kbd>. The only difference between them is that it never calls <kbd>onComplete()</kbd>, forever leaving observers waiting for emissions but never actually giving any:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>empty </span><span>= </span><span>Observable</span><span>.</span><span>never</span><span>();<br/></span><span><br/></span><span>        </span><span>empty</span><span>.</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>,<br/></span><span>          </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>            () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>       }<br/></span><span>     } </span></pre>
<p>This <kbd>Observable</kbd> is primarily used for testing and not that often in production. We have to use <kbd>sleep()</kbd> here just like <kbd>Observable.interval()</kbd> because the main thread is not going to wait for it after kicking it off. In this case, we just use <kbd>sleep()</kbd> for five seconds to prove that no emissions are coming from it. Then, the application will quit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.error()</h1>
                </header>
            
            <article>
                
<p>This too is something you likely will only do with testing, but you can create an <kbd>Observable</kbd> that immediately calls <kbd>onError()</kbd> with a specified exception:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        <br/></span><span>        </span><span>Observable</span><span>.</span><span>error</span><span>(</span><span>new </span><span>Exception</span><span>(</span><span>"Crash and burn!"</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>            </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>              () </span>-&gt;  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span>      }<br/></span><span>     }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    java.lang.Exception: Crash and burn!<br/>    at Launcher.lambda$main$0(Launcher.java:7)<br/>    at io.reactivex.internal.operators.observable.<br/>      ObservableError.subscribeActual(ObservableError.java:32)<br/>    at io.reactivex.Observable.subscribe(Observable.java:10514)<br/>    at io.reactivex.Observable.subscribe(Observable.java:10500)<br/>    ...</pre>
<p>You can also provide the exception through a lambda so that it is created from scratch and separate exception instances are provided to each Observer:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{</span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {</span><span><br/><br/></span><span>        </span><span>Observable</span><span>.</span><span>error</span><span>(() </span>-&gt; <span>new </span><span>Exception</span><span>(</span><span>"Crash and burn!"</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>           </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>           () </span>-&gt;  <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));</span><span><br/></span><span>      }<br/></span><span>    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.defer()</h1>
                </header>
            
            <article>
                
<p><kbd>Observable.defer()</kbd> is a powerful factory due to its ability to create a separate state for each <kbd>Observer</kbd>. When using certain <kbd>Observable</kbd> factories, you may run into some nuances if your source is stateful and you want to create a separate state for each <kbd>Observer</kbd>. Your source <kbd>Observable</kbd> may not capture something that has changed about its parameters and send emissions that are obsolete. Here is a simple example: we have an <kbd>Observable.range()</kbd> built off two static <kbd>int</kbd> properties, <kbd>start</kbd> and <kbd>count</kbd>.</p>
<p>If you subscribe to this <kbd>Observable</kbd>, modify the count, and then subscribe again, you will find that the second <kbd>Observer</kbd> does not see this change:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>     public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>private static int </span><span>start </span><span>= </span><span>1</span><span>;<br/></span><span>      </span><span>private static int </span><span>count </span><span>= </span><span>5</span><span>;<br/></span><span>    <br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        <br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>start</span><span>,</span><span>count</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//modify count<br/></span><span>        </span><span>count </span><span>= </span><span>10</span><span>;<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span>       }<br/></span><span>     }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Observer 1: 1<br/>    Observer 1: 2<br/>    Observer 1: 3<br/>    Observer 1: 4<br/>    Observer 1: 5<br/>    Observer 2: 1<br/>    Observer 2: 2<br/>    Observer 2: 3<br/>    Observer 2: 4<br/>    Observer 2: 5</pre>
<p>To remedy this problem of <kbd>Observable</kbd> sources not capturing state changes, you can create a fresh <kbd>Observable</kbd> for each subscription. This can be achieved using <kbd>Observable.defer()</kbd>, which accepts a lambda instructing how to create an <kbd>Observable</kbd> for every subscription. Because this creates a new <kbd>Observable</kbd> each time, it will reflect any changes driving its parameters:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>private static int </span><span>start </span><span>= </span><span>1</span><span>;<br/></span><span>      </span><span>private static int </span><span>count </span><span>= </span><span>5</span><span>;<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>source </span><span>= </span><span>Observable</span><span>.</span><span>defer</span><span>(() </span>-&gt; <br/><span>        Observable</span><span>.</span><span>range</span><span>(</span><span>start</span><span>,</span><span>count</span><span>));<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//modify count<br/></span><span>        </span><span>count </span><span>= </span><span>10</span><span>;<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Observer 1: 1<br/>    Observer 1: 2<br/>    Observer 1: 3<br/>    Observer 1: 4<br/>    Observer 1: 5<br/>    Observer 2: 1<br/>    Observer 2: 2<br/>    Observer 2: 3<br/>    Observer 2: 4<br/>    Observer 2: 5<br/>    Observer 2: 6<br/>    Observer 2: 7<br/>    Observer 2: 8<br/>    Observer 2: 9<br/>    Observer 2: 10</pre>
<p>That's better! When your <kbd>Observable</kbd> source is not capturing changes to the things driving it, try putting it in <kbd>Observable.defer()</kbd>. If your Observable source was implemented naively and behaves brokenly with more than one Observer (for example, it reuses an Iterator that only iterates data once), <kbd>Observable.defer()</kbd> provides a quick workaround for this as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.fromCallable()</h1>
                </header>
            
            <article>
                
<p>If you need to perform a calculation or action and then emit it, you can use <kbd>Observable.just()</kbd> (or <kbd>Single.just()</kbd> or <kbd>Maybe.just()</kbd>, which we will learn about later). But sometimes, we want to do this in a lazy or deferred manner. Also, if that procedure throws an error, we want it to be emitted up the <kbd>Observable</kbd> chain through <kbd>onError()</kbd> rather than throw the error at that location in traditional Java fashion. For instance, if you try to wrap <kbd>Observable.just()</kbd> around an expression that divides  <kbd>1</kbd> by <kbd>0</kbd>, the exception will be thrown, not emitted up to <kbd>Observer</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable;</span><span><br/></span><span>    </span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>1 </span><span>/ </span><span>0</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>        </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Error Captured: " </span><span>+ </span><span>e</span><span>)</span><span>);<br/></span><span>      }<br/></span><span>    }<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 30px">    Exception in thread "main" java.lang.ArithmeticException: / by zero<br/>    at Launcher.main(Launcher.java:6)<br/>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>    at sun.reflect.NativeMethodAccessorImpl.invoke<br/>      (NativeMethodAccessorImpl.java:62)<br/>    at sun.reflect.DelegatingMethodAccessorImpl.<br/>      invoke(DelegatingMethodAccessorImpl.java:43)<br/>    at java.lang.reflect.Method.invoke(Method.java:498)<br/>    at com.intellij.rt.execution.<br/>      application.AppMain.main(AppMain.java:147)</pre>
<p> </p>
<p>If we are going to be reactive in our error handling, this may not be desirable. Perhaps you would like the error to be emitted down the chain to the <kbd>Observer</kbd> where it will be handled. If that is the case, use <kbd>Observable.fromCallable()</kbd> instead, as it accepts a lambda <kbd>Supplier&lt;T&gt;</kbd> and it will emit any error that occurs down to <kbd>Observer</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>fromCallable</span><span>(() </span>-&gt; <span>1 </span><span>/ </span><span>0</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>i</span><span>),<br/></span><span>        e</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Error Captured: " </span><span>+ </span><span>e</span><span>)</span><span>);<br/></span><span>      }<br/></span><span>    }<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre>    Error Captured: java.lang.ArithmeticException: / by zero</pre>
<p>That is better! The error was emitted to the <kbd>Observer</kbd> rather than being thrown where it occurred. If initializing your emission has a likelihood of throwing an error, you should use <kbd>Observable.fromCallable()</kbd> instead of <kbd>Observable.just()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single, Completable, and Maybe</h1>
                </header>
            
            <article>
                
<p>There are a few specialized flavors of <kbd>Observable</kbd> that are explicitly set up for one or no emissions: <kbd>Single</kbd>, <kbd>Maybe</kbd>, and <kbd>Completable</kbd>. These all follow the <kbd>Observable</kbd> closely and should be intuitive to use in your reactive coding workflow. You can create them in similar ways as the <kbd>Observable</kbd> (for example, they each have their own <kbd>create()</kbd> factory), but certain <kbd>Observable</kbd> operators may return them too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single</h1>
                </header>
            
            <article>
                
<p><kbd>Single&lt;T&gt;</kbd> is essentially an <kbd>Observable&lt;T&gt;</kbd> that will only emit one item. It works just like an Observable, but it is limited only to operators that make sense for a single emission. It has its own <kbd>SingleObserver</kbd> interface as well:</p>
<pre style="padding-left: 30px"><span class="pl-k">    interface</span> <span class="pl-en">SingleObserver</span>&lt;T&gt; {<br/><span class="pl-k">    void</span> <span class="pl-en">onSubscribe</span>(<span class="pl-smi">Disposable</span> <span class="pl-v">d</span>);<br/><span class="pl-k">    void</span> <span class="pl-en">onSuccess</span>(<span class="pl-smi">T </span><span class="pl-v">value</span>);<br/><span class="pl-k">    void</span> <span class="pl-en">onError</span>(<span class="pl-smi">Throwable</span> <span class="pl-v">error</span>);<br/>    }</pre>
<p>The <kbd>onSuccess()</kbd> essentially consolidates <kbd>onNext()</kbd> and <kbd>onComplete()</kbd> into a single event that accepts the one emission. When you call <kbd>subscribe()</kbd> against a Single, you provide the lambdas for <kbd>onSuccess()</kbd> as well as an optional <kbd>onError()</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Single</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>    <br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Single</span><span>.</span><span>just</span><span>(</span><span>"Hello"</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println, <br/>        Throwable::printStackTrace</span><span>);<br/></span><span>      }<br/>    }<br/></span></pre>
<p>Certain RxJava Observable operators will yield a Single, as we will see in the next chapter. For instance, the <kbd>first()</kbd> operator will return a Single since that operator is logically concerned with a single item. However, it accepts a default value as a parameter (which I specified as <kbd>Nil</kbd> in the following example) if the Observable comes out empty: </p>
<pre><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>     public class </span><span>Launcher </span><span>{<br/></span><span>  <br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= <br/></span><span>        Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>first</span><span>(</span><span>"Nil"</span><span>) //returns a Single<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>       }<br/></span><span>     }</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 30px"><strong>    </strong>Alpha</pre>
<p>The <kbd>Single</kbd> must have one emission, and you should prefer it if you only have one emission to provide. This means that instead of using <kbd>Observable.just("Alpha")</kbd>, you should try to use <kbd>Single.just("Alpha")</kbd> instead. There are operators on <kbd>Single</kbd> that will allow you to turn it into an <kbd>Observable</kbd> when needed, such as <kbd>toObservable()</kbd>.</p>
<p>If there are <kbd>0</kbd> or <kbd>1</kbd> emissions, you will want to use <kbd>Maybe</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maybe</h1>
                </header>
            
            <article>
                
<p><kbd>Maybe</kbd> is just like a <kbd>Single</kbd> except that it allows no emission to occur at all (hence <kbd>Maybe</kbd>). <kbd>MaybeObserver</kbd> is much like a standard Observer, but <kbd>onNext()</kbd> is called <kbd>onSuccess()</kbd> instead:</p>
<pre style="padding-left: 30px">      public interface MaybeObserver&lt;T&gt; {<br/>      void onSubscribe(Disposable d);<br/>      void onSuccess(T value);<br/>      void onError(Throwable e);<br/>      void onComplete();<br/>    }</pre>
<p>A given <kbd>Maybe&lt;T&gt;</kbd> will only emit <kbd>0</kbd> or  <kbd>1</kbd> emissions. It will pass the possible emission to <kbd>onSuccess()</kbd>, and in either case, it will call <kbd>onComplete()</kbd> when done. <kbd>Maybe.just()</kbd> can be used to create a <kbd>Maybe</kbd> emitting the single item. <kbd>Maybe.empty()</kbd> will create a <kbd>Maybe</kbd> that yields no emission:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Maybe</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>// has emission<br/></span><span>        </span><span>Maybe</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>presentSource </span><span>= </span><span>Maybe</span><span>.</span><span>just</span><span>(</span><span>100</span><span>);<br/></span><span><br/></span><span>        </span><span>presentSource</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Process 1<br/>          received: " </span><span>+ </span><span>s</span><span>),<br/></span><span>        </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>        () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Process 1 done!"</span><span>)</span><span>);<br/></span><span><br/></span><span>        </span><span>//no emission<br/></span><span>        </span><span>Maybe</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>emptySource </span><span>= </span><span>Maybe</span><span>.</span><span>empty</span><span>();<br/></span><span><br/></span><span>        </span><span>emptySource</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Process 2<br/>          received: " </span><span>+ </span><span>s</span><span>),<br/></span><span>        </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>        () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Process 2 done!"</span><span>)</span><span>);<br/></span><span>      }<br/></span><span>     }</span></pre>
<p> The output is as follows:</p>
<pre style="padding-left: 30px">    Process 1 received: 100<br/>    Process 2 done!</pre>
<p>Certain <kbd>Observable</kbd> operators that we will learn about later yield a <kbd>Maybe</kbd>. One example is the <kbd>firstElement()</kbd> operator, which is similar to <kbd>first()</kbd>, but it returns an empty result if no elements are emitted:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>,</span><span>"Delta"</span><span>,</span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>firstElement</span><span>().</span><span>subscribe</span><span>(<br/></span><span>          </span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED " </span><span>+ </span><span>s</span><span>),<br/></span><span>        </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>        () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>)</span><span>);<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><span> The output is as follows:</span></p>
<pre style="padding-left: 30px">    RECEIVED Alpha</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completable</h1>
                </header>
            
            <article>
                
<p><kbd>Completable</kbd> is simply concerned with an action being executed, but it does not receive any emissions. Logically, it does not have  <kbd>onNext()</kbd> or <kbd>onSuccess()</kbd> to receive emissions, but it does have <kbd>onError()</kbd> and <kbd>onComplete()</kbd>:</p>
<pre style="padding-left: 30px"><span class="pl-k">    interface</span> <span class="pl-en">CompletableObserver</span>&lt;T&gt; {<br/><span class="pl-k">    void</span> <span class="pl-en">onSubscribe</span>(<span class="pl-smi">Disposable</span> <span class="pl-v">d</span>);<br/><span class="pl-k">    void</span> <span class="pl-en">onComplete</span>();<br/><span class="pl-k">    void</span> <span class="pl-en">onError</span>(<span class="pl-smi">Throwable</span> <span class="pl-v">error</span>);<br/>    }</pre>
<p>Completable is something you likely will not use often. You can construct one quickly by calling <kbd>Completable.complete()</kbd> or <kbd>Completable.fromRunnable()</kbd>. The former will immediately call <kbd>onComplete()</kbd> without doing anything, while <kbd>fromRunnable()</kbd> will execute the specified action before calling <kbd>onComplete()</kbd>:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Completable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Completable</span><span>.</span><span>fromRunnable</span><span>(() </span>-&gt; <span>runProcess</span><span>())<br/></span><span>        .</span><span>subscribe</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>      </span><span>public static void </span><span>runProcess</span><span>() {<br/></span><span>        </span><span>//run process here<br/></span><span>       </span><span>}<br/></span><span>     }</span></pre>
<p> The output is as follows:</p>
<pre style="padding-left: 30px">    Done!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disposing</h1>
                </header>
            
            <article>
                
<p>When you <kbd>subscribe()</kbd> to an Observable to receive emissions, a stream is created to process these emissions through the Observable chain. Of course, this uses resources. When we are done, we want to dispose of these resources so that they can be garbage-collected. Thankfully, the finite Observables that call <kbd>onComplete()</kbd> will typically dispose of themselves safely when they are done. But if you are working with infinite or long-running Observables, you likely will run into situations where you want to explicitly stop the emissions and dispose of everything associated with that subscription. As a matter of fact, you cannot trust the garbage collector to take care of active subscriptions that you no longer need, and explicit disposal is necessary in order to prevent memory leaks.</p>
<p>The Disposable is a link between an Observable and an active Observer, and you can call its <kbd>dispose()</kbd> method to stop emissions and dispose of all resources used for that Observer. It also has an <kbd>isDisposed()</kbd> method, indicating whether it has been disposed of already:</p>
<pre style="padding-left: 30px">    package io.reactivex.disposables;<br/><br/>    public interface Disposable {<br/>      void dispose();<br/>      boolean isDisposed();<br/>    }</pre>
<p>When you provide <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and/or <kbd>onError()</kbd> lambdas as arguments to the <kbd>subscribe()</kbd> method,  it will actually return a <kbd>Disposable</kbd>. You can use this to stop emissions at any time by calling its <kbd>dispose()</kbd> method. For instance, we can stop receiving emissions from an <kbd>Observable.interval()</kbd> after five seconds:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>Disposable </span><span>disposable </span><span>=<br/></span><span>          </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>        </span><span>//dispose and stop emissions<br/></span><span>        </span><span>disposable</span><span>.</span><span>dispose</span><span>();<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds to prove<br/></span><span>        //there are no more emissions<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>       }<br/></span><span>     }</span></pre>
<p>Here, we let <kbd>Observable.interval()</kbd> run for <span>five</span> seconds with an Observer, but we save the Disposable returned from the <kbd>subscribe()</kbd> method. Then we call the Disposable's <kbd>dispose()</kbd> method to stop the process and free any resources that were being used. Then, we sleep for another <span>five</span> seconds just to prove that no more emissions are happening.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling a Disposable within an Observer</h1>
                </header>
            
            <article>
                
<p>Earlier, I shied away from talking about the <kbd>onSubscribe()</kbd> method in the <kbd>Observer</kbd>, but now we will address it. You may have noticed that <kbd>Disposable</kbd> is passed in the implementation of an <kbd>Observer</kbd> through the <kbd>onSubscribe()</kbd> method. This method was added in RxJava 2.0, and it allows the <kbd>Observer</kbd> to have the ability to dispose of the subscription at any time.</p>
<p>For instance, you can implement your own <kbd>Observer</kbd> and use <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, or <kbd>onError()</kbd> to have access to the <kbd>Disposable</kbd>.<strong> </strong>This way, these three events can call <kbd>dispose()</kbd> if, for whatever reason, the <kbd>Observer</kbd> does not want any more emissions:</p>
<pre style="padding-left: 30px"><span>    Observer</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>myObserver </span><span>= </span><span>new </span><span>Observer</span><span>&lt;</span><span>Integer</span><span>&gt;</span><span>() {<br/></span><span>      </span><span>private </span><span>Disposable </span><span>disposable</span><span>;<br/></span><span><br/></span><span>      </span><span>@Override<br/></span><span>      </span><span>public void </span><span>onSubscribe</span><span>(</span><span>Disposable </span><span>disposable</span><span>) {<br/></span><span>        </span><span>this</span><span>.</span><span>disposable </span><span>= </span><span>disposable</span><span>;<br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>@Override<br/></span><span>      </span><span>public void </span><span>onNext</span><span>(</span><span>Integer </span><span>value</span><span>) {<br/></span><span>        </span><span>//has access to Disposable<br/></span><span>      </span><span>}<br/></span><span><br/></span><span>      </span><span>@Override<br/></span><span>      </span><span>public void </span><span>onError</span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>        </span><span>//has access to Disposable<br/></span><span>      </span><span>}<br/></span><span><br/></span><span>      </span><span>@Override<br/></span><span>      </span><span>public void </span><span>onComplete</span><span>() {<br/></span><span>        </span><span>//has access to Disposable<br/></span><span>       </span><span>}<br/></span><span>     };</span></pre>
<p>The <kbd>Disposable</kbd> is sent from the source all the way up the chain to the Observer, so each step in the <kbd>Observable</kbd> chain has access to the Disposable.</p>
<p>Note that passing an <kbd>Observer</kbd> to the <kbd>subscribe()</kbd> method will be void and not return a <kbd>Disposable</kbd> since it is assumed that the <kbd>Observer</kbd> will handle it. If you do not want to explicitly handle the <kbd>Disposable</kbd> and want RxJava to handle it for you (which is probably a good idea until you have reason to take control), you can extend <kbd>ResourceObserver</kbd> as your Observer, which uses a default <kbd>Disposable</kbd> handling. Pass this to <kbd>subscribeWith()</kbd> instead of <kbd>subscribe()</kbd>, and you will get the default <kbd>Disposable</kbd> returned:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span>    import </span><span>io.reactivex.observers.</span><span>ResourceObserver</span><span>;<br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>source </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>         </span><span>ResourceObserver</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>myObserver </span><span>= </span><span>new  <br/></span><span>         ResourceObserver</span><span>&lt;</span><span>Long</span><span>&gt;</span><span>() {<br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onNext</span><span>(</span><span>Long </span><span>value</span><span>) {<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>value</span><span>);<br/></span><span>          }<br/></span><span><br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onError</span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>          }<br/></span><span><br/></span><span>          </span><span>@Override<br/></span><span>          </span><span>public void </span><span>onComplete</span><span>() {<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>);<br/></span><span>          }<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>//capture Disposable<br/></span><span>        </span><span>Disposable </span><span>disposable </span><span>= </span><span>source</span><span>.</span><span>subscribeWith</span><span>(</span><span>myObserver</span><span>);<br/></span><span>       }<br/></span><span>      }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using CompositeDisposable</h1>
                </header>
            
            <article>
                
<p>If you have several subscriptions that need to be managed and disposed of, it can be helpful to use <kbd>CompositeDisposable</kbd>. It implements <kbd>Disposable</kbd>, but it internally holds a collection of <kbd>disposables</kbd>, which you can add to and then dispose all at once:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>    import </span><span>io.reactivex.disposables.CompositeDisposable</span><span>;<br/></span><span>    import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span>    import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>private static final </span><span>CompositeDisposable </span><span>disposables<br/></span><span>        </span><span>= </span><span>new </span><span>CompositeDisposable</span><span>();<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//subscribe and capture disposables<br/></span><span>        </span><span>Disposable </span><span>disposable1 </span><span>=<br/></span><span>          </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ <br/></span><span>          l</span><span>));<br/></span><span><br/></span><span><br/></span><span>        </span><span>Disposable </span><span>disposable2 </span><span>=<br/></span><span>          </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ <br/></span><span>         l</span><span>));<br/></span><span><br/></span><span>        </span><span>//put both disposables into CompositeDisposable<br/></span><span>        </span><span>disposables</span><span>.</span><span>addAll</span><span>(</span><span>disposable1</span><span>, </span><span>disposable2</span><span>);<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>        </span><span>//dispose all disposables<br/></span><span>        </span><span>disposables</span><span>.</span><span>dispose</span><span>();<br/></span><span><br/></span><span>        </span><span>//sleep 5 seconds to prove<br/></span><span>        //there are no more emissions<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>    }</span></pre>
<p><kbd>CompositeDisposable</kbd> is a simple but helpful utility to maintain a collection of <kbd>disposables</kbd> that you can add to by calling <kbd>add()</kbd> or <kbd>addAll()</kbd>. When you no longer want these subscriptions, you can call <kbd>dispose()</kbd> to dispose of all of them at once.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling Disposal with Observable.create()</h1>
                </header>
            
            <article>
                
<p>If your <kbd>Observable.create()</kbd> is returning a long-running or infinite <kbd>Observable</kbd>, you should ideally check the <kbd>isDisposed()</kbd> method of <kbd>ObservableEmitter</kbd> regularly, to see whether you should keep sending emissions. This prevents unnecessary work from being done if the subscription is no longer active.</p>
<p>In this case, you should use <kbd>Observable.range()</kbd>, but for the sake of the example, let's say we are emitting integers in a <kbd>for</kbd> loop in <kbd>Observable.create()</kbd>. Before emitting each integer, you should make sure that <kbd>ObservableEmitter</kbd> does not indicate that a disposal was called:</p>
<pre style="padding-left: 30px"><span>    import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>source </span><span>= <br/></span><span>        Observable</span><span>.</span><span>create</span><span>(</span><span>observableEmitter </span>-&gt; <span>{<br/></span><span>          </span><span>try </span><span>{<br/></span><span>            </span><span>for </span><span>(</span><span>int </span><span>i </span><span>= </span><span>0</span><span>; </span><span>i </span><span>&lt; </span><span>1000</span><span>; </span><span>i</span><span>++</span><span>) {<br/></span><span>              </span><span>while </span><span>(</span><span>!</span><span>observableEmitter</span><span>.</span><span>isDisposed</span><span>()) {<br/></span><span>                </span><span>observableEmitter</span><span>.</span><span>onNext</span><span>(</span><span>i</span><span>);<br/></span><span>              } <br/>              if (observableEmitter.isDisposed()) <br/>                return;<br/></span><span>            }<br/></span><span>            </span><span>observableEmitter</span><span>.</span><span>onComplete</span><span>();<br/></span><span>          } </span><span>catch </span><span>(</span><span>Throwable </span><span>e</span><span>) {<br/></span><span>            </span><span>observableEmitter</span><span>.</span><span>onError</span><span>(</span><span>e</span><span>);<br/></span><span>          }<br/></span><span>        });<br/></span><span>       }<br/></span><span>     }</span></pre>
<p><span>If your <kbd>Observable.create()</kbd> is wrapped around some resource, you should also handle the disposal of that resource to prevent leaks. <kbd>ObservableEmitter</kbd> has the <kbd>setCancellable()</kbd> and <kbd>setDisposable()</kbd> methods for that. In our earlier JavaFX example, we should remove the  <kbd>ChangeListener</kbd> from our JavaFX <kbd>ObservableValue</kbd> when a disposal occurs. We can provide a lambda to <kbd>setCancellable()</kbd>, which will execute the following action for us, which will occur when <kbd>dispose()</kbd> is called:</span></p>
<pre style="padding-left: 30px"><span>    private static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>Observable</span><span>&lt;</span><span>T</span><span>&gt; </span><span>valuesOf</span><span>(</span><span>final </span><span>ObservableValue</span><span>&lt;</span><span>T</span><span>&gt; <br/></span><span>    fxObservable</span><span>) {<br/></span><span>      </span><span>return </span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>observableEmitter </span>-&gt; <span>{<br/></span><span><br/></span><span>        </span><span>//emit initial state<br/></span><span>        </span><span>observableEmitter</span><span>.</span><span>onNext</span><span>(</span><span>fxObservable</span><span>.</span><span>getValue</span><span>());<br/></span><span><br/></span><span>        </span><span>//emit value changes uses a listener<br/></span><span>        </span><span>final </span><span>ChangeListener</span><span>&lt;</span><span>T</span><span>&gt; </span><span>listener </span><span>=<br/></span><span>          </span><span>(</span><span>observableValue</span><span>, </span><span>prev</span><span>, </span><span>current</span><span>) </span>-&gt;  <br/><span>           observableEmitter</span><span>.</span><span>onNext</span><span>(</span><span>current</span><span>);<br/></span><span><br/></span><span>        </span><span>//add listener to ObservableValue<br/></span><span>        </span><span>fxObservable</span><span>.</span><span>addListener</span><span>(</span><span>listener</span><span>);<br/></span><span><br/></span><span>        </span><span>//Handle disposing by specifying cancellable<br/></span><span>        </span><span>observableEmitter</span><span>.</span><span>setCancellable</span><span>(() </span>-&gt; <br/><span>       fxObservable</span><span>.</span><span>removeListener</span><span>(</span><span>listener</span><span>));<br/></span><span>      });<br/></span><span>     }
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This was an intense chapter, but it will provide a solid foundation as you learn how to use RxJava to tackle real-world work. RxJava, with all of its expressive power, has some nuances that are entirely due to the change of mindset it demands. It has done an impressive amount of work taking an imperative language like Java and adapting it to become reactive and functional. But this interoperability requires some understanding of the implementations between an <kbd>Observable</kbd> and a <kbd>Observer</kbd>. We touched on various ways to create Observables as well as how they interact with Observers.</p>
<p>Take your time trying to digest all this information but do not let it stop you from moving on to the next two chapters, where the usefulness of RxJava starts to take formation. In the next chapters, the pragmatic usefulness of RxJava will start to become clear.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>