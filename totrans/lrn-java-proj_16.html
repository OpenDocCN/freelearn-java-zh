<html><head></head><body>
		<div id="_idContainer278">
			<h1 id="_idParaDest-401" class="chapter-number"><a id="_idTextAnchor401"/>16</h1>
			<h1 id="_idParaDest-402"><a id="_idTextAnchor402"/>Streams: Advanced Concepts</h1>
			<p>In <a href="B19793_15.xhtml#_idTextAnchor377"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, we learned about the fundamentals of streams. We started by discussing what a stream pipeline is by using an analogy of an assembly line. We saw that items only make their way onto the assembly line as and when needed. This is the principle of lazy evaluation. In this analogy, there are several operators that operate on the data (pencils) under the supervision of a supervisor (Java). The supervisor will not allow any work to start until the terminal operation in place. As Java is now aware of the full pipeline, efficiencies can be introduced. Once a pencil has passed an operator, the operator cannot get that pencil back. Thus, streams are different to arrays or <strong class="source-inline">Collection</strong>s in that manner. The pencils can be processed by as many operators as necessary but only one operator is the terminal operation. The other operators represent intermediate operations (a topic in <span class="No-Break">this chapter).</span></p>
			<p>We examined how to create streams. Streams can be created from various sources: arrays, collections, files, and varargs. We created both finite and infinite streams. Infinite streams are created using <strong class="source-inline">Stream.generate()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Stream.iterate()</strong></span><span class="No-Break">.</span></p>
			<p>We took a deep dive into terminal operations. Nothing happens until a terminal operation executes and once executed the stream is considered closed and must be re-streamed if you want to use it again. A reduction is an operation that examines all of the stream and produces a single output (primitive or <strong class="source-inline">Object</strong>). One of the terminal operations is the overloaded <strong class="source-inline">reduce()</strong> method which performs reductions on the stream. The <strong class="source-inline">collect()</strong> terminal operation is extremely useful for extracting data out of the stream (into a <strong class="source-inline">Map</strong> for example) for <span class="No-Break">later use.</span></p>
			<p>In this chapter, we will continue our coverage of streams. We will, with the aid of code examples, examine intermediate operations. Following that, we will discuss primitive streams and how to map streams. We will also discuss <strong class="source-inline">Optional</strong>s and lastly, we will finish with <span class="No-Break">parallel streams.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Examining <span class="No-Break">intermediate operations</span></li>
				<li>Delving into <span class="No-Break">primitive streams</span></li>
				<li><span class="No-Break">Mapping streams</span></li>
				<li><span class="No-Break">Explaining </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">s</span></li>
				<li>Understanding <span class="No-Break">parallel streams</span></li>
			</ul>
			<h1 id="_idParaDest-403"><a id="_idTextAnchor403"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-404"><a id="_idTextAnchor404"/>Examining intermediate operations</h1>
			<p>As we know, a <a id="_idIndexMarker1331"/>stream pipeline consists of a source, followed by zero or more intermediate operations, followed by a terminal operation. While the terminal operation is mandatory, intermediate operations are not. That said, intermediate operations are where pipelines get their real power as they transform the stream data as it flows by. Unlike terminal operations, intermediate operations produce a stream as a result. Let us start with <strong class="source-inline">filter()</strong>, which is taken from IntermediateOperations.java on <span class="No-Break">the repo:</span></p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor405"/>filter(Predicate)</h2>
			<p>The <strong class="source-inline">filter()</strong> operation <a id="_idIndexMarker1332"/>returns a stream containing<a id="_idIndexMarker1333"/> the elements matching the given predicate. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.1</em> presents a code example (from <strong class="source-inline">IntermediateOperations.java</strong> on <span class="No-Break">the repo):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/B19793_16_1.jpg" alt="Figure 16.1 - The filter(Predicate) intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 - The filter(Predicate) intermediate operation in code</p>
			<p>In this figure, the <a id="_idIndexMarker1334"/>countries whose names are longer than 5 characters <span class="No-Break">are output.</span></p>
			<h2 id="_idParaDest-406"><a id="_idTextAnchor406"/>distinct()</h2>
			<p>The <strong class="source-inline">distinct()</strong> operation<a id="_idIndexMarker1335"/> returns a<a id="_idIndexMarker1336"/> stream with duplicate elements removed. Internally, <strong class="source-inline">distinct()</strong> uses the <strong class="source-inline">equals()</strong> method from <strong class="source-inline">Object</strong> <span class="No-Break">when comparing.</span></p>
			<p>It is a <em class="italic">stateful</em> intermediate operation which means it needs to keep some state to operate effectively. This state enables <strong class="source-inline">distinct()</strong> to operate as follows: if this is the first time <strong class="source-inline">distinct()</strong> has seen this object, it passes it on but remembers it; if <strong class="source-inline">distinct()</strong> has already seen this object, it filters <span class="No-Break">it out.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.2</em> presents a code example (from <strong class="source-inline">IntermediateOperations.java</strong> on <span class="No-Break">the repo):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/B19793_16_2.jpg" alt="Figure 16.2 - The distinct() intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 - The distinct() intermediate operation in code</p>
			<p>In this figure, we<a id="_idIndexMarker1337"/> are streaming a list of strings, where <strong class="source-inline">"eagle"</strong> is duplicated. We are using the very useful <strong class="source-inline">Stream&lt;T&gt; peek(Consumer)</strong> intermediate operation. This <strong class="source-inline">peek()</strong> operation executes the consumer on the data as it passes by. This is a great help as it enables us to view the data flowing by. The <strong class="source-inline">distinct()</strong> operation is in our pipeline and the <strong class="source-inline">forEach()</strong> terminal operation starts <span class="No-Break">the streaming.</span></p>
			<p>When run, this code generates the <span class="No-Break">following output:</span></p>
			<pre class="console">
// Output: Before: eagle, After: eagle//              Before: eagleBefore: EAGLE, After: EAGLE</pre>
			<p>The<a id="_idIndexMarker1338"/> first <strong class="source-inline">"eagle"</strong> is streamed into the pipeline, where <strong class="source-inline">peek()</strong> echoes it to the screen, with the decoration <strong class="source-inline">"Before: "</strong>. Then <strong class="source-inline">peek()</strong> passes <strong class="source-inline">"eagle"</strong> on to <strong class="source-inline">distinct()</strong>. As this is the first time <strong class="source-inline">distinct()</strong> has seen <strong class="source-inline">"eagle"</strong>, it passes it on but remembers it. Lastly, <strong class="source-inline">forEach()</strong> takes <strong class="source-inline">"eagle"</strong> and outputs it prepended with the string <strong class="source-inline">", After:"</strong>, followed by <span class="No-Break">a newline.</span></p>
			<p>Now the second <strong class="source-inline">"eagle"</strong> is streamed. The <strong class="source-inline">peek()</strong> operation outputs the details and passes <strong class="source-inline">"eagle"</strong> on. However, <strong class="source-inline">distinct()</strong> remembers that it has seen this element already and filters it out. This is why <strong class="source-inline">", After: eagle"</strong> appears only once in <span class="No-Break">the output.</span></p>
			<p>Lastly, <strong class="source-inline">"EAGLE"</strong> is streamed. This proceeds just as the first <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">eagle"</strong></span><span class="No-Break"> did.</span></p>
			<h2 id="_idParaDest-407"><a id="_idTextAnchor407"/>limit(long)</h2>
			<p>The <strong class="source-inline">limit()</strong> operation <a id="_idIndexMarker1339"/>is a short-circuiting, stateful <a id="_idIndexMarker1340"/>intermediate operation. We saw its short-circuiting nature put into good effect by transforming an infinite stream into a finite stream in <a href="B19793_15.xhtml#_idTextAnchor377"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><em class="italic">.</em> Obviously, it needs to maintain some state in order to keep a count of the elements that have passed by. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.3</em> presents a code <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">IntermediateOperations.java</strong></span><span class="No-Break">):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/B19793_16_3.jpg" alt="Figure 16.3 - The limit(long) intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 - The limit(long) intermediate operation in code</p>
			<p>In this example, we are streaming a list of numbers. This example is a good example of lazy evaluation. The <span class="No-Break">output is:</span></p>
			<pre class="console">
   A - 11 A - 22 A - 33 A - 44 B - 44 C - 44 A - 55 B - 55 C - 55</pre>			<p>Let us examine what <span class="No-Break">happens here.</span></p>
			<ul>
				<li>11 is streamed, first <strong class="source-inline">peek()</strong> outputs it prepended with <strong class="source-inline">"A - "</strong> and passes it to <strong class="source-inline">filter()</strong> where it fails (as 11 is not &gt; <span class="No-Break">40)</span></li>
				<li>22 is streamed and behaves just as <span class="No-Break">11 did</span></li>
				<li>33 is streamed and operates in a similar fashion to 11 <span class="No-Break">and 22</span></li>
				<li>44 is streamed, passes the filter, hence <strong class="source-inline">"B - 44"</strong> is output; 44 is passed to <strong class="source-inline">limit()</strong> which records that this is the first element it has seen, before passing it on; <strong class="source-inline">forEach()</strong> outputs 44 prepended with <strong class="source-inline">"C - "</strong>.</li>
				<li>55 is<a id="_idIndexMarker1341"/> streamed and operates as 44 except that <strong class="source-inline">limit()</strong> informs <a id="_idIndexMarker1342"/>Java that this is the second element it has passed and the limit is 2. Java lets <strong class="source-inline">forEach()</strong> finish and the stream <span class="No-Break">is closed.</span></li>
				<li>Note that the first <strong class="source-inline">peek()</strong> never outputs <strong class="source-inline">"A - 66"</strong>, <strong class="source-inline">"A - 77"</strong>, <strong class="source-inline">"A - 88"</strong>, or <strong class="source-inline">"A - 99"</strong>. Therefore, 66, 77, 88, and 99 are never streamed - as they are not needed. This is another example of <span class="No-Break">lazy evaluation.</span></li>
			</ul>
			<p>Now let us look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-408"><a id="_idTextAnchor408"/>map(Function)</h2>
			<p>The <strong class="source-inline">Stream&lt;R&gt; map(Function&lt;T, R&gt;)</strong> operation<a id="_idIndexMarker1343"/> is for transforming data. It creates a one-to-one mapping between<a id="_idIndexMarker1344"/> elements in the stream and elements in the new stream returned. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.4</em> presents a code <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">IntermediateOperations.java</strong></span><span class="No-Break">):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/B19793_16_4.jpg" alt="Figure 16.4 - The map(Function) intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 - The map(Function) intermediate operation in code</p>
			<p>The <strong class="source-inline">map()</strong> operation takes in a <strong class="source-inline">Function</strong> which, takes in one type and returns another, possibly different type. In this example, the lambda used, takes in a <strong class="source-inline">String</strong> namely <strong class="source-inline">s</strong>, and returns the <strong class="source-inline">Integer</strong> length of that <strong class="source-inline">String</strong>. The <strong class="source-inline">forEach()</strong> outputs the lengths of the <strong class="source-inline">String</strong>s streamed: <strong class="source-inline">"book"</strong> is <strong class="source-inline">4</strong>, <strong class="source-inline">"pen"</strong> is <strong class="source-inline">3</strong> and <strong class="source-inline">"ruler"</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-409"><a id="_idTextAnchor409"/>flatMap(Function)</h2>
			<p>The <strong class="source-inline">flatMap()</strong> operation “flattens” a stream. In other words, multiple collections/arrays are <a id="_idIndexMarker1345"/>merged into one. For example, if we<a id="_idIndexMarker1346"/> were streaming <strong class="source-inline">List&lt;String&gt;</strong> elements, they would be flattened into a stream of <strong class="source-inline">String</strong>s, which “removes” or hides each individual <strong class="source-inline">List</strong>. This is helpful when combining lists or for removing empty elements (which <strong class="source-inline">flatMap()</strong> also does). <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.5</em> presents a code <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">IntermediateOperations.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/B19793_16_5.jpg" alt="Figure 16.5 - The flatMap(Function) intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 - The flatMap(Function) intermediate operation in code</p>
			<p>In this example, we are going to contrast two streams - one with <strong class="source-inline">flatMap()</strong> and the other without <strong class="source-inline">flatMap()</strong>. Let us start with the <span class="No-Break">non-</span><span class="No-Break"><strong class="source-inline">flatMap()</strong></span><span class="No-Break"> stream.</span></p>
			<p>Firstly, we create the lists, the first of which is an <span class="No-Break">empty list:</span></p>
			<pre class="source-code">
   List&lt;String&gt; nothing = List.of();   List&lt;String&gt; list1 = Arrays.asList("Sean");
   List&lt;String&gt; list2 = Arrays.asList("Maike", "van", "Putten");</pre>
			<p>We then stream the <span class="No-Break">three lists:</span></p>
			<pre class="source-code">
   Stream&lt;List&lt;String&gt;&gt; streamOfLists = Stream.of(nothing, list1, list2);</pre>			<p>We then stream and output our <strong class="source-inline">streamOfLists</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">forEach()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   streamOfLists.forEach(System.out::print);</pre>			<p><span class="No-Break">This outputs:</span></p>
			<pre class="source-code">
   [][Sean][Maike, van, Putten]</pre>			<p>Note that <a id="_idIndexMarker1347"/>each element is a list (reflected by the square brackets <strong class="source-inline">[ ]</strong>) and that the empty list <span class="No-Break">is present.</span></p>
			<p>As the stream has been processed by a terminal operation (<strong class="source-inline">forEach()</strong>), the stream is closed. To avoid an exception, we must re-stream the source. This is what <span class="No-Break">we do:</span></p>
			<pre class="source-code">
   streamOfLists = Stream.of(nothing, list1, list2);</pre>			<p>This second pipeline contains the <span class="No-Break"><strong class="source-inline">flatMap()</strong></span><span class="No-Break"> operation:</span></p>
			<pre class="source-code">
   streamOfLists.flatMap(list -&gt; list.stream())</pre>			<p>The <a id="_idIndexMarker1348"/>signature for <strong class="source-inline">flatMap()</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
   Stream&lt;R&gt; flatMap(Function(T, R))</pre>			<p>Therefore, <strong class="source-inline">flatMap()</strong> takes in a <strong class="source-inline">Function</strong>. The function input <strong class="source-inline">T</strong>, is a <strong class="source-inline">List&lt;String&gt;</strong> and the function output <strong class="source-inline">R</strong>, is <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Stream&lt;String&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Using <strong class="source-inline">forEach()</strong> again to both start off the streaming and output the elements in the stream, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
   SeanMaikevanPutten</pre>			<p>Note that they are all just <strong class="source-inline">Strings</strong> (no <strong class="source-inline">List</strong>s) and that the empty element has been removed. The <strong class="source-inline">String</strong> elements that were in the <strong class="source-inline">List</strong>s are now top-level elements in the stream. This is the flattening process <span class="No-Break">explained earlier.</span></p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor410"/>sorted() and sorted(Comparator)</h2>
			<p>The<a id="_idIndexMarker1349"/> overloaded <strong class="source-inline">sorted()</strong> operation<a id="_idIndexMarker1350"/> returns a stream with the elements sorted. Just like sorting arrays, Java uses<a id="_idIndexMarker1351"/> natural ordering unless we provide a <strong class="source-inline">Comparator</strong>. For example, natural ordering for numbers is ascending numeric order; natural ordering for <strong class="source-inline">String</strong>s is alphabetic. This operation is a stateful intermediate operation which means that <strong class="source-inline">sorted()</strong> needs to see all of the data before it can sort it. Both<a id="_idIndexMarker1352"/> sorted examples are based on IntermediateOperations.java in the repo. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.6</em> presents a code example <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">sorted(Comparator)</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B19793_16_6.jpg" alt="Figure 16.6 - The sorted(Comparator) intermediate operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 - The sorted(Comparator) intermediate operation in code</p>
			<p>In this<a id="_idIndexMarker1353"/> example, assume <a id="_idIndexMarker1354"/>the existence of a <strong class="source-inline">Person</strong> class that has both <strong class="source-inline">String</strong> <strong class="source-inline">name</strong> and <strong class="source-inline">Integer</strong> <strong class="source-inline">age</strong> instance variables. We start by streaming the <strong class="source-inline">Person</strong> objects; <strong class="source-inline">"Mary"</strong> is first, age 25 and <strong class="source-inline">"John"</strong> is second, <span class="No-Break">age </span><span class="No-Break"><strong class="source-inline">23</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">sorted(Comparator)</strong> line <span class="No-Break">is interesting:</span></p>
			<pre class="source-code">
   .sorted(Comparator.comparing(Person::getAge)) // p -&gt; p.getAge()</pre>			<p>The <strong class="source-inline">Comparator.comparing(Function keyExtractor)</strong> static method is a very useful way of generating a <strong class="source-inline">Comparator</strong>. It accepts in a <strong class="source-inline">Function</strong> that extracts a <strong class="source-inline">Comparable</strong> sort key - as in, a key whose type implements the <strong class="source-inline">Comparable</strong> interface. In this example, the <strong class="source-inline">Function</strong> input is a <strong class="source-inline">Person</strong> and the <strong class="source-inline">Function</strong> return is an <strong class="source-inline">Integer</strong> (the age of the person). As <strong class="source-inline">Integer</strong> implements <strong class="source-inline">Comparable</strong>, this is fine. The method then returns a <strong class="source-inline">Comparator</strong> that compares by that sort key. This pipeline is short and does not clearly demonstrate the stateful nature of <strong class="source-inline">sorted()</strong>. The next example will <span class="No-Break">do that.</span></p>
			<p>When we output the stream, <strong class="source-inline">"John"</strong> comes out first and <strong class="source-inline">"Mary"</strong> second (the reverse of the order in which they were streamed). This is because we are sorting by <strong class="source-inline">age</strong> and <strong class="source-inline">"John"</strong>, at <strong class="source-inline">23</strong>, is younger than <strong class="source-inline">"Mary"</strong>, who <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">25</strong></span><span class="No-Break">.</span></p>
			<p>Now let us <a id="_idIndexMarker1355"/>look at another <strong class="source-inline">sorted()</strong> example. This one will demonstrate the stateful nature of <strong class="source-inline">sorted()</strong> and at the same time, highlight lazy evaluation. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.7</em> presents <span class="No-Break">the code.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/B19793_16_7.jpg" alt="Figure 16.7 - The stateful nature of sorted()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7 - The stateful nature of sorted()</p>
			<p>In this example, we are streaming a list of <strong class="source-inline">String</strong>s (names). Names that are of length <strong class="source-inline">3</strong> pass <span class="No-Break">the filter:</span></p>
			<pre class="source-code">
.filter(name -&gt; name.length() == 3)</pre>			<p>The <strong class="source-inline">sorted()</strong> operation<a id="_idIndexMarker1356"/> is stateful - it needs to see <em class="italic">all</em> of the data before it can sort that data. We also have a <strong class="source-inline">limit(2)</strong> operation which is both <a id="_idIndexMarker1357"/>stateful and short-circuiting. It will short-circuit after 2 names have passed by. Lastly, the terminal operation <strong class="source-inline">forEach()</strong> starts off the streaming process and outputs the names as <span class="No-Break">they arrive.</span></p>
			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
   0.Tim 1.Tim 0.Jim 1.Jim 0.Peter 0.Ann 1.Ann 0.Mary 2.Ann 3.Ann 2.Jim 3.Jim</pre>			<p>Let us examine what happens here. Note that the comments on the right of the pipeline (lines 49-55) indicate <a id="_idIndexMarker1358"/>what stage each name <span class="No-Break">gets to.</span></p>
			<ul>
				<li><strong class="source-inline">"Tim"</strong> is streamed <a id="_idIndexMarker1359"/>and passes the filter. <strong class="source-inline">"Tim"</strong> makes its way to <strong class="source-inline">sorted()</strong> where it is stored. Java tells <strong class="source-inline">sorted()</strong> that there is more data to be streamed and not to sort yet. This results in <strong class="source-inline">"0. Tim 1. Tim"</strong> in <span class="No-Break">the output.</span></li>
				<li><strong class="source-inline">"Jim"</strong> is streamed next and behaves exactly as <strong class="source-inline">"Tim"</strong>, with <strong class="source-inline">sorted()</strong> keeping a record that it will have to sort both <strong class="source-inline">"Tim"</strong> and <strong class="source-inline">"Jim"</strong>. Again, Java tells <strong class="source-inline">sorted()</strong> that there is more data to come and not to sort yet. Thus, we have <strong class="source-inline">"0. Jim 1. Jim"</strong> in <span class="No-Break">the output.</span></li>
				<li><strong class="source-inline">"Peter"</strong> is then streamed but fails the filter (just <strong class="source-inline">"0. Peter"</strong> and no <strong class="source-inline">"1. Peter"</strong> in <span class="No-Break">the output).</span></li>
				<li><strong class="source-inline">"Ann"</strong> is streamed next and behaves exactly as <strong class="source-inline">"Tim"</strong> and <strong class="source-inline">"Jim"</strong>, with <strong class="source-inline">sorted()</strong> keeping a record that it will have to sort <strong class="source-inline">"Tim"</strong>, <strong class="source-inline">"Jim"</strong>, and <strong class="source-inline">"Ann"</strong>. Again, Java tells <strong class="source-inline">sorted()</strong> not to sort yet. Thus, we have in <strong class="source-inline">"0. Ann 1. Ann"</strong> in <span class="No-Break">the output.</span></li>
				<li><strong class="source-inline">"Mary"</strong> is the last name to be streamed. <strong class="source-inline">"Mary"</strong> fails the filter also (just “<strong class="source-inline">0. Mary</strong>” and no <strong class="source-inline">"1. Mary"</strong> in <span class="No-Break">the output).</span></li>
				<li>As the stream is now empty, Java tells <strong class="source-inline">sorted()</strong> that it can sort the data. The sorted names are <strong class="source-inline">"Ann"</strong>, <strong class="source-inline">"Jim"</strong>, and <strong class="source-inline">"Tim"</strong>. So <strong class="source-inline">"Ann"</strong> now makes its way out of <strong class="source-inline">sorted()</strong> and onto the next stage of the <span class="No-Break">stream pipeline.</span></li>
				<li>The <strong class="source-inline">peek()</strong> after <strong class="source-inline">sorted()</strong> outputs <strong class="source-inline">"2. Ann"</strong> showing <strong class="source-inline">"Ann"</strong> <span class="No-Break">got here.</span></li>
				<li>The <strong class="source-inline">limit()</strong> operation passes “Ann” on but records that it has handled <span class="No-Break">one name.</span></li>
				<li>The terminal operation <strong class="source-inline">forEach()</strong> which kick-started the whole streaming process, outputs <strong class="source-inline">"3. Ann"</strong> to show that <strong class="source-inline">"Ann"</strong> got as far <span class="No-Break">as here.</span></li>
				<li><strong class="source-inline">"Jim"</strong> now makes its way out of <strong class="source-inline">sorted()</strong>. <strong class="source-inline">"Jim"</strong> is peeked (<strong class="source-inline">"2. Jim"</strong>) and passes through <strong class="source-inline">limit()</strong>. However, <strong class="source-inline">limit()</strong> short-circuits as this is the second name it has handled. Java is informed of <span class="No-Break">this fact.</span></li>
				<li>The <strong class="source-inline">forEach()</strong> operation<a id="_idIndexMarker1360"/> is allowed to finish outputting <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">3. Jim"</strong></span><span class="No-Break">.</span></li>
				<li>Note that <strong class="source-inline">"Tim"</strong> never gets out of <strong class="source-inline">sorted()</strong> and into the last <strong class="source-inline">peek()</strong> - there is no <strong class="source-inline">"2. Tim"</strong> in <span class="No-Break">the output.</span></li>
			</ul>
			<p>That <a id="_idIndexMarker1361"/>completes <a id="_idIndexMarker1362"/>this section on intermediate operations. Let us now examine <span class="No-Break">primitive streams.</span></p>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor411"/>Delving into primitive streams</h1>
			<p>Thus far, all our <a id="_idIndexMarker1363"/>streams have been for <strong class="source-inline">Object</strong> types. For example, a <strong class="source-inline">Stream&lt;Integer&gt;</strong> caters for the wrapper class <strong class="source-inline">Integer</strong>. Java also has classes specifically tailored for streams of primitives. For example, assuming a stream of <strong class="source-inline">int</strong> primitives, rather than <strong class="source-inline">Stream&lt;Integer&gt;</strong>, we use <strong class="source-inline">IntStream</strong>. As we shall see shortly, primitive streams have some really useful methods for processing numeric data, such as <strong class="source-inline">sum()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">average()</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Table 16.1</em> introduces the <a id="_idIndexMarker1364"/>primitive <span class="No-Break">stream classes.</span></p>
			<table id="table001-4" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Wrapper stream</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Primitive stream</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Primitives </strong><span class="No-Break"><strong class="bold">catered for</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Stream&lt;Integer&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">IntStream</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">int, short, </strong><span class="No-Break"><strong class="source-inline">byte, char</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Stream&lt;Double&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">DoubleStream</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">double, float</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Stream&lt;Long&gt;</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">LongStream</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.1 - Primitive stream classes</p>
			<p>In this table, the first column lists the wrapper type streams; the second column lists the corresponding primitive stream and the last column, enumerates the primitives catered for by the primitive stream from <span class="No-Break">column two.</span></p>
			<p>Let us examine how to create <span class="No-Break">primitive streams.</span></p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor412"/>Creating primitive streams</h2>
			<p>As with<a id="_idIndexMarker1365"/> creating <strong class="source-inline">Object</strong> streams, we can easily create primitive streams as well. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.8</em> presents sample code creating primitive streams (based on code from PrimitiveStreams.java in <span class="No-Break">the repo).</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/B19793_16_8.jpg" alt="Figure 16.8 - Creating primitive streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8 - Creating primitive streams</p>
			<p>In this example, we create arrays of differing <span class="No-Break">primitive types:</span></p>
			<pre class="source-code">
   int[] ia          = {1,2,3};   double[] da       = {1.1, 2.2, 3.3};
   long[] la         = {1L, 2L, 3L};</pre>
			<p>Using the overloaded <strong class="source-inline">Arrays.stream()</strong> method, we create an <strong class="source-inline">IntStream</strong>, <strong class="source-inline">DoubleStream</strong> and <span class="No-Break"><strong class="source-inline">LongStream</strong></span><span class="No-Break"> respectively:</span></p>
			<pre class="source-code">
   IntStream iStream1       = Arrays.stream(ia);   DoubleStream dStream1    = Arrays.stream(da);
   LongStream lStream1      = Arrays.stream(la);</pre>
			<p>For example, the <strong class="source-inline">Arrays.stream(ia)</strong> takes in an <strong class="source-inline">int[]</strong> and returns an <strong class="source-inline">IntStream</strong> with<a id="_idIndexMarker1366"/> the specified array as <span class="No-Break">its source.</span></p>
			<p>We then execute the <strong class="source-inline">count()</strong> terminal operation on each of the streams. Each returns <strong class="source-inline">3</strong> as there are <strong class="source-inline">3</strong> primitives in each <span class="No-Break">array source:</span></p>
			<pre class="source-code">
System.out.println(iStream1.count() + ", " + dStream1.count() + ", " + lStream1.count()); // 3, 3, 3</pre>			<p>The <strong class="source-inline">of()</strong> method should look familiar from how we created a regular stream using the <strong class="source-inline">Stream</strong> class. There is an equivalent method in <strong class="source-inline">IntStream</strong>, <strong class="source-inline">DoubleStream</strong> and <strong class="source-inline">LongStream</strong>. The values in the streams are specified in the <span class="No-Break">varargs arguments:</span></p>
			<pre class="source-code">
   IntStream iStream2       = IntStream.of(1, 2, 3);   DoubleStream dStream2    = DoubleStream.of(1.1, 2.2, 3.3);
   LongStream lStream2      = LongStream.of(1L, 2L, 3L);</pre>
			<p>Again, we execute the <strong class="source-inline">count()</strong> terminal operation on each of the streams. As before, <strong class="source-inline">3</strong> is returned each time, as there are <strong class="source-inline">3</strong> primitives in each of <span class="No-Break">the streams:</span></p>
			<pre class="source-code">
System.out.println(iStream2.count() + ", " + dStream2.count() + ", " + lStream2.count()); // 3, 3, 3</pre>			<p>We can of course create infinite streams of primitives. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.9</em>, from PrimitiveStreams.java in the repo, shows them being used and their equivalent names in the <strong class="source-inline">Stream</strong> class are familiar, namely <strong class="source-inline">generate()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">iterate()</strong></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/B19793_16_9.jpg" alt="Figure 16.9 - Infinite primitive streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9 - Infinite primitive streams</p>
			<p>In this <a id="_idIndexMarker1367"/>example, we<a id="_idIndexMarker1368"/> start out with the following two lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
   DoubleStream random    = DoubleStream.generate(() -&gt; Math.random());   random.limit(5).forEach(System.out::println);</pre>
			<p>The <strong class="source-inline">DoubleStream.generate(DoubleSupplier)</strong> method has equivalent versions in <strong class="source-inline">IntStream</strong> and <strong class="source-inline">LongStream</strong>. Its parameter <strong class="source-inline">DoubleSupplier</strong> is a functional interface where it produces a <strong class="source-inline">double</strong>. Thus, it is a <strong class="source-inline">double</strong> primitive version of <strong class="source-inline">Supplier&lt;T&gt;</strong>. Its functional method <strong class="source-inline">double getAsDouble()</strong> reinforces this fact. We use <strong class="source-inline">limit(5)</strong> to limit the infinite flow of numbers to <strong class="source-inline">5</strong> and each is output by the terminal <span class="No-Break">operation </span><span class="No-Break"><strong class="source-inline">forEach()</strong></span><span class="No-Break">.</span></p>
			<p>We follow that with the next two lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
   IntStream even = IntStream.iterate(2, (n) -&gt; n + 2);   even.limit(5).forEach(System.out::println);</pre>
			<p>The <strong class="source-inline">IntStream.iterate()</strong> method has equivalent versions in <strong class="source-inline">DoubleStream</strong> and <strong class="source-inline">LongStream</strong>. It takes two arguments, an <strong class="source-inline">int</strong> seed (the starting value) and an <strong class="source-inline">IntUnaryOperator</strong> function. This <strong class="source-inline">IntUnaryOperator</strong> function takes in an <strong class="source-inline">int</strong> and returns an <strong class="source-inline">int</strong>. It is the <strong class="source-inline">int</strong> primitive specialization of <strong class="source-inline">UnaryOperator&lt;T&gt;</strong>. The stream of numbers generated are even numbers, starting at <strong class="source-inline">2</strong>. As the sequence of numbers is infinite, we apply a limit of 5 numbers (<strong class="source-inline">2</strong>, <strong class="source-inline">4</strong>, <strong class="source-inline">6</strong>, <span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">).</span></p>
			<p>Let us now examine common primitive <span class="No-Break">stream methods.</span></p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor413"/>Common primitive stream methods</h2>
			<p>The<a id="_idIndexMarker1369"/> methods just presented, namely <strong class="source-inline">of()</strong>, <strong class="source-inline">generate()</strong> and <strong class="source-inline">iterate()</strong> are common to <strong class="source-inline">Stream&lt;T&gt;</strong> as well. <em class="italic">Table 16.2</em> presents commonly used methods that are unique to <span class="No-Break">primitive streams.</span></p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/B19793_16_Table_02.jpg" alt="Table 16.2 - Common primitive stream methods"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.2 - Common primitive stream methods</p>
			<p>This table has two columns: the name of the method (including its return type) and the primitive streams. Each of the methods listed are reductions and terminal operations. Recall that a reduction produces a single summary result by repeatedly applying an operation to a sequence of input results. We saw the general form of reductions with the <strong class="source-inline">reduce()</strong> and <strong class="source-inline">collect()</strong> methods in the <strong class="source-inline">Stream&lt;T&gt;</strong> interface. The reductions in this table are specialized <span class="No-Break">for primitives.</span></p>
			<p>Let us first examine the <strong class="source-inline">sum()</strong> method. Notice that it does not return an <strong class="source-inline">Optional</strong> whereas all the other methods do. This is because <strong class="source-inline">0</strong> is a valid value to return for the sum of an empty stream. In other words, if the stream is empty when you execute <strong class="source-inline">sum()</strong> - perhaps all of the data has been filtered out - then <strong class="source-inline">0</strong> is a valid return. The other methods <a id="_idIndexMarker1370"/>in the table, however, would need to return an empty <strong class="source-inline">Optional</strong> in that scenario. The <strong class="source-inline">IntStream</strong> for <strong class="source-inline">sum()</strong> returns an <strong class="source-inline">int</strong>, the version in <strong class="source-inline">LongStream</strong> returns a <strong class="source-inline">long</strong> and the version in <strong class="source-inline">DoubleStream</strong> returns <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
			<p>Regarding <strong class="source-inline">min()</strong> and <strong class="source-inline">max()</strong>, both <strong class="source-inline">IntStream</strong> versions return an <strong class="source-inline">OptionalInt</strong>; both <strong class="source-inline">LongStream</strong> versions return an <strong class="source-inline">OptionalLong</strong> and both <strong class="source-inline">DoubleStream</strong> versions return <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">OptionalDouble</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">average()</strong> method is a little different because of the possibility of decimal places regardless of the type being totaled. So all three primitive stream types, namely <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong>, and <strong class="source-inline">DoubleStream</strong> return <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">OptionalDouble</strong></span><span class="No-Break">.</span></p>
			<p>Let us examine them in code (PrimitiveStreams.java in the repo). Firstly, <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.10</em> presents <strong class="source-inline">min()</strong>, <strong class="source-inline">max()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">average()</strong></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/B19793_16_10.jpg" alt="Figure 16.10 – The min(), max() and average() operations in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.10 – The min(), max() and average() operations in code</p>
			<p>In this figure, we start with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
   OptionalInt max = IntStream.of(10, 20, 30)           .max(); // terminal operation
   max.ifPresent(System.out::println);// 30</pre>
			<p>Firstly, we <a id="_idIndexMarker1371"/>create a stream of <strong class="source-inline">int</strong> primitives. We then execute the terminal operation <strong class="source-inline">max()</strong>, which starts the stream and calculates the maximum number in the stream, which is 30. No need for any <strong class="source-inline">Comparator</strong> or accumulator here! We then use the <strong class="source-inline">ifPresent(IntConsumer)</strong> from <strong class="source-inline">OptionalInt</strong> (there are equivalents for <strong class="source-inline">OptionalDouble</strong> and <strong class="source-inline">OptionalLong</strong>). What this method means, is that, if there is a value <em class="italic">present</em> in the <strong class="source-inline">OptionalInt</strong>, output it. If the optional is empty, nothing <span class="No-Break">is printed.</span></p>
			<p>The next code segment of <span class="No-Break">interest is:</span></p>
			<pre class="source-code">
   OptionalDouble min = DoubleStream.of(10.0, 20.0, 30.0)           .min(); // terminal operation
   // NoSuchElementException is thrown if no value present
   System.out.println(min.orElseThrow());// 10.0</pre>
			<p>In this code segment, we create a <strong class="source-inline">DoubleStream</strong> based on the values provided in the varargs argument. Using <strong class="source-inline">min()</strong>, we stream the values and calculate the minimum value. The <strong class="source-inline">orElseThrow()</strong> method means: if there is a value present, return that value; otherwise throw <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NoSuchElementException</strong></span><span class="No-Break">.</span></p>
			<p>The last code <span class="No-Break">segment is:</span></p>
			<pre class="source-code">
   OptionalDouble average = LongStream.of(10L, 20L, 30L)           .average(); // terminal operation
   System.out.println(average.orElseGet(() -&gt; Math.random())); // 20.0</pre>
			<p>Here, we create a <strong class="source-inline">LongStream</strong> based on the values provided in the varargs argument. This is followed by executing <strong class="source-inline">average()</strong>, which both streams the values and calculates their average. The <strong class="source-inline">orElseGet(DoubleSupplier)</strong> method means: if there is a value present, return that value; otherwise return the value from the supplying function (a <span class="No-Break">random number).</span></p>
			<p>Let us now examine <strong class="source-inline">sum()</strong>. It is easy to see why primitive streams are useful in the next<a id="_idIndexMarker1372"/> example, <span class="No-Break"><em class="italic">Figure 16</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/B19793_16_11.jpg" alt="Figure 16.11 - The sum() primitive operation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.11 - The sum() primitive operation</p>
			<p>In this figure, we <a id="_idIndexMarker1373"/>start out with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
   IntStream is = IntStream.of(4, 2, 3);   System.out.println(is.sum());// 9</pre>
			<p>This code creates an <strong class="source-inline">int</strong> primitive stream directly using the <strong class="source-inline">IntStream.of()</strong> method and uses the <strong class="source-inline">sum()</strong> terminal method to stream the numbers and return the sum, which <span class="No-Break">is 9.</span></p>
			<p>The rest of the example code, contrasts <strong class="source-inline">reduce()</strong> from <strong class="source-inline">Stream&lt;T&gt;</strong> and <strong class="source-inline">sum()</strong> from <strong class="source-inline">IntStream</strong>. Let us focus on <span class="No-Break"><strong class="source-inline">reduce()</strong></span><span class="No-Break"> first:</span></p>
			<pre class="source-code">
   Stream&lt;Integer&gt; numbers = Stream.of(1,2,3);  System.out.println(numbers.reduce(0, (n1, n2) -&gt; n1 + n2)); // 6</pre>
			<p>Initially, we stream a list of <strong class="source-inline">Integer</strong>s into a <strong class="source-inline">Stream&lt;Integer&gt;</strong> and them sum them up by passing an accumulator function argument <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">reduce()</strong></span><span class="No-Break">.</span></p>
			<p>Now we will focus on how to do the same thing <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">sum()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   Stream&lt;Integer&gt; sInteger = Stream.of(1,2,3);   IntStream intS           = sInteger.mapToInt( n -&gt; n); // unboxed
   System.out.println(intS.sum()); // 6</pre>
			<p>Firstly, we <a id="_idIndexMarker1374"/>stream the same numbers as a <strong class="source-inline">Stream&lt;Integer&gt;</strong> again - we do not have a stream of primitives at this point. The second line shows how easy it is to convert from a <strong class="source-inline">Stream&lt;Integer&gt;</strong> to a <strong class="source-inline">Stream</strong> of <strong class="source-inline">int</strong> primitives. Using the <strong class="source-inline">Stream</strong> interfaces <strong class="source-inline">mapToInt()</strong> function; we pass in our function, which takes in an <strong class="source-inline">Integer</strong> and returns the <strong class="source-inline">int</strong> primitive wrapped by that <strong class="source-inline">Integer</strong>. In this code, we are availing of auto-unboxing by simply specifying the identifier <strong class="source-inline">n</strong> on both sides of the arrow token in the lambda. Now that we have an <strong class="source-inline">IntStream</strong> object we can use the <strong class="source-inline">sum()</strong> method - which streams the integers and returns the sum of 6. Note that we have deliberately left the return types visible in the code. This helps explain what is happening in the pipeline. In reality, you would code it much more concisely <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
int sum = Stream.of(1,2,3)                           .mapToInt(n -&gt; n)
                           .sum();
System.out.println(sum); // 6</pre>
			<p>With each of the primitive streams, you can get summarizing statistics (summary data about the elements in the stream). Let us look at these in action. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.12</em> <span class="No-Break">presents </span><span class="No-Break"><strong class="source-inline">IntSummaryStatistics</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/B19793_16_12.jpg" alt="Figure 16.12 - IntSummaryStatistics in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.12 - IntSummaryStatistics in code</p>
			<p>In this example, the streams are being passed in via the following <span class="No-Break">method calls:</span></p>
			<pre class="source-code">
   stats(IntStream.of(5, 10, 15, 20));   stats(IntStream.empty());</pre>
			<p>The first<a id="_idIndexMarker1375"/> invocation passes in a valid stream of integers whereas the second stream is empty. Once inside the <strong class="source-inline">stats()</strong> method, the terminal operation <strong class="source-inline">summaryStatistics()</strong> is executed on the <strong class="source-inline">IntStream</strong> passed in. The resultant <strong class="source-inline">IntSummaryStatistics</strong> object is now available to inspect for <span class="No-Break">summary data:</span></p>
			<pre class="source-code">
   IntSummaryStatistics intStats = numbers.summaryStatistics(); // terminal op.</pre>
			<p>The output for the first stream (5, 10, 15 and <span class="No-Break">20) is:</span></p>
			<pre class="console">
520
12.5
4
50</pre>
			<p><strong class="source-inline">5</strong> is output by <strong class="source-inline">getMin()</strong>; <strong class="source-inline">20</strong> is output by <strong class="source-inline">getMax()</strong>; <strong class="source-inline">12.5</strong> is output by <strong class="source-inline">getAverage()</strong>; <strong class="source-inline">4</strong> is output by <strong class="source-inline">getCount()</strong> and <strong class="source-inline">50</strong> is output <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">getSum()</strong></span><span class="No-Break">.</span></p>
			<p>The output for the empty <span class="No-Break">stream is:</span></p>
			<pre class="console">
2147483647-2147483648
0.0
0
0</pre>
			<p><strong class="source-inline">2147483647</strong> (which is <strong class="source-inline">Integer.MAX_VALUE</strong>) is output by <strong class="source-inline">getMin()</strong>; <strong class="source-inline">-2147483648</strong> (<strong class="source-inline">Integer.MIN_VALUE</strong>) is output by <strong class="source-inline">getMax()</strong>; 0.0 is output by <strong class="source-inline">getAverage()</strong>; 0 is output by <strong class="source-inline">getCount()</strong> and 0 is output <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">getSum()</strong></span><span class="No-Break">.</span></p>
			<p>With primitive streams there are now extra functional interfaces that we need to be <span class="No-Break">aware of.</span></p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor414"/>New primitive stream interfaces</h2>
			<p>There <a id="_idIndexMarker1376"/>are many new functional interfaces to be aware of. Thankfully, they follow a consistent naming pattern. <em class="italic">Table 16.3</em> outlines the more common ones. For further details please see the JavaDocs <span class="No-Break">at:</span><span class="No-Break"><span class="hidden"> </span></span><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html</span></a><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/B19793_16_Table_03.jpg" alt="Tables 16.3 (a) and (b) - New primitive stream functional interfaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Tables 16.3 (a) and (b) - New primitive stream functional interfaces</p>
			<p>In this figure, table A is on the left, with table B on the right. Each table has two columns - one for the functional interface name and one for its <span class="No-Break">functional method.</span></p>
			<p>We have deliberately included the generically marked functional interfaces encountered earlier. This is to help contrast them with their primitive counterparts. The previous functional interfaces that we came across are:  <strong class="source-inline">Supplier&lt;T&gt;,</strong> <strong class="source-inline">Consumer&lt;T&gt;</strong>, <strong class="source-inline">BiConsumer&lt;T, U&gt;</strong>, <strong class="source-inline">Predicate&lt;T&gt;</strong>, <strong class="source-inline">BiPredicate&lt;T, U&gt;</strong>, <strong class="source-inline">Function&lt;T, R&gt;</strong>, <strong class="source-inline">BiFunction&lt;T, U, R&gt;</strong>, <strong class="source-inline">UnaryOperator&lt;T&gt;</strong> and <strong class="source-inline">BinaryOperator&lt;T&gt;</strong>. Note the generic types in them all. Very few primitive functional interfaces use generics, as they are typed for a <span class="No-Break">particular primitive.</span></p>
			<p>We have color-coordinated the interfaces in order to group them. So for example, in table A the yellow colored interfaces are the suppliers. <strong class="source-inline">Supplier&lt;T&gt;</strong> with its <strong class="source-inline">T get()</strong> functional method - as stated, this is included for comparison purposes. <strong class="source-inline">DoubleSupplier</strong> is the interface for generating <strong class="source-inline">double</strong> primitives. Its functional method is <strong class="source-inline">getAsDouble()</strong> and its return type is a <strong class="source-inline">double</strong>. The <strong class="source-inline">IntSupplier</strong> and <strong class="source-inline">LongSupplier</strong> interfaces follow the <span class="No-Break">same pattern.</span></p>
			<p>Still in table A, the <a id="_idIndexMarker1377"/>consumers are next, in green. <strong class="source-inline">DoubleConsumer</strong> “accepts” a <strong class="source-inline">double</strong> primitive and returns nothing. <strong class="source-inline">IntConsumer</strong> accepts in an <strong class="source-inline">int</strong>, returns nothing; and <strong class="source-inline">LongConsumer</strong> accepts in a <strong class="source-inline">long</strong>, returns nothing. All the functional methods are called <strong class="source-inline">accept()</strong>. Note the pattern for naming: suppliers use <strong class="source-inline">DoubleSupplier</strong>; consumers <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">DoubleConsumer</strong></span><span class="No-Break">.</span></p>
			<p>This naming convention continues with the predicates (blue). We have <strong class="source-inline">DoublePredicate</strong> that “tests” a <strong class="source-inline">double</strong> and returns a <strong class="source-inline">boolean</strong>. <strong class="source-inline">IntPredicate</strong> and <strong class="source-inline">LongPredicate</strong> behave in a similar manner - a primitive type parameter and a return type <strong class="source-inline">boolean</strong>. All the functional methods are <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">test()</strong></span><span class="No-Break">.</span></p>
			<p>In table B, we have the functions, in yellow. We have <strong class="source-inline">DoubleFunction&lt;R&gt;</strong> that “applies” a <strong class="source-inline">double</strong> and returns the type <strong class="source-inline">R</strong>. The functions are a case where generics are used to represent the type being returned. However, the primitive being applied is the important aspect here. <strong class="source-inline">IntFunction&lt;R&gt;</strong> and <strong class="source-inline">LongFunction&lt;R&gt;</strong> behave in a similar manner - a primitive type parameter and a return type <strong class="source-inline">R</strong>. All the functional methods are <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">apply()</strong></span><span class="No-Break">.</span></p>
			<p>Lastly, in table B, we have the primitive versions of <strong class="source-inline">UnaryOperator&lt;T&gt;</strong> and <strong class="source-inline">BinaryOperator&lt;T&gt;</strong>. The <strong class="source-inline">double</strong> primitive version of <strong class="source-inline">UnaryOperator&lt;T&gt;</strong> is <strong class="source-inline">DoubleUnaryOperator</strong> (note the word <strong class="source-inline">Double</strong> at the start again). Recall that unary functions are functions that accept in one parameter and return a value; where both types are the same. Therefore, <strong class="source-inline">DoubleUnaryOperator</strong> has a <strong class="source-inline">double</strong> parameter and a <strong class="source-inline">double</strong> return type. <strong class="source-inline">IntUnaryOperator</strong> and <strong class="source-inline">LongUnaryOperator</strong> follow the <span class="No-Break">same pattern.</span></p>
			<p>The <strong class="source-inline">DoubleBinaryOperator</strong>, <strong class="source-inline">IntBinaryOperator</strong> and <strong class="source-inline">LongBinaryOperator</strong> interfaces only differ from their unary counterparts in the number of parameters they take in. Therefore, <strong class="source-inline">DoubleBinaryOperator</strong> takes in two <strong class="source-inline">double</strong>s, <strong class="source-inline">IntBinaryOperator</strong> takes in two <strong class="source-inline">int</strong>s and <strong class="source-inline">LongBinaryOperator</strong> takes in <span class="No-Break">two </span><span class="No-Break"><strong class="source-inline">long</strong></span><span class="No-Break">s.</span></p>
			<p>There are other ways to create streams and that is by mapping from other streams. Let us examine <span class="No-Break">that now.</span></p>
			<h1 id="_idParaDest-415"><a id="_idTextAnchor415"/>Mapping streams</h1>
			<p>Again, there<a id="_idIndexMarker1378"/> are many new functional interfaces to be aware of; and again, thankfully, they follow a consistent naming pattern. <em class="italic">Table 16.4</em> outlines the more <span class="No-Break">common ones.</span></p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/B19793_16_Table_04.jpg" alt="Table 16.4 - Mapping streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.4 - Mapping streams</p>
			<p>In this table, the rows represent the source stream class and the columns represent the target stream class. Again, we use color to help organize our explanations. The yellow boxes represent situations where the source and target classes are the same. So, for example, if you are going from a <strong class="source-inline">DoubleStream</strong> to another <strong class="source-inline">DoubleStream</strong>, the method is <strong class="source-inline">map(DoubleUnaryOperator)</strong>. The functional method is also listed - so for this example, <strong class="source-inline">DoubleUnaryOperator</strong>‘s functional method is <span class="No-Break"><strong class="source-inline">double applyAsDouble(double)</strong></span><span class="No-Break">.</span></p>
			<p>Let us examine the brown boxes. Each of these uses a <strong class="source-inline">mapToObj()</strong> method as the source is a primitive stream and the target is a stream of objects. The source stream hints at the function to be used. For example, if the source is a <strong class="source-inline">DoubleStream</strong> then the <strong class="source-inline">DoubleFunction</strong> interface applies, as you are mapping from a <strong class="source-inline">double</strong> primitive to a type <strong class="source-inline">R</strong>. This is specified in the functional method <strong class="source-inline">R </strong><span class="No-Break"><strong class="source-inline">apply(double value)</strong></span><span class="No-Break">.</span></p>
			<p>Next the green boxes. The target stream is <strong class="source-inline">DoubleStream</strong> and hence the method name is <strong class="source-inline">mapToDouble()</strong>. If the source stream is a stream of objects then the interface is <strong class="source-inline">ToDoubleFunction&lt;T&gt;</strong>. Its functional method is <strong class="source-inline">double</strong> <strong class="source-inline">applyAsDouble(T value)</strong>, so a type <strong class="source-inline">T</strong> is input and a <strong class="source-inline">double</strong> primitive is output. Just what you would expect, when going from an object of type <strong class="source-inline">T</strong> to a <span class="No-Break">primitive </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
			<p>Staying with the<a id="_idIndexMarker1379"/> target stream of <strong class="source-inline">DoubleStream</strong>, if the source was an <strong class="source-inline">IntStream</strong>, then the primitives involved are in the name of the interface: <strong class="source-inline">IntToDoubleFunction</strong>. No surprise that its functional method is <strong class="source-inline">double</strong> <strong class="source-inline">applyAsDouble(int)</strong>. If the source was a <strong class="source-inline">LongStream</strong>, then the primitives involved are again in the name of the interface: <strong class="source-inline">LongToDoubleFunction</strong>. No surprise either that its functional method is <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">applyAsDouble(long)</strong></span><span class="No-Break">.</span></p>
			<p>The blue boxes represent a target stream of <strong class="source-inline">IntStream</strong>. The method name is <strong class="source-inline">mapToInt()</strong>. The functional interfaces used as parameters and their functional methods, follow the same naming pattern as outlined <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">DoubleStream</strong></span><span class="No-Break">.</span></p>
			<p>Lastly, the grey boxes represent a target stream of <strong class="source-inline">LongStream</strong>. The method name is <strong class="source-inline">mapToLong()</strong>. A similar naming pattern is again applied to the functional interfaces and their functional methods as shown in <strong class="source-inline">DoubleStream</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">IntStream</strong></span><span class="No-Break">.</span></p>
			<p>Let us look at some code examples. We will start with mapping from streams <span class="No-Break">of objects.</span></p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor416"/>Mapping from Object streams</h2>
			<p>The first <a id="_idIndexMarker1380"/>example will have a <strong class="source-inline">Stream&lt;String&gt;</strong> as the source and map to the various other streams accordingly. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.13</em> represents the code (<strong class="source-inline">MappingStreams.java</strong> in <span class="No-Break">the repo).</span></p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/B19793_16_13.jpg" alt="Figure 16.13 - Mapping Object streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.13 - Mapping Object streams</p>
			<p>In this figure, we <a id="_idIndexMarker1381"/>are mapping a <strong class="source-inline">Stream&lt;String&gt;</strong> to all the other stream types, including <strong class="source-inline">Stream&lt;String&gt;</strong> itself. The first <span class="No-Break">example is:</span></p>
			<pre class="source-code">
// Stream&lt;T&gt; to Stream&lt;T&gt;Stream.of("ash", "beech", "sycamore")
        // map(Function&lt;T,R&gt;)
        //    Function&lt;T,R&gt; =&gt; Function&lt;String, String&gt;
        //       String apply(String s)
        .map(tree -&gt; tree.toUpperCase())
        .forEach(System.out::println);// ASH, BEECH, SYCAMORE</pre>
			<p>In this case, the <strong class="source-inline">map(Function&lt;T,R&gt;)</strong> maps from <strong class="source-inline">String</strong> to <strong class="source-inline">String</strong>. The function converts the string to uppercase. The <strong class="source-inline">forEach()</strong> terminal operation starts the streaming <a id="_idIndexMarker1382"/>process and outputs <span class="No-Break">the strings.</span></p>
			<p>The second <span class="No-Break">example is:</span></p>
			<pre class="source-code">
// Stream&lt;T&gt; to DoubleStreamDoubleStream dblStream = Stream.of("ash", "beech", "sycamore")
        // mapToDouble(ToDoubleFunction&lt;T&gt;)
        //   ToDoubleFunction&lt;T&gt; is a functional interface:
        //      double applyAsDouble(T value) =&gt; double applyAsDouble(String tree)
        .mapToDouble(tree -&gt; tree.length()); // upcast in background
dblStream.forEach(System.out::println); // 3.0, 5.0, 8.0</pre>
			<p>This time the <strong class="source-inline">Stream&lt;String&gt;</strong> is mapped to a <strong class="source-inline">DoubleStream</strong> (of <strong class="source-inline">double</strong> primitives). Notice that we must re-stream the source as the previous <strong class="source-inline">forEach()</strong> closed it. This pipeline uses the <strong class="source-inline">mapToDouble(ToDoubleFunction&lt;T&gt;)</strong> to map from a <strong class="source-inline">String</strong> to a <strong class="source-inline">double</strong> primitive. The function this time use the <strong class="source-inline">length()</strong> of the <strong class="source-inline">String</strong> which is an <strong class="source-inline">int</strong>. This <strong class="source-inline">int</strong> is upcast to a <strong class="source-inline">double</strong> in the background. The <strong class="source-inline">forEach()</strong>starts the stream and outputs the <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> values.</span></p>
			<p>The third <span class="No-Break">example is:</span></p>
			<pre class="source-code">
// Stream&lt;T&gt; to IntStreamIntStream intStream    = Stream.of("ash", "beech", "sycamore")
        // mapToInt(ToIntFunction&lt;T&gt;)
        //   ToIntFunction&lt;T&gt; is a functional interface:
        //      int applyAsInt(T value) =&gt; int applyAsInt(String tree)
        .mapToInt(tree -&gt; tree.length());
intStream.forEach(System.out::println); // 3, 5, 8</pre>
			<p>This<a id="_idIndexMarker1383"/> time the <strong class="source-inline">Stream&lt;String&gt;</strong> is mapped to an <strong class="source-inline">IntStream</strong>. Again we must re-stream the source. This pipeline uses the <strong class="source-inline">mapToInt(ToIntFunction&lt;T&gt;)</strong> to map from a <strong class="source-inline">String</strong> to an <strong class="source-inline">int</strong> primitive. We again use the <strong class="source-inline">length()</strong> function of <strong class="source-inline">String</strong>. As this is an <strong class="source-inline">int</strong>, no upcasting is required in the background. The <strong class="source-inline">forEach()</strong> terminal operation is used to start the stream and output the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values.</span></p>
			<p>The last <span class="No-Break">example is:</span></p>
			<pre class="source-code">
// Stream&lt;T&gt; to LongStreamLongStream longStream = Stream.of("ash", "beech", "sycamore")
        // mapToLong(ToLongFunction&lt;T&gt;)
        //   ToLongFunction&lt;T&gt; is a functional interface:
        //      long applyAsLong(T value) =&gt; long applyAsLong(String tree)
        .mapToLong(tree -&gt; tree.length()); // upcast in background
longStream.forEach(System.out::println); // 3, 5, 8</pre>
			<p>Here, the <strong class="source-inline">Stream&lt;String&gt;</strong> is mapped to a <strong class="source-inline">LongStream</strong>. This pipeline uses the <strong class="source-inline">mapToLong(ToLongFunction&lt;T&gt;)</strong> to map from a <strong class="source-inline">String</strong> to a <strong class="source-inline">long</strong> primitive. As the <strong class="source-inline">length()</strong> of <strong class="source-inline">String</strong> returns an <strong class="source-inline">int</strong>, upcasting is done in the background. The <strong class="source-inline">long</strong> values are output as part of the <strong class="source-inline">forEach()</strong> <span class="No-Break">terminal operation.</span></p>
			<p>Now let us examine code examples mapping from streams <span class="No-Break">of primitives.</span></p>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor417"/>Mapping from primitive streams</h2>
			<p>In this example, we<a id="_idIndexMarker1384"/> are mapping from streams of primitives to other stream types. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.14</em> presents the <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">MappingStreams.java</strong></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B19793_16_14.jpg" alt="Figure 16.14 - Mapping primitive streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.14 - Mapping primitive streams</p>
			<p>In this example, we are<a id="_idIndexMarker1385"/> streaming <strong class="source-inline">int</strong> primitives using <strong class="source-inline">IntStream.of()</strong>, and converting the <strong class="source-inline">IntStream</strong> to a <strong class="source-inline">Stream&lt;String&gt;</strong>, <strong class="source-inline">DoubleStream</strong>, <strong class="source-inline">IntStream</strong> and <strong class="source-inline">LongStream</strong> <span class="No-Break">in turn.</span></p>
			<p>Here is the <span class="No-Break">first example:</span></p>
			<pre class="source-code">
// IntStream to Stream&lt;T&gt;Stream&lt;String&gt; streamStr = IntStream.of(1, 2, 3)
        // mapToObj(IntFunction&lt;R&gt;)
        //    IntFunction is a functional interface:
        //       R apply(int value)
        .mapToObj(n -&gt; "Number:"+ n);
streamStr.forEach(System.out::println);// Number:1, Number:2, Number:3</pre>
			<p>This code <a id="_idIndexMarker1386"/>represents a sample pipeline for streaming <strong class="source-inline">int</strong> primitives and mapping them to a stream of <strong class="source-inline">String</strong> objects. The <strong class="source-inline">mapToObj()</strong> method is important here. It’s signature is: <strong class="source-inline">Stream&lt;R&gt; mapToObj(IntFunction&lt;R&gt;)</strong>. The lambda passed in is easier to understand when we look at the functional method of the functional interface <strong class="source-inline">IntFunction&lt;R&gt;</strong>. The functional method is <strong class="source-inline">R apply(int value)</strong>. In our example, the <strong class="source-inline">int</strong> primitive is passed in as <strong class="source-inline">n</strong> and the <strong class="source-inline">String</strong> returned (represented by <strong class="source-inline">R</strong> in the method signature) is the string formed by prepending <strong class="source-inline">"Number:"</strong> in front of the <strong class="source-inline">int</strong>. Recall that when you have a string on the left or the right side (or both) of a <strong class="source-inline">+</strong> the result is a <strong class="source-inline">String</strong>. The <strong class="source-inline">forEach()</strong> streams the <strong class="source-inline">int</strong> primitives and outputs <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Stream&lt;String&gt;</strong></span><span class="No-Break">.</span></p>
			<p>The next <span class="No-Break">example is:</span></p>
			<pre class="source-code">
// IntStream to DoubleStreamDoubleStream dblStream = IntStream.of(1, 2, 3) // re-open closed stream
        // mapToDouble(IntToDoubleFunction)
        //   IntToDoubleFunction is a functional interface:
        //      double applyAsDouble(int value)
        .mapToDouble(n -&gt; (double)n); // cast NOT necessary
dblStream.forEach(System.out::println); // 1.0, 2.0, 3.0</pre>
			<p>This code is mapping from an <strong class="source-inline">IntStream</strong> to a <strong class="source-inline">DoubleStream</strong>. The <strong class="source-inline">mapToDouble()</strong> method is important here. It’s <span class="No-Break">signature is:</span></p>
			<p><strong class="source-inline">DoubleStream</strong> <strong class="source-inline">mapToDouble(IntToDoubleFunction)</strong>. The functional method for <strong class="source-inline">IntToDoubleFunction</strong> is <strong class="source-inline">double applyAsDouble(int value)</strong>. Thus, our lambda passes in an <strong class="source-inline">int</strong> and returns a <strong class="source-inline">double</strong>. The cast is not necessary and<a id="_idIndexMarker1387"/> it just there to emphasize that a <strong class="source-inline">double</strong> primitive <span class="No-Break">is returned.</span></p>
			<p>Here is the <span class="No-Break">next example:</span></p>
			<pre class="source-code">
// IntStream to IntStreamIntStream intStream = IntStream.of(1, 2, 3)
        //  map(IntUnaryOperator)
        //    IntUnaryOperator is a functional interface:
        //        int applyAsInt(int)
        .map(n -&gt; n*2);
intStream.forEach(System.out::println);// 2, 4, 6</pre>
			<p>Here we are mapping an <strong class="source-inline">IntStream</strong> to another <strong class="source-inline">IntStream</strong>. The method <strong class="source-inline">IntStream map(IntUnaryOperator)</strong> is used. Its functional <span class="No-Break">method is:</span></p>
			<p><strong class="source-inline">int applyAsInt(int value)</strong> so we pass in an <strong class="source-inline">int</strong> and get back an <strong class="source-inline">int</strong>. Our lambda is simply multiplying the <strong class="source-inline">int</strong> coming in by 2 and returning <span class="No-Break">the result.</span></p>
			<p>And the <span class="No-Break">last example:</span></p>
			<pre class="source-code">
// IntStream to LongStreamLongStream longStream = IntStream.of(1, 2, 3)
        // mapToLong(IntToLongFunction)
        //   IntToLongFunction is a functional interface:
        //      long applyAsLong(int value)
        .mapToLong(n -&gt; (long)n); // cast NOT necessary
longStream.forEach(System.out::println); // 1, 2, 3</pre>
			<p>This code maps an <strong class="source-inline">IntStream</strong> to a <strong class="source-inline">LongStream</strong>. The method <strong class="source-inline">LongStream mapToLong(IntToLongFunction)</strong> is used. Its functional <span class="No-Break">method is:</span></p>
			<p><strong class="source-inline">long applyAsLong(int value)</strong> so we pass in an <strong class="source-inline">int</strong> and get back a <strong class="source-inline">long</strong>. Again, the cast<a id="_idIndexMarker1388"/> is not necessary, it is simply emphasizing that a <strong class="source-inline">long</strong> primitive <span class="No-Break">is returned.</span></p>
			<p>That completes our coverage of mapping streams. Let us now move on to <span class="No-Break">examining </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">s.</span></p>
			<h1 id="_idParaDest-418"><a id="_idTextAnchor418"/>Explaining Optionals</h1>
			<p>An <strong class="source-inline">Optional</strong> can <a id="_idIndexMarker1389"/>be thought of as a container that may or may not be empty. As per the API, the container “may or may not contain a non-<strong class="source-inline">null</strong> value”. An <strong class="source-inline">Optional</strong> is primarily used as a method return type where there is a real need to represent “no result” and when returning <strong class="source-inline">null</strong> could cause errors. Before Java 8, programmers would return <strong class="source-inline">null</strong> but now, since Java 8, we can return an <em class="italic">empty</em> <strong class="source-inline">Optional</strong> instead. This has <span class="No-Break">several advantages:</span></p>
			<ul>
				<li>Reduces the risk <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">NullPointerException</strong></span><span class="No-Break">s</span></li>
				<li>By using <strong class="source-inline">Optional</strong> as the return type, the API can now clearly state that there may not be a <span class="No-Break">value returned</span></li>
				<li>The <strong class="source-inline">Optional</strong> API facilitates the functional <span class="No-Break">programming style</span></li>
			</ul>
			<p>As well as <strong class="source-inline">Optional&lt;T&gt;</strong>, there are <strong class="source-inline">Optional</strong>s for the primitive types also; namely: <strong class="source-inline">OptionalInt</strong>, <strong class="source-inline">OptionalDouble</strong> and <strong class="source-inline">OptionalLong</strong>. We will examine <span class="No-Break">them later.</span></p>
			<p>Let us first look at how to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">s.</span></p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor419"/>Creating Optionals</h2>
			<p>The API provides<a id="_idIndexMarker1390"/> several <strong class="source-inline">static</strong> methods for this purpose. Let’s start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Optional.of(T)</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
Optional&lt;T&gt; Optional.of(T value)</pre>			<p>The <strong class="source-inline">value</strong> parameter is wrapped in an <strong class="source-inline">Optional</strong>. The <strong class="source-inline">value</strong> passed must be a non-<strong class="source-inline">null</strong> value. If <strong class="source-inline">null</strong> is passed in, a <span class="No-Break"><strong class="source-inline">NullPointerException </strong></span><span class="No-Break">results.</span></p>
			<p>Now, let us look at <strong class="source-inline">Optional.empty()</strong>. This is how you create an empty <span class="No-Break">Optional instance.</span></p>
			<pre class="source-code">
Optional.empty()</pre>			<p>Lastly, we <a id="_idIndexMarker1391"/>will <span class="No-Break">examine </span><span class="No-Break"><strong class="source-inline">Optional.ofNullable(T)</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
Optional.ofNullable(T value)</pre>			<p>If the given <strong class="source-inline">value</strong> is non-<strong class="source-inline">null</strong>, this method returns the wrapped <strong class="source-inline">value</strong> in an <strong class="source-inline">Optional</strong>. If <strong class="source-inline">null</strong> is passed in, an empty <strong class="source-inline">Optional</strong> is returned. If we examine the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
Optional opt1 = Optional.ofNullable(value);Optional opt2 = (value == null) ? Optional.empty() : Optional.of(value);</pre>
			<p>Both of these lines do the same thing. The first line is shorthand for the ternary operator on the second line. The ternary operator is expressing the following: if <strong class="source-inline">value</strong> is <strong class="source-inline">null</strong>, <strong class="source-inline">opt2</strong> is assigned an empty <strong class="source-inline">Optional</strong>; otherwise, <strong class="source-inline">opt2</strong> is assigned the <span class="No-Break">wrapped </span><span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.15</em> presents them in code (<strong class="source-inline">Optionals.java</strong> in <span class="No-Break">the repo).</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/B19793_16_15.jpg" alt="Figure 16.15 - Creating Optionals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.15 - Creating Optionals</p>
			<p>The first <a id="_idIndexMarker1392"/>example here creates an <span class="No-Break">empty </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        Optional opt1 = Optional.empty();//        System.out.println(opt1.get()); // NoSuchElementException
        opt1.ifPresent(o -&gt; System.out.println("opt1: "+o)); 
        // no exception</pre>
			<p>We use the <strong class="source-inline">Optional.empty()</strong> method to create an empty <strong class="source-inline">Optional</strong>. The next line is commented out because if you execute <strong class="source-inline">get()</strong> on an empty <strong class="source-inline">Optional</strong>, you will get a <strong class="source-inline">NoSuchElementException</strong> exception. The last line shows the functional style <strong class="source-inline">ifPresent(Consumer)</strong>. If a value is present, the given consumer is applied to the value; otherwise it does nothing. In this case, it does nothing as the <strong class="source-inline">Optional</strong> <span class="No-Break">is empty.</span></p>
			<p>The next example creates a <span class="No-Break">non-empty </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        Optional opt2 = Optional.of(23);//        Optional.of(null); // NullPointerException
        opt2.ifPresent(o -&gt; System.out.println("opt2: "+o)); 
        // opt2: 23</pre>
			<p>This time we create an <strong class="source-inline">Optional</strong> using <strong class="source-inline">Optional.of()</strong>, with the value 23. The second line shows that you will get a <strong class="source-inline">NullPointerException</strong> if you pass <strong class="source-inline">null</strong> to <strong class="source-inline">Optional.of()</strong>. The <strong class="source-inline">ifPresent()</strong> now executes the consumer passed, which outputs <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">opt2: 23"</strong></span><span class="No-Break">.</span></p>
			<p>The next <a id="_idIndexMarker1393"/>example <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">Optional.ofNullable()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Optional opt3 = Optional.ofNullable(23);opt3.ifPresent(o -&gt; System.out.println("opt3: "+o)); // opt3: 23</pre>
			<p>Here we create an <strong class="source-inline">Optional</strong> using <strong class="source-inline">Optional.ofNullable()</strong>, also with the value 23. As the <strong class="source-inline">Optional</strong> is not empty, the consumer passed to <strong class="source-inline">ifPresent()</strong> outputs <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">opt3: 23"</strong></span><span class="No-Break">.</span></p>
			<p>Here is the <span class="No-Break">last example:</span></p>
			<pre class="source-code">
Optional opt4 = Optional.ofNullable(null);opt4.ifPresent(o -&gt; System.out.println("opt4: "+o));
if(opt4.isEmpty()){
    System.out.println("opt4 is empty!");           // opt4 is empty!
}</pre>
			<p>In this example, we use <strong class="source-inline">Optional.ofNullable()</strong> again, but this time, we pass in <strong class="source-inline">null</strong>. Rather than getting an exception (which is what <strong class="source-inline">Optional.of(null)</strong> would generate), we get an <strong class="bold">empty</strong> <strong class="source-inline">Optional</strong>. As the <strong class="source-inline">Optional</strong> is empty, the <strong class="source-inline">ifPresent()</strong> does nothing. The <strong class="source-inline">isEmpty()</strong> proves that the <strong class="source-inline">Optional</strong> is in fact empty resulting in <strong class="source-inline">"opt4 is empty!"</strong> <span class="No-Break">being output.</span></p>
			<p>Now that we know how to create <strong class="source-inline">Optional</strong>s, let us explore the API <span class="No-Break">methods available.</span></p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor420"/>Using the Optional API</h2>
			<p><em class="italic">Table 16.5</em> represents <a id="_idIndexMarker1394"/>the instance methods <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">.</span></p>
			<table id="table002-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">What happens if Optional </strong><span class="No-Break"><strong class="bold">is empty</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">What happens if Optional has </strong><span class="No-Break"><strong class="bold">a value</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">get()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Throws </span><span class="No-Break"><strong class="source-inline">NoSuchElementException</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns <span class="No-Break">the value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">isPresent()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Returns </span><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Returns </span><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ifPresent(Consumer)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Does nothing</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Executes <strong class="source-inline">Consumer</strong> <span class="No-Break">with value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElse(T otherValue)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Returns </span><span class="No-Break"><strong class="source-inline">otherValue</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns <span class="No-Break">the value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseGet(Supplier)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns result of <span class="No-Break">executing </span><span class="No-Break"><strong class="source-inline">Supplier</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns <span class="No-Break">the value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseThrow()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Throws </span><span class="No-Break"><strong class="source-inline">NoSuchElementException</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns <span class="No-Break">the value</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseThrow(Supplier)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Throws exception returned by <strong class="source-inline">Supplier</strong>. However, if <strong class="source-inline">Supplier</strong> is <strong class="source-inline">null</strong>, throws <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NullPointerException</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Returns <span class="No-Break">the value</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.5 - Optional instance methods</p>
			<p>Many of these methods enable us <a id="_idIndexMarker1395"/>to write code in a more concise and expressive manner. <strong class="source-inline">ifPresent(Consumer)</strong> is a very good example - rather than having in <strong class="source-inline">if-else</strong> statement, <strong class="source-inline">ifPresent(Consumer)</strong> removes the need to code the <strong class="source-inline">else</strong> part. Additionally, <strong class="source-inline">ifPresent(Consumer)</strong> helps us express our intent more clearly - if a value <em class="italic">is present</em>, do this; otherwise <span class="No-Break">do nothing.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.16</em> presents methods from the <strong class="source-inline">Optional</strong> API <span class="No-Break">in code.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B19793_16_16.jpg" alt="Figure 16.16 - Optional methods in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.16 - Optional methods in code</p>
			<p>In this example, we <a id="_idIndexMarker1396"/>will use both a non-null <strong class="source-inline">Optional</strong> and an empty <strong class="source-inline">Optional</strong> to test the various methods. Let us start with a valid <span class="No-Break">non-null </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">.</span></p>
			<h3>Optional with a value</h3>
			<p>Firstly, we <a id="_idIndexMarker1397"/>create an <strong class="source-inline">Optional</strong> wrapped around the <span class="No-Break"><strong class="source-inline">Double 60.0</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   Optional&lt;Double&gt; valueInOptional = Optional.ofNullable(60.0);</pre>			<p>We then use <strong class="source-inline">isPresent()</strong> to ensure it is safe to execute the <strong class="source-inline">get()</strong> method, as executing <strong class="source-inline">get()</strong> on an empty <strong class="source-inline">Optional</strong> results in <span class="No-Break">an exception:</span></p>
			<pre class="source-code">
   if(valueInOptional.isPresent()){     System.out.println(valueInOptional.get());  // 60.0
   }</pre>
			<p>As <strong class="source-inline">isPresent()</strong> returns <strong class="source-inline">true</strong>, it is safe to execute <strong class="source-inline">get()</strong>, which returns <strong class="source-inline">60.0</strong> and this is output to <span class="No-Break">the screen.</span></p>
			<p>The next 2 <span class="No-Break">lines are:</span></p>
			<pre class="source-code">
   valueInOptional.ifPresent(System.out::println);// 60.0   System.out.println(valueInOptional.orElse(Double.NaN)); // 60.0</pre>
			<p>In this code <a id="_idIndexMarker1398"/>segment, as there is a non-null value in <strong class="source-inline">valueInOptional</strong>, the consumer argument to <strong class="source-inline">ifPresent()</strong> is executed, and <strong class="source-inline">60.0</strong> is output to the screen. In addition, as we have a value in <strong class="source-inline">valueInOptional</strong>, the <strong class="source-inline">orElse(T value)</strong> method is not executed; meaning that <strong class="source-inline">60.0</strong> is output to <span class="No-Break">the screen.</span></p>
			<h3>Empty Optional</h3>
			<p>Firstly, we<a id="_idIndexMarker1399"/> create an empty <strong class="source-inline">Optional</strong> by passing in <strong class="source-inline">null</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ofNullable()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   Optional&lt;Double&gt; emptyOptional = Optional.ofNullable(null);</pre>			<p>We <span class="No-Break">then have:</span></p>
			<pre class="source-code">
System.out.println(emptyOptional.orElse(Double.NaN)); // NaNSystem.out.println(emptyOptional.orElseGet(() -&gt; Math.random())); 
// 0.8524556508038182</pre>
			<p>The <strong class="source-inline">orElse(T value)</strong> returns <strong class="source-inline">NaN</strong> and <strong class="source-inline">orElseGet(Supplier)</strong> executes the <strong class="source-inline">Supplier</strong> which is to generate a random number. Note that the <strong class="source-inline">Supplier</strong> must return a <strong class="source-inline">Double</strong> as that is the type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">emptyOptional</strong></span><span class="No-Break">.</span></p>
			<p>Lastly, <span class="No-Break">we have:</span></p>
			<pre class="source-code">
    System.out.println(emptyOptional.orElseThrow()); // NoSuchElementException
// System.out.println(emptyOptional.orElseThrow(() -&gt; new RuntimeException()));</pre>
			<p>Both lines execute <strong class="source-inline">orElseThrow()</strong> and are mutually exclusive. What this means is that,  to see the exception on the second line, comment out the first line. As the <strong class="source-inline">Optional</strong> is empty, the first line throws a <strong class="source-inline">NoSuchElementException</strong>. Assuming we comment out the first line and uncomment the second line, the <strong class="source-inline">Supplier</strong> passed in to <strong class="source-inline">orElseThrow()</strong> will return a <strong class="source-inline">RuntimeException</strong>. Note that we do not use the keyword <strong class="source-inline">throw</strong> in our <strong class="source-inline">Supplier</strong>. The <strong class="source-inline">orElseThrow()</strong> method will do that for us - our job is to give it, via the <strong class="source-inline">Supplier</strong>, an exception object <span class="No-Break">to throw.</span></p>
			<p>Our last section <a id="_idIndexMarker1400"/>regarding <strong class="source-inline">Optional</strong>s, are <span class="No-Break">primitive </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">s.</span></p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor421"/>Primitive Optionals</h2>
			<p>As stated<a id="_idIndexMarker1401"/> earlier, there are <strong class="source-inline">Optional</strong>s for the primitive types also; namely: <strong class="source-inline">OptionalInt</strong>, <strong class="source-inline">OptionalDouble</strong> and <strong class="source-inline">OptionalLong</strong>. We <a id="_idIndexMarker1402"/>will look at <span class="No-Break">them now.</span></p>
			<p><em class="italic">Table 16.6</em> highlights the more commonly used primitive <span class="No-Break">stream methods.</span></p>
			<table id="table003-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">OptionalInt</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">OptionalDouble</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">OptionalLong</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">int getAsInt()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">double getAsDouble()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">long getAsLong()</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ifPresent(IntConsumer)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">void accept(int)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ifPresent (DoubleConsumer)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">void accept(double)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ifPresent(LongConsumer)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">void accept(long)</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">OptionalInt of(int)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">OptionalDouble of(double)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">OptionalLong of(long)</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">int </strong><span class="No-Break"><strong class="source-inline">orElse(int other)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">double orElse</strong></span><strong class="source-inline"> (</strong><span class="No-Break"><strong class="source-inline">double other)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">long </strong><span class="No-Break"><strong class="source-inline">orElse(long other)</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseGet(IntSupplier)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">int getAsInt()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseGet (DoubleSupplier)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">double getAsDouble()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">orElseGet(LongSupplier)</strong></span></p>
							<p><span class="No-Break"><strong class="source-inline">long getAsLong()</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">IntStream stream()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">DoubleStream stream()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">LongStream stream()</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 16.6 - Commonly used primitive stream methods</p>
			<p>This table contrasts the more commonly used methods across the primitive streams. Where appropriate, the functional method is also listed, beneath the functional interface. For example, examining the <strong class="source-inline">ifPresent(IntConsumer)</strong> for <strong class="source-inline">OptionalInt</strong> shows that <strong class="source-inline">IntConsumer</strong>’s functional method is <span class="No-Break"><strong class="source-inline">void accept(int)</strong></span><span class="No-Break">.</span></p>
			<p>Note that the <a id="_idIndexMarker1403"/>return types for the <strong class="source-inline">orElseGet()</strong> methods can be deduced from the functional methods just below. For example, examining the <strong class="source-inline">orElseGet()</strong> for <strong class="source-inline">OptionalInt</strong> shows that <strong class="source-inline">IntSupplier</strong>’s functional method is <strong class="source-inline">int getAsInt()</strong>. Therefore, the return type for <strong class="source-inline">orElseGet(IntSupplier)</strong> is <span class="No-Break">also </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">.</span></p>
			<p>Let us examine<a id="_idIndexMarker1404"/> some of these in code. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.17</em> is the <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">Optionals.java</strong></span><span class="No-Break">):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B19793_16_17.jpg" alt="Figure 16.17 - Primitive stream methods in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.17 - Primitive stream methods in code</p>
			<p>In this figure, we start out <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
   OptionalDouble optAvg = IntStream.rangeClosed(1, 10).average();   optAvg.ifPresent(d -&gt; System.out.println(d));// 5.5</pre>
			<p>This first line uses the <strong class="source-inline">IntSream</strong> method <strong class="source-inline">rangeClosed()</strong> to generate a stream of integers from 1 to 10 inclusive, in steps of 1. The <strong class="source-inline">average()</strong> method then calculates the average of these numbers, which is <strong class="source-inline">5.5</strong> (55/10). Note that the type for <strong class="source-inline">optAvg</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">OptionalDouble</strong></span><span class="No-Break">.</span></p>
			<p>The second uses the now familiar <strong class="source-inline">ifPresent()</strong> method. This time the consumer argument is a <strong class="source-inline">DoubleConsumer</strong>, which means the functional method is <strong class="source-inline">void accept(double)</strong>. This is what we are doing - the value of the <strong class="source-inline">OptionalDouble</strong> is used (namely <strong class="source-inline">d</strong>) <span class="No-Break">and output.</span></p>
			<p>We <span class="No-Break">then have:</span></p>
			<pre class="source-code">
   System.out.println(optAvg.getAsDouble()); // 5.5</pre>			<p>which uses <strong class="source-inline">getAsDouble()</strong> to return the <strong class="source-inline">double</strong> value. If no value is present, this method (like <strong class="source-inline">get()</strong> in <strong class="source-inline">Optional&lt;T&gt;</strong>) generates <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NoSuchElementException</strong></span><span class="No-Break">.</span></p>
			<p>The next two <span class="No-Break">lines are:</span></p>
			<pre class="source-code">
   double dblAvg = optAvg.orElseGet(() -&gt; Double.NaN);   System.out.println(dblAvg);// 5.5</pre>
			<p>The<a id="_idIndexMarker1405"/> first line uses the <strong class="source-inline">orElseGet()</strong> method. We pass in a <strong class="source-inline">DoubleSupplier</strong>, which means there is no input argument (hence the <strong class="source-inline">()</strong> in the lambda) and a <strong class="source-inline">double</strong> returned (<strong class="source-inline">Double.NaN</strong>). As the <strong class="source-inline">OptionDouble</strong> has a value, the value is used to initialize <strong class="source-inline">dblAvg</strong> and the <strong class="source-inline">DoubleSupplier</strong> is ignored. We then output the <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">dblAvg</strong></span><span class="No-Break">.</span></p>
			<p>The <a id="_idIndexMarker1406"/>following code segment completes <span class="No-Break">the example:</span></p>
			<pre class="source-code">
   OptionalInt optInt = OptionalInt.of(35);   int age = optInt.orElseGet(() -&gt; 0);
   System.out.println(age); // 35
   System.out.println(optInt.getAsInt()); // 35</pre>
			<p>The first line creates an <strong class="source-inline">OptionalInt</strong> using the static <strong class="source-inline">OptionalInt.of()</strong> method. The second line uses the <strong class="source-inline">orElseGet()</strong> method. We pass in a <strong class="source-inline">IntSupplier</strong>, meaning we pass in nothing and get back in <strong class="source-inline">int</strong> (which is <strong class="source-inline">0</strong>). As <strong class="source-inline">optInt</strong> has a value, the value is used to initialize <strong class="source-inline">age</strong> and the <strong class="source-inline">IntSupplier</strong> is ignored. The third line outputs the variable <strong class="source-inline">age</strong>. The last line uses <strong class="source-inline">getAsInt()</strong> to return the <strong class="source-inline">int</strong> value. If no value is present in the optional, this method would also, like <strong class="source-inline">getAsDouble()</strong>, generate a <strong class="source-inline">NoSuchElementException</strong>. However, as <strong class="source-inline">optInt</strong> contains a value (of 35), it is returned <span class="No-Break">and output.</span></p>
			<p>That complete the <strong class="source-inline">Optional</strong>s section. Our least section in this chapter is <span class="No-Break">parallel streams.</span></p>
			<h1 id="_idParaDest-422"><a id="_idTextAnchor422"/>Understanding parallel streams</h1>
			<p>All of the<a id="_idIndexMarker1407"/> streams so far have been serial streams where the results are ordered. With serial streams, a single thread processes one entry at a time. A parallel stream is processed by multiple threads executing concurrently (running on multiple CPUs). The stream elements are split into substreams, which are processed by multiple instances of the stream pipeline being executed in multiple threads. These partial substream results are then combined into a final result. To execute the substreams in parallel, the streams use the support of Java’s fork/join framework for <span class="No-Break">thread management.</span></p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor423"/>Creating parallel streams</h2>
			<p>To make a<a id="_idIndexMarker1408"/> stream a parallel stream is very straightforward. We have two options: we can use the <strong class="source-inline">parallelStream()</strong> method from the <strong class="source-inline">Collection</strong> API or the <strong class="source-inline">parallel()</strong> intermediate operation from the <span class="No-Break"><strong class="source-inline">Stream</strong></span><span class="No-Break"> API.</span></p>
			<p>Here are examples of <span class="No-Break">both methods:</span></p>
			<pre class="source-code">
Stream&lt;String&gt; parallelFarmAnimals =    List.of("sheep", "pigs", "horses").parallelStream(); // Collection API
Stream&lt;String&gt; parallelHouseAnimals =
    Stream.of("cats", "dogs").parallel(); // Stream API</pre>
			<p>Let us look at an example contrasting a sequential stream with a parallel stream to show how easy it is to create a parallel stream. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.18</em> is the code (<strong class="source-inline">ParalledStreams.java</strong> in <span class="No-Break">the repo):</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/B19793_16_18.jpg" alt="Figure 16.18 - Creating a parallel stream"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.18 - Creating a parallel stream</p>
			<p>Let us <a id="_idIndexMarker1409"/>examine the sequential <span class="No-Break">stream first:</span></p>
			<pre class="source-code">
   int sum = Stream.of(10, 20, 30, 40, 50, 60)                              .mapToInt(Integer::intValue)
                              .sum();
   System.out.println("Sum == "+sum);  // 210</pre>
			<p>We initially generate a stream of <strong class="source-inline">Stream&lt;Integer&gt;</strong>. The second line uses the <strong class="source-inline">mapToInt()</strong> function to map the <strong class="source-inline">Stream&lt;Integer&gt;</strong> to an <strong class="source-inline">IntStream</strong>. In other words, map from a stream of <strong class="source-inline">Integer</strong> objects to a stream of <strong class="source-inline">int</strong> primitives. This is so we can use the <strong class="source-inline">sum()</strong> method in <strong class="source-inline">IntStream</strong>. The result, 210 is <span class="No-Break">then output.</span></p>
			<p>The parallel <span class="No-Break">version is:</span></p>
			<pre class="source-code">
   int sum = Stream.of(10, 20, 30, 40, 50, 60)                              .parallel()  // Stream&lt;T&gt; method
                              .mapToInt(Integer::intValue)
                              .sum();
   System.out.println("Sum == "+sum);  // 210</pre>
			<p>The only difference is the call to <strong class="source-inline">parallel()</strong> on the second line. This is a <strong class="source-inline">Stream</strong> method. This is abstraction at its finest! The data partitioning and thread management are handled by the API and <span class="No-Break">the JVM.</span></p>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor424"/>Parallel decomposition</h2>
			<p>Creating <a id="_idIndexMarker1410"/>parallel streams is the easy part. Things get interesting when performing <em class="italic">parallel decomposition</em> - where a task is broken down (decomposed) into smaller tasks that are executed concurrently, and their results <span class="No-Break">assembled afterwards.</span></p>
			<p>With serial streams, results are ordered and therefore predictable. With parallel streams and parallel decomposition, this is not the case, as order is not guaranteed and therefore, results are unpredictable. This is because the threads take the subtasks in any order and return the results in <span class="No-Break">any order.</span></p>
			<p>Let us look at a simple code example demonstrating this. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.19</em> presents the <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ParalledStreams.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/B19793_16_19.jpg" alt="Figure 16.19 - Ordering in serial streams and lack of ordering in parallel streams"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.19 - Ordering in serial streams and lack of ordering in parallel streams</p>
			<p>This <a id="_idIndexMarker1411"/>figure presents a <strong class="source-inline">dbAction()</strong> method that mimics a database action by sleeping the thread for 1 second. When the <strong class="source-inline">orderedSerialStreams()</strong> method executes, the output <span class="No-Break">is predictable:</span></p>
			<pre class="console">
10 20 30 40 50Operation took: 5 seconds.</pre>
			<p>The integers are ordered as per the source and the operation took <strong class="source-inline">5 seconds</strong>, <strong class="source-inline">1 second</strong> for <span class="No-Break">each value.</span></p>
			<p>The <strong class="source-inline">unorderedParallelStreams()</strong> method is the same as the serial version except that we are now creating a parallel stream. Let us examine <span class="No-Break">its output:</span></p>
			<pre class="console">
40 20 30 50 10Operation took: 1 seconds.</pre>
			<p>One can <a id="_idIndexMarker1412"/>see the obvious performance benefit of parallel processing: 1 second versus 5 seconds. Note that this performance gain depends on the number of CPUs available - if this code is run on a machine with fewer processors, the gain would <span class="No-Break">be less.</span></p>
			<p>However, the output is now unordered as both <strong class="source-inline">map()</strong> and <strong class="source-inline">forEach()</strong> are applied concurrently. Instead of <strong class="source-inline">forEach()</strong>, we could use the <strong class="source-inline">forEachOrdered()</strong> terminal operation. This operation ensures the consumer is applied to the elements in their <em class="italic">encounter order</em> as they left the source. In our example, this would be <strong class="source-inline">10</strong>, <strong class="source-inline">20</strong>, <strong class="source-inline">30</strong>, <strong class="source-inline">40</strong>, and <strong class="source-inline">50</strong>. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.20</em> shows it in <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ParalledStreams.java</strong></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/B19793_16_20.jpg" alt="Figure 16.20 - The forEachOrdered() method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.20 - The forEachOrdered() method</p>
			<p>In this figure, the terminal operation is no longer <strong class="source-inline">forEach()</strong> but is <strong class="source-inline">forEachOrdered()</strong>. The output from this figure is <span class="No-Break">as follows:</span></p>
			<pre class="console">
10 20 30 40 50Operation took: 1 seconds.</pre>
			<p>Now the integers are ordered and the performance gain is still significant due to <strong class="source-inline">map()</strong> being <span class="No-Break">applied concurrently.</span></p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor425"/>Parallel reductions using reduce()</h2>
			<p>As order <a id="_idIndexMarker1413"/>is not guaranteed with parallel streams, the results of parallel reductions can be unexpected. A reduction combines a stream into a single result. Recall that the overloaded <strong class="source-inline">reduce()</strong> operation accepted three parameters: an identity, an accumulator and a combiner. The combiner function is used in a parallel environment for combining the accumulator results. What the following examples are going to demonstrate is that the <em class="italic">accumulator and combiner must work regardless of the order in which they are executed</em>. They must <span class="No-Break">be associative.</span></p>
			<p class="callout-heading">Associativity</p>
			<p class="callout">An operator or function is considered associative if the <span class="No-Break">following holds:</span></p>
			<p class="callout">    <strong class="source-inline">(a op b) op c)</strong> == <strong class="source-inline">a op (b </strong><span class="No-Break"><strong class="source-inline">op c)</strong></span><span class="No-Break">.</span></p>
			<p class="callout">For example, addition <span class="No-Break">is associative:</span></p>
			<p class="callout">   <strong class="source-inline">(2 + 3) + 4</strong> == <strong class="source-inline">2 + (3 + 4)</strong> == <strong class="source-inline">9</strong></p>
			<p class="callout">However, subtraction is <span class="No-Break">not associative:</span></p>
			<p class="callout">   <strong class="source-inline">(2 - 3) - 4</strong> ==  <strong class="source-inline">-5</strong> whereas <strong class="source-inline">2 - (3 - 4)</strong> == <strong class="source-inline">3</strong></p>
			<p class="callout">This is really important in parallel processing. <span class="No-Break">For example:</span></p>
			<p class="callout">   <strong class="source-inline">a op b op c op d</strong> == <strong class="source-inline">(a op b) op (c </strong><span class="No-Break"><strong class="source-inline">op d)</strong></span></p>
			<p class="callout">If <strong class="source-inline">op</strong> is associative then <strong class="source-inline">(a op b)</strong> and <strong class="source-inline">(c op d)</strong> can be evaluated in parallel; and <strong class="source-inline">op</strong> then performed on <span class="No-Break">the results.</span></p>
			<p>Let us first examine a <span class="No-Break">serial reduction:</span></p>
			<pre class="source-code">
   int result = Stream.of(1,2,3,4,5)                                .reduce(0,
                                              (n1, n2) -&gt; n1 - n2);
   System.out.println(result); // -15</pre>
			<p>As this is a <a id="_idIndexMarker1414"/>serial reduction, there is no need for a combiner. The result is -15. Let us now examine the parallel version to see do we get the same result. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.21</em> represents the <span class="No-Break">code (ParallelStreams.java).</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="image/B19793_16_21.jpg" alt="Figure 16.21 - A parallel reduction using reduce()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.21 - A parallel reduction using reduce()</p>
			<p>In this figure, we have expanded both the accumulator and the combiner to show the values as <span class="No-Break">they appear:</span></p>
			<pre class="source-code">
(n1, n2) -&gt; { // accumulator    System.out.print(n1 + ", " + n2 + "\n");
    return n1 - n2;
},
(subTask1, subTask2) -&gt; { // combiner
    System.out.print("\t" +subTask1 + ", " + subTask2 + "\n");
    return subTask1 - subTask2;
}</pre>
			<p>The output is as follows (with the combiner subtask values <span class="No-Break">tabbed in):</span></p>
			<pre class="console">
0, 1           // (identity, 1) == -1        // line 10, 3           // (identity, 3) == -3        // line 2
0, 5           // (identity, 5) == -5        // line 3
0, 2           // (identity, 2) == -2        // line 4
0, 4           // (identity, 4) == -4        // line 5
    -1, -2     // (line 1, line 4)        // line 6
    -4, -5     // (line 5, line 3)        // line 7
    -3, 1      // (line 2, line 6)        // line 8
    1, -4      // (line 7, line 8)        // line 9
5                 // line 9</pre>
			<p>Notice <a id="_idIndexMarker1415"/>that the final result is <strong class="source-inline">5</strong>, which is incorrect. This is because subtraction is not associative. Interestingly, in the parallel process the identity is applied to multiple elements in the stream, giving us <span class="No-Break">unexpected results.</span></p>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor426"/>Parallel reductions using collect()</h2>
			<p>The <strong class="source-inline">collect()</strong> method, like <strong class="source-inline">reduce()</strong> has a three-argument version, which accepts an accumulator and <a id="_idIndexMarker1416"/>a combiner. For the first argument, rather than an identity, <strong class="source-inline">collect()</strong> uses a <strong class="source-inline">Supplier</strong>. The same rule applies here too - the accumulator and combiner operations must be able to perform in <span class="No-Break">any order.</span></p>
			<p>One should use a concurrent collection, in order to avoid concurrent threads causing <strong class="source-inline">ConcurrentModificationException</strong>s. Another consideration is the target collection - if it is ordered (a <strong class="source-inline">List</strong> for example), then the background processing required to maintain that order may reduce performance. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.22</em> presents an example of a concurrent collection, namely <strong class="source-inline">ConcurrentMap</strong> in <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ParallelStreams.java</strong></span><span class="No-Break">).</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="image/B19793_16_22.jpg" alt="Figure 16.22 - collect() returning a concurrent collection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.22 - collect() returning a concurrent collection</p>
			<p>The output from the <span class="No-Break">code is:</span></p>
			<pre class="console">
   {P=Paula, J=John, M=Mike, Mary}   class java.util.concurrent.ConcurrentHashMap</pre>
			<p>Therefore, the <strong class="source-inline">ConcurrentMap</strong> implementation here is a <strong class="source-inline">ConcurrentHashMap</strong>. This is not guaranteed but some implementation of the <strong class="source-inline">ConcurrentMap</strong> interface <span class="No-Break">is guaranteed.</span></p>
			<p>The <a id="_idIndexMarker1417"/>key in our map is the first letter in <span class="No-Break">the name:</span></p>
			<pre class="source-code">
   name -&gt; name.charAt(0),  // key</pre>			<p>The value associated with the key is the <span class="No-Break">name itself:</span></p>
			<pre class="source-code">
   name -&gt; name,            // value</pre>			<p>If more than one name starts with the same letter, the names are appended, with a comma between <span class="No-Break">the names:</span></p>
			<pre class="source-code">
   (name1, name2) -&gt; name1 + ", "+ name2));// key collisions</pre>			<p>That completes our discussion on parallel streams and indeed concludes <a href="B19793_16.xhtml#_idTextAnchor401"><span class="No-Break"><em class="italic">Chapter 16</em></span></a><em class="italic">.</em> Let us now put that knowledge into practice to reinforce <span class="No-Break">the concepts.</span></p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor427"/>Exercises</h1>
			<ol>
				<li>To keep the park running smoothly, we need to keep track of the health of all dinosaurs. We need to identify any ill dinosaurs. Using a stream of <strong class="source-inline">Dinosaur</strong> objects, filter out dinosaurs that are ill (assuming the <strong class="source-inline">isIll()</strong> method exists the in <strong class="source-inline">Dinosaur</strong> class), map them to their names, and collect the results in a list. Lastly, print out this list of names of the dinosaurs that need <span class="No-Break">immediate attention.</span></li>
				<li>Managing a dinosaur park of this size involves handling large amounts of data. To make an announcement in the park about dinosaur feeding times, create a list of dinosaurs, convert it into a stream, and use the <strong class="source-inline">map()</strong> function to get a list of dinosaur names. Then, use the <strong class="source-inline">forEach</strong> terminal operation to print out a message for each dinosaur’s <span class="No-Break">feeding time.</span></li>
				<li>Keeping track of the total food required for all the dinosaurs can be tricky. Suppose you have an array of weights of all dinosaurs. Convert it into an <strong class="source-inline">IntStream</strong> and use the <strong class="source-inline">sum</strong> method to get the total weight of all dinosaurs in the park. This could help you estimate the total <span class="No-Break">food requirements.</span></li>
				<li>When dealing with data about dinosaurs or employees, we may encounter null references. To avoid a <strong class="source-inline">NullPointerException</strong> error, use <strong class="source-inline">Optional</strong> when retrieving a dinosaur by its name from a map of dinosaurs. If a dinosaur with the provided name doesn’t exist, <strong class="source-inline">Optional</strong> should return a message indicating the dinosaur hasn’t <span class="No-Break">been found.</span></li>
				<li>Calculating the average weight of dinosaurs can be a time-consuming operation, especially when dealing with a large number of dinosaurs. To speed up the process, use parallel streams. Convert a list of dinosaur weights into a parallel stream and use the average method to calculate the <span class="No-Break">average weight.</span></li>
			</ol>
			<h1 id="_idParaDest-428"><a id="_idTextAnchor428"/>Project – dynamic dinosaur care system</h1>
			<p>Integrate<a id="_idIndexMarker1418"/> the Stream API into your dinosaur care system to process large volumes of dinosaur data, such as health records, feeding schedules, and so on. The system should also incorporate <strong class="source-inline">Optional</strong> and parallel streams where appropriate, optimizing data processing and minimizing potential null <span class="No-Break">pointer exceptions.</span></p>
			<p>Here are the steps to get <span class="No-Break">you there:</span></p>
			<ol>
				<li><strong class="bold">Set up your project</strong>: If you haven’t done so already, create a new Java project in your IDE of choice. You should have a <strong class="source-inline">Dinosaur</strong> class with properties such as <strong class="source-inline">name</strong>, <strong class="source-inline">species</strong>, <strong class="source-inline">healthStatus</strong>, and so on. There should also be a <strong class="source-inline">DinosaurCareSystem</strong> class for implementing the <span class="No-Break">main functionalities.</span></li>
				<li><strong class="bold">Use streams to process </strong><span class="No-Break"><strong class="bold">dinosaur data</strong></span><span class="No-Break">:</span><ol><li class="upper-roman"><strong class="bold">Health records</strong>: Suppose you have a list of health records for each dinosaur and you want to find records where a dinosaur’s health status was below a certain threshold. You could create a <strong class="source-inline">Stream</strong> from the list of records and use the <strong class="source-inline">filter</strong> method to get these records. Here’s an example: <strong class="source-inline">List&lt;HealthRecord&gt; criticalRecords = records.stream().filter(r -&gt; r.getHealthStatus() &lt; </strong><span class="No-Break"><strong class="source-inline">CRITICAL_THRESHOLD).collect(Collectors.toList())</strong></span><span class="No-Break">.</span></li><li class="upper-roman"><strong class="bold">Feeding schedules</strong>: Maybe you want to find out all the feeding schedules within a certain period. Again, you can use a <strong class="source-inline">Stream</strong> to filter the schedules. Here’s an example: <strong class="source-inline">List&lt;FeedingSchedule&gt; morningFeeds = schedules.stream().filter(s -&gt; </strong><span class="No-Break"><strong class="source-inline">s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())</strong></span><span class="No-Break">.</span></li><li class="upper-roman"><strong class="bold">Use Optional to avoid</strong>: <strong class="source-inline">NullPointerException</strong><strong class="bold"> errors</strong>: Let’s say each dinosaur has a trainer field that could be null. When trying to access the trainer’s name, use <strong class="source-inline">Optional</strong> to avoid a <strong class="source-inline">NullPointerException</strong> error. Here’s an example: <strong class="source-inline">Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No </strong><span class="No-Break"><strong class="source-inline">trainer assigned").</strong></span></li></ol></li>
				<li><strong class="bold">Use parallel streams to process large amounts of data</strong>: If the number of health<a id="_idIndexMarker1419"/> records or feeding schedules is very large, you could use parallel streams to speed up the processing. This is as simple as replacing <strong class="source-inline">stream()</strong> with <strong class="source-inline">parallelStream()</strong> in the previous examples. Be aware, though, that not every problem is suitable for parallel processing. If the tasks have dependencies or need to be processed in a specific order, stick with <span class="No-Break">regular streams.</span></li>
			</ol>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor429"/>Summary</h1>
			<p>In this chapter, we explored advanced streaming concepts. We started by exploring intermediate operations, which are powerful, as they transform the stream into another stream. Popular intermediate operations are: <strong class="source-inline">filter()</strong>, <strong class="source-inline">distinct()</strong>, <strong class="source-inline">limit()</strong>, <strong class="source-inline">map()</strong>, <strong class="source-inline">flatMap()</strong>, and <strong class="source-inline">sorted()</strong>. Some of these are known as <em class="italic">stateful</em> as they need to maintain some state to operate effectively. Examples are <strong class="source-inline">limit()</strong> and <strong class="source-inline">sorted()</strong>. The <strong class="source-inline">limit()</strong> method is also <em class="italic">short-circuiting</em> as it can cause the pipeline to shut down even if there is more data available in <span class="No-Break">the source.</span></p>
			<p>We then examined the primitive stream types in the API, namely <strong class="source-inline">IntStream</strong>, <strong class="source-inline">LongStream</strong> and <strong class="source-inline">DoubleStream</strong>. These types have some very useful methods for operating on numeric types, such as <strong class="source-inline">sum()</strong> and <strong class="source-inline">average()</strong>. We also explained the patterns behind the names of the new primitive stream functional interfaces and their <span class="No-Break">functional methods.</span></p>
			<p>We can create streams by mapping from another stream. There are many methods to do this but they follow a pattern in their naming. We examined these and explained <span class="No-Break">the patterns.</span></p>
			<p><strong class="source-inline">Optional</strong>s are boxes that may or may not be empty. They are mainly used as a method return type where there is a real need to represent “no result”. Rather than returning <strong class="source-inline">null</strong> (with its pitfalls), we can return an empty <strong class="source-inline">Optional</strong>. We can create <strong class="source-inline">Optional</strong>s using <strong class="source-inline">Optional.of</strong>, <strong class="source-inline">Optional.empty()</strong> and <strong class="source-inline">Optional.ofNullable()</strong>. The <strong class="source-inline">Optional</strong> API supports functional-style programming; for example, <strong class="source-inline">ifPresent()</strong> lets us state clearly what we want without the need for an <strong class="source-inline">else</strong> statement. We also examined the primitive <strong class="source-inline">Optional</strong>s, namely <strong class="source-inline">OptionalInt</strong>, <strong class="source-inline">OptionalLong</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">OptionalDouble</strong></span><span class="No-Break">.</span></p>
			<p>Lastly, we looked at parallel streams, which can be easily created using the <strong class="source-inline">Collection</strong> API method <strong class="source-inline">parallelStream()</strong> or the <strong class="source-inline">Stream</strong> API method <strong class="source-inline">parallel()</strong>. While serial streams are ordered, parallel streams are not. This is due to parallel decomposition where tasks are broken down and re-assembled later. In a parallel multi-threaded environment, threads can take sub-tasks in any order and return the results in any order. This is fine for an associative task such as addition but not suitable <span class="No-Break">for subtraction.</span></p>
			<p>If you are using the parallel reduction methods <strong class="source-inline">reduce()</strong> and <strong class="source-inline">collect()</strong>, ensure that the accumulator and combiner functions are associative; as they must work correctly regardless of the order they are <span class="No-Break">executed in.</span></p>
			<p>That completes our discussion on streams. The next chapter, Concurrency will further solidify the last section here on <span class="No-Break">parallel streams.</span></p>
		</div>
	</body></html>