- en: Data and Stream Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we generated streams of data by using a Reactor Flux
    and then consumed it in a subscriber. Reactor also provides a diverse set of operators
    that can be used to manipulate data. These operators take a stream as input and
    then generate another stream of another type of data. In a nutshell, these operators
    provide a powerful way to compose readable data pipelines. There are various operators
    for filtering, mapping, and collecting data. All of them will be covered in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE, 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Generating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into working with various operators, let's first generate a stream
    of data. In order to do this, let's revisit our Fibonacci series from [Chapter
    1](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml), *Getting Started with Reactive
    Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: In number theory, Fibonacci numbers are characterized by the fact that every
    number after the first two numbers is the sum of the two preceding ones (that
    is, 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ,21 , 34 , 55 , 89 , 144, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flux generated API enables us to build a generator. These generators start
    the series from 0 and 1\. All numbers are printed to the console by a subscriber,
    which listens to all of the generated events. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recap what is happening here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the Fibonacci series as `Flux<Long>` by using the `Flux.generate()`
    call. The API has a state and sink.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API takes a seed as `Tuple [0 , 1]`. It then emits the first argument of
    the pair by using the `Sink.next()` call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API also generates the next Fibonacci number, by aggregating the pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The publisher marks the stream as complete when we generate negative numbers.
    This is due to their being out of range of the long data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We subscribe to the published numbers, then print the received number to the
    console. This is shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7b04e524-ec34-4575-9f90-592b33ebcfb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the most simple operator for selecting data. There are different
    analogies of data filtration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select or reject data based on a given condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select or reject a subset of the generated data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding information is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fac3048-5c21-41fd-b2cc-17f964c00fbe.png)'
  prefs: []
  type: TYPE_IMG
- en: The filter() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filter()` operator enables selection of the data on the passed condition.
    The API takes a Boolean predicate, which is evaluated for every emitted value,
    in order to determine whether it is selected. Filtering is quite common. Let's
    suppose that we want to select dates based on a month range, or we want to select
    employee data based on employee IDs. In those cases, the Boolean predicate passed
    to the filter holds the selection logic. This can be quite flexible, and can be
    adapted to different needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our Fibonacci generator to only select even numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the predicate performs a divisibility check. If the number
    is divisible by `2`, the operator performs a predicate evaluation in a synchronous
    manner. If the condition is satisfied, the value is passed to the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a `FilterWhen`, which is an asynchronous manner of Boolean evaluation.
    This takes the input value and provides the Boolean publisher in return. This
    can be explained with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the predicate performs a less-than check. This is a deferred
    evaluation, and the result is returned as a `Mono<Boolean>`.
  prefs: []
  type: TYPE_NORMAL
- en: The take operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filter methods discussed previously enable us to select data. If we want
    to select the top 10 elements, for example, we can use the `filter` operator,
    with a predicate that has a counter. Alternatively, there is a `take` operator
    for this purpose. The operator takes a number and selects the specified number
    of elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will select the first `10` values to form the Fibonacci generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that we want to select the last 10 elements. The `takeLast`
    operator is designed for this purpose. It also maintains a count and selects elements
    from the end of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the stream is truly unbounded, there will not be any last elements. The operator
    only works when there is a normal close of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only want to select the last value, we can use the `takeLast(1)` operator.
    This operator will give back a Flux stream containing just one value. Alternatively,
    there is a `last()` operator, which gives back a Mono publisher that consists
    of the last published element. The use of the `last` operator is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The skip operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have found ways to select data, let''s look at ways to reject data.
    The Reactor API offers diverse methods to reject data. There is a skip operator,
    with the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skip(count)`: This will reject the specified number of elements from the beginning
    of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Skip(Duration)`: This will reject elements for the said duration from the
    beginning of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipLast(count)`: This will reject a specified number of elements from the
    end of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipUntil(Boolean Predicate)`: This will reject elements until the first occurrence
    of the said condition is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding commands are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sample has the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: The first subscriber rejects the first `10` elements and prints the rest of
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second subscriber prints the elements after rejecting the elements for `10`
    milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second subscriber prints the elements after the first data element goes
    beyond `100`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64301bd5-b071-48a0-87d1-9ff5e043f4be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Until now, we have discussed generic ways to select and reject data. However,
    the Flux interface offers the following special operators for filtering data in
    specific scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distinct`: This operator is used to select unique elements of the passed data
    stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distintUntilChanged`: This operator is used to select the first set of distinct
    items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreElements`: This operator is used to completely ignore the data elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single`: This operator is used to select only a single data element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementAt`: This operator selects the element at the specified index of the
    stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding section, we discussed ways to select or reject data. Reactor
    offers many operators for this purpose. It is often a good idea to check the API
    and determine whether there is an operator for the intended purpose rather than
    customize the predicate with the filter and skip methods.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often necessary to convert data from one format to another. The reactor
    provides a vast set of operators to achieve this. Not only can we convert data
    but we can modify the amount of data elements as well.
  prefs: []
  type: TYPE_NORMAL
- en: The map() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the preceding Fibonacci example that was used to explain the `skip()` operator,
    suppose that we want to convert the first 10 elements into Roman numeral equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roman numerals are represented by seven letters: I, V, X, L, C, D, and M. These
    letters represent 1, 5, 10, 50, 100, 500, and 1,000, respectively. The seven letters
    can be combined to represent thousands of numbers. The Roman numeral scheme used
    letters as tally markers. Markers were combined to represent unit values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a long number and we want to convert it to its Roman equivalent; this
    is where the `map()` operator is valuable. It applies a transformation to each
    and every value of the existing stream, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/780c0950-35bd-4673-8a36-36c4d7f00c52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to achieve this transformation, we need a `RomanNumberConvertor`.
    In the following code, we have defined a conversion from integers to their Roman
    equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know how to convert an integer, we will define the `Map` function
    for our stream processor. The operator will take the long `Value` as an input
    and will then generate the Roman equivalent as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things are done in the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `skip(1)` operator has been used. In the last section, we mentioned that
    this will skip the first element of the series. This happens because 0 has no
    Roman equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `take(10)` operator has been used. This will select only 10 elements from
    the generated series. This is done to limit the number to less than 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map()` operator defines the conversion of `longValue` to the Roman-equivalent
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the preceding operators have been chained together to generate one single
    stream. The output is shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4f6e72e7-d511-49bf-b8da-62cd79a3724e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding output, the value transformation from number
    to Roman numeral is applied to each item flowing through the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding transformation example that used the `map()` operator was effective
    when we had a one-to-one value conversion, but it could not handle a one-to-*n*
    value conversion. We can show this premise by generating a stream of factors for
    our Fibonacci numbers. Let's first revise what factorization is.
  prefs: []
  type: TYPE_NORMAL
- en: In number theory, factorization is the breakup of a composite number into a
    product of smaller numbers. For 6, for example, the factors are 1, 2, 3, and 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to convert Fibonacci numbers to their corresponding factors. Each
    number of the series must be converted to all possible factors. First, let''s
    build a simple function to compute factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used the brute force method, which divides the specified
    number by all numbers less than or equal to the number. If the number is divisible,
    then the divisor is added to the list of factors. We can use this with a `map`
    operator, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output includes individual collections that contain factors of
    the Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cde056ed-d1e7-4e13-96cb-26085c01d133.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to make the generated factors a stream of integral factors, we must
    use the `flatMap` operator. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following things are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap` takes an integer and passes it to the factor generator. It expects
    a publisher of the other data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factors are generated as a collection of integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These integers are converted into a Flux using the `fromIterable` methods to
    match the expectations of the `FlatMap` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05bd4f4-d944-4686-ba87-db0e1e1b8a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: When using `flatMap`, it is essential to know what kind of Flux we are generating
    back. A simple change from `Flux.fromIterable` to `Flux.just` alters the complete
    behavior of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The repeat operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides an operator to replay a stream of data. The `repeat` operator
    is designed for this purpose. It replays the steam upon receiving the completion
    event. Let''s suppose that we want to output the Fibonacci series twice. We will
    use the `repeat()` operator, with `2` as the argument to the `repeat()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generated the stream twice, as shown in the following output.
    It is important to note that the `repeat()` operator repeats a stream after receiving
    the completion event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f497e3c7-8d02-493e-bb9f-635828ea9e13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Reactor also makes it possible to perform infinite repeats. The `repeat()`
    operator, invoked without any argument, replays the stream an infinite number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/446a4439-972f-4885-80fa-c78956aa7099.png)'
  prefs: []
  type: TYPE_IMG
- en: There is also a predicate variant in which a Boolean provider is passed to the
    repeat operator. Upon completion, the provider is evaluated every time in order
    to discover whether the stream needs to be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: The collect operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor also provides operators that make it possible to accumulate data streams
    as collections. The most basic of these is the `collectList()` operator. The operator
    accumulates the data as a list, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb2dce83-521a-4ec0-8b5a-9690ecc734dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take our Fibonacci example and collect the data into a list. The collector
    method provides a Mono publisher that will emit a single list containing all of
    the published data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator selects the first 10 elements of the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then accumulates them into a list, giving back a Mono publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is provided to the subscriber, which prints it to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The behavior is confirmed in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bf35886-454e-47ef-90f9-c0921fc23a04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `collectList()` operator aggregates the data in a list, but there is also
    a `CollectSortList` operator, which can collect data in a sorted list based on
    the natural order of the data. We can also provide a comparator to the `CollectSortedList`
    method to alter the order of the data, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator selects the first 10 elements of the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then accumulates them into a `SortedList` by using the passed comparator
    function, giving back a Mono publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comparator function compares two long data types and reverses the evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is provided to the subscriber, which prints it to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, the subscriber receives a list in the reverse order of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b0451f7-6cb7-423e-b425-9be7d015773f.png)'
  prefs: []
  type: TYPE_IMG
- en: The collectMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `collectlist()`, Reactor also provides `collectMap()` to accumulate
    data into a `java.util.Map`; `collectMap` takes a key generator function to create
    keys for the generated value elements. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates a `Map` with two keys that are represented as
    `even` and `odd`. It will keep the last even/odd number in the map. This is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bab627b-6bdd-40a6-bf5d-4ee43acde4b4.png)'
  prefs: []
  type: TYPE_IMG
- en: The `collectMap` command not only takes a `keyGeneator`, but also provides the
    option to pass a value generator. The value generator alters the original value
    of the data stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a `CollectMultiMap()` method, which collects data into a map
    of keys and lists them as values. Instead of overwriting the original value, it
    aggregates the values against the same key into a list. If executed with the `collectMultiMap`
    operator, the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04b9be62-26e1-4219-ba4d-2df87afd7cef.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the accumulators discussed previously, there is a generic `Collect`
    operator, which makes it possible to accumulate data into any format. This operator
    converts the Flux publisher back to a Mono publisher, emitting a single accumulated
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The reduce operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding section covered value accumulation, whereas the reduce operation
    revolves around value consolidation. The reduce method makes it possible to aggregate
    the complete data stream into a single value. This is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b416e1ae-aa53-428c-beb9-8f70ea3b7805.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose that we want to generate a sum of Fibonacci numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator selected the first 10 elements for the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reduce` operator took a Bifunction of the long type. The lambda expression
    returns the sum of the long values to generate the back sum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `subscribe` operation received a `Mono<Long>`, which was printed on the
    console. This is depicted as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2a77eff6-a2a9-47c3-bc9b-aba8f8d6a5da.png)'
  prefs: []
  type: TYPE_IMG
- en: There is also an overloaded `reduce` method, which can take an initial value
    as the starting point of the aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special `count` operator that is responsible for returning the size
    of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we been discussed operators that work on original data. The Reactor
    framework provides Boolean operators that enable the testing of each of the data
    elements in the stream. There are two types of operators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`all`: This operator takes a predicate and confirms whether all of the elements
    meet the specified criteria. This is the logical `AND` operator for all data elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`: This operator takes a predicate and confirms whether any single element
    meets the specified criteria. This is a logical `OR` for all data elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The results of the preceding methods are consolidated into a single Boolean
    result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator selected the first `10` elements for the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `all` operator took a Boolean predicate to confirm that all of the elements
    are greater than `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subscribe` operation received a `Mono<Boolean>`, which was printed on the
    console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35894b33-c4f3-4993-8d02-e1eb146101e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Appending data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have worked on data generated from a single Flux stream. Stream
    processing is not limited to one publisher. Reactor provides operators that make
    it possible to merge different publishers into one single stream of data. Values
    can be added either before the specified published values or after the published
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The concatWith operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `concatWith` operator makes it possible to append a value event after the
    published values. It takes a publisher as input and appends the published values
    after the first publisher has completed, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb94a19a-ab39-4d9d-bce4-09bd97b7f150.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s suppose that we want to append some negative values at the end of our
    Fibonacci stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator selected the first `10` elements for the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `concatWith` operator took a publisher. It appended its values after the
    completion of the original stream, that is, after `10` elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subscribe` operation received a `Flux<Long>`, which was printed on the
    console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `concatWith`, there is a `startWith` operator, which can be used
    to add values before the original stream values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the wide range of operators available in Reactor.
    We started by looking at simple operators for selecting and rejecting data. We
    then looked at operators for converting data to other types. The converted data
    element does not need to be one-to-one mapped. There can be more than one element
    for each processed value. Next, we looked at operators that accumulate data. By
    the end of the chapter, we had covered aggregation and conditional tests for data.
    In a nutshell, we have covered the complete range of operators available in Reactor.
    In the next chapter we will look at the processors, which provide the necessary
    glue to bind Reactor components.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What operator is used to select data elements from a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operator is used to reject data elements from a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operators does Reactor offer for data conversion? How are these operators
    different from each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we perform data aggregation by using Reactor operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What conditional operators are offered by Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
