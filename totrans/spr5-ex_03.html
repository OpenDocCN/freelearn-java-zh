<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Persistence with Spring Data and Reactive Fashion</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we created our <strong>Content Management System</strong> (<strong>CMS</strong>) application. We also introduced <strong>REST</strong> (<strong>Representational State Transfer</strong>) support in Spring, which enabled us to develop a simple web application. Also, we learned how dependency injection works in the Spring Framework, which is probably the most famous feature of the framework.</p>
<p>In this chapter, we will add more features to our application. Systems in the real world need to persist their data on a real database; this is an essential characteristic for a production-ready application. Also, based on our model, we need to choose the correct data structure to achieve performance and avoid the impedance mismatch.</p>
<p>In the first part of this chapter, we will use the traditional SQL database as a store for our application. We will deep dive on the Spring Data <strong>JPA</strong> (<strong>Java Persistence API</strong>) to achieve the persistence for our CMS application. We will understand how to enable transactions with this amazing Spring module.</p>
<p>After that, we will change to a more modern type of database called <strong>NoSQL</strong> <strong>technologies</strong>. In this field, we will use the famous database document model called <strong>MongoDB</strong> and then we will create the final solution for our CMS application.</p>
<p>MongoDB offers a fantastic solution for our application because it has support for a document storage model and enables us to store our objects in the form of JSON, which makes our data more readable. Also, MongoDB is schema-less, which is a fantastic feature because one collection can store different documents. It means records can have different fields, content, and sizes. The other important characteristic from MongoDB is the query model. It offers a document-based query that is easy to understand, and, based on JSON notations, our queries will be more readable than any other database can be.</p>
<p>Finally, we will add the most important feature present in Spring 5.0: support for Reactive Streams. Our application will be transformed into a modern web application which has some important requirements.</p>
<p>Here's an overview of what you will learn in this chapter:</p>
<ul>
<li>Implementing the Spring Data JPA</li>
<li>Creating repositories with Spring Data Reactive MongoDB</li>
<li>Learning the Reactive Spring</li>
<li>Understand the Project Reactor</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning the basics of Docker</h1>
                </header>
            
            <article>
                
<p>We learned about Docker concepts in <a href="45a65572-53a1-42bd-aa7a-d1437e65a58f.xhtml" target="_blank">Chapter 1</a>, <em>Journey to the Spring World</em>. Now, it is time to test our knowledge and put it into practice. In the first part of this chapter, we will start MongoDB and Postgres instances to serve as a database for our application. We will configure connection settings in the application.</p>
<p>In the last part of this chapter, we will introduce the Maven plugin which provides an easy way to create Docker images via <kbd>pom.xml</kbd> with a couple of configurations on file. Finally, we will run our application in a Docker container. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing  MongoDB</h1>
                </header>
            
            <article>
                
<p>Let's create our MongoDB container. We will use the official image provided by the Docker Hub.</p>
<p>First, we need to pull the image:</p>
<pre><strong>docker pull mongo:3.4.10</strong></pre>
<p>Then, we will see the Docker Engine downloading the image contents.</p>
<p>To create an isolation from our containers, we will create a separated network for our application and database. The network should use the bridge driver to allow the container communications.</p>
<p>Let's create a <kbd>docker network</kbd>:</p>
<pre><strong>docker network create cms-application</strong></pre>
<p>The command output should be an ID of a created network. Your ID will probably be different compared to mine:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ef52923-37c6-446d-9e6a-371ac525bce9.png"/></div>
<p>To check if the network was created successfully, the <kbd>docker network ls</kbd> <span>command </span>can help us.</p>
<p>We will start our MongoDB. The network should be <kbd>cms-application</kbd>, but we will map the database port to a host port. For debugging purposes, we will connect a client to a running database, but please don't do this in a non-development environment.</p>
<div class="packt_infobox">Exposing a port over host is not a best practice. Hence, we use a Docker container, which is one of the main advantages is process isolation. In this case, we will have no control over the network. Otherwise, we may cause some port conflicts.</div>
<p>To start, type the following command:</p>
<pre><strong>docker run -d --name mongodb --net cms-application -p 27017:27017 mongo:3.4.10</strong></pre>
<div class="packt_tip">Also, we can stop the Docker MongoDB container using <kbd>docker stop mongodb</kbd> and start our container again by using the following command: <kbd>docker start mongodb</kbd>.</div>
<p>The output will be a hash which represents the ID of the container.</p>
<p>The parameter instructions are:</p>
<ul>
<li><kbd>-d</kbd>: This instructs Docker to run the container in a background mode</li>
<li><kbd>--name</kbd>: The container name; it will be a kind of hostname in our network</li>
<li><kbd>--net</kbd>: The network where the container will be attached</li>
<li><kbd>-p</kbd>: The host port and container port, which will be mapped to a container on a host interface</li>
</ul>
<p>Now, we have a pretty standard MongoDB instance running on our machines, and we can start to add a persistence in our CMS application. We will do that soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing a PostgreSQL database</h1>
                </header>
            
            <article>
                
<p>Like MongoDB, we will prepare a PostgreSQL instance for our CMS application. We will change our persistence layer to demonstrate how Spring Data abstracts it for developers. Then, we need to prepare a Docker Postgres instance for that.</p>
<p>We will use the version 9.6.6 of Postgres and use the <kbd>alpine</kbd> tag because it is smaller than other <span>Postgres</span> images. Let's pull our image. The command should be like this:</p>
<pre><strong>docker pull postgres:9.6.6-alpine</strong></pre>
<p>Then, wait until the download ends.</p>
<p>In the previous section, we created our Docker network called <kbd>cms-application</kbd>. Now, we will start our Postgres instance on that network as we did for MongoDB. The command to start the Postgres should be the following:</p>
<pre>docker run -d --name postgres --net cms-application -p 5432:5432 <strong>-e POSTGRES_PASSWORD=cms@springfive</strong><br/>postgres:9.6.6-alpine</pre>
<p>The list of parameters is the same as we passed for MongoDB. We want to run it in background mode and attach it to our custom network. As we can see, there is one more new parameter in the <kbd>docker run</kbd> command. Let's understand it:</p>
<ul>
<li><kbd>-e</kbd>: This enables us to pass environment variables for a container. In this case, we want to change the password value.</li>
</ul>
<p>Good job. We have done our infrastructure requirements. Let's understand the persistence details right now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data project</h1>
                </header>
            
            <article>
                
<p>The Spring Data project is an umbrella project that offers a familiar way to create our data access layer on a wide range of database technologies. It means there are high-level abstractions to interact with different kinds of data structures, such as the document model, column family, key-value, and graphs. Also, the JPA specification is fully supported by the Spring Data JPA project.</p>
<p>These modules offer powerful object-mapping abstractions for our domain model.</p>
<p>There is support for different types of data structures and databases. There is a set of sub-modules to keep the framework modularity. Also, there are two categories of these sub-modules: the first one is a subset of projects supported by the Spring Framework Team and the second one is a subset of sub-modules provided by the community.</p>
<p><span>Projects supported by the Spring Team include</span>:</p>
<ul>
<li>Spring Data Commons</li>
<li>Spring Data JPA</li>
<li>Spring Data MongoDB</li>
<li>Spring Data Redis</li>
<li>Spring Data for Apache Cassandra</li>
</ul>
<p><span>Projects supported by the community include</span>:</p>
<ul>
<li>Spring Data Aerospike</li>
<li>Spring Data ElasticSearch</li>
<li>Spring Data DynamoDB</li>
<li>Spring Data Neo4J</li>
</ul>
<p>The base of the repositories interfaces chain is the<span> </span><kbd>Repository</kbd><span> </span>interface. It is a marker interface, and the general purpose is to store the type information. The type will be used for other interfaces that extend it.</p>
<p>There is also a<span> </span><kbd>CrudRepository</kbd><span> </span>interface. It is the most important, and the name is self-explanatory; it provides a couple of methods to perform CRUD operations, and it provides some utility methods, such as <kbd>count()</kbd>,<span> </span><kbd>exists()</kbd><span>, </span>and<span> </span><kbd>deleteAll()</kbd>. Those are the most important base interfaces for the repository implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data JPA</h1>
                </header>
            
            <article>
                
<p>The Spring Data JPA provides an easy way to implement a data access layer using the JPA specification from Java EE. Usually, these implementations had a lot of boilerplate and repetitive code and it was hard to maintain the changes in the database code. The Spring Data JPA is trying to resolve these issues and provides a comprehensible way to do that without boilerplate and repetitive code.</p>
<p>The JPA specification provides an abstraction layer to interact with different database vendors that have been implemented. Spring adds one more layer to the abstraction in a high-level mode. It means the Spring Data JPA will create a repositories implementation and encapsulate the whole JPA implementation details. We can build our persistence layer with a little knowledge of the JPA spec.</p>
<div class="packt_infobox">The <em>JPA Specification</em> was created by the <strong>JCP</strong> (<strong>Java Community Process</strong>) to help developers to persist, access, and manage data between Java classes and relational databases. There are some vendors that implement this specification. The most famous implementation is Hibernate (<a href="http://hibernate.org/orm/">http://hibernate.org/orm/</a>), and by default, Spring Data JPA uses Hibernate as the JPA implementation.</div>
<p>Say goodbye to the <strong>DAO</strong> (<strong>Data Access Object</strong>) pattern and implementations. The Spring Data JPA aims to solve this problem with a well-tested framework and with some production-ready features.</p>
<p>Now, we have an idea of what the Spring Data JPA is. Let's put it into practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring pom.xml for Spring Data JPA</h1>
                </header>
            
            <article>
                
<p>Now, we need to put the correct dependencies to work with Spring Data JPA. There are a couple of dependencies to configure in our <kbd>pom.xml</kbd> file.</p>
<p><span>The </span>first one<span> is the Spring Data JPA Starter, which provides a lot of auto-configuration classes which permits us to bootstrap the application quickly. </span>The last one is the PostgreSQL JDBC driver, and it is necessary because it contains the JDBC implementation classes to connect with the PostgreSQL database. </p>
<p>The new dependencies are:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span><strong>spring-boot-starter-data-jpa</strong><span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.postgresql<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span><strong>postgresql</strong><span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>42.1.4<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Simple and pretty easy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Postgres connections</h1>
                </header>
            
            <article>
                
<p>To connect our application with our recently created database, we need to configure a couple of lines in the <kbd>application.yaml</kbd> file. Once again, thanks to Spring Data Starter, our connection will be configured automatically.</p>
<p>We can produce the connection objects using the <kbd>@Bean</kbd> annotations as well, but there are many objects to configure. We will go forward with the configuration file. It is more simple and straightforward to understand as well.</p>
<p>To configure the database connections, we need to provide the Spring Framework a couple of attributes, such as the database URL, database username, password, and also a driver class name to instruct the JPA framework about the full path of the JDBC class.</p>
<p>The <kbd>application.yaml</kbd> file should be like this:</p>
<pre><span>spring:<br/></span><span><strong>  datasource</strong>:<br/></span><span><strong>    url</strong>: </span>jdbc:postgresql://localhost:5432/postgres<br/>    <span><strong>username</strong>: </span>postgres<br/>    <span><strong>password</strong>: </span>cms@springfive<br/>    <span><strong>driver-class-name</strong>: </span>org.postgresql.Driver<br/>  <span>jpa:<br/></span><span>    show-sql: </span>true<br/>    <span>generate-ddl: </span>true</pre>
<p>In the <kbd>datasource</kbd> section, we have configured the database credentials connections and database host as well.</p>
<p>The JPA section in <kbd>application.yaml</kbd> can be used to configure the JPA framework. In this part, we configured to log SQL instructions in the console. This is helpful to debug and perform troubleshooting. Also, we have configured the JPA framework to create our tables in a database when the application gets the startup process.</p>
<p>Awesome, the JPA infrastructure is configured. Well done! Now, we can map our models in the JPA style. Let's do that in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping the models</h1>
                </header>
            
            <article>
                
<p>We have configured the database connections successfully. Now, we are ready to map our models using the JPA annotations. Let's start with our <kbd>Category</kbd> model. It is a pretty simple class, which is good because we are interested in Spring Data JPA stuff.</p>
<p>Our first version of the <kbd>Category</kbd> model should be like this:</p>
<pre><span>package </span>springfive.cms.domain.models<span>;<br/></span><span><br/></span><span>import </span>javax.persistence.<span>Entity</span><span>;<br/></span><span>import </span>javax.persistence.<span>GeneratedValue</span><span>;<br/></span><span>import </span>javax.persistence.<span>Id</span><span>;<br/></span><span>import </span>javax.persistence.<span>Table</span><span>;<br/></span><span>import </span>lombok.<span>Data</span><span>;<br/></span><span>import </span>org.hibernate.annotations.<span>GenericGenerator</span><span>;<br/></span><span><br/></span><span>@Data<br/></span><strong>@Entity<br/>@Table(name = "category")</strong><br/><span>public class </span>Category {<br/><br/>  <strong>@Id<br/>  @GeneratedValue(generator = "system-uuid")</strong><br/><strong>  @GenericGenerator(name = "system-uuid", strategy = "uuid2")</strong><br/>  String <span>id</span><span>;<br/></span><span><br/></span><span>  </span>String <span>name</span><span>;<br/></span><span><br/></span>}</pre>
<div class="packt_infobox">We need to change some model classes to adapt to the JPA specification. We can find the model classes on GitHub at: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models</a>.</div>
<p>There is some new stuff here. The <kbd>@Entity</kbd> annotation instructs the JPA framework that the annotated class is an entity, in our case, the <kbd>Category</kbd> class, and then the framework will correlate it with a database table. The <kbd>@Table</kbd> annotation is used to name the table in the database. These annotations are inserted on the class level, which means on top of the class declaration.</p>
<p>The <kbd>@Id</kbd> annotation instructs the JPA as to which annotated field is the primary key of the database table. It is not a good practice to generate IDs sequentially for entities, especially if you are creating the APIs. It helps hackers to understand the logic about the IDs and makes the attacks easier. So, we will generate UUIDs (Universally Unique IDentifiers) instead of simple sequentially IDs. The <kbd>@GenericGenerator</kbd> <span>annotation </span>instructs Hibernate, which is a JPA specification implementation vendor, to generate random UUIDs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the JPA repositories in the CMS application</h1>
                </header>
            
            <article>
                
<p>Once the whole infrastructure and JPA mappings are done, we can add our repositories to our projects. In the Spring Data project, there are some abstractions, such as <kbd>Repository</kbd>, <kbd>CrudRepository</kbd>, and <kbd>JpaRepository</kbd>. We will use the <kbd>JpaRepository</kbd> because it supports the paging and sorting features.</p>
<p>Our repository will be pretty simple. There are a couple of standard methods, such as <kbd>save()</kbd>, <kbd>update()</kbd>, and <kbd>delete()</kbd>, and we will take a look at some DSL query methods which allow developers to create custom queries based on attribute names. <span>We created an </span><kbd>AbstractRepository</kbd><span> to help us to store the objects in memory. It is not necessary anymore. We can remove it.</span></p>
<p>Let's create our first JPA repository:</p>
<pre><span>package </span>springfive.cms.domain.repository<span>;<br/></span><span><br/></span><span>import </span>java.util.List<span>;<br/></span><span>import </span>org.springframework.data.jpa.repository.JpaRepository<span>;<br/></span><span>import </span>springfive.cms.domain.models.Category<span>;<br/></span><span><br/></span><span>public interface </span>CategoryRepository <span>extends </span><strong>JpaRepository</strong>&lt;Category<span>, </span>String&gt; {<br/><br/>  List&lt;Category&gt; <strong>findByName</strong>(String name)<span>;<br/></span><span><br/></span><span>  </span>List&lt;Category&gt; <strong>findByNameIgnoreCaseStartingWith</strong>(String name)<span>;<br/></span><span><br/></span>}</pre>
<p>As we can see, the <kbd>JpaRepository</kbd> interface is typed with the desired entity and the type of ID of the entity as well. There is no secret to this part. This amazing thing happens to support the custom queries based on attribute names. In the <kbd>Category</kbd> model, there is an attribute called <kbd>name</kbd><strong>.</strong> We can create custom methods in our <kbd>CategoryRepository</kbd> using the <kbd>Category</kbd> model attributes using the <kbd>By</kbd> instruction. As we can see, above <kbd>findByName(String name)</kbd>, Spring Data Framework will create the correct query to look up categories by name. It is fantastic.</p>
<p>There are many keywords supported by the custom query methods:</p>
<table style="width: 1034px;height: 1021px">
<tbody>
<tr>
<td><strong>Logical Keyword</strong></td>
<td><strong>Logical Expressions</strong></td>
</tr>
<tr>
<td><kbd>AND</kbd></td>
<td><kbd>And</kbd></td>
</tr>
<tr>
<td><kbd>OR</kbd></td>
<td><kbd>Or</kbd></td>
</tr>
<tr>
<td><kbd>AFTER</kbd></td>
<td><kbd>After</kbd>, <kbd>IsAfter</kbd></td>
</tr>
<tr>
<td><kbd>BEFORE</kbd></td>
<td><kbd>Before</kbd>, <kbd>IsBefore</kbd></td>
</tr>
<tr>
<td><kbd>CONTAINING</kbd></td>
<td><kbd>Containing</kbd>, <kbd>IsContaining</kbd>, <kbd>Contains</kbd></td>
</tr>
<tr>
<td><kbd>BETWEEN</kbd></td>
<td><kbd>Between</kbd>, <kbd>IsBetween</kbd></td>
</tr>
<tr>
<td><kbd>ENDING_WITH</kbd></td>
<td><kbd>EndingWith</kbd>, <kbd>IsEndingWith</kbd>, <kbd>EndsWith</kbd></td>
</tr>
<tr>
<td><kbd>EXISTS</kbd></td>
<td><kbd>Exists</kbd></td>
</tr>
<tr>
<td><kbd>FALSE</kbd></td>
<td><kbd>False</kbd>, <kbd>IsFalse</kbd></td>
</tr>
<tr>
<td><kbd>GREATER_THAN</kbd></td>
<td><kbd>GreaterThan</kbd>, <kbd>IsGreaterThan</kbd></td>
</tr>
<tr>
<td><kbd>GREATHER_THAN_EQUALS</kbd></td>
<td><kbd>GreaterThanEqual</kbd>, <kbd>IsGreaterThanEqual</kbd></td>
</tr>
<tr>
<td><kbd>IN</kbd></td>
<td><kbd>In</kbd>, <kbd>IsIn</kbd></td>
</tr>
<tr>
<td><kbd>IS</kbd></td>
<td><kbd>Is</kbd>, <kbd>Equals</kbd>, (or no keyword)</td>
</tr>
<tr>
<td><kbd>IS_EMPTY</kbd></td>
<td><kbd>IsEmpty</kbd>, <kbd>Empty</kbd></td>
</tr>
<tr>
<td><kbd>IS_NOT_EMPTY</kbd></td>
<td><kbd>IsNotEmpty</kbd>, <kbd>NotEmpty</kbd></td>
</tr>
<tr>
<td><kbd>IS_NOT_NULL</kbd></td>
<td><kbd>NotNull</kbd>, <kbd>IsNotNull</kbd></td>
</tr>
<tr>
<td><kbd>IS_NULL</kbd></td>
<td><kbd>Null</kbd>, <kbd>IsNull</kbd></td>
</tr>
<tr>
<td><kbd>LESS_THAN</kbd></td>
<td><kbd>LessThan</kbd>, <kbd>IsLessThan</kbd></td>
</tr>
<tr>
<td><kbd>LESS_THAN_EQUAL</kbd></td>
<td><kbd>LessThanEqual</kbd>, <kbd>IsLessThanEqual</kbd></td>
</tr>
<tr>
<td><kbd>LIKE</kbd></td>
<td><kbd>Like</kbd>, <kbd>IsLike</kbd></td>
</tr>
<tr>
<td><kbd>NEAR</kbd></td>
<td><kbd>Near</kbd>, <kbd>IsNear</kbd></td>
</tr>
<tr>
<td><kbd>NOT</kbd></td>
<td><kbd>Not</kbd>, <kbd>IsNot</kbd></td>
</tr>
<tr>
<td><kbd>NOT_IN</kbd></td>
<td><kbd>NotIn</kbd>, <kbd>IsNotIn</kbd></td>
</tr>
<tr>
<td><kbd>NOT_LIKE</kbd></td>
<td><kbd>NotLike</kbd>, <kbd>IsNotLike</kbd></td>
</tr>
<tr>
<td><kbd>REGEX</kbd></td>
<td><kbd>Regex</kbd>, <kbd>MatchesRegex</kbd>, <kbd>Matches</kbd></td>
</tr>
<tr>
<td><kbd>STARTING_WITH</kbd></td>
<td><kbd>StartingWith</kbd>, <kbd>IsStartingWith</kbd>, <kbd>StartsWith</kbd></td>
</tr>
<tr>
<td><kbd>TRUE</kbd></td>
<td><kbd>True</kbd>, <kbd>IsTrue</kbd></td>
</tr>
<tr>
<td><kbd>WITHIN</kbd></td>
<td><kbd>Within</kbd>, <kbd>IsWithin</kbd></td>
</tr>
</tbody>
</table>
<p>There are many ways to create a query based on attributes names. We can combine the keywords using keywords as well, such as <kbd>findByNameAndId</kbd>, for instance. The Spring Data JPA provides a consistent way to create queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring transactions</h1>
                </header>
            
            <article>
                
<p>When we use the JPA specification, most of the applications need to have support for transactions as well. Spring has excellent support for transactions even in other modules. This support is integrated with Spring Data JPA, and we can take advantage of it. Configuring transactions in Spring is a piece of cake; we need to insert the <kbd>@Transactional</kbd> annotation whenever needed. There are some different use cases to use it. We will use the <kbd>@Transactional</kbd> in our services layer and then we will put the annotation in our service classes. Let's see our <kbd>CategoryService</kbd> class:</p>
<pre><span>package </span>springfive.cms.domain.service<span>;<br/></span><span><br/></span><span>import </span>java.util.List<span>;<br/></span><span>import </span>java.util.Optional<span>;<br/></span><span>import </span>org.springframework.stereotype.<span>Service</span><span>;<br/></span><span>import </span>org.springframework.transaction.annotation.<span>Transactional</span><span>;<br/></span><span>import </span>springfive.cms.domain.exceptions.CategoryNotFoundException<span>;<br/></span><span>import </span>springfive.cms.domain.models.Category<span>;<br/></span><span>import </span>springfive.cms.domain.repository.CategoryRepository<span>;<br/></span><span>import </span>springfive.cms.domain.vo.CategoryRequest<span>;<br/></span><span><br/></span><span>@Service<br/></span><strong>@Transactional(readOnly = true)</strong><br/><span>public class </span>CategoryService {<br/><br/>  <span>private final </span>CategoryRepository <span>categoryRepository</span><span>;<br/></span><span><br/></span><span>  public </span><span>CategoryService</span>(CategoryRepository categoryRepository) {<br/>    <span>this</span>.<span>categoryRepository </span>= categoryRepository<span>;<br/></span><span>  </span>}<br/><br/>  <span><strong>@Transactional</strong><br/></span><span>  </span><span>public </span>Category <span>update</span>(Category category) {<br/>    <span>return this</span>.<span>categoryRepository</span>.save(category)<span>;<br/></span><span>  </span>}<br/><br/>  <span><strong>@Transactional</strong><br/></span><span>  </span><span>public </span>Category <span>create</span>(CategoryRequest request) {<br/>    Category category = <span>new </span>Category()<span>;<br/></span><span>    </span>category.setName(request.getName())<span>;<br/></span><span>    return this</span>.<span>categoryRepository</span>.save(category)<span>;<br/></span><span>  </span>}<br/><br/>  <span><strong>@Transactional</strong><br/></span><span>  </span><span>public void </span><span>delete</span>(String id) {<br/>    <span>final </span>Optional&lt;Category&gt; category = <span>this</span>.<span>categoryRepository</span>.findById(id)<span>;<br/></span><span>    </span>category.ifPresent(<span>this</span>.<span>categoryRepository</span>::delete)<span>;<br/></span><span>  </span>}<br/><br/>  <span>public </span>List&lt;Category&gt; <span>findAll</span>() {<br/>    <span>return this</span>.<span>categoryRepository</span>.findAll()<span>;<br/></span><span>  </span>}<br/><br/>  <span>public </span>List&lt;Category&gt; <span>findByName</span>(String name) {<br/>    <span>return this</span>.<span>categoryRepository</span>.findByName(name)<span>;<br/></span><span>  </span>}<br/><br/>  <span>public </span>List&lt;Category&gt; <span>findByNameStartingWith</span>(String name) {<br/>    <span>return this</span>.<span>categoryRepository</span>.findByNameIgnoreCaseStartingWith(name)<span>;<br/></span><span>  </span>}<br/><br/>  <span>public </span>Category <span>findOne</span>(String id) {<br/>    <span>final </span>Optional&lt;Category&gt; category = <span>this</span>.<span>categoryRepository</span>.findById(id)<span>;<br/></span><span>    if </span>(category.isPresent()) {<br/>      <span>return </span>category.get()<span>;<br/></span><span>    </span>} <span>else </span>{<br/>      <span>throw new </span>CategoryNotFoundException(id)<span>;<br/></span><span>    </span>}<br/>  }<br/><br/>}</pre>
<p>There are many <kbd>@Transactional</kbd> annotations in the <kbd>CategoryService</kbd> class. The first annotation at class level instructs the framework to configure the <kbd>readOnly</kbd> for all methods present in those classes, except the methods configured with <kbd>@Transactional</kbd>. In this case, the class-level annotation will be overridden with <kbd>readOnly=false</kbd>. This is the default configuration when the value is omitted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and configuring pgAdmin3</h1>
                </header>
            
            <article>
                
<p>To connect on our PostgreSQL instance, we will use <span>pgAdmin 3, which is the free tool provided by the Postgres team.</span></p>
<p><span>To install pgAdmin 3, we can use the following command:</span></p>
<pre><strong>sudo apt-get install pgadmin3 -y</strong></pre>
<p><span>This will install pgAdmin 3 on our machine.</span></p>
<p>After installation, open pgAdmin 3 and then click on <span class="packt_screen">Add a connection to a server</span>. The button looks like this<em><strong>:</strong></em></p>
<div class="CDPAlignCenter CDPAlign"><img height="69" src="assets/1dd5adeb-ebbf-47b8-a707-d01201e5e74f.png" width="81"/></div>
<p>Then, fill in the information, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="360" src="assets/fe9cc957-3670-4483-8475-6fc0265a1ef2.png" width="392"/></div>
<p>The password should be: <kbd>cms@springfive.</kbd></p>
<p>Awesome, our pgAdmin 3 tool is configured.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the data on the database structure</h1>
                </header>
            
            <article>
                
<p>The whole application structure is ready. Now, we can check the database to get our persisted data. There are many open source Postgres clients. We will use pgAdmin 3, as previously configured.</p>
<p>The first time you open the application, you will be asked about the credentials and host. We must put the same information as we configured on the <kbd>application.yaml</kbd> file. Then, we are able to make instructions in the database.</p>
<p>Before checking the database, we can use Swagger to create some categories in our CMS system. We can use the instructions provided in <a href="8b857b24-87be-4066-acb3-daa9a596b61e.xhtml">Chapter 2</a>, <em>Starting in the Spring World – The CMS Application,</em> to create some data.</p>
<p>After that, we can execute the following SQL instruction in the database:</p>
<pre><strong>select * from category;</strong></pre>
<p>And the result should be the categories created on Swagger calls. In my case, I have created two categories, <kbd>sports</kbd>, and <kbd>movies</kbd>. The result will be like the ones shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c77ce367-0276-46c9-844e-c609c52369f6.png"/></div>
<p>Awesome work, guys. The application is fully operational.</p>
<p>Now, we will create our final solution for the repositories. We have learned the basics of the Spring Data project and in the next section, we will change the persistence layer to a modern database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the final data access layer</h1>
                </header>
            
            <article>
                
<p>We have played with the Spring Data JPA project, and we have seen how easy it can be. We learned how to configure the database connections to persist the real data on the Postgres database. Now, we will create the final solution for the data access layer for our application. The final solution will use MongoDB as a database and will use the Spring Data MongoDB project, which provides support for MongoDB repositories.</p>
<p>We will see some similarities with the Spring Data JPA projects. It is amazing because we can prove the power of Spring Data abstractions in practice. With a couple of changes, we can move to another database model.</p>
<p>Let's understand the new project and put it into practice in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data MongoDB</h1>
                </header>
            
            <article>
                
<p>The Spring Data MongoDB provides integration with our domain objects and the MongoDB document. With a couple of annotations, our entity class is ready to be persisted in the database. The mapping is based on a <strong>POJO</strong> (<strong>Plain Old Java Object</strong>) pattern, which is known by all Java developers.</p>
<p>There are two levels of abstraction supplied by the module. The first one is a high-level abstraction. It increases the developer productivity. This level provides a couple of annotations to instruct the framework to convert the domain objects in MongoDB documents and vice versa. The developer does not need to write any code about the persistence; it will be managed by the Spring Data MongoDB framework. There are more exciting things at this level, such as the rich mapping configurations provided by the Spring Conversion Service. The Spring Data projects provide a rich DSL to enable developers to create queries based on the attribute names.</p>
<p>The second level of abstraction is the low-level abstraction. A<span>t this level, behaviors are not automatically managed by the framework</span>. The developers need to understand a little bit more about the Spring and MongoDB document model. The framework provides a couple of interfaces to enable developers to take control of the read and write instructions. This can be useful for scenarios where the high-level abstraction does not fit well. In this case, the control should be more granular in the entities mapping.</p>
<p>Again, Spring provides the power of choice for developers. The high-level abstraction improves the developer performance and the low-level permits developers to take more control.</p>
<p>Now, we will add mapping annotation to our model. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing the PostgreSQL and Spring Data JPA dependencies</h1>
                </header>
            
            <article>
                
<p>We will convert our project to use the brand new Spring Data Reactive MongoDB repositories. After that, we will not use the Spring Data JPA and PostgreSQL drivers anymore. Let's remove these dependencies from our <kbd>pom.xml</kbd>:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-data-jpa<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.postgresql<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>postgresql<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>42.1.4<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>And then, we can add the following dependency:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-data-mongodb-reactive<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<div class="packt_tip">The final version of <kbd>pom.xml</kbd> can be found on GitHub at <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping the domain model</h1>
                </header>
            
            <article>
                
<p>We will add mapping annotations on our domain model. The Spring Data MongoDB will use these annotations to persist our objects in the MongoDB collections. We will start with the <kbd>Category</kbd> entity, which should be like this:</p>
<pre>package springfive.cms.domain.models;<br/><br/>import lombok.Data;<br/>import org.springframework.data.annotation.Id;<br/>import org.springframework.data.mongodb.core.mapping.Document;<br/><br/>@Data<br/><strong>@Document(collection = "category")</strong><br/>public class Category {<br/><br/>  <strong>@Id</strong><br/>  String id;<br/><br/>  String name;<br/><br/>}</pre>
<p>We added two new annotations in the <kbd>Category</kbd> class. The <kbd>@Document</kbd> from Spring Data MongoDB enables us to configure the collection name. Collections in MongoDB are similar to tables in SQL databases.</p>
<p>The <kbd>@Id</kbd> annotation is from the Spring Data Commons project. It is interesting because, as we can see, it is not specific for MongoDB mappings. The field annotation with this will be converted in the <kbd>_id</kbd> field on MongoDB collection. </p>
<p>With these few annotations, the <kbd>Category</kbd> class is configured to be persisted on MongoDB. In the following section, we will create our repository classes.</p>
<p>We need to do the same task for our other entities. The <kbd>User</kbd> and <kbd>News</kbd> need to be configured in the same way as we did for the <kbd>Category</kbd> class. The full source code can be found on GitHub at: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the database connection</h1>
                </header>
            
            <article>
                
<p>Before we create our repositories, we will configure the MongoDB connection. The repository layer abstracts the driver implementation, but is necessary to configure the driver correctly.</p>
<p>On the resources directory, we will change the<span> </span><kbd>application.yaml</kbd><span> </span>file, previously configured for the Spring Data JPA. The Spring Framework supports the configuration through the YAML file. This kind of file is more readable for humans and has a kind of hierarchy. These features are the reason to choose this extension.</p>
<p>The <kbd>application.yaml</kbd> file should be like the following example:</p>
<pre>spring:<br/>  data:<br/>    mongodb:<br/>      database: cms<br/>      host: localhost<br/>      port: 27017</pre>
<div class="packt_tip">The <kbd>application.yaml</kbd> file for MongoDB can be found on GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml</a>).</div>
<p>The file is quite simple for now. There is a <kbd>database</kbd> tag for configuring the database name. The <kbd>host</kbd> and <kbd>port</kbd> tags are about the address that the MongoDB instance is running.</p>
<p>We also can configure the connections programmatically with a couple of objects, but it requires us to code a lot of boilerplate code. Spring Boot offers it out of the box for us. Let's enjoy it.</p>
<p>Excellent, the connection was configured successfully. The infrastructure requirements are solved. Let's go on to implement our repositories.</p>
<div class="packt_infobox">Spring Boot Framework supports profiles in <kbd>application.properties</kbd>or<kbd>application.yaml</kbd>. This means that if the application was configured in a properties file style, we could use <kbd>application-&lt;profile&gt;.properties</kbd>. Then, these properties will be applied to the required profile. In YAML style, we can use only one file with multiples profiles.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the repository layer</h1>
                </header>
            
            <article>
                
<p>Once the entities have been mapped, and the connections are done, it's time to create our repositories. The Spring Data Framework provides some interfaces that can be used in different use cases. We will use the specialization for the MongoDB database, which is <kbd>MongoRepository</kbd>. It extends the <kbd>PagingAndSortingRepository</kbd> and <kbd>QueryByExampleExecutor</kbd>. The first is about pagination and sorting features, and the other is about queries by example.</p>
<div class="packt_infobox">In some cases, the database query result set can be very large. This can cause some application performance issues because we will fetch a lot of database records. We can limit the number of records fetched from the database and configure limits for that. This technique is called <strong>Pagination</strong>. We can find the full documentation at <em>Spring Data Commons Documentation</em> (<a href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/">https://docs.spring.io/spring-data/commons/docs/current/reference/html/</a>).</div>
<p>This interface offers a lot of built-in methods for convenience. There are a couple of methods to insert one or more instances, methods for listing all instances of requested entities, methods to remove one or more instances, and many more features, such as ordering and paging.</p>
<p>It enables developers to create repositories without code or even without a deep knowledge of MongoDB. However, some knowledge of MongoDB is necessary to troubleshoot various errors.</p>
<p>We will start by creating the <kbd>CategoryRepository</kbd>. Change the type of <kbd>CategoryRepository</kbd> to an interface instead of a class. The code in this interface is not necessary. The Spring container will inject the correct implementation when the application starts.</p>
<p>Let's create our first concrete repository, which means the repository will persist the data on the MongoDB we previously configured. The <kbd>CategoryRepository</kbd> needs to be like this:</p>
<pre>package springfive.cms.domain.repository;<br/><br/>import org.springframework.data.mongodb.repository.MongoRepository;<br/>import springfive.cms.domain.models.Category;<br/><br/>public <strong>interface</strong> CategoryRepository extends <strong>MongoRepository&lt;Category,String&gt;</strong> {}</pre>
<p>The type is an <kbd>interface</kbd>.<em> </em><span>Repositories do not have any stereotypes anymore.</span> The Spring container can identify the implementation because it extends the <kbd>MongoRepository</kbd> interface.</p>
<p>The <kbd>MongoRepository</kbd> interface should be parameterized. The first argument is the type of model that it represents. In our case, it represents a repository for the <kbd>Category</kbd> class. The second parameter is about the type of ID of the model. We will use the string type for that.</p>
<p>Now, we need to do the same for the other entities, <kbd>User</kbd>, and <kbd>News</kbd>. The code is quite similar to the preceding code. You can find the full source code on GitHub at: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository</a>.</p>
<p>In the next section, we will check the database to assert that the rows are persisted correctly. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the persistence</h1>
                </header>
            
            <article>
                
<p>Now, we can test the persistence and all layers of the application. We will provide the API documentation for that. Let's open the Swagger documentation and create some records in our CMS application.</p>
<p>Creating sample categories on Swagger:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/19e4c9c0-2dd1-4672-893c-0893ec51560e.png"/></div>
<p>Fill in the category JSON, as shown in the preceding screenshot, and then click on <span class="packt_screen">Try it out!</span>. It will invoke the Category API and persist the category on the database. Now, we can check it.</p>
<p>To connect to the MongoDB instance and check the collection, we will use the <kbd>mongo-express</kbd> tool. It is a web-based tool written in NodeJS to interact with our database instance.</p>
<p>The tool can be installed, but we will run the tool on a Docker container. The Docker tool will help us in this part. Let's start the container:</p>
<pre><strong>docker run -d --link mongodb:mongo<span>--net cms-application </span>-p 8081:8081 mongo-express</strong></pre>
<p>It instructs Docker to spin up a container with the <kbd>mongo-express</kbd> tool and connect to the desired instance. The <kbd>--link</kbd> argument instructs Docker to create a kind of <em>hostname</em> for our MongoDB instance. Remember the name of our instance is <kbd>mongodb</kbd>; we did it on the run command previously.</p>
<p>Good job. Go to <kbd>http://localhost:8081</kbd> and we will see this page:</p>
<div class="CDPAlignCenter CDPAlign"><img height="523" src="assets/612df25d-1ee2-4b1e-9242-782e95554648.png" width="906"/></div>
<p>There are a couple of databases. We are interested in the CMS database. Click on the <span class="packt_screen">View</span> button next to <span class="packt_screen">cms</span>. Then, the tool will present the collections of the selected database; in our case, the CMS database. The view should be like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="477" src="assets/06842b34-47ef-433d-a742-d7961996a368.png" width="852"/></div>
<p>The category is presented as a collection. We can <span class="packt_screen">View</span>, <span class="packt_screen">Export</span>, and export as JSON, but for now, we are interested in checking if our CMS application persisted the data properly. So, click on the <span class="packt_screen">View</span> button. We will use the MongoDB collection data like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="425" src="assets/ca8b9aca-8cd4-4077-8617-f34e4e83df0f.png" width="931"/></div>
<p>As we can see, the data was stored in MongoDB as expected. There are two categories in the database—<span class="packt_screen">sports</span> and <span class="packt_screen">travel</span>. There is a <kbd><span>_class</span></kbd> field that helps Spring Data to convert domain classes.</p>
<p>Awesome job, the CMS application is up and running, and also persisting the data in MongoDB. Now, our application is almost production ready, and the data is persisted outside in the amazing document datastore.</p>
<p>In the following section, we will create our Docker image, and then we will run the CMS application with Docker commands. It will be interesting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Docker image for CMS</h1>
                </header>
            
            <article>
                
<p>We are doing an awesome job. We created an application with the Spring Boot Framework. The application has been using the Spring REST, Spring Data, and Spring DI.</p>
<p>Now we will go a step forward and create our Docker image. It will be useful to help us to deliver our application for production. There are some advantages, and we can run the application on-premise or on any cloud providers because Docker abstracts the operating system layer. We do not need Java to be installed on the application host, and it also allows us to use different Java versions on the hosts. There are so many advantages involved in adopting Docker for delivery. </p>
<p>We are using Maven as a build tool. Maven has an excellent plugin to helps us to create Docker images. In the following section, we will learn how Maven can help us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the docker-maven-plugin</h1>
                </header>
            
            <article>
                
<p>There is an excellent Maven plugin provided by fabric8 (<a href="https://github.com/fabric8io/docker-maven-plugin">https://github.com/fabric8io/docker-maven-plugin</a>). It is licensed under the Apache-2.0 license, which means we can use it without any worries.</p>
<p>We will configure our project to use it, and after image creation, we will push this image on Docker Hub. It is a public Docker registry. </p>
<p>The steps are:</p>
<ol>
<li>Configure the plugin</li>
<li>Push the Docker image</li>
<li>Configure the Docker Spring profile</li>
</ol>
<p>Then, it is show time. Let's go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the plugin on pom.xml</h1>
                </header>
            
            <article>
                
<p>Let's configure the Maven plugin. It is necessary to add a plugin to the plugin section on our <kbd>pom.xml</kbd> and add some configurations. The plugin should be configured as follows:</p>
<pre>&lt;plugin&gt;<br/>   &lt;groupId&gt;io.fabric8&lt;/groupId&gt;<br/>   &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;<br/>   &lt;version&gt;0.21.0&lt;/version&gt;<br/>   &lt;configuration&gt;<br/>      &lt;images&gt;<br/>         &lt;image&gt;<br/>            <strong>&lt;name&gt;springfivebyexample/${project.build.finalName}&lt;/name&gt; </strong><br/>            &lt;build&gt;<br/>               &lt;from&gt;openjdk:latest&lt;/from&gt;<br/>               <strong>&lt;entryPoint&gt;java -Dspring.profiles.active=container -jar /application/${project.build.finalName}.jar&lt;/entryPoint&gt;</strong><br/>               &lt;assembly&gt;<br/>                  <strong>&lt;basedir&gt;/application&lt;/basedir&gt;</strong><br/>                  &lt;descriptorRef&gt;artifact&lt;/descriptorRef&gt;<br/>                  &lt;inline&gt;<br/>                     &lt;id&gt;assembly&lt;/id&gt;<br/>                     &lt;files&gt;<br/>                        &lt;file&gt;<br/>                           <strong>&lt;source&gt;target/${project.build.finalName}.jar&lt;/source&gt;</strong><br/>                        &lt;/file&gt;<br/>                     &lt;/files&gt;<br/>                  &lt;/inline&gt;<br/>               &lt;/assembly&gt;<br/>               &lt;tags&gt;<br/>                  &lt;tag&gt;latest&lt;/tag&gt;<br/>               &lt;/tags&gt;<br/>               &lt;ports&gt;<br/>                  <strong>&lt;port&gt;8080&lt;/port&gt;</strong><br/>               &lt;/ports&gt;<br/>            &lt;/build&gt;<br/>            &lt;run&gt;<br/>               &lt;namingStrategy&gt;alias&lt;/namingStrategy&gt;<br/>            &lt;/run&gt;<br/>            &lt;alias&gt;${project.build.finalName}&lt;/alias&gt;<br/>         &lt;/image&gt;<br/>      &lt;/images&gt;<br/>   &lt;/configuration&gt;<br/>&lt;/plugin&gt;</pre>
<p>There are a couple of new configurations here. Let's start with the <kbd>&lt;name&gt;</kbd> tag—it configures the repository and Docker image name to push to Docker Hub. For this book, we will use <kbd>springfivebyexample</kbd> as a Docker ID. We can see there is a <em>slash</em> as a separator for the repository and image name. The image name for us will be the final project name. Then, we need to configure it.</p>
<div class="packt_infobox">The Docker ID is free to use, which can be used to access some Docker services, such as Docker Store, Docker Cloud, and Docker Hub. We can find more information at Docker Page (<a href="https://docs.docker.com/docker-id/">https://docs.docker.com/docker-id/</a>).</div>
<p>This configuration should be the same as shown in the following code snippet:</p>
<pre>&lt;build&gt;<br/>  <strong>&lt;finalName&gt;cms&lt;/finalName&gt;</strong><br/>  ....<br/>&lt;/build&gt;</pre>
<p>Another important tag is <kbd>&lt;entrypoint&gt;</kbd>. This is an exec system call instruction when we use the <kbd>docker run</kbd> command. In our case, we expected the application to run when the container bootstraps. We will execute <kbd>java -jar</kbd> passing the container as an active profile for Spring.</p>
<p>We need to pass the full path of the Java artifact. This path will be configured on the <kbd>&lt;assembly&gt;</kbd> tag with the <kbd>&lt;basedir&gt;</kbd> <span>parameter. I</span>t can be any folder name. Also, there is a configuration to the Java artifact path. Usually, this is the target folder which is the result of the compilation. It can be configured in the <kbd>&lt;source&gt;</kbd> tag.</p>
<p>Finally, we have the <kbd>&lt;port&gt;</kbd> configuration. The port of the application will be exposed using this tag.</p>
<p>Now, we will create a Docker image by using the following instruction:</p>
<pre>mvn clean install <strong>docker:build</strong></pre>
<p>It should be executed in the root folder of the project. <span>The goal of the <kbd>docker:build</kbd> command is to build a Docker image for our project</span>. After the build ends, we can check if the Docker image has been created successfully.</p>
<p>Then, type the following command:</p>
<pre>docker images</pre>
<p>The <kbd>springfivebyexample/cms</kbd> image should be present, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb420ba4-fd31-4f1c-9c8a-f6b3002071b1.png"/></div>
<p>Good. The image is ready. Let's push to the Docker Hub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pushing the image to Docker Hub</h1>
                </header>
            
            <article>
                
<p>The Docker Hub is a public repository to store Docker images. It is free, and we will use it for this book. Now, we will push our image to the Docker Hub registry.</p>
<p>The command for that is pretty simple. Type:</p>
<pre><strong>docker push springfivebyexample/cms:latest</strong></pre>
<div class="packt_infobox">I have used the <kbd>springfivebyexample</kbd> user that I have created. You can test the <kbd>docker push</kbd> command creating by your own user on Docker Hub and changing the user on the <kbd>docker push</kbd> command. You can create your Docker ID at Docker Hub (<a href="https://cloud.docker.com/">https://cloud.docker.com/</a>).</div>
<p>Then, the image will be sent to the registry. That is it.</p>
<div class="packt_tip">We can find the image at Docker Hub (<a href="https://store.docker.com/community/images/springfivebyexample/cms">https://store.docker.com/community/images/springfivebyexample/cms</a>). If you have used your own user, the link will probably change.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Docker Spring profile</h1>
                </header>
            
            <article>
                
<p>Before we run our application in a Docker container, we need to create a YAML file to configure a container profile. The new YAML file should be named as <kbd>application-container.yaml</kbd> because we will use the container profile to run it. Remember, we configured the <kbd>entrypoint</kbd> on <kbd>pom.xml</kbd> in the previous section.</p>
<p>Let's create our new file. The file should be the same content as described in the following snippet:</p>
<pre>spring:<br/>  data:<br/>    mongodb:<br/>      database: cms<br/>      host: mongodb<br/>      port: 27017</pre>
<p>The host must be changed for MongoDB. We have been running the MongoDB container with this name in the <em>Preparing a MongoDB</em> section. It is an important configuration, and we need to pay attention at this point. We cannot use localhost anymore because the application is running in the Docker container now. The localhost in that context means it is in the same container, and we do not have MongoDB in the CMS application container. We need to have one application per container and avoid multiple responsibilities for one container.</p>
<p>Done. In the following section, we will run our first application in the Docker container. It will be amazing. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Dockerized CMS</h1>
                </header>
            
            <article>
                
<p>In the previous section, we have created our file to configure the container profile properly. Now, it is time to run our container. The command is quite simple, but we need to pay attention to the arguments. </p>
<p>The instruction we run should be the same as the following code:</p>
<pre>docker run -d --name cms <strong>--link mongodb:mongodb</strong> --net cms-application -p 8080:8080 springfivebyexample/cms:latest</pre>
<p>We have been setting the link for the MongoDB container. Remember, we made this configuration in the YAML file, in the <kbd>host</kbd> property. During the bootstrapping phase, the application will look for MongoDB instance named <kbd>mongodb</kbd>. We solved this by using the link command. It will work perfectly.</p>
<p>We can check if our application is healthy by using the <kbd>docker ps</kbd> command. The output should be like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa2019c6-2585-4fdb-aee0-97d8d59cd286.png"/></div>
<p>In the first line, we have our application container. It is up and running.</p>
<p>Awesome work. Our application is fully containerized and ready to deploy anywhere we want.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting in Reactive fashion</h1>
                </header>
            
            <article>
                
<p>We have been creating an amazing application with Spring Boot. The application was built on the traditional web stack present on Spring Framework. It means the application uses the web servers based on Servlet APIs. </p>
<p>The servlet specification was built with the blocking semantics or one-request-per-thread model. Sometimes, we need to change the application architecture because of non-functional requirements. For example, if the application was bought by a huge company, and that company wanted to create a plan to launch the application for the entire world, the volume of requests would probably increase a lot. So, we need to change the architecture to adapt the application structure for cloud environments.</p>
<p>Usually, in a cloud environment, the machines are smaller than traditional data centers. Instead of a big machine, it is popular to use many small machines and try to scale applications horizontally. In this scenario, the servlet spec can be switched to an architecture created upon Reactive Streams. This kind of architecture fits better than servlet for the cloud environments.</p>
<p>Spring Framework has been creating the Spring WebFlux to helps developers to create Reactive Web Applications. Let's change our application architecture to reactive and learn the pretty new Spring WebFlux component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Spring</h1>
                </header>
            
            <article>
                
<p>The Reactive Stream Spec is the specification that provides a standard for asynchronous programming for stream processing. It is becoming popular in the programming world nowadays, and Spring introduces it on the framework. </p>
<p>This style of programming is more efficient regarding resources usage and fits amazingly with the new generation of machines with multiple cores.</p>
<p>Spring reactive uses the Project Reactor as the implementation for the Reactive Streams. The Project Reactor is powered by Pivotal and has the very good implementation of the Reactive Streams Spec.</p>
<p>Now, we will deep dive in the reactive module for Spring Boot and create an amazing reactive API and try the new style of the Spring Framework. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project Reactor</h1>
                </header>
            
            <article>
                
<p>The Project Reactor was created by the Spring and Pivotal teams. This project is an implementation of Reactive Streams for JVM.  It is a fully non-blocking foundation and helps developers to create a non-blocking application in the JVM ecosystem.</p>
<p>There is a restriction to using Reactor in our application. The project runs on Java 8 and above. It is important because we will use many lambda expressions in our examples and projects.</p>
<p><span>The Spring Framework internally uses the Project Reactor as an implementation of Reactive Streams.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components</h1>
                </header>
            
            <article>
                
<p>Let's look at the different components of the Project Reactor:</p>
<ul>
<li><strong>Publishers</strong>:<strong> </strong>The publishers are responsible for pushing data elements to the stream. It notifies the subscribers that a new piece of data is coming to the stream.<br/>
The publisher interface is defined in the following code snippet:</li>
</ul>
<pre style="padding-left: 60px"><span>/************************************************************************<br/></span><span> * Licensed under Public Domain (CC0)                                    *<br/></span><span> *                                                                       *<br/></span><span> * To the extent possible under law, the person who associated CC0 with  *<br/></span><span> * this code has waived all copyright and related or neighboring         *<br/></span><span> * rights to this code.                                                  *<br/></span><span> *                                                                       *<br/></span><span> * You should have received a copy of the CC0 legalcode along with this  *<br/></span><span> * work. If not, see </span><span>&lt;http:</span><span>//creativecommons.org/publicdomain/zero/1.0/&gt;.*<br/></span><span> ************************************************************************/<br/></span><span><br/></span><span>package </span>org.reactivestreams<span>;<br/></span><span><br/></span><span>/**<br/></span><span> * A {</span><span>@link </span><span>Publisher} is a provider of a potentially unbounded number of sequenced elements, publishing them according to<br/></span><span> * the demand received from its {</span><span>@link </span><span>Subscriber}(s).<br/></span><span> * </span><span>&lt;p&gt;<br/></span><span> </span><span>* A {</span><span>@link </span><span>Publisher} can serve multiple {</span><span>@link </span><span>Subscriber}s subscribed {</span><span>@link </span><span>#subscribe(Subscriber)} dynamically<br/></span><span> * at various points in time.<br/></span><span> *<br/></span><span> * </span><span>@param </span><span>&lt;</span><span>T</span><span>&gt; </span><span>the type of element signaled.<br/></span><span> */<br/></span><span>public interface </span>Publisher&lt;<span>T</span>&gt; {<br/><span><br/></span><span>    </span><span>public void </span><span>subscribe</span>(Subscriber&lt;? <span>super </span><span>T</span>&gt; s)<span>;<br/><br/></span>}</pre>
<ul>
<li><strong>Subscribers</strong>: The subscribers are responsible for making the data flow in the stream. When the publisher starts to send the piece of data on the data flow, the piece of data will be collected by the <kbd>onNext(T instance)</kbd> <span>method, which is the parametrized interface. <br/></span>The subscriber interface is defined in the following code snippet:</li>
</ul>
<pre style="padding-left: 60px"><span>/************************************************************************<br/></span><span> * Licensed under Public Domain (CC0)                                    *<br/></span><span> *                                                                       *<br/></span><span> * To the extent possible under law, the person who associated CC0 with  *<br/></span><span> * this code has waived all copyright and related or neighboring         *<br/></span><span> * rights to this code.                                                  *<br/></span><span> *                                                                       *<br/></span><span> * You should have received a copy of the CC0 legalcode along with this  *<br/></span><span> * work. If not, see </span><span>&lt;http:</span><span>//creativecommons.org/publicdomain/zero/1.0/&gt;.*<br/></span><span> ************************************************************************/<br/></span><span><br/></span><span>package </span>org.reactivestreams<span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Will receive call to {</span><span>@link </span><span>#onSubscribe(Subscription)} once after passing an instance of {</span><span>@link </span><span>Subscriber} to {</span><span>@link </span><span>Publisher#subscribe(Subscriber)}.<br/></span><span> * </span><span>&lt;p&gt;<br/></span><span> </span><span>* No further notifications will be received until {</span><span>@link </span><span>Subscription#request(long)} is called.<br/></span><span> * </span><span>&lt;p&gt;<br/></span><span> </span><span>* After signaling demand:<br/></span><span> * </span><span>&lt;ul&gt;<br/></span><span> </span><span>* </span><span>&lt;li&gt;</span><span>One or more invocations of {</span><span>@link </span><span>#onNext(Object)} up to the maximum number defined by {</span><span>@link </span><span>Subscription#request(long)}</span><span>&lt;/li&gt;<br/></span><span> </span><span>* </span><span>&lt;li&gt;</span><span>Single invocation of {</span><span>@link </span><span>#onError(Throwable)} or {</span><span>@link </span><span>Subscriber#onComplete()} which signals a terminal state after which no further events will be sent.<br/></span><span> * </span><span>&lt;/ul&gt;<br/></span><span> </span><span>* </span><span>&lt;p&gt;<br/></span><span> </span><span>* Demand can be signaled via {</span><span>@link </span><span>Subscription#request(long)} whenever the {</span><span>@link </span><span>Subscriber} instance is capable of handling more.<br/></span><span> *<br/></span><span> * </span><span>@param </span><span>&lt;</span><span>T</span><span>&gt; </span><span>the type of element signaled.<br/></span><span> */<br/></span><span>public interface </span>Subscriber&lt;<span>T</span>&gt; {<br/>    <span><br/></span><span>    </span><span>public void </span><span>onSubscribe</span>(Subscription s)<span>;<br/></span><span><br/></span><span>    </span><span>public void </span><span>onNext</span>(<span>T </span>t)<span>;<br/></span><span><br/></span><span>    </span><span>public void </span><span>onComplete</span>()<span>;<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot and cold</h1>
                </header>
            
            <article>
                
<p>There are two categories of reactive sequences—hot and cold. These functions affect the usage of the implementation directly. Hence, we need to understand them:</p>
<ul>
<li><strong>Cold</strong>: The cold publishers start to generate data only if it receives a new subscription. If there are no subscriptions, the data never comes to the flow.</li>
<li><strong>Hot</strong>: The hot publishers do not need any subscribers to generate the data flow. When the new subscriber is registered, the subscriber will only get the new data elements emitted.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive types</h1>
                </header>
            
            <article>
                
<p>There are two reactive types which represent the reactive sequences. The<span> </span><kbd>Mono</kbd><span> </span>objects represent a single value or empty 0|1. The<span> </span><kbd>Flux</kbd><span> </span>objects represent a sequence of 0|N items.</p>
<p>We will find many references in our code. The Spring Data reactive repository uses these abstractions in their methods. The<span> </span><kbd>findOne()</kbd><span> </span>method returns the<span> </span><kbd>Mono&lt;T&gt;</kbd><span> </span>object and the<span> </span><kbd>findAll()</kbd><span> </span>returns a<span> </span><kbd>Flux&lt;T&gt;</kbd>. The same behavior we will be found in our REST resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let's play with the Reactor</h1>
                </header>
            
            <article>
                
<p>To understand it better, let's play with the Reactor. We will implement and understand the difference between hot and cold publishers in practice. </p>
<p><strong>Cold</strong> publishers do not produce any data until a new subscription arrives. In the following code, we will create a cold publisher and the <kbd>System.out:println</kbd> will never be executed because it does not have any subscribers. Let's test the behavior:</p>
<pre><span>@Test<br/></span><span>public void </span><strong>coldBehavior</strong>(){<br/>  Category sports = <span>new </span>Category()<span>;<br/></span><span>  </span>sports.setName(<span>"sports"</span>)<span>;<br/></span><span>  </span>Category music = <span>new </span>Category()<span>;<br/></span><span>  </span>sports.setName(<span>"music"</span>)<span>;<br/></span><span>  </span>Flux.<span>just</span>(sports<span>,</span>music)<br/>      .doOnNext(System.<span>out</span>::println)<span>;<br/></span>}</pre>
<p>As we can see, the method <kbd>subscribe()</kbd> is not present in this snippet. When we execute the code, we will not see any data on the standard print output.</p>
<p>We can execute the method on the IDE. We will able to see the output of this test. The output should be like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e2ea25e-3922-45d7-b0fc-beddae937856.png"/></div>
<p>The process has finished, the test passed, and we will not be able to see the print. That is the cold publisher's behavior.</p>
<p>Now, we will subscribe the publisher and the data will be sent on the data flow. Let's try this.</p>
<p>We will insert the subscribe instruction after <kbd>doOnNext()</kbd>. Let's change our code:</p>
<pre> @Test<br/>  public void coldBehaviorWithSubscribe(){<br/>    Category sports = new Category();<br/>    sports.setId(UUID.randomUUID().toString());<br/>    sports.setName("sports");<br/>    Category music = new Category();<br/>    music.setId(UUID.randomUUID().toString());<br/>    music.setName("music");<br/>    Flux.just(sports,music)<br/>        .doOnNext(System.out::println)<br/>        .<strong>subscribe()</strong>;<br/>  }</pre>
<p>The output should be like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bcfef033-e11d-4d1d-9b4b-d9cdb2ac69b3.png"/></div>
<p>In the preceding screenshot, we can see that the publisher pushes the data on the stream after the stream got subscribed. That is the cold publisher behavior after the subscription.</p>
<p>Hot publishers do not depend on any subscribers. The hot publisher will publish data, even if there is no subscriber to receive the data. Let's see an example:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testHotPublisher</span>(){<br/>  UnicastProcessor&lt;String&gt; hotSource = UnicastProcessor.<span>create</span>()<span>;<br/></span><span>  </span>Flux&lt;Category&gt; hotPublisher = hotSource.publish()<br/>      .autoConnect().map((String t) -&gt; Category.<span>builder</span>().name(t).build())<span>;<br/></span><span>  </span>hotPublisher.subscribe(category -&gt; System.<span>out</span>.println(<span>"Subscriber 1: "</span>+ category.getName()))<span>;<br/></span><span>  </span>hotSource.onNext(<span>"sports"</span>)<span>;<br/></span><span>  </span>hotSource.onNext(<span>"cars"</span>)<span>;<br/></span><span>  </span>hotPublisher.subscribe(category -&gt; System.<span>out</span>.println(<span>"Subscriber 2: "</span>+category.getName()))<span>;<br/></span><span>  </span>hotSource.onNext(<span>"games"</span>)<span>;<br/></span><span>  </span>hotSource.onNext(<span>"electronics"</span>)<span>;<br/></span><span>  </span>hotSource.onComplete()<span>;<br/></span>}</pre>
<p>Let's understand what happens here. The <kbd>UnicastProcessor</kbd> is a processor that allows only one <kbd>Subscriber</kbd>.The processor replays notifications when the subscriber requests. It will emit some data on a stream. The first subscription will capture all the categories, as we will see, because it was registered before the event emissions. The second subscription will capture only the last events because it was registered before the last two emissions. </p>
<p>The output of the preceding code should be:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/47ec7d59-37b9-4c73-9997-cc6cad4ecc34.png"/></div>
<p>Awesome. This is the hot publisher's behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux</h1>
                </header>
            
            <article>
                
<p class="mce-root">The traditional Java enterprise web applications are based on the servlet specification. The servlet specification before 3.1 is synchronous, which means it was created with blocking semantics. This model was good at the time because computers were big with a powerful CPU and hundreds of gigabytes of memory. Usually, the applications at the time were configured with a big thread pool with hundreds of threads because the computer was designed for this. The primary deployment model at that time was the replica. There are some machines with the same configuration and application deployments.</p>
<p><span>The developers have been creating applications like this for many years.</span></p>
<p>Nowadays, most of the applications are deployed in cloud vendors. There are no big machines anymore because the price is much higher. Instead of big machines, there are a number of small machines. It is much cheaper and these machines have a reasonable CPU power and memory. </p>
<p>In this new scenario, the application with the huge thread pools is not effective anymore, because the machine is small and it does not have the power to handle all these threads.</p>
<p>The Spring Team added the support for the Reactive Streams in the framework. This model of programming changes the application deployment and the way to build applications.</p>
<p>Instead of a thread-per-request model, the applications are created with the event-loop model. This model requires a small number of threads and is more efficient regarding resource usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event-loop model</h1>
                </header>
            
            <article>
                
<p>Popularized by the NodeJS language, this model is based on event-driven programming. There are two central concepts: the events which will be enqueued on a queue, and the handlers which keep track of and process these events.</p>
<p>There are some advantages of adopting this model. The first one is the ordering. The events are enqueued and dispatched in the same order in which the events are coming. In some uses cases, this is an important requirement.</p>
<p>The other one is the synchronization. The event-loop must be executed on only one thread. This makes the states easy to handle and avoids the shared state problems.</p>
<p>There is an important piece of advice here. The handlers must not be synchronous. Otherwise, the application will be blocked until the handlers end their workload.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data for Reactive Extensions</h1>
                </header>
            
            <article>
                
<p>The Spring Data projects have some extensions to work with a reactive foundation. The project provides a couple of implementations based on asynchronous programming. It means the whole stack is asynchronous since database drivers are as well.</p>
<p>The Spring reactive repository supports Cassandra, MongoDB, and Redis as database stores. The repository implementations offer the same behaviors as the non-reactive implementation. There is a <strong>DSL</strong> (<strong>Domain-Specific Language</strong>) to create domain-specific query methods.</p>
<p>The module uses the Project Reactor as a reactive foundation implementation, but is possible to change the implementation to RxJava as well. Both libraries are production-ready and are adopted by the community. One point to be aware of is that if we change to RxJava, we need to ensure our method returns to <kbd>Observable</kbd> and <kbd>Single</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data Reactive</h1>
                </header>
            
            <article>
                
<p>The Spring Data Project has support for the reactive data access. Until now, Spring has support for MongoDB, Apache Cassandra, and Redis, all of which have reactive drivers.</p>
<p>In our CMS application, we will use the MongoDB reactive drivers to give the reactive characteristics for our repositories. We will use the new reactive interface provided by the Spring Data reactive. Also, we need to change the code a little bit. In this chapter, we will do that step by step. Let's start.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive repositories in practice</h1>
                </header>
            
            <article>
                
<p>Before we start, we can check out the full source code at GitHub, or we can perform the following steps.</p>
<p>Now, we are ready to build our new reactive repositories. The first thing that we need to do is add the Maven dependencies to our project. This can be done using <kbd>pom.xml</kbd>.</p>
<p>Let's configure our new dependency:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-data-mongodb-reactive<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Our project is ready to use reactive MongoDB repositories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the first Reactive repository</h1>
                </header>
            
            <article>
                
<p>We have a couple of repositories in our CMS project. Now, we need to convert these repositories to reactive ones. The first thing we will do is remove the extension from <kbd>CrudRepository</kbd>, which is not necessary anymore. Now, we want the reactive version of that. </p>
<p>We will update the <kbd>ReactiveMongoRepository</kbd> interface. The parameters of the interface are the same as the ones we inserted before. The interface should be like this:</p>
<pre>package springfive.cms.domain.repository;<br/><br/>import org.springframework.data.mongodb.repository.ReactiveMongoRepository;<br/>import springfive.cms.domain.models.Category;<br/><br/>public interface CategoryRepository extends <strong>ReactiveMongoRepository&lt;Category,String&gt;</strong> {<br/>}</pre>
<p>This is quite similar to the one we created before. We need to extend the new <kbd>ReactiveMongoRepository</kbd> <span>interface, </span>which contains methods for the CRUD operations and much more. The interface returns <kbd>Mono&lt;Category&gt;</kbd> or <kbd>Flux&lt;Category&gt;</kbd><span>.  The methods do not return the entities anymore. It is a common way of programming when the Reactive Stream is adopted.</span></p>
<p>We need to change the other repositories as well. You can find the full source code on GitHub at: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository</a>.</p>
<p>Now, we need to change the service layer. Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fixing the service layer</h1>
                </header>
            
            <article>
                
<p>We need to change the service layer to adopt the new reactive programming style. We changed the repository layer, so now we need to fix the compilation problem result because of this change. The application needs to be reactive. Any point of the application can be blocked because we are using the event-loop model. If we do not do this, the application will be getting blocked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the CategoryService</h1>
                </header>
            
            <article>
                
<p>Now, we will fix the <kbd>CategoryService</kbd> class. We will change the return type of a couple of methods. Before, we could return the model class, but now we need to change to return <kbd>Mono</kbd> or <kbd>Flux</kbd>, similar to what we did in the repository layer.</p>
<p>The new <kbd>CategoryService</kbd> should be like the implementation shown in the following code snippet:</p>
<pre>package springfive.cms.domain.service;<br/><br/>import org.springframework.stereotype.Service;<br/>import reactor.core.publisher.Flux;<br/>import reactor.core.publisher.Mono;<br/>import springfive.cms.domain.models.Category;<br/>import springfive.cms.domain.repository.CategoryRepository;<br/>import springfive.cms.domain.vo.CategoryRequest;<br/><br/>@Service<br/>public class <strong>CategoryService</strong> {<br/><br/>  private final CategoryRepository categoryRepository;<br/><br/>  public CategoryService(CategoryRepository categoryRepository) {<br/>    this.categoryRepository = categoryRepository;<br/>  }<br/><br/>  public <strong>Mono&lt;Category&gt;</strong> update(String id,CategoryRequest category){<br/>    return this.categoryRepository.findById(id).flatMap(categoryDatabase -&gt; {<br/>      categoryDatabase.setName(category.getName());<br/>      return this.categoryRepository.save(categoryDatabase);<br/>    });<br/>  }<br/><br/>  public <strong>Mono&lt;Category&gt;</strong> create(CategoryRequest request){<br/>    Category category = new Category();<br/>    category.setName(request.getName());<br/>    return this.categoryRepository.save(category);<br/>  }<br/><br/>  public void delete(String id){<br/>    this.categoryRepository.deleteById(id);<br/>  }<br/><br/>  public <strong>Flux&lt;Category&gt;</strong> findAll(){<br/>    return this.categoryRepository.findAll();<br/>  }<br/><br/>  public <strong>Mono&lt;Category&gt;</strong> findOne(String id){<br/>    return this.categoryRepository.findById(id);<br/>  }<br/><br/>}</pre>
<p>As we can see, the return types changed in the methods.</p>
<p>The important thing here is that we need to follow the reactive principles. When the method returns only one instance, we need to use <kbd>Mono&lt;Category&gt;</kbd>. When the method returns one or more instances, we should use <kbd>Flux&lt;Category&gt;</kbd>. This is essential to follow because developers and Spring containers can then interpret the code correctly.</p>
<p>The <kbd>update()</kbd> <span>method </span>has an interesting call: <kbd>flatMap()</kbd>. The project reactor allows us to use a kind of DSL to compose calls. It is very interesting and very useful as well. It helps developers to create code that is easier to understand than before. The <kbd>flatMap()</kbd> <span>method </span>is usually used to convert the data emitted by <kbd>Mono</kbd> or <kbd>Flux</kbd>. In this context, we need to set the new name of the category on the category retrieved from the database. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the REST layer</h1>
                </header>
            
            <article>
                
<p>We will make some fixes on the REST layer as well. We changed the service layer, and it caused some compilation problems in our resources classes.</p>
<p>We need to add the new dependency, <kbd>spring-web-reactive</kbd>. This supports the <kbd>@Controller</kbd> or <kbd>@RestController</kbd> annotations for the reactive non-blocking engine. The Spring MVC does not support the reactive extensions, and this module enables developers to use reactive <span>paradigms,</span> as they did before.</p>
<p><kbd>spring-web-reactive</kbd> will change many contracts on the Spring MVC foundations, such as <kbd>HandlerMapping</kbd>, and <kbd>HandlerAdapter</kbd>, to enable reactive foundations on these components. </p>
<p>The following image can help us to better understand the Spring HTTP layers:</p>
<div class="CDPAlignCenter CDPAlign"><img height="123" src="assets/1890e6e7-c0ca-4eb5-a423-dec9beea51ed.png" width="255"/></div>
<p>As we can see, <kbd>@Controller</kbd> and <kbd>@RequestMapping</kbd> can be used for different approaches in the Spring MVC traditional applications, or by using the Spring web reactive module.</p>
<p>Before we start to change our REST layer, we need to remove the Spring Fox dependencies and annotations in our project. At present, the Spring Fox has no support for reactive applications yet.</p>
<p>The dependencies to remove are:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.springfox<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>springfox-swagger2<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>2.7.0<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.springfox<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>springfox-swagger-ui<span>&lt;/artifactId&gt;<br/></span></pre>
<pre><span>  &lt;version&gt;</span>2.7.0<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>After that, we need to remove the annotations from the Swagger packages, such as <kbd>@Api</kbd> and <kbd>@ApiOperation</kbd>.</p>
<p>Now, let's adjust our REST layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the Spring WebFlux dependency</h1>
                </header>
            
            <article>
                
<p>Before we start to change our REST layer, we need to add the new dependency to our <kbd>pom.xml</kbd>.</p>
<p>First, we will remove the Spring MVC traditional dependencies. To do this, we need to remove the following dependency:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;<strong>spring-boot-starter-web</strong>&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>We do not need this dependency anymore. Our application will be reactive now. Then, we need to add the new dependencies described in the following code snippet:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;io.netty&lt;/groupId&gt;<br/>  &lt;artifactId&gt;<strong>netty-transport-native-epoll</strong>&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;<strong>spring-boot-starter-webflux</strong>&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p><kbd>spring-boot-starter-webflux</kbd><strong> </strong>is a kind of syntax sugar for dependencies. It has the <kbd>spring-boot-starter-reactor-netty</kbd> dependency, which is the Reactor Netty, as embedded in the reactive HTTP server.</p>
<p>Awesome, our project is ready to convert the REST layer. Let's transform our application into a fully reactive application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the CategoryResource</h1>
                </header>
            
            <article>
                
<p>We will change the <kbd>CategoryResource</kbd> class. The idea is pretty simple. We will convert our <kbd>ResponseEntity</kbd>, which is parametrized with the models class to <kbd>ResponseEntity</kbd> using <kbd>Mono</kbd> or <kbd>Flux</kbd>.</p>
<p>The new version of the <kbd>CategoryResource</kbd> should be like this:</p>
<pre>package springfive.cms.domain.resources;<br/><br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.DeleteMapping;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.PostMapping;<br/>import org.springframework.web.bind.annotation.PutMapping;<br/>import org.springframework.web.bind.annotation.RequestBody;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.ResponseStatus;<br/>import org.springframework.web.bind.annotation.RestController;<br/>import reactor.core.publisher.Flux;<br/>import reactor.core.publisher.Mono;<br/>import springfive.cms.domain.models.Category;<br/>import springfive.cms.domain.service.CategoryService;<br/>import springfive.cms.domain.vo.CategoryRequest;<br/><br/>@RestController<br/>@RequestMapping("/api/category")<br/>public class CategoryResource {<br/><br/>  private final CategoryService categoryService;<br/><br/>  public CategoryResource(CategoryService categoryService) {<br/>    this.categoryService = categoryService;<br/>  }<br/><br/>  @GetMapping(value = "/{id}")<br/>  public <strong>ResponseEntity&lt;Mono&lt;Category&gt;&gt;</strong> findOne(@PathVariable("id") String id){<br/>    return ResponseEntity.ok(this.categoryService.findOne(id));<br/>  }<br/><br/>  @GetMapping<br/>  public <strong>ResponseEntity&lt;Flux&lt;Category&gt;&gt;</strong> findAll(){<br/>    return ResponseEntity.ok(this.categoryService.findAll());<br/>  }<br/><br/>  @PostMapping<br/>  public <strong>ResponseEntity&lt;Mono&lt;Category&gt;&gt;</strong> newCategory(<strong>@RequestBody</strong> CategoryRequest category){<br/>    return new ResponseEntity&lt;&gt;(this.categoryService.create(category), HttpStatus.CREATED);<br/>  }<br/><br/>  @DeleteMapping("/{id}")<br/>  @ResponseStatus(HttpStatus.NO_CONTENT)<br/>  public void removeCategory(@PathVariable("id") String id){<br/>    this.categoryService.delete(id);<br/>  }<br/><br/>  @PutMapping("/{id}")<br/>  public <strong>ResponseEntity&lt;Mono&lt;Category&gt;&gt;</strong> updateCategory(@PathVariable("id") String id,CategoryRequest category){<br/>    return new ResponseEntity&lt;&gt;(this.categoryService.update(id,category), HttpStatus.OK);<br/>  }<br/><br/>}</pre>
<p>The code is quite similar to what we did before. We have used the  <kbd>@RequestBody</kbd> annotation in the method argument; otherwise, the JSON converter will not work.</p>
<p>The other important characteristic here is the <kbd>return</kbd> <span>method. </span>It returns <kbd>Mono</kbd> or <kbd>Flux</kbd>, which are parameterized types for <kbd>ResponseEntity</kbd>.</p>
<p>We can test the reactive implementation by using the command line. It will persist the <kbd>Category</kbd> object on MongoDB. Type the following command on the Terminal:</p>
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"name":"reactive"}' http://localhost:8080/api/category</strong></pre>
<p>And then, we can use the following command to check the database. Using the browser, go to <kbd>http://localhost:8080/api/category</kbd>. The following result should be presented:</p>
<div class="CDPAlignCenter CDPAlign"><img height="135" src="assets/6236f06f-38ed-46f9-9b97-68d12de94b78.png" width="469"/></div>
<p>Awesome, our reactive implementation is working as expected. Well done!!!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned a lot of Spring concepts. We have introduced you to Spring Data projects, which help developers to create data access layers as we have never seen before. We saw how easy it is to create repositories with this project.</p>
<p>Also, we presented some relatively new projects, such as Spring WebFlux, which permits developers to create modern web applications, applying the Reactive Streams foundations and reactive programming style in projects. </p>
<p>We have finished our CMS application. The application has the characteristics of a production-ready application, such as database connections, and services which have been well-designed with single responsibilities. Also, we introduced the <kbd>docker-maven-plugin</kbd>, which provides a reasonable way to create images using the <kbd>pom.xml</kbd> configurations.</p>
<p>In the next chapter, we will create a new application using the <em>Reactive Manifesto</em> based on message-driven applications. See you there. </p>
<p> </p>
<p> </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>