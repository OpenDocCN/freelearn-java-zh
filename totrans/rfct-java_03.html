<html><head></head><body>
<div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.2.1">Code Smells</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The title of this chapter should be self-explanatory or perhaps sounds disgusting, but I think it’s important to explain what is </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.4.1">meant by the term </span><em class="italic"><span class="koboSpan" id="kobo.5.1">code smell</span></em><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">The sensation is similar to when you open the refrigerator and a strange odor hits your nose, something that shouldn’t be there. </span><span class="koboSpan" id="kobo.6.3">A bad smell doesn’t necessarily indicate a problem, but it’s worth taking a look, just in case. </span><span class="koboSpan" id="kobo.6.4">There might be an issue, or there might not be, but ignoring it is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">good idea.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In our code base, it’s the same. </span><span class="koboSpan" id="kobo.8.2">A code smell is a potential problem, a situation in the code that makes us wrinkle our noses. </span><span class="koboSpan" id="kobo.8.3">They are very tangible and observable situations, recurring patterns in our projects. </span><span class="koboSpan" id="kobo.8.4">They indicate that there is or could be something that needs to be fixed as soon as possible before the problem becomes even bigger. </span><span class="koboSpan" id="kobo.8.5">Just like bad code in general, smelly code can lead to widespread inefficiency, limited code extensibility, and comprehension, as well as performance issues and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">potential bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">We need to learn how to recognize and avoid code smells; it’s much easier to produce them than one might think, given how absorbed we are in tasks and deadlines. </span><span class="koboSpan" id="kobo.10.2">The important thing is, once again, to take the time to review our work and identify potential problems, the bad smells that arise from our lines of code. </span><span class="koboSpan" id="kobo.10.3">Over time, with practice and experience, you’ll build a mental compass that points out coding pitfalls like a seasoned treasure hunter unearthing hidden gems. </span><span class="koboSpan" id="kobo.10.4">Sometimes, it will guide you even before you’ve finished crafting </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">There are plenty of code smells that have already been cataloged by our </span><em class="italic"><span class="koboSpan" id="kobo.13.1">developer ancestors</span></em><span class="koboSpan" id="kobo.14.1">; I don’t think it’s appropriate to list them all here. </span><span class="koboSpan" id="kobo.14.2">I’ll tell you about the ones that I believe are the most common to encounter and produce. </span><span class="koboSpan" id="kobo.14.3">The selection has been made based on purely subjective criteria, so feel free – in fact, I recommend it – to delve deeper into the </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Further reading</span></em><span class="koboSpan" id="kobo.16.1"> section. </span><span class="koboSpan" id="kobo.16.2">Many of these code smells are related to </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">clean code</span></strong><span class="koboSpan" id="kobo.18.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">SOLID principles</span></strong><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">If you happened to skip the previous chapter, it might be a good idea to go back and take </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">a look.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">We’ll start with duplicated code, the nuisance of almost all code bases. </span><span class="koboSpan" id="kobo.22.2">It’s often caused by the developer’s temptation to meet deadlines by resorting to the ultimate shortcut: copy and paste. </span><span class="koboSpan" id="kobo.22.3">We’ll then move on to long methods and large classes. </span><span class="koboSpan" id="kobo.22.4">It’s truly disheartening when you encounter a bug on line number </span><em class="italic"><span class="koboSpan" id="kobo.23.1">4215</span></em><span class="koboSpan" id="kobo.24.1"> of a class, not because of the bug itself, but due to the humongous number of lines the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">class contains!</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Then, I’ll show you that </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">switch</span></strong><span class="koboSpan" id="kobo.28.1"> statements can also be a problem when they are repeated; a typical situation that object-oriented programming can easily solve! </span><span class="koboSpan" id="kobo.28.2">When discussing object-oriented programming, why not represent the concepts of our domain through dedicated </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.29.1">objects rather than rely on language primitives? </span><span class="koboSpan" id="kobo.29.2">There’s an anti-pattern called </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">Primitive Obsession</span></strong><span class="koboSpan" id="kobo.31.1"> and we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">tackle it.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In addition to large classes, there are classes or methods that heavily rely on the methods of others; in other words, they just can’t mind their own business! </span><span class="koboSpan" id="kobo.33.2">We’ll explore what </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">feature envy</span></strong><span class="koboSpan" id="kobo.35.1"> methods are and how to address the potential harm they cause. </span><span class="koboSpan" id="kobo.35.2">We’ll also discuss two anti-patterns closely related to code changes and intertwined with each other: </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">divergent change</span></strong><span class="koboSpan" id="kobo.37.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Shotgun Surgery</span></strong><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Depending on where and how many changes we need to make in our code when introducing new features or making modifications in general, we may encounter one or </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Last but not least, we’ll talk about the so-called </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">god object</span></strong><span class="koboSpan" id="kobo.43.1">; this anti-pattern is a bit like that friend of yours who insists on doing everything, taking all the responsibilities; but then everyone relies on them for everything, and it’s too much for them. </span><span class="koboSpan" id="kobo.43.2">Too many responsibilities should not be assigned to a single entity, right? </span><span class="koboSpan" id="kobo.43.3">I’ll tell you what’s wrong with this and how to try to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the problem.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In this chapter, we’ll learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Duplicated code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Long methods</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.49.1">Large classes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Switches</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Primitive Obsession</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Middle Man</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Message Chains</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Feature </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">envy methods</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Divergent change</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.57.1">Shotgun Surgery</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.58.1">God object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.59.1">As mentioned before, code smells are, at the end of the day, smells. </span><span class="koboSpan" id="kobo.59.2">Just as a bad odor in the fridge doesn’t necessarily indicate a problem with your food (think of gorgonzola cheese!), a bad smell in your code doesn’t necessarily indicate a problem. </span><span class="koboSpan" id="kobo.59.3">However, there is a potential problem that is worth considering. </span><span class="koboSpan" id="kobo.59.4">In my view, the most important thing is to be aware of what we have in our code bases. </span><span class="koboSpan" id="kobo.59.5">We shouldn’t perceive every code smell as the most urgent thing in the world because it probably isn’t. </span><span class="koboSpan" id="kobo.59.6">However, it is crucial not to underestimate them because by ignoring one code smell after another, we end up with code bases that are either unmaintainable or maintainable at an excessively high cost. </span><span class="koboSpan" id="kobo.59.7">This applies not only in economic terms but also to </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">personal frustration.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.61.1">Duplicated code</span></h1>
<p><span class="koboSpan" id="kobo.62.1">Let’s start with what Martin Fowler calls the </span><em class="italic"><span class="koboSpan" id="kobo.63.1">stink parade</span></em><span class="koboSpan" id="kobo.64.1"> (I can’t help but mention it because the term cracks me up) with duplicated code. </span><span class="koboSpan" id="kobo.64.2">Duplicated code is intuitively a bad smell, and our software </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.65.1">engineer instincts will soon learn to reject it as something that harms us. </span><span class="koboSpan" id="kobo.65.2">Let’s try to list a few reasons why duplicated code is harmful to the health of our </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">code bases.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Clearly, copy-pasting code is the first thing to avoid, at least in 99% of cases. </span><span class="koboSpan" id="kobo.67.2">Taking a piece of code from one class and using it exactly as it is in another is easily avoidable. </span><span class="koboSpan" id="kobo.67.3">By pausing for a moment to reflect, it’s highly likely that we can extract a method to use instead of the duplicated code. </span><span class="koboSpan" id="kobo.67.4">Centralizing the code in this way ensures better code maintainability. </span><span class="koboSpan" id="kobo.67.5">Just think about how nightmarish it would be to maintain (e.g., fixing a bug in) every single piece of copy-pasted code scattered throughout the code base (and the scariest part is that the developers might not be aware of all the instances of duplication). </span><span class="koboSpan" id="kobo.67.6">A nightmare. </span><span class="koboSpan" id="kobo.67.7">A nightmare that is a reality in many places, </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">believe me.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Sometimes, duplicated code exists because the programmer doesn’t have a clear understanding of what they are doing, they don’t own the source, or they want to change it. </span><span class="koboSpan" id="kobo.69.2">In other words, they struggle to grasp the code they are working on. </span><span class="koboSpan" id="kobo.69.3">As mentioned before, it’s useful to do some refactoring to try to better understand the code we’re working with. </span><span class="koboSpan" id="kobo.69.4">It’s likely that even with this simple (figuratively speaking) approach, you’ll already be able to handle what you’re working on </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">more effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In general, code quality is compromised by duplicated code; the code becomes longer and sometimes less readable. </span><span class="koboSpan" id="kobo.71.2">Sometimes it’s impossible to refactor a duplicate code block, but the aim should be to decrease technical debt as much as possible. </span><span class="koboSpan" id="kobo.71.3">It helps to make your code of </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">higher quality.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The most basic form of duplicated code occurs when you come across the same expression in two </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.74.1">methods within the same class. </span><span class="koboSpan" id="kobo.74.2">To solve this, all you need to do is extract a method and call that piece of code from </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">both locations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
public void printCharacters() {
    SwCharacter darthVader = new DarthVader();
    SwCharacter obiWan = new ObiWanKenobi();
    System.out.println("Name: " + darthVader.getName());
    System.out.println("LightSaber color: " +
        darthVader.getLightSaberColor());
    System.out.println("Birth place: " +
        darthVader.getBirthPlace());
    System.out.println("Name: " + obiWan.getName());
    System.out.println("LightSaber color: " +
        obiWan.getLightSaberColor());
    System.out.println("Birth place: " +
        obiWan.getBirthPlace());
}</span></pre> <p><span class="koboSpan" id="kobo.77.1">The previous snippet presents some repetitions, as you can easily spot. </span><span class="koboSpan" id="kobo.77.2">We’ll extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">printDetails</span></strong><span class="koboSpan" id="kobo.79.1"> method and use </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">it twice:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
public void printCharacters() {
    SwCharacter darthVader = new DarthVader();
    SwCharacter obiWan = new ObiWanKenobi();
    printDetails(darthVader);
    printDetails(obiWan);
}
private static void printDetails(SwCharacter darthVader) {
    System.out.println("Name: " + darthVader.getName());
    System.out.println("LightSaber color: " +
        darthVader.getLightSaberColor());
    System.out.println("Birth place: " +
        darthVader.getBirthPlace());
}</span></pre> <p><span class="koboSpan" id="kobo.82.1">These days, IDEs are </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.83.1">perfectly capable of flagging duplicate code (for example, in IntelliJ IDEA, it’s a built-in feature) and suggesting a small refactoring to extract the method. </span><span class="koboSpan" id="kobo.83.2">We will discuss how to get the most out of IDEs and other tools later in </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">We’ll now move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">long methods.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.87.1">Long methods</span></h1>
<p><span class="koboSpan" id="kobo.88.1">This is a very typical code smell, very sneaky, and often underestimated. </span><span class="koboSpan" id="kobo.88.2">Even though it may seem </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.89.1">like a trivial topic to address, I’d like to share </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">some thoughts.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Code is read much more than it’s written, so taking a little extra time to shorten a method can pay off big time. </span><span class="koboSpan" id="kobo.91.2">When you have to modify a long method, you have to read and comprehend every single line of code to make the change safely. </span><span class="koboSpan" id="kobo.91.3">In this case, we’re burdened with loading all the work this method does into our brains just to understand what’s happening, let alone have the ability to modify any part </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Long code is </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.94.1">very likely doing more than one thing: according to the </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.96.1">, a method should ideally focus on doing just one thing. </span><span class="koboSpan" id="kobo.96.2">It’s almost impossible to achieve that when you have so many lines </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">It would be useful to know when “long” becomes “too long.” </span><span class="koboSpan" id="kobo.98.2">10 lines? </span><span class="koboSpan" id="kobo.98.3">20? </span><span class="koboSpan" id="kobo.98.4">100? </span><span class="koboSpan" id="kobo.98.5">It’s hard to establish a fixed rule. </span><span class="koboSpan" id="kobo.98.6">It’s a bit like saying when a cake is too sweet or when pasta is too salty; we instinctively recognize the excesses, but we probably couldn’t agree on the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">exact numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">My advice here is to follow your gut and, above all, reach a consensus within the team. </span><span class="koboSpan" id="kobo.100.2">For example, you can decide that 20 lines are the maximum limit or that it shouldn’t exceed one screen height (of course, it depends on screen resolution, font size, etc.). </span><span class="koboSpan" id="kobo.100.3">Another cool </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.101.1">thing would be to use standards for formatting, even through the use of automatic tools that take care of it; more on this later in the book. </span><span class="koboSpan" id="kobo.101.2">In short, it depends. </span><span class="koboSpan" id="kobo.101.3">It could also be the case that a method is long but only contains configurations, things that are very readable and don’t require much effort to understand. </span><span class="koboSpan" id="kobo.101.4">In that case, you might even not care </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">about it.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">Furthermore, I want to bring up a heuristic tip from Martin Fowler’s </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Refactoring</span></em><span class="koboSpan" id="kobo.105.1">: whenever you feel the need to insert a comment in the code to explain it, write a method instead. </span><span class="koboSpan" id="kobo.105.2">The method will contain the code you intended to comment on, but the name of the function itself will explain the intention behind the code, rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">its functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">The following are some small tricks that help in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">long methods.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.109.1">Replace temporary variables with query methods</span></h2>
<p><span class="koboSpan" id="kobo.110.1">Most of </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.111.1">the time, extracting a method or a function from your long method should do the trick; look for parts </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.112.1">of the function that go well together </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.113.1">and create a fresh one. </span><span class="koboSpan" id="kobo.113.2">Sometimes you have a function with many parameters and temporary variables and they could become obstacles to the extraction process; extracting a function would lead to passing a lot of parameters to the extracted method, and that would be as unreadable as before. </span><span class="koboSpan" id="kobo.113.3">So, it could be useful to replace those temporary variables with a </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">query function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
Double basePrice = this.getCostPerKm() *
    this.getDistanceInKm();
if (passengerIsChild()) {
    return basePrice * 0.5;
} else {
    return basePrice;
}</span></pre> <p><span class="koboSpan" id="kobo.116.1">In this </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.117.1">code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">basePrice</span></strong><span class="koboSpan" id="kobo.119.1"> variable is used to store the result of a pricing operation and then again to calculate </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.120.1">the final price, which is discounted by 50% for child passengers. </span><span class="koboSpan" id="kobo.120.2">It could be a good idea to remove the temporary variable and inline the calculation, writing a method (query function) </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">calculateBasePrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
if(passengerIsChild()){
    return calculateBasePr</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.125.1">ice() * 0.5;
}else{
    return calculateBasePrice();
}</span></pre> <p><span class="koboSpan" id="kobo.126.1">In the next section, we’ll look at </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">parameter objects.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.128.1">Parameter object</span></h2>
<p><span class="koboSpan" id="kobo.129.1">It could </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.130.1">also happen that you have functions or methods with </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.131.1">a long or “repeated” signature, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">calculateFinalPrice</span></strong><span class="koboSpan" id="kobo.133.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">discountPrice</span></strong><span class="koboSpan" id="kobo.135.1"> methods in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
public Double calculateFinalPrice(Double amount, String
    currency){ ... </span><span class="koboSpan" id="kobo.137.2">}
public Double discountPrice(Double amount, String
</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.138.1">    currency){ ... </span><span class="koboSpan" id="kobo.138.2">}</span></pre> <p><span class="koboSpan" id="kobo.139.1">You can see that we have a couple of methods with the same signature, repeated. </span><span class="koboSpan" id="kobo.139.2">It’s also crucial to notice that in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">amount</span></strong><span class="koboSpan" id="kobo.141.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">currency</span></strong><span class="koboSpan" id="kobo.143.1"> parameters must always go together, as they represent a price. </span><span class="koboSpan" id="kobo.143.2">A cool solution is to pass to these methods a “parameter object” or a “request object” (I’ve heard it being called in many ways): that is, a complex object representing all the needed parameters that make sense together. </span><span class="koboSpan" id="kobo.143.3">Given that </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.144.1">amount and currency represent a price, why don’t </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.145.1">we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Price</span></strong><span class="koboSpan" id="kobo.147.1"> class? </span><span class="koboSpan" id="kobo.147.2">We do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
public Double calculate</span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.150.1">FinalPrice(Price price){ ... </span><span class="koboSpan" id="kobo.150.2">}
public Double dis</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.151.1">countPrice(Price price){ ... </span><span class="koboSpan" id="kobo.151.2">}
class Price {
    private Double amount;
    private String currency;
}</span></pre> <p><span class="koboSpan" id="kobo.152.1">In the next section, let’s replace a function/method with </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">a command.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.154.1">Replace a function or method with a command</span></h2>
<p><span class="koboSpan" id="kobo.155.1">If you’ve tried to extract functions and create parameter objects but you’re still left with an excessive </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.156.1">number of temporary </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.157.1">variables and parameters, another thing you can do is to replace the function with a command. </span><span class="koboSpan" id="kobo.157.2">Let’s suppose you have the following method, which takes a lot of parameters and is </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">very long:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
public Double calculatePrice(Double basePrice, Integer
    adults, Integer children, Integer infants) {
    Double calculatedPrice = 0.0;
    // long body...
</span><span class="koboSpan" id="kobo.159.2">    return calculatedPrice;
}</span></pre> <p><span class="koboSpan" id="kobo.160.1">If we implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">PriceCalculator</span></strong><span class="koboSpan" id="kobo.162.1"> object, everything becomes clearer; in this way, you have replaced a function with a command. </span><span class="koboSpan" id="kobo.162.2">All the parameters are passed at the beginning, of the constructor. </span><span class="koboSpan" id="kobo.162.3">You can reuse this component by passing all the parameters </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.163.1">every time (and actually, this makes your component more reusable). </span><span class="koboSpan" id="kobo.163.2">The logic of the method is executed </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.164.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">calculatePrice()</span></strong><span class="koboSpan" id="kobo.166.1"> method, which doesn’t take any parameters; readability is </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">also improved:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
class PriceCalculator {
    private final Double basePrice;
    private final Integer adults;
    private final Integer children;
    private final Integer infants;
    public PriceCalculator(Double basePrice, Integer
        adults, Integer children, Integer infants) {
        this.basePrice = basePrice;
        this.adults = adults;
        this.children = children;
        this.infants = infants;
    }
    public Double calculatePrice() {
        Double calculatedPrice = 0.0;
        // long body...
</span><span class="koboSpan" id="kobo.168.2">        return calculatedPrice;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.169.1">When dealing with code extraction, which is to be put in a different method, it can be hard, sometimes, just to identify the code you want to separate. </span><span class="koboSpan" id="kobo.169.2">How can you spot the chunks of </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.170.1">code to extract? </span><span class="koboSpan" id="kobo.170.2">A handy </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.171.1">approach is to check for comments. </span><span class="koboSpan" id="kobo.171.2">They often indicate these types of meaningful sections. </span><span class="koboSpan" id="kobo.171.3">If you come across a block of code with a comment explaining its purpose, you can replace it with a method named after the comment (and then you can decide whether to keep the comments or not). </span><span class="koboSpan" id="kobo.171.4">Even a single line is worth extracting if it requires </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">an explanation.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.173.1">Decompose conditionals</span></h2>
<p><span class="koboSpan" id="kobo.174.1">There are also other indicators of code that need to be extracted; for instance, conditionals </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.175.1">and loops also provide useful hints for extractions. </span><span class="koboSpan" id="kobo.175.2">If you </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.176.1">have a conditional expression, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">if</span></strong><span class="koboSpan" id="kobo.178.1"> in the following snippet, it can be handy to apply the “decompose </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">conditional” technique:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
if (1 &lt;= rowNumber &amp;&amp; rowNumber &lt;= 30) {
    price = basePrice * plane.getFirstRowsCharge();
} else {
    price = basePrice * plane.getStandardCharge();
}</span></pre> <p><span class="koboSpan" id="kobo.181.1">This code snippet calculates the price of a plane seat depending on the row numbers (it probably doesn’t make any sense, but it’s useful for this example!). </span><span class="koboSpan" id="kobo.181.2">If the seat is located in the first 30 lines, we have to pay a different fare. </span><span class="koboSpan" id="kobo.181.3">There is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">if</span></strong><span class="koboSpan" id="kobo.183.1">, which is quite simple here, but you have to imagine this in a real-world scenario, where conditions can be much more complex and involve many more parameters and objects. </span><span class="koboSpan" id="kobo.183.2">In the refactored snippet, we isolated some logic, including the condition, to improve readability and potentially reuse the code (and potentially, in the future, you could externalize the condition calculations, by doing requests to third-party systems or even </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">rule engines):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.185.1">
if (firstRows()) {
    price = firstRowsPrice();
} else {
    price = standardPrice();
}</span></pre> <p><span class="koboSpan" id="kobo.186.1">But conditions are not only </span><em class="italic"><span class="koboSpan" id="kobo.187.1">ifs</span></em><span class="koboSpan" id="kobo.188.1">, but also </span><em class="italic"><span class="koboSpan" id="kobo.189.1">switches</span></em><span class="koboSpan" id="kobo.190.1"> (which are, in a way, </span><em class="italic"><span class="koboSpan" id="kobo.191.1">ifs</span></em><span class="koboSpan" id="kobo.192.1"> in disguise). </span><span class="koboSpan" id="kobo.192.2">If you encounter a lengthy switch statement, transform each case into a separate function call using the “extract function” approach, which we covered in the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">preceding section.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.194.1">Split loops</span></h2>
<p><span class="koboSpan" id="kobo.195.1">Sometimes, loops can also become a problem; for instance, it is common to have a loop body that does </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.196.1">more than one thing. </span><span class="koboSpan" id="kobo.196.2">In this case, you should create a distinct method for the loop itself and the code within it. </span><span class="koboSpan" id="kobo.196.3">If you struggle to find a suitable </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.197.1">name for the extracted loop, it might be because it’s performing two distinct tasks. </span><span class="koboSpan" id="kobo.197.2">In such cases, don’t hesitate to use the following technique, called </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">split loop</span></strong><span class="koboSpan" id="kobo.199.1">, to separate the tasks into </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">different parts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.201.1">
Integer totalBaggageNumber = 0;
Double totalPrice = 0.0;
for (Passenger passenger : passengers) {
    totalBaggageNumber += passenger.getBaggageNumber();
    totalPrice += passenger.getPrice();
}</span></pre> <p><span class="koboSpan" id="kobo.202.1">The previous snippet is made of a very basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">for</span></strong><span class="koboSpan" id="kobo.204.1"> loop. </span><span class="koboSpan" id="kobo.204.2">Even in these two lines, a problem is hidden! </span><span class="koboSpan" id="kobo.204.3">In fact, you have two different things done in the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">for</span></strong><span class="koboSpan" id="kobo.206.1"> loop. </span><span class="koboSpan" id="kobo.206.2">I can already hear you saying, “</span><em class="italic"><span class="koboSpan" id="kobo.207.1">Come on, it’s just two lines!</span></em><span class="koboSpan" id="kobo.208.1">” but – again – I’m simplifying things as much as possible here. </span><span class="koboSpan" id="kobo.208.2">Reality is often more complex, but the problem is the same. </span><span class="koboSpan" id="kobo.208.3">Refactoring the code by splitting the loop makes the code clearer and more reusable; should you move part of the logic elsewhere, now it should be simpler (we could also use Java streams, but we want to keep it as simple </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">as possible):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
for (Passenger passenger : passengers) {
    totalBaggageNumber += passenger.getBaggageNumber();
}
for (Passenger passenger : passengers) {
    totalPrice += passenger.getPrice();
}</span></pre> <p><span class="koboSpan" id="kobo.211.1">Lots of programmers don’t like this refactoring because it makes you run the loop twice. </span><span class="koboSpan" id="kobo.211.2">But please </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.212.1">remember that we’re separating refactoring from optimization. </span><span class="koboSpan" id="kobo.212.2">First, get your code nice and clean, then you can optimize it. </span><span class="koboSpan" id="kobo.212.3">If looping through </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.213.1">a list is causing a slowdown, you can easily combine the loops again. </span><span class="koboSpan" id="kobo.213.2">But honestly, going through a big list is usually not the real issue, and splitting the loops can actually open up opportunities for </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">better optimizations.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.215.1">Large classes</span></h1>
<p><span class="koboSpan" id="kobo.216.1">This is another very common smell. </span><span class="koboSpan" id="kobo.216.2">How many times have you found yourself working on classes with </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.217.1">thousands of lines? </span><span class="koboSpan" id="kobo.217.2">It’s nobody’s fault, it’s just that classes start small and, very understandably, gradually end up incorporating more information and functionality. </span><span class="koboSpan" id="kobo.217.3">There’s nothing wrong with that; the important thing is to realize it and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">refactor it.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">A practical way to notice that a class is too big is when there are too many fields (instance variables). </span><span class="koboSpan" id="kobo.219.2">If there are too many fields in a class, it’s likely doing too many things; besides having too many responsibilities, often in this case, code duplication becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">a problem.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">You can create (extract) a new class to group several variables together. </span><span class="koboSpan" id="kobo.221.2">Pick the variables that naturally go hand in hand and put them in a component. </span><span class="koboSpan" id="kobo.221.3">For instance, if you see a bunch of parameters called something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">priceAmount</span></strong><span class="koboSpan" id="kobo.223.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">priceCurrency</span></strong><span class="koboSpan" id="kobo.225.1">, they are probably meant to be part of the same component. </span><span class="koboSpan" id="kobo.225.2">In general, if you notice common prefixes or suffixes among a subset of variables in a class, it indicates the possibility of creating </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">a component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
class Order {
    private String name;
    private String surname;
    private String streetName;
    private String streetType;
    private String streetDirection;
    private Double priceAmount;
    private String priceCurrency;
   //constructor and getter methods
}</span></pre> <p><span class="koboSpan" id="kobo.228.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Order</span></strong><span class="koboSpan" id="kobo.230.1"> class contains </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.231.1">numerous fields that each represent distinct properties of the order. </span><span class="koboSpan" id="kobo.231.2">However, if you look closer, it becomes evident that some of these fields can be logically “grouped” together, as they belong to specific aspects of an order property. </span><span class="koboSpan" id="kobo.231.3">For instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">name</span></strong><span class="koboSpan" id="kobo.233.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">surname</span></strong><span class="koboSpan" id="kobo.235.1"> fields can be seen as representing the buyer’s information (to simplify the concept). </span><span class="koboSpan" id="kobo.235.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">streetName</span></strong><span class="koboSpan" id="kobo.237.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">streetType</span></strong><span class="koboSpan" id="kobo.239.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">streetDirection</span></strong><span class="koboSpan" id="kobo.241.1"> fields are related to the shipping address for the order, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">priceAmount</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">priceCurrency</span></strong><span class="koboSpan" id="kobo.245.1"> provide information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">selling price.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">Given these insights, it is possible to restructure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Order</span></strong><span class="koboSpan" id="kobo.249.1"> class by grouping certain fields to create new </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">entities</span></strong><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">These entities can (</span><em class="italic"><span class="koboSpan" id="kobo.252.1">should</span></em><span class="koboSpan" id="kobo.253.1">) be reused effectively throughout the project, enhancing code organization </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">and maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">The restructured </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Order</span></strong><span class="koboSpan" id="kobo.257.1"> class should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
class Order {
    private User orderBuyer;
    private Address shippingAddress;
    private Price orderPrice;
   //constructor and getter methods
}</span></pre> <p><span class="koboSpan" id="kobo.260.1">Of course, it should </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.261.1">have all of the previous fields “distributed” among </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">different classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
class User {
    private String name;
    private String surname;
    //constructor and getter methods
}
class Address {
    private String streetName;
    private String streetType;
    private String streetDirection;
    //constructor and getter methods
}
class Price {
    private Double priceAmount;
    private String priceCurrency;
    //constructor and getter methods
}</span></pre> <p><span class="koboSpan" id="kobo.264.1">If using inheritance </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.265.1">makes sense for the component, you’ll likely find that techniques such as extracting a superclass or replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">type</span></strong><span class="koboSpan" id="kobo.267.1"> with subclasses (also known as extracting a subclass) are often simpler to apply. </span><span class="koboSpan" id="kobo.267.2">The following is a very common situation; we have a class that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">type</span></strong><span class="koboSpan" id="kobo.269.1"> parameter because, depending on its value, the class has to behave </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">slightly differently:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
public Transport createTransportation(String name, String
    type){
    return new Transport(name, type);
}</span></pre> <p><span class="koboSpan" id="kobo.272.1">I bet some instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">if</span></strong><span class="koboSpan" id="kobo.274.1"> are hiding inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Transport</span></strong><span class="koboSpan" id="kobo.276.1"> class! </span><span class="koboSpan" id="kobo.276.2">But object-oriented programming comes with inheritance, so why don’t we use it? </span><span class="koboSpan" id="kobo.276.3">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
public Transport createTransport(String name, TransportType
    type) {
    switch (type) {
        case PLANE -&gt; {
            return new Plane(name);
        }
        case TRAIN -&gt; {
            return new Train(name);
        }
        case BUS -&gt; {
            return new Bus(name);
        }
    }
    return null;
}</span></pre> <p><span class="koboSpan" id="kobo.279.1">In this refactored code snippet, we have two major improvements. </span><span class="koboSpan" id="kobo.279.2">We changed the class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">type</span></strong><span class="koboSpan" id="kobo.281.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">String</span></strong><span class="koboSpan" id="kobo.283.1"> to an enum called </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">TransportType</span></strong><span class="koboSpan" id="kobo.285.1">; this allows us to perform the subsequent switch statement in a safer way because we’ll be warned (by an IDE, likely) if we are not considering some of the possible values of type. </span><span class="koboSpan" id="kobo.285.2">Then, we created a specific class for each type of transport, avoiding mixing things up; of course, all of these classes will implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">same interface.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">Aside from </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.288.1">having a bunch of instance parameters, a class that is too large is generally not good; it’s a breeding ground for duplicated code, unclear code, confusion, and despair. </span><span class="koboSpan" id="kobo.288.2">A simple, yet effective, approach to start with is to eliminate repetitions within the class itself. </span><span class="koboSpan" id="kobo.288.3">Simply put, you can look for code that makes sense to group together and write standalone methods for them. </span><span class="koboSpan" id="kobo.288.4">Shorten the methods within a very large class. </span><span class="koboSpan" id="kobo.288.5">Maybe the number of methods will increase, but you’ll likely realize that you can move some of them to a separate class, if those methods make sense together and concern a single aspect. </span><span class="koboSpan" id="kobo.288.6">In very large classes, it’s very common to have duplicated code or similar repetitions. </span><span class="koboSpan" id="kobo.288.7">At that point, from a 100-line method, we can extract two or three 10-line methods, with a few extra lines to invoke them. </span><span class="koboSpan" id="kobo.288.8">The most difficult part is probably understanding how to split the code. </span><span class="koboSpan" id="kobo.288.9">Here’s a very simple tip that often works: the </span><em class="italic"><span class="koboSpan" id="kobo.289.1">clients</span></em><span class="koboSpan" id="kobo.290.1"> of such a class can often provide valuable hints for breaking it down. </span><span class="koboSpan" id="kobo.290.2">Take a closer look and perform some static analysis of the code (that is, open the code and go through it. </span><span class="koboSpan" id="kobo.290.3">There are </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.291.1">also automatic tools for doing this; we’ll meet them later) to see how clients utilize only a portion of the class’s features. </span><span class="koboSpan" id="kobo.291.2">Each distinct subset of features can potentially become a </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">separate class.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.293.1">Switches</span></h1>
<p><span class="koboSpan" id="kobo.294.1">To put it simply, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">switch</span></strong><span class="koboSpan" id="kobo.296.1"> statement itself is not problematic per se. </span><span class="koboSpan" id="kobo.296.2">In fact, we find it quite elegant </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.297.1">and self-explanatory. </span><span class="koboSpan" id="kobo.297.2">Many programming languages even offer more advanced forms of </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">switch</span></strong><span class="koboSpan" id="kobo.299.1"> statements that can use more complex code as their foundation. </span><span class="koboSpan" id="kobo.299.2">They can simplify code and replace ugly nested ifs. </span><span class="koboSpan" id="kobo.299.3">I must admit, we have a soft spot for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.301.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">However, the issue arises when we encounter </span><em class="italic"><span class="koboSpan" id="kobo.303.1">repeated</span></em><span class="koboSpan" id="kobo.304.1"> switches in object-oriented programming. </span><span class="koboSpan" id="kobo.304.2">We consider this to be problematic for several reasons. </span><span class="koboSpan" id="kobo.304.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">switch</span></strong><span class="koboSpan" id="kobo.306.1"> statements </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.307.1">violate the </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">open-closed principle</span></strong><span class="koboSpan" id="kobo.309.1"> because every time a developer needs to add a new type, they must insert a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">case</span></strong><span class="koboSpan" id="kobo.311.1"> statement in each section. </span><span class="koboSpan" id="kobo.311.2">This leads to modifying existing code, which goes against the principle. </span><span class="koboSpan" id="kobo.311.3">Furthermore, switches can be challenging to maintain. </span><span class="koboSpan" id="kobo.311.4">As new requirements emerge, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">switch</span></strong><span class="koboSpan" id="kobo.313.1"> statements can grow in complexity, making the code harder to manage. </span><span class="koboSpan" id="kobo.313.2">Another issue with switches is the potential for redundant code in </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">certain cases.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The solution in this case is quite simple – </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">use polymorphism:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
public String printLightSaberColor(SwCharacter character){
   switch (character.getName()) {
       case "LUKE" -&gt; {
           return "GREEN";
       }
       case "OBI-WAN" -&gt; {
           return "BLUE";
       }
       case "DARTH VADER" -&gt; {
           return "RED";
       }
   }
}</span></pre> <p><span class="koboSpan" id="kobo.318.1">I assume you’re already familiar with these characters and you know what a </span><em class="italic"><span class="koboSpan" id="kobo.319.1">lightsaber</span></em><span class="koboSpan" id="kobo.320.1"> is. </span><span class="koboSpan" id="kobo.320.2">If not, I highly recommend Googling them and watching those movies right away. </span><span class="koboSpan" id="kobo.320.3">The previous piece of code </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.321.1">could be refactored into the following classes/methods, in which we designed an abstract class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">SwCharacter</span></strong><span class="koboSpan" id="kobo.323.1">, that will be extended for each specific character. </span><span class="koboSpan" id="kobo.323.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">printLightSaberColor</span></strong><span class="koboSpan" id="kobo.325.1"> method will take a “generic” </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">SwCharacter</span></strong><span class="koboSpan" id="kobo.327.1"> and call the relative implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">getLightSaberColor</span></strong><span class="koboSpan" id="kobo.329.1"> method. </span><span class="koboSpan" id="kobo.329.2">In the following code, we’re going to omit some boilerplate code, such as constructors or other getters, </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for simplicity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
public St</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.332.1">ring printLightSaberColor(SwCharacter character){
    return character.getLightSaberColor();
}
public abstract class SwCharacter {
    private final String name;
    protected SwCharacter(String name) {
        this.name = name;
    }
    public abstract String getLightSaberColor();
}
public class LukeSkywalker extends SwCharacter {
    protected LukeSkywalker() {
        super("Luke Skywalker");
    }
    @Override
    public String getLightSaberColor() {
        return "GREEN";
    }
}
public class ObiWanKenobi extends SwCharacter{
    public ObiWanKenobi() {
        super("Obi-Wan Kenobi");
    }
    @Override
    public String getLightSaberColor() {
        return "BLUE";
    }
}
public class DarthVader extends SwCharacter{
    public DarthVader(String name) {
        super(name);
    }
    @Override
    public String getLightSaberColor() {
        return "RED";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.333.1">It is worth </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.334.1">mentioning that in this particular case, we increased the number of code lines. </span><span class="koboSpan" id="kobo.334.2">However, in our opinion, this is highly acceptable as we improved readability. </span><span class="koboSpan" id="kobo.334.3">In the examples I’ve given you, I tried to keep things simple by using basic stuff such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">int</span></strong><span class="koboSpan" id="kobo.336.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">String</span></strong><span class="koboSpan" id="kobo.338.1"> most of the time. </span><span class="koboSpan" id="kobo.338.2">But that’s not always the best approach. </span><span class="koboSpan" id="kobo.338.3">It depends. </span><span class="koboSpan" id="kobo.338.4">Sometimes, relying too much on the language’s primitive types can lead to a code smell called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.339.1">Primitive Obsession</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.341.1">Primitive Obsession</span></h1>
<p><span class="koboSpan" id="kobo.342.1">To understand what Primitive Obsession is and how to deal with it, let’s remember what primitive types </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.343.1">are in a programming language. </span><span class="koboSpan" id="kobo.343.2">Primitive types are like the ready-made types that come with the language. </span><span class="koboSpan" id="kobo.343.3">You can think of them as straight from the manufacturer. </span><span class="koboSpan" id="kobo.343.4">Each language has its own set of primitive types, and since we’re talking about Java here, let’s focus on how it works </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">in Java.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">In Java, a </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">primitive type</span></strong><span class="koboSpan" id="kobo.347.1"> is a type </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.348.1">that is already defined in the language and has a special keyword associated with it. </span><span class="koboSpan" id="kobo.348.2">Primitive values are independent of each other, they don’t share their state. </span><span class="koboSpan" id="kobo.348.3">Java supports eight primitive data types: byte, short, int, long, float, double, Boolean, and char. </span><span class="koboSpan" id="kobo.348.4">Along with these eight types, Java also provides special support for strings through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">java.lang.String</span></strong><span class="koboSpan" id="kobo.350.1"> class. </span><span class="koboSpan" id="kobo.350.2">Although the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">String</span></strong><span class="koboSpan" id="kobo.352.1"> class is not technically a primitive data type, it’s given special treatment in the language, so you might consider it </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">as one.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Primitive Obsession is when the code becomes too dependent on basic data types. </span><span class="koboSpan" id="kobo.354.2">It means that a simple value takes charge of the class logic and lacks type safety. </span><span class="koboSpan" id="kobo.354.3">In simpler terms, it’s a bad habit of using basic types to represent an object in a specific area </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">of focus.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Let’s take the example of representing a website’s URL. </span><span class="koboSpan" id="kobo.356.2">Usually, we store it as a string. </span><span class="koboSpan" id="kobo.356.3">However, the problem arises because a URL has more details and distinct characteristics than just being a simple string. </span><span class="koboSpan" id="kobo.356.4">It includes elements such as the scheme, query parameters, and protocol. </span><span class="koboSpan" id="kobo.356.5">When we store it as a string, we lose the ability to directly access these URL-specific components (the essential parts of the URL) without writing additional code. </span><span class="koboSpan" id="kobo.356.6">We could use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">java.net.URL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1"> instead.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Strings are often breeding grounds for this kind of issue. </span><span class="koboSpan" id="kobo.359.2">Take a telephone number, for example. </span><span class="koboSpan" id="kobo.359.3">It’s more than just a random assortment of characters. </span><span class="koboSpan" id="kobo.359.4">In many cases, a proper data type can provide consistent display logic when it needs to be shown in a user interface. </span><span class="koboSpan" id="kobo.359.5">Representing such types as strings creates a problem so common that they are sometimes referred to as </span><em class="italic"><span class="koboSpan" id="kobo.360.1">stringly </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">typed</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1"> variables.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">If you think </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.364.1">about it, it is quite simple to solve the problem; it is necessary to replace the primitive(s) with objects. </span><span class="koboSpan" id="kobo.364.2">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
String url = "https://www.packtpub.com/";
String protocol = extractProtocol(url);
String host = extractHost(url);</span></pre> <p><span class="koboSpan" id="kobo.367.1">This can become </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
URL url = new URL("https://www.packtpub.com/");
String protocol = url.getProtocol();
String host = url.getHost();</span></pre> <p><span class="koboSpan" id="kobo.370.1">If you’re curious about how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">URL</span></strong><span class="koboSpan" id="kobo.372.1"> class works, look at its documentation (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">java.net.URL</span></strong><span class="koboSpan" id="kobo.374.1"> class is included in the Standard </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">Java Library).</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">If you have a group of primitives that can go together, you can group them by extracting a class, like in the address example we covered in the </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Large </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">classes</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Now that we’ve dealt with Primitive Obsession, let’s tackle all those classes that have little desire to work and make others do all the work. </span><span class="koboSpan" id="kobo.380.2">This was just a playful way to say that we will talk about a smell called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.381.1">middle man</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.383.1">Middle man</span></h1>
<p><span class="koboSpan" id="kobo.384.1">The middle man is a code </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.385.1">smell that occurs when we have a class or, in general, an object that does only one thing, and that thing is... </span><span class="koboSpan" id="kobo.385.2">delegating the work to someone else. </span><span class="koboSpan" id="kobo.385.3">We are not suggesting that a class should have only one method to be considered a "middle man". </span><span class="koboSpan" id="kobo.385.4">Rather, each of its methods should only invoke others. </span><span class="koboSpan" id="kobo.385.5">So, the question arises spontaneously: why keep a class in our codebase that does nothing? </span><span class="koboSpan" id="kobo.385.6">In fact, there is (almost never) a reason. </span><span class="koboSpan" id="kobo.385.7">Let’s delete this class or method and ensure that the client calls the “destination” directly. </span><span class="koboSpan" id="kobo.385.8">This way, we will eliminate unnecessary complexity and ensure that, when we modify or add features to the destination objects, we are not forced to also modify our </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">middle man.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">To give an </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.388.1">example, suppose we have a class structured </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
public class Person {
    private Address address;
    public City getCity() {
        return address.getCity();
    }
    public Address getAddress() {
        return address;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.391.1">A “client” method would use it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">following way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
Person person = getPerson();
var person = person.getCity();</span></pre> <p><span class="koboSpan" id="kobo.394.1">You can easily notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">getCity()</span></strong><span class="koboSpan" id="kobo.396.1"> method serves solely as a proxy to the other class. </span><span class="koboSpan" id="kobo.396.2">So why not use the other class directly? </span><span class="koboSpan" id="kobo.396.3">Our example would </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">then become:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
var city = person.getAddress().getCity();</span></pre> <p><span class="koboSpan" id="kobo.399.1">And so, we can eliminate the middle man composed of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">getCity()</span></strong><span class="koboSpan" id="kobo.401.1"> method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Person</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">However, this refactoring can paradoxically lead to another code smell, the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">message chain!</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.406.1">Message chains</span></h1>
<p><span class="koboSpan" id="kobo.407.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">message chain</span></strong><span class="koboSpan" id="kobo.409.1"> occurs when </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.410.1">a client requests an object, which then requests another object, and so on. </span><span class="koboSpan" id="kobo.410.2">This makes all the objects dependent on the structure of the called objects, and a change in these objects would necessarily impact the entire chain of calls, at every point where they are made. </span><span class="koboSpan" id="kobo.410.3">Building upon the example from the previous section, we could have </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">something like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
var cityName = person.getLocation().getAddress().getCity().getName();</span></pre> <p><span class="koboSpan" id="kobo.413.1">The solution is to hide the “delegate”, that is the method calling the other one(s). </span><span class="koboSpan" id="kobo.413.2">We could transform the previous example </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">into this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
var cityName = person.getCityName();</span></pre> <p><span class="koboSpan" id="kobo.416.1">Where the chain of calls is hidden in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">getCityName()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Taken to the extreme, however, this refactoring can lead to the middle man smell! </span><span class="koboSpan" id="kobo.419.2">Have we ended up in a time loop like Christopher Nolan? </span><span class="koboSpan" id="kobo.419.3">The truth is, it depends. </span><span class="koboSpan" id="kobo.419.4">These refactorings must indeed be properly weighted, attempting to choose the lesser evil (also considering the possibility that perhaps the class modeling itself is flawed and might require changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">some way).</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Opting for middle man instead of message chains offers the advantage of requiring fewer mocks during unit testing. </span><span class="koboSpan" id="kobo.421.2">Testing classes becomes challenging when you have to provide mocks not just for their immediate and indirect dependencies. </span><span class="koboSpan" id="kobo.421.3">Additionally, it aids in the separation of concerns. </span><span class="koboSpan" id="kobo.421.4">A code that possesses an </span><em class="italic"><span class="koboSpan" id="kobo.422.1">A</span></em><span class="koboSpan" id="kobo.423.1"> component and requires a </span><em class="italic"><span class="koboSpan" id="kobo.424.1">C</span></em><span class="koboSpan" id="kobo.425.1"> component should ideally remain unaware of the involvement of a </span><em class="italic"><span class="koboSpan" id="kobo.426.1">B</span></em><span class="koboSpan" id="kobo.427.1"> component. </span><span class="koboSpan" id="kobo.427.2">This contributes to better modularity. </span><span class="koboSpan" id="kobo.427.3">While the primary argument for message chains is the avoidance of writing boilerplate in the middle, and there might be cases where it makes sense, the general guideline should lean towards preferring the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">middle man.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Choosing middle man over message chains aligns with the principles of the Law of Demeter, often summarized as “only talk to your direct dependencies.” </span><span class="koboSpan" id="kobo.429.2">This guideline encapsulates a design philosophy advocating for encapsulation and reduced coupling in object-oriented systems. </span><span class="koboSpan" id="kobo.429.3">We talked about the Law of Demeter in </span><a href="B20912_02.xhtml#_idTextAnchor042"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.430.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.431.1">.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.432.1">Feature envy methods</span></h1>
<p><span class="koboSpan" id="kobo.433.1">When we try to break down our code base into components that make sense based on our use case and domain, we’re basically dividing the code into </span><em class="italic"><span class="koboSpan" id="kobo.434.1">zones</span></em><span class="koboSpan" id="kobo.435.1">. </span><span class="koboSpan" id="kobo.435.2">One of the key things we </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.436.1">need to be careful about is maximizing interactions within the zones and, conversely, minimizing interactions between different zones. </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">Feature envy</span></strong><span class="koboSpan" id="kobo.438.1"> is like a warning sign in the code, describing when an object accesses another object’s fields to perform an operation instead of simply instructing the object on what </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">to do.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">As a simple example, let’s consider a method that calculates a price based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">payment request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
public Double calculatePrice(PaymentRequest paymentRequest);</span></pre> <p><span class="koboSpan" id="kobo.443.1">Everything seems fine until we realize that we need the order and some user information to calculate the price. </span><span class="koboSpan" id="kobo.443.2">That’s when we start writing its implementation and, for instance, we must retrieve the order related to the payment request; in the first lines of the method, we’ll write something like </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
Order order = orderRepository.findById
    (paymentRequest.getOrderId());</span></pre> <p><span class="koboSpan" id="kobo.446.1">Very likely, a user will be needed too. </span><span class="koboSpan" id="kobo.446.2">So, after fetching the order, we’ll probably add a line in which we also retrieve the user, because we need some information </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">about them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
User user = userRepositoty.findById
    (paymentRequest.getUserId());</span></pre> <p><span class="koboSpan" id="kobo.449.1">From these objects, we’re going to take some specific properties that we need to complete the payment. </span><span class="koboSpan" id="kobo.449.2">For instance, we’ll write something like </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
order.getItems();
order.getOrderDate();
user.getLevel();</span></pre> <p><span class="koboSpan" id="kobo.452.1">Once again, we’re faced with a ton of finder/getter methods being called. </span><span class="koboSpan" id="kobo.452.2">It’s very common to find methods invoking tons of getter methods of other objects to retrieve or calculate some value. </span><span class="koboSpan" id="kobo.452.3">In this case, it’s also likely that your bean, your Java class, will have a lot of </span><em class="italic"><span class="koboSpan" id="kobo.453.1">collaborators</span></em><span class="koboSpan" id="kobo.454.1">, that is, a lot of other classes injected in yours through </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">In the most basic scenario, you can simply transfer the method you’re using from one class to another (and modify its name, if necessary). </span><span class="koboSpan" id="kobo.456.2">If only a portion of the method requires access to another object’s data, you can extract that specific part into a separate method. </span><span class="koboSpan" id="kobo.456.3">However, not all cases are straightforward; sometimes, a function relies on features from multiple modules, so it becomes a question of which module it should belong to. </span><span class="koboSpan" id="kobo.456.4">A rule of thumb (as suggested by Martin Fowler) is to determine the module that </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.457.1">possesses most of the data and place the function there. </span><span class="koboSpan" id="kobo.457.2">This process is often facilitated by extracting methods to break down the function into smaller pieces that can be placed in </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">different locations.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Sometimes, even when this guideline is not applicable, you have the option to use the Strategy or Visitor patterns described in the book by the </span><em class="italic"><span class="koboSpan" id="kobo.460.1">Gang of Four</span></em><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">However, providing a detailed explanation of these patterns is beyond our scope. </span><span class="koboSpan" id="kobo.461.3">For more in-depth explanations, you can refer to the </span><em class="italic"><span class="koboSpan" id="kobo.462.1">Further reading</span></em><span class="koboSpan" id="kobo.463.1"> section. </span><span class="koboSpan" id="kobo.463.2">The fundamental principle remains unchanged: grouping elements that undergo changes together. </span><span class="koboSpan" id="kobo.463.3">Typically, data and the corresponding behavior that relies on that data tend to change simultaneously, though exceptions exist. </span><span class="koboSpan" id="kobo.463.4">In such scenarios, relocating the behavior ensures that changes are consolidated in a single location. </span><span class="koboSpan" id="kobo.463.5">Strategies and Visitors offer a practical means of modifying behavior by isolating specific portions that require overriding, even though this approach introduces some </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">additional indirection.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.465.1">Divergent change</span></h1>
<p><span class="koboSpan" id="kobo.466.1">As software engineers, we know our work product is soft and flexible. </span><span class="koboSpan" id="kobo.466.2">Once, a professor at university told us, “</span><em class="italic"><span class="koboSpan" id="kobo.467.1">We’re the only engineers who are asked to change the project many times, even when it’s done. </span><span class="koboSpan" id="kobo.467.2">Imagine doing that with a bridge. </span><span class="koboSpan" id="kobo.467.3">This is our strength and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.468.1">our curse.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">As we know </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.471.1">from the Agile philosophy, </span><em class="italic"><span class="koboSpan" id="kobo.472.1">change is good</span></em><span class="koboSpan" id="kobo.473.1">, but it needs to be controlled and managed. </span><span class="koboSpan" id="kobo.473.2">Going back to code smells, we have divergent changes when we need to modify a certain class often, even though we’re touching seemingly unrelated aspects. </span><span class="koboSpan" id="kobo.473.3">Think of a class that handles the results of a search for transportation options like for a travel booking website (those where you put when you want to leave, when you want to return, where you want to go and they give you a bazillion options to choose from – planes, trains, buses and so on). </span><span class="koboSpan" id="kobo.473.4">At some point, we need to change the database the application relies on. </span><span class="koboSpan" id="kobo.473.5">Consequently, we modify class </span><em class="italic"><span class="koboSpan" id="kobo.474.1">X</span></em><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">Then, we need to integrate a new type of transportation, and we must modify class </span><em class="italic"><span class="koboSpan" id="kobo.476.1">X</span></em><span class="koboSpan" id="kobo.477.1"> again. </span><span class="koboSpan" id="kobo.477.2">New payment method? </span><span class="koboSpan" id="kobo.477.3">Again, class </span><em class="italic"><span class="koboSpan" id="kobo.478.1">X</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.479.1">needs modification.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">All these aspects are unrelated, but class </span><em class="italic"><span class="koboSpan" id="kobo.481.1">X</span></em><span class="koboSpan" id="kobo.482.1"> is always in the middle! </span><span class="koboSpan" id="kobo.482.2">Divergent change happens when a module (or a class, or a project) is frequently modified for various reasons, resulting in a mixing of different contexts in a single location. </span><span class="koboSpan" id="kobo.482.3">To enhance our programming experience, we can improve it by segregating these contexts into </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">separate modules.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">The most likely </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.485.1">reason is that the </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.487.1"> has been violated. </span><span class="koboSpan" id="kobo.487.2">In general, we either have a flawed programming structure or we’ve gone overboard with copy and paste. </span><span class="koboSpan" id="kobo.487.3">Thus, it becomes necessary to create appropriate modules and move the methods accordingly. </span><span class="koboSpan" id="kobo.487.4">Sometimes it may be necessary to extract ad hoc methods (and perhaps relocate them) or even extract </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">entire classes.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">Sometimes, we come across a special situation where two aspects, mistakenly tangled up in a single class, naturally form a sequence. </span><span class="koboSpan" id="kobo.489.2">A classic example is when we fetch data from the database, process it, and then feed it to a function that uses it. </span><span class="koboSpan" id="kobo.489.3">In cases like these, we can use a </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.490.1">refactoring technique called </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">split phase</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">In this refactoring process, we break down a complex computation into two phases (or more). </span><span class="koboSpan" id="kobo.492.3">During the first phase, we calculate a result, and then we pass this result, along with some intermediate data structure, to the second phase for </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">further processing.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">For example, take the following code snippet: it retrieves some flight data array from a database, parses an element of that array to a double, then takes some of the output and uses it to perform further calculation... </span><span class="koboSpan" id="kobo.494.2">the point is that it does a lot of different things one after </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the other:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
String[] flightData =
    getFlightDataFromDatabase(flightId).split("-");
double basePrice = parseDouble(flightData[3]);
double totalPrice = basePrice * parseDouble(flightData[0])
    + basePrice * parseDouble(flightData[1]) + basePrice *
        parseDouble(flightData[2]);</span></pre> <p><span class="koboSpan" id="kobo.497.1">It would be nice to refactor this code and make it a bit more readable and somehow modular, even if this term could be inappropriate when talking about a small set of code lines. </span><span class="koboSpan" id="kobo.497.2">Anyway, we’re going to split this code into phases, almost like it was a workflow: we’ll call </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">getFlightDataFromDatabase</span></strong><span class="koboSpan" id="kobo.499.1"> (without splitting the result immediately; that is something that will be needed only in the next code line). </span><span class="koboSpan" id="kobo.499.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">flightData</span></strong><span class="koboSpan" id="kobo.501.1"> string, of course, is not </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.502.1">very handy (we’re assuming we cannot change the return type because we’re using a third-party library) so we’re going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">parseFlightData</span></strong><span class="koboSpan" id="kobo.504.1"> into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.506.1"> object, which handles the flight information in a very handy way. </span><span class="koboSpan" id="kobo.506.2">At the end, we’re going to finally implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">calculateTotalPrice</span></strong><span class="koboSpan" id="kobo.508.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">flightInfo</span></strong><span class="koboSpan" id="kobo.510.1"> object. </span><span class="koboSpan" id="kobo.510.2">See how this code – even a four-line piece of code – can become much </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">more readable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
String flightData = getFlightDataFromDatabase(flightId);
FlightInfo flightInfo = parseFlightData(flightData);
double totalPrice = calculateTotalPrice(flightInfo);
...
</span><span class="koboSpan" id="kobo.512.2">double calculateTotalPrice(FlightInfo flightInfo) {
    var basePrice = flightInfo.getBasePrice();
    return basePrice * flightInfo.getAdultsCount() +
         basePrice * flightInfo.getChildrenCount() +
            basePrice * flightInfo.getInfantsCount();
}</span></pre> <p><span class="koboSpan" id="kobo.513.1">When the change you need is not in a single class you have to change often, but spread across the project, you’re forced to modify the code in a lot of different points. </span><span class="koboSpan" id="kobo.513.2">That’s when you have the code smell known as </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.514.1">Shotgun Surgery</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.516.1">Shotgun Surgery</span></h1>
<p><span class="koboSpan" id="kobo.517.1">Although it </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.518.1">might seem a bit violent at first, to me, the term seems also funny, to be honest; that’s why I really like it. </span><span class="koboSpan" id="kobo.518.2">Sometimes, I’ve heard it referred to as </span><em class="italic"><span class="koboSpan" id="kobo.519.1">shooting a fly with a bazooka.</span></em><span class="koboSpan" id="kobo.520.1"> It is, basically, the opposite of </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">divergent change.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">When you’re dealing with Shotgun Surgery, it means you must make a bunch of changes in your code base just to tackle seemingly simple tasks. </span><span class="koboSpan" id="kobo.522.2">Frequently, you’ll find yourself altering code that appears quite similar, either directly copy-pasted or with a similar purpose. </span><span class="koboSpan" id="kobo.522.3">The term refers to the work of a surgeon, which is done very precisely, with a scalpel, in the least invasive way possible. </span><span class="koboSpan" id="kobo.522.4">Now replace the image of the scalpel with a shotgun and... </span><span class="koboSpan" id="kobo.522.5">well, you get </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the idea.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">There can be </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.525.1">several examples or reasons that lead to Shotgun Surgery; let’s quickly go through some of them, so we can prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">the problem:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.527.1">Copy and paste</span></strong><span class="koboSpan" id="kobo.528.1">: This is the first example that comes to mind; you’ve done some good </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.529.1">old copy and pasting of code! </span><span class="koboSpan" id="kobo.529.2">This means, of course, that making changes to some of the copied code requires you to make those same changes to each and every copy. </span><span class="koboSpan" id="kobo.529.3">It’s pretty </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">straightforward, really.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.531.1">Excessive layering</span></strong><span class="koboSpan" id="kobo.532.1">: Sometimes, our application tends to be too layered. </span><span class="koboSpan" id="kobo.532.2">For example, imagine a basic CRUD app that goes all out with multiple layers, including </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.533.1">data transfer objects, data access objects, and domain objects. </span><span class="koboSpan" id="kobo.533.2">Every time you want to add a table to the database, you not only have to add stuff to all four layers but also deal with all the property bag objects within those layers. </span><span class="koboSpan" id="kobo.533.3">It’s another case of Shotgun Surgery. </span><span class="koboSpan" id="kobo.533.4">(But the world isn’t all black or white; there are many shades of gray. </span><span class="koboSpan" id="kobo.533.5">Sometimes, an application with well-defined layers helps to isolate concepts and responsibilities. </span><span class="koboSpan" id="kobo.533.6">So, be careful; I’m not saying that designing multiple layers in an architecture is inherently bad. </span><span class="koboSpan" id="kobo.533.7">You always have to find the right balance, just like </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">in life!)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.535.1">Limited layering</span></strong><span class="koboSpan" id="kobo.536.1">: Just </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.537.1">as sometimes there are too many layers in the design of an application, there are also times when responsibilities are excessively separated: one class for constants, another for static variables, and so on. </span><span class="koboSpan" id="kobo.537.2">Then, when you need to make a change, you find yourself having to touch them all! </span><span class="koboSpan" id="kobo.537.3">Has it ever happened to you? </span><span class="koboSpan" id="kobo.537.4">It happens to me quite often. </span><span class="koboSpan" id="kobo.537.5">And there you are again, using a shotgun in the </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">operating room.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.539.1">You should care about these problems because changes become more time-consuming since you have to edit your code base in more places. </span><em class="italic"><span class="koboSpan" id="kobo.540.1">Merge conflicts</span></em><span class="koboSpan" id="kobo.541.1"> become more likely, as more people are touching the code in different locations, making collaborative projects more difficult. </span><span class="koboSpan" id="kobo.541.2">You’re also more likely to introduce bugs due to the cognitive load of remembering to change the code in multiple places. </span><span class="koboSpan" id="kobo.541.3">Additionally, you end up with more code because of knowledge duplication and the need for additional constructs to connect the different pieces. </span><span class="koboSpan" id="kobo.541.4">Lastly, the learning curve is higher for new team members as development becomes like a treasure hunt in navigating through the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">When you have </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.544.1">your logic spread all over the code base, you could simply move your method(s) or your field(s) into the same class or module. </span><span class="koboSpan" id="kobo.544.2">By doing so, you make sure that related software elements are clustered together, making it easier to locate and comprehend the connections between them. </span><span class="koboSpan" id="kobo.544.3">All the relevant context would be consolidated in one place, enhancing encapsulation and enabling other parts of the software to be less reliant on the specifics of </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">this module.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">Another intriguing approach to tackle Shotgun Surgery is to employ inlining refactorings. </span><span class="koboSpan" id="kobo.546.2">In other words, it can be beneficial to merge methods or classes in order to consolidate poorly separated logic. </span><span class="koboSpan" id="kobo.546.3">This may result in a long method or a large class; I know we just said that this would be bad, but this would only be a temporary (but very useful) situation so that you can subsequently use extractions to break it down into more coherent pieces. </span><span class="koboSpan" id="kobo.546.4">Of course, we typically prefer small functions and classes in our code but don’t hesitate to create something large as an intermediate step </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">toward reorganization.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">Inlining a method means, basically, doing the opposite of extracting a method. </span><span class="koboSpan" id="kobo.548.2">Suppose we have </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
public Double calculatePrice(Integer passenger, Double
    baseFare){
    var basePrice = passenger * baseFare;
    var basePriceWithVAT = VATCalculator.addVat(basePrice);
    return basePriceWithVAT;
}
class VATCalculator {
    public static Double addVat(double basePrice) {
        return basePrice * (1 + DefaultValues.DEFAULT_VAT);
    }
}
class DefaultValues {
    public static final Double DEFAULT_VAT = 0.22;
}</span></pre> <p><span class="koboSpan" id="kobo.551.1">You have created a separate class, with a static method, just to implement the VAT addition. </span><span class="koboSpan" id="kobo.551.2">Supposing that </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.552.1">this method is used only once, this seems a bit too much; the suggestion here is simply to inline the content of the static method, avoiding creating a separate class, which would make the code a bit more difficult to read. </span><span class="koboSpan" id="kobo.552.2">You could simply do </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
public Double calculatePrice(Integer passenger, Double
    baseFare){
    var basePrice = passenger * baseFare;
    return basePrice * (1 + 0.22);
}</span></pre> <p><span class="koboSpan" id="kobo.555.1">Anyway, the real deal is to always keep Shotgun Surgery on your radar as you work. </span><span class="koboSpan" id="kobo.555.2">Keep asking yourself whether future maintenance programmers (which could also be your future self) will need a shotgun or a scalpel to make the anticipated changes. </span><span class="koboSpan" id="kobo.555.3">If the answer leans toward </span><em class="italic"><span class="koboSpan" id="kobo.556.1">shotgun</span></em><span class="koboSpan" id="kobo.557.1">… then it’s high time you rethink </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">your approach.</span></span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.559.1">God object</span></h1>
<p><span class="koboSpan" id="kobo.560.1">Of all the anti-patterns </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.561.1">mentioned in this chapter (there are many more; I encourage </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.562.1">you to delve into the </span><em class="italic"><span class="koboSpan" id="kobo.563.1">Further reading</span></em><span class="koboSpan" id="kobo.564.1"> section), perhaps the one called </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">god object</span></strong><span class="koboSpan" id="kobo.566.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">god class</span></strong><span class="koboSpan" id="kobo.568.1">) is the one I most frequently come across. </span><span class="koboSpan" id="kobo.568.2">As the name suggests (I must say, in the world of refactoring and clean code, the level of naming is remarkable!), a god class is a negative coding practice characterized by a class that assumes an excessively considerable number of responsibilities. </span><span class="koboSpan" id="kobo.568.3">It manifests as a class that consolidates and oversees numerous objects, performing all tasks within the application. </span><span class="koboSpan" id="kobo.568.4">This anti-pattern violates the principle of keeping classes focused and modular, leading to poor maintainability and hindered </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">code readability.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">You may think that this may be a good pattern; also, the name can suggest something positive. </span><span class="koboSpan" id="kobo.570.2">Well, this is not the case, and we are about to </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">see why.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">God objects violate SOLID, especially the Single Responsibility Principle. </span><span class="koboSpan" id="kobo.572.2">God classes go completely against the Single Responsibility Principle by assuming an excessive number of responsibilities </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.573.1">and lacking focus. </span><span class="koboSpan" id="kobo.573.2">As a result, engineers end up reinventing the wheel, duplicating code, and accumulating </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">Because of god objects, your code will be more fragile. </span><span class="koboSpan" id="kobo.575.2">Due to the overwhelming responsibilities of a god class, it requires frequent updates, which significantly raises the chances of introducing breaking changes. </span><span class="koboSpan" id="kobo.575.3">Understanding the impact of modifications to a god class on the rest of the application can be challenging, if </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">not impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">God objects are hardly testable. </span><span class="koboSpan" id="kobo.577.2">A class is easily testable, in general, when it is small, focused, and independent of other types. </span><span class="koboSpan" id="kobo.577.3">On the contrary, a god class operates in the opposite manner. </span><span class="koboSpan" id="kobo.577.4">Being a large, all-encompassing entity that controls and manages numerous other objects, it becomes tightly coupled to those types. </span><span class="koboSpan" id="kobo.577.5">Consequently, testing the god class becomes a daunting task due to its intricate setup and the necessity to stub or mock numerous dependencies just to instantiate it for testing purposes. </span><span class="koboSpan" id="kobo.577.6">You can often become aware you are writing a god object when it has too many </span><em class="italic"><span class="koboSpan" id="kobo.578.1">collaborators</span></em><span class="koboSpan" id="kobo.579.1">, that is, too many other objects needed for the class itself </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Finally, the main pain point. </span><span class="koboSpan" id="kobo.581.2">We always end up with this. </span><span class="koboSpan" id="kobo.581.3">A god object makes your code harder to read and understand. </span><span class="koboSpan" id="kobo.581.4">It is no wonder that the code within these classes becomes complex, considering their extensive responsibilities and interactions with several types. </span><span class="koboSpan" id="kobo.581.5">I am not (only) talking about cyclomatic complexity here; for example, relying on external dependencies that cause side effects and mutability. </span><span class="koboSpan" id="kobo.581.6">The cumulative effect of these complexities contributes to the overall cognitive complexity of the code, creating obstacles in understanding and reducing engineers’ productivity </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The solution here is not unique, but the approach can be. </span><span class="koboSpan" id="kobo.583.2">It is quite easy to create a god object (especially in object-oriented programming) but it can be extremely hard to undo them. </span><span class="koboSpan" id="kobo.583.3">So, use the good old </span><em class="italic"><span class="koboSpan" id="kobo.584.1">divide et impera</span></em><span class="koboSpan" id="kobo.585.1"> technique (again, the Single Responsibility Principle) and split the class into smaller pieces; be guided by your domain; and group the common methods and properties in a class while keeping the classes loosely coupled. </span><span class="koboSpan" id="kobo.585.2">If classes </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.586.1">or methods have a lot of code or functionality in them, break them into simple, manageable, testable classes and methods. </span><span class="koboSpan" id="kobo.586.2">Finally, delete or deprecate the </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">god object.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.588.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.589.1">In this chapter, we learned how to spot some – not all – code smells. </span><span class="koboSpan" id="kobo.589.2">We covered the ones that I think are the most common. </span><span class="koboSpan" id="kobo.589.3">Some of them you’ll pick up instinctively and avoid them as you write code. </span><span class="koboSpan" id="kobo.589.4">We tackled duplicated code, long methods, large classes, and repeated switches. </span><span class="koboSpan" id="kobo.589.5">We also learned to avoid our obsession with primitive types (using string for everything is a strong temptation!) and looked at feature envy methods. </span><span class="koboSpan" id="kobo.589.6">Finally, we talked about divergent change and its opposite, Shotgun Surgery. </span><span class="koboSpan" id="kobo.589.7">Oh, and let’s not forget about the god object. </span><span class="koboSpan" id="kobo.589.8">This is just a partial selection of all the existing code smells out there, but I believe it’s a good starting point to steer clear </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">A crucial condition to perform any kind of refactoring, especially god object refactoring, is good test coverage. </span><span class="koboSpan" id="kobo.591.2">In the next chapter, we are going to tackle this extremely </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">important matter.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.593.1">Further reading</span></h1>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.594.1">Primitive Data </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.595.1">Types</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">: </span></span><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html"><span class="No-Break"><span class="koboSpan" id="kobo.597.1">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</span></span></a></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.598.1">Strategy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">: </span></span><a href="https://refactoring.guru/design-patterns/strategy"><span class="No-Break"><span class="koboSpan" id="kobo.600.1">https://refactoring.guru/design-patterns/strategy</span></span></a></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.601.1">Visitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">: </span></span><a href="https://refactoring.guru/design-patterns/visitor"><span class="No-Break"><span class="koboSpan" id="kobo.603.1">https://refactoring.guru/design-patterns/visitor</span></span></a></li>
<li><span class="koboSpan" id="kobo.604.1">Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (1994). </span><em class="italic"><span class="koboSpan" id="kobo.605.1">Design Patterns: Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.606.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">Addison-Wesley Professional.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.608.1">Code</span></strong> <span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.609.1">Smells</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">: </span></span><a href="https://refactoring.guru/refactoring/smells"><span class="No-Break"><span class="koboSpan" id="kobo.611.1">https://refactoring.guru/refactoring/smells</span></span></a></li>
</ul>
</div>
</body></html>