<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-57"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.2.1">Handling Behavior with Ports and Use Cases</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Once we have defined the business rules in the Domain hexagon, we can start thinking about ways to use those rules to create software features while considering how the system will handle the data coming from users and other applications. </span><span class="koboSpan" id="kobo.3.2">Ports and use cases address such concerns in the hexagonal architecture, where we need to orchestrate system data and business rules to provide useful </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">software functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll explore how to employ use cases to define the behaviors supported by the software. </span><span class="koboSpan" id="kobo.5.2">Through the integration of input and output ports with use cases, we’ll understand the role of such ports in establishing the communication flow within the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Expressing software behavior with </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">use cases</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Implementing use cases with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">input ports</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using output ports to deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">external data</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Automating behavior with the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Application hexagon</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">“By the end of this chapter, you’ll be able to employ ports and use cases to coordinate all the things a hexagonal system must do to fulfill user requirements.” </span><span class="koboSpan" id="kobo.17.2">Once you have grasped the fundamentals of ports and use cases, it will be possible to utilize them to combine elements from both the Domain and Application hexagons to construct </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">powerful features.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.22.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.24.1"> installed on your computer. </span><span class="koboSpan" id="kobo.24.2">They are both available for the Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Designing-Hexagonal-Architecture-with-Java/tree/main/Chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Designing-Hexagonal-Architecture-with-Java/tree/main/Chapter03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.30.1">Expressing software behavior with use cases</span></h1>
<p><span class="koboSpan" id="kobo.31.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">software system</span></strong><span class="koboSpan" id="kobo.33.1"> is nothing more than a set of behaviors working</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.34.1"> together to achieve the goals </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.35.1">defined by users or even other software</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.36.1"> systems. </span><span class="koboSpan" id="kobo.36.2">A software behavior, in turn, is a worthy action that, alone or combined with other software actions, contributes to realizing a worthy software goal. </span><span class="koboSpan" id="kobo.36.3">Such goals are intimately connected to the desires expressed by interested users </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">or systems.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">We can classify those interested folks as stakeholders or actors from which we will ultimately derive the real-world needs that will be transmuted</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.39.1"> into goals. </span><span class="koboSpan" id="kobo.39.2">These actors' goals will be fulfilled by the </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">System under Discussion</span></strong><span class="koboSpan" id="kobo.41.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.42.1">SuD</span></strong><span class="koboSpan" id="kobo.43.1">), or simply the software you </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">are developing.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">From the hexagonal architecture’s standpoint, we can relate these actors to what we saw in </span><a href="B19777_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.47.1">, </span><em class="italic"><span class="koboSpan" id="kobo.48.1">Why Hexagonal Architecture?</span></em><span class="koboSpan" id="kobo.49.1">, when discussing driver</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.50.1"> and driven operations. </span><span class="koboSpan" id="kobo.50.2">In the same vein, we can classify the SuD actors: the </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">driver actor</span></strong><span class="koboSpan" id="kobo.52.1"> is a person or system that triggers one</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.53.1"> of the SuD behaviors, while the </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">driven actor</span></strong><span class="koboSpan" id="kobo.55.1"> is an external system consumed by </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the SuD.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">To express what a system does in both functional and non-functional terms, people such as Ivar Jacobson and Alistair Cockburn and the Agile community, in general, have contributed to developing useful techniques to transform business requirements into meaningful written descriptions of how a system should behave. </span><span class="koboSpan" id="kobo.57.2">Among those techniques, one that stands out is that of </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Unlike the UML, which depicts a high-level view of the system through the relationship between diagrams, use cases perform a deeper</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.60.1"> dive by providing a detailed written description of SuD behaviors. </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Use cases</span></strong><span class="koboSpan" id="kobo.62.1"> are a valuable technique to set SuD goals, the means or behaviors to fulfill them, the possible failure scenarios, and what to do when they occur. </span><span class="koboSpan" id="kobo.62.2">When combined with DDD techniques, use cases are instrumental in bridging the gap of dealing with application-specific activities that mean more to the SuD – and the Application hexagon – than to the problem domain and its business rules in the Domain hexagon. </span><span class="koboSpan" id="kobo.62.3">By thinking in terms of use cases, we are making a significant step to improve the separation of concerns in the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">hexagonal architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">We can create use cases</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.65.1"> by simply writing a description</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.66.1"> about them, but it’s also possible to express them through code. </span><span class="koboSpan" id="kobo.66.2">Next, we’ll learn how to create use cases both in written and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">code form.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.68.1">How to create a use case</span></h2>
<p><span class="koboSpan" id="kobo.69.1">There are elaborate </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.70.1">approaches to creating written use cases where you</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.71.1"> may specify detailed and standardized information about the input data, possible behaviors, and use case results. </span><span class="koboSpan" id="kobo.71.2">Cockburn classifies those detailed use cases as fully dressed ones. </span><span class="koboSpan" id="kobo.71.3">Fully dressed use cases may be helpful in new teams, where people are not used to working together. </span><span class="koboSpan" id="kobo.71.4">The standards enforced by the fully dressed approach help provide a clear path about how a use case should be built. </span><span class="koboSpan" id="kobo.71.5">It helps prevent situations where a person may consider certain use case aspects that are not present in use cases written by another person. </span><span class="koboSpan" id="kobo.71.6">An example of a fully dressed use case is </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Actor</span></strong><span class="koboSpan" id="kobo.74.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">Infrastructure engineer</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Goal</span></strong><span class="koboSpan" id="kobo.77.1">: To add a new network to an </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">edge router</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Scope</span></strong><span class="koboSpan" id="kobo.80.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">Infrastructure department</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Trigger</span></strong><span class="koboSpan" id="kobo.83.1">: A particular reason to segregate network access through a </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">different network</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Input data</span></strong><span class="koboSpan" id="kobo.86.1">: Router ID, network name, address, </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and CIDR</span></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.88.1">Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.90.1">Look up the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">router ID.</span></span></li><li class="upper-roman"><span class="koboSpan" id="kobo.92.1">Validate that the network address doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">already exist.</span></span></li><li class="upper-roman"><span class="koboSpan" id="kobo.94.1">Validate that the CIDR is not below the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">minimum allowed.</span></span></li><li class="upper-roman"><span class="koboSpan" id="kobo.96.1">If the previous validations are okay, add the network to the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">informed router.</span></span></li></ol></li>
</ul>
<p><span class="koboSpan" id="kobo.98.1">On the opposite side, we have the less formal and casual types of use cases. </span><span class="koboSpan" id="kobo.98.2">The main characteristic of casual use cases is that they don’t follow standards about how the information should be recorded. </span><span class="koboSpan" id="kobo.98.3">They try to convey as much meaning as possible in one or two paragraphs, as mentioned in the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">following example.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">The infrastructure engineer</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.101.1"> sends a request</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.102.1"> to the application containing the router ID, network name, address, and CIDR. </span><span class="koboSpan" id="kobo.102.2">The application performs a lookup in the router ID, then validates that the network does not already exist, followed by another validation to confirm that the CIDR value is not below the minimum allowed. </span><span class="koboSpan" id="kobo.102.3">If all the validations are okay, then the system proceeds to add the network to the </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">informed router.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Aside from the formal and casual written techniques, it’s possible to express user intent directly in the code</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.105.1"> through automated tests. </span><span class="koboSpan" id="kobo.105.2">That approach relies on </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">behavior-driven design</span></strong><span class="koboSpan" id="kobo.107.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.108.1">BDD</span></strong><span class="koboSpan" id="kobo.109.1">) principles related to discovery, formulation, and automation. </span><span class="koboSpan" id="kobo.109.2">In such an approach, you start talking with business people trying to discover what they need. </span><span class="koboSpan" id="kobo.109.3">The output of this discovery process contains examples of situations and behaviors depicting the business need. </span><span class="koboSpan" id="kobo.109.4">Then, you move on to the formulation phase, where structured documentation is created based on those examples. </span><span class="koboSpan" id="kobo.109.5">Finally, the automation phase is where tests are created and executed to validate those behaviors from examples described and structured in </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">previous phases.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">When employing BDD earlier in software development, we have the opportunity to create use cases iteratively based on examples and tests created to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">business ideas.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">With the aid of tools such as Cucumber, we can adopt the BDD approach in our hexagonal application. </span><span class="koboSpan" id="kobo.113.2">To convert the written use cases we built previously, we need to create a Cucumber </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">feature file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
@addNetworkToRouter
</span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Feature</span></strong><span class="koboSpan" id="kobo.117.1">: Add network to a router
I want to be able to add a network to an existent router
</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Scenario</span></strong><span class="koboSpan" id="kobo.119.1">: Adding a network to an existent router
</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Given</span></strong><span class="koboSpan" id="kobo.121.1"> I provide a router ID and the network details
</span><strong class="bold"><span class="koboSpan" id="kobo.122.1">When</span></strong><span class="koboSpan" id="kobo.123.1"> I found the router
</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">And</span></strong><span class="koboSpan" id="kobo.125.1"> The network address is valid and doesn't already exist
</span><strong class="bold"><span class="koboSpan" id="kobo.126.1">And</span></strong><span class="koboSpan" id="kobo.127.1"> The CIDR is valid
</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Then</span></strong><span class="koboSpan" id="kobo.129.1"> Add the network to the router</span></pre> <p><span class="koboSpan" id="kobo.130.1">Then, based on the steps provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Given</span></strong><span class="koboSpan" id="kobo.132.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">When</span></strong><span class="koboSpan" id="kobo.134.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">And</span></strong><span class="koboSpan" id="kobo.136.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">Then</span></strong><span class="koboSpan" id="kobo.138.1"> terms from the feature files, we need to create a test class to automate the validation of our use </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">case steps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
public class AddNetworkStepsTest {
  private RouterId routerId;
  private Router router;
  private RouterNetworkFileAdapter routerNetworkFileAdapter
    = RouterNetworkFileAdapter.getInstance();
  Network network = new Network(new IP("20.0.0.0"),
  "Marketing", 8);
  /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.141.1">First, we have to declare</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.142.1"> the types and initialize the objects</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.143.1"> we will use to perform our tests. </span><span class="koboSpan" id="kobo.143.2">In the preceding code, we declared the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">RouterId</span></strong><span class="koboSpan" id="kobo.145.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Router</span></strong><span class="koboSpan" id="kobo.147.1"> types. </span><span class="koboSpan" id="kobo.147.2">Then, we initialized the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">RouterNetworkFileAdapter</span></strong><span class="koboSpan" id="kobo.149.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1"> instances.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">After preparing the resources we need to test, we can start by implementing the first step of </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">our test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.154.1">
@Given("I provide a router ID and the network details")
public void obtain_routerId() {
  this.routerId = RouterId.withId(
  "ca23800e-9b5a-11eb-a8b3-0242ac130003");
}</span></pre> <p><span class="koboSpan" id="kobo.155.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">@Given</span></strong><span class="koboSpan" id="kobo.157.1"> annotation describes the retrieval of </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">RouterId</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">We can use this ID to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">a router:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
@When("I found the router")
public void lookup_router() {
  router =
  routerNetworkFileAdapter.fetchRouterById(routerId);
}</span></pre> <p><span class="koboSpan" id="kobo.162.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">RouterNetworkFileAdapter</span></strong><span class="koboSpan" id="kobo.164.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">RouterId</span></strong><span class="koboSpan" id="kobo.166.1">, we retrieve a </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">Router</span></strong><span class="koboSpan" id="kobo.168.1"> object. </span><span class="koboSpan" id="kobo.168.2">Next, we can check</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.169.1"> whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Network</span></strong><span class="koboSpan" id="kobo.171.1"> object meets</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.172.1"> the desired requirements before adding it to </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the router:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
@And(
"The network address is valid and doesn't already exist")
public void check_address_validity_and_existence() {
  var availabilitySpec =
  new NetworkAvailabilitySpecification(
  network.getAddress(), network.getName(),
  network.getCidr());
  if(!availabilitySpec.isSatisfiedBy(router))
  throw new IllegalArgumentException("Address already
  exist");
}</span></pre> <p><span class="koboSpan" id="kobo.175.1">To ensure the network is valid, we must apply the rules from </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">NetworkAvailabilitySpecification</span></strong><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">Next, we must check the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">network CIDR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
@Given("The CIDR is valid")
public void check_cidr() {
  var cidrSpec = new CIDRSpecification();
  if(cidrSpec.isSatisfiedBy(network.getCidr()))
  throw new IllegalArgumentException(
    "CIDR is below"+CIDRSpecification.
</span><span class="koboSpan" id="kobo.179.2">      MINIMUM_ALLOWED_CIDR);
}</span></pre> <p><span class="koboSpan" id="kobo.180.1">As the last verification step, we must apply the rules from </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">CIDRSpecification</span></strong><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">If everything is fine, then we can add the network to </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">the router:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
@Then("Add the network to the router")
public void add_network() {
  router.addNetworkToSwitch(network);
}</span></pre> <p><span class="koboSpan" id="kobo.185.1">By calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.187.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Router</span></strong><span class="koboSpan" id="kobo.189.1">, we have added the network to </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the router.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The following</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.192.1"> is a visual representation</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.193.1"> of the formal, casual, and BDD-based types of </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">use cases:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.195.1"><img alt="Figure 3.1 – A use case for the topology and inventory network system" src="image/B19777_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">Figure 3.1 – A use case for the topology and inventory network system</span></p>
<p><span class="koboSpan" id="kobo.197.1">Fully dressed, casual, and BDD-based use cases express the same thing. </span><span class="koboSpan" id="kobo.197.2">The main difference lies not in the </span><em class="italic"><span class="koboSpan" id="kobo.198.1">what</span></em><span class="koboSpan" id="kobo.199.1"> but rather in </span><em class="italic"><span class="koboSpan" id="kobo.200.1">how</span></em><span class="koboSpan" id="kobo.201.1"> the three techniques achieve the same objective to describe system behavior. </span><span class="koboSpan" id="kobo.201.2">As we may expect, the best choice is conditioned to money, time, and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">organization constraints.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">We could bypass this use case creation/process and go straight on to code the use case. </span><span class="koboSpan" id="kobo.203.2">Although I don’t consider the formal use case structuring part a required step, I certainly consider it a recommended one. </span><span class="koboSpan" id="kobo.203.3">By writing down and structuring the use case’s expected behaviors, we’re engaging in a valuable additional step to help us clarify and better organize our ideas regarding the use case’s arrangement. </span><span class="koboSpan" id="kobo.203.4">Once the structuring effort is made, we only need to translate that into its </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">code counterpart.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">What I propose in developing hexagonal applications</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.206.1"> is to design use cases as abstractions</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.207.1"> rather than implementations. </span><span class="koboSpan" id="kobo.207.2">I am using interfaces in these examples, but there is no problem using abstract classes. </span><span class="koboSpan" id="kobo.207.3">The following code shows a use case interface based on its </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">written form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
public interface RouterNetworkUseCase {
    Router addNetworkToRouter(RouterId routerId, Network
    network);
}</span></pre> <p><span class="koboSpan" id="kobo.210.1">We define use cases as interfaces</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.211.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">three reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.213.1">To provide different ways of fulfilling the use </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">cases’ goals</span></span></li>
<li><span class="koboSpan" id="kobo.215.1">To allow dependency on abstraction rather </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">than implementation</span></span></li>
<li><span class="koboSpan" id="kobo.217.1">For governance </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">of APIs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.219.1">The role of use cases in the hexagonal architecture is that they allow us to implement input ports. </span><span class="koboSpan" id="kobo.219.2">It’s through input ports that we construct the logic that will, for example, call Domain hexagon services, other use cases, and external resources through output ports. </span><span class="koboSpan" id="kobo.219.3">The UML representation of the use case and its input port is </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.221.1"><img alt="Figure 3.2 – A use case for the topology and inventory network system" src="image/B19777_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">Figure 3.2 – A use case for the topology and inventory network system</span></p>
<p><span class="koboSpan" id="kobo.223.1">Now that we know how to create</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.224.1"> use cases, both</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.225.1"> in written and code form, let’s explore the ways to implement use cases with </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">input ports.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.227.1">Implementing use cases with input ports</span></h1>
<p><span class="koboSpan" id="kobo.228.1">In the hexagonal architecture, there is this idea</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.229.1"> about driving and driven</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.230.1"> operations. </span><span class="koboSpan" id="kobo.230.2">We’ve seen that such classification is also valid to determine which actors interact with the hexagon system. </span><span class="koboSpan" id="kobo.230.3">Driving actors are the ones who send requests to the application, while the driven actors represent the external components accessed by the application. </span><span class="koboSpan" id="kobo.230.4">We use </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">input ports</span></strong><span class="koboSpan" id="kobo.232.1"> – also known as </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">primary ports</span></strong><span class="koboSpan" id="kobo.234.1"> – to allow the communication flow between driving</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.235.1"> actors and the driving operations exposed by a hexagonal system. </span><span class="koboSpan" id="kobo.235.2">Use cases tell us what behaviors the application will support, while input ports tell us how such behaviors will </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">be performed.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Input ports play an integrating role because they are like pipes that allow the data to flow from driving actors when they hit the hexagonal system through one of its adapters on the Framework hexagon. </span><span class="koboSpan" id="kobo.237.2">In the same vein, input ports provide the pipes for communication with business rules from the Domain hexagon. </span><span class="koboSpan" id="kobo.237.3">Through input ports, we also orchestrate communication with external systems through output ports </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">and adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Input ports are at the crossroads of a hexagonal system, helping translate what comes from the outside and goes in the direction of the Domain and Application hexagons. </span><span class="koboSpan" id="kobo.239.2">Input ports are also essential in orchestrating communication with external systems. </span><span class="koboSpan" id="kobo.239.3">In the following diagram, we can see how </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Application Hexagon</span></strong><span class="koboSpan" id="kobo.241.1"> is the integration point between </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">Driving Actor</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">Driven Actor</span></strong><span class="koboSpan" id="kobo.245.1"> and their respective input and output ports </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">and adapters:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 3.3 – The various ports and the Application hexagon" src="image/B19777_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 3.3 – The various ports and the Application hexagon</span></p>
<p><span class="koboSpan" id="kobo.249.1">In the previous section, we</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.250.1"> defined a use case interface describing an operation</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.251.1"> that allowed us to add a network to a router. </span><span class="koboSpan" id="kobo.251.2">Let’s learn how to create an input port by implementing that </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">use case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
public class RouterNetworkInputPort implements RouterNet
  workUseCase {
private final RouterNetworkOutputPort
    routerNetworkOutputPort;
public RouterNetworkInputPort(RouterNetworkOutputPort
      routerNetworkOutputPort){
      this.routerNetworkOutputPort =
      routerNetworkOutputPort;
}
@Override
public Router addNetworkToRouter(RouterId routerId, Network
    network) {
    var router = fetchRouter(routerId);
    return createNetwork(router, network);
}
private Router fetchRouter(RouterId routerId) {
    return
    routerNetworkOutputPort.fetchRouterById(routerId);
}
private Router createNetwork(Router router, Network net
  work) {
    var newRouter =
    NetworkOperation.createNewNetwork(router, network);
    return persistNetwork(router) ? </span><span class="koboSpan" id="kobo.253.2">newRouter : router;
}
private boolean persistNetwork(Router router) {
    return routerNetworkOutputPort.persistRouter(router);
}
}</span></pre> <p><span class="koboSpan" id="kobo.254.1">With this input port</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.255.1"> implementation, we have a clear view</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.256.1"> of what actions the software must perform to fulfill the use case’s goal of adding a network to the router. </span><span class="koboSpan" id="kobo.256.2">Before we look closer at the input port methods, let’s consider the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">RouterNetworkOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.258.1">interface’s declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
public interface RouterNetworkOutputPort {
     Router fetchRouterById(RouterId routerId);
     boolean persistRouter(Router router);
}</span></pre> <p><span class="koboSpan" id="kobo.260.1">This output port states that the application intends to obtain and persist data from external sources. </span><span class="koboSpan" id="kobo.260.2">The hexagon system is not aware of whether the external source is a database, a flat file, or another system. </span><span class="koboSpan" id="kobo.260.3">Here, we only state the intention to get data </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">from outside.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">addNetworkToRouter</span></strong><span class="koboSpan" id="kobo.264.1"> method, which returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Router</span></strong><span class="koboSpan" id="kobo.266.1"> object, is the only public method that’s exposed by the input port. </span><span class="koboSpan" id="kobo.266.2">We make all other methods private because they are not supposed to be used outside the context of this input port. </span><span class="koboSpan" id="kobo.266.3">The input port starts its job by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">RouterId</span></strong><span class="koboSpan" id="kobo.268.1"> to retrieve a </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Router</span></strong><span class="koboSpan" id="kobo.270.1"> object; then, it creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Network</span></strong><span class="koboSpan" id="kobo.272.1"> object on that </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Router</span></strong><span class="koboSpan" id="kobo.274.1"> object. </span><span class="koboSpan" id="kobo.274.2">Remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Network</span></strong><span class="koboSpan" id="kobo.276.1"> object comprises the address, name, and CIDR attributes, as expressed in the use case’s written form. </span><span class="koboSpan" id="kobo.276.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">fetchRouter</span></strong><span class="koboSpan" id="kobo.278.1"> method will try to obtain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Router</span></strong><span class="koboSpan" id="kobo.280.1"> object by passing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">RouterId</span></strong><span class="koboSpan" id="kobo.282.1"> ID to the output port’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">fetchRouterById</span></strong><span class="koboSpan" id="kobo.284.1"> method. </span><span class="koboSpan" id="kobo.284.2">That’s when the input port will need to coordinate an external call that will be carried out by an output adapter that implements the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">output port.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">If everything goes well, the input port will receive the desired </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Router</span></strong><span class="koboSpan" id="kobo.288.1"> object and will be able to create a network object and add it to the informed router. </span><span class="koboSpan" id="kobo.288.2">At this point, the input port is interacting with a Domain service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">createNewNetwork</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">This service works under the constraints imposed by business rules from the Domain hexagon. </span><span class="koboSpan" id="kobo.290.3">Finally, the input port coordinates the persistence of the whole operation through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">persistRouter</span></strong><span class="koboSpan" id="kobo.292.1"> method from the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">output port.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">This input port does not contain anything specific to the problem domain. </span><span class="koboSpan" id="kobo.294.2">Its primary concern is to handle data by orchestrating internal calls with Domain services and external calls with output ports. </span><span class="koboSpan" id="kobo.294.3">The input port sets the operation’s execution order and provides the Domain hexagon with data in a format </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">it understands.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">External calls are interactions</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.297.1"> that are performed by the hexagonal</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.298.1"> application to get data from or persist data to external systems. </span><span class="koboSpan" id="kobo.298.2">This is the subject of the next section, where we’ll learn how to use output ports to deal with things living outside </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the application.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.300.1">Using output ports to deal with external data</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.301.1">Output ports</span></strong><span class="koboSpan" id="kobo.302.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">secondary ports</span></strong><span class="koboSpan" id="kobo.304.1">, represent the application’s intent to deal with external</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.305.1"> data. </span><span class="koboSpan" id="kobo.305.2">It’s through output</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.306.1"> ports that we prepare the system</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.307.1"> to communicate with the outside</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.308.1"> world. </span><span class="koboSpan" id="kobo.308.2">By allowing this communication, we can associate output ports with driven actors and operations. </span><span class="koboSpan" id="kobo.308.3">Remember, driven actors are external systems, while driven operations are used to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">such systems.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">I say that we’re preparing the hexagonal application to communicate with the outside world because, at the Application hexagon level, we don’t know how that communication will occur yet. </span><span class="koboSpan" id="kobo.310.2">This approach is based on Uncle Bob’s wise advice to postpone, as much as possible, any decisions concerned about which technologies will be used to fulfill the application’s needs. </span><span class="koboSpan" id="kobo.310.3">By doing that, we’re putting more emphasis on the problem domain than on technological details. </span><span class="koboSpan" id="kobo.310.4">I’m not saying that the persistence or messaging mechanisms, for example, are not relevant enough to influence the application’s design. </span><span class="koboSpan" id="kobo.310.5">Instead, the idea is to not let external technologies dictate how the application </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">is designed.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">In the early stages of a software project, it’s not uncommon to see people discussing whether to use PostgreSQL or Oracle databases for persistence, Kafka or Redis for pub-sub activities, and so on. </span><span class="koboSpan" id="kobo.312.2">Those types of discussions exert a strong influence on how the software solves business problems. </span><span class="koboSpan" id="kobo.312.3">Sometimes, it’s hard to imagine such software solving the same business problems but with different technologies. </span><span class="koboSpan" id="kobo.312.4">On certain occasions, it’s even inconceivable to consider such a thing because the whole application architecture is centered on </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">specific technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">As people who work with technology, we’re always eager to use the hottest development framework or a modern programming language. </span><span class="koboSpan" id="kobo.314.2">That is a good attitude, and I think we should continuously pursue better techniques and sophisticated ways to solve problems. </span><span class="koboSpan" id="kobo.314.3">But prudence</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.315.1"> is advised to properly balance our focus</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.316.1"> between the technology and problem domain aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">a system.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.318.1">It’s not only about repositories</span></h2>
<p><span class="koboSpan" id="kobo.319.1">You may be used</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.320.1"> to using terms such as repository or </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">data access object</span></strong><span class="koboSpan" id="kobo.322.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.323.1">DAO</span></strong><span class="koboSpan" id="kobo.324.1">) to describe application behaviors related to persistence</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.325.1"> in a database. </span><span class="koboSpan" id="kobo.325.2">In hexagonal applications, we replace repositories with </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">output ports.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Repositories are often associated with database operations, a fact that, by the way, is also enforced by some development frameworks that formalize this association through persistence features offered by the framework. </span><span class="koboSpan" id="kobo.327.2">A recurring example of this approach is similar t</span><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.328.1">o the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
public interface PasswordResetTokenRepository extends
  JpaRepository&lt;PasswordResetToken, Long&gt; {
     PasswordResetToken findByToken(String token);
     PasswordResetToken findByUser(User user);
     Stream&lt;PasswordResetToken&gt;
       findAllByExpiryDateLessThan(Date now);
     void deleteByExpiryDateLessThan(Date now);
     @Modifying
     @Query(«delete from PasswordResetToken t where
       t.expiryDate &lt;= ?1")
     void deleteAllExpiredSince(Date now);
}</span></pre> <p><span class="koboSpan" id="kobo.331.1">The usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">JpaRepository</span></strong><span class="koboSpan" id="kobo.333.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">@Query</span></strong><span class="koboSpan" id="kobo.335.1"> annotation from the Spring framework reinforces</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.336.1"> the notion that the password data will come from a relational database. </span><span class="koboSpan" id="kobo.336.2">This situation could also be seen as a leaking abstraction condition because our </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">PasswordResetTokenRepository</span></strong><span class="koboSpan" id="kobo.338.1"> interface would also con</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.339.1">tain all the methods inherited from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">JpaRepository</span></strong><span class="koboSpan" id="kobo.341.1"> class that may not be relevant or provide behaviors that don’t suit the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">system’s needs.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">The underlying idea about output ports is that we’re not inferring that persistence or any kind of external communication will occur with a database system. </span><span class="koboSpan" id="kobo.343.2">Instead, the output port’s scope is broader. </span><span class="koboSpan" id="kobo.343.3">Its concern is with communicating with any system, be it a database, a messaging system, or a local or network filesystem, </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">A more hexagonal approach to the password reset interface shown previously would look something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
public interface PasswordResetTokenOutputPort {
     PasswordResetToken findByToken(String token);
     PasswordResetToken findByUser(User user);
     Stream&lt;PasswordResetToken&gt;
       findAllByExpiryDateLessThan(Date now);
     void deleteByExpiryDateLessThan(Date now);
     void deleteAllExpiredSince(Date now);
}</span></pre> <p><span class="koboSpan" id="kobo.348.1">By not extending types from a specific framework and avoiding the usage of annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@Query</span></strong><span class="koboSpan" id="kobo.350.1">, we’re turning the output port into a POJO. </span><span class="koboSpan" id="kobo.350.2">The usage of annotations per se is not a problem. </span><span class="koboSpan" id="kobo.350.3">The issue lies more in the purpose of their usage. </span><span class="koboSpan" id="kobo.350.4">If the aim is to use annotations to implement features that only exist in a particular framework, we are then coupling the software to that framework. </span><span class="koboSpan" id="kobo.350.5">Instead, if the purpose is to use annotations to implement features based on Java standard specifications, we are making a valuable effort to make the software more tolerant </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">The data that’s obtained from an output port</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.353.1"> today may come directly from a relational database. </span><span class="koboSpan" id="kobo.353.2">Tomorrow, this same data can be obtained from the REST API of some application. </span><span class="koboSpan" id="kobo.353.3">Those details are not necessary from the Application hexagon’s perspective because the components in this hexagon are not concerned with how the data </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">is obtained.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Their main concern is in expressing what kind of data they need to conduct their activities. </span><span class="koboSpan" id="kobo.355.2">The way those Application hexagon components define what data they need is based on the entity and value objects from the Domain hexagon. </span><span class="koboSpan" id="kobo.355.3">With this arrangement, where an output port states what type of data it needs, we can plug multiple adapters into the same output port. </span><span class="koboSpan" id="kobo.355.4">So, these adapters carry out the necessary tasks to obtain the data, as expressed by the output port. </span><span class="koboSpan" id="kobo.355.5">This flow is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 3.4 – The output port and its adapters" src="image/B19777_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 3.4 – The output port and its adapters</span></p>
<p><span class="koboSpan" id="kobo.359.1">The output port’s main goal is to state what kind of data it needs without specifying how it will get that data. </span><span class="koboSpan" id="kobo.359.2">That’s the reason why we define them as interfaces and not implementations. </span><span class="koboSpan" id="kobo.359.3">The implementation part is reserved for output adapters, an essential hexagonal architecture component</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.360.1"> that we’ll look at in the next chapter. </span><span class="koboSpan" id="kobo.360.2">To conclude our analysis of output ports, let’s explore where they should </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">be used.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.362.1">Where to use output ports</span></h2>
<p><span class="koboSpan" id="kobo.363.1">At the beginning of this chapter, we learned</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.364.1"> how use cases establish the necessary actions to accomplish something useful in the application. </span><span class="koboSpan" id="kobo.364.2">Among these actions, there may be situations that require us to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">external systems.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">So, the reason to create and utilize</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.367.1"> output ports will be derived from the activities performed by use cases. </span><span class="koboSpan" id="kobo.367.2">In code, the reference for an output port will not appear in the use case’s interface declaration. </span><span class="koboSpan" id="kobo.367.3">The usage of output ports is made explicit when we implement the use case with an input port. </span><span class="koboSpan" id="kobo.367.4">That’s what we did when we implemented </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">RouterNetworkUseCase</span></strong><span class="koboSpan" id="kobo.369.1"> and declared a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">RouterNetworkOutputPort</span></strong><span class="koboSpan" id="kobo.371.1"> attribute at the beginning </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">RouterNetworkInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
public class RouterNetworkInputPort implements RouterNet
  workUseCase {
     private final RouterNetworkOutputPort
     routerNetworkOutputPort;
     public RouterNetworkInputPort(RouterNetworkOutputPort
       routerNetworkOutputPort){
          this.routerNetworkOutputPort =
            routerNetworkOutputPort;
     }
     private Router fetchRouter(RouterId routerId) {
          return routerNetworkOutputPort.fetchRouterById
            (routerId);
     }
     private boolean persistNetwork(Router router) {
          return routerNetworkOutputPort.persistRouter
            (router);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.376.1">You may be wondering when and how the instance for an output port is created. </span><span class="koboSpan" id="kobo.376.2">The previous example shows one approach, where the input port constructor receives a reference for an output port object. </span><span class="koboSpan" id="kobo.376.3">This object will be an implementation provided by an </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">output adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Among the operations defined by a use case and implemented by an input port, some operations are responsible for getting data from or persisting data to external sources. </span><span class="koboSpan" id="kobo.378.2">That’s where output ports come in: to provide the data required to fulfill the use </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">case’s goal.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">In the same way that a use case goal</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.381.1"> is used to represent a piece of software’s intent, without saying how this intent will be realized, output ports do the same thing by representing what kind of data the application needs, without needing to know how that data will be obtained. </span><span class="koboSpan" id="kobo.381.2">Output ports, along with input ports and use cases, are the hexagonal architecture components that support the automation effort that characterizes the Application hexagon. </span><span class="koboSpan" id="kobo.381.3">We’ll examine this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">next section.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.383.1">Automating behavior with the Application hexagon</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.384.1">Automation</span></strong><span class="koboSpan" id="kobo.385.1"> is one of the most valuable</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.386.1"> things</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.387.1"> software can do. </span><span class="koboSpan" id="kobo.387.2">The advent</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.388.1"> of computation brought radical changes to how people solve their problems. </span><span class="koboSpan" id="kobo.388.2">An interesting scenario is that of the credit card industry in its early years. </span><span class="koboSpan" id="kobo.388.3">When banks started to offer credit cards to their customers, most of the back-office activities were done manually. </span><span class="koboSpan" id="kobo.388.4">If you wanted to pay for something with a credit card, the person in the store would need to call their bank, who, in turn, would need to contact your card issuer to confirm you had credit. </span><span class="koboSpan" id="kobo.388.5">As the technology evolved, computer systems were able to automate this credit </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">verification process.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">If we decided to use the hexagonal architecture to build a credit card verification system, those required steps to confirm the cardholder’s credit could be expressed using a use case. </span><span class="koboSpan" id="kobo.390.2">With an input port, we could handle business rules and all the data necessary to achieve the use case goal, consuming, if necessary, external systems through an output port. </span><span class="koboSpan" id="kobo.390.3">When we put all those activities together, the fundamental role of the Application hexagon in automating those activities to fulfill the system’s intent becomes more apparent. </span><span class="koboSpan" id="kobo.390.4">Here’s a code example to illustrate how the credit</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.391.1"> verification process</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.392.1"> would look in the </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">Application hexagon:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.394.1">We start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">CreditCard</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.396.1">entity class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
public class CreditCard {
    /** Code omitted **/
    double availableCredit;
    public boolean
           isAvailableCreditGreaterOrEqualThan(
           double transactionAmount) {
        return  availableCredit&gt;=transactionAmount;
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.398.1">The preceding code only emphasizes the credit availability aspect. </span><span class="koboSpan" id="kobo.398.2">So, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">availableCredit</span></strong><span class="koboSpan" id="kobo.400.1"> attribute and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">isAvailableCreditGreaterOrEqualThan</span></strong><span class="koboSpan" id="kobo.402.1"> method to check that there’s enough credit for a </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">given transaction.</span></span></p></li> <li><span class="koboSpan" id="kobo.404.1">Then, we declare the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">CreditCheckUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
public interface CreditCheckUseCase {
    boolean hasEnoughCredit(String cardId, double
      transactionAmount);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.408.1">The goal is to check</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.409.1"> whether the credit card has enough</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.410.1"> credit for the transaction amount. </span><span class="koboSpan" id="kobo.410.2">To do so, we expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">cardId</span></strong><span class="koboSpan" id="kobo.412.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">transactionAmount</span></strong><span class="koboSpan" id="kobo.414.1"> attributes. </span><span class="koboSpan" id="kobo.414.2">We intend to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">cardId</span></strong><span class="koboSpan" id="kobo.416.1"> to get credit card data from somewhere. </span><span class="koboSpan" id="kobo.416.2">So, having an output port is required to get data from </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">other places.</span></span></p></li> <li><span class="koboSpan" id="kobo.418.1">Here, we </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">declare </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">CreditCheckOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
public interface CreditCheckOutputPort {
    CreditCard getCreditCard(String cardId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.423.1">This is a straightforward output port where we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">cardId</span></strong><span class="koboSpan" id="kobo.425.1"> attribute and expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">CreditCard</span></strong><span class="koboSpan" id="kobo.427.1"> object to contain, among other things, how much credit </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">is available.</span></span></p></li> <li><span class="koboSpan" id="kobo.429.1">Suppose credit card data is stored in a MySQL database. </span><span class="koboSpan" id="kobo.429.2">We would need an output adapter that implements the previously defined </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">output port:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.431.1">
public class CreditCheckMySQLOutputAdapter implements
  CreditCheckOutputPort {
    @Override
    public CreditCard getCreditCard(String cardId) {
        /** Code omitted **/
        return creditCard;
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.432.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">getCreditCard</span></strong><span class="koboSpan" id="kobo.434.1"> method, we would probably have some sort of mapping mechanism to convert the data that’s retrieved from the database into the domain entity object – that </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">CreditCard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.438.1">Finally, we can create</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.439.1"> the input port </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.440.1">by implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">CreditCheckUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.443.1">
public class CreditCheckInputPort implements
  CreditCheckUseCase {
    CreditCheckOutputPort creditCheckOutputPort;
    @Override
    public boolean hasEnoughCredit(
    String cardId, double transactionAmount) {
        return
        getCreditCard(cardId)
        .isAvailableCreditGreaterOrEqualThan
        (transactionAmount);
    }
    private CreditCard getCreditCard(String cardId) {
        return creditCheckOutputPort
               .getCreditCard(cardId);
    }
}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">CreditCheckInputPort</span></strong><span class="koboSpan" id="kobo.445.1"> relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">CreditCheckOutputPort</span></strong><span class="koboSpan" id="kobo.447.1"> to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">CreditCard</span></strong><span class="koboSpan" id="kobo.449.1">, which is used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">hasEnoughCredit</span></strong><span class="koboSpan" id="kobo.451.1"> method, to check whether there is enough </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">credit available.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.453.1">One advantage of implementing the Application hexagon is that we don’t need to be specific about which technologies we should use to fulfill the automation needs of our system. </span><span class="koboSpan" id="kobo.453.2">Of course, it’s possible to add a fancy development framework to make our lives easier when handling</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.454.1"> certain activities–such as object life cycle management, which is provided by </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">Contexts and Dependency Injection</span></strong><span class="koboSpan" id="kobo.456.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.457.1">CDI</span></strong><span class="koboSpan" id="kobo.458.1">) mechanisms – but it’s that purist approach of not focusing on technological details that makes hexagon systems easier to integrate with </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">different technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">As we continue exploring</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.461.1"> the possibilities offered by the hexagonal </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.462.1">architecture, we’ll see that using a development framework is not a central point for software development. </span><span class="koboSpan" id="kobo.462.2">Instead, in hexagonal systems, frameworks are like ordinary utilitarian libraries that we use to strategically solve a </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">specific problem.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.464.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.465.1">In this chapter, we learned how to arrange the components that are responsible for organizing and building the features provided by the software. </span><span class="koboSpan" id="kobo.465.2">By looking into use cases, we grasped the fundamental principles to translate the behaviors that allow a system to meet users’ goals into code. </span><span class="koboSpan" id="kobo.465.3">We discovered how input ports play a central role by implementing use cases and acting as middlemen, intermediating the communication flow between internal and external things. </span><span class="koboSpan" id="kobo.465.4">With output ports, we can express the need for data from external sources without coupling the hexagonal system with specific technologies. </span><span class="koboSpan" id="kobo.465.5">Finally, by using use cases and input and output ports together, we saw how the Applica</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.466.1">tion hexagon supports the software’s </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">automation effort.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">By learning how to arrange things inside the Application hexagon, we can now combine business rules, entities, Domain services, use cases, and other components from both the Application and Domain hexagons to create fully fledged features in the hexagon application, ready to be integrated with different technologies. </span><span class="koboSpan" id="kobo.468.2">Such integration can be accomplished with the so-called adapters in the Framework hexagon. </span><span class="koboSpan" id="kobo.468.3">That’s what we will look at in the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">next chapter.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.470.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.471.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.473.1">What is the purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">use cases?</span></span></li>
<li><span class="koboSpan" id="kobo.475.1">Input ports implement use cases. </span><span class="koboSpan" id="kobo.475.2">Why do we have to </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">do that?</span></span></li>
<li><span class="koboSpan" id="kobo.477.1">Where should output ports </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">be used?</span></span></li>
<li><span class="koboSpan" id="kobo.479.1">What is the advantage of implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">Application hexagon?</span></span></li>
</ol>
<h1 id="_idParaDest-68"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.481.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.482.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.484.1">Writing Effective Use Cases</span></em><span class="koboSpan" id="kobo.485.1"> (Alistair </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">Cockburn, 2000)</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.487.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.488.1"> (Robert Cecil </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">Martin, 2017)</span></span></li>
</ul>
<h1 id="_idParaDest-69"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.490.1">Answers</span></h1>
<p><span class="koboSpan" id="kobo.491.1">The following are the answers to this </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">chapter’s questions:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.493.1">It’s to define software behaviors by establishing who the actors are and what features they expect from </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">a system.</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">Because in the hexagonal architecture, use cases are interfaces that state the supported software capabilities. </span><span class="koboSpan" id="kobo.495.2">Input ports, in turn, describe the actions that will enable </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">those capabilities.</span></span></li>
<li><span class="koboSpan" id="kobo.497.1">Output ports appear inside input ports when it is necessary to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">external systems.</span></span></li>
<li><span class="koboSpan" id="kobo.499.1">By implementing the Application hexagon, we’re supporting the overall hexagonal application’s effort to automate operations without relying on specific technologies to </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">do so.</span></span></li>
</ol>
</div>
</body></html>