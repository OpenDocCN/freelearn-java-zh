<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sorting Algorithms and Fundamental Data Structures</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we saw how the intersection problem can be improved by using a sorting algorithm. This is common with many problems. If the data is organized in an ordered manner, a more efficient algorithm can be developed. In this chapter, we will start by exploring three types of sorting techniques, which are bubble, quick, and merge sorting. Later, we will learn different ways to organize data using fundamental data structures.</p>
<p class="mce-root"><span class="calibre14">By the end of this chapter, you will be able to:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Describe how bubble sorting works</span></li>
<li class="calibre13"><span class="calibre10">Implement faster sorting with quick sort</span></li>
<li class="calibre13"><span class="calibre10">Characterize merge sorting</span></li>
<li class="calibre13"><span class="calibre10">Build a linked list data structure</span></li>
<li class="calibre13"><span class="calibre10">Implement queues</span></li>
<li class="calibre13"><span class="calibre10">Describe the stack data structure</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introducing Bubble Sorting</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Bubble sorting is the simplest sorting algorithm out there. The technique involves making multiple passes over the input array and swapping unordered elements close to one another. The technique is called bubble sort, as the sorted list "bubbles" up from the tail end of the list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Bubble Sorting</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">All sorting algorithms accept a list of elements and return them ordered. The main difference between each algorithm is the manner in which the sorting is done. Bubble sorting works by swapping adjacent elements. This pushes the sorted elements toward the end of the list.</p>
<p class="mce-root"><em class="calibre19">Snippet 2.1</em> shows the pseudocode for bubble sort. The algorithm involves three simple tasks, which involves repeatedly stepping through the list to sort, comparing adjacent elements, and swapping them around if the first element is bigger than the second.</p>
<p class="mce-root">How many passes do we need to perform on the array until our list is sorted? It turns out that to guarantee that our list is sorted, we need to do <em class="calibre19">(n - 1)</em> passes on the list, <em class="calibre19">n</em> being the length of our array. We will show why <em class="calibre19">(n - 1)</em> passes are needed in the next section, but this is the main reason why bubble sort has a runtime complexity of <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>, since we're processing <em class="calibre19">n</em> elements for <em class="calibre19">n - 1</em> times.</p>
<p class="mce-root">The pseudocode for bubble sort is as follows:</p>
<pre class="calibre20"><span class="calibre10">bubbleSort(array)<br class="calibre2"/>  n = length(array)<br class="calibre2"/>  for (k = 1 until n)<br class="calibre2"/>    for (j = 0 until -1)<br class="calibre2"/>      if(array[j] &gt; array[j + 1])<br class="calibre2"/>        swap(array, j, j + 1)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.1: Bubble sort pseudocode</span></div>
<div class="packt_infobox"><br class="calibre2"/>
The swap function in the <em class="calibre21">Snippet 2.1</em> switches the values of the two array pointers <kbd class="calibre31">j</kbd> and <kbd class="calibre31">j+1</kbd> using a temporary variable.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Bubble Sort</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To implement bubble sort in Java, follow these steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Apply the pseudocode shown in</span> <em class="calibre21"><span class="calibre10">Snippet 2.1</span></em> <span class="calibre10">in Java. Create a class and a method, accepting an array to sort as follows:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">public void sort(int[] numbers)</span> </pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The slightly tricky part of this algorithm is the swapping logic. This is done by assigning one of the elements to be swapped to a temporary variable, as shown in</span> <em class="calibre21"><span class="calibre10">Snippet 2.2</span></em><span class="calibre10">:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public void sort(int[] numbers) {<br class="calibre2"/>  for (int i = 1; i &lt; numbers.length; i++) {<br class="calibre2"/>    for (int j = 0; j &lt; numbers.length - 1; j++) {<br class="calibre2"/>      if (numbers[j] &gt; numbers[j + 1]) {<br class="calibre2"/>        int temp = numbers[j];<br class="calibre2"/>        numbers[j] = numbers[j + 1];<br class="calibre2"/>        numbers[j + 1] = temp;<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.2: Bubble sort solution. Source class name:</span> <span class="calibre10">BubbleSort</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/7atHVR" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/7atHVR</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root"><span class="calibre14">Although bubble sort is very easy to implement, it's also one of the slowest sorting methods out there. In the next section, we will look at how we can slightly improve the performance of this algorithm.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving Bubble Sorting</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two main techniques we can adopt to improve the performance of bubble sort. It's important to realize that although both of these strategies improve the overall performance of bubble sort in the average case; in the worst case, the algorithm still has the same poor runtime complexity of <em class="calibre19">O(n²)</em>.</p>
<p class="mce-root">The first small enhancement we can make to the original bubble sort is to make use of the fact that a sorted "bubble" is building at the end of the list. With every pass we make, another item is added at the end portion of this bubble. This is the reason why <em class="calibre19">(n - 1)</em> passes are needed.</p>
<p class="mce-root">This is also shown in <em class="calibre19">Figure 2.1</em>. In this diagram, the items shown in the dotted circle are already sorted in the correct place:</p>
<p class="cdpaligncenter"><img src="Images/35c38596-9b67-43de-9b6a-857729e91c1d.png" width="1152" height="940" class="calibre43"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.1: Bubble forming toward the end of the list</span></div>
<p class="mce-root"><span class="calibre14">We can use this fact so we don't try to sort the elements inside this bubble. We can do this by slightly modifying our Java code, as shown in</span> <em class="calibre19"><span class="calibre14">Snippet 2.3</span></em><span class="calibre14">. In the inner loop, instead of processing until the end of the list, we can stop just before the sorted bubble, until</span> <kbd class="calibre15"><span class="calibre10">numbers.length - i</span></kbd><span class="calibre14">. For brevity, in</span> <em class="calibre19"><span class="calibre14">Snippet 2.3</span></em> <span class="calibre14">we have replaced the swap logic with a method as follows:</span></p>
<pre class="calibre20"><span class="calibre10">public void sortImprovement1(int[] numbers) {<br class="calibre2"/>  for (int i = 1; i &lt; numbers.length; i++) {<br class="calibre2"/>    for (int j = 0; j &lt; numbers.length - i; j++) {<br class="calibre2"/>      if (numbers[j] &gt; numbers[j + 1]) {<br class="calibre2"/>        swap(numbers, j, j + 1);<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.3: Bubble sort improvement 1. Source class name:</span> <span class="calibre10">BubbleSort</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/vj267K" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/vj267K</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">If we give a sorted list to our bubble sort algorithm, we will still make multiple passes on it without modifying it. We can further improve the algorithm by cutting short the outer loop when the list inside the array is fully sorted. We can check that the array is sorted by checking if any swaps were done during our last pass. In this manner, if we give our method an already sorted list, we just need to do one pass on the array and leave it untouched. This means that the best case is now <em class="calibre19">O(n)</em>, although the worst case stays the same.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Bubble Sort Improvement</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need to improve the bubble sort algorithm by reducing the number of passes.</p>
<p class="mce-root">The steps to do this are as follows:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Change the bubble sort method so that it stops sorting if the array is untouched after an inner loop pass.</span></li>
<li class="chapter">The solution can be developed easily if the outer for loop is changed into a <kbd class="calibre15">while</kbd> <span class="calibre10">loop and a flag is kept to indicate if any elements have been swapped while going through the array. This is shown in the following code snippet:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public void sortImprovement2(int[] numbers) {<br class="calibre2"/>  int i = 0;<br class="calibre2"/>  boolean swapOccured = true;<br class="calibre2"/>  while (swapOccured) {<br class="calibre2"/>     swapOccured = false;<br class="calibre2"/>     i++;<br class="calibre2"/>     for (int j = 0; j &lt; numbers.length - i; j++) {<br class="calibre2"/>          if (numbers[j] &gt; numbers[j + 1]) {<br class="calibre2"/>              swap(numbers, j, j + 1);<br class="calibre2"/>              swapOccured = true;<br class="calibre2"/>          }<br class="calibre2"/>     }<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.4: Bubble sort improvement 2. Source class name:</span> <span class="calibre10">BubbleSort</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/HgVYfL" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/HgVYfL</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root"><span class="calibre14">In this section, we have seen some simple tricks on how to improve the bubble sort algorithm. In the following sections, we shall look at some other sorting techniques that perform much faster than bubble sort.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing Selection Sort in Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root"><span class="calibre14">Selection sort is best understood by imagining that you have two lists, A and B. Initially, we have list A, containing all the unsorted elements, and list B is empty. The idea is to use B to store the sorted elements. The algorithm would work by finding the smallest element from A and moving it to the end of B. We keep on doing this until A is empty and B is full. Instead of using two separate lists, we can just use the same input array, but keeping a pointer to divide the array in two.</span></p>
<p class="mce-root"><span class="calibre14">In real life, this can be explained by picturing how you would sort a deck of cards. Using a shuffled deck, you can go through the cards one by one until you find the lowest card. You set this aside as a new, second pile. You then look for the next-lowest card and once found, you put it at the bottom of the second pile. You repeat this until the first pile is empty.</span></p>
<p class="mce-root"><span class="calibre14">One way to arrive at the solution is to first write the pseudocode that uses two arrays (</span><span class="calibre14">A</span> <span class="calibre14">and</span> <span class="calibre14">B</span><span class="calibre14">, in the preceding description). Then, adopt the pseudocode to store the sorted list (array</span> <span class="calibre14">B</span><span class="calibre14">) in the same input array by using the swapping method.</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root"><span class="calibre14">Implement the selection sort in Java</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Prerequisites</span></strong></p>
<ul class="calibre12">
<li class="calibre13">Implement the sort method found in the following class, which is available on the GitHub repository for the book at the following path: <br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java</a></li>
<li class="calibre13"><span class="calibre10">The</span> <span class="calibre10"><kbd class="calibre15">sort</kbd></span> <span class="calibre10">method should accept an integer array and sort it</span></li>
</ul>
<div class="packt_infobox"><span class="calibre10">If you have your project set up, you can run the unit test for this activity by running the following command:<br class="calibre2"/></span><strong class="calibre3"><kbd class="calibre31"><span class="calibre10">gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.selectionsort*</span></kbd></strong></div>
<p class="mce-root"><strong class="calibre6">Steps for Completion</strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Split the input array in two by using an array index pointer</span></li>
<li class="chapter"><span class="calibre10">The <kbd class="calibre15">sort</kbd> method should accept an integer array and sort it</span></li>
<li class="chapter"><span class="calibre10">Iterate over the unsorted portion of the array to find the minimum</span></li>
<li class="chapter"><span class="calibre10">The minimum item is then swapped so that it can be added to the end of the sorted portion</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Quick Sort</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">Quick sort is a big improvement over bubble sort. This sorting technique was developed by British computer scientist Tony Hoare. The algorithm works in three main steps:<br class="calibre7"/></span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Select a pivot</span></li>
<li class="chapter"><span class="calibre10">Partition the list so that elements on the left of the pivot are less than the value of the pivot and the ones on the right are greater</span></li>
<li class="chapter"><span class="calibre10">Repeat steps 1 and 2 on the left and right parts separately</span></li>
</ol>
<p class="mce-root"><span class="calibre14">Since recursion is required for quick sort, we will begin this section by giving an example of recursion. Later, we will see how the partitioning in the quick sort algorithm works, and in the end, we will put the recursion techniques to use in the final part.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Recursion</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Recursion is a really useful tool for algorithm designers. It allows you to solve large problems by solving a smaller occurrence of the same problem. Recursive functions usually have a common structure with the following components:</p>
<ul class="calibre12">
<li class="calibre13"><em class="calibre21">One or more stopping conditions</em>: Under certain conditions, it would stop the function from calling itself again</li>
<li class="calibre13"><em class="calibre21">One or more recursive calls</em>: This is when a function (or method) calls itself</li>
</ul>
<p class="mce-root">In the next example, we will pick the binary search problem seen in the previous chapter and change the algorithm to work in a recursive manner. Consider the binary search problem discussed in <a href="52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 1</a>, <em class="calibre19">Algorithms and Complexities</em>, listed in <em class="calibre19">Snippet 1.7</em>. The implementation is iterative, that is, it loops until an item is found or the <kbd class="calibre15">end</kbd> parameter is equal or greater than the <kbd class="calibre15">start</kbd> variable. The following code snippet shows pseudocode on how we can change this method into a recursive function:</p>
<pre class="calibre20"><span class="calibre10">binarySearch(x, array, start, end)<br class="calibre2"/>  if(start &lt;= end)<br class="calibre2"/>    mid = (end - start) / 2 + start<br class="calibre2"/>    if (array[mid] == x) return true</span> <br class="calibre2"/>    <span class="calibre10">if (array[mid] &gt; x) return binarySearch(x, array, start, mid - 1)<br class="calibre2"/>    return binarySearch(x, array, mid + 1, end)<br class="calibre2"/>  return false</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.5: Recursive binary search pseudocode</span></div>
<div class="packt_infobox">There are actually two stopping conditions in a recursive binary search. The function stops the recursive chain if it either finds the search item at the midpoint or if the start array pointer is greater than the end, meaning the item wasn't found. The stopping condition can easily be found by examining any return paths that don't involve further recursive calls.<span class="calibre10"><br class="calibre2"/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Binary Search Recursively</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">To implement binary search recursively in Java, we'll follow these steps:</span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Using the pseudocode shown in</span> <em class="calibre21"><span class="calibre10">Snippet 2.5</span></em><span class="calibre10">, implement a recursive binary search function.</span></li>
<li class="chapter"><span class="calibre10">Provide another method with a signature that only contains the search item and the sorted array as input. This method will then call the recursive function with appropriate values as follows:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">public boolean binarySearch(int x, int[] sortedNumbers)</span> </pre>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Output</span></strong></p>
<p class="mce-root"><span class="calibre14">The following code shows the additional method making the initial call and the recursive function as follows:</span></p>
<pre class="calibre20"><span class="calibre10">public boolean binarySearch(int x, int[] sortedNumbers, int start,<br class="calibre2"/>int end) {<br class="calibre2"/>  if (start &lt;= end) {<br class="calibre2"/>    int mid = (end - start) / 2 + start;<br class="calibre2"/>    if (sortedNumbers[mid] == x) return true;<br class="calibre2"/>    if (sortedNumbers[mid] &gt; x)<br class="calibre2"/>    return binarySearch(x, sortedNumbers, start, mid - 1);<br class="calibre2"/>    return binarySearch(x, sortedNumbers, mid + 1, end);<br class="calibre2"/>  }<br class="calibre2"/>return false;}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.6: Recursive binary search. Source class name:</span> <span class="calibre10">BinarySearchRecursive</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/pPaZVZ" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/pPaZVZ</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">Recursion is an essential tool for any developer and we'll make use of it in many parts in this book. In this section, we implemented an example for binary searching. In the next section, we shall look at how partitioning works in the quicksort algorithm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Quicksort Partitioning</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Partitioning is the process by which we reorder our array so that elements with a value less than our pivot are moved to the left of the pivot and those with a larger value are moved to the right (see <em class="calibre19">Figure 2.2</em>). There are numerous manners in which we can do this. Here, we will describe an easy-to-understand scheme known as <strong class="calibre6">Lomuto Partitioning</strong>.</p>
<p class="mce-root">Take a look at this diagram:</p>
<p class="cdpaligncenter"><img src="Images/b53ef27e-6226-464d-9cbd-ff60637422d3.png" width="1628" height="715" class="calibre44"/></p>
<div class="packt_figref">Figure 2.2: Before and after partitioning of an array</div>
<div class="packt_infobox"><span class="calibre10"><span class="calibre10">Many other schemes exist. The Lomuto scheme has the drawback that it is not very performant when it is used on already-sorted lists. The original Hoare partition scheme performs better and works by having the array processed from both ends.</span></span><span class="calibre10"><span class="calibre10">The original Hoare scheme performs better as it does fewer swaps, although it also suffers from slow performance when a sorted list is used as input. Both the Lomuto and Hoare schemes result in non-stable sorting. A stable sort means that if two or more elements have the same key value, they will appear in the same input order as the sorted output. There are other schemes that can be used to make quick sort stable, but they utilize more memory.</span></span></div>
<p class="mce-root"><span class="calibre14">To get a good perception on this partitioning scheme, it is best to simplify what the algorithm is doing in five simple steps, as follows:</span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Pick the right most element of the array as the pivot.</span></li>
<li class="chapter"><span class="calibre10">Start from the left and find the next element that is larger than the pivot.</span></li>
<li class="chapter"><span class="calibre10">Swap this element with the next, which is smaller than pivot element.</span></li>
<li class="chapter"><span class="calibre10">Repeat steps 2 and 3 until no more swapping is possible.</span></li>
<li class="chapter"><span class="calibre10">Swap the first item which is larger than the pivot's value with the pivot itself.</span></li>
</ol>
<p class="mce-root">To perform efficient partitioning using the steps mentioned, we can make use of two pointers, one pointing to the first item larger than the pivot value and the other used to search for the value that is smaller than pivot value.</p>
<p class="mce-root">In the following code, these are the integer pointers named <kbd class="calibre15">x</kbd> and <kbd class="calibre15">i</kbd>, respectively. The algorithm starts by choosing the pivot as the last item on the input array. It then processes the array from left to right in a single pass using the variable <kbd class="calibre15">i</kbd>. If the element currently being processed at <kbd class="calibre15">i</kbd> is smaller than the pivot, <kbd class="calibre15">x</kbd> is incremented and swapped. Using this technique, variable <kbd class="calibre15">x</kbd> is either pointing to a value larger than the pivot or the value of <kbd class="calibre15">x</kbd> is the same as <kbd class="calibre15">i</kbd>, in which case swapping will not modify the array. Once the loop exits, we perform the final step of swapping the first item that is larger than the pivot's value with the pivot. The code is as follows:</p>
<pre class="calibre20"><span class="calibre10">private int partition(int[] numbers, int start, int end) {<br class="calibre2"/>  int pivot = numbers[end];<br class="calibre2"/>  int x = start - 1;<br class="calibre2"/>  for (int i = start; i &lt; end; i++) {<br class="calibre2"/>    if (numbers[i] &lt; pivot) {<br class="calibre2"/>      x++;<br class="calibre2"/>      swap(numbers, x, i);<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>  swap(numbers, x + 1, end);<br class="calibre2"/>  return x + 1;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.7: Partitioning for quick sort. Source class name:</span> <span class="calibre10">QuickSort</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/vrStai" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/vrStai</span></a> <span class="calibre10">to access the code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Understanding the Partitioning Method</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root"><span class="calibre14">To better understand the partitioning method used in</span> <em class="calibre19"><span class="calibre14">Snippet 2.7</span></em><span class="calibre14">, walk through it one</span><span class="calibre14"> step at a time using an example.</span></p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root"><span class="calibre14">To understand how the Lomuto partitioning works.</span></p>
<p class="mce-root"><strong class="calibre6">Steps for completion</strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Dry run the code mentioned in</span> <em class="calibre21"><span class="calibre10">Snippet 2.7</span></em> <span class="calibre10">for each element in the array by incrementing the values of variables <kbd class="calibre15">x</kbd> and</span> <kbd class="calibre15"><span class="calibre10">i</span></kbd><span class="calibre10">.</span></li>
<li class="chapter"><span class="calibre10">Complete the following table, assuming that the pivot is the last element of the list, that is, 16:</span></li>
</ol>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25"><strong class="calibre3">Array</strong></td>
<td class="calibre25"><strong class="calibre3">x</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">-</kbd></td>
<td class="calibre25"><kbd class="calibre15">[4, 5, 33, 17, 3, 21, 1, 16]</kbd></td>
<td class="calibre25"><kbd class="calibre15">-1</kbd></td>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">0</kbd></td>
<td class="calibre25"><kbd class="calibre15">[4, 5, 33, 17, 3, 21, 1, 16]</kbd></td>
<td class="calibre25"><kbd class="calibre15">0</kbd></td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">1</kbd></td>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">2</kbd></td>
<td class="calibre25"><kbd class="calibre15">[4, 5, 33, 17, 3, 21, 1, 16]</kbd></td>
<td class="calibre25"><kbd class="calibre15">1</kbd></td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">3</kbd></td>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">4</kbd></td>
<td class="calibre25"><kbd class="calibre15">[4, 5, 3, 17, 33, 21, 1, 16]</kbd></td>
<td class="calibre25"><kbd class="calibre15">2</kbd></td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">5</kbd></td>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">6</kbd></td>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">7</kbd></td>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
<tr class="calibre27">
<td class="calibre25">final</td>
<td class="calibre25"><kbd class="calibre15">[4, 5, 3, 1, 16, 21, 17, 33]</kbd></td>
<td class="calibre25"><kbd class="calibre15">3</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 2.1: Steps through the partitioning method</span></div>
<p class="mce-root"><span class="calibre14">In this section, we have gained an understanding of how partitioning in quick sort works. In the next section, we'll put the partitioning method to use by including it in the full quick sort algorithm.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Putting It All Together</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The quick sort is from a class of algorithms called divide and conquer. We will see many other examples from this class in the book, and we will go into detail on divide and conquer in <a href="da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 4</a>, <em class="calibre19">Algorithm Design Paradigms</em>. For now, it's important to know that divide and conquer algorithms keep on splitting the problem into smaller ones until the problem is small enough that it becomes trivial to solve. This splitting can be easily implemented using recursion.</p>
<p class="mce-root">In quick sorting, we keep on recursively partitioning the array in this manner until the problem is small enough that we can easily solve it. When the array has only one element, the solution is simple: the array stays exactly as it is, as there is nothing to sort. This is the stopping condition of our recursive algorithm. When the array is larger than one element, we can keep dividing our array and use the partitioning method we developed in the previous section.</p>
<div class="packt_infobox">There is also a non-recursive quick sort algorithm which makes use of a stack data structure, although it is a bit more complex to write. We will discuss stacks and lists later on in this chapter.</div>
<p class="mce-root">The following code snippet shows the pseudocode for the complete quick sort. Just like most recursive functions, the code starts by checking the stopping condition. In this case, we check if the array has at least two elements by ensuring that the start array pointer is less than the end. The pseudocode is as follows:</p>
<pre class="calibre20"><span class="calibre10">quickSort(array, start, end)<br class="calibre2"/>  if(start &lt; end)<br class="calibre2"/>    p = partition(array, start, end)<br class="calibre2"/>    quickSort(array, start, p - 1)<br class="calibre2"/>    quickSort(array, p + 1, end)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.8: Recursive quick sort pseudocode</span></div>
<p class="mce-root">When we have at least two elements in the array, we call the partitioning method. Then, using the pivot's last position (returned by the partitioning method), we recursively quick sort the left part and then the right part.</p>
<p class="mce-root">This is done by calling the same quick sort code using pointers of <kbd class="calibre15">(start, p - 1)</kbd> and<br class="calibre7"/>
<kbd class="calibre15">(p + 1, end)</kbd>, not including the <kbd class="calibre15">p</kbd>, which is the pivot's position.</p>
<p class="mce-root">The trick to understanding how quick sort works is to realize that once we perform the partition call on the array, the element at the returned position (the pivot) doesn't need to move within the array anymore. This is because all the elements on its right are larger and the ones on the left are smaller, so the pivot is in the correct final position.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Quick Sort</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">To implement quick sort in Java, follow these steps:</span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement the pseudocode shown in</span> <em class="calibre21"><span class="calibre10">Snippet 2.8</span></em> <span class="calibre10">in Java, calling the partitioning method shown in</span> <em class="calibre21"><span class="calibre10">Snippet 2.7</span></em><span class="calibre10">.</span></li>
<li class="chapter"><span class="calibre10">The following code shows the recursive implementation in Java, making use of the partition method developed in the preceding section:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">private void sort(int[] numbers, int start, int end) {<br class="calibre2"/>  if (start &lt; end) {<br class="calibre2"/>    int p = partition(numbers, start, end);<br class="calibre2"/>      sort(numbers, start, p - 1);<br class="calibre2"/>      sort(numbers, p + 1, end);<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.9: Solution for quick sort. Source class name:</span> <span class="calibre10">Quicksort</span></div>
<p class="mce-root">In this section, we have described the quick sort algorithm, which is much faster than the bubble sort algorithm that we saw in the previous section. On average, this algorithm performs in <em class="calibre19">O(n log n)</em>, a huge improvement over bubble sort's <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>. However, in the worst case, the algorithm still performs in <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>. The worst-case input of quick sort depends on the type of partitioning scheme in use. In the Lomuto scheme discussed in this section, the worst case occurs when the input is already sorted. In the next section, we will examine another sorting algorithm for which the worst runtime case is <em class="calibre19">O(n log n)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Merge Sort</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Although the quicksort on average is pretty fast, it still has the theoretical worst time complexity of <em class="calibre19">O(n²)</em>. In this section, we shall examine another sorting algorithm, called <strong class="calibre6">merge sort</strong>, in which the worst time complexity is <em class="calibre19">O(n log n)</em>. Similar to quick sort, merge sort belongs to the divide and conquer class of algorithms.</p>
<p class="mce-root">Merge sort can be summarized in three simple steps as follows: </p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Split the array in the middle</span></li>
<li class="chapter"><span class="calibre10">Recursively sort each part separately</span></li>
<li class="chapter"><span class="calibre10">Merge the two sorted parts together</span></li>
</ol>
<p class="mce-root"><span class="calibre14">In the following section, we will develop the preceding steps gradually, at each turn slowly building our understanding of how merge sorting works.</span></p>
<div class="packt_infobox"><span class="calibre10">Although merge sort is theoretically faster than quick sort, in practice, some implementations of quick sort can be more efficient than merge sort. Additionally, the merge sort uses about</span> <em class="calibre21"><span class="calibre10">O(n)</span></em> <span class="calibre10">memory as opposed to quick sort, which is</span> <em class="calibre21"><span class="calibre10">O(log n)</span></em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dividing the Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the preceding section, we saw how we can use a recursive technique to split the problem into smaller multiple ones until the solution becomes easy to solve. Merge sort uses the same approach. The base case for our recursive technique is the same as quick sort. This is when the array is only one element long. When the array to sort only contains one item, the array is already sorted.</p>
<p class="mce-root"><em class="calibre19">Figure 2.3</em> shows how merge sort array splitting occurs. At each step, we find the midpoint of the array and split the array in two. We then recursively sort the left and right part of the split array separately. We can stop the recursive call once the total elements to sort is equal to one as shown in the following figure:</p>
<p class="cdpaligncenter"><img src="Images/31934f86-5e69-48c3-8cf4-2917b9760159.png" width="1271" height="759" class="calibre45"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.3 Showing the dividing steps for the merge sort algorithm</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Merge Sort</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need to <span class="calibre14">complete the </span>pseudocode <span class="calibre14">for a merge sort algorithm.</span></p>
<p class="mce-root"><span class="calibre14">Keeping in mind that the merge sort's recursive part is very similar to the quick sort algorithm we saw in the preceding section, complete the pseudocode shown in the following code as follows:</span></p>
<pre class="calibre20"><span class="calibre10">mergeSort(array, start, end)<br class="calibre2"/>  if(_____________)<br class="calibre2"/>    midPoint = _________<br class="calibre2"/>    mergeSort(array, _____, _____)<br class="calibre2"/>    mergeSort(array, _____, _____)<br class="calibre2"/>    merge(array, start, midPoint, end)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.10: Recursive merge sort pseudocode exercise</span></div>
<p class="mce-root"><span class="calibre14">The pseudocode for merge sort can be completed as follows:</span></p>
<pre class="calibre20"><span class="calibre10">mergeSort(array, start, end)<br class="calibre2"/>  if(start &lt; end)<br class="calibre2"/>    midPoint = (end - start) / 2 + start<br class="calibre2"/>    mergeSort(array, start, midPoint)<br class="calibre2"/>    mergeSort(array, midPoint + 1, start)<br class="calibre2"/>    merge(array, start, midPoint, end)</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.11: Recursive merge sort pseudocode solution</span> </div>
<p class="mce-root">The merge sort algorithm is from the same class of algorithms as quick sort; however, its runtime and space complexity are different. Instead of dividing the array from the pivot's position, the merge sort always partitions the array at the midpoint. This is a similar process to binary search and results in <em class="calibre19">log<sub class="calibre40">2</sub> n</em> array divisions. In the next section, we will introduce the merge part of the merge sort algorithm, where the two different parts of the split array are combined into a sorted one.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Merging the Problem</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">How do you merge two sorted lists into a sorted one? This is the task of the <kbd class="calibre15">merge()</kbd> function, which is found at the end of the pseudocode shown in the preceding section. This process is shown in <em class="calibre19">Figure 2.4</em>. Merging two sorted lists is an easier task than sorting from scratch.</p>
<p class="mce-root">This is similar to the intersection problem we saw in <a href="52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 1</a>, <em class="calibre19">Algorithms and Complexities</em>.</p>
<p class="mce-root">We can merge in linear time utilizing just two pointers and an empty array as shown in the following diagram:</p>
<p class="cdpaligncenter"><img src="Images/deeaf0cf-05a5-4e78-991f-1bf79f1cd9e2.png" width="1265" height="500" class="calibre46"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.4: Before and after merging two sorted arrays</span></div>
<div class="packt_infobox">Since the two parts of the split array are both sorted, it's easy to merge the two together. A useful analogy is to refer back to how the intersection problem we saw in <a href="52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">Chapter 1</a>, <em class="calibre21">Algorithms and Complexities</em>, got a lot easier once the input arrays were both sorted. A similar algorithm can be used here.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">The pseudocode for the merging is shown in the following code snippet. In this code, the <kbd class="calibre15">copyArray()</kbd> function simply takes in a source array as a first argument and copies it to the target array, that is, the second argument. It makes use of the <kbd class="calibre15">start</kbd> variable as a pointer, indicating where to place the first element of the source array onto the target one. The pseudocode is as follows:</p>
<pre class="calibre20"><span class="calibre10">merge(array, start, middle, end)<br class="calibre2"/>  i = start<br class="calibre2"/>  j = middle + 1<br class="calibre2"/>  arrayTemp = initArrayOfSize(end - start + 1)<br class="calibre2"/>  for (k = 0 until end-start)<br class="calibre2"/>    if (i &lt;= middle &amp;&amp; (j &gt; end || array[i] &lt;= array[j]))<br class="calibre2"/>      arrayTemp[k] = array[i]<br class="calibre2"/>      i++<br class="calibre2"/>    else<br class="calibre2"/>      arrayTemp[k] = array[j]<br class="calibre2"/>      j++<br class="calibre2"/>  copyArray(arrayTemp, array, start)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.12: Merge pseudocode for the merge sort</span></div>
<p class="mce-root">In the merging part of the merge sort, we create a temporary array which is of size equal to the size of two array parts together. We then do a single pass on this array, filling the temporary array one item at a time by picking the smallest item between the two input lists (represented by the start, middle, and end pointers). After picking an item from one of the lists, we advance the pointer of that list and repeat until the merge is complete.</p>
<div class="packt_infobox"><span class="calibre10">There are various </span>Java tools we can use to implement the <kbd class="calibre31">copyArray()</kbd> function shown at the end of <em class="calibre21">Snippet 2.12</em>. We can simply implement a <kbd class="calibre31">for</kbd> loop and implement the <kbd class="calibre31">copy()</kbd> function ourselves. Alternatively, we can make use of Java's streams and write the copy in a single line. Possibly the easiest manner is to make use of the <kbd class="calibre31">System.arrayCopy()</kbd> function.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">Merge sort is theoretically one of the fastest sorting algorithms. The drawback of its speed is that it consumes a bit more memory, although some implementations exist that perform the merge step in place to save memory.</p>
<p class="mce-root">For comparison, we present multiple sorting techniques with their runtime and memory performances in the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Algorithm name</strong></td>
<td class="calibre25"><strong class="calibre3">Average case</strong></td>
<td class="calibre25"><strong class="calibre3">Worst case</strong></td>
<td class="calibre25"><strong class="calibre3">Memory</strong></td>
<td class="calibre25"><strong class="calibre3">Stability</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">Bubble</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21">O(n<sup class="calibre32">2</sup>)</em></td>
<td class="calibre25"><em class="calibre21">O(1)</em></td>
<td class="calibre25">Stable</td>
</tr>
<tr class="calibre24">
<td class="calibre25">Selection</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21">O(1)</em></td>
<td class="calibre25">Unstable</td>
</tr>
<tr class="calibre26">
<td class="calibre25">Insertion</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21">O(1)</em></td>
<td class="calibre25"><span class="calibre10">Stable</span></td>
</tr>
<tr class="calibre24">
<td class="calibre25">Quick</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n log n)</span></em></td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n</span><sup class="calibre32">2</sup><span class="calibre10">)</span></em></td>
<td class="calibre25"><em class="calibre21">O(1)</em></td>
<td class="calibre25"><span class="calibre10">Unstable</span></td>
</tr>
<tr class="calibre26">
<td class="calibre25">Merge</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n log n)</span></em></td>
<td class="calibre25"><em class="calibre21">O(n log n)</em></td>
<td class="calibre25"><em class="calibre21">O(n)</em></td>
<td class="calibre25"><span class="calibre10">Stable</span></td>
</tr>
<tr class="calibre27">
<td class="calibre25">Heap</td>
<td class="calibre25"><em class="calibre21"><span class="calibre10">O(n log n)</span></em></td>
<td class="calibre25"><em class="calibre21">O(n log n)</em></td>
<td class="calibre25"><em class="calibre21">O(1)</em></td>
<td class="calibre25"><span class="calibre10">Unstable</span></td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 2.2: Sorting algorithms</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing Merge Sort in Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root"><span class="calibre14">Merge sorting is one of the fastest sorting techniques. It is used in many bundled libraries and APIs. In this activity, we will write an algorithm in Java to sort an array using merge sort.</span></p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root"><span class="calibre14">To use the pseudocode shown in this section to implement the full merge sort algorithm in Java.</span></p>
<p class="mce-root"><strong class="calibre6">Prerequisites</strong></p>
<p class="mce-root"><span class="calibre14">To solve this activity, you have to implement the methods found in the following class, which is available on the GitHub repository for the book at the following path:</span></p>
<p class="mce-root"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java</a></p>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">If you have your project set up, you can run the unit test for this activity by running the following command:<br class="calibre2"/></span><strong class="calibre3"><kbd class="calibre31"><span class="calibre10">gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.mergesort*</span></kbd></strong></div>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Start from the</span> <kbd class="calibre15"><span class="calibre10">mergeSort</span></kbd> <span class="calibre10">method, which splits the array in two, recursively sorts both, and merges the result</span></li>
<li class="chapter"><span class="calibre10">Then, implement the merge method, which merges both ends of the split </span><span class="calibre10">array into another space</span></li>
<li class="chapter"><span class="calibre10">After the merge is done, copy the new array back in place of the input array</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting Started with Fundamental Data Structures</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Data structures are a way to organize data so that it is efficiently accessible for the problem you are trying to solve. Choosing the right data structure will depend on the type of problem you're trying to solve (dictating the manner you access your data), the amount of data you need to organize, and the medium you use to store your data (memory, disk, and so on).</p>
<p class="mce-root">We have already seen and used one example of a data structure. In the preceding sections, we have made extensive use of arrays. Arrays are the most primitive of data structures. They provide access to your data using an index and are fixed in size (also called static). This is opposed to other dynamic data structures that can grow and make more space for data whenever it's needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introducing Data Structures</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">More formally, a data structure is an organization of data elements, a collection of functions that can be applied on the data (such as add, delete, and search) and any relations between the different data elements. The following table shows common operations that some data structures provide:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Operation</strong></td>
<td class="calibre25"><strong class="calibre3">Type</strong></td>
<td class="calibre25"><strong class="calibre3">Description</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">search(key)</kbd></td>
<td class="calibre25">Non-modifying</td>
<td class="calibre25">An operation that, given the key to a particular value, will return the value stored in the data structure if it can be found.</td>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">side()</kbd></td>
<td class="calibre25">Non-modifying</td>
<td class="calibre25">The total number of values stored in the data structure.</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">add(value)</kbd></td>
<td class="calibre25">Modifying</td>
<td class="calibre25">Inserts a value in the data structure.</td>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">update(key, value)</kbd></td>
<td class="calibre25">Modifying</td>
<td class="calibre25">Updates an existing entry using the provided key and value.</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><kbd class="calibre15">delete(value)</kbd></td>
<td class="calibre25">Modifying</td>
<td class="calibre25">Removes an item of data from the data structure.</td>
</tr>
<tr class="calibre24">
<td class="calibre25"><kbd class="calibre15">minimum()</kbd></td>
<td class="calibre25">Non-modifying</td>
<td class="calibre25">An operation supported only by ordered data structures, which will return the value with the minimal key.</td>
</tr>
<tr class="calibre38">
<td class="calibre25"><kbd class="calibre15">maximum()</kbd></td>
<td class="calibre25">Non-modifying</td>
<td class="calibre25">An operation supported only by ordered data structures, which will return the value with the minimal key.</td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 2.3: Some common operations on data structures</span></div>
<p class="mce-root">In this section, we will see various types of dynamic data structures. We will start with linked lists, which are optimized for dynamic growth but are slow while searching. Then, we'll use these linked lists to implement other data structures on top, such as queues and stacks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Linked Lists Structure</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A linked list is a list of data items where each item only knows about the next item in the list if there is one. <em class="calibre19">Figure 2.5</em> shows one such example. Each box in the figure represents a container for a data item we need to store. This container, called a node, contains our data values and a pointer to the next node in the list. As the diagram shows, the node on the front of the list is called the head of the list and the last item of the list is called the tail.</p>
<p class="mce-root">Separate pointers to these nodes are stored for easy access of the data structure:</p>
<p class="cdpaligncenter"><img src="Images/335eb13f-be8e-4b8f-bcdd-09dab74fb329.png" width="1178" height="371" class="calibre47"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.5: Linked list example</span></div>
<p class="mce-root">The advantage of using a linked list as opposed to an array is that a linked list can grow dynamically. When using an array, you allocate space in the start and that space remains fixed. If you allocate too much and the space remains unused, you're wasting resources. On the other hand, if you make your array too small, the data might not ft. In a linked list, however, the space is not fixed. The structure grows dynamically as you add more data and it shrinks, freeing memory space as you remove it.</p>
<p class="mce-root">Using an object-oriented language, such as Java, let's model the linked list using separate node instances that are connected together to build our linked list. The following code shows how we can model a linked list node in a Java class.</p>
<p class="mce-root">The class contains a self-reference so we can link multiple nodes in list fashion, as shown in the <em class="calibre19">Figure 2.5</em>.</p>
<pre class="calibre20"><span class="calibre10">public class LinkedListNode&lt;V&gt; {<br class="calibre2"/>  private V value;<br class="calibre2"/>  private LinkedListNode&lt;V&gt; next;</span>  <br class="calibre2"/><span class="calibre10">  public LinkedListNode(V value, LinkedListNode&lt;V&gt; next) {<br class="calibre2"/>    this.value = value;<br class="calibre2"/>    this.next = next;<br class="calibre2"/>  }<br class="calibre2"/>  public Optional&lt;LinkedListNode&lt;V&gt;&gt; getNext() {<br class="calibre2"/>    return Optional.ofNullable(next);<br class="calibre2"/>  }<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.13: Linked list node class, with getters and setters omitted for brevity. Source class name:</span> <span class="calibre10">Linkedlistnode</span> </div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/SAefic" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/SAefic</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">Notice how we use Java's optional classes (instead of returning null pointers) to represent whether there is a link to the next node. The tail node of a linked list will always have an empty optional. We also make use of generics to model the type of data we want to store. This way, we can keep the structure as general as possible so that it can used by any data type.</p>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">The</span> <span class="calibre10"><kbd class="calibre31">Optional</kbd></span> <span class="calibre10">class was introduced in Java 8 to give the ability to represent optional values instead of using nulls.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Converting the Linked List to a Doubly Linked List Structure </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need t<span class="calibre14">o modify the Java node class to</span> support <span class="calibre14">the doubly linked list structure.</span></p>
<p class="mce-root"><span class="calibre14">A doubly linked list is a linked list in which each node contains a relation to the following and previous nodes. Modify the preceding code in</span> <em class="calibre19"><span class="calibre14">Snippet 2.13</span></em> <span class="calibre14">to support this.</span></p>
<p class="mce-root"><span class="calibre14">The following code shows the solution to this:</span></p>
<pre class="calibre20"><span class="calibre10">public class DblLinkedListNode&lt;V&gt; {<br class="calibre2"/>  private V value;<br class="calibre2"/>  private DblLinkedListNode&lt;V&gt; next;<br class="calibre2"/>  private DblLinkedListNode&lt;V&gt; previous;<br class="calibre2"/>  public DblLinkedListNode(V value,<br class="calibre2"/>  DblLinkedListNode&lt;V&gt; next,<br class="calibre2"/>  DblLinkedListNode&lt;V&gt; previous) {<br class="calibre2"/>    this.value = value;<br class="calibre2"/>    this.next = next;<br class="calibre2"/>    this.previous = previous;<br class="calibre2"/>  }<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.14: Doubly linked list node class, with getters and setters omitted for brevity. Source class name:</span> <span class="calibre10">Dbllinkedlistnode</span></div>
<div class="packt_infobox"><span class="calibre10">Go to</span> <a href="https://goo.gl/oJDQ8g" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/oJDQ8g</span></a> <span class="calibre10">to access the code.<br class="calibre2"/></span> <span class="calibre10">In a doubly linked list, the head node will have a null previous pointer while the tail node will have a null next pointer.</span></div>
<p class="mce-root"><span class="calibre14">In this section, we saw how to model a linked list node using classes, generics, and optional references. In the next section, we shall see how to implement some of the linked list operations.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Linked Lists Operations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we can use any linked list operations, we need to initialize the data structure and mark it as empty. Conceptually, this is when the head of the list is pointing to nothing. We can do this in Java by adding this logic in a constructor.</p>
<p class="mce-root">The following code snippet shows this. Notice that, once again, we use generics to hold the type of the items we want to store in the linked list:</p>
<pre class="calibre20"><span class="calibre10">public class LinkedList&lt;V&gt; {<br class="calibre2"/>  private LinkedListNode&lt;V&gt; head;<br class="calibre2"/>  public LinkedList() {<br class="calibre2"/>    head = null;<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.15: Initializing the linked list data structure using constructors. Source class name: </span><span class="calibre10">Linkedlist</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/vxpkRt" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/vxpkRt</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">How can we add and remove items from the head of the list? Adding a node in a linked list requires a two pointer reassignment. On the new node, you set the next pointer to point to whatever the head pointer is assigned to. Then, you set the head pointer to point to this newly created node. This process is shown in <em class="calibre19">Figure 2.6</em>. Deleting from the front of the list is the reverse. You set the head pointer to point to the next pointer of the node at the old head. For completeness, you can set this next pointer to point to nothing:</p>
<p class="cdpaligncenter"><img src="Images/9d869c0c-805c-4240-888a-808d38be4d54.png" width="1516" height="484" class="calibre48"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.6: Adding a node to the front of the list</span></div>
<p class="mce-root">To locate an item in a list, we need to traverse the entire list until we find the item we're searching or reach the end of the list. This can be done easily by starting at the head pointer and always following the node's next pointer until you either find the node with the value you're looking for or you run out of nodes. For example, the next pointer is a null one.</p>
<p class="mce-root">The following code <em class="calibre19">snippet</em> shows the <kbd class="calibre15">addFront()</kbd> and <kbd class="calibre15">deleteFront()</kbd> operations for a linked list. For the <kbd class="calibre15">addFront()</kbd> method, we simply create a new node with its next pointer set as the current head pointer. Then, we assign the head to the new node. Notice in the delete method how we make use of Java's <kbd class="calibre15">Optional</kbd> objects. If the head pointer is null, it will stay null and we don't change anything. Otherwise, we flatten it to the next pointer. Finally, we set the first node's next pointer as null. This last step is not necessary since the orphaned node will be garbage collected; however, we're including it for completeness.</p>
<p class="mce-root">The code is as follows:</p>
<pre class="calibre20"><span class="calibre10">public void addFront(V item) {<br class="calibre2"/>  this.head = new LinkedListNode&lt;&gt;(item, head);<br class="calibre2"/>}<br class="calibre2"/>public void deleteFront() {<br class="calibre2"/>  Optional&lt;LinkedListNode&lt;V&gt;&gt; firstNode = Optional.<br class="calibre2"/>  ofNullable(this.head);<br class="calibre2"/>  this.head = firstNode.flatMap(LinkedListNode::getNext).<br class="calibre2"/>  orElse(null);<br class="calibre2"/>  firstNode.ifPresent(n -&gt; n.setNext(null));<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.16: Adding and deleting from the front of the linked list. Source class name: </span><span class="calibre10">Linkedlist</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/D5NAoT" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/D5NAoT</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">The following code snippet shows one way to implement a find method. Again, observe how we make use of Java's <kbd class="calibre15">Optional</kbd> methods. We start a <kbd class="calibre15">while</kbd> loop from the head pointer and keep on moving to the next node as long as there is a node present and that node doesn't contain the item we're looking for. We then return the last pointer, which can be an empty optional or a node containing a match:</p>
<pre class="calibre20"><span class="calibre10">public Optional&lt;LinkedListNode&lt;V&gt;&gt; find(V item) {<br class="calibre2"/>  Optional&lt;LinkedListNode&lt;V&gt;&gt; node = Optional.ofNullable(this.head);</span></pre>
<pre class="calibre20"><span class="calibre10"><br class="calibre2"/>  while (node.filter(n -&gt; n.getValue() != item).isPresent()) {<br class="calibre2"/>    node = node.flatMap(LinkedListNode::getNext);<br class="calibre2"/>  }<br class="calibre2"/>  return node;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.17: Adding and deleting from the front of the linked list. Source class name: </span><span class="calibre10">Linkedlist</span></div>
<div class="packt_infobox"><span class="calibre10">Go to</span> <a href="https://goo.gl/6pQm3T" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/6pQm3T</span></a> <span class="calibre10">to access the code. <span class="calibre10">The <kbd class="calibre31">find()</kbd> method on a linked list has the worst runtime complexity of <em class="calibre21">O(n)</em>. This happens when either the matching item is at the end of the list or the item is not in the list at all.<br class="calibre2"/></span></span></div>
<p class="mce-root"><span class="calibre14">In the preceding example, we have shown how to add an item at the head of the list. How can we insert this into a linked list at an arbitrary point?</span> <em class="calibre19"><span class="calibre14">Figure 2.7</span></em> <span class="calibre14">shows how we can do this in two steps:</span></p>
<p class="cdpaligncenter"><img src="Images/6bb7a80c-3e61-4cd4-940b-61298bba2e4d.png" width="1518" height="527" class="calibre49"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.7: Adding a node at an arbitrary position in the list</span></div>
<p class="mce-root"><em class="calibre19"><span class="calibre14">Snippet 2.18</span></em> <span class="calibre14">shows how we can do this. It is a Java method called</span> <span class="calibre14"><kbd class="calibre15">addAfter()</kbd> </span><span class="calibre14">accepting a node and an item to insert. The method adds a node, containing the item, after the</span> <span class="calibre14"><kbd class="calibre15">aNode</kbd></span> <span class="calibre14">argument. The implementation follows the steps shown in <em class="calibre19">Figure 2.7</em>.</span></p>
<pre class="calibre20"><span class="calibre10">public void addAfter(LinkedListNode&lt;V&gt; aNode, V item) {<br class="calibre2"/>  aNode.setNext(new LinkedListNode&lt;&gt;(item, aNode.getNext().orElse(null)));<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.18: Solution method for</span> <span class="calibre10">addAfter</span> <span class="calibre10">operation. Source class name:</span> <span class="calibre10">Linkedlist</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/Sjxc6T" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/Sjxc6T</span></a> <span class="calibre10">to access this code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Traversing the Linked List</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root"><span class="calibre14">We have a linked list containing some elements and we need to build a string of the form <kbd class="calibre15">[3,6,4,2,4]</kbd>. If the list is empty, it should output <kbd class="calibre15">[]</kbd>.</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root"><span class="calibre14">To write code in Java for traversing the linked list.</span> </p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Write a</span> <kbd class="calibre15"><span class="calibre10">toString()</span></kbd> <span class="calibre10">method in the</span> <kbd class="calibre15"><span class="calibre10">LinkedList</span></kbd> <span class="calibre10">class as follows:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public String toString() {<br class="calibre2"/>}</span>  </pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">Use a <kbd class="calibre15">while</kbd> loop to traverse the linked list.</span></li>
</ol>
<p class="mce-root">In this section, we have seen how we can implement the various operations found in the linked list. The data structure will be a base tool that we will use to model queues and stacks. Linked lists will also be extensively used in more advanced algorithms further along the book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Queues</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Queues are abstract data structures that are meant to emulate the workings of real life queues. They are used extensively in various applications, such resource allocation, scheduling, sorting, and many others. They are typically implemented using a double linked list, although many other implementations exists. A queue usually consists of two operations; an <kbd class="calibre15">enqueue</kbd> operation, where items are added to the rear of the queue, and an opposite <kbd class="calibre15">dequeue</kbd> operation, where items are removed from the front of the queue. These two operations make the mode of operation of this data structure <strong class="calibre6">First In First Out</strong> (<strong class="calibre6">FIFO</strong>).</p>
<p class="mce-root"><span class="calibre14">We can implement an efficient queue using a double linked list. This enables us implement the</span> <span class="calibre14"><kbd class="calibre15">dequeue</kbd></span> <span class="calibre14">operation by removing an item from the head of the linked list.</span> <span class="calibre14"><kbd class="calibre15">enqueue</kbd></span> <span class="calibre14">is simply adding an item to the tail of the linked list.</span> <em class="calibre19"><span class="calibre14">Figure 2.8</span></em> <span class="calibre14">shows how the two operations are performed:</span></p>
<p class="cdpaligncenter"><img src="Images/05f0f5c4-28b6-4eb2-8e4f-cfe31143e049.png" width="1650" height="472" class="calibre50"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.8: Enqueuing and dequeuing using a double linked list</span></div>
<p class="mce-root">To dequeue an item using a double linked list as a base data structure, we just need to move the head to the next item in the list and unlink the old head by pointing the previous pointer to nothing. Enqueuing at the tail is a three-step process. Point the new node's preceding pointer to the current tail, then point the current tail's next pointer to the new node, and finally moving the tail to the new node. The pseudocode for both of these operations is shown in the following code snippet:</p>
<pre class="calibre20"><span class="calibre10">dequeue(head)<br class="calibre2"/>  if (head != null)<br class="calibre2"/>    node = head<br class="calibre2"/>    head = head.next<br class="calibre2"/>    if (head != null) head.previous = null<br class="calibre2"/>    return node.value<br class="calibre2"/>  return null<br class="calibre2"/>enqueue(tail, item)<br class="calibre2"/>  node = new Node(item)<br class="calibre2"/>  node.previous = tail<br class="calibre2"/>  if (tail != null) tail.next = node<br class="calibre2"/>  if (head == null) head = node<br class="calibre2"/>  tail = node</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.19: Enqueuing and dequeuing using a doubly linked list</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding and Deleting the Elements from the Queue</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">To implement the</span> <kbd class="calibre15"><span class="calibre10">enqueue()</span></kbd> <span class="calibre14">and</span> <kbd class="calibre15"><span class="calibre10">dequeue()</span></kbd> <span class="calibre14">methods in Java, follow these steps:</span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Using a double linked list, implement the dequeue and enqueue pseudocode shown in the preceding code in Java. Follow the structure and method signature shown in the following code snippet:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public class Queue&lt;V&gt; {<br class="calibre2"/>  private DblLinkedListNode&lt;V&gt; head;<br class="calibre2"/>  private DblLinkedListNode&lt;V&gt; tail;<br class="calibre2"/>  public void enqueue(V item)<br class="calibre2"/>  public Optional&lt;V&gt; dequeue()<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.20: Exercise class structure and method signatures</span></div>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The</span> <kbd class="calibre15"><span class="calibre10">enqueue()</span></kbd> <span class="calibre10">method can be implemented as shown in the following code:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public void enqueue(V item) {<br class="calibre2"/>  DblLinkedListNode&lt;V&gt; node = new DblLinkedListNode&lt;&gt;(item, null, tail);<br class="calibre2"/>  Optional.ofNullable(tail).ifPresent(n -&gt; n.setNext(node));<br class="calibre2"/>  tail = node;<br class="calibre2"/>  if(head == null) head = node;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.21: Exercise class structure and method signatures. Source class name:</span> <span class="calibre10">Queue</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/FddeYu" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/FddeYu</span></a> <span class="calibre10">to access the code for</span> <kbd class="calibre31"><span class="calibre10">dequeue()</span></kbd> <span class="calibre10">method.</span></div>
<p class="mce-root"><span class="calibre14">Queues are dynamic data structures that have a FIFO ordering. In the next section, we shall explore another data structure with a different ordering called a stack.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Stacks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Stacks, typically also implemented using linked lists, work differently than queues. Instead of the FIFO ordering, they have a <strong class="calibre6">Last In First Out</strong> (<strong class="calibre6">LIFO</strong>) ordering (see <em class="calibre19">Figure 2.9</em>). They have two main operations called push, which adds an item on top of the stack, and pop, which removes and returns one item from the top of the stack. Like queues, stacks are heavily used in many algorithms, such as depth first search traversal, expression evaluations, and many others:</p>
<p class="cdpaligncenter"><img src="Images/9fcff6f4-1791-4ac3-a673-b1f420fdc65a.png" width="1014" height="416" class="calibre51"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.9: Pushing and popping operations on a stack of papers</span></div>
<p class="mce-root">To model a stack, it's enough to use a simple linked list. The head of the linked list can be used to reference the top of the stack. Every time we need to push something on the top of our stack, we can use the <kbd class="calibre15">addFront()</kbd> method we developed in the preceding sections. The implementations differ only in the fact that the pop operation returns the optional item on the top of the stack. Both push and pop can been seen in the Java implementation in the following code snippet. Notice how the pop operations return an optional value which is populated if the stack is not empty.</p>
<p class="mce-root">A one-way linked list is enough to model a stack since we only need to operate from one end of the list. For a queue, we needed to modify both the head and tail of the linked list, hence it was more efficient to use a double linked list. The following code shows the implementation of the <kbd class="calibre15">push()</kbd> and <kbd class="calibre15">pop()</kbd> methods:</p>
<pre class="calibre20"><span class="calibre10">public void push(V item) {<br class="calibre2"/>  head = new LinkedListNode&lt;V&gt;(item, head);<br class="calibre2"/>}<br class="calibre2"/>public Optional&lt;V&gt; pop() {<br class="calibre2"/>  Optional&lt;LinkedListNode&lt;V&gt;&gt; node = Optional.ofNullable(head);<br class="calibre2"/>  head = node.flatMap(LinkedListNode::getNext).orElse(null);<br class="calibre2"/>  return node.map(LinkedListNode::getValue);<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.22: Push and pop operations in java. Source class name:</span> <span class="calibre10">Stack</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/uUhuqg" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/uUhuqg</span></a> <span class="calibre10">to access the code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reversing a String</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need t<span class="calibre14">o make use of a stack data</span> structure <span class="calibre14">for reversing a string.</span></p>
<p class="mce-root">Follow these steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">To reverse the string, push of each character of the input string and then pop everything out, one at a time, building a reversed string. The method signature can be as follows:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public String reverse(String str)</span><span class="calibre10"> </span></pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The following code shows how a string can be reversed using the stack data structure:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public String reverse(String str) {<br class="calibre2"/>  StringBuilder result = new StringBuilder();<br class="calibre2"/>  Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<br class="calibre2"/>  for (char c : str.toCharArray())<br class="calibre2"/>  stack.push(c);<br class="calibre2"/>  Optional&lt;Character&gt; optChar = stack.pop();<br class="calibre2"/>  while (optChar.isPresent()) {<br class="calibre2"/>    result.append(optChar.get());<br class="calibre2"/>    optChar = stack.pop();<br class="calibre2"/>  }<br class="calibre2"/>  return result.toString();<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.23: Reverse a string solution Source class name:</span> <span class="calibre10">StringReverse</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to<span class="calibre10"> </span></span><span class="calibre10"><a href="https://goo.gl/UN2d5U" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/UN2d5U</a><span class="calibre10"> </span></span><span class="calibre10">to access the code.</span><span class="calibre10"> </span></div>
<p class="mce-root">Stack data structures are extensively used in computer science for many algorithms. In this section, we have seen how to implement them in a dynamic fashion using linked lists. In the next section, we shall see how to model stacks and queue in a static manner using arrays.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Modeling Stacks and Queues Using Arrays</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Stacks and queues don't necessarily need to be dynamic. You may want a more concise implementation if you know your data requirements are of a fixed size. Using an array approach to model stacks and queues guarantees that your data structure will only grow up to a certain size. The other advantage of using an array is that the array approach is more memory efficient if you can live with having a static data structure. The catch with static data structures is that the queue or stack can only grow to a maximum fixed size of your initially allocated array.</p>
<p class="mce-root">Implementing a stack using an array involves first initializing an empty array with a fixed size. Then, it's a matter of keeping an index pointer to the top of the stack, initially pointing to zero. As we push items on the stack, we place the item at this index and increment the pointer by one. When we need to pop an element, we reduce this pointer by one and read the value. This process is shown in the following code:</p>
<pre class="calibre20"><span class="calibre10">public StackArray(int capacity) {<br class="calibre2"/>  array = (V[]) new Object[capacity];<br class="calibre2"/>}<br class="calibre2"/>public void push(V item) {<br class="calibre2"/>  array[headPtr++] = item;<br class="calibre2"/>}<br class="calibre2"/>public Optional&lt;V&gt; pop() {<br class="calibre2"/>  if (headPtr &gt; 0) return Optional.of(array[--headPtr]);<br class="calibre2"/>  else return Optional.empty();<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.24: Stack using an array instead of linked list. Source class name:</span> <span class="calibre10">Stackarray</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/T61L33" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/T61L33</span></a> <span class="calibre10">to access the code</span></div>
<p class="mce-root">Implementing a queue using an array requires a little more thinking. The difficulty with a queue is that the structure is modified from both ends since it grows from the tail and shrinks from the head.</p>
<p class="mce-root">As we enqueue and dequeue the contents of the queue, it seems to be moving towards the right of the array. We need to deal with what happens when the contents reaches the end of our array. To make the queue work in an array, we just need to let our data wrap around the edges (think <em class="calibre19">Pacman</em>, <em class="calibre19">Figure 2.10</em>):</p>
<p class="cdpaligncenter"><img src="Images/2e942fe9-67f4-4fcd-9f60-bf6ba43bc06d.png" width="1244" height="445" class="calibre52"/></p>
<div class="packt_figref"><span class="calibre10">Figure 2.10: Array wrap around analogy</span></div>
<p class="mce-root">When we reach the end of our array, we can just start again from the beginning index. This wrap around mechanism is called a <strong class="calibre6">circular buffer</strong>. It can be implemented using the modulus operator to access any element in the underlying array. The following code snippet shows how this works. Notice that when we enqueue an item, we place it at the tail position and increment the tail pointer using the <kbd class="calibre15">mod</kbd> operator. When the pointer is larger or equal to the size of the array, it wraps around and starts again from zero. The same happens on the <kbd class="calibre15">dequeue</kbd> method, where we access and increment the head pointer in a similar fashion. The following code demonstrates it:</p>
<div class="packt_infobox">The implementation in <em class="calibre21">Snippet 2.25</em> does not check if the circular buffer is full before enqueuing another item. Implementing this check is given as an exercise in the next section.</div>
<pre class="calibre20"><span class="calibre10">public void enqueue(V item) {<br class="calibre2"/>  array[tailPtr] = item;<br class="calibre2"/>  tailPtr = (tailPtr + 1) % array.length;<br class="calibre2"/>}<br class="calibre2"/>public Optional&lt;V&gt; dequeue() {<br class="calibre2"/>  if (headPtr != tailPtr) {<br class="calibre2"/>    Optional&lt;V&gt; item = Optional.of(array[headPtr]);<br class="calibre2"/>    headPtr = (headPtr + 1) % array.length;<br class="calibre2"/>    return item;<br class="calibre2"/>  } else return Optional.empty();<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.25: Enqueue and dequeue using an array. Source class name:</span> <span class="calibre10">QueueArray</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/LJuYz9" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/LJuYz9</span></a> <span class="calibre10">to access this code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Safe Enqueuing in an Array</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We need to<span class="calibre14"> write a safe</span> <kbd class="calibre15"><span class="calibre10">enqueue()</span></kbd> <span class="calibre14">method that will fail when the queue is full.</span><span class="calibre14"> </span></p>
<p class="mce-root"><span class="calibre14">Steps for completion:</span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Modify the enqueue and dequeue methods shown in the preceding code so that the enqueue returns a Boolean value which is</span> <span class="calibre10"><kbd class="calibre15">false</kbd></span> <span class="calibre10">when the queue is full and cannot accept further elements.</span></li>
<li class="chapter"><span class="calibre10">Implement the method signatures as follows:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public boolean enqueueSafe(V item)<br class="calibre2"/>public Optional&lt;V&gt; dequeueSafe()</span>  </pre>
<ol start="3" class="calibre17">
<li class="chapter"><span class="calibre10">The following</span> <em class="calibre21"><span class="calibre10">Snippet 2.26</span></em> <span class="calibre10">provides an implementation of the</span> <span class="calibre10"><kbd class="calibre15">enqueueSafe()</kbd> </span><span class="calibre10">method, returning a Boolean value when the queue is full:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">private boolean full = false;<br class="calibre2"/>public boolean enqueueSafe(V item) {<br class="calibre2"/>  if (!full) {<br class="calibre2"/>    array[tailPtr] = item;<br class="calibre2"/>    tailPtr = (tailPtr + 1) % array.length;<br class="calibre2"/>    this.full = tailPtr == headPtr;<br class="calibre2"/>    return true;<br class="calibre2"/>  }<br class="calibre2"/>  return false;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 2.26: Safe Enqueue and dequeue solution. Source class name:</span> <span class="calibre10">QueueArray</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/cBszQL" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/cBszQL</span></a> <span class="calibre10">to access the code for implementation of</span> <kbd class="calibre31"><span class="calibre10">dequeueSafe()</span></kbd> <span class="calibre10">method.</span></div>
<p class="mce-root"><span class="calibre14">We have seen how both queues and stacks can be implemented using a static array structure instead of using the dynamic linked list. This has the advantage of consuming less memory per element as a linked list has to store pointers to other nodes. However, this comes at the cost of having a limit on the structure size.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Evaluating the Postfix Expression</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root">We are used to writing mathematical expressions in the form of <em class="calibre19">1 + 2 * 3</em>. This type of notation is called an <strong class="calibre6">infix</strong>. Using infix notation, an operator is always in between two operators. There is a different notation called postfix, where the operator is after the operands. Examples of such expressions are shown in the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Infix expression</strong></td>
<td class="calibre25"><strong class="calibre3">Postfix expression</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">1 + 2</td>
<td class="calibre25">1 2 +</td>
</tr>
<tr class="calibre24">
<td class="calibre25">1 + 2 * 3</td>
<td class="calibre25">1 2 3 * +</td>
</tr>
<tr class="calibre26">
<td class="calibre25">(1 + 2) * 3</td>
<td class="calibre25">1 2 + 3 *</td>
</tr>
<tr class="calibre27">
<td class="calibre25">5 + 4 / 2 * 3</td>
<td class="calibre25">5 4 2 / 3 * +</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root"><span class="calibre14">Implement an algorithm that accepts a postfix string, evaluates it, and returns the result.</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Prerequisites</span></strong></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Implement the following method in the class which is available on the<br class="calibre2"/>
GitHub repository for the book at the following path:</span><br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java</a></li>
</ul>
<pre class="calibre30"> <span class="calibre10">public double evaluate(String postfix)</span> </pre>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Assume the operator and operands are always separated by a space, such as <em class="calibre21">"5 2 +"</em>. The input string will look like the examples shown in the preceding table</span>.</li>
</ul>
<div class="packt_infobox"><span class="calibre10">If you have your project set up, you can run the unit test for this activity by running the following command:</span><br class="calibre2"/>
<br class="calibre2"/>
<strong class="calibre3"><kbd class="calibre31"><span class="calibre10">gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.postfix*</span></kbd></strong><br class="calibre2"/>
<br class="calibre2"/>
The solution becomes a lot simpler if you use one of the data structures we studied in this section.</div>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Use the stack data structure to solve this problem</span></li>
<li class="chapter"><span class="calibre10">Start processing the expression from left to right</span></li>
<li class="chapter"><span class="calibre10">If you encounter a numeric operand, push it on the stack</span></li>
<li class="chapter"><span class="calibre10">If you encounter an operator, pop two items from the stack and perform the operation accordingly (addition, subtraction, and so on) and push the result back on the stack</span></li>
<li class="chapter"><span class="calibre10">Once you have processed the entire expression, the result should be the on the top of the stack</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we laid the foundations for the more complex upcoming sections. In the first few sections, we saw how a simple problem such as sorting can have many solutions, all with different performance properties. We explored three main implementations, which were bubble, quick, and merge sort.</p>
<p class="mce-root">In later sections, we introduced data structures and studied various implementations and use cases of linked lists, queues, and stacks. We also saw how some data structures can be used as building blocks to build more complex ones on top. In the next chapter, we will study hash tables and binary trees, two important and widely used data structures.</p>


            </article>

            
        </section>
    </div>



  </body></html>