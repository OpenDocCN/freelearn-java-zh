<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Additional Information</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Processing results for Runnable objects in the Executor framework</li>
<li class="calibre18">Processing uncontrolled exceptions in a ForkJoinPool class</li>
<li class="calibre18">Using a blocking thread-safe queue to communicate with producers and consumers</li>
<li class="calibre18">Monitoring a Thread class</li>
<li class="calibre18">Monitoring a Semaphore class</li>
<li class="calibre18">Generating concurrent random numbers</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">This chapter include recipes about the <kbd class="calibre15">Executor</kbd> framework and the fork/join framework, concurrent data structures, monitoring concurrent objects, and generating concurrent random numbers.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Processing results for Runnable objects in the Executor framework</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework allows the execution of concurrent tasks that returns a result using the <kbd class="calibre15">Callable</kbd> and <kbd class="calibre15">Future</kbd> interfaces. The traditional concurrent programming in Java is based on <kbd class="calibre15">Runnable</kbd> objects, but this kind of object doesn't return a result.</p>
<p class="calibre4">In this recipe, you will learn how to adapt a <kbd class="calibre15">Runnable</kbd> object to simulate a <kbd class="calibre15">Callable</kbd> one, allowing a concurrent task to return a result.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse, or another IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Perform the following steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">FileSearch</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface. This class implements the file search operation:</li>
</ol>
<pre class="calibre23">
        public class FileSearch implements Runnable { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private <kbd class="calibre15">String</kbd> attributes: one named <kbd class="calibre15">initPath</kbd>, which will store the initial folder for the search operation, and the other named end, which will store the extension of the files this task is going to look for:</li>
</ol>
<pre class="calibre23">
        private String initPath; <br class="title-page-name"/>        private String end; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">List&lt;String&gt;</kbd> attribute named <kbd class="calibre15">results</kbd> that will store the full paths of the files that this task has found:</li>
</ol>
<pre class="calibre23">
        private List&lt;String&gt; results; 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class that will initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public FileSearch(String initPath, String end) { <br class="title-page-name"/>          this.initPath = initPath; <br class="title-page-name"/>          this.end = end; <br class="title-page-name"/>          results=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        } 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the method <kbd class="calibre15">getResults()</kbd>. This method returns the list with the full paths of the files that this task has found:</li>
</ol>
<pre class="calibre23">
        public List&lt;String&gt; getResults() { <br class="title-page-name"/>          return results; <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First of all, write a log message to the console indicating that the task is starting its job:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          System.out.printf("%s: Starting\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Then, if the <kbd class="calibre15">initPath</kbd> attribute stores the name of an existing folder, call the auxiliary method, <kbd class="calibre15">directoryProcess()</kbd>, to process its files and folders:</li>
</ol>
<pre class="calibre23">
        File file = new File(initPath); <br class="title-page-name"/>          if (file.isDirectory()) { <br class="title-page-name"/>            directoryProcess(file); <br class="title-page-name"/>          } 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the auxiliary <kbd class="calibre15">diretoryProcess()</kbd> method, which receives a <kbd class="calibre15">File</kbd> object as a parameter. First of all, get the contents of the folder pointed to by the parameter:</li>
</ol>
<pre class="calibre23">
        private void directoryProcess(File file) { <br class="title-page-name"/>          File list[] = file.listFiles(); 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">With all the elements of the folder, if they are folders, make a recursive call to the <kbd class="calibre15">directoryProcess()</kbd> method. If they are files, call the <kbd class="calibre15">fileProcess()</kbd> auxiliary method:</li>
</ol>
<pre class="calibre23">
        if (list != null) { <br class="title-page-name"/>          for (int i = 0; i &lt; list.length; i++) { <br class="title-page-name"/>            if (list[i].isDirectory()) { <br class="title-page-name"/>              directoryProcess(list[i]); <br class="title-page-name"/>            } else { <br class="title-page-name"/>              fileProcess(list[i]); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the auxiliary method <kbd class="calibre15">fileProcess()</kbd> that receives a <kbd class="calibre15">File</kbd> object with the full path of a file. This method checks if the file extension is equal to the one stored in the end attribute. If they are equal, add the full path of the file to the list of results:</li>
</ol>
<pre class="calibre23">
        private void fileProcess(File file) { <br class="title-page-name"/>          if (file.getName().endsWith(end)) { <br class="title-page-name"/>            results.add(file.getAbsolutePath()); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement a class named <kbd class="calibre15">Task</kbd> that extends the <kbd class="calibre15">FutureTask</kbd> class. You'll use <kbd class="calibre15">List&lt;String&gt;</kbd> as the parameterized type, as this will be the type of the data this task will return:</li>
</ol>
<pre class="calibre23">
        public class Task extends FutureTask&lt;List&lt;String&gt;&gt; { 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare a private <kbd class="calibre15">FileSearch</kbd> attribute named <kbd class="calibre15">fileSearch</kbd>:</li>
</ol>
<pre class="calibre23">
        private FileSearch fileSearch; 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the constructor of this class. This constructor has two parameters: a <kbd class="calibre15">Runnable</kbd> object named <kbd class="calibre15">runnable</kbd> and a <kbd class="calibre15">List&lt;String&gt;</kbd> object named result. In the constructor, you have to call the constructor of the parent class, passing to it the same parameters. Then, store the <kbd class="calibre15">runnable</kbd> parameter, casting it to a <kbd class="calibre15">FileSearch</kbd> object:</li>
</ol>
<pre class="calibre23">
        public Task(Runnable runnable, List&lt;String&gt; result) { <br class="title-page-name"/>          super(runnable, result); <br class="title-page-name"/>          this.fileSearch=(FileSearch)runnable; <br class="title-page-name"/>        } 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Override the <kbd class="calibre15">set()</kbd> method of the <kbd class="calibre15">FutureTask</kbd> class:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void set(List&lt;String&gt; v) { 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">If the parameter that it receives is null, store in it the result of calling the <kbd class="calibre15">getResults()</kbd> method of the <kbd class="calibre15">FileSearch</kbd> class:</li>
</ol>
<pre class="calibre23">
        v=fileSearch.getResults();     
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Then, call the parent's method passing the received parameter as a parameter:</li>
</ol>
<pre class="calibre23">
        super.set(v); 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Finally, implement the main class of the example. Create a class named <kbd class="calibre15">Main</kbd> and implement the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a <kbd class="calibre15">ThreadPoolExecutor</kbd> object named executor calling the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ExecutorService executor = Executors.newCachedThreadPool(); 
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create three <kbd class="calibre15">FileSearch</kbd> objects with a different initial folder for each one. You are going to look for files with the <kbd class="calibre15">log</kbd> extension:</li>
</ol>
<pre class="calibre23">
        FileSearch system=new FileSearch("C:\\Windows", "log"); <br class="title-page-name"/>        FileSearch apps=new FileSearch("C:\\Program Files","log"); <br class="title-page-name"/>        FileSearch documents=new FileSearch("C:\\Documents And<br class="title-page-name"/>                                             Settings","log"); 
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create three <kbd class="calibre15">Task</kbd> objects to execute the search operations in the executor:</li>
</ol>
<pre class="calibre23">
        Task systemTask=new Task(system,null); <br class="title-page-name"/>        Task appsTask=new Task(apps,null); <br class="title-page-name"/>        Task documentsTask=new Task(documents,null); 
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Send these objects to the executor object using the <kbd class="calibre15">submit()</kbd> method. This version of the <kbd class="calibre15">submit()</kbd> method returns a <kbd class="calibre15">Future&lt;?&gt;</kbd> object, but you're going to ignore it. You have a class that extends the <kbd class="calibre15">FutureTask</kbd> class to control the execution of this task:</li>
</ol>
<pre class="calibre23">
        executor.submit(systemTask); <br class="title-page-name"/>        executor.submit(appsTask); <br class="title-page-name"/>        executor.submit(documentsTask); 
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Call the <kbd class="calibre15">shutdown()</kbd> method of the executor object to indicate that it should finish its execution when these three tasks have finished:</li>
</ol>
<pre class="calibre23">
        executor.shutdown(); 
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Call the <kbd class="calibre15">awaitTermination()</kbd> method of the executor object, indicating a long waiting period to guarantee that this method won't return until the three tasks have finished:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          executor.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">For each task, write a message with the size of the result list using the <kbd class="calibre15">get()</kbd> method of the <kbd class="calibre15">Task</kbd> object:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          System.out.printf("Main: System Task: Number of Results: %d\n",<br class="title-page-name"/>                            systemTask.get().size()); <br class="title-page-name"/>          System.out.printf("Main: App Task: Number of Results: %d\n",<br class="title-page-name"/>                            appsTask.get().size()); <br class="title-page-name"/>          System.out.printf("Main: Documents Task: Number of <br class="title-page-name"/>                             Results: %d\n",documentsTask.get().size()); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } catch (ExecutionException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The first point to take into consideration to understand this example is the difference between the <kbd class="calibre15">submit()</kbd> method of the <kbd class="calibre15">ThreadPoolExecutor</kbd> class when you pass a <kbd class="calibre15">Callable</kbd> object as the parameter and the <kbd class="calibre15">submit()</kbd> method when you pass a <kbd class="calibre15">Runnable</kbd> object as the parameter. In the first case, you can use the <kbd class="calibre15">Future</kbd> object that this method returns to control the status of the task and to get its result. But in the second case, when you pass a <kbd class="calibre15">Runnable</kbd> object, you can only use the <kbd class="calibre15">Future</kbd> object that this method returns to control the status of the task. If you call the <kbd class="calibre15">get()</kbd> method of that <kbd class="calibre15">Future</kbd> object, you will get a null value.</p>
<p class="calibre4">To override this behavior, you have implemented the <kbd class="calibre15">Task</kbd> class. This class extends the <kbd class="calibre15">FutureTask</kbd> class that is a class that implements the <kbd class="calibre15">Future</kbd> interface and the <kbd class="calibre15">Runnable</kbd> interface. When you call a method that returns a <kbd class="calibre15">Future</kbd> object (for example, the <kbd class="calibre15">submit()</kbd> method), you will normally get a <kbd class="calibre15">FutureTask</kbd> object. So you can use this class with two objectives:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, execute the <kbd class="calibre15">Runnable</kbd> object (in this case, a <kbd class="calibre15">FileSearch</kbd> object).</li>
<li value="2" class="calibre18">Second, return the results that this task generates. To achieve this, you have overridden the <kbd class="calibre15">set()</kbd> method of the <kbd class="calibre15">Task</kbd> class. Internally, the <kbd class="calibre15">FutureTask</kbd> class controls when the task it has to execute has finished. At that moment, it makes a call to the <kbd class="calibre15">set()</kbd> method to establish the return value of the task. When you are executing a <kbd class="calibre15">Callable</kbd> object, this call is made with the value returned by the <kbd class="calibre15">call()</kbd> method, but when you are executing a <kbd class="calibre15">Runnable</kbd> object, this call is made with the null value. You have changed this null value with the list of results generated by the <kbd class="calibre15">FileSearch</kbd> object. The <kbd class="calibre15">set()</kbd> method will only have effect the first time it is called. When it's called for the first time, it marks the task as finished and the rest of the calls will not modify the return value of the task.</li>
</ol>
<p class="calibre4">In the <kbd class="calibre15">Main</kbd> class, instead of sending the <kbd class="calibre15">FutureTasks</kbd> objects to the <kbd class="calibre15">Callable</kbd> or <kbd class="calibre15">Runnable</kbd> objects, you can send it to the executor object. The main difference is that you use the <kbd class="calibre15">FutureTasks</kbd> objects to get the results of the task instead of the <kbd class="calibre15">Future</kbd> object returned by the <kbd class="calibre15">submit()</kbd> method.</p>
<p class="calibre4">In this case, you can still use the <kbd class="calibre15">Future</kbd> object returned by the <kbd class="calibre15">submit()</kbd> method to control the status of the task but remember that, as this task executes a <kbd class="calibre15">Runnable</kbd> object (you have initialized the <kbd class="calibre15">FutureTasks</kbd> objects with the <kbd class="calibre15">FileSearch</kbd> objects that implement the <kbd class="calibre15">Runnable</kbd> interface), if you call the <kbd class="calibre15">get()</kbd> method in the <kbd class="calibre15">Future</kbd> objects, you will get the null value.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">FutureTask</kbd> class provides a method not included in the <kbd class="calibre15">Future</kbd> interface. It's the <kbd class="calibre15">setException()</kbd> method. This method receives a <kbd class="calibre15">Throwable</kbd> object as the parameter and when the <kbd class="calibre15">get()</kbd> method is called, an <kbd class="calibre15">ExecutionException</kbd> exception will be thrown. This call has an effect only if the <kbd class="calibre15">set()</kbd> method of the <kbd class="calibre15">FutureTask</kbd> object hasn't been called yet.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Executing tasks in an executor that returns a result</em> recipe in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
<li class="calibre18">The <em class="calibre14">Creating, running, and setting the characteristics of a thread</em> recipe in <a href="part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre14">Thread Management</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Processing uncontrolled exceptions in a ForkJoinPool class</h1>
            

            <article>
                
<p class="calibre4">The fork/join framework gives you the possibility to set a handler for the exceptions thrown by the worker threads of a <kbd class="calibre15">ForkJoinPool</kbd> class. When you work with a <kbd class="calibre15">ForkJoinPool</kbd> class, you should understand the difference between tasks and worker threads.</p>
<p class="calibre4">To work with the fork/join framework, you implement a task extending the <kbd class="calibre15">ForkJoinTask</kbd> class or, usually, the <kbd class="calibre15">RecursiveAction</kbd> or <kbd class="calibre15">RecursiveTask</kbd> classes. The task implements the actions you want to execute concurrently with the framework. They are executed in the <kbd class="calibre15">ForkJoinPool</kbd> class by the worker threads. A worker thread will execute various tasks. In the work-stealing algorithm implemented by the <kbd class="calibre15">ForkJoinPool</kbd> class, a worker thread looks for a new task when the task it was executing finishes its execution or it is waiting for the completion of another task.</p>
<p class="calibre4">In this recipe, you will learn how to process the exceptions thrown by a worker thread. You'll have to implement two additional elements for it to work as described in the following items:</p>
<ul class="calibre17">
<li class="calibre18">The first element is an extended class of the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class. This class implements the worker thread of a <kbd class="calibre15">ForkJoinPool</kbd> class. You will implement a basic child class that will throw an exception.</li>
<li class="calibre18">The second element is a factory to create worker threads of your own custom type. The <kbd class="calibre15">ForkJoinPool</kbd> class uses a factory to create its worker threads. You have to implement a class that implements the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface and uses an object of that class in the constructor of the <kbd class="calibre15">ForkJoinPool</kbd> class. The <kbd class="calibre15">ForkJoinPool</kbd> object created will use that factory to create worker threads.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Perform the following steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, implement your own worker thread class. Create a class named <kbd class="calibre15">AlwaysThrowsExceptionWorkerThread</kbd> that extends the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class AlwaysThrowsExceptionWorkerThread extends<br class="title-page-name"/>                                ForkJoinWorkerThread { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the constructor of the class. It receives a <kbd class="calibre15">ForkJoinPool</kbd> class as a parameter and calls the constructor of its parent class:</li>
</ol>
<pre class="calibre23">
        protected AlwaysThrowsExceptionWorkerThread(ForkJoinPool pool) { <br class="title-page-name"/>          super(pool); <br class="title-page-name"/>        } 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">onStart()</kbd> method. This is a method of the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class and is executed when the worker thread begins its execution. The implementation will throw a <kbd class="calibre15">RuntimeException</kbd> exception upon being called:</li>
</ol>
<pre class="calibre23">
        protected void onStart() { <br class="title-page-name"/>          super.onStart(); <br class="title-page-name"/>          throw new RuntimeException("Exception from worker thread"); <br class="title-page-name"/>        } 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Now, implement the factory needed to create your worker threads. Create a class named <kbd class="calibre15">AlwaysThrowsExceptionWorkerThreadFactory</kbd> that implements the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class AlwaysThrowsExceptionWorkerThreadFactory implements<br class="title-page-name"/>                                 ForkJoinWorkerThreadFactory {  
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">newThread()</kbd> method. It receives a <kbd class="calibre15">ForkJoinPool</kbd> object as the parameter and returns a <kbd class="calibre15">ForkJoinWorkerThread</kbd> object. Create an <kbd class="calibre15">AlwaysThrowsExceptionWorkerThread</kbd> object and return it:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public ForkJoinWorkerThread newThread(ForkJoinPool pool) { <br class="title-page-name"/>          return new AlwaysThrowsExceptionWorkerThread(pool); <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a class that will manage the exceptions thrown by worker threads. Implement a class named <kbd class="calibre15">Handler</kbd> that implements the <kbd class="calibre15">UncaughtExceptionHandler</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Handler implements UncaughtExceptionHandler { 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">uncaughtException()</kbd> method. It receives as parameters a Thread object and a <kbd class="calibre15">Throwable</kbd> object and is called by the <kbd class="calibre15">ForkJoinPool</kbd> class each time a worker thread throws an exception. Write a message to the console and exit the program:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void uncaughtException(Thread t, Throwable e) { <br class="title-page-name"/>          System.out.printf("Handler: Thread %s has thrown an<br class="title-page-name"/>                             Exception.\n",t.getName()); <br class="title-page-name"/>          System.out.printf("%s\n",e); <br class="title-page-name"/>          System.exit(-1); <br class="title-page-name"/>        } 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Now, implement a task to be executed in the <kbd class="calibre15">ForkJoinPool</kbd> executor. Create a class named <kbd class="calibre15">OneSecondLongTask</kbd> that extends the <kbd class="calibre15">RecursiveAction</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class OneSecondLongTask extends RecursiveAction{ 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. It simply puts the thread to sleep after one second:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void compute() { <br class="title-page-name"/>          System.out.printf("Task: Starting.\n"); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Task: Finish.\n"); <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Now, implement the main class of the example. Create a class named Main with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a new <kbd class="calibre15">OneSecondLongTask</kbd> object:</li>
</ol>
<pre class="calibre23">
        OneSecondLongTask task=new OneSecondLongTask(); 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a new Handler object:</li>
</ol>
<pre class="calibre23">
        Handler handler = new Handler(); 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a new <kbd class="calibre15">AlwaysThrowsExceptionWorkerThreadFactory</kbd> object:</li>
</ol>
<pre class="calibre23">
        AlwaysThrowsExceptionWorkerThreadFactory factory=new<br class="title-page-name"/>                            AlwaysThrowsExceptionWorkerThreadFactory(); 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a new <kbd class="calibre15">ForkJoinPool</kbd> object. Pass as parameters the value <kbd class="calibre15">2</kbd>, the factory object, the handler object, and the value <kbd class="calibre15">false</kbd>:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(2,factory,handler,false); 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Execute the task in the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task); 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Shut down the pool with the <kbd class="calibre15">shutdown()</kbd> method.</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Wait for the finalization of the tasks using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          pool.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Write a message indicating the end of the program:</li>
</ol>
<pre class="calibre23">
         System.out.printf("Task: Finish.\n"); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you have implemented the following elements:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Your own worker thread class</strong>: You have implemented the <kbd class="calibre15">AlwaysThrowsExceptionWorkerThread</kbd> class, which extends the <kbd class="calibre15">ForkJoinWorkerThread</kbd> class, which implements the worker threads of a fork/join pool. You have overridden the <kbd class="calibre15">onStart()</kbd> method. This method is executed when a worker thread starts its execution. It simply throws an exception <kbd class="calibre15">RuntimeException</kbd> upon being called.</li>
<li class="calibre18"><strong class="calibre1">Your own thread factory</strong>: A <kbd class="calibre15">ForkJoinPool</kbd> class creates its worker threads using a factory. As you want to create a <kbd class="calibre15">ForkJoinPool</kbd> object that uses the <kbd class="calibre15">AlwaysThrowsExceptionWorkerThreadFactory</kbd> worker threads, you have implemented a factory that creates them. To implement a worker thread factory, you need to implement the <kbd class="calibre15">ForkJoinWorkerThreadFactory</kbd> interface. This interface only has a method named <kbd class="calibre15">newThread()</kbd>, which creates the worker thread and returns it to the <kbd class="calibre15">ForkJoinPool</kbd> class.</li>
<li class="calibre18"><strong class="calibre1">A task class</strong>: The worker threads execute the tasks you send to the <kbd class="calibre15">ForkJoinPool</kbd> executor. As you want to start the execution of a worker thread, you need to send a task to the <kbd class="calibre15">ForkJoinPool</kbd> executor. The task sleeps for one second, but, as the <kbd class="calibre15">AlwaysThrowsExceptionWorkerThread</kbd> thread throws an exception, it will never be executed.</li>
<li class="calibre18"><strong class="calibre1">A handler class for uncaught exceptions</strong>: When a worker thread throws an exception, the <kbd class="calibre15">ForkJoinPool</kbd> class checks whether an exception handler has been registered. You have implemented the <kbd class="calibre15">Handler</kbd> class for this purpose. This handler implements the <kbd class="calibre15">UncaughtExceptionHandler</kbd> interface, which only has one method, that is, the <kbd class="calibre15">uncaughtException()</kbd> method. This method receives as a parameter the thread that throws the exception and the exception it throws.</li>
</ul>
<p class="calibre4">In the Main class, you have put together all these elements. You have passed to the constructor of the <kbd class="calibre15">ForkJoinPool</kbd> class four parameters: the parallelism level, the number of active worker threads you want to have, the worker thread factory you want to use in the <kbd class="calibre15">ForkJoinPool</kbd> object, the handler you want to use for the uncaught exceptions of the worker threads, and the async mode.</p>
<p class="calibre4">The following screenshot shows the result of an execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border12" src="../images/00073.jpeg"/></div>
<p class="calibre4">When you execute the program, a worker thread throws a <kbd class="calibre15">RuntimeException</kbd> exception. The <kbd class="calibre15">ForkJoinPool</kbd> class hands it over to your handler, which in turn writes the message to the console and exits the program. The task doesn't start its execution.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can test two interesting variants of this example:</p>
<ul class="calibre17">
<li class="calibre18">If you comment the following line in the Handler class and execute the program, you will see a lot of messages written in the console. The <kbd class="calibre15">ForkJoinPool</kbd> class tries to start a worker thread to execute the task and, as it can't because they always throw an exception, it tries it over and over again:</li>
</ul>
<pre class="calibre23">
        System.exit(-1); 
</pre>
<ul class="calibre17">
<li class="calibre18">Something like that occurs if you change the third parameter (the exception handler) of the <kbd class="calibre15">ForkJoinPool</kbd> class constructor for the null value. In this case, you will see how the JVM writes the exceptions in the console.</li>
</ul>
<ul class="calibre17">
<li class="calibre18">Take this into account when you implement your own worker threads that could throw exceptions.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in <a href="part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 5</span></a>, <em class="calibre14">Fork/Join Framework</em></li>
<li class="calibre18">The <em class="calibre14">Customizing tasks running in the fork/join framework</em> and <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</em> recipes in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using a blocking thread-safe queue for communicating with producers and consumers</h1>
            

            <article>
                
<p class="calibre4">The producer/consumer problem is a classical problem in concurrent programming. You have one or more producers of data that store this data in a buffer. You also have one or more consumers of data that take the data from the same buffer. Both producers and consumers share the same buffer, so you have to control access to it to avoid data inconsistency problems. When the buffer is empty, the consumers wait until the buffer has elements. If the buffer is full, the producers wait until the buffer has empty space.</p>
<p class="calibre4">This problem has been implemented using almost all the techniques and synchronization mechanisms developed in Java and in other languages (refer to the <em class="calibre14">See Also</em> section to get more information). One advantage of this problem is that it can be extrapolated to a lot of real-world situations.</p>
<p class="calibre4">The Java 7 Concurrency API introduced a data structure oriented to be used in these kinds of problem. It's the <kbd class="calibre15">LinkedTransferQueue</kbd> class, and its main characteristics are as follows:</p>
<ul class="calibre17">
<li class="calibre18">It's a blocking data structure. The thread is blocked until the operation can be made, provided that the operations are performed immediately.</li>
<li class="calibre18">Its size has no limit. You can insert as many elements as you want.</li>
<li class="calibre18">It's a parameterized class. You have to indicate the class of the elements you're going to store in the list.</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">LinkedTransferQueue</kbd> class running a lot of producer and consumer tasks that share a buffer of strings.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Perform the following steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Producer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Producer implements Runnable { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">LinkedTransferQueue</kbd> attribute parameterized with the <kbd class="calibre15">String</kbd> class named buffer:</li>
</ol>
<pre class="calibre23">
        private LinkedTransferQueue&lt;String&gt; buffer; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named name to store the name of the producer:</li>
</ol>
<pre class="calibre23">
        private String name; 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Producer(String name, LinkedTransferQueue&lt;String&gt; buffer){ <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>        } 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Store <kbd class="calibre15">10,000</kbd> strings in the buffer using the <kbd class="calibre15">put()</kbd> method of the buffer object and write a message to the console indicating the end of the method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;10000; i++) { <br class="title-page-name"/>            buffer.put(name+": Element "+i); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Producer: %s: Producer done\n",name); <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a class named <kbd class="calibre15">Consumer</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Consumer implements Runnable { 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Declare a private <kbd class="calibre15">LinkedTransferQueue</kbd> attribute parameterized with the <kbd class="calibre15">String</kbd> class named buffer:</li>
</ol>
<pre class="calibre23">
        private LinkedTransferQueue&lt;String&gt; buffer; 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named name to store the name of the consumer:</li>
</ol>
<pre class="calibre23">
        private String name; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Consumer(String name, LinkedTransferQueue&lt;String&gt; buffer){ <br class="title-page-name"/>          this.name=name; <br class="title-page-name"/>          this.buffer=buffer; <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Take out 10,000 strings from the buffer using the <kbd class="calibre15">take()</kbd> method of the buffer object and write a message to the console indicating the end of the method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;10000; i++){ <br class="title-page-name"/>            try { <br class="title-page-name"/>              buffer.take(); <br class="title-page-name"/>            } catch (InterruptedException e) { <br class="title-page-name"/>              e.printStackTrace(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("Consumer: %s: Consumer done\n",name); <br class="title-page-name"/>        } 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the main class of the example. Create a class named <kbd class="calibre15">Main</kbd> and add to it the <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare a constant named <kbd class="calibre15">THREADS</kbd> and assign to it the value <kbd class="calibre15">100</kbd>. Create a <kbd class="calibre15">LinkedTransferQueue</kbd> object with the <kbd class="calibre15">String</kbd> class object and call it buffer:</li>
</ol>
<pre class="calibre23">
        final int THREADS=100; <br class="title-page-name"/>        LinkedTransferQueue&lt;String&gt; buffer=new LinkedTransferQueue&lt;&gt;(); 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create an array of 100 Thread objects to execute 100 producer tasks:</li>
</ol>
<pre class="calibre23">
        Thread producerThreads[]=new Thread[THREADS]; 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create an array of 100 Thread objects to execute 100 consumer tasks:</li>
</ol>
<pre class="calibre23">
        Thread consumerThreads[]=new Thread[THREADS]; 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create and launch 100 <kbd class="calibre15">Consumer</kbd> objects and store the threads in the array created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;THREADS; i++){ <br class="title-page-name"/>          Consumer consumer=new Consumer("Consumer "+i,buffer); <br class="title-page-name"/>          consumerThreads[i]=new Thread(consumer); <br class="title-page-name"/>          consumerThreads[i].start(); <br class="title-page-name"/>        } 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create and launch 100 <kbd class="calibre15">Producer</kbd> objects and store the threads in the array created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;THREADS; i++) { <br class="title-page-name"/>          Producer producer=new Producer("Producer: "+ i , buffer); <br class="title-page-name"/>          producerThreads[i]=new Thread(producer); <br class="title-page-name"/>          producerThreads[i].start(); <br class="title-page-name"/>        } 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Wait for the finalization of the threads using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;THREADS; i++){ <br class="title-page-name"/>          try { <br class="title-page-name"/>            producerThreads[i].join(); <br class="title-page-name"/>            consumerThreads[i].join(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Write a message to the console with the size of the buffer:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Size of the buffer: %d\n",<br class="title-page-name"/>                          buffer.size()); <br class="title-page-name"/>        System.out.printf("Main: End of the example\n"); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you have used the <kbd class="calibre15">LinkedTransferQueue</kbd> class parameterized with the String class to implement the producer/consumer problem. This <kbd class="calibre15">LinkedTransferQueue</kbd> class is used as a buffer to share the data between producers and consumers.</p>
<p class="calibre4">You have implemented a <kbd class="calibre15">Producer</kbd> class that adds strings to the buffer using the <kbd class="calibre15">put()</kbd> method. You have executed 100 producers and every producer inserts in the buffer 10,000 strings, so you insert 1,000,000 strings in the buffer. The <kbd class="calibre15">put()</kbd> method adds the element at the end of the buffer.</p>
<p class="calibre4">You also have implemented a <kbd class="calibre15">Consumer</kbd> class, which gets a string from the buffer using the <kbd class="calibre15">take()</kbd> method. This method returns and deletes the first element of the buffer. If the buffer is empty, the method blocks the thread that makes the call until there are strings in the buffer to consume. You have executed 100 consumers, and every consumer gets 10,000 strings from the buffer.</p>
<p class="calibre4">In the example, first, you have launched the consumers and then the producers, so, as the buffer is empty, all the consumers will be blocked until the producers begin their execution and stores strings in the list.</p>
<p class="calibre4">The following screenshot shows part of the output of an execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border13" src="../images/00074.jpeg"/></div>
<p class="calibre4">To write the number of elements of the buffer, you have used the <kbd class="calibre15">size()</kbd> method. You have to take into account that this method can return a value that is not real, if you use them when there are threads adding or deleting data in the list. The method has to traverse the entire list to count the elements and the contents of the list can change for this operation. Only if you use them when there aren't any threads modifying the list, you will have the guarantee that the returned result is correct.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">LinkedTransferQueue</kbd> class provides other useful methods. The following are some of them:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getWaitingConsumerCount()</kbd>: This method returns the number of consumers that are blocked in the <kbd class="calibre15">take()</kbd> method or <kbd class="calibre15">poll (long timeout, TimeUnit unit)</kbd> because the <kbd class="calibre15">LinkedTransferQueue</kbd> object is empty.</li>
<li class="calibre18"><kbd class="calibre15">hasWaitingConsumer()</kbd>: This method returns <kbd class="calibre15">true</kbd> if the <kbd class="calibre15">LinkedTransferQueue</kbd> object has consumers waiting, or false otherwise.</li>
<li class="calibre18"><kbd class="calibre15">offer(E e)</kbd>: This method adds the element passed as a parameter at the end of the <kbd class="calibre15">LinkedTransferQueue</kbd> object and returns the true value. <kbd class="calibre15">E</kbd> represents the class used to parameterize the declaration of the <kbd class="calibre15">LinkedTransferQueue</kbd> class or a subclass of it.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>: This method returns the first element in the <kbd class="calibre15">LinkedTransferQueue</kbd> object, but it doesn't delete it from the list. If the queue is empty, the method returns the null value.</li>
<li class="calibre18"><kbd class="calibre15">poll(long timeout, TimeUnit unit)</kbd>: This version of the poll method, if the <kbd class="calibre15">LinkedTransferQueue</kbd> buffer is empty, waits for it for a specified period of time. If the specified period of time passes and the buffer is still empty, the method returns a <kbd class="calibre15">null</kbd> value. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants-<kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using conditions in synchronized code</em> recipe in <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em></li>
<li class="calibre18">The <em class="calibre14">Exchanging data between concurrent tasks</em> recipe in <a href="part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 3</span></a>, <em class="calibre14">Thread Synchronization Utilities</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a Thread class</h1>
            

            <article>
                
<p class="calibre4">Threads are the most basic element of the Java Concurrency API. Every Java program has at least one thread that executes the <kbd class="calibre15">main()</kbd> method, which, in turn, starts the execution of the application. When you launch a new <kbd class="calibre15">Thread</kbd> class, it's executed in parallel with the other threads of the application and with the other processes on an operating system. There is a critical difference between process and thread. A process is an instance of an application that is running (for example, you're editing a document in a text processor). This process has one or more threads that execute the tasks that make the process. You can be running more than one process of the same application, for example, two instances of the text processor. Threads inside a process share the memory while processes of the same OS don't.</p>
<p class="calibre4">All the kinds of Java tasks that you can execute (<kbd class="calibre15">Runnable</kbd>, <kbd class="calibre15">Callable</kbd>, or fork/join tasks) are executed in threads, and all the advanced Java concurrency mechanisms, such as the <kbd class="calibre15">Executor</kbd> framework and the fork/join framework, are based on pools of threads.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about the status of a <kbd class="calibre15">Thread</kbd> class and how to obtain it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Perform the following steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method of the task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Create a loop with 100 steps:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;100; i++) { 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">In each step, put the thread to sleep for 100 milliseconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.MILLISECONDS.sleep(100); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Write a message in the console with the name of the thread and the step number:</li>
</ol>
<pre class="calibre23">
              System.out.printf("%s: %d\n",Thread.currentThread()<br class="title-page-name"/>                                                  .getName(),i);      <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create the main class of the example. Create a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception{ 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object named task:</li>
</ol>
<pre class="calibre23">
        Task task = new Task(); 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a <kbd class="calibre15">Thread</kbd> array with five elements:</li>
</ol>
<pre class="calibre23">
        Thread threads[] = new Thread[5]; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create and start five threads to execute the <kbd class="calibre15">Task</kbd> object created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i = 0; i &lt; 5; i++) { <br class="title-page-name"/>          threads[i] = new Thread(task); <br class="title-page-name"/>          threads[i].setPriority(i + 1); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a loop with ten steps to write information about the threads launched before. Inside it, create another loop with five steps:</li>
</ol>
<pre class="calibre23">
        for (int j = 0; j &lt; 10; j++) { <br class="title-page-name"/>          System.out.printf("Main: Logging threads\n"); <br class="title-page-name"/>          for (int i = 0; i &lt; threads.length; i++) { 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">For each thread, write its name, its status, its group, and the length of its stack trace in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("**********************\n"); <br class="title-page-name"/>        System.out.printf("Main: %d: Id: %d Name: %s: Priority: %d\n",i,<br class="title-page-name"/>                          threads[i].getId(),threads[i].getName(),<br class="title-page-name"/>                          threads[i].getPriority()); <br class="title-page-name"/>        System.out.printf("Main: Status: %s\n",threads[i].getState()); <br class="title-page-name"/>        System.out.printf("Main: Thread Group: %s\n",<br class="title-page-name"/>                          threads[i].getThreadGroup()); <br class="title-page-name"/>        System.out.printf("Main: Stack Trace: \n"); 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Write a loop to write the stack trace of the thread:</li>
</ol>
<pre class="calibre23">
          for (int t=0; t&lt;threads[i].getStackTrace().length; t++) { <br class="title-page-name"/>            System.out.printf("Main: %s\n",threads[i].getStackTrace()<br class="title-page-name"/>                              [t]); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("**********************\n"); <br class="title-page-name"/>        } 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Put the thread to sleep for one second and close the loop and the class:</li>
</ol>
<pre class="calibre23">
              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you have used the following methods to get information about a <kbd class="calibre15">Thread</kbd> class:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getId()</kbd>: This method returns the ID of a thread. It's a unique long number and it can't be changed.</li>
<li class="calibre18"><kbd class="calibre15">getName()</kbd>: This method returns the name of a thread. If you don't establish the name of the thread, Java gives it a default name.</li>
<li class="calibre18"><kbd class="calibre15">getPriority()</kbd>: This method returns the priority of execution of a thread. Threads with higher priority are executed in preference to threads with lower priority. It's an <kbd class="calibre15">int</kbd> value that has a value between the <kbd class="calibre15">MIN_PRIORITY</kbd> and <kbd class="calibre15">MAX_PRIORITY</kbd> constants of the <kbd class="calibre15">Thread</kbd> class. By default, threads are created with the same priority that specified by the constant <kbd class="calibre15">NORM_PRIORITY</kbd> of the <kbd class="calibre15">Thread</kbd> class.</li>
<li class="calibre18"><kbd class="calibre15">getState()</kbd>: This method returns the status of a thread. It's a <kbd class="calibre15">Thread.State</kbd> object. The <kbd class="calibre15">Thread.State</kbd> enumeration has all the possible states of a thread.</li>
<li class="calibre18"><kbd class="calibre15">getThreadGroup()</kbd>: This method returns the <kbd class="calibre15">ThreadGroup</kbd> object of a thread. By default, threads belong to the same thread group, but you can establish a different one in the constructor of a thread.</li>
<li class="calibre18"><kbd class="calibre15">getStackTrace()</kbd>: This method returns an array of <kbd class="calibre15">StackTraceElement</kbd> objects. Each of these objects represent a call to a method that begins with the <kbd class="calibre15">run()</kbd> method of a thread and includes all the methods that have been called until the actual execution point. When a new method is called, a new stack trace element is added to the array. When a method finishes its execution, its stack trace element is removed from the array.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Thread</kbd> class includes other methods that provide information about it that can be useful. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">activeCount()</kbd>: This method returns the number of active threads in a group of threads.</li>
<li class="calibre18"><kbd class="calibre15">dumpStack()</kbd>: This method prints the stack trace of a thread to the standard error output.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating, running, and setting the characteristics of a thread</em> recipe in <a href="part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre14">Thread Management</em></li>
<li class="calibre18">The <em class="calibre14">Using a ThreadFactory interface in an Executor framework</em> and <em class="calibre14">Implementing a ThreadFactory interface to generate custom threads for the fork/join framework</em> recipes in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a Semaphore class</h1>
            

            <article>
                
<p class="calibre4">A semaphore is a counter that protects the access to one or more shared resources.</p>
<div class="packt_infobox">The concept of semaphore was introduced by Edsgar Dijkstra in 1965 and was used for the first time in the THEOS operating system.</div>
<p class="calibre4">When a thread wants to use shared resources, it must acquire a semaphore. If the internal counter of the semaphore is greater than 0, the semaphore decrements the counter and allows the access to the shared resource. If the counter of the semaphore is 0, the semaphore blocks the thread until the counter is greater than 0. When the thread has finished using the shared resource, it must release the semaphore. That operation increases the internal counter of the semaphore.</p>
<p class="calibre4">In Java, semaphores are implemented in the <kbd class="calibre15">Semaphore</kbd> class.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about the status of a semaphore and how to obtain it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Perform the following steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">Semaphore</kbd> attribute named <kbd class="calibre15">semaphore</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Semaphore semaphore; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Task(Semaphore semaphore){ <br class="title-page-name"/>          this.semaphore=semaphore; <br class="title-page-name"/>        } 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First, acquire permit for the <kbd class="calibre15">semaphore</kbd> attribute writing a message in the console to indicate that circumstance:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          try { <br class="title-page-name"/>            semaphore.acquire(); <br class="title-page-name"/>            System.out.printf("%s: Get the semaphore.\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, put the thread to sleep for two seconds using the <kbd class="calibre15">sleep()</kbd> method. Finally, release the permit and write a message in the console to indicate that circumstance:</li>
</ol>
<pre class="calibre23">
          TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>          System.out.println(Thread.currentThread().getName()+":<br class="title-page-name"/>                             Release the semaphore."); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } finally { <br class="title-page-name"/>          semaphore.release();       <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the main class of the example. Create a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception { 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a <kbd class="calibre15">Semaphore</kbd> object named <kbd class="calibre15">semaphore</kbd> with three permits:</li>
</ol>
<pre class="calibre23">
        Semaphore semaphore=new Semaphore(3); 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create an array to store 10 <kbd class="calibre15">Thread</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[10]; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create and start 10 <kbd class="calibre15">Thread</kbd> objects to execute 10 <kbd class="calibre15">Task</kbd> objects. After starting a thread, put the thread to sleep for 200 milliseconds and call the <kbd class="calibre15">showLog()</kbd> method to write information about the <kbd class="calibre15">Semaphore</kbd> class:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          Task task=new Task(semaphore); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>               <br class="title-page-name"/>          TimeUnit.MILLISECONDS.sleep(200); <br class="title-page-name"/>              <br class="title-page-name"/>          showLog(semaphore); <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement a loop with five steps to call the <kbd class="calibre15">showLog()</kbd> method to write information about the <kbd class="calibre15">semaphore</kbd> and put the thread to sleep for <kbd class="calibre15">1</kbd> second:</li>
</ol>
<pre class="calibre23">
          for (int i=0; i&lt;5; i++) { <br class="title-page-name"/>            showLog(semaphore); <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">showLog()</kbd> method. It receives a <kbd class="calibre15">Semaphore</kbd> object as parameter. Write in the console information about the available permits, queued threads, and permits of the <kbd class="calibre15">semaphore</kbd>:</li>
</ol>
<pre class="calibre23">
        private static void showLog(Semaphore semaphore) { <br class="title-page-name"/>          System.out.printf("********************\n"); <br class="title-page-name"/>          System.out.printf("Main: Semaphore Log\n"); <br class="title-page-name"/>          System.out.printf("Main: Semaphore: Avalaible Permits: %d\n",<br class="title-page-name"/>                            semaphore.availablePermits()); <br class="title-page-name"/>          System.out.printf("Main: Semaphore: Queued Threads: %s\n",<br class="title-page-name"/>                            semaphore.hasQueuedThreads()); <br class="title-page-name"/>          System.out.printf("Main: Semaphore: Queue Length: %d\n",<br class="title-page-name"/>                            semaphore.getQueueLength()); <br class="title-page-name"/>          System.out.printf("Main: Semaphore: Fairness: %s\n",<br class="title-page-name"/>                            semaphore.isFair()); <br class="title-page-name"/>          System.out.printf("********************\n"); <br class="title-page-name"/>        } 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you have used the following methods to get information about a <kbd class="calibre15">semaphore</kbd>:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">availablePermits()</kbd>: This method returns an <kbd class="calibre15">int</kbd> value, which is the number of available resources of a semaphore.</li>
<li class="calibre18"><kbd class="calibre15">hasQueuedThreads()</kbd>: This method returns a Boolean value indicating if there are threads waiting for a resource protected by a semaphore.</li>
<li class="calibre18"><kbd class="calibre15">getQueueLength()</kbd>: This method returns the number of threads that are waiting for a resource protected by a semaphore.</li>
<li class="calibre18"><kbd class="calibre15">isFair()</kbd>: This method returns a Boolean value indicating if a semaphore has the fair mode activated. When the fair mode is active (this method returns the true value), and the lock has to select another thread to give to it the access to the shared resource, it selects the longest-waiting thread. If the fair mode is inactive (this method returns the false value), there is no guarantee about the order in which threads are selected to get the access to the shared resource.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Controlling concurrent access to one or more copies of a resource</em> recipes in <a href="part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 3</span></a>, <em class="calibre14">Thread Synchronization Utilities</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Generating concurrent random numbers</h1>
            

            <article>
                
<p class="calibre4">The Java concurrency API provides a specific class to generate pseudorandom numbers in concurrent applications. It's the <kbd class="calibre15">ThreadLocalRandom</kbd> class and it's new in Java 7 version. It works as the thread's local variables. Every thread that wants to generate random numbers has a different generator, but all of them are managed from the same class, in a transparent way to the programmer. With this mechanism, you will get a better performance than using a shared Random object to generate the random numbers of all the threads.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">ThreadLocalRandom</kbd> class to generate random numbers in a concurrent application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or any other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">TaskLocalRandom</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class TaskLocalRandom implements Runnable { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Get the name of the thread that is executing this task and write 10 random integer numbers to the console using the <kbd class="calibre15">nextInt()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          String name=Thread.currentThread().getName(); <br class="title-page-name"/>          for (int i=0; i&lt;10; i++){ <br class="title-page-name"/>            System.out.printf("%s: %d\n",name,<br class="title-page-name"/>                              ThreadLocalRandom.current().nextInt(10)); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and add the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create an array for three <kbd class="calibre15">Thread</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[3]; 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create and launch three <kbd class="calibre15">TaskLocalRandom</kbd> tasks. Store the threads in the array created earlier:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;3; i++) { <br class="title-page-name"/>          TaskLocalRandom task=new TaskLocalRandom(); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        } 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The key of this example is in the <kbd class="calibre15">TaskLocalRandom</kbd> class. In the constructor of the class, we make a call to the <kbd class="calibre15">current()</kbd> method of the <kbd class="calibre15">ThreadLocalRandom</kbd> class. This is a static method that returns the <kbd class="calibre15">ThreadLocalRandom</kbd> object associated with the current thread, so you can generate random numbers using that object. If the thread that makes the call does not have any object associated yet, the class creates a new one. In this case, you use this method to initialize the random generator associated with this task, so it will be created in the next call to the method.</p>
<p class="calibre4">In the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">TaskLocalRandom</kbd> class, make a call to the <kbd class="calibre15">current()</kbd> method to get the random generator associated with this thread, also you make a call to the <kbd class="calibre15">nextInt()</kbd> method passing the number 10 as the parameter. This method will return a pseudo random number between 0 and 10. Each task generates 10 random numbers.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ThreadLocalRandom</kbd> class also provides methods to generate long, float, and double numbers, and Boolean values. There are methods that allow you to provide a number as a parameter to generate random numbers between zero and that number. The other methods allow you to provide two parameters to generate random numbers between these numbers.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<p class="calibre4">The <em class="calibre14">Using local thread variables</em> recipe in <a href="part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre14">Thread management</em></p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>