- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing API Evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating an API is a frequent and necessary process as business requirements
    evolve and new features are introduced. However, it requires careful decision-making
    to avoid breaking existing client integrations. Even small changes to an API’s
    structure, behavior, or response format can have significant impacts on consumers
    who depend on a stable, predictable interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to evolve your APIs while ensuring backward
    compatibility. We will also discuss strategies for versioning APIs in cases when
    a breaking change is necessary, using the example of our product API.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin the chapter by exploring different **versioning strategies** that
    can be applied to RESTful APIs. **Versioning** is a critical aspect of API design,
    as it ensures that your application can evolve over time without breaking existing
    client integrations. We will examine several versioning techniques, such as URL
    versioning, query parameter versioning, HTTP header versioning, and content negotiation,
    while discussing the challenges each approach presents, including maintenance,
    compatibility, and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll take our existing product API and introduce a breaking change, which
    will require us to implement a versioning strategy. By evolving our API, we will
    ensure that clients using earlier versions remain unaffected while enabling new
    functionality for those adopting the latest version. This process highlights the
    importance of backward compatibility and minimizing disruption for users, even
    as the API continues to evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will explore the best practices for managing API evolution over
    time. We will discuss how to gracefully deprecate old versions, effectively communicate
    changes with clients, and maintain multiple versions of an API without creating
    unnecessary complexity. By the end of this chapter, you will have a solid understanding
    of how to implement versioning strategies that support long-term growth and stability
    for your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Versioning strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing versioning in the product API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing API evolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will evolve our product API. To be able to follow along
    and use the code examples as they are printed in the book, you should have the
    product API code that was created in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .
  prefs: []
  type: TYPE_NORMAL
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/
    Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Versioning strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Versioning refers to the practice of managing changes in an application over
    time by assigning distinct version numbers to different stages of the API’s life
    cycle. It ensures that updates to an API—such as new features or breaking changes—can
    be introduced without disrupting existing clients that rely on earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning became critical for REST APIs as the architecture of software systems
    shifted from monolithic to distributed systems. In monolithic architectures, where
    the consumer and provider of a service typically reside within the same application,
    there is direct control over both ends of the communication. When changes are
    made, they are applied uniformly across the entire system, ensuring that the consumer
    is always in sync with the provider. Hence, the versioning of interfaces within
    a monolithic application is not necessary because the consumers are tightly coupled
    with the providers, and updates are deployed simultaneously without causing compatibility
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the rise of distributed systems and the adoption of REST APIs,
    which serve multiple independent clients (such as web browsers, mobile apps, and
    third-party services), the situation changed dramatically. REST APIs expose services
    to the outside world, where different clients may use different versions of the
    API simultaneously. This introduces a challenge—how do you update the API to introduce
    new features or fix issues without breaking functionality for existing clients?
    Versioning solves this by allowing multiple versions of the API to coexist, ensuring
    backward compatibility, and enabling the API to evolve over time while still supporting
    older clients.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can apply versioning strategies to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring versioning strategies, it’s essential to distinguish between
    backward-compatible changes and breaking changes. Understanding this distinction
    is crucial because, for breaking changes, updating the API version is necessary
    to ensure existing clients can continue to use the API smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Breaking changes** are modifications that disrupt existing client interactions
    with the API. These changes typically necessitate a new API version to prevent
    breaking current integrations. These are some examples of breaking changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing an endpoint** : Deleting an existing API endpoint that clients rely
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changing response data structure** : Altering the format of response data,
    such as renaming or removing fields in the JSON response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifying required parameters** : Changing required parameters for an endpoint,
    which could cause existing requests to fail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Altering authentication methods** : Changing or removing existing authentication
    mechanisms or security protocols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changing endpoint behavior** : Modifying the behavior of an endpoint so that
    it no longer performs as it did previously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In contrast, **backward-compatible changes** enhance or extend the API without
    disrupting existing clients. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding new optional fields** : Introducing new fields to the response payload
    that are not required for existing clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding new endpoints** : Creating new API endpoints that provide additional
    functionality without affecting existing ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending response data** : Adding extra information to the response data
    that does not alter the existing structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding new query parameters** : Introducing optional query parameters to
    existing endpoints that offer additional filtering or functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhancing documentation** : Improving or expanding API documentation to provide
    more details without altering the API itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we understand the need for using versioning for breaking changes,
    let’s explore various versioning strategies, along with their advantages and disadvantages.
    The most common strategies include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: URL path versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameter versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP header versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go deep into each versioning strategy and understand when to use one instead
    of the other.
  prefs: []
  type: TYPE_NORMAL
- en: URL path versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: URL path versioning is one of the most common and straightforward strategies
    for versioning REST APIs. This strategy is used by many companies, such as X,
    Google, GitLab, and others. In this strategy, the version number is included directly
    within the API’s URL path, such as `https://api.product.com/v1/products.`
  prefs: []
  type: TYPE_NORMAL
- en: This approach makes it easy for both developers and clients to identify and
    access specific versions of an API without any ambiguity. By embedding the version
    number in the URL path, API consumers have a clear and explicit way of requesting
    the desired version, ensuring that any integration remains stable even as the
    API evolves. Additionally, the server can easily route incoming requests to the
    correct version of the code base, simplifying maintenance and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: URL path versioning provides several clear advantages for API management. One
    of its primary benefits is that version numbers are directly visible in the URI,
    making it immediately clear which version of the API is being accessed. Additionally,
    URL versioning integrates well with HTTP caching mechanisms, as different versions
    of the API are treated as distinct resources, allowing for the effective and independent
    caching of each version. It also facilitates bookmarking and sharing, enabling
    users to save and reference specific versions of endpoints easily, ensuring consistency
    in interactions.
  prefs: []
  type: TYPE_NORMAL
- en: However, URL versioning also presents certain drawbacks. Over time, maintaining
    multiple versions can lead to cluttered URIs, especially if multiple versions
    of the API are maintained simultaneously. Moreover, once a version is embedded
    in the URL path, it becomes part of the API’s public contract. Furthermore, the
    overhead associated with managing numerous URLs can increase complexity in both
    development and documentation processes.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a new feature, breaking changes typically affect only a few
    specific endpoints, not the entire API. If you update the version number for endpoints
    that haven’t changed, it can create unnecessary confusion for both clients and
    maintainers. This approach makes it harder to understand how different versions
    of various endpoints should be used together, potentially complicating the integration
    process and hindering overall API clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Using URL paths for versioning is well-suited for many scenarios, particularly
    when clear and explicit versioning is crucial. It is an excellent choice for APIs
    that are stable, with minimal expected changes that could introduce breaking modifications.
    URL path versioning provides a straightforward approach to managing different
    versions, making it easier to track and maintain the API as it evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameter versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query parameter versioning involves specifying the API version as a query parameter
    in the URL, such as `https://api.product.com/products?version=1` . This approach
    is commonly recommended in Microsoft’s guidelines. This strategy makes it easier
    to implement and introduce new versions without modifying URL paths. This can
    be particularly useful when you want to maintain a consistent endpoint path structure
    while still providing version-specific functionality. It also allows versioning
    without creating a proliferation of URL paths.
  prefs: []
  type: TYPE_NORMAL
- en: However, it has some drawbacks. Clients must include the version parameter with
    every request, which adds an extra step in request construction. Additionally,
    the API server must handle versioning logic based on query parameters, potentially
    complicating implementation and increasing processing overhead. Furthermore, the
    version information is less visible in the URL, making it harder to quickly identify
    which version is being accessed. This lack of clarity can cause confusion, especially
    when the versioning affects critical parts of the API’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Another concern is how query parameter versioning interacts with caching. Since
    the version is embedded in the query string rather than the URL path, caching
    mechanisms may not handle it as effectively. This can lead to complications in
    how different versions of the API are cached, potentially impacting performance
    and efficiency for clients who rely on caching to improve response times.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP header versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP header versioning involves specifying the API version in the HTTP headers
    of a request. This approach allows clients to indicate which version of the API
    they wish to use by including a custom header, such as `X-API-Version` , in their
    requests. GitHub is an example of an application that uses the HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This strategy keeps the URL clean and avoids cluttering it with versioning information.
    It also provides a flexible and less intrusive way to manage versions, as it does
    not alter the endpoint paths or query strings. Additionally, HTTP header versioning
    can facilitate smoother transitions between versions since the versioning information
    is separated from the URL being the resource identifier, reducing the risk associated
    with breaking changes for clients.
  prefs: []
  type: TYPE_NORMAL
- en: However, HTTP header versioning presents some challenges. Unlike URL versioning,
    the versioning information is not immediately visible in the URL, which can make
    debugging and documentation more complex. This lack of visibility can hinder developers
    and clients when troubleshooting issues or understanding API versions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, custom headers can lead to inconsistent implementation practices
    across different APIs. When APIs use custom headers, it becomes challenging to
    establish uniform standards, which can confuse developers and users alike. For
    example, one API might use `X-Api-Version` while another might use `X-Version`
    , leading to ambiguity and potential integration issues. The use of the `X-` prefix
    for custom headers has been deprecated since the introduction of RFC 6648 in 2012.
    As an alternative, the content negotiation strategy leverages existing headers,
    avoiding the need for custom headers, and ensuring better adherence to standard
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Content negotiation is one of the techniques used to handle versioning in RESTful
    APIs, allowing clients to specify the API version via HTTP headers rather than
    through the URL path. The idea is to let the client request a particular version
    of the API by sending a specific `Accept` header. For example, a client might
    request version 1 of the API in JSON format by sending the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This technique of API versioning via content negotiation is closely related
    to HTTP header versioning, as both strategies rely on HTTP headers to specify
    the version. The key difference is that content negotiation avoids creating custom
    HTTP headers, adhering to RFC 6648, which discourages custom headers. Instead,
    this method uses standard headers such as `Accept` and `Content-Type` to specify
    both the format and version of the response, promoting a cleaner and more standardized
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is widely adopted by large organizations such as Adidas and Mambu.
    The content negotiation strategy is aligned with the REST standard in that it
    follows the principle of content negotiation, where the client and server agree
    on the representation format and version via headers, keeping the interface flexible
    and compliant with RESTful best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Since our API is already implemented, we will adopt a content negotiation strategy
    to enable seamless evolution, allowing new features to be introduced without disrupting
    existing clients or causing breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing versioning in the product API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our product API is already in use by other applications, it’s essential to
    maintain stability while continuing to evolve the API to meet new requirements.
    One of the challenges in API development is balancing the need for enhancements
    while not disrupting existing consumers. In this section, we will explore how
    to implement versioning in the product API to handle changes without causing breaking
    issues for clients.
  prefs: []
  type: TYPE_NORMAL
- en: The product API currently returns a complete list of products without pagination.
    To improve performance and scalability, we’ve decided to introduce pagination
    to the product list response. This modification will change the current behavior,
    potentially disrupting users who rely on the existing output. To prevent any impact
    on their workflows, we will implement a versioning strategy. This approach will
    allow us to support the new paginated format for future clients while maintaining
    backward compatibility for existing consumers, ensuring that the API can evolve
    without interrupting service.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we will use the content negotiation strategy to introduce
    pagination into our product API without breaking the existing functionality. This
    strategy will allow us to evolve the API while letting clients specify the version
    they prefer through request headers. By utilizing content negotiation, we can
    offer both the original product list format and the new paginated version, ensuring
    backward compatibility and giving clients flexibility in how they consume the
    API. This method ensures a smooth transition for existing users while accommodating
    new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our product API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s enhance our API by adding new functionality to our list endpoint while
    maintaining backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our current API, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create another method to handle version 2 of our API, which will include
    support for pagination. To achieve this, we’ll add two `RequestParam` annotations:
    one to specify the current page and another to define the limit of the number
    of results per page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Design strategy to prevent backward-incompatible changes**'
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination in our example cannot be done without a breaking change because
    the response is a JSON array of the products, so there is no place for pagination
    information that is common for all products returned (the total number of pages).
    A trick to prevent this situation is, instead of using a JSON array at the top
    level, to wrap the list (JSON array) in a JSON object even if it would have just
    one attribute. This minimal additional overhead would allow us to evolve the API
    without introducing a breaking change. We would just add optional pagination request
    parameters, and the pagination information could be added to the object at the
    root level of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see these `RequestParam` annotations in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By adding `produces = "application/vnd.packt-v2+json"` , we enable Spring to
    route any request with the `Accept` header set to `application/vnd.packt-v2+json`
    to the appropriate endpoint. This allows clients to receive the response tailored
    to their version by specifying the `Accept` header in their API requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also updated the API response to return a `PaginatedProducts` class,
    which now includes the `totalPages` attribute, as we can see in the following
    code. This addition is crucial for the client to determine whether more resources
    are available or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We opted to modify the response body to include this information, though other
    strategies could have been used to achieve the same goal, as we will explore in
    [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135) .
  prefs: []
  type: TYPE_NORMAL
- en: 'With the addition of this new endpoint ( `getProductsV2` ), we need to update
    the `ProductsQueryUseCase` class to include the necessary implementation code.
    In the following example, the `getAllProducts` method now accepts a `Pageable`
    object from Spring, which handles pagination details. The method returns a `Page`
    object containing the list of products along with metadata such as the total number
    of pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, adding this endpoint requires us to change the `ProductsApi`
    interface and add the definition and documentation of our endpoint, as we can
    see in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the documentation code, let’s see what our Swagger documentation
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Swagger UI](img/B21843_05_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.1* illustrates our API, showcasing the `/api/products` endpoint with
    two parameters and a new response format when the media type is `application/vnd.packt-v2+json`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'By switching the media type to `application/json` , as we can see in *Figure
    5.2* , the API will change the response to its previous behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Swagger UI](img/B21843_05_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the API maintains backward compatibility by providing the original
    output for older clients. However, our documentation still enforces parameters,
    even though they aren’t being used. Unfortunately, OpenAPI 3.x does not support
    varying parameters based on content type.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming OpenAPI 4.x, expected by the end of 2024, will address the limitation
    of supporting different query parameters according to the content type. Since
    we are currently using 3.x, this feature is not supported in our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: With the new version implemented, it’s time to validate our changes and ensure
    everything functions as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and validating our product API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our product API is equipped to support multiple versions, it’s time
    to test and validate the functionality. We want to ensure that each version of
    the API behaves as expected, delivering the correct responses without breaking
    any existing functionality. To achieve this, we can use tools such as Swagger
    for the graphical interface, or we can interact with the API directly via the
    command line using `curl` commands. By testing both the original and updated versions,
    we can confirm that the API handles different versions correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the list of products using the first version of the API, you can
    execute the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command sends a request to the API without specifying the version of the
    product API. The expected result is a list of products in the original format,
    without pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try the same request passing the page and the limit, using the following
    `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output will remain the same as before, even though we’ve specified a limit
    of two items. This occurs because the first version of our API wasn’t designed
    to handle pagination query parameters. As a result, the API ignores these parameters
    and the full list of products is returned, adhering to the behavior defined in
    version 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in our first version will return all available elements. We implemented
    the second version by passing Spring’s `Pageable` object. To adhere to the **Don’t
    Repeat Yourself** ( **DRY** ) principle, we must update the code from version
    1, where all items are returned by default, and we have to set the size to the
    maximum possible value. This ensures that the first version continues to function
    as expected without introducing pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve confirmed that our API functions as expected for the previous
    version, let’s move on to testing the latest version. To do this, we will use
    the `curl` command shown here to verify the behavior of the updated API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The key difference in this command compared to the previous one is the `Accept`
    header, where we specify `application/vnd.packt-v2+json` . By doing so, the Spring
    Framework will route the request to the version 2 endpoint of our API. The expected
    output is a paginated list of products, reflecting the new behavior introduced
    in version 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the response contains only two items, and the
    `totalPages` field reflects the pagination, adjusting the result according to
    the limit parameter we provided. This demonstrates that the latest version handles
    pagination as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have confirmed the expected behavior for both version 1 and version
    2, let us explore what happens when we attempt to access a non-existent version
    (let’s call it version 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can execute the following `curl` command and observe the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing it, the output will be the same as that obtained with version
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior might not be ideal, as it could mislead the client into thinking
    version 3 exists. This happens because, by default, the Spring Framework allows
    two media types: `application/json` and `application/*+json` . As a result, any
    request with the `application/*+json` media type will be processed by the default
    method unless explicitly mapped to a different version, as in our second version.
    Therefore, without specific handling, requests for version 3 may still be routed
    to the default version, giving an unintended response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can update our endpoint from version 1 and force
    it to accept only `application/json` , as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After applying this solution, when we execute the `curl` command with the `application/vnd.packt-v3+json`
    media type, we will encounter an error like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This error response helps the client easily identify the available versions
    of the endpoint. By returning a clear error when an unsupported version is requested,
    we provide immediate feedback, guiding the client toward the correct version and
    improving overall API usability.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve tested our solution and confirmed that it maintains the expected
    behavior from version 1 while introducing the new functionality in version 2,
    along with returning a `406 Not Acceptable` error for incorrect versions, we can
    shift our focus to managing these versions effectively as the API continues to
    evolve. Let’s explore how to handle versioning as our API grows and adapts to
    future needs.
  prefs: []
  type: TYPE_NORMAL
- en: Managing API evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing the evolution of an API is a critical aspect of long-term API maintenance.
    As applications grow and customer needs change, APIs must adapt and introduce
    new features while ensuring the stability and continuity of existing services.
    Effective management of API evolution involves planning for changes, communicating
    clearly with API consumers, and implementing strategies that avoid breaking existing
    functionality while introducing improvements in a structured and predictable manner.
  prefs: []
  type: TYPE_NORMAL
- en: To manage API evolution successfully, we should consider the key practices described
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding introducing breaking changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, the best approach to evolving your API is to ensure
    that new changes don’t disrupt existing clients by maintaining backward compatibility.
    This minimizes potential service interruptions and provides a smooth transition
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, it’s essential to clearly differentiate between breaking and
    non-breaking changes. When introducing breaking changes, applying versioning is
    crucial to preserve the integrity of the current functionality while allowing
    new features to coexist.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and applying a versioning strategy across your APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a breaking change is necessary, applying a versioning strategy is essential.
    There are many ways to version your API so, as discussed earlier, maintaining
    consistency in versioning is crucial for ensuring that clients can easily understand
    and interact with your API. A clear and predictable versioning strategy enhances
    the user experience, making it simpler for clients to navigate and integrate with
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: Having a well-defined REST guideline that outlines how to implement a versioning
    strategy consistently across all APIs, as mentioned in [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015)
    , is key, and establishing a unique versioning strategy provides numerous benefits,
    including improved usability and transparency for API consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and informing clients about new versions and deadlines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With multiple API versions in play, it is essential to establish clear migration
    guidelines and deprecation timelines. Providing detailed information on how to
    transition between versions helps clients understand the process and prepare for
    changes. This transparency is crucial for a smooth migration and the minimization
    of potential disruptions.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining an up-to-date changelog is equally important. It offers clients
    a comprehensive view of recent updates, bug fixes, and new features, ensuring
    they are informed of any modifications. A well-documented changelog supports clients
    in adapting to changes effectively and fosters a positive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Semantic versioning ( https://semver.org/ ) is a widely adopted system that
    clearly communicates the scope and impact of changes in an API. It uses a three-part
    format: `MAJOR.MINOR.PATCH` . For example, a major version change (e.g., from
    1.x to 2.0.0) alerts clients that breaking changes have been introduced, giving
    them time to adapt. In contrast, minor and patch updates (e.g., 1.1.0 or 1.0.1)
    reassure clients that improvements or bug fixes have been made without affecting
    compatibility. This structured approach allows developers to quickly assess the
    nature of an update, minimizing the risk of breaking existing functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: By implementing semantic versioning, we can offer clear guidelines and comprehensive
    changelogs to keep clients informed about updates. This structured approach helps
    clients understand the significance of each version change, making it easier for
    them to prepare for major updates that may require action.
  prefs: []
  type: TYPE_NORMAL
- en: For minor or patch updates, clients are notified of new features or bug fixes
    without immediate pressure to upgrade. This balance ensures that clients stay
    informed and can choose to update at their convenience, maintaining a smooth and
    flexible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Marking old endpoints as deprecated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of the API evolution process, it’s important to clearly mark endpoints
    scheduled for deprecation to give clients ample time to transition to new versions.
    Deprecating old endpoints helps signal to clients that updates are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenAPI provides a way to mark any endpoint as deprecated, which is reflected
    in the Swagger UI. This can be easily done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When we add the `deprecated` attribute and view it in the Swagger UI, the output
    will look like *Figure 5.3* . However, we chose not to use this attribute here
    because OpenAPI 3.x currently doesn’t support deprecated endpoints with versioning
    based on content negotiation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Swagger UI: Monitoring the usage of deprecated endpoints](img/B21843_05_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3 – Swagger UI: Monitoring the usage of deprecated endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the usage of deprecated endpoints is essential for ensuring a smooth
    transition when phasing out older versions of an API. By tracking requests to
    these endpoints, you can determine how many clients are still using outdated functionality
    and evaluate their progress in migrating to newer versions. This helps you make
    informed decisions about when to officially remove old versions, avoiding unexpected
    disruptions to your clients’ operations. Additionally, it provides insights into
    which clients might need extra support or communication during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring tools, such as Grafana, New Relic, Datadog, and Splunk, not only
    facilitate a smooth deprecation process but also help confirm the adoption of
    newer API versions. These insights enable you to set practical timelines for deprecating
    endpoints, ensuring their removal does not disrupt clients and enhancing trust
    and reliability in your API’s development.
  prefs: []
  type: TYPE_NORMAL
- en: Removing old endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have established a deadline, communicated with your clients, and provided
    clear instructions for upgrading to the latest version, the next step is to remove
    the deprecated endpoints. But, before finalizing the removal, it is crucial to
    verify that clients have successfully migrated to the newest version. This process
    involves not only deleting the old code but also ensuring that all references
    and dependencies related to these endpoints are thoroughly cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: By applying these principles, you can manage API evolution smoothly and effectively,
    minimizing the risk of disrupting existing clients while equipping them with the
    necessary tools and information to adapt seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a well-defined versioning strategy, using semantic versioning,
    and properly deprecating old endpoints allows your API to grow with minimal disruption.
    This approach ensures that your clients have sufficient time to transition, while
    you continue to improve and expand your API’s capabilities. Ultimately, it promotes
    long-term stability and improves the developer experience by allowing your API
    to evolve sustainably over time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various versioning strategies for REST APIs and
    learned how to evolve our API while maintaining compatibility and ensuring a smooth
    transition to newer versions. We also applied content negotiation versioning to
    our current API, specifically focusing on implementing pagination.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into more advanced topics, including enhanced
    pagination techniques, filtering, file uploads, and additional features to further
    refine your API.
  prefs: []
  type: TYPE_NORMAL
