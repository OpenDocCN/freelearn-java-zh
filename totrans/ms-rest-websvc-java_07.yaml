- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing API Evolution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理API演变
- en: Updating an API is a frequent and necessary process as business requirements
    evolve and new features are introduced. However, it requires careful decision-making
    to avoid breaking existing client integrations. Even small changes to an API’s
    structure, behavior, or response format can have significant impacts on consumers
    who depend on a stable, predictable interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着业务需求的变化和新功能的引入，更新API是一个频繁且必要的流程。然而，为了避免破坏现有的客户端集成，这需要谨慎的决策。即使是API结构、行为或响应格式的微小更改，也可能对依赖于稳定、可预测界面的消费者产生重大影响。
- en: In this chapter, we will show you how to evolve your APIs while ensuring backward
    compatibility. We will also discuss strategies for versioning APIs in cases when
    a breaking change is necessary, using the example of our product API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何在确保向后兼容性的同时演变您的API。我们还将讨论在必要时进行破坏性变更时对API进行版本控制的策略，以我们产品API为例。
- en: We will begin the chapter by exploring different **versioning strategies** that
    can be applied to RESTful APIs. **Versioning** is a critical aspect of API design,
    as it ensures that your application can evolve over time without breaking existing
    client integrations. We will examine several versioning techniques, such as URL
    versioning, query parameter versioning, HTTP header versioning, and content negotiation,
    while discussing the challenges each approach presents, including maintenance,
    compatibility, and complexity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章开始时探讨可以应用于RESTful API的不同**版本控制策略**。**版本控制**是API设计的关键方面，因为它确保您的应用程序可以在不破坏现有客户端集成的情况下随时间演变。我们将检查几种版本控制技术，如URL版本控制、查询参数版本控制、HTTP头版本控制以及内容协商，同时讨论每种方法所面临的挑战，包括维护、兼容性和复杂性。
- en: Next, we’ll take our existing product API and introduce a breaking change, which
    will require us to implement a versioning strategy. By evolving our API, we will
    ensure that clients using earlier versions remain unaffected while enabling new
    functionality for those adopting the latest version. This process highlights the
    importance of backward compatibility and minimizing disruption for users, even
    as the API continues to evolve.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对我们的现有产品API进行一次破坏性变更，这将需要我们实施一个版本控制策略。通过演变我们的API，我们将确保使用早期版本的客户端不受影响，同时为采用最新版本的客户端启用新功能。这个过程突出了向后兼容性和最小化对用户干扰的重要性，即使API持续演变。
- en: Finally, we will explore the best practices for managing API evolution over
    time. We will discuss how to gracefully deprecate old versions, effectively communicate
    changes with clients, and maintain multiple versions of an API without creating
    unnecessary complexity. By the end of this chapter, you will have a solid understanding
    of how to implement versioning strategies that support long-term growth and stability
    for your APIs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨管理API演变过程中的最佳实践。我们将讨论如何优雅地弃用旧版本，与客户端有效沟通变更，以及在不增加不必要复杂性的情况下维护API的多个版本。到本章结束时，您将深入了解如何实施支持API长期增长和稳定的版本控制策略。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Versioning strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制策略
- en: Implementing versioning in the product API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在产品API中实现版本控制
- en: Managing API evolution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理API演变
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will evolve our product API. To be able to follow along
    and use the code examples as they are printed in the book, you should have the
    product API code that was created in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演变我们的产品API。为了能够跟随并使用书中打印的代码示例，您应该拥有在[*第2章*](B21843_02.xhtml#_idTextAnchor050)中创建的产品API代码。
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/
    Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5)
    .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上访问本章的代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter5)。
- en: Versioning strategies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制策略
- en: Versioning refers to the practice of managing changes in an application over
    time by assigning distinct version numbers to different stages of the API’s life
    cycle. It ensures that updates to an API—such as new features or breaking changes—can
    be introduced without disrupting existing clients that rely on earlier versions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是指通过为API生命周期的不同阶段分配不同的版本号来管理应用程序随时间的变化。它确保API的更新（如新功能或破坏性变更）可以引入，而不会破坏依赖于早期版本的现有客户端。
- en: Versioning became critical for REST APIs as the architecture of software systems
    shifted from monolithic to distributed systems. In monolithic architectures, where
    the consumer and provider of a service typically reside within the same application,
    there is direct control over both ends of the communication. When changes are
    made, they are applied uniformly across the entire system, ensuring that the consumer
    is always in sync with the provider. Hence, the versioning of interfaces within
    a monolithic application is not necessary because the consumers are tightly coupled
    with the providers, and updates are deployed simultaneously without causing compatibility
    issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件系统架构从单体架构转向分布式系统，版本控制对REST API变得至关重要。在单体架构中，服务的消费者和提供者通常位于同一应用程序中，可以对通信的两端进行直接控制。当进行更改时，它们会统一应用于整个系统，确保消费者始终与提供者保持同步。因此，在单体应用程序中接口的版本控制不是必要的，因为消费者与提供者紧密耦合，更新同时部署而不会引起兼容性问题。
- en: However, with the rise of distributed systems and the adoption of REST APIs,
    which serve multiple independent clients (such as web browsers, mobile apps, and
    third-party services), the situation changed dramatically. REST APIs expose services
    to the outside world, where different clients may use different versions of the
    API simultaneously. This introduces a challenge—how do you update the API to introduce
    new features or fix issues without breaking functionality for existing clients?
    Versioning solves this by allowing multiple versions of the API to coexist, ensuring
    backward compatibility, and enabling the API to evolve over time while still supporting
    older clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着分布式系统的兴起和REST API的采用，这些API服务于多个独立的客户端（如网页浏览器、移动应用和第三方服务），情况发生了巨大变化。REST
    API将服务暴露给外部世界，不同客户端可能同时使用API的不同版本。这引入了一个挑战——如何更新API以引入新功能或修复问题，同时又不破坏现有客户端的功能？版本控制通过允许API的多个版本共存，确保向后兼容性，并使API能够随着时间的推移而演进，同时仍然支持旧客户端。
- en: Let’s see how we can apply versioning strategies to solve this problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何应用版本控制策略来解决这个问题。
- en: Before exploring versioning strategies, it’s essential to distinguish between
    backward-compatible changes and breaking changes. Understanding this distinction
    is crucial because, for breaking changes, updating the API version is necessary
    to ensure existing clients can continue to use the API smoothly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索版本控制策略之前，区分向后兼容的变更和破坏性变更至关重要。理解这种区别非常重要，因为对于破坏性变更，更新API版本是必要的，以确保现有客户端可以继续平稳地使用API。
- en: '**Breaking changes** are modifications that disrupt existing client interactions
    with the API. These changes typically necessitate a new API version to prevent
    breaking current integrations. These are some examples of breaking changes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**破坏性变更**是指那些会中断现有客户端与API交互的修改。这些变更通常需要一个新的API版本来防止破坏当前的集成。以下是一些破坏性变更的例子：'
- en: '**Removing an endpoint** : Deleting an existing API endpoint that clients rely
    on'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除端点**：删除客户端依赖的现有API端点'
- en: '**Changing response data structure** : Altering the format of response data,
    such as renaming or removing fields in the JSON response'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改响应数据结构**：更改响应数据的格式，例如在JSON响应中重命名或删除字段'
- en: '**Modifying required parameters** : Changing required parameters for an endpoint,
    which could cause existing requests to fail'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改必需参数**：更改端点的必需参数，这可能导致现有请求失败'
- en: '**Altering authentication methods** : Changing or removing existing authentication
    mechanisms or security protocols'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改认证方法**：更改或删除现有的认证机制或安全协议'
- en: '**Changing endpoint behavior** : Modifying the behavior of an endpoint so that
    it no longer performs as it did previously'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改变端点行为**：修改端点的行为，使其不再像之前那样执行'
- en: 'In contrast, **backward-compatible changes** enhance or extend the API without
    disrupting existing clients. Here are some examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**向后兼容的变更**增强了或扩展了API，而不会破坏现有客户端。以下是一些向后兼容变更的例子：
- en: '**Adding new optional fields** : Introducing new fields to the response payload
    that are not required for existing clients'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新的可选字段**：向响应负载中引入新的字段，这些字段对于现有客户端不是必需的'
- en: '**Adding new endpoints** : Creating new API endpoints that provide additional
    functionality without affecting existing ones'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新的端点**：创建新的API端点，提供额外的功能，而不会影响现有的端点'
- en: '**Extending response data** : Adding extra information to the response data
    that does not alter the existing structure'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展响应数据**：向响应数据中添加额外的信息，而不会改变现有的结构'
- en: '**Adding new query parameters** : Introducing optional query parameters to
    existing endpoints that offer additional filtering or functionality'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新的查询参数**：向现有端点引入可选的查询参数，以提供额外的过滤或功能'
- en: '**Enhancing documentation** : Improving or expanding API documentation to provide
    more details without altering the API itself'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强文档**：改进或扩展API文档，以提供更多细节而不改变API本身'
- en: 'Now that we understand the need for using versioning for breaking changes,
    let’s explore various versioning strategies, along with their advantages and disadvantages.
    The most common strategies include the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用版本控制进行重大变更的需求，让我们来探讨各种版本控制策略，以及它们的优缺点。最常见的方法包括以下几种：
- en: URL path versioning
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL路径版本控制
- en: Query parameter versioning
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数版本控制
- en: HTTP header versioning
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头版本控制
- en: Content negotiation
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商
- en: Let’s go deep into each versioning strategy and understand when to use one instead
    of the other.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨每种版本控制策略，并了解何时使用一种策略而不是另一种策略。
- en: URL path versioning
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL路径版本控制
- en: URL path versioning is one of the most common and straightforward strategies
    for versioning REST APIs. This strategy is used by many companies, such as X,
    Google, GitLab, and others. In this strategy, the version number is included directly
    within the API’s URL path, such as `https://api.product.com/v1/products.`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: URL路径版本控制是REST API版本控制中最常见且最直接的方法之一。许多公司，如X、Google、GitLab等，都使用这种方法。在这种策略中，版本号直接包含在API的URL路径中，例如`https://api.product.com/v1/products.`。
- en: This approach makes it easy for both developers and clients to identify and
    access specific versions of an API without any ambiguity. By embedding the version
    number in the URL path, API consumers have a clear and explicit way of requesting
    the desired version, ensuring that any integration remains stable even as the
    API evolves. Additionally, the server can easily route incoming requests to the
    correct version of the code base, simplifying maintenance and deployment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得开发者和客户端都能轻松地识别和访问API的具体版本，而不会产生任何歧义。通过在URL路径中嵌入版本号，API消费者可以明确地请求所需的版本，确保任何集成在API演变过程中都能保持稳定。此外，服务器可以轻松地将传入的请求路由到正确的代码库版本，简化维护和部署。
- en: URL path versioning provides several clear advantages for API management. One
    of its primary benefits is that version numbers are directly visible in the URI,
    making it immediately clear which version of the API is being accessed. Additionally,
    URL versioning integrates well with HTTP caching mechanisms, as different versions
    of the API are treated as distinct resources, allowing for the effective and independent
    caching of each version. It also facilitates bookmarking and sharing, enabling
    users to save and reference specific versions of endpoints easily, ensuring consistency
    in interactions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: URL路径版本控制为API管理提供了几个明显的优势。其主要好处之一是版本号直接显示在URI中，使得访问的API版本一目了然。此外，URL版本控制与HTTP缓存机制很好地集成，因为API的不同版本被视为不同的资源，允许对每个版本进行有效且独立的缓存。它还促进了书签和分享，使用户能够轻松保存和引用特定版本的端点，确保交互的一致性。
- en: However, URL versioning also presents certain drawbacks. Over time, maintaining
    multiple versions can lead to cluttered URIs, especially if multiple versions
    of the API are maintained simultaneously. Moreover, once a version is embedded
    in the URL path, it becomes part of the API’s public contract. Furthermore, the
    overhead associated with managing numerous URLs can increase complexity in both
    development and documentation processes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，URL版本控制也存在一些缺点。随着时间的推移，维护多个版本可能会导致URI杂乱无章，尤其是在同时维护多个API版本的情况下。此外，一旦版本嵌入到URL路径中，它就成为API公共契约的一部分。此外，管理众多URL相关的开销可能会增加开发和文档流程的复杂性。
- en: When implementing a new feature, breaking changes typically affect only a few
    specific endpoints, not the entire API. If you update the version number for endpoints
    that haven’t changed, it can create unnecessary confusion for both clients and
    maintainers. This approach makes it harder to understand how different versions
    of various endpoints should be used together, potentially complicating the integration
    process and hindering overall API clarity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现新功能时，破坏性更改通常只会影响少数特定的端点，而不是整个API。如果您更新未更改的端点的版本号，这可能会给客户端和维护者造成不必要的混淆。这种方法使得理解不同版本的各个端点应该如何一起使用变得更加困难，可能会使集成过程复杂化，并阻碍API的整体清晰度。
- en: Using URL paths for versioning is well-suited for many scenarios, particularly
    when clear and explicit versioning is crucial. It is an excellent choice for APIs
    that are stable, with minimal expected changes that could introduce breaking modifications.
    URL path versioning provides a straightforward approach to managing different
    versions, making it easier to track and maintain the API as it evolves.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用URL路径进行版本控制非常适合许多场景，尤其是在清晰和明确的版本控制至关重要时。对于稳定、预期变化最小且不会引入破坏性修改的API来说，这是一个极佳的选择。URL路径版本控制提供了一种简单的方法来管理不同的版本，使得跟踪和维护随着时间演变的API变得更加容易。
- en: Query parameter versioning
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数版本控制
- en: Query parameter versioning involves specifying the API version as a query parameter
    in the URL, such as `https://api.product.com/products?version=1` . This approach
    is commonly recommended in Microsoft’s guidelines. This strategy makes it easier
    to implement and introduce new versions without modifying URL paths. This can
    be particularly useful when you want to maintain a consistent endpoint path structure
    while still providing version-specific functionality. It also allows versioning
    without creating a proliferation of URL paths.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数版本控制涉及在URL中将API版本指定为查询参数，例如 `https://api.product.com/products?version=1`。这种方法在微软的指南中通常被推荐。这种策略使得在不修改URL路径的情况下实施和引入新版本变得更加容易。这在您希望保持一致的端点路径结构的同时，仍然提供特定版本的功能时尤其有用。它还允许在不创建大量URL路径的情况下进行版本控制。
- en: However, it has some drawbacks. Clients must include the version parameter with
    every request, which adds an extra step in request construction. Additionally,
    the API server must handle versioning logic based on query parameters, potentially
    complicating implementation and increasing processing overhead. Furthermore, the
    version information is less visible in the URL, making it harder to quickly identify
    which version is being accessed. This lack of clarity can cause confusion, especially
    when the versioning affects critical parts of the API’s functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点。客户端必须在每次请求中都包含版本参数，这增加了请求构建的额外步骤。此外，API服务器必须根据查询参数处理版本逻辑，这可能会使实现复杂化并增加处理开销。此外，版本信息在URL中不太明显，这使得快速识别正在访问哪个版本变得更加困难。这种不明确性可能会导致混淆，尤其是在版本化影响API功能的关键部分时。
- en: Another concern is how query parameter versioning interacts with caching. Since
    the version is embedded in the query string rather than the URL path, caching
    mechanisms may not handle it as effectively. This can lead to complications in
    how different versions of the API are cached, potentially impacting performance
    and efficiency for clients who rely on caching to improve response times.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关注点是查询参数版本控制如何与缓存交互。由于版本信息嵌入在查询字符串中而不是URL路径中，缓存机制可能无法有效地处理它。这可能导致不同版本的API缓存方式复杂化，可能会影响依赖于缓存来提高响应时间的客户端的性能和效率。
- en: HTTP header versioning
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP头版本控制
- en: 'HTTP header versioning involves specifying the API version in the HTTP headers
    of a request. This approach allows clients to indicate which version of the API
    they wish to use by including a custom header, such as `X-API-Version` , in their
    requests. GitHub is an example of an application that uses the HTTP header:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头版本控制涉及在请求的HTTP头中指定API版本。这种方法允许客户端通过在其请求中包含一个自定义头，如 `X-API-Version`，来指示他们希望使用哪个版本的API。GitHub就是使用HTTP头的一个例子：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This strategy keeps the URL clean and avoids cluttering it with versioning information.
    It also provides a flexible and less intrusive way to manage versions, as it does
    not alter the endpoint paths or query strings. Additionally, HTTP header versioning
    can facilitate smoother transitions between versions since the versioning information
    is separated from the URL being the resource identifier, reducing the risk associated
    with breaking changes for clients.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略保持了URL的整洁，避免了在URL中添加版本信息。它还提供了一种灵活且不那么侵入性的版本管理方式，因为它不会更改端点路径或查询字符串。此外，HTTP头版本控制可以促进版本之间的平稳过渡，因为版本信息与资源标识符URL分离，减少了与破坏性变更相关的风险。
- en: However, HTTP header versioning presents some challenges. Unlike URL versioning,
    the versioning information is not immediately visible in the URL, which can make
    debugging and documentation more complex. This lack of visibility can hinder developers
    and clients when troubleshooting issues or understanding API versions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTTP头版本控制带来了一些挑战。与URL版本控制不同，版本信息并不直接体现在URL中，这可能会使调试和文档编写变得更加复杂。这种缺乏可见性可能会阻碍开发者和客户在故障排除或理解API版本时的工作。
- en: Additionally, custom headers can lead to inconsistent implementation practices
    across different APIs. When APIs use custom headers, it becomes challenging to
    establish uniform standards, which can confuse developers and users alike. For
    example, one API might use `X-Api-Version` while another might use `X-Version`
    , leading to ambiguity and potential integration issues. The use of the `X-` prefix
    for custom headers has been deprecated since the introduction of RFC 6648 in 2012.
    As an alternative, the content negotiation strategy leverages existing headers,
    avoiding the need for custom headers, and ensuring better adherence to standard
    practices.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自定义头可能导致不同API之间实现实践的不一致。当API使用自定义头时，建立统一标准变得具有挑战性，这可能会让开发者和用户都感到困惑。例如，一个API可能使用`X-Api-Version`，而另一个API可能使用`X-Version`，这会导致歧义和潜在的集成问题。自2012年引入RFC
    6648以来，使用`X-`前缀作为自定义头已被弃用。作为替代，内容协商策略利用现有头，避免需要自定义头，并确保更好地遵循标准实践。
- en: Content negotiation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容协商
- en: 'Content negotiation is one of the techniques used to handle versioning in RESTful
    APIs, allowing clients to specify the API version via HTTP headers rather than
    through the URL path. The idea is to let the client request a particular version
    of the API by sending a specific `Accept` header. For example, a client might
    request version 1 of the API in JSON format by sending the following request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 内容协商是处理RESTful API版本控制的技术之一，允许客户端通过HTTP头来指定API版本，而不是通过URL路径。其理念是让客户端通过发送特定的`Accept`头来请求特定的API版本。例如，一个客户端可能通过发送以下请求来请求API的1.0版本，格式为JSON：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This technique of API versioning via content negotiation is closely related
    to HTTP header versioning, as both strategies rely on HTTP headers to specify
    the version. The key difference is that content negotiation avoids creating custom
    HTTP headers, adhering to RFC 6648, which discourages custom headers. Instead,
    this method uses standard headers such as `Accept` and `Content-Type` to specify
    both the format and version of the response, promoting a cleaner and more standardized
    approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过内容协商进行API版本控制的技巧与HTTP头版本控制密切相关，因为这两种策略都依赖于HTTP头来指定版本。关键区别在于内容协商避免了创建自定义HTTP头，遵循RFC
    6648，该规范不鼓励使用自定义头。相反，这种方法使用标准头，如`Accept`和`Content-Type`，来指定响应的格式和版本，从而促进了一种更干净、更标准化的方法。
- en: This strategy is widely adopted by large organizations such as Adidas and Mambu.
    The content negotiation strategy is aligned with the REST standard in that it
    follows the principle of content negotiation, where the client and server agree
    on the representation format and version via headers, keeping the interface flexible
    and compliant with RESTful best practices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略被像阿迪达斯和Mambu这样的大型组织广泛采用。内容协商策略与REST标准保持一致，因为它遵循内容协商原则，即客户端和服务器通过头信息来协商表示格式和版本，保持接口的灵活性和符合RESTful最佳实践。
- en: Since our API is already implemented, we will adopt a content negotiation strategy
    to enable seamless evolution, allowing new features to be introduced without disrupting
    existing clients or causing breaking changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的API已经实现，我们将采用内容协商策略以实现无缝演进，允许引入新功能而不会干扰现有客户端或造成破坏性变更。
- en: Implementing versioning in the product API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在产品API中实现版本控制
- en: As our product API is already in use by other applications, it’s essential to
    maintain stability while continuing to evolve the API to meet new requirements.
    One of the challenges in API development is balancing the need for enhancements
    while not disrupting existing consumers. In this section, we will explore how
    to implement versioning in the product API to handle changes without causing breaking
    issues for clients.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的产品API已经被其他应用程序使用，在继续演进API以满足新需求的同时保持稳定性至关重要。在API开发中，一个挑战是在增强需求的同时不破坏现有消费者。在本节中，我们将探讨如何在产品API中实现版本控制，以处理变更而不对客户端造成破坏性影响。
- en: The product API currently returns a complete list of products without pagination.
    To improve performance and scalability, we’ve decided to introduce pagination
    to the product list response. This modification will change the current behavior,
    potentially disrupting users who rely on the existing output. To prevent any impact
    on their workflows, we will implement a versioning strategy. This approach will
    allow us to support the new paginated format for future clients while maintaining
    backward compatibility for existing consumers, ensuring that the API can evolve
    without interrupting service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 产品API目前返回不带分页的产品完整列表。为了提高性能和可扩展性，我们决定在产品列表响应中引入分页。这种修改将改变当前的行为，可能会干扰依赖于现有输出的用户。为了防止对其工作流程造成任何影响，我们将实施版本控制策略。这种方法将使我们能够支持未来客户端的新分页格式，同时保持对现有消费者的向后兼容性，确保API可以在不中断服务的情况下演进。
- en: As mentioned previously, we will use the content negotiation strategy to introduce
    pagination into our product API without breaking the existing functionality. This
    strategy will allow us to evolve the API while letting clients specify the version
    they prefer through request headers. By utilizing content negotiation, we can
    offer both the original product list format and the new paginated version, ensuring
    backward compatibility and giving clients flexibility in how they consume the
    API. This method ensures a smooth transition for existing users while accommodating
    new requirements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用内容协商策略将分页引入我们的产品API，而不会破坏现有的功能。这种策略将使我们能够在客户端通过请求头指定他们偏好的版本的同时，使API得以演进。通过利用内容协商，我们可以提供原始的产品列表格式和新的分页版本，确保向后兼容性，并给客户端在如何消费API方面提供灵活性。这种方法确保了现有用户的平稳过渡，同时满足了新的需求。
- en: Updating our product API
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的产品API
- en: Let’s enhance our API by adding new functionality to our list endpoint while
    maintaining backward compatibility.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的列表端点添加新功能来增强我们的API，同时保持向后兼容性。
- en: 'In our current API, we have the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的API中，我们有以下代码：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s create another method to handle version 2 of our API, which will include
    support for pagination. To achieve this, we’ll add two `RequestParam` annotations:
    one to specify the current page and another to define the limit of the number
    of results per page.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一种方法来处理我们API的版本2，这将包括对分页的支持。为了实现这一点，我们将添加两个`RequestParam`注解：一个用于指定当前页，另一个用于定义每页结果的数量限制。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: '**Design strategy to prevent backward-incompatible changes**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计策略以防止向后不兼容的更改**'
- en: Adding pagination in our example cannot be done without a breaking change because
    the response is a JSON array of the products, so there is no place for pagination
    information that is common for all products returned (the total number of pages).
    A trick to prevent this situation is, instead of using a JSON array at the top
    level, to wrap the list (JSON array) in a JSON object even if it would have just
    one attribute. This minimal additional overhead would allow us to evolve the API
    without introducing a breaking change. We would just add optional pagination request
    parameters, and the pagination information could be added to the object at the
    root level of the response.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中添加分页而不造成破坏性更改是不可能的，因为响应是一个包含产品的JSON数组，因此没有地方放置适用于所有返回产品的分页信息（总页数）。防止这种情况的一个技巧是，而不是在顶层使用JSON数组，即使它只有一个属性，也要将列表（JSON数组）包裹在一个JSON对象中。这种最小的额外开销将使我们能够在不引入破坏性更改的情况下演进API。我们只需添加可选的分页请求参数，并将分页信息添加到响应根级别的对象中。
- en: 'You can see these `RequestParam` annotations in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码中看到这些`RequestParam`注解：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By adding `produces = "application/vnd.packt-v2+json"` , we enable Spring to
    route any request with the `Accept` header set to `application/vnd.packt-v2+json`
    to the appropriate endpoint. This allows clients to receive the response tailored
    to their version by specifying the `Accept` header in their API requests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`produces = "application/vnd.packt-v2+json"`，我们使Spring能够将任何将`Accept`头设置为`application/vnd.packt-v2+json`的请求路由到适当的端点。这允许客户端通过在他们的API请求中指定`Accept`头来接收针对他们版本的定制响应。
- en: 'We have also updated the API response to return a `PaginatedProducts` class,
    which now includes the `totalPages` attribute, as we can see in the following
    code. This addition is crucial for the client to determine whether more resources
    are available or not:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了API响应，以返回一个`PaginatedProducts`类，该类现在包括`totalPages`属性，如下面的代码所示。这个添加对于客户端确定是否有更多资源可用至关重要：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We opted to modify the response body to include this information, though other
    strategies could have been used to achieve the same goal, as we will explore in
    [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135) .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择修改响应体以包含此信息，尽管可以使用其他策略达到相同的目标，我们将在[*第 6 章*](B21843_06.xhtml#_idTextAnchor135)中探讨。
- en: 'With the addition of this new endpoint ( `getProductsV2` ), we need to update
    the `ProductsQueryUseCase` class to include the necessary implementation code.
    In the following example, the `getAllProducts` method now accepts a `Pageable`
    object from Spring, which handles pagination details. The method returns a `Page`
    object containing the list of products along with metadata such as the total number
    of pages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新增了这个新的端点（`getProductsV2`），我们需要更新`ProductsQueryUseCase`类以包含必要的实现代码。在下面的示例中，`getAllProducts`方法现在从Spring接受一个`Pageable`对象，该对象处理分页细节。该方法返回一个包含产品列表以及如总页数等元数据的`Page`对象：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Additionally, adding this endpoint requires us to change the `ProductsApi`
    interface and add the definition and documentation of our endpoint, as we can
    see in the following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加此端点需要我们更改`ProductsApi`接口，并添加端点的定义和文档，如下面的代码块所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have the documentation code, let’s see what our Swagger documentation
    looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了文档代码，让我们看看我们的Swagger文档看起来像什么：
- en: '![Figure 5.1 – Swagger UI](img/B21843_05_1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Swagger UI](img/B21843_05_1.png)'
- en: Figure 5.1 – Swagger UI
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Swagger UI
- en: '*Figure 5.1* illustrates our API, showcasing the `/api/products` endpoint with
    two parameters and a new response format when the media type is `application/vnd.packt-v2+json`
    .'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 展示了我们的API，展示了当媒体类型为`application/vnd.packt-v2+json`时的`/api/products`端点及其新的响应格式。'
- en: 'By switching the media type to `application/json` , as we can see in *Figure
    5.2* , the API will change the response to its previous behavior:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将媒体类型切换到`application/json`，如*图 5.2* 所示，API将响应更改为其之前的行性行为：
- en: '![Figure 5.2 – Swagger UI](img/B21843_05_2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Swagger UI](img/B21843_05_2.png)'
- en: Figure 5.2 – Swagger UI
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Swagger UI
- en: As shown, the API maintains backward compatibility by providing the original
    output for older clients. However, our documentation still enforces parameters,
    even though they aren’t being used. Unfortunately, OpenAPI 3.x does not support
    varying parameters based on content type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，API通过为旧客户端提供原始输出来保持向后兼容性。然而，我们的文档仍然强制执行参数，尽管它们没有被使用。不幸的是，OpenAPI 3.x不支持根据内容类型变化参数。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The upcoming OpenAPI 4.x, expected by the end of 2024, will address the limitation
    of supporting different query parameters according to the content type. Since
    we are currently using 3.x, this feature is not supported in our implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 预计到2024年底发布的OpenAPI 4.x将解决根据内容类型支持不同查询参数的限制。由于我们目前使用的是3.x，这个特性在我们的实现中不受支持。
- en: With the new version implemented, it’s time to validate our changes and ensure
    everything functions as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了新版本后，现在是时候验证我们的更改并确保一切按预期工作。
- en: Testing and validating our product API
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和验证我们的产品API
- en: Now that our product API is equipped to support multiple versions, it’s time
    to test and validate the functionality. We want to ensure that each version of
    the API behaves as expected, delivering the correct responses without breaking
    any existing functionality. To achieve this, we can use tools such as Swagger
    for the graphical interface, or we can interact with the API directly via the
    command line using `curl` commands. By testing both the original and updated versions,
    we can confirm that the API handles different versions correctly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使产品API能够支持多个版本，是时候测试和验证功能了。我们希望确保API的每个版本都按预期行为，提供正确的响应，而不破坏任何现有功能。为了实现这一点，我们可以使用Swagger进行图形界面，或者我们可以直接通过命令行使用`curl`命令与API交互。通过测试原始和更新版本，我们可以确认API正确处理了不同的版本。
- en: 'To retrieve the list of products using the first version of the API, you can
    execute the following `curl` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用API的第一个版本检索产品列表，您可以执行以下`curl`命令：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command sends a request to the API without specifying the version of the
    product API. The expected result is a list of products in the original format,
    without pagination:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令向API发送请求，但不指定产品API的版本。预期结果是原始格式的产品列表，不进行分页：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s try the same request passing the page and the limit, using the following
    `curl` command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用相同的请求传递页码和限制，使用以下`curl`命令：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output will remain the same as before, even though we’ve specified a limit
    of two items. This occurs because the first version of our API wasn’t designed
    to handle pagination query parameters. As a result, the API ignores these parameters
    and the full list of products is returned, adhering to the behavior defined in
    version 1.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经指定了两个项目的限制，输出也将保持不变。这是因为我们API的第一个版本没有设计来处理分页查询参数。因此，API忽略这些参数，并返回完整的产品列表，遵循版本1中定义的行为。
- en: 'The code in our first version will return all available elements. We implemented
    the second version by passing Spring’s `Pageable` object. To adhere to the **Don’t
    Repeat Yourself** ( **DRY** ) principle, we must update the code from version
    1, where all items are returned by default, and we have to set the size to the
    maximum possible value. This ensures that the first version continues to function
    as expected without introducing pagination:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个版本的代码将返回所有可用元素。我们通过传递Spring的`Pageable`对象实现了第二个版本。为了遵循**不要重复自己**（**DRY**）原则，我们必须更新版本1中的代码，其中默认返回所有项目，我们必须将大小设置为最大可能值。这确保了第一个版本继续按预期工作，而没有引入分页。
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we’ve confirmed that our API functions as expected for the previous
    version, let’s move on to testing the latest version. To do this, we will use
    the `curl` command shown here to verify the behavior of the updated API:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了API对先前版本的功能按预期工作，让我们继续测试最新版本。为此，我们将使用此处显示的`curl`命令来验证更新后API的行为：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The key difference in this command compared to the previous one is the `Accept`
    header, where we specify `application/vnd.packt-v2+json` . By doing so, the Spring
    Framework will route the request to the version 2 endpoint of our API. The expected
    output is a paginated list of products, reflecting the new behavior introduced
    in version 2:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个命令相比，此命令的关键区别在于`Accept`头，我们指定了`application/vnd.packt-v2+json`。通过这样做，Spring框架将请求路由到我们API的版本2端点。预期输出是分页的产品列表，反映了版本2中引入的新行为：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see from the output, the response contains only two items, and the
    `totalPages` field reflects the pagination, adjusting the result according to
    the limit parameter we provided. This demonstrates that the latest version handles
    pagination as expected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中看到的，响应中只包含两个项目，`totalPages`字段反映了分页，根据我们提供的限制参数调整结果。这表明最新版本按预期处理了分页。
- en: Now that we have confirmed the expected behavior for both version 1 and version
    2, let us explore what happens when we attempt to access a non-existent version
    (let’s call it version 3).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了版本1和版本2的预期行为，让我们探索当我们尝试访问一个不存在的版本（让我们称它为版本3）时会发生什么。
- en: 'To do this, we can execute the following `curl` command and observe the result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以执行以下`curl`命令并观察结果：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After executing it, the output will be the same as that obtained with version
    1:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，输出将与版本1相同：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This behavior might not be ideal, as it could mislead the client into thinking
    version 3 exists. This happens because, by default, the Spring Framework allows
    two media types: `application/json` and `application/*+json` . As a result, any
    request with the `application/*+json` media type will be processed by the default
    method unless explicitly mapped to a different version, as in our second version.
    Therefore, without specific handling, requests for version 3 may still be routed
    to the default version, giving an unintended response.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能并不理想，因为它可能会误导客户端认为存在版本3。这是因为Spring框架默认允许两种媒体类型：`application/json`和`application/*+json`。因此，任何带有`application/*+json`媒体类型的请求都将由默认方法处理，除非显式映射到不同的版本，就像我们的第二个版本那样。因此，如果没有特定的处理，对版本3的请求可能仍然被路由到默认版本，从而给出意外的响应。
- en: 'To solve this problem, we can update our endpoint from version 1 and force
    it to accept only `application/json` , as we can see in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将我们的端点从版本1更新，并强制它只接受`application/json`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After applying this solution, when we execute the `curl` command with the `application/vnd.packt-v3+json`
    media type, we will encounter an error like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用此解决方案后，当我们使用`curl`命令并指定`application/vnd.packt-v3+json`媒体类型时，我们会遇到如下错误：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This error response helps the client easily identify the available versions
    of the endpoint. By returning a clear error when an unsupported version is requested,
    we provide immediate feedback, guiding the client toward the correct version and
    improving overall API usability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误响应帮助客户端轻松地识别端点的可用版本。当请求不支持的版本时，返回清晰的错误，我们提供即时反馈，引导客户端向正确的版本过渡，从而提高API的整体可用性。
- en: Now that we’ve tested our solution and confirmed that it maintains the expected
    behavior from version 1 while introducing the new functionality in version 2,
    along with returning a `406 Not Acceptable` error for incorrect versions, we can
    shift our focus to managing these versions effectively as the API continues to
    evolve. Let’s explore how to handle versioning as our API grows and adapts to
    future needs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了我们的解决方案，并确认它保持了版本1的预期行为，同时引入了版本2的新功能，并为不正确的版本返回`406 Not Acceptable`错误，我们可以将我们的重点转移到有效管理这些版本上，因为API仍在演变。让我们探讨如何随着API的增长和适应未来需求来处理版本控制。
- en: Managing API evolution
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理API演变
- en: Managing the evolution of an API is a critical aspect of long-term API maintenance.
    As applications grow and customer needs change, APIs must adapt and introduce
    new features while ensuring the stability and continuity of existing services.
    Effective management of API evolution involves planning for changes, communicating
    clearly with API consumers, and implementing strategies that avoid breaking existing
    functionality while introducing improvements in a structured and predictable manner.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 管理API的演变是长期API维护的关键方面。随着应用程序的增长和客户需求的变化，API必须适应并引入新功能，同时确保现有服务的稳定性和连续性。有效管理API演变涉及规划变更、与API消费者进行清晰沟通，并实施避免破坏现有功能同时以结构化和可预测的方式引入改进的策略。
- en: To manage API evolution successfully, we should consider the key practices described
    in the following subsections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功管理API演变，我们应该考虑以下子节中描述的关键实践。
- en: Avoiding introducing breaking changes
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免引入破坏性变更
- en: As we discussed earlier, the best approach to evolving your API is to ensure
    that new changes don’t disrupt existing clients by maintaining backward compatibility.
    This minimizes potential service interruptions and provides a smooth transition
    for users.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，使API演变最佳的方法是确保新更改不会通过保持向后兼容性来干扰现有客户端。这最小化了潜在的服务中断，并为用户提供平稳的过渡。
- en: To achieve this, it’s essential to clearly differentiate between breaking and
    non-breaking changes. When introducing breaking changes, applying versioning is
    crucial to preserve the integrity of the current functionality while allowing
    new features to coexist.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，明确区分破坏性变更和非破坏性变更至关重要。在引入破坏性变更时，应用版本控制对于保持当前功能的完整性同时允许新功能共存至关重要。
- en: Defining and applying a versioning strategy across your APIs
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的API中定义和应用版本控制策略
- en: When a breaking change is necessary, applying a versioning strategy is essential.
    There are many ways to version your API so, as discussed earlier, maintaining
    consistency in versioning is crucial for ensuring that clients can easily understand
    and interact with your API. A clear and predictable versioning strategy enhances
    the user experience, making it simpler for clients to navigate and integrate with
    the API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要实施重大变更时，应用版本控制策略是至关重要的。有多种方法可以对API进行版本控制，正如之前讨论的，保持版本控制的连贯性对于确保客户能够轻松理解和交互API至关重要。一个清晰且可预测的版本控制策略可以提升用户体验，使客户更易于导航和集成API。
- en: Having a well-defined REST guideline that outlines how to implement a versioning
    strategy consistently across all APIs, as mentioned in [*Chapter 1*](B21843_01.xhtml#_idTextAnchor015)
    , is key, and establishing a unique versioning strategy provides numerous benefits,
    including improved usability and transparency for API consumers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个明确定义的REST指南，概述如何在所有API中一致地实施版本控制策略，如[第1章](B21843_01.xhtml#_idTextAnchor015)中所述，这是关键，并建立一个独特的版本控制策略为API消费者提供了许多好处，包括改进的可使用性和透明度。
- en: Updating and informing clients about new versions and deadlines
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新并通知客户关于新版本和截止日期
- en: With multiple API versions in play, it is essential to establish clear migration
    guidelines and deprecation timelines. Providing detailed information on how to
    transition between versions helps clients understand the process and prepare for
    changes. This transparency is crucial for a smooth migration and the minimization
    of potential disruptions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个API版本并存的情况下，建立明确的迁移指南和弃用时间表是必不可少的。提供有关如何在不同版本之间过渡的详细信息有助于客户理解流程并为变化做好准备。这种透明度对于平稳迁移和最小化潜在中断至关重要。
- en: Maintaining an up-to-date changelog is equally important. It offers clients
    a comprehensive view of recent updates, bug fixes, and new features, ensuring
    they are informed of any modifications. A well-documented changelog supports clients
    in adapting to changes effectively and fosters a positive user experience.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 维护一个最新的变更日志同样重要。它为客户提供了对最近更新、错误修复和新功能的全面了解，确保他们了解任何修改。一个良好的变更日志有助于客户有效地适应变化，并促进积极的用户体验。
- en: Semantic versioning
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本控制
- en: 'Semantic versioning ( https://semver.org/ ) is a widely adopted system that
    clearly communicates the scope and impact of changes in an API. It uses a three-part
    format: `MAJOR.MINOR.PATCH` . For example, a major version change (e.g., from
    1.x to 2.0.0) alerts clients that breaking changes have been introduced, giving
    them time to adapt. In contrast, minor and patch updates (e.g., 1.1.0 or 1.0.1)
    reassure clients that improvements or bug fixes have been made without affecting
    compatibility. This structured approach allows developers to quickly assess the
    nature of an update, minimizing the risk of breaking existing functionality.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制（https://semver.org/）是一个广泛采用的系统，它清楚地传达了API中变化的范围和影响。它使用三部分格式：`MAJOR.MINOR.PATCH`。例如，主版本变更（例如，从1.x到2.0.0）会通知客户已引入重大变更，给他们时间来适应。相比之下，次要和补丁更新（例如，1.1.0或1.0.1）向客户保证已进行改进或错误修复，而不影响兼容性。这种结构化方法允许开发者快速评估更新的性质，最小化破坏现有功能的风险。
- en: By implementing semantic versioning, we can offer clear guidelines and comprehensive
    changelogs to keep clients informed about updates. This structured approach helps
    clients understand the significance of each version change, making it easier for
    them to prepare for major updates that may require action.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施语义版本控制，我们可以提供清晰的指南和全面的变更日志，以保持客户对更新的了解。这种结构化方法有助于客户理解每个版本变更的重要性，使他们更容易为可能需要采取行动的重大更新做好准备。
- en: For minor or patch updates, clients are notified of new features or bug fixes
    without immediate pressure to upgrade. This balance ensures that clients stay
    informed and can choose to update at their convenience, maintaining a smooth and
    flexible user experience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于次要或补丁更新，客户会被告知新功能或错误修复，而无需立即升级的压力。这种平衡确保客户保持了解，并可以在方便的时候选择更新，保持平滑和灵活的用户体验。
- en: Marking old endpoints as deprecated
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记旧端点为弃用
- en: As part of the API evolution process, it’s important to clearly mark endpoints
    scheduled for deprecation to give clients ample time to transition to new versions.
    Deprecating old endpoints helps signal to clients that updates are required.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为API演变过程的一部分，明确标记计划弃用的端点是重要的，以给客户足够的时间过渡到新版本。弃用旧端点有助于向客户发出更新所需的信号。
- en: 'OpenAPI provides a way to mark any endpoint as deprecated, which is reflected
    in the Swagger UI. This can be easily done using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 提供了一种标记任何端点为弃用的方式，这在 Swagger UI 中得到反映。这可以通过以下代码轻松完成：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we add the `deprecated` attribute and view it in the Swagger UI, the output
    will look like *Figure 5.3* . However, we chose not to use this attribute here
    because OpenAPI 3.x currently doesn’t support deprecated endpoints with versioning
    based on content negotiation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Swagger UI 中添加 `deprecated` 属性并查看时，输出将类似于 *图 5.3*。然而，我们选择在此处不使用此属性，因为 OpenAPI
    3.x 目前不支持基于内容协商的版本控制的弃用端点。
- en: '![Figure 5.3 – Swagger UI: Monitoring the usage of deprecated endpoints](img/B21843_05_3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Swagger UI：监控已弃用端点的使用情况](img/B21843_05_3.png)'
- en: 'Figure 5.3 – Swagger UI: Monitoring the usage of deprecated endpoints'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Swagger UI：监控已弃用端点的使用情况
- en: Monitoring the usage of deprecated endpoints is essential for ensuring a smooth
    transition when phasing out older versions of an API. By tracking requests to
    these endpoints, you can determine how many clients are still using outdated functionality
    and evaluate their progress in migrating to newer versions. This helps you make
    informed decisions about when to officially remove old versions, avoiding unexpected
    disruptions to your clients’ operations. Additionally, it provides insights into
    which clients might need extra support or communication during the transition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 监控已弃用端点的使用情况对于确保在淘汰 API 的旧版本时平稳过渡至关重要。通过跟踪对这些端点的请求，您可以确定仍在使用过时功能的有多少客户，并评估他们迁移到新版本的过程。这有助于您在何时正式移除旧版本时做出明智的决定，避免对客户运营造成意外中断。此外，它还提供了关于哪些客户在过渡期间可能需要额外支持或沟通的见解。
- en: Monitoring tools, such as Grafana, New Relic, Datadog, and Splunk, not only
    facilitate a smooth deprecation process but also help confirm the adoption of
    newer API versions. These insights enable you to set practical timelines for deprecating
    endpoints, ensuring their removal does not disrupt clients and enhancing trust
    and reliability in your API’s development.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 监控工具，如 Grafana、New Relic、Datadog 和 Splunk，不仅有助于顺利的弃用过程，还有助于确认新 API 版本的采用。这些洞察使您能够设定实际的时间表来弃用端点，确保其移除不会干扰客户，并增强对
    API 开发的信任和可靠性。
- en: Removing old endpoints
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除旧端点
- en: Once you have established a deadline, communicated with your clients, and provided
    clear instructions for upgrading to the latest version, the next step is to remove
    the deprecated endpoints. But, before finalizing the removal, it is crucial to
    verify that clients have successfully migrated to the newest version. This process
    involves not only deleting the old code but also ensuring that all references
    and dependencies related to these endpoints are thoroughly cleaned up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设定了最后期限，与您的客户进行了沟通，并提供了升级到最新版本的明确说明，下一步就是移除已弃用的端点。但在最终确定移除之前，验证客户是否已成功迁移到最新版本至关重要。这个过程不仅涉及删除旧代码，还要确保与这些端点相关的所有引用和依赖关系都得到彻底清理。
- en: By applying these principles, you can manage API evolution smoothly and effectively,
    minimizing the risk of disrupting existing clients while equipping them with the
    necessary tools and information to adapt seamlessly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这些原则，您可以平稳有效地管理 API 的演变，最小化干扰现有客户的风险，同时为他们提供必要的工具和信息，以便无缝适应。
- en: Establishing a well-defined versioning strategy, using semantic versioning,
    and properly deprecating old endpoints allows your API to grow with minimal disruption.
    This approach ensures that your clients have sufficient time to transition, while
    you continue to improve and expand your API’s capabilities. Ultimately, it promotes
    long-term stability and improves the developer experience by allowing your API
    to evolve sustainably over time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个明确的版本控制策略，使用语义版本控制，并正确地弃用旧端点，可以让您的 API 在最小干扰的情况下增长。这种方法确保您的客户有足够的时间过渡，同时您继续改进和扩展
    API 的功能。最终，它促进了长期稳定性，并通过允许 API 随时间可持续地发展来提高开发者体验。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various versioning strategies for REST APIs and
    learned how to evolve our API while maintaining compatibility and ensuring a smooth
    transition to newer versions. We also applied content negotiation versioning to
    our current API, specifically focusing on implementing pagination.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 REST API 的各种版本控制策略，并学习了如何在保持兼容性的同时演进我们的 API，并确保平滑过渡到新版本。我们还应用了内容协商版本控制到当前的
    API 中，特别关注实现分页。
- en: In the next chapter, we will delve into more advanced topics, including enhanced
    pagination techniques, filtering, file uploads, and additional features to further
    refine your API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨更高级的主题，包括增强的分页技术、过滤、文件上传以及更多功能，以进一步精炼您的API。
