<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Connecting to SQL Databases Using JDBC</h1>
                </header>
            
            <article>
                
<p>Managing information means performing operations such as storing, modifying, removing, sorting, arranging, linking, and matching data in a data store. Database management systems provide the means to perform these operations and relational databases are the most common type of data store used with web applications.</p>
<p><span>This chapter starts by briefly discussing the fundamental Java technology for persistence,</span><span> </span><strong>Java Database Connectivity</strong><span> </span>(<strong>JDBC</strong>)<span>. We will learn how to connect and how to consume data from a relational database using connection pools and SQL queries. We will also describe </span><span>the concept of a </span><em>data repository</em><span>, a way of encapsulating persistence implementation details.</span></p>
<p><span>We will develop a very simple web UI that lists data from a database</span><span>. The purpose of the example is to show you the very fundamentals of database connectivity. <a href="9a3c93d4-374e-4324-9201-1d446093fef3.xhtml" target="_blank">Chapter 6</a>, <em>Connecting to SQL Databases Using ORM Frameworks</em>, will focus on more advanced database operations with basic data binding.</span></p>
<p class="p1"><span class="s1">This chapter covers the following topics:</span></p>
<ul>
<li>JDBC technology</li>
<li>JDBC drivers</li>
<li>Connection pools</li>
<li>SQL query execution</li>
<li>Data<span> </span>repositories</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/7VonXg">https://goo.gl/7VonXg</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to JDBC</h1>
                </header>
            
            <article>
                
<p><span>If you have developed </span><em>business applications</em><span> with Java, you have most likely used JDBC directly or indirectly(through an object-relational mapping framework) to connect and use relational databases. </span>A<span> </span><em>relational database</em><span> </span>is a system for storing information in a tabular form; that is, in tables. There are many vendors offering free and commercial<span> </span><strong>relational database management systems</strong><span> </span>(<strong>RDBMS</strong>). Two of the most popular open source RDBMS are<span> </span><em>PostgreSQL</em><span> </span>and<span> </span><em>MySQL</em>, while<span> </span><em>Oracle Database</em><span> </span>and<span> </span><em>Microsoft SQL Server</em><span> </span>are well-known options among the commercial ones. These systems understand the<span> </span><strong>Structured Query Language</strong><span> </span>(<strong>SQL</strong>), a<span> </span><em>declarative language</em><span> </span>used to perform tasks such as adding or deleting rows in a table.</p>
<div class="packt_infobox">When using a <strong>declarative language</strong>, you specify<span> </span><em>what</em><span> </span>you want the program to do. In contrast, when using an <strong>imperative language</strong>, such as the Java programming language, you specify <em>how</em><span> </span>to do it.</div>
<p>Before we get started with the actual code, try compiling and running the example application located in the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8/chapter-05</kbd><span> </span>Maven module. Follow these steps:</p>
<ol>
<li>If you haven't done so, import the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8</kbd><span> </span>Maven project into your IDE.</li>
</ol>
<p> </p>
<ol start="2">
<li>Create a<span> </span><em>running configuration</em><span> </span>for the<span> </span><kbd>packt.vaadin.datacentric.chapter05.jdbc.H2Server</kbd><span> </span>class and run it. This is your database server. It runs in a separate process<span> </span>in<span> </span>your computer. <span>Alternatively, you can run the H2 server with Maven from the <kbd>chapter-05</kbd> directory: <kbd>mvn test exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.H2Server"</kbd>.</span></li>
<li>Create a running configuration for the<span> </span><kbd>packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization</kbd><span> </span>class and run it. <span>You should see an <span class="packt_screen">initialization succeeded</span> message in the log. This initialization creates a new table (<kbd>messages</kbd>) in the database, and adds some demo rows to it. Alternatively, you can run the initialization application with Maven: <kbd>mvn exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization"</kbd>.</span></li>
<li>Create a running configuration for the Jetty Maven Plugin in the <kbd>chapter-05</kbd> module.</li>
<li>Point your browser to <kbd>http://localhost:8080</kbd>. You should see some demo data rendered by a Vaadin application.</li>
<li>The H2 server we started in step 2 starts also a web application you can use to run SQL queries. Let's try it! Point your browser <span>to </span><kbd>http://localhost:8082</kbd><span> </span><span>and connect using the following configuration:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-197 image-border" src="assets/0900594a-2c00-49a9-977a-176d67fc9eb3.png" style=""/></div>
<ol start="7">
<li>Insert a new row into the<span> </span><kbd>messages</kbd><span> </span>table by executing the following SQL statement: <kbd>INSERT INTO messages VALUES('Welcome to JDBC!')</kbd>.</li>
<li>Point your browser to (or reload) the Vaadin application. You should see the new message listed there:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-226 image-border" src="assets/e8dbea3b-1e2c-420d-a407-f06490e4d521.png" style=""/></div>
<p>If you want to, you can stop the Vaadin application and the H2 server, and run them again. You should see all the same data as before, including the newly inserted row. Just keep in mind that you need to run the H2 server first!</p>
<div class="packt_infobox">If you are curious, the location of the actual H2 database file is <kbd>&lt;home-directory&gt;/h2-databases/demo.mv.db</kbd>. You can delete this file and run the<span> </span><kbd>DatabaseInitialization</kbd><span> </span>application again if you want to recreate the initial state of the database.</div>
<p class="mce-root">The<span> </span><strong>Java Database Connectivity</strong><span> </span>(<strong>JDBC</strong>) <span><strong>API</strong> </span>enables your applications to connect to an RDBMS and make SQL calls to it. Other technologies for SQL persistence are usually implemented on top of the JDBC. Understanding the key aspects of JDBC will make your life easier even if you are planning (or if you are already using) other persistence technologies.</p>
<p>Typically, your application should perform five steps in order to use a database with the JDBC API:</p>
<ol>
<li>Add a<span> </span><strong>JDBC driver</strong><span> </span>for your database.</li>
<li>Establish a<span> </span><strong>connection</strong><span> </span>to the database.</li>
<li>Create a <strong>statement</strong><span> </span>to<span> </span><strong>execute</strong><span> </span>an SQL query.</li>
<li>Get and process the<span> </span><strong>result set.</strong></li>
<li><strong>Close</strong><span> </span>the connection.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a JDBC driver for your database</h1>
                </header>
            
            <article>
                
<p><span>Connecting to an RDBMS from a Java application is done through a </span><em>JDBC driver</em><span>. Most (if not all) database vendors include JDBC drivers for their RDBMS. A JDBC driver, in practice, is just a Java dependency (a JAR) in your project. If, for example, you need to connect your application to a PostgreSQL database, you will need to add the </span><kbd>postgresql-x.x.x.jar</kbd><span> file to your classpath. This, of course, can also be done with Maven. It's through this JDBC driver that your Java application communicates with the RDBMS, and it does so by establishing connections and executing SQL statements to retrieve data.</span></p>
<div class="packt_infobox"><span>We are not covering the details about RDBMS and SQL in this book. These topics are complex enough by themselves to deserve a complete book about them. There are plenty of good bibliographic and online resources you can consult to learn more about these topics.</span></div>
<p>In this book, we are going to use an H2 database. H2 is a popular open source database engine that doesn't require you to install anything<span> </span>on<span> </span>your computer<span>. All the concepts apply to other RDBMS as well, and we'll include snippets or commented sections in the accompanying code that show the specifics for MySQL and PostgreSQL, in case you want to experiment with these databases by yourself.</span></p>
<p>Adding a JDBC driver is as simple as including the right dependency in your project. For example, to include the H2 JDBC driver, add the following dependency to your<span> </span><kbd>pom.xml</kbd><span> </span>file:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>com.h2database<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>h2<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>1.4.196<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Or if you want to use MySQL or PostgreSQL, add the following dependencies:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>mysql<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>mysql-connector-java<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>6.0.6<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/><br/></span><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.postgresql<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>postgresql<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>42.1.4<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<div class="packt_tip">JDBC was designed to support <span>not only relational databases, but also </span>any kind of data source, including file systems or object-oriented systems. Keep this in mind when you need to connect your application to any kind of data source; there might be a JDBC driver for it.</div>
<p>You can, of course, include several JDBC drivers in the same project. The<span> </span><kbd>chapter-05</kbd><span> </span>application includes all of the previous drivers.</p>
<div class="packt_tip"><span>In old versions of JDBC, you had to manually load the JDBC driver class using the </span><kbd>Class.forName</kbd><span> method. This is no longer required in JDBC 4.0. Any JDBC 4.0 driver in the classpath is automatically loaded.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Establishing a database connection through a connection pool</h1>
                </header>
            
            <article>
                
<p>One of the most common pitfalls when developing web applications with Vaadin is to forget that what you are developing is actually a web application! Since the API resembles that of desktop-like UI frameworks, it's easy to forget that a Vaadin application is most likely going to be used by several users at the same time. You need to keep the multi user nature of a Vaadin application <span>in mind </span>when establishing connections to a database.</p>
<p>A desktop application you run locally on your machine might be able to work perfectly with a single connection to the database during its execution time (depending on the complexity of the application, of course). This is due to the single-user nature of the application; you know there's only one user per instance. On the other hand, a single instance of a web application is used by many users at the same time. It requires multiple connections to work properly. You don't want to have users<span> </span><em>A, B, C..., X</em><span> </span>waiting for the connection to be released by greedy user<span> </span><em>Z</em>, right? However, establishing connections is expensive! Opening and closing a connection every time a new user requests the application is not an option, since your app could reach a big number of concurrent users, and hence connections.</p>
<p>This is where a <em>connection pool</em> comes in handy. A connection pool is a class that maintains several connections to the database, like a <em>cache</em><span> </span>of connections, if you wish. The connection pool keeps all its connections open so that they can be reused by client classes when they need it.<span> </span>Without<span> </span>a connection pool, any time your app needs to perform a database operation, it has to create a new connection, execute the query, and close the connection. As mentioned previously, this is expensive and wastes resources. Instead, a connection pool creates a set of connections and "lends" them to client classes. Once the connection is used, it's not closed, but returned to the pool and used again.</p>
<p>As you can guess, connection pools are such a well-known pattern that many implementations exist. Let's see how to use one of them, <kbd>BoneCP</kbd>, a free open source JDBC connection pool implementation.</p>
<div class="packt_infobox"><span>Other popular connection pool implementations are <em>C3P0</em> and <em>Apache DBCP</em>. Moreover, a</span>pplication servers and servlet containers offer the possibility to define pooled data sources (see Java's<span> </span><kbd>DataSource</kbd><span> </span>interface documentation) as part of their configuration. This decouples the data source configuration from your running environment while offering connection pooling mechanisms for free.</div>
<p>First of all, here are the dependencies you need to add:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>com.jolbox<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>bonecp<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>0.8.0.RELEASE<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.slf4j<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>slf4j-simple<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>1.7.25<span>&lt;/version&gt;<br/></span><span>    &lt;scope&gt;</span>test<span>&lt;/scope&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p><kbd>BoneCP</kbd> requires<span> </span>SLF4J, a logging library that offers a<span> </span><em>facade</em><span> </span>over several logging frameworks. This is needed in order to see logs by <kbd>BoneCP</kbd> in the console or web server log.</p>
<p>There should be one instance of the connection pool per instance of the web application. We used a static Java block in the previous chapter to initialize application-level resources. This works in small applications where these resources don't depend on others. In more complex applications, your initialization code might depend on other services (such as<span> </span><em>dependency injection</em>) in order to work, so let's use a more realistic approach this time and use a <kbd>ServletContextListener</kbd><span> </span>to <kbd>init</kbd> the connection pool. A <kbd>ServletContextListener</kbd><span> </span>allows your application to react to events in the<span> </span><em>servlet context lifecycle</em>; in particular, the initialization of a servlet context and its destruction.</p>
<p>As with previous examples, the<span> </span><kbd>chapter-05</kbd><span> </span>Vaadin application includes a<span> </span><kbd>WebConfig</kbd><span> </span>class that defines <q>everything web</q>; that is, servlets and event listeners. Besides the<span> </span><kbd>VaadinServlet</kbd>, we can include a<span> </span><kbd>ServletContextListener</kbd><span> </span>that initializes the database when the servlet context is created (that is when the web application starts... sort of):</p>
<pre><span><strong>@WebListener</strong><br/></span><span>public static class </span>JdbcExampleContextListener <span>implements </span><strong>ServletContextListener</strong> {<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><strong>contextInitialized</strong>(ServletContextEvent sce) {<br/><span>        try {<br/>            <strong>DatabaseService.init()</strong>;<br/><br/>        } catch (Exception e) {<br/>            e.printStackTrace();<br/>        }<br/>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span>contextDestroyed(ServletContextEvent sce) {<br/>    }<br/>}</pre>
<p>Thanks to the<span> </span><kbd>@WebListener</kbd><span> </span>annotation, this class is going to be discovered<span> </span>by the servlet container and registered with the servlet context automatically. Inside the<span> </span><kbd>contextInitialized</kbd><span> </span>method, we can add the code to initialize the connection pool; in this case, by delegating to the custom <kbd>DatabaseService</kbd><span> </span>class we'll implement next.</p>
<p>The infrastructure code is ready; now it's time for the actual <kbd>BoneCp</kbd> connection pool. Let's start with the<span> </span><kbd>init</kbd><span> </span>method:</p>
<pre><span>public class </span>DatabaseService {<br/><br/><span>    private <strong>static </strong></span><strong>BoneCP pool</strong><span>;<br/></span><span><br/></span><span>    public static void </span><strong>init()</strong> throws SQLException {<br/>        BoneCPConfig config = <span>new </span>BoneCPConfig()<span>;<br/></span><span>        </span>config.setJdbcUrl(<strong>"jdbc:h2:tcp://localhost/~/h2-databases/demo"</strong>)<span>;<br/></span><span>        </span>config.setUsername(<strong>"sa"</strong>)<span>;<br/></span><span>        </span>config.setPassword(<strong>""</strong>)<span>;<br/></span><span><br/></span>        <strong>pool = new BoneCP(config)</strong><span><strong>;</strong><br/></span>    }<br/>}</pre>
<p>This implementation defines a static (only one instance per application)<span> </span><kbd>BoneCP</kbd><span> </span>field, <span><kbd>pool</kbd>, </span>the actual connection pool. The<span> </span><kbd>pool</kbd><span> </span>field is initialized in the<span> </span><kbd>init</kbd><span> </span>method, which is called when the application starts (see the<span> </span><kbd>JdbcExampleContextListener</kbd><span> </span>class).</p>
<p>There are three things you need to specify when connecting to a database with JDBC:</p>
<ul>
<li><strong>The connection URL</strong>: With JDBC, a database is represented by a connection URL. JDBC uses this URL to get the information about where and how to connect to the database. In the previous example, we can see that the string contains the name of the database (<kbd>h2</kbd>), a host (<kbd>localhost</kbd>), and a database name (<kbd>~/h2-databases/demo</kbd>).</li>
<li><strong>The username</strong>: Databases allow you to define a set of users, roles, and permissions. The username is an identifier that the database can check in order to grant permissions on the data. By default, the H2 database defines the username<span> </span><kbd>sa</kbd>.</li>
<li><strong>The password</strong>: As you can guess, this is what allows the database engine to run the authentication check. By default, H2 uses an empty password for the default<span> </span><kbd>sa</kbd><span> </span>user.</li>
</ul>
<p>What if you wanted to use MySQL or PostgreSQL now? you would have to change the<span> </span><kbd>String</kbd><span> </span>literals in this class, recompile, and redeploy. A much better approach is to externalize this<span> </span><kbd>String</kbd>. One approach is to use the standard Java<span> </span><kbd>Properties</kbd><span> </span>class to load<span> </span><em>key/value</em><span> </span>pairs with the connection URL, username, and password. For example, the<span> </span><kbd>chapter-05</kbd><span> </span>application includes a<span> </span><kbd>datasource.properties</kbd><span> </span>file in the<span> </span><kbd>/src/main/resources</kbd><span> </span>directory:</p>
<pre><span>datasource.url</span><span>=</span><span>jdbc:h2:tcp://localhost/~/h2-databases/demo<br/></span><span>datasource.username</span><span>=</span><span>sa<br/></span><span>datasource.password</span><span>=<br/></span></pre>
<div class="packt_infobox">With MySQL databases, use: <span><kbd>datasource.url=jdbc:mysql://localhost/demo</kbd></span><br/>
<span><span><span>With PostgreSQL databases, use: </span></span></span><kbd>datasource.url=jdbc:postgresql://localhost:5432/demo</kbd><span><span><br/></span></span></div>
<p>The<span> </span><kbd>DatabaseService</kbd><span> </span>class can now use these properties (<kbd>datasource.*</kbd>) instead of the<span> </span><em>hard-coded</em><span> </span>literals:</p>
<pre><span>public class </span>DatabaseService {<br/><br/><span>    private static </span>String <strong>url</strong><span>;<br/></span><span>    private static </span>String <strong>password</strong><span>;<br/></span><span>    private static </span>String <strong>username</strong><span>;<br/></span><span>    private static </span>BoneCP <span>pool</span><span>;<br/></span><span><br/></span><span>    public static void </span><span>init</span>() throws SQLException, IOException {<br/>        <strong>loadProperties()</strong><span>;<br/></span><span>        </span><strong>createPool()</strong><span>;<br/></span><span>    </span>}<br/><br/>    <span>private static void </span><strong>loadProperties()</strong> throws IOException {<br/>        <span>try </span>(InputStream inputStream = DatabaseService.<span>class</span>.getClassLoader().getResourceAsStream(<span>"<strong>datasource.properties</strong>"</span>)) {<br/>            Properties properties = <span>new </span>Properties()<span>;<br/></span><span>            </span>properties.load(inputStream)<span>;<br/></span><span><br/></span><strong>            url = properties.getProperty("datasource.url");<br/>            username = properties.getProperty("datasource.username");<br/>            password = properties.getProperty("datasource.password");</strong><span><br/></span><span>        </span>}<br/>    }<br/><br/>    <span>private static void </span><span>createPool</span>() {<br/>        ...<span><br/></span><strong>        config.setJdbcUrl(url);<br/>        config.setUsername(username);<br/>        config.setPassword(password);<br/></strong>        ...<br/>    }<br/>}</pre>
<p>The connection properties (<kbd>url</kbd>,<span> </span><kbd>username</kbd>, and<span> </span><kbd>password</kbd>) are now static fields in the class populated from the<span> </span><kbd>datasource.properties</kbd><span> </span>file.</p>
<div class="packt_tip packt_infobox">A way of making your web application configuration independent of the running environment is to use the operating system's<span> </span><em>environment variables</em>. For example, let's say you define<span> </span>a<span> </span><kbd>MY-WEBAPP-CONF-DIRECTORY</kbd> environment variable in your computer, and set its value to<span> </span><kbd>~/my-webapp-conf</kbd>. Inside this directory, you can put all the<span> </span><kbd>.properties</kbd><span> </span>files that make up the configuration for example, the <kbd>datasource.properties</kbd> file. The web application can read the environment variable like this:<span> </span><kbd>String<span> </span>confDirectory<span> </span>= System.getenv("MY-WEBAPP-CONF-DIRECTORY")</kbd>, and read any files inside this directory in order to configure the application accordingly. With this technique, each developer in the team can define their own local configuration. Moreover, you can easily configure <em>test</em><span> </span>and<span> </span><em>production</em><span> </span>environments by defining the environment variable and placing the corresponding configuration files â€“ no need to worry about replacing files when you deploy to these environments besides checking that all configuration properties are in place. Make sure you show good error or warning messages when a property doesn't exist.</div>
<div>
<p>Now that we have a connection pool ready, we can get actual connections to the database. Here is how:</p>
</div>
<pre>Connection connection = <span>pool</span>.getConnection();</pre>
<p>A<span> </span><kbd>Connection</kbd><span> </span>represents a session with the database. This interface contains a number of methods to get information about the capabilities of the database and the state of the connection, but the most important part allows you to create<span> </span><kbd>Statements</kbd><span> </span>objects.</p>
<div class="packt_tip packt_infobox">Connection pool implementations offer good configurations for development or testing environments. This is most likely not optimal for a production environment. Consult the documentation of the implementation, and tune the configuration accordingly when deploying to production environments.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a statement and executing an SQL query</h1>
                </header>
            
            <article>
                
<p>A<span> </span><kbd>Statement</kbd><span> </span>object is used to invoke SQL statements in the database. The following snippet of code shows how to retrieve a<span> </span><kbd>Connection</kbd><span> </span>object from the connection pool. This object is used to create a new<span> </span><kbd>Statement</kbd><span>, </span>which, in turn, is used to execute an SQL statement:</p>
<pre><span>try </span>(Connection <strong>connection = pool.getConnection()</strong>) {<br/>    Statement <strong>statement = connection.createStatement()</strong><span>;<br/></span><span><strong>    ResultSet resultSet</strong> = </span><strong>statement.execute</strong>("SELECT content FROM messages")<span>;<br/></span>}</pre>
<div class="packt_tip">In this<span> </span>chapter<span>,</span><span> </span>we are using the<span> </span><kbd>Statement</kbd><span> </span>interface and its <kbd>createStatement</kbd> counterpart method. In more critical applications, you should use the<span> </span><kbd>PreparedStatement</kbd><span> interface </span>and the<span> </span><kbd>prepareStatement</kbd><span> </span>method in order to increase performance and prevent SQL injection attacks.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting and processing a result set</h1>
                </header>
            
            <article>
                
<p>As you can see, the<span> </span><kbd>execute</kbd><span> </span>method of the<span> </span><kbd>Statement</kbd><span> </span>class returns a<span> </span><kbd>ResultSet</kbd><span> </span>object. A<span> </span><kbd>ResultSet</kbd><span> </span>object represents data from the database. It works like a cursor pointing to the rows in the data.<span> First</span>, the cursor is placed before the first row. You can use the<span> </span><kbd>next</kbd><span> </span>method to iterate through the rows as follows:</p>
<pre><span>while </span>(<strong>resultSet.next()</strong>) {<br/>    String content = resultSet.<strong>getString("content")</strong>)<span>;<br/></span>}</pre>
<p>In the previous example, we are using the<span> </span><kbd>getString</kbd><span> </span>method to get the value that corresponds to the<span> </span><kbd>content</kbd><span> </span>column. <span>There are methods for various data types: for example, the <kbd>getInt</kbd> method returns the value in the specified column as a Java <kbd>int</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closing a database connection</h1>
                </header>
            
            <article>
                
<p>When using a connection pool, the pool implementation takes care of closing the JDBC connections. Depending on the specific implementation, you might have to invoke this process. Usually, you want the pool to be active during the lifetime of your web application. Remember the <span><kbd>ServletContextListener</kbd> implementation we used to initialize the connection pool? Well, we can use it to shut the pool down. All we need to do is to implement the </span><kbd>contextDestroyed</kbd><span> method:</span></p>
<pre><span>@WebListener<br/></span><span>public static class </span>JdbcExampleContextListener <span>implements </span>ServletContextListener {<br/>    ...<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><strong>contextDestroyed</strong>(ServletContextEvent sce) {<br/><strong>        DatabaseService.shutdown()</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>Finally, the<span> </span><kbd>shutdown</kbd><span> </span>method is implemented as follows:</p>
<pre><span>public class </span>DatabaseService {<br/>    ...<br/>    <span>public static void </span><strong>shutdown</strong>() {<br/>        <strong>pool.shutdown()</strong><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>Now, it's a good time for you to play with the<span> <kbd>chapter-05</kbd> demo application </span>again. Have a close look at the<span> </span><kbd>DatabaseService</kbd><span> </span>class and how it is used<span> </span>in<span> </span>the<span> </span><kbd>VaadinUI</kbd><span> </span>class. The<span> </span><kbd>findAllMessages</kbd><span> method </span>is pretty interesting in particular, as it acts as the main communication point between the Vaadin application and the UI:</p>
<pre>package packt.vaadin.datacentric.chapter05.jdbc;<br/><br/>import com.jolbox.bonecp.BoneCP;<br/>import com.jolbox.bonecp.BoneCPConfig;<br/><br/>import java.io.IOException;<br/>import java.io.InputStream;<br/>import java.sql.Connection;<br/>import java.sql.ResultSet;<br/>import java.sql.SQLException;<br/>import java.sql.Statement;<br/>import java.util.ArrayList;<br/>import java.util.List;<br/>import java.util.Properties;<br/><br/>/**<br/> * @author Alejandro Duarte<br/> */<br/>public class DatabaseService {<br/><br/>    private static final String <strong>SELECT_SQL = "SELECT content FROM messages"</strong>;<br/>    private static final String <strong>CONTENT_COLUMN = "content"</strong>;<br/>    ...<br/><br/>    public static <strong>List&lt;String&gt; findAllMessages()</strong> throws SQLException {<br/>        try (Connection connection = pool.getConnection()) {<br/>            Statement statement = connection.createStatement();<br/>            ResultSet resultSet = statement.executeQuery(<strong>SELECT_SQL</strong>);<br/><br/>            List&lt;String&gt; messages = new ArrayList&lt;&gt;();<br/>            while (resultSet.next()) {<br/>                messages.add(resultSet.getString(<strong>CONTENT_COLUMN</strong>));<br/>            }<br/><br/>            return messages;<br/>        }<br/>    }<br/>    ...<br/><br/>}</pre>
<p>See how the SQL queries are defined in<span> </span><kbd>String</kbd><span> </span>constants. Can you think of a better way of doing this? In a more complex application, you might end up having hundreds of SQL queries. A better practice in these scenarios is to externalize the SQL code. Properties files might help, but defining SQL queries in a single line could be a challenge, to say the least. A better approach is XML, a format that allows you to use multiple lines to define values. We'll see how MyBatis promotes this approach in <a href="9a3c93d4-374e-4324-9201-1d446093fef3.xhtml" target="_blank">Chapter 6</a>, <em>Connecting to SQL Databases Using ORM Frameworks</em>.</p>
<p>Another interesting detail in the<span> </span><kbd>findAllMessages</kbd><span> method </span>is the return type. Why not return a<span> </span><kbd>ResultSet</kbd><span> </span>object? We do this to avoid coupling the presentation layer with persistence implementation details. This is what we are going to explore in the following section.</p>
<div class="packt_infobox">You might have noticed that the<span> </span><kbd>findAllMessages</kbd><span> </span>method can throw<span> </span>an<span> </span><kbd>SQLException</kbd>. This<span> </span>makes<span> </span>clients of this method aware of implementation details at some level. Although the name of the exception class implies SQL is being used, according to the API documentation,<span> </span>an<span> </span><kbd>SQLException</kbd><span> </span>is "<span><q>an exception that provides information on a database access error or other errors</q>". This exception is used even in drivers for <em>NoSQL</em> databases.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing data repositories</h1>
                </header>
            
            <article>
                
<p>A<span> </span><em>repository</em><span>, </span>for the purposes of this book, is a class that includes all or some of the<span> </span><strong>CRUD</strong><span> </span>operations (<strong>Create, Read, Update, and Delete</strong>). Repositories encapsulate persistence details in an application. A repository holds the means to the domain model (or entities).</p>
<div class="packt_tip packt_infobox">More precisely, a domain model includes not only data, but also behavior. Another term used widely is <strong>data transfer object</strong><span> </span>(<strong>DTO</strong>). Although the original definition of DTO was intended to describe a way to transport data between processes, many architectures (inaccurately) define DTO as an object that carries data between software components in the same process. To complicate things even more, there are<span> </span><em>value objects</em><span> </span>(objects that are equal if their properties are equal), and<span> </span><em>entities</em><span> </span>(objects that are<span> </span>equal<span> </span>based on their identity, which can be defined by a single property). When documenting and designing your software, spend some time investigating the terms, and try to choose the one that best matches your design.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a domain model</h1>
                </header>
            
            <article>
                
<p>Let's study this with an example. Suppose you are implementing a simple e-commerce application. You are in charge of the<span> </span><em>orders module,</em> and have to provide access to the data related to this module through a web UI. After reading the specification, you designed a simple domain model formed by the following classes:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-199 image-border" src="assets/5e32ca64-5673-45f9-aa28-4c1398348e8b.jpg" style="width:38.08em;height:10.58em;"/> </div>
<p>This is pretty straightforward: an<span> </span><kbd>Order</kbd><span> </span>has one or more<span> </span><kbd>Product</kbd> objects and one<span> </span><kbd>Customer</kbd>. You want to use the hypothetical <em>Technology X</em> to persist data <span>(it doesn't matter which one for this example),</span> and you want your Vaadin<span> </span><kbd>UI</kbd><span> </span>implementation to be able to directly use the domain class; however, you don't want to couple your UI implementation with Technology X. Moreover, you have to expose orders and product data through a web service for an external accounting system. You decided, then, to implement three repositories, one for each domain class:<span> </span><kbd>ProductRepository</kbd>,<span> </span><kbd>OrderRepository</kbd>, and<span> </span><kbd>CustomerRepository</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing repositories and services</h1>
                </header>
            
            <article>
                
<p>At this point, you started implementing the Vaadin UI, and had a clear understanding of the methods that the repositories should expose. You then implemented these methods in the respective repository classes:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-200 image-border" src="assets/8a3386ea-77a5-4a66-9d54-43e4174a9f7a.jpg" style=""/></div>
<p class="mce-root"><span>Let's take a closer look at the methods in the repository classes</span><span>. As you can see, all method names start with <kbd>find</kbd> or <kbd>get</kbd>. This is a well-known convention in the industry, and it's used by libraries such as <strong>Spring Data</strong> or <strong>Apache DeltaSpike</strong>. Methods starting with <kbd>find</kbd> return a collection of objects, while methods starting with <kbd>get</kbd> return single, ready-to-use values (such as a domain instance, or one of its properties).</span></p>
<p class="mce-root"><span>Notice how each repository has a private <kbd>persistence</kbd> field that represents the entry point to use Technology X, we will see concrete examples of this later in this chapter. If, for some reason, you had to change the persistence technology to something else, client classes wouldn't be affected. Moreover, you can use different persistence technologies for different repositories without having client classes to deal with different APIs. The following code will give you a clear idea of how these repositories can be implemented:</span></p>
<pre>public class OrderRepository {<br/><br/>    private TechnologyX persistence = ...<br/><br/>    public List&lt;Product&gt; findAll() {<br/>        ... use Technology X through the persistence instance to fetch the data ...<br/>        ... convert the data to a List ...<br/>        return list;<br/>    }<br/>    ...<br/>}</pre>
<p>All the implementation details regarding how to get the data are encapsulated in the repository class. Now, let's move on and see how this can be used from a Vaadin application.</p>
<p class="mce-root">While doing<span> </span><em>pair programming</em>, your colleague suggested you should use service classes to abstract away the concept of<span> </span><em>repository</em><span> </span>from the Vaadin UI. She argued that there should be one <kbd>service</kbd> class for each repository:<span> </span><kbd>ProductService</kbd>,<span> </span><kbd>OrderService</kbd>, and<span> </span><kbd>CustomerService</kbd>. It seemed like a good idea to you too; however, she immediately noticed that the service classes would be simple<span> </span><em>facades</em><span> </span>for their repository counterparts, and wouldn't include any extra logic. You pointed out that the application had to expose data through a web service consumed by the accounting system, and that the service classes might be used for that. After you and your colleague investigated the precise data the web service had to expose, you both decided to<span> </span><em>Fight for Simplicity,</em><span> </span>and not to implement one <kbd>service</kbd> class per <kbd>repository</kbd> class.</p>
<p class="mce-root">Instead, the Vaadin UI would be allowed to have references to the repository classes. You also decided to implement a separate<span> </span><kbd>AccountingWebService</kbd><span> </span>class to expose the data for the accounting system, so that you could know and control what this system is "seeing" in the future. As with the Vaadin UI classes, the web service implementation would use the repository classes to fetch data.</p>
<div class="packt_tip">The previous hypothetical example doesn't imply that you shouldn't enforce a repository/service pairing kind of design in your projects. Always stop and think before making this kind of decision. The situation in the example shows how the developers considered alternatives, investigated the requirements more deeply, and then took an informed decision. Keep the developers, who will maintain your code in the future in mind. Keep your legacy in mind.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The active record pattern</h1>
                </header>
            
            <article>
                
<p>There are many architectural patterns that may or may not help in your projects; in particular, regarding domain models and persistence. You might want to have a look at the <em>active record pattern</em>. An active record class encapsulates not only the data, but also its persistence operations. For example, the <kbd>Order</kbd> class of the previous example would look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-201 image-border" src="assets/29eb1f9e-ff9d-4527-a8fc-213b44ac9bea.jpg" style=""/></div>
<p>Notice how the CRUD operations are implemented in the domain class alongside with the methods previously implemented in the <kbd>repository</kbd> class. Although being an alternative to keep in mind, we won't further cover or use the active record pattern in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter served as the fundamentals of database connectivity with Java. We learned concepts such as JDBC drivers (that allow applications to connect to specific relational database engines) and connection pools (to better use connection resources). We learned how to use a<span> </span><kbd>ContextServletListener</kbd><span> </span>to initialize connection pools or database-related services. We saw an example of a simple domain model, and how repository classes allow us to encapsulate<span> </span>access<span> </span>to data represented in this model. </p>
<p>In the next chapter, we are going to learn about several persistence technologies, and how to integrate them with the Vaadin Framework.</p>


            </article>

            
        </section>
    </body></html>