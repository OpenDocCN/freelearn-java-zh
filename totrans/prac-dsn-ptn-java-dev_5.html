<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-187" class="chapter-number"><a id="_idTextAnchor255"/>5</h1>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor256"/>Behavioral Design Patterns</h1>
			<p>Code maintainability plays a key role in applications across the spectrum of the industry, but it’s not fair to stop there and look no further. This means skipping over code <a id="_idTextAnchor257"/>behavior at runtime, which has an impact on physical and virtual memory usage. The primary motivation for using behavior patterns is transparent communication between objects, or in other words, the efficient usage of <a id="_idTextAnchor258"/>memory allocation for this communication. Utilizing behavioral patterns improves the flexibility of communication and helps complete a task with a single object or multiple objects exchanging information with each other. Structural design patterns can sometimes seem close to behavioral ones, but as we will see in each case, the purpose is slightly different. Let us dive deeper and learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li>Limiting expensive initialization using the <span class="No-Break">caching pattern</span></li>
				<li>Handling events using the chain of <span class="No-Break">responsibility pattern</span></li>
				<li>Turning information into action with the <span class="No-Break">command pattern</span></li>
				<li>Giving meaning to the context using an <span class="No-Break">interpreter pattern</span></li>
				<li>Checking all the elements with the <span class="No-Break">iterator pattern</span></li>
				<li>Utilizing the mediator pattern for <span class="No-Break">information exchange</span></li>
				<li>Restoring the desired state with the <span class="No-Break">memento pattern</span></li>
				<li><a id="_idTextAnchor259"/>Avoiding a null pointer exception state with the null <span class="No-Break">object pattern</span></li>
				<li><a id="_idTextAnchor260"/>Keeping all interested parties informed using the <span class="No-Break">observer pattern</span></li>
				<li>Dealing with instance stages by using the <span class="No-Break">pipeline pattern</span></li>
				<li>Changing object behavior with the <span class="No-Break">state pattern</span></li>
				<li>Using the strategy pattern to change <span class="No-Break">object behavior</span></li>
				<li><a id="_idTextAnchor261"/>Standardizing processes with the <span class="No-Break">template pattern</span></li>
				<li>Executing code based on the object type using the <span class="No-Break">visitor pattern</span></li>
			</ul>
			<p>By the end of this chapter, you will have a good foundation for understanding the importance of program behavior, not only for resource utilization but also from the perspective of SOLID <span class="No-Break">design principles.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter05</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor263"/>Limiting expensive initialization using the caching pattern</h1>
			<p>The caching pattern<a id="_idIndexMarker403"/> is not found in the<a id="_idIndexMarker404"/> traditional list from the <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>). However, due to industry requirements and resource usage, it has been identified as a commonly used approach and has <span class="No-Break">gained importance.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor264"/>Motivation</h2>
			<p>The caching pattern supports<a id="_idIndexMarker405"/> element reuse. It does not create a new element on demand – instead, it reuses an already-created element stored in the cache. It stores frequently needed data in fast-access storage for increased performance. Reading data from the cache is faster than instantiating a new entity given the low complexity of fetching the <span class="No-Break">required element.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor265"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">java.base</strong> module and its <strong class="source-inline">java.lang</strong> package provide<a id="_idIndexMarker406"/> wrapper classes for primitive types. The <strong class="source-inline">valueOf</strong> method for double, float, integer, byte, or character types uses a caching mechanism for frequently requested values to reduce memory <a id="_idIndexMarker407"/>space and <span class="No-Break">improve performance.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor266"/>Sample code</h2>
			<p>Le<a id="_idTextAnchor267"/>t us ima<a id="_idTextAnchor268"/>gine the following<a id="_idIndexMarker408"/> caching example by creating a <strong class="source-inline">Vehicle</strong> class. It contains references to its internal systems (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B18884_05_01.jpg" alt="Figure 5.1 – The UML class diagram showing the considered VehicleSystem types for the Vehicle class"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The UML class diagram showing the considered VehicleSystem types for the Vehicle class</p>
			<p>This means that the vehicle is precisely defined and does not mutate. When a client requests a specific system, it always initiates the one that corresponds to the object. This pattern also enforces control over the storage procedure (<span class="No-Break"><em class="italic">Example 5.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static <a id="_idTextAnchor269"/>void <a id="_idTextAnchor270"/>main(String[] args) {
    System.out.println("Caching Pattern, initiated vehicle
        system");
    var vehicle = new Vehicle();
    vehicle.init();
    var suspension = new SuspensionSystem("suspension");
    vehicle.addSystem(suspension);
    System.out.printf("Systems types:'%s%n",
        vehicle.systemTypes());
    var suspensionCache =
        vehicle.getSystemByType("suspension");
    System.out.printf("Is suspension equa<a id="_idTextAnchor271"/>l? '%s:%s'%n",
        suspension.equals(suspensionCache),
            suspensionCache);
    vehicle.addSystem(new EngineSystem("engine2"));
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker409"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Caching Pattern, initiated vehicle system</strong>
<strong class="bold">Vehicle, init cache:'break':'BreakSystem@adb0cf77',</strong>
<strong class="bold">  'engine':'EngineSystem@a067<a id="_idTextAnchor272"/>5694'</strong>
<strong class="bold">Sy<a id="_idTextAnchor273"/>stems types:''break':'BreakSystem@adb0cf77','engine'</strong>
<strong class="bold">  :'EngineSystem@a0675694','suspension':'Suspension</strong>
<strong class="bold">    System@369ef459'</strong>
<strong class="bold">Is suspension eq<a id="_idTextAnchor274"/>ual? 'true:SuspensionSystem@369ef459'</strong>
<strong class="bold">SystemCache<a id="_idTextAnchor275"/>, not stored:EngineSystem@6c828066</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.1 – The caching pattern provides a guarantee to always get the required element and gain control over the storage</p>
			<p>In other words, it is not necessary to create another instance such as <strong class="source-inline">EngineSystem</strong> to access its functions. Those object accesses or that program behavior can easily lead to <span class="No-Break">undesirable conditions.</span></p>
			<p>The vehicle’s <strong class="source-inline">SystemCache</strong> only considers specific typ<a id="_idTextAnchor276"/>es<a id="_idIndexMarker410"/> of instances and is also limited by size (<span class="No-Break"><em class="italic">Example 5.2</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class SystemCache {
    private final VehicleSystem[] systems;
    private int end;
...
    boolean addSystem(VehicleSystem system) {
        var availableSystem = getSystem(system.type());
        if (availableSystem == null &amp;&amp; end &lt;
            systems.length) {
            systems[end++] = system;
            return true;
        }
        return fa<a id="_idTextAnchor277"/>lse;
    }
   VehicleSystem getSystem(String type) {…}
    ...
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.2 – The SystemCache instance provides features to ensure program stability and may give additional guarantees</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor278"/>Conclusion</h2>
			<p>The example (from <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em>) showed that implementing caching<a id="_idIndexMarker411"/> is simple. It may be a good idea to consider when clients require repeated access to the same set of elements. This can have a positive impact <span class="No-Break">on performance.</span></p>
			<p>Some of these elements may be responsible for the program’s runtime behavior. Let’s dive deeper into this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor279"/>Handling events using the chain of responsibility pattern</h1>
			<p>The chain of responsibility pattern<a id="_idIndexMarker412"/> helps avoid tying the handler logic to the sender<a id="_idIndexMarker413"/> that fired the event. This pattern was identified by the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor280"/>Motivation</h2>
			<p>The program receives an initial triggered<a id="_idIndexMarker414"/> event. Each chained handler decides whether to process the request or pass it on to the next handler without responding. A pattern can consist of command objects that are processed by a series of handler objects. Some handlers can act as dispatchers, capable of sending commands in different directions to form a <span class="No-Break">responsibility tree.</span></p>
			<p>The chain of responsibility pattern allows you to build a chain of implementations in which a certain action is performed before or after calling the next handler in <span class="No-Break">the chain.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor281"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">java.logging</strong> module includes<a id="_idIndexMarker415"/> the <strong class="source-inline">java.util.logging</strong> package, which contains a <strong class="source-inline">Logger</strong> class, intended for recording application component messages. Loggers can be chained and the logged message is only processed by the desired <span class="No-Break"><strong class="source-inline">Logger</strong></span><span class="No-Break"> instances.</span></p>
			<p>Another example provided in the JDK is the <strong class="source-inline">DirectoryStream</strong> class, which comes with the <strong class="source-inline">java.base</strong> module and is located in the <strong class="source-inline">java.nio</strong> package. This class is responsible for iterating over entire directories and contains a nested filter interface. The interface provides an <strong class="source-inline">accept</strong> method. The actual representation of the chained filter differentiates depending<a id="_idIndexMarker416"/> on whether the directory is to be processed <span class="No-Break">or excluded.</span></p>
			<h2 id="_idParaDest-198">Sample<a id="_idTextAnchor282"/> code</h2>
			<p>Let us examine an example<a id="_idIndexMarker417"/> of how the chain of responsibility design pattern can be used to respond to a trigger event from the driver system (<span class="No-Break"><em class="italic">Example 5.3</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
   System.out.println("Pattern Chain of Responsibility, vehicle 
      system initialisation");
    var engineSystem = new EngineSystem();
    var driverSystem = new DriverSystem();
    var transmissionSystem = new TransmissionSystem();
    driverSystem.setNext(transmissionSystem);
    transmissionSystem.setNext(engineSystem);
    driverSystem.powerOn();
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Chain of Responsibility, vehicle system initialisation</strong>
<strong class="bold">DriverSystem: activated</strong>
<strong class="bold">TransmissionSystem: activated</strong>
<strong class="bold">EngineSystem, activated</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.3 – The DriverSystem instance initiates the powerOn event that is propagated through the chained instances</p>
			<p>The behavior of the system<a id="_idIndexMarker418"/> ch<a id="_idTextAnchor283"/>ain created is transparent, and the logic is properly encapsulated by each system. The provided generic abstract <strong class="source-inline">VehicleSystem</strong> instance defines the functionality, what function each element must fulfill, and how the following elements should be chained (<span class="No-Break"><em class="italic">Example 5.4</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sealed abstract class VehicleSystem permits DriverSystem,
    EngineSystem, TransmissionSystem {
    ...
    protected VehicleSystem nextSystem;
    protected boolean active;
       ...
    void setNext(VehicleSystem system){
        this.nextSystem = system;
    }
    void powerOn(){
        if(!this.active){
            activate();
        }
        if(nextSystem != null){
            nextSystem.powerOn();
        }
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.4 – The sealed classes usage provides additional stability and control</p>
			<p>The client receives a framework<a id="_idIndexMarker419"/> for how and which classes can be considered when building a chain (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B18884_05_02.jpg" alt="Figure 5.2 – The UML class diagram showing which elements participate in the powerOn event"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The UML class diagram showing which elements participate in the powerOn event</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor284"/>Conclusion</h2>
			<p>The chain of responsibility pattern<a id="_idIndexMarker420"/> showed that an incoming event that affects the runtime behavior of a program can result in the creation of multiple objects. The manipulators are encapsulated and the logic is properly isolated according to SOLID principles. Using this pattern, the client gets the opportunity to dynamically decide which handlers should be involved in the event process. Therefore, it is a hot candidate for security frameworks <span class="No-Break">or similar.</span></p>
			<p>Chained handlers can issue multiple commands to the client at runtime. Let’s explore command responses in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor285"/>Turning information into action with the command pattern</h1>
			<p>The command pattern<a id="_idIndexMarker421"/> is sometimes<a id="_idIndexMarker422"/> known as action. The command<a id="_idIndexMarker423"/> pattern encapsulates the triggered event as an object that allows the client to act. This pattern was early identified and described in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor286"/>Motivation</h2>
			<p>The command pattern dictates<a id="_idIndexMarker424"/> which instances of the command interface perform which actions on the receiver client. A command object can be parameterized to define an action in greater detail. The commands can include a callback function to notify others of the occurrence of an event. Sometimes, commands can be thought of as object-oriented replacements for callback functions. A newly created command object can have different dynamics depending on the event that initiated it. The client can react to it according to an already <span class="No-Break">scheduled scenario.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor287"/>Finding it in the JDK</h2>
			<p>Nice examples are provided<a id="_idIndexMarker425"/> in the JDK by the <strong class="source-inline">Callable</strong> and <strong class="source-inline">Runnable</strong> interfaces from the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.util.concurrent</strong> package. The implementation of each interface is scheduled for execution based on a <span class="No-Break">known scenario.</span></p>
			<p>Other uses of the command pattern can be found in the <strong class="source-inline">java.desktop</strong> module in the <strong class="source-inline">javax.swing</strong> package and a class implementing the <span class="No-Break"><strong class="source-inline">Action</strong></span><span class="No-Break"> interface.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor288"/>Sample code</h2>
			<p>The following example<a id="_idIndexMarker426"/> shows how a <strong class="source-inline">Driver</strong> object con<a id="_idTextAnchor289"/>trols a vehicle using well-defined commands (<span class="No-Break"><em class="italic">Example 5.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Command, turn on/off
        vehicle");
    var vehicle = new Vehicle("sport-car");
    var driver = new Driver();
    driver.addCommand(new StartCommand(vehicle));
    driver.addCommand(new StopCommand(vehicle));
    driver.addCommand(new StartCommand(vehicle));
    driver.executeCommands("start_stop");
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Command, turn on/off vehicle</strong>
<strong class="bold">START:Vehicle{type='sport-car', running=true}</strong>
<strong class="bold">STOP:Vehicle{type='sport-car', running=false}</strong>
<strong class="bold">START:Vehicle{type='sport-car', running=true}</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.5 – The triggered start_stop event is translated and transformed by the Driver instance into actions</p>
			<p>Commands<a id="_idIndexMarker427"/> are properly encapsulated and may contain additional logic for interacting with different clients or may decide on execution steps (<span class="No-Break"><em class="italic">Example 5.6</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sealed interface VehicleCommand permits StartCommand,
    <a id="_idTextAnchor290"/>StopCommand {
    void process(String command);
}
record StartCommand(Vehicle vehicle) implements
    VehicleCommand {
    @Ov<a id="_idTextAnchor291"/>erride
    public void process(String command) {
        if(c<a id="_idTextAnchor292"/>ommand.contains("start")){ ... }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.6 – To preserve the intended command design, the concept of sealed classes may be appropriated</p>
			<p>Commands can be transparently<a id="_idIndexMarker428"/> extended as the driver functionality evolves (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B18884_05_03.jpg" alt="Figure 5.3 – The UML class diagram showing which command can be considered a driver"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The UML class diagram showing which command can be considered a driver</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor293"/>Conclusion</h2>
			<p>A simple example (<span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.3</em>) showed the value of the command<a id="_idIndexMarker429"/> pattern. The command object is separate from the logic and may contain additional valuable information. A command has its own lifecycle and makes it easy to implement callback functions that can trigger <span class="No-Break">another event.</span></p>
			<p>Representing these commands textually can be tricky. The following section shows how the client can <span class="No-Break">understand them.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor294"/>Giving meaning to the context using the interpreter pattern</h1>
			<p>The interpreter pattern<a id="_idIndexMarker430"/> interprets sequences of characters into desired actions. It was identified early due to its use in SQL statement translation and described in more detail in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor295"/>Motivation</h2>
			<p>The interpreter pattern<a id="_idIndexMarker431"/> defines two types of objects that refer to specific sequences of characters. They are terminal and non-terminal actions or operations that can be performed on the sequence of characters under consideration. These operations represent the computer language that is used and have their own semantics. The syntactic tree of a given sentence – a sequence of characters – is an instance of a compound pattern and is used to evaluate and interpret meaning for the <span class="No-Break">client program.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor296"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">java.base</strong> module contains<a id="_idIndexMarker432"/> the <strong class="source-inline">java.util.regex</strong> package with the <strong class="source-inline">Pattern</strong> class. This class represents the compilation of regular expressions. Specific semantics are applied to a sequence of characters to verify the <span class="No-Break">required match.</span></p>
			<p>Another example comes from a similar module and the <strong class="source-inline">java.text</strong> package. The abstract <strong class="source-inline">Format</strong> class implementation serves locale-sensitive information such as dates, number formats, and <span class="No-Break">so on.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor297"/>Sample code</h2>
			<p>Let’s create a simple<a id="_idIndexMarker433"/> string math formula. The formula contains values from different sensors and their contribution to the result. The result represents<a id="_idIndexMarker434"/> the final value of the formula (<span class="No-Break"><em class="italic">Example 5.7</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Interpreter, sensors
        value");
    var stack = new Stack&lt;Expression&gt;();
    var formula = "1 - 3 + 100 + 1";
    var parsedFormula = formula.split(" ");
    var index = 0;
    while (index &lt; parsedFormula.length ){
        var text = parsedFormula[index++];
        if(isOperator(text)){
            var leftExp = stack.pop();
            var rightText = parsedFormula[index++];
            var rightEpx = new IntegerExpression
                (rightText);
            var operatorExp = getEvaluationExpression(text,
                left, right);
            stack.push(operatorExp);
        } else {
            var exp = new IntegerExpression(text);
            stack.push(exp);
        }
    }
    System.out.println("Formula result: " +
        stack.pop().interpret());
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Interpreter, math formula evaluation</strong>
<strong class="bold">Formula result: 99</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.7 – The parser converts the math string formula into the appropriate Expression types</p>
			<p>The basic element<a id="_idIndexMarker435"/> is the interface and its <strong class="source-inline">interpret</strong> method. The <strong class="source-inline">1 - 3 + 100 + 1</strong> formula is evaluated sequentially, and the last element contains the result. Each expression is encapsulated, and the interpreter can be conveniently extended (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B18884_05_04.jpg" alt="Figure 5.4 – The UML class diagram showing which participants are required for evaluation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The UML class diagram showing which participants are required for evaluation</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor298"/>Conclusion</h2>
			<p>An interpreter pattern is a powerful design<a id="_idIndexMarker436"/> pattern in which a client requires a textual representation of commands with known semantics to be processed. It allows you to create a grammar represented by a hierarchy of classes that can be easily extended and even dynamically modified <span class="No-Break">at runtime.</span></p>
			<p>The next section shows us how to navigate through a collection of commands. Let’s dive <span class="No-Break">into it.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor299"/>Checking all the elements with the iterator pattern</h1>
			<p>This iterator pattern<a id="_idIndexMarker437"/> can be close to the abstraction of a cursor pointing<a id="_idIndexMarker438"/> to the desired position. Since array construction is a commonly used structure type, this pattern was soon identified. It is considered one of the core patterns contained in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor300"/>Motivation</h2>
			<p>The iterator pattern<a id="_idIndexMarker439"/> defines a transparent way to iterate through a collection of objects without having to expose or be aware of any of the internal details of an object. To step between elements, the iterator pattern uses an <span class="No-Break">iteration function.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor301"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">java.base</strong> module contains multiple implementations<a id="_idIndexMarker440"/> of the iterator pattern. The first implementation can be considered the one provided by the collection framework located in the <strong class="source-inline">java.util</strong> package. An implementation of the <strong class="source-inline">Iterator</strong> interface traverses through a collection without knowing about the <span class="No-Break">element’s membership.</span></p>
			<p>Another example that can be considered is the iterator provided by the <strong class="source-inline">BaseStream</strong> interface and its <strong class="source-inline">iterator</strong> method. This class comes from a similar module and the <strong class="source-inline">java.util.stream</strong> package, namely the Stream API. It represents the <span class="No-Break">terminal operation.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor302"/>Sample code</h2>
			<p>Every vehicle has several common<a id="_idIndexMarker441"/> parts. The following example shows the use of the iterator pattern to loop through them<a id="_idTextAnchor303"/> (<span class="No-Break"><em class="italic">Exa<a id="_idTextAnchor304"/>mple 5.8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Iterator Pattern, vehicle parts");
    var standardVe<a id="_idTextAnchor305"/>hicle = new StandardVehicle();
    for(PartsIterator part = standardVehicl<a id="_idTextAnchor306"/>e.getParts();
        part.hasNext();){
        var vehiclePart = part.next();
        System<a id="_idTextAnchor307"/>.out.println("VehiclePart name:" +
            vehiclePart.name());
    }
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Iterator Pattern, vehicle parts</strong>
<strong class="bold">VehiclePart name:engine</strong>
<strong class="bold">VehiclePart name:breaks</strong>
<strong class="bold">VehiclePart name:navigation</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.8 – To preserve the intended command design, the concept of sealed classes may be appropriated</p>
			<p>The vehicle can provide a common abstraction vehicle that handles the iterator (<span class="No-Break"><em class="italic">Example 5.9</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
interface PartsIterator {
    boolean hasNext();
    VehiclePart next();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.9 – A program can implement different iterators with different dynamics</p>
			<p>The client can traverse all elements individually. An implementation of this kind of iterator can be thought<a id="_idIndexMarker442"/><a id="_idTextAnchor308"/> of as a nested <a id="_idTextAnchor309"/><a id="_idTextAnchor310"/>class of a concrete implementation (<span class="No-Break"><em class="italic">Example 5.10</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sealed interface Vehicle permits StandardVehicle {
    PartsIterator getParts();
}
final class StandardVehicle impl<a id="_idTextAnchor311"/>ements Vehicle {
    private final String[] vehiclePartsNam<a id="_idTextAnchor312"/>es = {"engine",
        "breaks", "navigation"};
    private class VehiclePartsIterator implements
        PartsIterator {
        ...
    }
    @Override
    public PartsIterator getParts() {
        return new VehiclePartsIterator();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.10 – A program can implement different iterators with different dynamics</p>
			<p>The sample program behavior<a id="_idIndexMarker443"/> is transparent to the client, and it provides a framework for extending the intended implementation of the vehicle with new parts and a way to navigate through them (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B18884_05_05.jpg" alt="Figure 5.5 – The UML class diagram representing a collection of parts designed for StandardVehicle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The UML class diagram representing a collection of parts designed for StandardVehicle</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor313"/>Conclusion</h2>
			<p>The strength of the iterator pattern<a id="_idIndexMarker444"/> is that it can be implemented in a very general way – no need to understand the element types being considered. The iterator loops through them all without touching their internal representation at runtime. Along with another pattern, it can change strategies on the fly or only consider specific <span class="No-Break">object types.</span></p>
			<p>The next section explores runtime communication between specific object types – let’s <span class="No-Break">rock it.</span></p>
			<h1 id="_idParaDest-215">Utilizing the medi<a id="_idTextAnchor314"/>ator pattern for information exchange</h1>
			<p>A common situation across different<a id="_idIndexMarker445"/> types of applications is the requirement to manage communication between clients that require the exchange of information in order to maintain a process. This pattern was identified early and is one of the core patterns of the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor315"/>Motivation</h2>
			<p>The mediator pattern<a id="_idIndexMarker446"/> represents an object, a man in the middle, that defines the way that a group of objects interacts within the group. The mediator establishes a free connection for client communication. Clients can refer to each other explicitly through an intermediary. In this way, communication can <span class="No-Break">be moderated.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor316"/>Finding it in the JDK</h2>
			<p>Although it may not be obvious<a id="_idIndexMarker447"/> at first glance, the medi<a id="_idTextAnchor317"/>ator pattern can be easily found in the <strong class="source-inline">java.base</strong> module an<a id="_idTextAnchor318"/>d the <strong class="source-inline">java.util.concurrent</strong> packa<a id="_idTextAnchor319"/>ge. The <strong class="source-inline">ExecutorSer<a id="_idTextAnchor320"/>vice</strong> class defines a <strong class="source-inline">submit</strong> method. Its parent class, <strong class="source-inline">Executor</strong>, exposes the <strong class="source-inline">execute</strong> method. These methods can be used to pass implementations of the <strong class="source-inline">Callable</strong> or <strong class="source-inline">Runnable</strong> interfaces, which were previously referred to as implementations of the <span class="No-Break">command pattern.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor321"/>Sample code</h2>
			<p>The following example<a id="_idIndexMarker448"/> is quite trivial compared to others, but it shows how a processor can maintain vehicle sen<a id="_idTextAnchor322"/>sor communication (<span class="No-Break"><em class="italic">Example 5.11</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
record Sensor(String name) {
    void emitMessage(String message) {
        VehicleProcessor.acceptMessage(na<a id="_idTextAnchor323"/>me, m<a id="_idTextAnchor324"/>essage);
    }
}
public static void main(String[] args) {
    System.out.println("Mediator Pattern, vehicle parts");
    var engineSensor = new Sensor("engine");
    var breakSensor = new Sensor("break");
    engineSensor.emitMessage("turn on");
    breakSensor.emitMessage("init");
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Mediator Pattern, vehicle parts</strong>
<strong class="bold">Sensor:'engine', delivered message:'turn on'</strong>
<strong class="bold">Sensor:'break', delivered message:'init'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.11 – Communication is handled by a VehicleProcessor instance</p>
			<p>The central element<a id="_idIndexMarker449"/> of the example is the<a id="_idTextAnchor325"/> <strong class="source-inline">VehicleProcessor</strong> instance, which obtains all the messages emitted and can react to them (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B18884_05_06.jpg" alt="Figure 5.6 – The UML class diagram emphasizing the communication that takes place via the processor"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The UML class diagram emphasizing the communication that takes place via the processor</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor326"/>Conclusion</h2>
			<p>The mediator pattern introduces<a id="_idIndexMarker450"/> the ability to isolate complex communication between different objects. The number of participating objects may vary at runtime. The pattern provides an encapsulated and decoupled way to allow all clients to communicate with <span class="No-Break">each other.</span></p>
			<p>Communication can bring about various states. In the next section, we’ll explore how to remember and <span class="No-Break">restore them.</span></p>
			<h1 id="_idParaDest-220">Restoring <a id="_idTextAnchor327"/>the desired state with the memento pattern</h1>
			<p>Sometimes, it may be useful to consider<a id="_idIndexMarker451"/> keeping minimal information about the state of an object in order to continue or restore it. The memento pattern provides this functionality and was described in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor328"/>Motivation</h2>
			<p>Without breaking encapsulation, the internal state<a id="_idIndexMarker452"/> of an object, a memento, needs to be captured and externalized so that the object can later be restored to that state. The memento pattern provides a client function to restore the desired state of an object, a memento, <span class="No-Break">on demand.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor329"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">Date</strong> class that comes with the <strong class="source-inline">java.base</strong> module and its <strong class="source-inline">java.util</strong> package is a nice implementation<a id="_idIndexMarker453"/> of the memento pattern. An instance of a class represents a specific point on a timeline, and the date can be restored to that timeline referring to the calendar or <span class="No-Break">zone used.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor330"/>Sample code</h2>
			<p>Let us look at the example<a id="_idIndexMarker454"/> of air conditioning in a vehicle. The controller gives us several options for setting the cockpit temperature, which also means that the driver can restore an already selected state (<span class="No-Break"><em class="italic">Example 5.12</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
 public static void main(String[] args) {
    System.out.println("Memento Pattern, air-condition
        system");
    var originator = new AirConditionSystemOriginator();
    var careTaker = new AirConditionSystemCareTaker();
    originator.setState("low");
    var stateLow = originator.saveState(careTaker);
    originator.setState("medium");
    var stateMedium = originator.saveState(careTaker);
    originator.setState("high");
    var stateHigh = originator.saveState(careTaker);
    System.out.printf("""
            Current Air-Condition System state:'%s'%n""",
                originator.getState());
    originator.restoreState(careTaker.getMemento(stateLow));
    System.out.printf("""
            Restored position:'%d', Air-Condition System
                state:'%s'%n""", stateLow,
                    originator.getState());
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Memento Pattern, air-condition system</strong>
<strong class="bold">Current Air-Condition System state:'high'</strong>
<strong class="bold">Restored position:'0', Air-Condition System state:'low'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.12 – Each state is memorized and the driver can restore it on demand</p>
			<p>The <strong class="source-inline">AirConditionSystemCareTaker</strong> instance, playing the role of a memento provider, contains<a id="_idIndexMarker455"/> links to already used states (<span class="No-Break"><em class="italic">Example 5.13</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
final class AirConditionSystemCareTaker {
    private final List&lt;SystemMemento&gt; memory = new
        ArrayList&lt;&gt;();
     ...
    int add(SystemMemento m) {... }
    SystemMemento getMemento(int i) {... }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.13 – Each state is remembered with an identifier for restoration</p>
			<p>The <strong class="source-inline">AirConditionSystemOriginator</strong> instance considers creating a memento state and restoring the previous one from the memento object. The client is required to remember the provided state identifier to ask the caretaker for a memento state (<span class="No-Break"><em class="italic">Example 5.14</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
final class AirConditionSystemOriginator {
    private String state;
    ...
    int saveState(AirConditionSystemCareTaker careTaker){
        return careTaker.add(new SystemMemento(state));
    }
    void restoreState(SystemMemento m){
        state = m.state();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.14 – The originator holds the mutable states and updates the caretaker</p>
			<p>The program<a id="_idIndexMarker456"/> allows the client to only work on a few considered states without creating any other instances (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B18884_05_07.jpg" alt="Figure 5.7 – The UML class diagram showing that only a few classes are involved"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The UML class diagram showing that only a few classes are involved</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor331"/>Conclusion</h2>
			<p>The memento pattern <a id="_idIndexMarker457"/>is very useful when a program needs to perform any undo operation or rewind the timeline. It provides transparent implementation and the separation of logic to enforce the sustainability of the <span class="No-Break">code base.</span></p>
			<p>Let us see the program behaving as expected and examine this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor332"/>Avoiding a null pointer exception state with the null object pattern</h1>
			<p>The null object pattern<a id="_idIndexMarker458"/> provides a way to gracefully deal with an unidentified object and not cause unexpected or undefined <span class="No-Break">program behavior.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor333"/>Motivation</h2>
			<p>Instead of using the Java<a id="_idIndexMarker459"/> <strong class="source-inline">null</strong> construct to indicate the absence of an object, consider introducing the Null object pattern. A null object is considered to belong to a specific family of objects. The object implements the expected interface, but implementing its methods does not cause any actions. The advantage of this approach over using an undefined null reference is that the null object is very predictable and has no side effects: it does nothing. It also attempts to eliminate the unpleasant null <span class="No-Break">pointer exception.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor334"/>Finding it in the JDK</h2>
			<p>The traditionally <a id="_idIndexMarker460"/>mentioned <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">Collection</strong> framework, located in the <strong class="source-inline">java.util</strong> package, define the <strong class="source-inline">Collections</strong> utility class. This class contains an internal private <strong class="source-inline">EmptyIterator</strong> class to serve an <strong class="source-inline">elementless</strong> <span class="No-Break">iterator instance.</span></p>
			<p>Another nice example can be found in the <strong class="source-inline">java.io</strong> module and package. The abstract class, <strong class="source-inline">InputStream</strong>, defines the <strong class="source-inline">nullInpuStream</strong> method that serves th<a id="_idTextAnchor335"/>e input stream with <span class="No-Break">zero bytes.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor336"/>Sample code</h2>
			<p>Let us examine the usage<a id="_idIndexMarker461"/> of the null object pattern more closely. Today’s vehicles contain a dramatic number of different sensors. In order to take advantage of more than just the functionality of the Stream API, it is quite usef<a id="_idTextAnchor337"/>ul to define a null object that contains the sensor type and that the program can transpar<a id="_idTextAnchor338"/>ently respond to (<span class="No-Break"><em class="italic">Example 5.15</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Null Object Pattern, vehicle
        sensor");
    var engineSensor = VehicleSensorsProvider
        .getSenorByType("engine");
    var transmissionSensor = VehicleSensorsProvider
        .getSenorByType("transmission");
    System.out.println("Engine Sensor: " + engineSensor);
    System.out.println("Transmission Sensor: " +
        transmissionSensor);
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Null Object Pattern, vehicle sensor</strong>
<strong class="bold">Engine Sensor: Sensor{type='engine'}</strong>
<strong class="bold">Transmission Sensor: Sensor{type='not_available'}</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.15 – The client receives information that the requested sensor is not available as a NullSensor instance</p>
			<p>A <strong class="source-inline">VehicleSensorProvider</strong> instance always returns a result of the expected type, and implementing the pattern<a id="_idIndexMarker462"/> is very straightforward (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B18884_05_08.jpg" alt="Figure 5.8 – The UML class diagram showing the relationships used in the type maintenance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The UML class diagram showing the relationships used in the type maintenance</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor339"/>Conclusion</h2>
			<p>The examples showed <a id="_idIndexMarker463"/>that the pattern can not only improve the maintainability of the code base but also reduce unwanted runtime states, such as a null <span class="No-Break">pointer exception.</span></p>
			<p>An undefined program state can be resolved using an approach that we’ll explore in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor340"/>Keeping all interested parties informed using the observer pattern</h1>
			<p>The observer pattern<a id="_idIndexMarker464"/> is sometimes known as the producer-customer pattern. Again, this is a very<a id="_idIndexMarker465"/> common use case that appears across applications and is therefore mentioned in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor341"/>Motivation</h2>
			<p>A pattern represents<a id="_idIndexMarker466"/> a direct relationship between objects. One object has the role of the producer. A producer may have many customers to whom the information should be delivered. These objects<a id="_idIndexMarker467"/> are sometimes called receivers. When an observer changes its state, all the registered clients are informed of this change. In other words, any changes that occur to the object will cause the observers to <span class="No-Break">be notified.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor342"/>Finding it in the JDK</h2>
			<p>The observer pattern<a id="_idIndexMarker468"/> is another fairly commonly used pattern across JDK modules. An example is the <strong class="source-inline">Observer</strong> interface from the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.util</strong> package. Although the interfaces have already been deprecated, they are still used through the <strong class="source-inline">Observable</strong> class in the <span class="No-Break">compiler’s implementations.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor343"/>Sample code</h2>
			<p>Let us examine temperature<a id="_idIndexMarker469"/> control at different locations in the vehicle. The <strong class="source-inline">VehicleSystem</strong> instance should always inform all the interested parties about the temperature goal that each system can adjust itself to (<span class="No-Break"><em class="italic">Example 5.16</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Observer Pattern, vehicle
        temperature senors");
    var temperatureControlSystem = new VehicleSystem();
    new CockpitObserver(temperatureControlSystem);
    new EngineObserver(temperatureControlSystem);
    temperatureControlSystem.setState("low");
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Observer Pattern, vehicle temperature senors</strong>
<strong class="bold">CockpitObserver, temperature:'11'</strong>
<strong class="bold">EngineObserver, temperature:'4'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.16 – Each subsystem adjusts its temperature according to the global setup</p>
			<p>The <strong class="source-inline">SystemObserver</strong> abstract class<a id="_idIndexMarker470"/> not only denotes the subsystem under consideration using the construction of sealed classes but also provides a basic template for constructing the intended subsystem (<span class="No-Break"><em class="italic">Example 5.17</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sealed abstract class SystemObserver permits
    CockpitObserver, EngineObserver {
    protected final VehicleSystem system;
    public SystemObserver(VehicleSystem system) {
        this.system = system;
    }
    abstract void update();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.17 – The newly added subsystem follows the generic template to enforce the maintainability</p>
			<p>Each instance contains a reference to the main system that controls the temperature target (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18884_05_09.jpg" alt="Figure 5.9 – A UML class diagram emphasizes the relationships between systems"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – A UML class diagram emphasizes the relationships between systems</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor344"/>Conclusion</h2>
			<p>The observer pattern is another <a id="_idIndexMarker471"/>very powerful one: it allows the client to keep all stakeholders informed without the need to change or understand the implementation. The pattern properly encapsulates and decouples the logic and allows the use of configurable processes <span class="No-Break">at runtime.</span></p>
			<p>The next section shows how to solve linked <span class="No-Break">processes separately.</span></p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor345"/>Dealing with instance stages by using the pipeline pattern</h1>
			<p>The pipeline pattern<a id="_idIndexMarker472"/> can make a significant contribution<a id="_idIndexMarker473"/> to improving the organization of multiple <span class="No-Break">downstream operations.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor346"/>Motivation</h2>
			<p>This pattern improves<a id="_idIndexMarker474"/> data processing in a series of stages by providing an initial input and passing the processed output along for use in subsequent stages. The processing elements are arranged in a continuous pipeline so that the output of one is the input of another, similar to how a physical pipe works. A pipeline pattern can provide some kind of buffering between successive members, represented by object instances. The information that flows through these pipes is often a stream <span class="No-Break">of records.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor347"/>Finding it in the JDK</h2>
			<p>The most obvious example of the<a id="_idIndexMarker475"/> use of the pipeline pattern is the <strong class="source-inline">Stream</strong> interface and its implementations. The interface is part of the Stream API and is shipped together with the <strong class="source-inline">java.base</strong> module and the <span class="No-Break"><strong class="source-inline">java.util.stream</strong></span><span class="No-Break"> package.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor348"/>Sample code</h2>
			<p>Let’s imagine a sequence<a id="_idIndexMarker476"/> of processes that need to be carried out in a vehicle, define them, and put them in sequence. We then initialize a <strong class="source-inline">SystemElement</strong> container that collects information abou<a id="_idTextAnchor349"/>t the<a id="_idTextAnchor350"/> results of each process (<span class="No-Break"><em class="italic">Example 5.18</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pipeline Pattern, vehic<a id="_idTextAnchor351"/>le turn on
        states");
    var pipeline = new PipeElement&lt;&gt;(new EngineProcessor())
            .addProcessor(new BreakProcessor())
            .addProcessor(new TransmissionProcessor());
    var systemState = pipeline.process(new
        SystemElement());
    System.out.println(systemState.logSummary());
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pipeline Pattern, vehicle turn on states</strong>
<strong class="bold">engine-system,break-system,transmission-system</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.18 – Each process result is considered in the final summary</p>
			<p>The basic construction is <strong class="source-inline">PipeElement</strong>, which defines<a id="_idIndexMarker477"/> not only input types but also outputs. Moreover, it defines the order of information processing (<span class="No-Break"><em class="italic">Example 5.19</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class PipeElement&lt;E extends Element, R extends Element&gt; {
    private final Processor&lt;E, R&gt; processor;
   ...
    &lt;O extends Element&gt; PipeElement&lt;E, O&gt; addProcessor
        (Processor&lt;R, O&gt; p){
        return new PipeElement&lt;&gt;(input -&gt; p.process
            (processor.process(input)));
    }
    R process(E inputElement){
        return processor.process(inputElement);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.19 – The addProcessor method defines the order of the processor’s process method execution</p>
			<p>Each processor implementation can be considered a functional interface construct, and the <strong class="source-inline">Element</strong> implementation can be changed on demand<a id="_idIndexMarker478"/> without breaking the pipeline base code (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18884_05_10.jpg" alt="Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The UML class diagram showing how pipeline type safety is maintained</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor352"/>Conclusion</h2>
			<p>The presented example<a id="_idIndexMarker479"/> shows the advantages of a clear separation of processes contributing to the final result. The pipeline pattern has the potential to create complex operational sequences that can be easily tested and also <span class="No-Break">dynamically changed.</span></p>
			<p>Let’s explore how each intended element can change its state in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor353"/>Changing object behavior with the state pattern</h1>
			<p>The behavior state pattern<a id="_idIndexMarker480"/> defines the procedure for influencing an object’s internal<a id="_idIndexMarker481"/> processes based on the mutation of its internal state. This pattern is part of the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor354"/>Motivation</h2>
			<p>Object states can be thought<a id="_idIndexMarker482"/> of as representing the concept of a finite machine. A pattern allows an object to change its behavior when its internal state changes. The state pattern enforces that an object describes its internal states with specific classes, and maps responses to those states to <span class="No-Break">specific instances.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor355"/>Finding it in the JDK</h2>
			<p>Usage of the state pattern<a id="_idIndexMarker483"/> can be found in the implementation of the <strong class="source-inline">jlink</strong> plugin, the <strong class="source-inline">jdk.jlink</strong> module, and the <strong class="source-inline">jdk.tools.jlink.plugin</strong> package. The interface plugin defines a nested enum class, <strong class="source-inline">State</strong>, whose values are references to the states <span class="No-Break">in question.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor356"/>Sample code</h2>
			<p>The next example considers<a id="_idIndexMarker484"/> that each vehicle has different states that are well identified (<span class="No-Break"><em class="italic">Example 5.20</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("State Pattern, vehicle turn on
        states");
    ...
    var initState = new InitState();
    var startState = new StartState();
    var stopState = new StopState();
    vehicle.setState(initState);
    System.out.println("Vehicle state2:" +
        vehicle.getState());
    vehicle.setState(startState);
    System.out.println("Vehicle state3:" +
        vehicle.getState());
    vehicle.setState(stopState);
    System.out.println("Vehicle state4:" +
        vehicle.getState());
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker485"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">State Pattern, vehicle turn on states</strong>
<strong class="bold">Vehicle state2:InitState{vehicle=truck}</strong>
<strong class="bold">Vehicle state3:StartState{vehicle=truck}</strong>
<strong class="bold">Vehicle state4:StopState{vehicle=truck}</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.20 – Vehicle states are nicely encapsulated and separated from the client logic</p>
			<p>Each <strong class="source-inline">Vehicle</strong> state considered can be developed independently and properly separated from the client logic (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18884_05_11.jpg" alt="Figure 5.11 – The UML class diagram showing the relation between the states considered"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – The UML class diagram showing the relation between the states considered</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor357"/>Conclusion</h2>
			<p>The state pattern <a id="_idIndexMarker486"/>shows the advantages of concretely representing a state as a dedicated instance of an object. Not only does it improve testability but it also greatly contributes to the maintainability of the underlying code, as each state is clearly encapsulated and conforms to the single responsibility principle according to the SOLID concept. Program execution becomes transparent to the client without implementing any additional <span class="No-Break">exception-handling logic.</span></p>
			<p>Each state can correspond to a specific program behavior or runtime interaction. Let’s dive deeper into this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor358"/>Using the strategy pattern to change object behavior</h1>
			<p>The strategy pattern can sometimes<a id="_idIndexMarker487"/> be called a policy pattern because it establishes<a id="_idIndexMarker488"/> precise steps for runtime<a id="_idIndexMarker489"/> execution in a particular situation or state. This pattern is a part of the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor359"/>Motivation</h2>
			<p>The strategy pattern<a id="_idIndexMarker490"/> represents a family of algorithms where each one is properly encapsulated. It defines the interchangeability of algorithms to which a particular object can respond. This strategy allows the algorithm to change independently of the clients using it and allows the client to choose the most appropriate one on the fly. In other words, the code allows the client to attach various strategy objects that affect the behavior of <span class="No-Break">the program.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor360"/>Finding it in the JDK</h2>
			<p>The strategy pattern<a id="_idIndexMarker491"/> is another pattern commonly used without being aware of its use. The <strong class="source-inline">Collection</strong> framework from the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.util</strong> package implements the <strong class="source-inline">Comparator</strong> class. This class is often used for sorting purposes, such as the implementation of the <span class="No-Break"><strong class="source-inline">Collections.sort()</strong></span><span class="No-Break"> method.</span></p>
			<p>Another possibly even more widely used implementation is the <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong> methods introduced by the Stream API, which also comes from the <strong class="source-inline">java.base</strong> module but in the <span class="No-Break"><strong class="source-inline">java.util.stream</strong></span><span class="No-Break"> package.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor361"/>Sample code</h2>
			<p>Suppose a driver has multiple<a id="_idIndexMarker492"/> driving licenses required for specific types of vehicles. Each vehicle req<a id="_idTextAnchor362"/>uires<a id="_idTextAnchor363"/> a slightly different driving strategy (<span class="No-Break"><em class="italic">Example 5.21</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Strategy Pattern, changing
        transport options");
    var driver = new VehicleDriver(new CarStrategy());
    driver.transport();
    driver.changeStrategy(new BusStrategy());
    driver.transport();
    driver.changeStrategy(new TruckStrategy());
    driver.transport();
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Strategy Pattern, changing transport options</strong>
<strong class="bold">C<a id="_idTextAnchor364"/>ar, four persons transport</strong>
<strong class="bold">Bus, whole crew transport</strong>
<strong class="bold">Truck, transporting heavy load</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.21 – The VehicleDriver instance can change the transport stra<a id="_idTextAnchor365"/>tegy at the runtime</p>
			<p>The <strong class="source-inline">VehicleDriver</strong> instance only holds<a id="_idIndexMarker493"/> the reference to the currently used <strong class="source-inline">TransportStrategy</strong> instance (<span class="No-Break"><em class="italic">Example 5.22</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class VehicleDriver {
    private TransportStrategy strategy;
    VehicleDriver(TransportStrategy strategy) {
        this.strategy = strategy;
    }
    void changeStrateg<a id="_idTextAnchor366"/>y(TransportStrategy strategy){
        this.strategy = strategy;
    }
    void transport(){
        strategy.transport();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.22 – The VehicleDriver instance communicates with strategy through the visible method</p>
			<p>The client can decide which strategy<a id="_idIndexMarker494"/> to use at runtime. Each strategy is properly encapsulated (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18884_05_12.jpg" alt="Figure 5.12 – The UML class diagram showing how simply a new strategy can be defined"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – The UML class diagram showing how simply a new strategy can be defined</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor367"/>Conclusion</h2>
			<p>This trivial example showed<a id="_idIndexMarker495"/> a nicely isolated strategic pattern in action. Drivers can change their abilities based on the type of vehicle provided. This pattern’s ability to separate its logic from the rest of the code base makes it perfectly suited to implementing complex algorithms or operations<a id="_idIndexMarker496"/> that should not be exposed <span class="No-Break">to clients.</span></p>
			<p>Many running events have a general basis. Let’s explore how to deal with this kind of situation in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor368"/>Standardizing processes with the template pattern</h1>
			<p>The template method pattern<a id="_idIndexMarker497"/> unifies the generalization of intensive actions with a templating approach. The template pattern was recognized early and considered as part of the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor369"/>Motivation</h2>
			<p>The template method pattern<a id="_idIndexMarker498"/> is based on identifying similarly used steps. These steps define the skeleton of an algorithm. Each operation can defer its steps to specific subclasses. The template method introduces subclasses to redefine certain parts of an algorithm without changing its structure. A template can be used to execute the internal methods in the <span class="No-Break">desired order.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor370"/>Finding it in the JDK</h2>
			<p>Java uses input or output<a id="_idIndexMarker499"/> byte streams defined by the I/O API located in the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.io</strong> package. The <strong class="source-inline">InputStream</strong> class contains an overloaded <strong class="source-inline">read</strong> method that represents a byte-handling template. It’s a similar approach to the <strong class="source-inline">OutputStream</strong> class defining an overloaded <span class="No-Break"><strong class="source-inline">write</strong></span><span class="No-Break"> method.</span></p>
			<p>Another use of the template pattern can be found in the <strong class="source-inline">Collection</strong> framework, which resides in the same module and the <strong class="source-inline">java.util</strong> package. The abstract <strong class="source-inline">AbstractList</strong>, <strong class="source-inline">AbstractSet</strong>, and <strong class="source-inline">AbstractMap</strong> classes implement the <strong class="source-inline">indexOf</strong> and <strong class="source-inline">lastIndexOf</strong> methods with different templates – for example, <strong class="source-inline">AbstractList</strong> uses <strong class="source-inline">ListIterator</strong>, in comparison to the common <strong class="source-inline">Iterator</strong> <span class="No-Break">interface implementation.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor371"/>Sample code</h2>
			<p>Let us examine how the template<a id="_idIndexMarker500"/> method pattern can simplify creating a new sensor (<span class="No-Break"><em class="italic">Example 5.23</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Template method Pattern, changing
        transport options");
    Arrays.asList(new BreaksSensor(), new EngineSensor())
            .forEach(VehicleSensor::activate);
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Template method Pattern, changing transport options</strong>
<strong class="bold">BreaksSensor, initiated</strong>
<strong class="bold">BreaksSensor, measurement started</strong>
<strong class="bold">BreaksSensor, data stored</strong>
<strong class="bold">BreaksSensor, measurement stopped</strong>
<strong class="bold">EngineSensor, initiated</strong>
<strong class="bold">EngineSensor, measurement started</strong>
<strong class="bold">EngineSensor, data stored</strong>
<strong class="bold">EngineSensor, measurement stopped</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.23 – The template provides generic activation steps valid for each sensor</p>
			<p>The <strong class="source-inline">VehicleSensor</strong> abstract class represents the core element of the example by defining a final <strong class="source-inline">activate</strong> method (<span class="No-Break"><em class="italic">Example 5.24</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
abstract sealed class VehicleSensor permits BreaksSensor,
    EngineSensor {
    abstract void init();
    abstract void startMeasure();
    abstract void storeData();
    abstract void stopMeasure();
    final void activate(){
        init();
        startMeasure();
        storeData();
        stopMeasure();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.24 – The activate() template method defines the steps for each implementation</p>
			<p>In other words, the template method<a id="_idIndexMarker501"/> pattern also describes an approach to expanding the vehicle’s sensor base (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18884_05_13.jpg" alt="Figure 5.13 – The UML class diagram highlighting the simplicity of adding a new sensor"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – The UML class diagram highlighting the simplicity of adding a new sensor</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor372"/>Conclusion</h2>
			<p>The template method<a id="_idIndexMarker502"/> pattern demonstrates its great advantages for generalized actions. It seamlessly separates the internal logic from the client and provides transparent and generic steps for performing actions. It is easy to maintain the code base or to discover potential issues <span class="No-Break">within it.</span></p>
			<p>The runtime environment can be complex. It’s always good to be awar<a id="_idTextAnchor373"/>e of which instances are present. We will find out how to do this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor374"/>Executing code based on the object type using the visitor pattern</h1>
			<p>The visitor pattern<a id="_idIndexMarker503"/> introduces the separation<a id="_idIndexMarker504"/> of algorithm execution from the object instance in question. This pattern is mentioned in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor375"/>Motivation</h2>
			<p>The visitor pattern<a id="_idIndexMarker505"/> allows a client to define a new operation without changing the instance of the class it is working on. This pattern provides a way to separate the underlying code from the object structure. The separation practically results in providing the ability to add new operations to an existing object without any modifications to <span class="No-Break">its structure.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor376"/>Finding it in the JDK</h2>
			<p>Usage of the visitor pattern<a id="_idIndexMarker506"/> can be found in the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.nio.file</strong> package. The <strong class="source-inline">FileVisitor</strong> interface used by the <strong class="source-inline">Files</strong> utility class and its <strong class="source-inline">walkFileTree</strong> method uses a pattern to traverse the directory structure and <span class="No-Break">associated files.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor377"/>Sample code</h2>
			<p>A vehicle’s security normally<a id="_idIndexMarker507"/> relies on the robustness of its sensors. The example <a id="_idTextAnchor378"/>shows<a id="_idTextAnchor379"/> how to ensure the presence of each specific sensor (<span class="No-Break"><em class="italic">Example 5.25</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Visitor Pattern, check vehicle
        parts");
    var vehicleCheck = new VehicleCheck();
    vehicleCheck.accept(new VehicleSystemCheckVisitor());
}</pre>
			<p>Here’s <span class="No-Break">the outp<a id="_idTextAnchor380"/>ut:</span></p>
			<pre class="source-code">
<strong class="bold">Visitor Pattern, check vehicle parts</strong>
<strong class="bold">BreakCheck, ready</strong>
<strong class="bold">BreakCheck, rea<a id="_idTextAnchor381"/>dy, double-check, BreaksCheck@23fc625e</strong>
<strong class="bold">EngineCheck, ready</strong>
<strong class="bold">EngineCheck, ready, doub<a id="_idTextAnchor382"/>le-check, EngineCheck@3f99bd52</strong>
<strong class="bold">SuspensionCheck, ready</strong>
<strong class="bold">SuspensionCheck, ready, double-check,</strong>
<strong class="bold">    SuspensionCheck@4f023edb</strong>
<strong class="bold">VehicleCheck, ready</strong>
<strong class="bold">VehicleCheck, ready, double-check, VehicleCheck@3a71f4dd</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.25 – The client also double-checks each sensor’s presence</p>
			<p>The <strong class="source-inline">VehicleSystemCheackVisitor</strong> class defines an overloaded<a id="_idIndexMarker508"/> implementation of the <strong class="source-inline">visit</strong> method. Each particular sensor instance can be considered simply by overloading the <strong class="source-inline">visit</strong> method (<span class="No-Break"><em class="italic">Example 5.26</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class VehicleSystemCheckVisitor implements  CheckVisitor{
    @Override
    public void visit(EngineCheck engineCheck) {
        System.out.println("EngineCheck, ready");
        visitBySwitch(engineCheck);
    }
   private void visitBySwitch(SystemCheck systemCheck){
        switch (systemCheck){
        case EngineCheck e -&gt; System.out.println
            ("EngineCheck, ready, double-check, " + e);
        ...
        default -&gt; System.out.println(
           "VehicleSystemCheckVisitor, not implemented");
     }
   }
  ....
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5.26 – Pattern matching in the instanceof concept can enforce code maintainability</p>
			<p>Each system check correctly<a id="_idIndexMarker509"/> registers the intended sensor and increases confidence in the vehicle’s safety systems (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B18884_05_14.jpg" alt="Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – The UML class diagram for the vehicle sensors and their abstractions</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor383"/>Conclusion</h2>
			<p>This example showed how the <strong class="source-inline">VehicleCheck</strong> system can ensure<a id="_idIndexMarker510"/> the presence of each part. Each control is self-contained and new ones can be easily added or removed as needed. The downside is that it requires creating a dedicated instance for each type of control. This also means that at least two classes reference a similar state in the hierarchy. Another advantage or disadvantage is that the pattern does not cause the compilation to fail when a new element that may be discovered at runtime is added. Potential duplication can be overcome and type safety – following the maintenance of the Liskov substitution principle, which is violated by a standard visitor pattern – can be ensured through the utilization of a newly added <strong class="source-inline">switch</strong><a id="_idIndexMarker511"/> statement with pattern matching and a number of other improvements. <em class="italic">Example 5.26</em> shows the <strong class="source-inline">visitBySwitch</strong> method, which accepts <strong class="source-inline">SystemCheck</strong> objects <span class="No-Break">as input.</span></p>
			<p>Having explored the visitor pattern, we’ve come to the end of the chapter – let’s briefly summarize what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor384"/>Summary</h1>
			<p>In this chapter, we learned about the importance of the runtime environment and the dynamic nature of program execution. Behavioral design patterns can improve a program’s interaction with the internal parts of the Java platform. The JIT compiler can handle dynamic bytecode translation at runtime better, or a garbage collector can perform more efficient <span class="No-Break">memory reclamation.</span></p>
			<p>Most of these design patterns comply with SOLID principles – only the visitor pattern has left some room for thought. However, recently added improvements to the Java platform can help overcome this. Whether sealed classes, <strong class="source-inline">switch</strong> statements, pattern-matching enhancements, or records, the platform provides a solid foundation for strengthening the program’s immutability and code stability and simplifying the use of design patterns. Some of them may come out of the box, such as a factory method and <strong class="source-inline">switch-case</strong> <span class="No-Break">statement enhancements.</span></p>
			<p>In this chapter, we learned how to solve challenges at runtime using examples. We explored how to process a chained task and command the required actors. The formula interpreter translates the text into objects and we figured out how to iterate over them. The mediator pattern centralizes complex communication between objects. We learned how to avoid a null-pointer exception and give an undefined object a type using the null <span class="No-Break">object pattern.</span></p>
			<p>The pipeline formula processes a collection of clients sequentially. We explored how to change the state of particular actors and reviewed how to monitor these changes with the observer pattern. The last pattern we learned about was the visitor pattern, which showed us how to perform a specific operation based on the <span class="No-Break">object type.</span></p>
			<p>With the knowledge gained from behavioral patterns, we have added the missing piece to the complete lifecycle of a single-thread program. This includes the creation of objects, the programming structure for working with these objects, and the dynamic behavior and communication between these objects <span class="No-Break">at runtime.</span></p>
			<p>Although the intended program starts from the main thread and may meet be single-threaded as required, neither the Java platform nor most business requirements are single-threaded. The shared nature of tasks lends itself to multi-threaded communication. This can be done using various frameworks. As we will see in the next chapter, we can explore some common concurrency patterns to solve the most common challenges in this regard. Let’s shake <span class="No-Break">it up!</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor385"/>Questions</h1>
			<ol>
				<li>What principle is broken by the standard <span class="No-Break">visitor pattern?</span></li>
				<li>Which pattern helps us traverse over elements in a collection without knowing <span class="No-Break">the type?</span></li>
				<li>Is there a pattern that allows us to change an instance’s behavior <span class="No-Break">at runtime?</span></li>
				<li>Which pattern helps the runtime transparently identify an <span class="No-Break">undefined state?</span></li>
				<li>What are the most used patterns by the Java <span class="No-Break">Stream API?</span></li>
				<li>Is there a way to notify all clustered clients <span class="No-Break">at runtime?</span></li>
				<li>Which pattern can be used to <span class="No-Break">implement callbacks?</span></li>
			</ol>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor386"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <span class="No-Break">Addison-Wesley, 1995</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, Object <span class="No-Break">Mentor, 2000</span></li>
				<li><em class="italic">JEP-358: Helpful </em><span class="No-Break"><em class="italic">NullPointerExceptions</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/358"><span class="No-Break">https://openjdk.org/jeps/358</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JEP-361: Switch </em><span class="No-Break"><em class="italic">Expression</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/361"><span class="No-Break">https://openjdk.org/jeps/361</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JEP-394: Pattern Matching for </em><span class="No-Break"><em class="italic">instanceof</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/394"><span class="No-Break">https://openjdk.org/jeps/394</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JEP-395: </em><span class="No-Break"><em class="italic">Records</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/395"><span class="No-Break">https://openjdk.org/jeps/395</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JEP-405: Sealed </em><span class="No-Break"><em class="italic">Classes</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/405"><span class="No-Break">https://openjdk.org/jeps/405</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JEP-409: Sealed </em><span class="No-Break"><em class="italic">Classes</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/409"><span class="No-Break">https://openjdk.org/jeps/409</span></a><span class="No-Break">)</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer075" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer076" class="Content">
			<h1 id="_idParaDest-263"><a id="_idTextAnchor387"/>Part 3: Other Essential Patterns and Anti-Patterns</h1>
			<p>This part covers design principles and patterns for building highly concurrent applications. It also discusses several anti-patterns, meaning inappropriate software design solutions to <span class="No-Break">given challenges.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18884_06.xhtml#_idTextAnchor388"><em class="italic">Chapter 6</em></a>, <em class="italic">Concurrency Design Patterns</em></li>
				<li><a href="B18884_07.xhtml#_idTextAnchor481"><em class="italic">Chapter 7</em></a>, <em class="italic">Understanding Common Anti-Patterns</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer077">
			</div>
		</div>
		<div>
			<div id="_idContainer078">
			</div>
		</div>
	</body></html>