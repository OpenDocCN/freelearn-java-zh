<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Epsilon GC</h1>
                </header>
            
            <article>
                
<p><span>Imagine that a software organization replaces its programmers with ones who don't know how to code, in order to calculate how long it will take for them to exhaust their funds and shut down. In this scenario, no new revenue is generated, while staff pay continues. In a similar manner, when you use the Epsilon <strong>garbage collector</strong> (<strong>GC</strong>), introduced in Java 11, the software application replaces its GC with Epsilon, which does not release memory—to calculate how long will it take for the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) to exhaust all its memory and shut down.</span></p>
<p>Epsilon is a <strong>no-operation</strong> (<strong>no-op</strong>) GC—that is, it doesn't collect any garbage. It only handles the allocation of memory. When the available Java heap is exhausted, the JVM shuts down.</p>
<p>If this GC seems weird to you, think again. The Epsilon GC has been added as a benchmark to test applications for performance, memory usage, latency, and throughput improvements.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Why Epsilon is required</li>
<li>Features of Epsilon</li>
<li>Examples of working with Epsilon</li>
<li>Epsilon use cases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To work with the code in this chapter, you should have JDK version 11, or later, installed on your system.</p>
<p>All of the code in this chapter can be accessed using this URL: <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a>.</p>
<p>Let's get started by exploring why we need a GC that doesn't collect any garbage.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The motivation behind Epsilon GC</h1>
                </header>
            
            <article>
                
<p>You may have seen posters that state that by the year 2050, there will be more plastic in our oceans than fish. We are still in the year 2019. So, how can can marine analysts make predictions about 2050? There could be multiple ways of doing so. Perhaps they just assume that plastic is added without any cleanup, or perhaps they just use the current rate of increasing plastic pollution, or they might have applied another kind of algorithm.</p>
<p>The essence of this statement is that by arriving at a number (such as the year 2050), they can spread awareness about increasing marine plastic pollution. By stating that there will be <em>more plastic than fish</em>, they can get the attention of the masses and encourage them to get working now. People dread the worst; if you throw an alarming situation at them, they are more likely to react (in the suggested way).</p>
<p class="mce-root">Similarly, you could use Epsilon GC to predict the performance capabilities of your application. Because Epsilon GC can measure and tune the performance, memory usage, latency, and throughput of your applications without reclaiming the allocated memory. If you want to benchmark the application performance, Epsilon GC is the tool for you.<br/></p>
<div class="packt_infobox">Epsilon GC is used to benchmark other GCs against your applications, on multiple factors such as performance and memory usage in order to optimize your applications and use the best GCs that can work for your project.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features of Epsilon</h1>
                </header>
            
            <article>
                
<p>Epsilon doesn't clear the heap memory of unused objects; it only allocates memory. When the JVM runs out of memory, it shuts down with an <kbd>OutOfMemoryError</kbd> error. If a heap dump is enabled, Epsilon will perform a head dump, after throwing an <kbd>OutOfMemoryError</kbd> error.</p>
<p>Epsilon GC uses a simple, lock-free <strong>Thread Local Allocation Buffer</strong> (<strong>TLAB</strong>) allocation. This works by allocating contiguous sections of memory in a linear manner. One of the main benefits of TLAB allocation is that it binds a process to use the memory that has been allocated to it.</p>
<p>The barrier set used by Epsilon GC is completely empty, hence the name, <strong>no-op</strong>. Since it doesn't reclaim memory, it doesn't need to bother itself with maintaining the object graph, object marking, object compaction, or object copy.</p>
<p class="mce-root"/>
<p>Will you ever have any latency overhead with Epsilon? Yes, it is possible. Your application might experience latency overhead while Epsilon <strong>allocates</strong> memory<span>—</span>that is, if the memory size is too large and the chunk of memory that is being allocated is also large.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Latency and application performance</h1>
                </header>
            
            <article>
                
<p>Imagine your application processes thousands of messages every second. In this case, a latency of even one millisecond or more can have a performance impact on your system. The worst part is that you won't even know when your GC will kick in and start the collection.</p>
<p>I have a suggestion; execute your application with Epsilon GC as a benchmark that won't collect any garbage. Now execute your application with GCs of your choice, and analyze the logs. Now you can filter out the latency induced due to a GC<span>—</span>such as GC workers scheduling, GC barrier costs, or GC cycles. The performance of your system might also suffer due to issues that are not related to a GC<span>—</span>such as OS scheduling or compiler issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GC-induced overheads versus system overheads</h1>
                </header>
            
            <article>
                
<p>A GC cycle has a latency overhead. For critical applications, this can affect the desired throughput. With a carefully selected combination of multiple parameters, such as heap size, allocation units, GC cycles duration, region size, and various other parameters, you can compare the performance of your application across various GCs (including Epsilon).</p>
<p>However, overheads can also be induced by the system, which is not related to a GC. Executing your applications with multiple GCs will enable you to separate out GC-induced overheads from system overheads and select the best GC for your application.</p>
<p>By using a no-op GC such as Epsilon, you can filter out the GC-induced performance issues with OS/compiler issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extremely short-lived work</h1>
                </header>
            
            <article>
                
<p>Imagine that you need to create an application that is extremely short-lived. When you exit an application, JVM shuts down, and all the heap memory is reclaimed. Since executing a GC cycle takes up some time (though as little as possible), you might consider using Epsilon GC with your application.</p>
<p>Let's get started by using Epsilon GC with some example code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with the HelloEpsilon GC class</h1>
                </header>
            
            <article>
                
<p>Let's write a <kbd>HelloEpsilon</kbd> class and execute it using Epsilon GC. Here's the sample code:</p>
<pre>class HelloEpsilonGC { 
    public static void main(String[] args) { 
        System.out.println("Hello to Epsilon GC!"); 
    } 
} </pre>
<p>To execute the preceding code using Epsilon GC, you must use the <kbd>-XX:+UnlockExperimentalVMOptions</kbd> option with the <kbd>-XX:+UseEpsilonGC</kbd> option, followed by the class to execute:</p>
<pre>    <strong>&gt;java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC <br/>    HelloEpsilonGC</strong>
  </pre>
<p>The following screenshot highlights the preceding command at the top; the remaining part includes the GC output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c6daacb2-2232-448f-ae8d-230939951465.png" style="width:37.92em;height:17.08em;"/></div>
<p>As highlighted in the preceding screenshot, the following describes the GC output:</p>
<ul>
<li>JVM uses the Epsilon GC</li>
<li>It outputs the <kbd>Hello to Epsilon GC!</kbd> string to the standard output</li>
<li>It includes just one allocation of <kbd><kbd>792 KB</kbd></kbd></li>
</ul>
<div class="packt_infobox">The literal meaning of Epsilon is an arbitrarily small amount. This aligns with its op-code.</div>
<p>Recently, I was delivering a session on Java 11 features, and one of the attendees had a query. He asked:</p>
<div class="packt_quote">I understand that Epsilon GC doesn't garbage collect the Java heap, but does it garbage collect the stack memory?</div>
<p>I think this is an important question. Often, we don't care about the details until we need them.</p>
<p>If you know the answer, this question might seem trivial to you. If not, let's answer this simple and important question in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Which memory area does GC collect – stack or heap?</h1>
                </header>
            
            <article>
                
<p>JVM defines different memory management mechanisms with stack and heap<strong> </strong>memory. All GCs clean up the heap memory area by reclaiming the space occupied by unused or unreferenced objects. The GCs don't reclaim space from stack memory.</p>
<p>The stack memory area is used by a current thread for the execution of a method. When the current thread completes the execution of the current method, stack memory is released (without involving a GC collection). The primitives are stored on stack memory.</p>
<p class="mce-root"/>
<p>In a method, the local primitive variables and references to objects (not the actual objects) are stored on the stack. The actual objects are stored on the heap. The local primitive variables and reference variables that are accessible after the execution of a method are defined in the heap memory area. In essence, the following takes place:</p>
<ul>
<li>All objects are stored on the heap.</li>
<li>The local object references are stored on the stack; the instance or static object references are stored on the heap.</li>
<li>The local primitive variables and their values are stored on the stack. The instance or static primitive variables and their values are stored on the heap.</li>
</ul>
<p>Let's work with simple use cases where Epsilon GC can help you to improve the performance, memory usage, latency, and throughput of your applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory pressure testing with Epsilon</h1>
                </header>
            
            <article>
                
<p>Imagine that you don't want your application, or say, a section of your application, to use more than a certain amount of heap memory, such as 40 MB. How can you assert this? In this case, you can configure to execute your applications with <kbd>-Xmx40m</kbd>. Here's some example code that adds the same string values as the key/value pair to <kbd>HashMap</kbd> and then removes it<span>—</span>by iterating it multiple times (<kbd>1_000_000</kbd> to be precise):</p>
<pre>import java.util.*; 
class EpMap { 
    public static void main(String args[]) { 
        Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;(); 
        int size = 1_000_000; 
        for(int i = 0; i &lt; size; i++) { 
            String java = new String("Java"); 
            String eJavaGuru = new String("eJavaGuru.com"); 
            myMap.put(java, eJavaGuru); 
            myMap.remove(java); 
        } 
    } 
} </pre>
<p>You can execute it using the following command:</p>
<pre>    <strong>&gt; java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xlog:gc* <br/>    -Xmx40M EpMap</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code exits with <kbd>OutOfMemoryError</kbd>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8a3f3e98-3872-46b5-b148-396da347b9a8.png"/></div>
<p>Let's revisit the code that generated this output and check whether we can do something about it. At present, the code uses the <kbd>new</kbd> operator to create the same string values. Let's see what happens if I modify it to use the string pool, as follows:</p>
<pre>import java.util.*; 
class EpMap { 
    public static void main(String args[]) { 
        Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;(); 
        int size = 1_000_000; 
        for(int i = 0; i &lt; size; i++) { 
            String java = "Java";<br/>            String eJavaGuru = "eJavaGuru.com"; 
            myMap.put(java, eJavaGuru); 
            myMap.remove(java); 
        } 
    } 
} </pre>
<p>On the execution of this modified code, try executing the following command:</p>
<pre>    <strong>&gt; java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xlog:gc* <br/>    -Xmx40M EpMap</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code doesn't exit with <kbd>OutOfMemoryError</kbd> and completes the execution, as demonstrated in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ea1f4a2b-e26a-49b4-a61f-821d1952672c.png" style="width:43.33em;height:23.08em;"/></div>
<div class="packt_infobox">Reducing garbage is just one of the solutions to out of memory errors. To prevent or delay a GC cycle, you can also tune your runtime using multiple parameters<span>—</span>such as increasing the heap size or by setting a minimum time before a GC cycle runs.</div>
<p>This brings me to a very interesting case; can you design a garbage-free application, that is, one that can work with Epsilon forever? I think we already have a few that are in production and are in use by developers (as covered in the next section).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing a garbage-free application</h1>
                </header>
            
            <article>
                
<p>In <em>Which memory area does GC collect – stack or heap?</em> section, I mentioned that a GC reclaims heap memory<span>—</span>which can include (non-local) primitive data types or objects. In your Java application, heap memory can be used by these variables and objects from either of the following:</p>
<ul>
<li>Third-party libraries used by your application</li>
<li>A JDK API</li>
<li>Your application classes</li>
</ul>
<p>There are multiple ways to reduce garbage creation<span>—</span>by preferring primitive data over objects, reusing buffers, using object pools, dumping temporary object creation, and others.</p>
<p>Here's proof that this is possible. One of the most popular garbage-free applications Log4j, which is a logging application by Apache, <span>runs by default in a so-called garbage-free mode. This means that it reuses objects and buffers and avoids the allocation of temporary objects as much as possible. It also has a so-called low garbage mode; this mode is not entirely garbage free, but it also does not use ThreadLocal fields. </span> You can visit <a href="https://logging.apache.org/log4j/2.x/manual/garbagefree.html">https://logging.apache.org/log4j/2.x/manual/garbagefree.html</a> to learn more about it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">VM interface testing</h1>
                </header>
            
            <article>
                
<p>Java 10 has added a GC interface<span>—</span>to provide a clean GC development interface so that GC developers and HotSpot developers don't struggle to develop new GCs, and can locate the functionality of existing GCs with ease.</p>
<p>To a certain extent, Epsilon validates the GC interface. Since it doesn't reclaim memory, it doesn't really need to implement the methods that require it to maintain objects to reclaim, remove, or copy them. So, it can just inherit the default implementation (which isn't supposed to do any work). Since it works, Epsilon has helped in testing VM interfaces.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered Epsilon, a no-op GC that only allocates memory and doesn't free up the heap.</p>
<p>You can execute your applications with Epsilon and other GCs to measure your application's performance, memory usage, latency, and <span>throughput—</span>eventually using the best possible combinations<span>—</span>tuning your runtime environment and optimizing your applications.</p>
<p>In the next chapter, you'll get to work with one of the most exciting features of Java<span>—</span>the HTTP Client, which uses reactive streams to access resources over a network in a non-synchronous and non-blocking manner.</p>


            </article>

            
        </section>
    </body></html>