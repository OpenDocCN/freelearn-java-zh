["```java\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-blaze-server\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-circe\" % http4sVersion,\n  \"org.http4s\" %% \"http4s-dsl\" % http4sVersion,\n  \"org.tpolecat\" %% \"doobie-core\" % doobieVersion,\n  \"org.tpolecat\" %% \"doobie-h2\" % doobieVersion,\n  \"org.tpolecat\" %% \"doobie-hikari\" % doobieVersion,\n  \"com.h2database\" % \"h2\" % h2Version,\n  \"org.flywaydb\" % \"flyway-core\" % flywayVersion,\n  \"io.circe\" %% \"circe-generic\" % circeVersion,\n  \"com.github.pureconfig\" %% \"pureconfig\" % pureConfigVersion,\n  \"ch.qos.logback\" % \"logback-classic\" % logbackVersion,\n  \"org.typelevel\" %% \"cats-core\" % catsVersion,\n\n  \"org.http4s\" %% \"http4s-blaze-client\" % http4sVersion % \"it,test\",\n  \"io.circe\" %% \"circe-literal\" % circeVersion % \"it,test\",\n  \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"it,test\",\n  \"org.scalamock\" %% \"scalamock\" % scalaMockVersion % Test\n)\n```", "```java\nval chars: fs2.Stream[fs2.Pure,Char] = Stream.emits(List('a','b','c'))\n```", "```java\nobject Test extends App {\n  import fs2.Stream\n  import cats.effect.IO // 1\n  val io: IO[String] = IO { println(\"IO effect\"); \"a\" * 2 } // 2\n  val as: Stream[IO, String] = Stream.eval(io) // 3\n  val c: Stream.ToEffect[IO, String] = as.compile // 4\n  val v: IO[Vector[String]] = c.toVector // 5\n  val l: IO[List[String]] = c.to[List] // 6\n  val d: IO[Unit] = c.drain // 7\n  val e: IO[Option[String]] = c.last // 8\n  println(v.unsafeRunSync()) // 9\n  println(e.unsafeRunSync()) // 10\n  Stream.eval(IO { 42 }).compile.toList.unsafeRunSync() // 11\n}\n```", "```java\nCREATE TABLE article (\n  name  VARCHAR PRIMARY KEY,\n  count INTEGER NOT NULL CHECK (count >= 0)\n);\n```", "```java\ndef initialize(transactor: HikariTransactor[IO]): IO[Unit] = {\n  transactor.configure { dataSource =>\n    IO {\n      val flyWay = new Flyway()\n      flyWay.setLocations(\"classpath:db_migrations\")\n      flyWay.setDataSource(dataSource)\n      flyWay.migrate()\n    }\n  }\n}\n```", "```java\ndef transactor(c: DBConfig): IO[HikariTransactor[IO]] = {\n  HikariTransactor\n   .newHikariTransactor[IO](c.driver, c.url, c.user, c.password)\n}\n```", "```java\ncase class ServerConfig(host: String, port: Int)\ncase class DBConfig(driver: String, url: String, user: String, password: String)\ncase class Config(server: ServerConfig, database: DBConfig)\n```", "```java\nserver {\n  host = \"0.0.0.0\"\n  port = 8080\n}\ndatabase {\n  driver = \"org.h2.Driver\"\n  url = \"jdbc:h2:mem:ch14;DB_CLOSE_DELAY=-1\"\n  user = \"sa\"\n  password = \"\"\n}\n```", "```java\nobject Config {\n  def load(fileName: String): IO[Config] = {\n    IO {\n      val config = ConfigFactory.load(fileName)\n      pureconfig.loadConfig[Config](config)\n    }.flatMap {\n      case Left(e) =>\n        IO.raiseError[Config](new ConfigReaderException[Config](e))\n      case Right(config) =>\n        IO.pure(config)\n    }\n  }\n}\n```", "```java\nimport cats.effect.IO\nimport fs2.Stream\nimport doobie._\nimport doobie.implicits._\nimport doobie.util.transactor.Transactor\nimport cats.implicits._\n```", "```java\nobject Model {\n  type Inventory = Map[String, Int]\n  abstract sealed class Operation(val inventory: Inventory)\n\n  final case class Purchase(order: Inventory)\n      extends Operation(order.mapValues(_ * -1))\n\n  final case class Restock(override val inventory: Inventory)\n      extends Operation(inventory)\n}\n```", "```java\nclass Repository(transactor: Transactor[IO]) { ... }\n```", "```java\ndef createArticle(name: String): IO[Boolean] = {\n  val sql: Fragment = sql\"INSERT INTO article (name, count) VALUES ($name, 0)\"   // 1\n  val update: Update0 = sql.update  // 2\n  val conn: ConnectionIO[Int] = update.run //3\n  val att: ConnectionIO[Either[Throwable, Int]] = conn.attempt //4\n  val transact: IO[Either[Throwable, Int]] = att.transact(transactor) // 5\n  transact.map { // 6\n    case Right(affectedRows) => affectedRows == 1\n    case Left(_)             => false\n  }\n}\n```", "```java\ndef deleteArticle(name: String): IO[Boolean] =\nsql\"DELETE FROM article WHERE name = $name\"\n.update.run.transact(transactor).map { _ == 1 }\n```", "```java\ndef getInventory: Stream[IO, Inventory] = {\n  val query: doobie.Query0[(String, Int)] = \n      sql\"SELECT name, count FROM article\".query[(String, Int)]\n  val stream: Stream[IO, (String, Int)] = \n      query.stream.transact(transactor)\n  stream.fold(Map.empty[String, Int])(_ + _)\n}\n```", "```java\ndef updateStock(inventory: Inventory): Stream[IO, Either[Throwable, Unit]] = {\n  val updates = inventory.map { case (name, count) =>\n      sql\"UPDATE article SET count = count + $count WHERE name = $name\".update.run\n  }.reduce(_ *> _)\n  Stream\n    .eval(\n      FC.setAutoCommit(false) *> updates *> FC.setAutoCommit(true)\n    )\n    .attempt.transact(transactor)\n}\n```", "```java\nimport cats.effect.IO\nimport fs2.Stream\nimport org.http4s._\nimport org.http4s.dsl.Http4sDsl\nimport org.http4s.circe._\nimport org.http4s.headers.`Content-Type`\nimport io.circe.generic.auto._\nimport io.circe.syntax._\n```", "```java\nclass Service(repo: Repository) extends Http4sDsl[IO] { ... }\n```", "```java\nval service: HttpService[IO] = HttpService[IO] {\n```", "```java\ncase DELETE -> Root / \"articles\" / name if name.nonEmpty =>\n  val repoResult: IO[Boolean] = repo.deleteArticle(name)\n  val toResponse: Boolean => IO[Response[IO]] = if (_) NoContent() else NotFound()\n  val response: IO[Response[IO]] = repoResult.flatMap(toResponse)\n  response\n```", "```java\ncase POST -> Root / \"articles\" / name if name.nonEmpty =>\n  repo.createArticle(name).flatMap { if (_) NoContent() else Conflict() }\n```", "```java\ncase GET -> Root / \"inventory\" =>\n  val inventory: Stream[IO, Inventory] = repo.getInventory\n  renderInventory(inventory)\n```", "```java\nprivate def renderInventory(inventory: Stream[IO, Inventory]): IO[Response[IO]] = {\n  val json: Stream[IO, String] = inventory.map(_.asJson.noSpaces)\n  val response: IO[Response[IO]] = \n           Ok(json, `Content-Type`(MediaType.`application/json`))\n  response\n}\n```", "```java\ncase req @ POST -> Root / \"restock\" =>\n  val newState = for {\n    purchase <- Stream.eval(req.decodeJson[Restock])\n    _ <- repo.updateStock(purchase.inventory)\n    inventory <- repo.getInventory\n  } yield inventory\n  renderInventory(newState)\n```", "```java\nimport org.http4s.server.blaze.BlazeBuilder\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n```", "```java\nobject Server extends StreamApp[IO] { ... }\n```", "```java\noverride def stream(args: List[String],\n           requestShutdown: IO[Unit]): Stream[IO, ExitCode] = {\n  val config: IO[Config] = Config.load(\"application.conf\")\n  new ServerInstance(config).create().flatMap(_.serve)\n}\n```", "```java\nclass ServerInstance(config: IO[Config]) {\n  def create(): Stream[IO, BlazeBuilder[IO]] = {\n    for {\n      config <- Stream.eval(config)\n      transactor <- Stream.eval(DB.transactor(config.database))\n      _ <- Stream.eval(DB.initialize(transactor))\n    } yield BlazeBuilder[IO]\n      .bindHttp(config.server.port, config.server.host)\n      .mountService(new Service(new Repository(transactor)).service, \"/\")\n  }\n}\n```", "```java\nclass ServerSpec extends WordSpec with Matchers with BeforeAndAfterAll {\n  private lazy val client = Http1Client[IO]().unsafeRunSync()\n  private lazy val configIO = Config.load(\"test.conf\")\n  private lazy val config = configIO.unsafeRunSync()\n  private val server: Option[Http4sServer[IO]] = (for {\n    builder <- new ServerInstance(configIO).create()\n  } yield builder.start.unsafeRunSync()).compile.last.unsafeRunSync()\n```", "```java\noverride def afterAll(): Unit = {\n  client.shutdown.unsafeRunSync()\n  server.foreach(_.shutdown.unsafeRunSync())\n}\n```", "```java\n\"create articles\" in {\n  val eggs = Request[IO](method = Method.POST, uri = Uri.unsafeFromString(s\"$rootUrl/articles/eggs\"))\n  client.status(eggs).unsafeRunSync() shouldBe Status.NoContent\n  val chocolate = Request[IO](method = Method.POST, uri = Uri.unsafeFromString(s\"$rootUrl/articles/chocolate\"))\n  client.status(chocolate).unsafeRunSync() shouldBe Status.NoContent\n  val json = client.expect[Json](s\"$rootUrl/inventory\").unsafeRunSync()\n  json shouldBe json\"\"\"{\"eggs\" : 0,\"chocolate\" : 0}\"\"\"\n}\n```", "```java\nCREATE TABLE IF NOT EXISTS PUBLIC.\"journal\" (\n  \"ordering\" BIGINT AUTO_INCREMENT,\n  \"persistence_id\" VARCHAR(255) NOT NULL,\n  \"sequence_number\" BIGINT NOT NULL,\n  \"deleted\" BOOLEAN DEFAULT FALSE,\n  \"tags\" VARCHAR(255) DEFAULT NULL,\n  \"message\" BYTEA NOT NULL,\n  PRIMARY KEY(\"persistence_id\", \"sequence_number\")\n);\n```", "```java\nCREATE TABLE IF NOT EXISTS PUBLIC.\"snapshot\" (\n  \"persistence_id\" VARCHAR(255) NOT NULL,\n  \"sequence_number\" BIGINT NOT NULL,\n  \"created\" BIGINT NOT NULL,\n  \"snapshot\" BYTEA NOT NULL,\n  PRIMARY KEY(\"persistence_id\", \"sequence_number\")\n);\n```", "```java\n\"com.typesafe.akka\"   %% \"akka-persistence\"       % akkaVersion,\n\"com.github.dnvriend\" %% \"akka-persistence-jdbc\"  % akkaPersistenceVersion,\n\"com.scalapenos\"      %% \"stamina-json\"           % staminaVersion,\n\"com.h2database\"      %  \"h2\"                     % h2Version,\n\"org.flywaydb\"        %  \"flyway-core\"            % flywayVersion,\n```", "```java\nakka.actor {\n    serializers.serializer = \"ch14.EventSerializer\"\n    serialization-bindings {\n      \"stamina.Persistable\" = serializer\n    }\n}\n```", "```java\nclass EventSerializer\n    extends stamina.StaminaAkkaSerializer(v1createdPersister,\n                                  v1deletedPersister,\n                                  v1purchasedPersister,\n                                  v1restockedPersister,\n                                  v1inventoryPersister)\n```", "```java\nimport stamina.json._\n\nobject PersistenceSupport extends JsonSupport {\n  val v1createdPersister = persister[ArticleCreated](\"article-created\")\n  val v1deletedPersister = persister[ArticleDeleted](\"article-deleted\")\n  val v1purchasedPersister = persister[ArticlesPurchased](\"articles-purchased\")\n  val v1restockedPersister = persister[ArticlesRestocked](\"articles-restocked\")\n  val v1inventoryPersister = persister[Inventory](\"inventory\")\n}\n```", "```java\nimport akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\nimport spray.json.{DefaultJsonProtocol, RootJsonFormat}\nimport DefaultJsonProtocol._\n\ntrait JsonSupport extends SprayJsonSupport {\n  implicit val invJF: RootJsonFormat[Inventory] =\n    jsonFormat1(Inventory)\n\n  implicit val createArticleJF = jsonFormat2(CreateArticle)\n  implicit val deleteArticleJF = jsonFormat1(DeleteArticle)\n  implicit val purchaseJF = jsonFormat1(PurchaseArticles)\n  implicit val restockJF = jsonFormat1(RestockArticles)\n\n  implicit val createdJF = jsonFormat2(ArticleCreated)\n  implicit val deletedJF = jsonFormat1(ArticleDeleted)\n  implicit val pJF = jsonFormat1(ArticlesPurchased)\n  implicit val reJF = jsonFormat1(ArticlesRestocked)\n}\n```", "```java\nsealed trait Command\nsealed trait Query\n\nobject Commands {\n  final case class CreateArticle(name: String, count: Int) extends Command\n  final case class DeleteArticle(name: String) extends Command\n  final case class PurchaseArticles(order: Map[String, Int]) extends Command\n  final case class RestockArticles(stock: Map[String, Int]) extends Command\n  final case object GetInventory extends Query\n}\n```", "```java\nobject Events {\n  final case class ArticleCreated(name: String, count: Int) extends Event\n  final case class ArticleDeleted(name: String) extends Event\n  final case class ArticlesPurchased(order: Map[String, Int]) extends Event\n  final case class ArticlesRestocked(stock: Map[String, Int]) extends Event\n}\n```", "```java\nfinal case class Inventory(state: Map[String, Int]) extends Persistable { ... }\n```", "```java\ndef update(event: Event): Inventory = event match {\n  case ArticleCreated(name, cnt) => create(name, cnt).get\n  case ArticleDeleted(name)      => delete(name).get\n  case ArticlesPurchased(order)  => add(order.mapValues(_ * -1))\n  case ArticlesRestocked(stock)  => add(stock)\n}\n```", "```java\ndef create(name: String, count: Int): Option[Inventory] =\n  state.get(name) match {\n    case None => Some(Inventory(state.updated(name, count)))\n    case _    => None\n  }\n```", "```java\ndef delete(name: String): Option[Inventory] =\n  if (state.contains(name))\n    Some(Inventory(state.filterKeys(k => !(k == name))))\n  else None\n```", "```java\ndef add(o: Map[String, Int]): Inventory = {\n  val newState = state.foldLeft(Map.empty[String, Int]) {\n    case (acc, (k, v)) => acc.updated(k, v + o.getOrElse(k, 0))\n  }\n  Inventory(newState)\n}\n```", "```java\ndef canUpdate(cmd: Command): Option[Event] = cmd match {\n  case CreateArticle(name, cnt) =>\n    create(name, cnt).map(_ => ArticleCreated(name, cnt))\n  case DeleteArticle(name)     => delete(name).map(_ => ArticleDeleted(name))\n  case PurchaseArticles(order) =>\n    val updated = add(order.mapValues(_ * -1))\n    if (updated.state.forall(_._2 >=  0)) Some(ArticlesPurchased(order)) else None\n  case RestockArticles(stock)  => Some(ArticlesRestocked(stock))\n}\n```", "```java\nclass InventoryActor extends Actor with PersistentActor {\n  private var inventory: Inventory = Inventory(Map.empty)\n\n  override def persistenceId: String = InventoryActor.persistenceId\n\n  override def receiveRecover: Receive = ???\n\n  override def receiveCommand: Receive = ???\n}\n```", "```java\noverride def receiveRecover: Receive = {\n  case SnapshotOffer(_, snapshot: Inventory) => inventory = snapshot\n  case event: Event => inventory = inventory.update(event)\n  case RecoveryCompleted => saveSnapshot(inventory)\n}\n```", "```java\noverride def receiveCommand: Receive = {\n  case GetInventory =>\n    sender() ! inventory\n\n  case cmd: Command =>\n    inventory.canUpdate(cmd) match {\n      case None =>\n        sender() ! None\n      case Some(event) =>\n        persistAsync(event) { ev =>\n          inventory = inventory.update(ev)\n          sender() ! Some(ev)\n        }\n    }\n}\n```", "```java\nlazy val inventoryRoutes: Route =\n  path(\"inventory\") {\n    get {\n      ???\n    }\n  } ~\n    path(\"purchase\") {\n      post {\n        entity(as[PurchaseArticles]) { order =>\n            ???\n        }\n      }\n    } ~\n    path(\"restock\") {\n      post {\n        entity(as[RestockArticles]) { stock =>\n            ???\n        }\n      }\n    }\n```", "```java\ncomplete((inventory ? GetInventory).mapTo[Inventory])\n```", "```java\ntrait Routes extends JsonSupport {\n  implicit def system: ActorSystem\n  def inventory: ActorRef\n  def config: Config\n\n  implicit lazy val timeout: Timeout = config.timeout\n  implicit lazy val ec: ExecutionContext = system.dispatcher\n```", "```java\nval response: Future[Option[ArticlesPurchased]] =\n  (inventory ? order).mapTo[Option[ArticlesPurchased]]\nonSuccess(response) {\n  case None        => complete(StatusCodes.Conflict)\n  case Some(event) => complete(event)\n```", "```java\nval response: Future[Option[ArticlesRestocked]] =\n  (inventory ? stock).mapTo[Option[ArticlesRestocked]]\ncomplete(response)\n```", "```java\nlazy val routes: Route = articlesRoutes ~ inventoryRoutes\n```", "```java\nobject Server extends App with Routes with JsonSupport {\n\n  val config = Config.load()\n\n  implicit val system: ActorSystem = ActorSystem(\"ch14\")\n  implicit val materializer: ActorMaterializer = ActorMaterializer()\n\n  DB.initialize(config.database)\n\n  lazy val inventory: ActorRef = system.actorOf(InventoryActor.props, InventoryActor.persistenceId)\n\n  Http().bindAndHandle(routes, config.server.host, config.server.port)\n  Await.result(system.whenTerminated, Duration.Inf)\n}\n```", "```java\nclass RoutesSpec extends WordSpec with Matchers with ScalaFutures with ScalatestRouteTest with Routes {\n\n  override lazy val config: Config = Config.load()\n\n  DB.initialize(config.database)\n\n  override lazy val inventory: ActorRef = system.actorOf(InventoryActor.props, \"inventory\")\n  ...\n}\n```", "```java\n\"Routes\" should { \"be able to add article (POST /articles/eggs)\" in {\n  val request = Post(\"/articles/eggs\")\n  request ~> routes ~> check {\n    status shouldBe StatusCodes.Created\n    contentType shouldBe ContentTypes.`application/json`\n    entityAs[String] shouldBe \"\"\"{\"name\":\"eggs\",\"count\":0}\"\"\"\n  }\n}}\n```", "```java\n\"be able to restock articles (POST /restock)\" in {\n  val restock = RestockArticles(Map(\"eggs\" -> 10, \"chocolate\" -> 20))\n  val entity  = Marshal(restock).to[MessageEntity].futureValue\n  val request = Post(\"/restock\").withEntity(entity)\n  request ~> routes ~> check {\n    status shouldBe StatusCodes.OK\n    contentType shouldBe ContentTypes.`application/json`\n    entityAs[String] shouldBe \"\"\"{\"stock\":{\"eggs\":10,\"chocolate\":20}}\"\"\"\n  }\n}\n```"]