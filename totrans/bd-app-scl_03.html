<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Developing the UI with Play Framework" id="aid-1HIT81"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Developing the UI with Play Framework</h1></div></div></div><p>In the previous chapter, we performed bootstrapping on our application using Activator. In this chapter, we will continue developing our web application using Scala and Play framework. Play framework is great for web development because it is simple to use, and at the same time, very powerful. This is because it uses top-notch reactive solutions like spray, Akka, and Akka Stream under the hood. For this chapter, we will create the basic UI for some parts of our reactive web solution by adding validation and an in-memory store so you can feel the application working. We will use a little bit of CSS for styling, and JavaScript for some simple visualizations.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Basics of web development with Scala and Play frameworks</li><li class="listitem">Creating your models</li><li class="listitem">Working with views and validations</li><li class="listitem">Working with session scopes</li></ul></div><div class="section" title="Getting started"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Getting started</h1></div></div></div><p>Let's have a look at the preview of <code class="literal">Reactive Web Store</code>--the application that we will build.</p><p>
</p><div class="mediaobject"><img src="../Images/image00256.jpeg" alt="Getting started"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>For now, we will build three simple operations--<span class="strong"><strong>Create, Retrieve, Update, </strong></span>and<span class="strong"><strong> Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>) in order to manage products, product reviews, and product images. We will create models, controllers, views, and routes for each CRUD.</p><p>Let's get started. First of all, we need to define our models. The models need to be located at <code class="literal">ReactiveWebStore/app/models</code>. Models are the CORE of the system and they represent the entity. We will use this entity later to store and retrieve data from a database later on in <a class="link" title="Chapter 6.  Persistence with Slick" href="part0071.xhtml#aid-23MNU1">Chapter 6</a>, <span class="emphasis"><em>Persistence with Slick</em></span>. Our models should not have any UI logic, since we should use controllers for UI logic.</p></div></div>
<div class="section" title="Creating our models" id="aid-1IHDQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Creating our models</h1></div></div></div><p>For our product model, we have a simple Scala case class in <code class="literal">Product.scala</code> as follows:</p><pre class="programlisting">    package models &#13;
    case class Product &#13;
    ( var id:Option[Long], &#13;
      var name:String, &#13;
      var details:String, &#13;
      var price:BigDecimal ) &#13;
    { &#13;
      override def toString:String =  &#13;
      { &#13;
        "Product { id: " + id.getOrElse(0) + ",name: " + name + ", &#13;
        details: "+ details + ", price: " + price + "}" &#13;
      } &#13;
    } &#13;
</pre><p>A product can have an optional ID, a name, details, and a price. We also override the <code class="literal">toString</code> method just for the sake of simplicity for logging. We also need to define models for image and review.</p><p>The following is the review model from <code class="literal">Review.scala</code>:</p><pre class="programlisting">    package models &#13;
 &#13;
    case class Review &#13;
    (var id:Option[Long], &#13;
      var productId:Option[Long], &#13;
      var author:String, &#13;
      var comment:String) &#13;
    { &#13;
      override def toString:String = { &#13;
        "Review { id: " + id + " ,productId: " +  &#13;
        productId.getOrElse(0) + ",author: " + author + ",comment:  &#13;
        " + comment + " }" &#13;
      } &#13;
    } &#13;
</pre><p>For a review model, we have an optional ID, an optional <code class="literal">productId</code>, one author, and a comment. Validations will be done on the views. Now let's go for the image model.</p><p>The image model can be found in <code class="literal">Image.scala</code> as follows:</p><pre class="programlisting">    package models &#13;
 &#13;
    case class Image &#13;
    (var id:Option[Long], &#13;
      var productId:Option[Long],  &#13;
      var url:String){ &#13;
        override def toString:String = { &#13;
          "Image { productId: " + productId.getOrElse(0) + ",url: "  &#13;
          + url + "}" &#13;
        } &#13;
  } &#13;
</pre><p>For an image model, we have an optional ID, an optional <code class="literal">productId</code>, and the image URL.</p><p>The Play framework does the routing, and we need to define the routes at <code class="literal">ReactiveWebStore/conf/routes</code>. Keep in mind that the Play framework will validate all the routes, so you need to specify valid packages and classes. Play also creates something called reverse controller, which we will use later in the chapter. For now, let's define the routes. Reverse controller is generated by the Play framework with an action method which is the same as that of the original controller with the same signature, but it returns <code class="literal">play.api.mvc.Call</code> instead of <code class="literal">play.api.mvc.Action</code>.</p></div>
<div class="section" title="Creating routes" id="aid-1JFUC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Creating routes</h1></div></div></div><p>The Play framework CRUD operations' routes for product, image, and review are as follows:</p><pre class="programlisting">    # Routes &#13;
    # This file defines all application routes (Higher priority routes first) &#13;
    # ~~~~ &#13;
     &#13;
    GET / controllers.HomeController.index &#13;
    GET /assets/*file controllers.Assets.at(path="/public", file) &#13;
     &#13;
    # &#13;
    # Complete CRUD for Product &#13;
    # &#13;
    GET /product controllers.ProductController.index &#13;
    GET /product/add controllers.ProductController.blank &#13;
    POST /product/ controllers.ProductController.insert &#13;
    POST /product/:id controllers.ProductController.update(id:Long) &#13;
    POST /product:id/remove controllers.ProductController.remove(id:Long) &#13;
    GET /product/details/:id controllers.ProductController.details(id:Long) &#13;
     &#13;
    # &#13;
    # Complete GRUD for Review &#13;
    # &#13;
    GET /review controllers.ReviewController.index &#13;
    GET /review/add controllers.ReviewController.blank &#13;
    POST /review/ controllers.ReviewController.insert &#13;
    POST /review/:id controllers.ReviewController.update(id:Long) &#13;
    POST /review:id/remove controllers.ReviewController.remove(id:Long) &#13;
    GET /review/details/:id controllers.ReviewController.details(id:Long) &#13;
     &#13;
    # &#13;
    # Complete CRUD for Image &#13;
    # &#13;
    GET /image controllers.ImageController.index &#13;
    GET /image/add controllers.ImageController.blank &#13;
    POST /image/ controllers.ImageController.insert &#13;
    POST /image/:id controllers.ImageController.update(id:Long) &#13;
    POST /image:id/remove controllers.ImageController.remove(id:Long) &#13;
    GET /image/details/:id controllers.ImageController.details(id:Long) &#13;
</pre><p>The routes work like this--First you need to define the rest verb such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, <code class="literal">DELETE</code>, and then you put in a <code class="literal">PATH</code> like <code class="literal">/image</code>. Finally, you specify which controller function will handle that route. Now we have the routes in place, we can move to the controllers. We will define the controllers for product, image and review.</p><p>All the routes follow the same logic. First we send the user to the web page where we list all the items (products, images, reviews)--this is represented by <code class="literal">GET /resource</code>, where the resource can be an image, product, or review, for instance. In order to get a specific resource, often by ID, we give the command <code class="literal">GET /resource (product, review or image)/ID. POST /resource</code> is used to perform the <code class="literal">UPDATE</code>.</p><p>In order to create a new item (product, review, or image), the pattern is <code class="literal">GET /resource/add</code> and <code class="literal">POST /resource/</code>. You may wonder why there are two routes to perform an insert. Well, that's because first of all we need to load the web page, and secondly, when the form is submitted, we need a new route to handle the values. There are two routes for an update as well for the same reason. If you want to <code class="literal">DELETE</code> a resource, the pattern is <code class="literal">POST /resource/ID/remove</code>. Lastly, we have the details of the operation, which is used to show detailed information with regard to a specific item--the pattern is <code class="literal">GET /resource/details/ID</code>. With six routes, we can do a complete CRUD for a resource such as product, image, and review, or any other future resource that you may add to this application or your own applications.</p></div>
<div class="section" title="Creating our controllers"><div class="titlepage" id="aid-1KEEU2"><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Creating our controllers</h1></div></div></div><p>Now let's move to the controllers used on the previous routes. The controllers need to be located at <code class="literal">ReactiveWebStore/app/controllers</code>. Controllers are bound between views (UI), models and service, which are responsible for business operations. It's always important to separate UI logic, which tends to be specific, from business logic, which tends to be more generic, and often, way more important.</p><p>Let's have a look at the product controller in <code class="literal">ProductController.scala</code> in the following code:</p><pre class="programlisting">    @Singleton &#13;
    class ProductController @Inject() (val messagesApi:MessagesApi,val &#13;
    service:IProductService) extends Controller with I18nSupport { &#13;
 &#13;
      val productForm: Form[Product] = Form( &#13;
        mapping( &#13;
          "id" -&gt; optional(longNumber), &#13;
          "name" -&gt; nonEmptyText, &#13;
          "details" -&gt; text, &#13;
          "price" -&gt; bigDecimal &#13;
        )(models.Product.apply)(models.Product.unapply)) &#13;
     &#13;
      def index = Action { implicit request =&gt; &#13;
        val products = service.findAll().getOrElse(Seq()) &#13;
        Logger.info("index called. Products: " + products) &#13;
        Ok(views.html.product_index(products)) &#13;
      } &#13;
 &#13;
      def blank = Action { implicit request =&gt; &#13;
        Logger.info("blank called. ") &#13;
        Ok(views.html.product_details(None, productForm)) &#13;
      } &#13;
     &#13;
      def details(id: Long) = Action { implicit request =&gt; &#13;
        Logger.info("details called. id: " + id) &#13;
        val product = service.findById(id).get &#13;
        Ok(views.html.product_details(Some(id),  &#13;
        productForm.fill(product))) &#13;
      } &#13;
 &#13;
      def insert()= Action { implicit request =&gt; &#13;
        Logger.info("insert called.") &#13;
        productForm.bindFromRequest.fold( &#13;
          form =&gt; { &#13;
            BadRequest(views.html.product_details(None, form)) &#13;
          }, &#13;
        product =&gt; { &#13;
          val id = service.insert(product) &#13;
          Redirect(routes.ProductController.index).flashing("success"  &#13;
          -&gt; Messages("success.insert", id)) &#13;
        }) &#13;
      } &#13;
 &#13;
      def update(id: Long) = Action { implicit request =&gt; &#13;
        Logger.info("updated called. id: " + id) &#13;
        productForm.bindFromRequest.fold( &#13;
          form =&gt; { &#13;
            Ok(views.html.product_details(Some(id),  &#13;
            form)).flashing("error" -&gt; "Fix the errors!") &#13;
          }, &#13;
          product =&gt; { &#13;
            service.update(id,product) &#13;
            Redirect(routes.ProductController.index). &#13;
            flashing("success" -&gt; Messages("success.update",  &#13;
            product.name)) &#13;
          }) &#13;
      } &#13;
     &#13;
     &#13;
      def remove(id: Long)= Action { &#13;
        service.findById(id).map { product =&gt; &#13;
        service.remove(id) &#13;
        Redirect(routes.ProductController.index).flashing("success" -&gt;  &#13;
        Messages("success.delete", product.name)) &#13;
      }.getOrElse(NotFound) &#13;
     &#13;
      } &#13;
    } &#13;
</pre><p>The Play framework uses dependency injection and inversion of control using Google Guice. So, you can see at the top of the controller that we have the annotations <code class="literal">@Singleton</code> and <code class="literal">@Inject</code>. Singleton means that Guice will create a single instance of the class to handle all requests. Inject means we are injecting other dependencies into our controller, for instance, we inject <code class="literal">MessagesApi</code> in order to have the Play framework internalization support for string messages, and <code class="literal">IProductService</code>, that is, the product service that we will cover later in this chapter.</p><p>We also need to extend the Play class, <code class="literal">play.api.mvc.Controller</code>. Each function in a controller needs to return an action. This action could be a view.The Play framework compiles all the views into Scala classes, so you can safely reference them into your controllers code.</p><p>All business operations are delegated to a trait called <code class="literal">IProductService</code>, which we will cover later in this chapter. We also log some information using the Logger class. Play Framework uses <code class="literal">Logback</code> as the default logging solution. Let's take a closer look at each controller function now.</p><p>The index function calls <code class="literal">IProductService</code>, and finds all the available products. If there are no products available, it returns an empty sequence, and then calls the product UI passing the collection of products.</p><p>The blank function renders a blank product form, so the user can have a blank product form on the UI in order to add data (insert operation). Play framework works with form binding. So, in each controller, you need to define how your form looks on the UI. That form mapping is done using <code class="literal">play.api.data.Form</code>. You can see the mapping on the immutable variable called <code class="literal">productForm</code>. The mapping is between the view(UI) and the model called product. Keep in mind that the name field is mapped as <code class="literal">NonEmptyText</code>, which means Play won't accept null or blank values. This is a great future, because we can do validations in a declarative way without having to write code. Price is defined as <code class="literal">BigDecimal</code>, so Play won't accept text, but only numbers.</p><p>The details function retrieves a product using <code class="literal">IProductService</code>, and redirects to the view. However, before doing the redirect, it binds the data with the form so the UI will load with all the data into the HTML inputs.</p><p>We also have the insert and update methods. They are all constructed with a <code class="literal">fold</code> method. The <code class="literal">fold</code> method has left and right, which means error or ok. The <code class="literal">fold</code> function is called from the mapped form and if there are no validation errors, it goes right, but if there are validations errors, it goes left. That's a very simple and clean way to code the <code class="literal">update</code> and <code class="literal">insert</code> flows. With <code class="literal">fold</code>, we don't need code for an <code class="literal">if</code> statement. Once the validation is OK, we call <code class="literal">IProductService</code> to do an insert or update, and then we perform a redirect to the view. Messages are passed via scope. Play has options for scope--session or Flash. Session is for multiple requests, and the value will be stored in the client side. Flash is a request scope, and most of the times that is what you need to use. Here we are using the <code class="literal">Flash</code> scope, so it will only exit during that specific request. This feature is used to pass <span class="strong"><strong>Internationalization messages</strong></span> (<span class="strong"><strong>i18n</strong></span>), which are the result of the action. All the i18n messages need to be defined at <code class="literal">ReactiveWebStore/conf/messages</code> as follows:</p><pre class="programlisting">    success.delete = OK '{0}' deleted! &#13;
    success.insert = OK '{0}' created! &#13;
    success.update = OK '{0}' updated! &#13;
    error.notFound = Nothing Found with ID {0,number,0} &#13;
    error.number = Not a valid number &#13;
    error.required = Missing value here &#13;
</pre><p>Lastly, we have the remove method. First of all, we need to make sure the product exists, so we do a <code class="literal">findById</code> using <code class="literal">IProductService</code>, and then we apply a map function. If the product doesn't exist, the Play framework has prebuilt HTTP error code messages like <code class="literal">NotFound</code>. If the product exists, we remove it using <code class="literal">IProductService</code>, and then we redirect to the UI with a flashing message. Now let's see the image and review controllers.</p><p>The review controller, <code class="literal">ReviewController.scala</code>, is as follows:</p><pre class="programlisting">    @Singleton &#13;
    class ReviewController @Inject() &#13;
    (val messagesApi:MessagesApi, &#13;
      val productService:IProductService, &#13;
      val service:IReviewService) &#13;
    extends Controller with I18nSupport { &#13;
      val reviewForm:Form[Review] = Form( &#13;
        mapping( &#13;
          "id" -&gt; optional(longNumber), &#13;
          "productId" -&gt; optional(longNumber), &#13;
          "author" -&gt; nonEmptyText, &#13;
          "comment" -&gt; nonEmptyText &#13;
        )(models.Review.apply)(models.Review.unapply)) &#13;
     &#13;
      def index = Action { implicit request =&gt; &#13;
        val reviews = service.findAll().getOrElse(Seq()) &#13;
        Logger.info("index called. Reviews: " + reviews) &#13;
        Ok(views.html.review_index(reviews)) &#13;
      } &#13;
     &#13;
      def blank = Action { implicit request =&gt; &#13;
        Logger.info("blank called. ") &#13;
        Ok(views.html.review_details(None,  &#13;
          reviewForm,productService.findAllProducts)) &#13;
      } &#13;
 &#13;
      def details(id: Long) = Action { implicit request =&gt; &#13;
        Logger.info("details called. id: " + id) &#13;
        val review = service.findById(id).get &#13;
        Ok(views.html.review_details(Some(id),  &#13;
        reviewForm.fill(review),productService.findAllProducts)) &#13;
      } &#13;
     &#13;
      def insert()= Action { implicit request =&gt; &#13;
        Logger.info("insert called.") &#13;
        reviewForm.bindFromRequest.fold( &#13;
        form =&gt; { &#13;
          BadRequest(views.html.review_details(None,  &#13;
          form,productService.findAllProducts)) &#13;
      }, &#13;
      review =&gt; { &#13;
        if (review.productId==null ||   &#13;
        review.productId.getOrElse(0)==0) { &#13;
          Redirect(routes.ReviewController.blank).flashing("error" -&gt;  &#13;
          "Product ID Cannot be Null!") &#13;
        }else { &#13;
          Logger.info("Review: " + review) &#13;
          if (review.productId==null ||  &#13;
          review.productId.getOrElse(0)==0) throw new  &#13;
          IllegalArgumentException("Product  Id Cannot Be Null") &#13;
          val id = service.insert(review) &#13;
          Redirect(routes.ReviewController.index).flashing("success" - &#13;
          &gt; Messages("success.insert", id)) &#13;
        } &#13;
      }) &#13;
    } &#13;
     &#13;
    def update(id: Long) = Action { implicit request =&gt; &#13;
      Logger.info("updated called. id: " + id) &#13;
      reviewForm.bindFromRequest.fold( &#13;
        form =&gt; { &#13;
          Ok(views.html.review_details(Some(id),  &#13;
            form,productService.findAllProducts)).flashing("error" -&gt;  &#13;
          "Fix the errors!") &#13;
        }, &#13;
        review =&gt; { &#13;
          service.update(id,review) &#13;
          Redirect(routes.ReviewController.index).flashing("success" - &#13;
          &gt;Messages("success.update", review.productId)) &#13;
        }) &#13;
      } &#13;
     &#13;
      def remove(id: Long)= Action { &#13;
        service.findById(id).map { review =&gt; &#13;
          service.remove(id) &#13;
          Redirect(routes.ReviewController.index).flashing("success" - &#13;
          &gt;Messages("success.delete", review.productId)) &#13;
        }.getOrElse(NotFound) &#13;
      } &#13;
     &#13;
    } &#13;
</pre><p>The review controller follows the same ideas and structure as the product controller. The only main difference is that here we need to Inject <code class="literal">IProductService</code>, because a review needs to belong to a product. Then we need to use <code class="literal">IProductService</code> in order to <code class="literal">findAllProduct</code>, because in the review view, we will have <code class="literal">SelectBox</code> with all the available products.</p><p>The image controller, <code class="literal">ImageController.scala</code>, is as follows:</p><pre class="programlisting">    @Singleton &#13;
    class ImageController @Inject() &#13;
    (val messagesApi:MessagesApi, &#13;
      val productService:IProductService, &#13;
      val service:IImageService) &#13;
    extends Controller with I18nSupport { &#13;
 &#13;
      val imageForm:Form[Image] = Form( &#13;
        mapping( &#13;
          "id" -&gt; optional(longNumber), &#13;
          "productId" -&gt; optional(longNumber), &#13;
          "url" -&gt; text &#13;
        )(models.Image.apply)(models.Image.unapply)) &#13;
 &#13;
        def index = Action { implicit request =&gt; &#13;
          val images = service.findAll().getOrElse(Seq()) &#13;
          Logger.info("index called. Images: " + images) &#13;
          Ok(views.html.image_index(images)) &#13;
        } &#13;
 &#13;
        def blank = Action { implicit request =&gt; &#13;
          Logger.info("blank called. ") &#13;
          Ok(views.html.image_details(None,  &#13;
          imageForm,productService.findAllProducts)) &#13;
        } &#13;
 &#13;
        def details(id: Long) = Action { implicit request =&gt; &#13;
          Logger.info("details called. id: " + id) &#13;
          val image = service.findById(id).get &#13;
          Ok(views.html.image_details(Some(id),  &#13;
          imageForm.fill(image),productService.findAllProducts)) &#13;
        } &#13;
 &#13;
        def insert()= Action { implicit request =&gt; &#13;
          Logger.info("insert called.") &#13;
          imageForm.bindFromRequest.fold( &#13;
            form =&gt; { &#13;
              BadRequest(views.html.image_details(None, form,  &#13;
              productService.findAllProducts)) &#13;
            }, &#13;
            image =&gt; { &#13;
              If (image.productId==null ||  &#13;
              image.productId.getOrElse(0)==0) { &#13;
                Redirect(routes.ImageController.blank). &#13;
                flashing("error" -&gt; "Product ID Cannot be Null!") &#13;
              }else { &#13;
                if (image.url==null || "".equals(image.url)) image.url  &#13;
                = "/assets/images/default_product.png" &#13;
                val id = service.insert(image) &#13;
                Redirect(routes.ImageController.index). &#13;
                flashing("success" -&gt; Messages("success.insert", id)) &#13;
              } &#13;
            }) &#13;
        } &#13;
 &#13;
        def update(id: Long) = Action { implicit request =&gt; &#13;
          Logger.info("updated called. id: " + id) &#13;
          imageForm.bindFromRequest.fold( &#13;
            form =&gt; { &#13;
              Ok(views.html.image_details(Some(id), form,  &#13;
              null)).flashing("error" -&gt; "Fix the errors!") &#13;
            }, &#13;
            image =&gt; { &#13;
              service.update(id,image) &#13;
              Redirect(routes.ImageController.index). &#13;
              flashing("success" -&gt; Messages("success.update",  &#13;
              image.id)) &#13;
            }) &#13;
        } &#13;
 &#13;
    def remove(id: Long)= Action { &#13;
      service.findById(id).map { image =&gt; &#13;
        service.remove(id) &#13;
        Redirect(routes.ImageController.index).flashing("success"  &#13;
        -&gt; Messages("success.delete", image.id)) &#13;
      }.getOrElse(NotFound) &#13;
    } &#13;
} &#13;
</pre><p>Image review works in a similar way to <code class="literal">ReviewController</code>. We need <code class="literal">IProductService</code> to get all the services.</p></div>
<div class="section" title="Working with services"><div class="titlepage" id="aid-1LCVG2"><div><div><h1 class="title"><a id="ch03lvl1sec48"/>Working with services</h1></div></div></div><p>Services are where we put the business logic. We will look at reactive persistence in <a class="link" title="Chapter 6.  Persistence with Slick" href="part0071.xhtml#aid-23MNU1">Chapter 6</a>, <span class="emphasis"><em>Persistence with Slick</em></span>. Right now, we don't have a database to persist information, so, for now, we will do an in-memory persistence.</p><p>First we will define the contract of our services. This is the Base API that we will use in the controllers. Let's take a look at the following trait in <code class="literal">BaseService.scala</code>:</p><pre class="programlisting">    package services &#13;
 &#13;
    import java.util.concurrent.atomic.AtomicLong &#13;
    import scala.collection.mutable.HashMap &#13;
     &#13;
    trait BaseService[A] { &#13;
     &#13;
      var inMemoryDB = new HashMap[Long,A] &#13;
      var idCounter = new AtomicLong(0) &#13;
 &#13;
      def insert(a:A):Long &#13;
      def update(id:Long,a:A):Boolean  &#13;
      def remove(id:Long):Boolean  &#13;
      def findById(id:Long):Option[A]  &#13;
      def findAll():Option[List[A]] &#13;
    } &#13;
</pre><p>In the preceding code, we have an in-memory mutable <code class="literal">HashMap</code>, which is in our memory database where we will store products, images, and reviews. We also have an atomic counter with which we can generate IDs for our models. This is a trait using Generics--as you can see, here we have all the operations with <code class="literal">A</code>, which will be specified later. Now we can move the service implementation for product, review, and image.</p><p>The <code class="literal">ProductService.scala</code> package is as follows:</p><pre class="programlisting">    package services &#13;
 &#13;
    import models.Product &#13;
    import javax.inject._ &#13;
 &#13;
    trait IProductService extends BaseService[Product]{ &#13;
      def insert(product:Product):Long &#13;
      def update(id:Long,product:Product):Boolean &#13;
      def remove(id:Long):Boolean &#13;
      def findById(id:Long):Option[Product] &#13;
      def findAll():Option[List[Product]] &#13;
      def findAllProducts():Seq[(String,String)] &#13;
    } &#13;
 &#13;
    @Singleton &#13;
    class ProductService extends IProductService{ &#13;
 &#13;
      def insert(product:Product):Long = { &#13;
        val id = idCounter.incrementAndGet() &#13;
        product.id = Some(id) &#13;
        inMemoryDB.put(id, product) &#13;
        id &#13;
      } &#13;
 &#13;
      def update(id:Long,product:Product):Boolean = { &#13;
        validateId(id) &#13;
        product.id = Some(id) &#13;
        inMemoryDB.put(id, product) &#13;
        true &#13;
      } &#13;
 &#13;
      def remove(id:Long):Boolean = { &#13;
        validateId(id) &#13;
        inMemoryDB.remove(id) &#13;
        true &#13;
      } &#13;
 &#13;
      def findById(id:Long):Option[Product] = { &#13;
        inMemoryDB.get(id) &#13;
      } &#13;
 &#13;
 &#13;
 &#13;
 &#13;
      def findAll():Option[List[Product]] = { &#13;
        if (inMemoryDB.values == Nil ||  &#13;
        inMemoryDB.values.toList.size==0) return None &#13;
        Some(inMemoryDB.values.toList) &#13;
      } &#13;
 &#13;
      private def validateId(id:Long):Unit = { &#13;
        val entry = inMemoryDB.get(id) &#13;
        if (entry==null) throw new RuntimeException("Could not find  &#13;
        Product: " + id) &#13;
      } &#13;
 &#13;
      def findAllProducts():Seq[(String,String)] = { &#13;
        val products:Seq[(String,String)] = this &#13;
        .findAll() &#13;
        .getOrElse(List(Product(Some(0),"","",0))) &#13;
        .toSeq &#13;
        .map { product =&gt; (product.id.get.toString,product.name) } &#13;
        return products &#13;
      } &#13;
    } &#13;
</pre><p>In the last code, we defined a trait called <code class="literal">IProductService</code>, which extends <code class="literal">BaseService</code> with a generic apply to product. The <code class="literal">ProductService</code> package implements <code class="literal">IProductService</code>. In Scala, we can have multiple classes in the same Scala file, so there is no need to create different files.</p><p>The code is very straightforward. There is a utility method here called <code class="literal">findAllProducts</code>, which is used by review and image controllers. Here we get all the elements on the in-memory hash map. If there are no elements, we return a list with empty product. Then we map the list to a <code class="literal">Seq</code> of tuple, which is required by the <code class="literal">SelectBox</code> checkbox that we will have in the view(UI). Now let's go for the image and review services  as follows:</p><pre class="programlisting">    package services &#13;
 &#13;
    import javax.inject._ &#13;
    import models.Image &#13;
    import scala.collection.mutable.HashMap &#13;
    import java.util.concurrent.atomic.AtomicLong &#13;
 &#13;
    trait IImageService extends BaseService[Image]{ &#13;
      def insert(image:Image):Long &#13;
      def update(id:Long,image:Image):Boolean &#13;
      def remove(id:Long):Boolean &#13;
      def findById(id:Long):Option[Image] &#13;
      def findAll():Option[List[Image]] &#13;
} &#13;
 &#13;
    @Singleton &#13;
    class ImageService extends IImageService{ &#13;
 &#13;
      def insert(image:Image):Long = { &#13;
        val id = idCounter.incrementAndGet(); &#13;
        image.id = Some(id) &#13;
        inMemoryDB.put(id, image) &#13;
        id &#13;
      } &#13;
 &#13;
      def update(id:Long,image:Image):Boolean = { &#13;
        validateId(id) &#13;
        image.id = Some(id) &#13;
        inMemoryDB.put(id, image) &#13;
        true &#13;
      } &#13;
 &#13;
      def remove(id:Long):Boolean = { &#13;
        validateId(id) &#13;
        inMemoryDB.remove(id) &#13;
        true &#13;
      } &#13;
 &#13;
      def findById(id:Long):Option[Image] = { &#13;
        inMemoryDB.get(id) &#13;
      } &#13;
 &#13;
      def findAll():Option[List[Image]] = { &#13;
        if (inMemoryDB.values.toList == null ||  &#13;
        inMemoryDB.values.toList.size==0) return None &#13;
        Some(inMemoryDB.values.toList) &#13;
      } &#13;
 &#13;
      private def validateId(id:Long):Unit = { &#13;
        val entry = inMemoryDB.get(id) &#13;
        If (entry==null) throw new RuntimeException("Could not find  &#13;
        Image: " + id) &#13;
      } &#13;
     &#13;
    } &#13;
</pre><p>In the preceding code, we have something pretty similar to that of <code class="literal">ProductService</code>. We have a trait called <code class="literal">IImageService</code> and the <code class="literal">ImageService</code> implementation. Now let's go for the review service implementation in <code class="literal">ReviewService.scala</code>as follows:</p><pre class="programlisting">    package services &#13;
 &#13;
    import javax.inject._ &#13;
    import models.Review &#13;
    import scala.collection.mutable.HashMap &#13;
    import java.util.concurrent.atomic.AtomicLong &#13;
 &#13;
    trait IReviewService extends BaseService[Review]{ &#13;
      def insert(review:Review):Long &#13;
      def update(id:Long,review:Review):Boolean &#13;
      def remove(id:Long):Boolean &#13;
      def findById(id:Long):Option[Review] &#13;
      def findAll():Option[List[Review]] &#13;
    } &#13;
 &#13;
    @Singleton &#13;
    class ReviewService extends IReviewService{ &#13;
 &#13;
      def insert(review:Review):Long = { &#13;
        val id = idCounter.incrementAndGet(); &#13;
        review.id = Some(id) &#13;
        inMemoryDB.put(id, review) &#13;
        id &#13;
      } &#13;
 &#13;
      def update(id:Long,review:Review):Boolean = { &#13;
        validateId(id) &#13;
        review.id = Some(id) &#13;
        inMemoryDB.put(id, review) &#13;
        true &#13;
      } &#13;
 &#13;
      def remove(id:Long):Boolean = { &#13;
        validateId(id) &#13;
        inMemoryDB.remove(id) &#13;
        true &#13;
      } &#13;
 &#13;
      def findById(id:Long):Option[Review] = { &#13;
        inMemoryDB.get(id) &#13;
      } &#13;
 &#13;
      def findAll():Option[List[Review]] = { &#13;
        if (inMemoryDB.values.toList == null ||  &#13;
        inMemoryDB.values.toList.size==0) return None &#13;
        Some(inMemoryDB.values.toList) &#13;
      } &#13;
 &#13;
      private def validateId(id:Long):Unit = { &#13;
        val entry = inMemoryDB.get(id) &#13;
        If (entry==null) throw new RuntimeException("Could not find  &#13;
        Review: " + id) &#13;
      } &#13;
    } &#13;
</pre><p>In the preceding code, we have the <code class="literal">IReviewService</code> trait and the <code class="literal">ReviewService</code> implementation. We have validations on the service as well as a good practice.</p></div>
<div class="section" title="Configuring the Guice module" id="aid-1MBG21"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec49"/>Configuring the Guice module</h1></div></div></div><p>We injected classes using <code class="literal">@Inject</code> in our controllers. The injection happens based on a trait; we need to define a concrete implementation for the traits we injected. The Play framework looks for Guice injections at the location <code class="literal">ReactiveWebStore/app/Module.scala</code>. Okay, so let's define our injections for the three controllers we just created.</p><p>The Guice module is found in <code class="literal">Module.scala</code>as follows:</p><pre class="programlisting">    import com.google.inject.AbstractModule 
    import java.time.Clock 
    import services.{ApplicationTimer} 
    import services.IProductService 
    import services.ProductService 
    import services.ReviewService 
    import services.IReviewService 
    import services.ImageService 
    import services.IImageService 
 
    /** 
    * This class is a Guice module that tells Guice how to bind several 
    * different types. This Guice module is created when the Play 
    * application starts. 
 
    * Play will automatically use any class called `Module` that is in 
    * the root package. You can create modules in other locations by 
    * adding `play.modules.enabled` settings to the `application.conf` 
    * configuration file. 
    */ 
    class Module extends AbstractModule { 
 
      override def configure() = { 
        // Use the system clock as the default implementation of Clock 
        bind(classOf[Clock]).toInstance(Clock.systemDefaultZone) 
        // Ask Guice to create an instance of ApplicationTimer  
        // when the application starts. 
        bind(classOf[ApplicationTimer]).asEagerSingleton() 
        bind(classOf[IProductService]).to(classOf[ProductService]). 
        asEagerSingleton() 
        bind(classOf[IReviewService]).to(classOf[ReviewService]). 
        asEagerSingleton() 
        bind(classOf[IImageService]).to(classOf[ImageService]). 
        asEagerSingleton() 
      } 
    } 
</pre><p>So we just need to add <code class="literal">bind</code> with our traits for the controllers, and then point to the controller implementation. They should also be created as singletons, as the Play framework starts our application. Here you also can define any other configuration or injection that our application may need. The last code defines three services: product service, <code class="literal">IReviewService</code>, and <code class="literal">IImageService</code>.</p></div>
<div class="section" title="Working with views(UI)"><div class="titlepage" id="aid-1NA0K2"><div><div><h1 class="title"><a id="ch03lvl1sec50"/>Working with views(UI)</h1></div></div></div><p>The Play framework works with a Scala-based templating engine called Twirl. Twirl was inspired by ASP.NET Razor. Twirl is compact and expressive; you will see we can do more with less. Twirl template files are simple text files, however, the Play framework compiles the templates and turns them into Scala classes. You can mix HTML with Scala smoothly in Twirl.</p><p>The UI will be compiled into a Scala class, that can and will be referenced at our controllers, because we can route to a view. The nice thing about it is that this makes our coding way safer, since we have the compiler checking for us. The bad news is that you need to compile your UI, otherwise, your controllers won't find it.</p><p>Previously in this chapter, we defined controllers for products, images, and reviews, and we wrote the following code:</p><pre class="programlisting">    Ok(views.html.product_details(None, productForm)) &#13;
</pre><p>With the preceding code, we redirect the user to a blank page for products so that the user can create a new product. We also can pass parameters to the UI. Since it is all Scala code, you are actually just calling a function as follows:</p><pre class="programlisting">    val product = service.findById(id).get &#13;
    Ok(views.html.product_details(Some(id), productForm.fill(product))) &#13;
</pre><p>In the preceding code, we call the service to retrieve a product by ID, and then pass the object to the UI with the form being filled.</p><p>Let's continue building our application and create the UI for the products, reviews, and images. Since we are doing a CRUD, we will need more than one template file per CRUD. We will need the following structure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Index Template<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">List all items</li><li class="listitem">Link to edit one item</li><li class="listitem">Link to remove one item</li><li class="listitem">Link to create a new Item<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Detail Template<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">HTML Form to create a new Item</li><li class="listitem">HTML form to edit an existing item(for update)</li></ul></div></li></ul></div></li></ul></div></li></ul></div><p>Having said that, we will have the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For Products:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">product_index.scala.html</li><li class="listitem">product_details.scala.html<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For Image:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">image_index.scala.html</li><li class="listitem">image_details.scala.html<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For Reviews:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">review_index.scala.html</li><li class="listitem">review_details.scala.html</li></ul></div></li></ul></div></li></ul></div></li></ul></div></li></ul></div></li></ul></div><p>For the sake of code reuse, we will create another file containing the basic structure of our UI, like CSS imports (CSS needs to be located at <code class="literal">ReactiveWebStore\public\stylesheets</code>), JavaScript imports, and page title so that we don't need to repeat that in all the templates for each CRUD. This page will be called: <code class="literal">main.scala.html</code>.</p><p>All the UI code should be located at <code class="literal">ReactiveWebStore/app/views</code>.</p><p>The main Scala with the UI index for all CRUD operations is in <code class="literal">main.scala.html</code>, as follows:</p><pre class="programlisting">    @(title: String)(content: Html)(implicit flash: Flash) &#13;
 &#13;
    &lt;!DOCTYPE html&gt; &#13;
      &lt;html lang="en"&gt; &#13;
        &lt;head&gt; &#13;
          &lt;title&gt;@title&lt;/title&gt; &#13;
          &lt;link rel="shortcut icon" type="image/png"  &#13;
          href="@routes.Assets.at("images/favicon.png")"&gt; &#13;
          &lt;link rel="stylesheet" media="screen"  &#13;
          href="@routes.Assets.at("stylesheets/main.css")"&gt; &#13;
          &lt;link rel="stylesheet" media="screen"  &#13;
          href="@routes.Assets.at("stylesheets/bootstrap.min.css")"&gt; &#13;
          &lt;script src="@routes.Assets.at("javascripts/jquery- &#13;
          1.9.0.min.js")" type="text/javascript"&gt;&lt;/script&gt; &#13;
          &lt;script src="@routes.Assets.at("javascripts/bootstrap.js")"  &#13;
          type="text/javascript"&gt;&lt;/script&gt; &#13;
          &lt;script src="@routes.Assets.at("javascripts/image.js")"  &#13;
          type="text/javascript"&gt;&lt;/script&gt; &#13;
        &lt;/head&gt; &#13;
        &lt;body&gt; &#13;
          &lt;center&gt;&lt;a href='/'&gt;&lt;img height='42' width='42'  &#13;
          src='@routes.Assets.at("images/rws.png")'&gt;&lt;/a&gt; &#13;
          &lt;h3&gt;@title&lt;/h3&gt;&lt;/center&gt; &#13;
          &lt;div class="container"&gt; &#13;
            @alert(alertType: String) = { &#13;
              @flash.get(alertType).map { message =&gt; &#13;
                &lt;div class="alert alert-@alertType"&gt; &#13;
                  &lt;button type="button" class="close" data- &#13;
                  dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#13;
                  @message &#13;
                &lt;/div&gt; &#13;
              } &#13;
            } &#13;
          @alert("error") &#13;
          @alert("success") &#13;
          @content &#13;
          &lt;a href="/"&gt;&lt;/a&gt;&lt;BR&gt; &#13;
          &lt;button type="submit" class="btn btn-primary"  &#13;
          onclick="window.location.href='/'; " &gt; &#13;
          Reactive Web Store - Home &#13;
          &lt;/button&gt; &#13;
        &lt;/div&gt; &#13;
      &lt;/body&gt; &#13;
    &lt;/html&gt; &#13;
</pre><p>In the preceding code, first of all, there is the following line at the very top:</p><pre class="programlisting">    @(title: String)(content: Html)(implicit flash: Flash) &#13;
</pre><p>This means that we define the parameters this UI can receive. Here we expect a string title, which will be the page title, and there are some currying variables as well. You can get more details about currying in <a class="link" title="Chapter 1. Introduction to FP, Reactive, and Scala" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Introduction to FP, Reactive, and Scala</em></span>. So in currying, there are two things: First is HTML, which means you can pass HTML code to this function, and second, we have <code class="literal">Flash</code> which the Play framework will pass for us. <code class="literal">Flash</code> is used to get parameters between requests.</p><p>As you can see, later in the code we have <code class="literal">@title</code>, which means we retrieve the title of the parameters, and add the value to the HTML. We also print any error message or any validations issues, if present, with <code class="literal">@alert</code>. We import JQuery and Twitter Bootstrap, but we do not put hard-coded paths. Instead, we use the routers like <code class="literal">@routes.Assets.at</code>. The Javascripts still need to be located at <code class="literal">ReactiveWebStore\public\javascripts</code>.</p><p>Now other templates can work with <code class="literal">@main(..),</code> and they don't need any declaration of Javascript or CSS. They can add an extra HTML code, which will be rendered on the previous code by <code class="literal">@content</code>. So, for the products, the content will be HTML product content, and so on for reviews, and images. Now we can move for the products UI.</p><p>Product index: ­ UI index for products <code class="literal">product_index.scala.html</code>
</p><pre class="programlisting">    @(products:Seq[Product])(implicit flash: Flash) &#13;
 &#13;
    @main("Products") { &#13;
 &#13;
      @if(!products.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;Name&lt;/th&gt; &#13;
            &lt;th&gt;Details&lt;/th&gt; &#13;
            &lt;th&gt;Price&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(product &lt;- products) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ProductController. &#13;
              details(product.id.get)"&gt;@product.name&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@product.details&lt;/td&gt; &#13;
              &lt;td&gt;@product.price&lt;/td&gt; &#13;
              &lt;td&gt;&lt;form method="post" action= &#13;
              "@routes.ProductController.remove(product.id.get)"&gt; &#13;
              &lt;button class="btn btn-link" type="submit"&gt; &#13;
              &lt;i class="icon-trash"&gt;&lt;/i&gt;Delete&lt;/button&gt; &#13;
              &lt;/form&gt;&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ProductController.blank" class= &#13;
      "btn btn-success"&gt;&lt;i class="icon-plus icon-white"&gt; &#13;
      &lt;/i&gt;Add Product&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
</pre><p>As you can see, there is HTML mixed with Scala code. Every time you need to run HTML, you just run it, and when you need run Scala code, you need use a special character, <code class="literal">@</code>. At the very top of the template, you can see the following code:</p><pre class="programlisting">    @(products:Seq[Product])(implicit flash: Flash) &#13;
</pre><p>Since this is Scala code in the end, and will be compiled, we need to define what parameters this UI template can receive. Here we expect a sequence of products. There is also a currying implicit variable called <code class="literal">Flash</code>, which will be provided by the Play framework, and we will use it for the message display. We also have the code-<code class="literal">@main("Products") { .. }</code>. This means that we call the main Scala template and add extra HTML--the product HTML. For this product UI, we list all the products based on the sequence of products. As you can see, we define an HTML table. We also validate if the sequence is not empty before listing all the products.</p><p>Now we can go for the details page for products in <code class="literal">product_details.scala.html</code> as follows:</p><pre class="programlisting">    @(id: Option[Long],product:Form[Product])(implicit flash:Flash) &#13;
     &#13;
    @import play.api.i18n.Messages.Implicits._ &#13;
    @import play.api.Play.current &#13;
     &#13;
    @main("Product: " + product("name").value.getOrElse("")){  &#13;
 &#13;
      @if(product.hasErrors) { &#13;
        &lt;div class="alert alert-error"&gt; &#13;
          &lt;button type="button" class="close" data- &#13;
          dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#13;
          Sorry! Some information does not look right. Could you  &#13;
          review it please and re-submit? &#13;
        &lt;/div&gt; &#13;
      } &#13;
  &#13;
      @helper.form(action = if (id.isDefined)  &#13;
        routes.ProductController.update(id.get) else  &#13;
        routes.ProductController.insert)  &#13;
      { &#13;
        @helper.inputText(product("name"),    '_label -&gt; "Product  &#13;
        Name") &#13;
        @helper.inputText(product("details"), '_label -&gt; "Product  &#13;
        Details") &#13;
        @helper.inputText(product("price"),   '_label -&gt; "Price") &#13;
        &lt;div class="form-actions"&gt; &#13;
          &lt;button type="submit" class="btn btn-primary"&gt; &#13;
            @if(id.isDefined) { Update Product } else { New Product } &#13;
          &lt;/button&gt; &#13;
        &lt;/div&gt; &#13;
      } &#13;
 &#13;
    } &#13;
</pre><p>For this preceding UI, at the very top, we have the following line:</p><pre class="programlisting">    @(id: Option[Long],product:Form[Product])(implicit flash:Flash) &#13;
</pre><p>This means that we expect an ID which is completely optional. This ID is used to know if we are dealing with an insert scenario or an update scenario, because we use the same UI for both insert and update. We also get the product form, which will be passed through <code class="literal">ProductController</code>, and we receive <code class="literal">Flash</code>, which will be provided by the Play framework.</p><p>We need to do some imports on the UI so that we can get access to the Play framework i18n support. This is done by the following:</p><pre class="programlisting">    @import play.api.i18n.Messages.Implicits._ &#13;
    @import play.api.Play.current &#13;
</pre><p>Like the previous UI, we render this UI within the main Scala UI. So we don't need to specify JavaScript and CSS again. This is done by the following code:</p><pre class="programlisting">    @main("Product: " + product("name").value.getOrElse("")){ .. } &#13;
</pre><p>Next we check if there are any validation errors. If there are, the users will need to fix the errors before moving on. This is done by the following code:</p><pre class="programlisting">    @if(product.hasErrors) { &#13;
      &lt;div class="alert alert-error"&gt; &#13;
        &lt;button type="button" class="close" data- &#13;
        dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#13;
        Sorry! Some information does not look right. Could you review  &#13;
        it please and re-submit? &#13;
      &lt;/div&gt; &#13;
    } &#13;
</pre><p>Now is the time to create the product form, which, in the end, will be mapped to HTML input boxes. We do this with the following code:</p><pre class="programlisting">    @helper.form(action = if (id.isDefined) &#13;
    routes.ProductController.update(id.get) else &#13;
    routes.ProductController.insert) { &#13;
      @helper.inputText(product("name"),    '_label -&gt; "Product Name") &#13;
      @helper.inputText(product("details"), '_label -&gt; "Product  &#13;
      Details") &#13;
      @helper.inputText(product("price"),   '_label -&gt; "Price") &#13;
      &lt;div class="form-actions"&gt; &#13;
        &lt;button type="submit" class="btn btn-primary"&gt; &#13;
          @if(id.isDefined) { Update Product } else { New Product } &#13;
        &lt;/button&gt; &#13;
      &lt;/div&gt; &#13;
    } &#13;
</pre><p>
<code class="literal">@helper.form</code> is a special helper provided by the Play framework to create HTML forms easily. So, the action is the target where the form will be submitted. We need to do an <code class="literal">if</code> here, since we need to know if it is an update or an insert. Then we map all the fields we have for our product model with this code:</p><pre class="programlisting">    @helper.inputText(product("name"),    '_label -&gt; "Product Name") &#13;
    @helper.inputText(product("details"), '_label -&gt; "Product Details") &#13;
    @helper.inputText(product("price"),   '_label -&gt; "Price") &#13;
</pre><p>Remember, the product form comes from the product controller. For the helper, we just need to tell it which product field is for which HTML label, and that's it. This will produce the following UIs.</p><p>The following image shows the blank product index UI:</p><p>
</p><div class="mediaobject"><img src="../Images/image00257.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The insert UI form for product details looks as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00258.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>With products added, the product index UI appears as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00259.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can move to reviews. Let's go for the UIs.</p><p>The review index UI in <code class="literal">review_index.scala.html</code> is as follows:</p><pre class="programlisting">    @(reviews:Seq[Review])(implicit flash: Flash) &#13;
 &#13;
    @main("Reviews") { &#13;
 &#13;
      @if(!reviews.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;ProductId&lt;/th&gt; &#13;
            &lt;th&gt;Author&lt;/th&gt; &#13;
            &lt;th&gt;Comment&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(review &lt;- reviews) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ReviewController.details &#13;
              (review.id.get)"&gt;@review.productId&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@review.author&lt;/td&gt; &#13;
              &lt;td&gt;@review.comment&lt;/td&gt; &#13;
              &lt;td&gt; &#13;
              &lt;form method="post" action="@routes.ReviewController. &#13;
              remove(review.id.get)"&gt; &#13;
                &lt;button class="btn btn-link" type="submit"&gt;&lt;i class= &#13;
                "icon-trash"&gt;&lt;/i&gt;Delete&lt;/button&gt; &#13;
              &lt;/form&gt;&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ReviewController.blank" class="btn btn- &#13;
      success"&gt;&lt;i class="icon-plus icon-white"&gt;&lt;/i&gt;Add Review&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
</pre><p>So here we have the same things as we had for the products. Let's take a look at the details page for review now. You can find it in <code class="literal">review_details.scala.html</code>.</p><pre class="programlisting">    @(id: Option[Long],review:Form[Review],products:&#13;
    Seq[(String,String)])(implicit flash:Flash) &#13;
 &#13;
    @import play.api.i18n.Messages.Implicits._ &#13;
    @import play.api.Play.current &#13;
 &#13;
    @main("review: " + review("name").value.getOrElse("")){  &#13;
 &#13;
      @if(review.hasErrors) { &#13;
        &lt;div class="alert alert-error"&gt; &#13;
          &lt;button type="button" class="close" data- &#13;
          dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#13;
          Sorry! Some information does not look right. Could you  &#13;
          review it please and re-submit? &#13;
        &lt;/div&gt; &#13;
      } &#13;
 &#13;
      @helper.form(action = if (id.isDefined)  &#13;
      routes.ReviewController.update(id.get) else  &#13;
      routes.ReviewController.insert) { &#13;
        @helper.select( &#13;
          field = review("productId"), &#13;
          options = products, &#13;
          '_label -&gt; "Product Name",  &#13;
          '_default -&gt; review("productId").value.getOrElse("Choose  &#13;
          One")) &#13;
          @helper.inputText(review("author"),     '_label -&gt; "Author") &#13;
          @helper.inputText(review("comment"),    '_label -&gt;  &#13;
          "Comment") &#13;
          &lt;div class="form-actions"&gt; &#13;
            &lt;button type="submit" class="btn btn-primary"&gt; &#13;
            @if(id.isDefined) { Update review } else { New review } &#13;
          &lt;/button&gt; &#13;
          &lt;/div&gt; &#13;
      } &#13;
 &#13;
    } &#13;
</pre><p>Here, in this last code, we have almost everything similar to what we had for products, however, there is one big difference. Review needs to be associated with a product ID. That's why, we need to have a select for the products, which is fulfilled by <code class="literal">products:Seq[(String,String)]</code>. This comes from the <code class="literal">ReviewController</code> code. This code produces the following UIs.</p><p>The blank review index UI is shown as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00260.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The insert review details UI looks as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00261.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The review index UI with reviews will look like the following image:</p><p>
</p><div class="mediaobject"><img src="../Images/image00262.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can move to the last one: the image UI. The image UI is very similar to the review UI, because it depends on the product ID too. Let's go for it.</p><p>The image index UI has the following code in <code class="literal">image_index.scala.html</code>:</p><pre class="programlisting">    @(images:Seq[Image])(implicit flash:Flash) &#13;
    @main("Images") { &#13;
      @if(!images.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;ProductID&lt;/th&gt; &#13;
            &lt;th&gt;URL&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(image &lt;- images) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ImageController.details &#13;
              (image.id.get)"&gt;@image.id&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@image.productId&lt;/td&gt; &#13;
              &lt;td&gt;@image.url&lt;/td&gt; &#13;
              &lt;td&gt;&lt;form method="post" action= &#13;
              "@routes.ImageController.remove(image.id.get)"&gt; &#13;
                &lt;button class="btn btn-link" type="submit"&gt; &#13;
                &lt;i class="icon-trash"&gt;&lt;/i&gt;Delete&lt;/button&gt; &#13;
              &lt;/form&gt;&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ImageController.blank" class= &#13;
      "btn btn-success"&gt;&lt;i class="icon-plus icon-white"&gt; &#13;
      &lt;/i&gt;Add Image&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
 &#13;
    Image Details UI [image_details.scala.html] &#13;
 &#13;
    @(id: Option[Long],image:Form[Image],products:Seq[(String,String)])&#13;
    (implicit flash:Flash) &#13;
    @import play.api.i18n.Messages.Implicits._ &#13;
    @import play.api.Play.current &#13;
    @main("Image: " + image("productId").value.getOrElse("")){  &#13;
      @if(image.hasErrors) { &#13;
        &lt;div class="alert alert-error"&gt; &#13;
          &lt;button type="button" class="close" data- &#13;
          dismiss="alert"&gt;&amp;times;&lt;/button&gt; &#13;
          Sorry! Some information does not look right. Could you image  &#13;
          it please and re-submit? &#13;
        &lt;/div&gt; &#13;
      } &#13;
 &#13;
      @helper.form(action = if (id.isDefined)  &#13;
      routes.ImageController.update(id.get) else  &#13;
      routes.ImageController.insert) { &#13;
        @helper.select(field = image("productId"), &#13;
          options = products, &#13;
          '_label -&gt; "Product Name",  &#13;
          '_default -&gt; image("productId").value.getOrElse("Choose  &#13;
          One") &#13;
        ) &#13;
        @helper.inputText(  &#13;
          image("url"),  &#13;
          '_label       -&gt; "URL", &#13;
          '_placeholder -&gt; "/assets/images/default_product.png", &#13;
          'onchange     -&gt; "javascript:loadImage();" &#13;
        ) &#13;
        Visualization&lt;br&gt; &#13;
        &lt;img id="imgProduct" height="42" width="42"  &#13;
        src="@image("url").value"&gt;&lt;/img&gt; &#13;
        &lt;div class="form-actions"&gt; &#13;
          &lt;button type="submit" class="btn btn-primary"&gt; &#13;
            @if(id.isDefined) { Update Image } else { New Image } &#13;
          &lt;/button&gt; &#13;
        &lt;/div&gt; &#13;
      } &#13;
 &#13;
    } &#13;
</pre><p>This UI template will create the following HTML Pages:</p><p>The blank image index UI is shown in the following image:</p><p>
</p><div class="mediaobject"><img src="../Images/image00263.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The insert UI for image details looks as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00264.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The following is the image index UI with items:</p><p>
</p><div class="mediaobject"><img src="../Images/image00265.jpeg" alt="Working with views(UI)"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we have a complete working UI application. There are controllers, models, views, and simple services as well. We also have all validations in place.</p></div>
<div class="section" title="Summary" id="aid-1O8H61"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create controllers, models, services, views (using Twirl templating), Guice injections, and routing. We covered the principles of Scala Web Development using the Play framework. By the end of the chapter, we got the application with the Play framework up and running.</p><p>In the next chapter, we will learn more about services. As you may realize, we did some simple services in this chapter for products, reviews, and images, but now we will continue working with services.</p></div></body></html>