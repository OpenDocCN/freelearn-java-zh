<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java CPU Profiling and Memory Tracking</h1>
                
            
            <article>
                
<p class="calibre3">In the previous chapter, we learned how to use the JMS (Java Messaging Service) APIs to write asynchronous applications. In this chapter, we will learn about some of the techniques and tools used to profile Java applications. Enterprise applications tend to be quite complex and big. There could be situations where the application does not perform as per your requirements or expectations. For example, some of the operations performed in the application might be taking too long or consuming more memory than you expected. Furthermore, debugging performance and memory issues can sometimes become very difficult.</p>
<p class="calibre3">Fortunately, there are tools available, both in JDK and Eclipse, to help us debug these issues. JDK 6 (update 7) and above are bundled with the <strong class="calibre5">jVisualVM</strong> application that can connect to remote or local applications. You can find this tool in the <kbd class="calibre13">&lt;JDK_HOME&gt;/bin</kbd> folder. jVisualVM can help you profile memory and CPU usage. It can also be configured to launch from Eclipse when an application is run from Eclipse. We will learn how to use VisualVM to profile Java applications in this chapter. You can find detailed information about jVisualVM/VisualVM at <a href="https://visualvm.github.io/" class="calibre9">https://visualvm.github.io/</a>.</p>
<p class="calibre3">We will create a small standalone Java application to simulate performance and memory issues, and will see how to use VisualVM for troubleshooting. Although the real applications that you may want to troubleshoot will be a lot more complex, the techniques that we will learn in this chapter can be used for complex applications too.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">CPU and memory profiling using VisualVM</li>
<li class="calibre11">Techniques to detect memory leaks and deadlocks</li>
<li class="calibre11">Using the Eclipse Memory Analyzer to analyze heap dumps created from VisualVM</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a sample Java project for profiling</h1>
                
            
            <article>
                
<p class="calibre3">We will create a simple standalone Java application so that it is easy for you to learn how to profile using VisualVM. Although it will be a standalone application, we will create classes that are similar to those we created for the <kbd class="calibre13">CourseManagement</kbd> web application in some of the previous chapters, particularly <kbd class="calibre13">CourseDTO</kbd>, <kbd class="calibre13">CourseBean</kbd> (JSP bean), <kbd class="calibre13">CourseService</kbd> (service bean), and <kbd class="calibre13">CourseDAO</kbd> (for database access).</p>
<ol class="calibre14">
<li value="1" class="calibre11">Create a standard Java project in Eclipse, named <kbd class="calibre13">CourseManagementStandalone</kbd>. Create the <kbd class="calibre13">CourseDTO</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.profile.dto</kbd> package:</li>
</ol>
<pre class="calibre35">package packt.jee.eclipse.profile.dto; 
 
public class CourseDTO { 
  private int id; 
  private String name; 
  private int credits; 
 
  //skipped Getters and Setters 
} </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Create the <kbd class="calibre13">CourseDAO</kbd> class in the <kbd class="calibre13">packt.jee.eclopse.profile.dao</kbd> package:</li>
</ol>
<pre class="calibre35">//skipped imports 
public class CourseDAO { 
 
  public List&lt;CourseDTO&gt; getCourses() { 
    //No real database access takes place here 
    //We will just simulate a long-running database operation 
 
    try { 
      Thread.sleep(2000); //wait 2 seconds 
    } catch (InterruptedException e) { 
      e.printStackTrace(); 
    } 
 
    //return dummy/empty list 
    return new ArrayList&lt;&gt;(); 
  } 
} </pre>
<p class="mce-root2">We have simulated a long-running database operation in the <kbd class="calibre13">getCourses</kbd> method by making the thread sleep for a few seconds.</p>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Create the <kbd class="calibre13">CourseService</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.profile.service</kbd> package:</li>
</ol>
<pre class="calibre35">//skipped imports 
public class CourseService { 
 
  private CourseDAO courseDAO = new CourseDAO(); 
 
 
  public List&lt;CourseDTO&gt; getCourses() { 
    return courseDAO.getCourses(); 
  } 
} </pre>
<p class="mce-root2"><kbd class="calibre13">CourseService.getCourses</kbd> delegates the call to <kbd class="calibre13">CourseDAO</kbd>.</p>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Create the <kbd class="calibre13">CourseBean</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.profile.bean</kbd> package:</li>
</ol>
<pre class="calibre35">//skipped imports 
public class CourseBean { 
  private CourseService courseService = new CourseService(); 
   
  public List&lt;CourseDTO&gt; getCourses() { 
    return courseService.getCourses(); 
  } 
} </pre>
<p class="mce-root2"><kbd class="calibre13">CourseBean.getcourses</kbd> delegates to <kbd class="calibre13">CourseService</kbd>.</p>
<ol start="5" class="calibre14">
<li value="5" class="calibre11">Finally, create the <kbd class="calibre13">CourseManagement</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.profile</kbd> package. This class contains the <kbd class="calibre13">main</kbd> method and starts the loop to call the <kbd class="calibre13">getCourses</kbd> method repeatedly after reading any character from the standard input:</li>
</ol>
<pre class="calibre35">//skipped imports 
public class CourseManagement { 
 
  public static void main(String[] args) throws IOException { 
 
    CourseBean courseBean = new CourseBean(); 
 
    System.out.println("Type any character to get courses. Type q <br class="title-page-name"/>     to quit."); 
 
    int ch; 
    while ((ch = System.in.read()) != -1) { 
      if (ch != 10 &amp;&amp; ch != 13) { //ignore new lines 
        if (ch == 'q') //quit if user types q 
          break; 
 
        System.out.println("Getting courses"); 
        List&lt;CourseDTO&gt; courses = courseBean.getCourses(); 
        System.out.println("Got courses"); 
 
        System.out.println("Type any character to get courses. <br class="title-page-name"/>         Type q to quit."); 
      } 
    } 
 
    System.out.println("Quitting ..."); 
  } 
} </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Run the application (right-click on the file and select <span>Run </span><span>As</span> | <span>Java Application</span>).<br class="title-page-name"/>
In the console window, type any character and press <em class="calibre2"><span>Enter</span></em>. You should see the <span>Getting courses</span> and <span>Got courses</span> messages.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Profiling the Java application</h1>
                
            
            <article>
                
<ol class="calibre14">
<li value="1" class="calibre11">Run jvisualvm from the <kbd class="calibre13">&lt;JDK_HOME&gt;/bin</kbd> folder:</li>
</ol>
<div class="mce-root1"><img src="../images/00210.jpeg" class="calibre223"/></div>
<div class="packt_figure1">Figure 11.1: Java VisualVM profiler</div>
<p class="mce-root2">VisualVM lists all the Java processes that can be profiled by it on the local machine under the <span class="calibre12">Local</span> node. You can see VisualVM itself listed along with Eclipse.</p>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Once you run the <kbd class="calibre13">CourseManagement</kbd> application, the process should also show up under <span>Local</span>:</li>
</ol>
<div class="mce-root1"><img src="../images/00211.jpeg" class="calibre224"/></div>
<div class="packt_figure1">Figure 11.2: The CourseManagement application available for profiling</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Double-click on the process (or right-click and select <span>Open</span>). Then, go to the <span>Profile</span> tab and click on the <span>CPU</span> button:</li>
</ol>
<div class="mce-root1"><img src="../images/00212.jpeg" class="calibre225"/></div>
<div class="packt_figure1">Figure 11.3: VisualVM Profiler tab</div>
<p class="mce-root2">You should see the status set as <span class="calibre12">profiling running</span>.</p>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">After starting CPU profiling, if you get an error such as <span>Redefinition failed with error 62</span>, try running the application with the <kbd class="calibre13">-XVerify:none</kbd> parameter. In Eclipse, select the <span>Run</span> | <span>Run </span><span>Configurations</span> menu and then select the <span>CourseManagement</span> application under the <span>Java Application</span> group. Go to the <span>Arguments</span> tab and add <kbd class="calibre13">-Xverify:none</kbd> to <span>VM arguments</span>. Run the application again.</li>
<li value="5" class="calibre11">In the VisualVM <span>Profiler</span> page, click on the <span>Settings</span> checkbox to see the packages included for profiling. Note that VisualVM selects these packages automatically:</li>
</ol>
<div class="mce-root1"><img src="../images/00213.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.4: VisualVM Profiler settings</div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">You must stop CPU profiling to edit the settings. However, we will retain the default settings. Uncheck the <span>Settings</span> box to hide the settings.</li>
<li value="7" class="calibre11">Click on the <span>Monitor</span> table for the overview of profiling activities:</li>
</ol>
<div class="mce-root1"><img src="../images/00214.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.5: Overview of profiling activities</div>
<ol start="8" class="calibre14">
<li value="8" class="calibre11">Now, let's execute the <kbd class="calibre13">getCourse</kbd> method in our application. Go to the console view of Eclipse in which our application is running, type a character (other than <kbd class="calibre13">q</kbd>), and hit <em class="calibre2"><span>Enter</span></em>. Go to the <span>Profiler</span> tab of VisualVM to view the profiled data:</li>
</ol>
<div class="mce-root1"><img src="../images/00215.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.6: CPU profiling of CourseManagement</div>
<p class="mce-root2">Observe the <span class="calibre12">Self time</span> column. This indicates the CPU time or the elapsed time to execute the corresponding method, excluding the time taken to execute other methods called from this method. In our case, <kbd class="calibre13">CourseDAO.getCourses</kbd> took the maximum time, so it is at the top of the list. This report could help you identify the bottlenecks in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Identifying resource contention</h1>
                
            
            <article>
                
<p class="calibre3">In a multithreaded application, it is typical for threads to lock or wait for a lock. The thread dump can be used for identifying resource contentions. Let's simulate this scenario in our application by modifying the main method of the <kbd class="calibre13">CourseManagement</kbd> class to call <kbd class="calibre13">courseBean.getCourses</kbd> in separate threads:</p>
<pre class="calibre25">public class CourseManagement { 
 
  public static void main(String[] args) throws IOException { 
 
    final CourseBean courseBean = new CourseBean(); 
 
    System.out.println("Type any character to get courses. Type q <br class="title-page-name"/>     to quit."); 
 
    int ch, threadIndex = 0; 
    while ((ch = System.in.read()) != -1) { 
      if (ch != 10 &amp;&amp; ch != 13) { //ignore new lines 
        if (ch == 'q') //quit if user types q 
          break; 
 
        threadIndex++; //used for naming the thread 
        Thread getCourseThread = new Thread("getCourseThread" + <br class="title-page-name"/>         threadIndex) 
{ 
 
          @Override 
          public void run() { 
            System.out.println("Getting courses"); 
            courseBean.getCourses(); 
            System.out.println("Got courses"); 
          } 
        }; 
 
        //Set this thread as Daemon so that the application can exit 
        //immediately when user enters 'q' 
        getCourseThread.setDaemon(true); 
 
        getCourseThread.start();  
 
        System.out.println("Type any character to get courses. <br class="title-page-name"/>         Type q to quit."); 
      } 
    } 
 
    System.out.println("Quitting ..."); 
  } 
} </pre>
<p class="calibre3">Note that we create a new <kbd class="calibre13">Thread</kbd> object in the <kbd class="calibre13">while</kbd> loop and call <kbd class="calibre13">courseBean.getCourses</kbd> in the <kbd class="calibre13">run</kbd> method of the thread. The <kbd class="calibre13">while</kbd> loop does not wait for <kbd class="calibre13">getCourses</kbd> to return results and can process the next user input immediately. This will allow us to simulate resource contention.</p>
<p class="calibre3">To actually cause resource contention, let's synchronize <kbd class="calibre13">CourseService.getCourses</kbd>:</p>
<pre class="calibre25">public class CourseService { 
 
  private CourseDAO courseDAO = new CourseDAO(); 
 
  public synchronized List&lt;CourseDTO&gt; getCourses() { 
    return courseDAO.getCourses(); 
  } 
 } </pre>
<p class="calibre3">The synchronized <kbd class="calibre13">getCourses</kbd> method will result in only one thread executing this method in an instance of the <kbd class="calibre13">CourseService</kbd> class. We can now trigger multiple <kbd class="calibre13">getCourses</kbd> calls simultaneously by typing characters in the console without waiting for the previous calls to the <kbd class="calibre13">getCourse</kbd> method to return. To give us more time to get the thread dump, let's increase the thread sleep time in <kbd class="calibre13">CourseDAO.getCourses</kbd> to, say, 30 seconds:</p>
<pre class="calibre25">public class CourseDAO { 
 
  public List&lt;CourseDTO&gt; getCourses() { 
    //No real database access takes place here. 
    //We will just simulate a long-running database operation 
 
    try { 
      Thread.sleep(30000); //wait 30 seconds 
    } catch (InterruptedException e) { 
      e.printStackTrace(); 
    } 
 
    //return dummy/empty list 
    return new ArrayList&lt;&gt;(); 
  } 
} </pre>
<p class="calibre3">Run the application and let's start monitoring this process in VisualVM. In the console window where the application is running in Eclipse, type a character and press <em class="calibre21"><span class="calibre12">Enter</span></em>. Repeat this one more time. Now, two calls to <kbd class="calibre13">getCourses</kbd> will be triggered. In VisualVM, go to the <span class="calibre12">Threads</span> tab and click on the <span class="calibre12">Thread</span><span class="calibre12">Dump</span> button. A new thread dump will be saved under the process node and will be displayed in a new tab. Look for threads starting with the <kbd class="calibre13">getCourseThread</kbd> prefix. Here is a sample thread dump of two <kbd class="calibre13">getCourseThreads</kbd>:</p>
<pre class="calibre25">"getCourseThread2" daemon prio=6 tid=0x000000001085b800 nid=0x34f8 waiting for monitor entry [0x0000000013aef000] 
   java.lang.Thread.State: BLOCKED (on object monitor) 
  at <br class="title-page-name"/> packt.jee.eclipse.profile.service.CourseService.getCourses(CourseService.java:13)  - waiting to lock &lt;0x00000007aaf57a80&gt; (a <br class="title-page-name"/> packt.jee.eclipse.profile.service.CourseService) 
  at packt.jee.eclipse.profile.bean.CourseBean.getCourses(CourseBean.java:12) 
  at packt.jee.eclipse.profile.CourseManagement$1.run(CourseManagement.java:27) 
 
   Locked ownable synchronizers: 
  - None 
 
"getCourseThread1" daemon prio=6 tid=0x000000001085a800 nid=0x2738 waiting on condition [0x000000001398f000] 
   java.lang.Thread.State: TIMED_WAITING (sleeping) 
  at java.lang.Thread.sleep(Native Method) 
  at packt.jee.eclipse.profile.dao.CourseDAO.getCourses(CourseDAO.java:15) 
  at packt.jee.eclipse.profile.service.CourseService.getCourses(CourseService.java:13) 
  - locked &lt;0x00000007aaf57a80&gt; (a packt.jee.eclipse.profile.service.CourseService) 
  at packt.jee.eclipse.profile.bean.CourseBean.getCourses(CourseBean.java:12) 
  at packt.jee.eclipse.profile.CourseManagement$1.run(CourseManagement.java:27) 
 
   Locked ownable synchronizers: 
  - None </pre>
<p class="calibre3">From the preceding thread dumps, it is clear that <kbd class="calibre13">getCourseThread2</kbd> is waiting (<kbd class="calibre13">to lock &lt;0x00000007aaf57a80&gt;</kbd>) and that <kbd class="calibre13">getCourseThread1</kbd> is holding lock on the same object (<kbd class="calibre13">locked &lt;0x00000007aaf57a80&gt;</kbd>).</p>
<p class="calibre3">Using the same technique (of inspecting locks), you can also detect deadlocks in the application. In fact, VisualVM can detect deadlocks and explicitly point to threads that are deadlocked. Let's modify the <kbd class="calibre13">main</kbd> method in the <kbd class="calibre13">CourseManagement</kbd> class to cause a deadlock. We will create two threads and make them lock two objects in the reverse order:</p>
<div class="packt_infobox"><br class="calibre26"/>
<span class="calibre23">Warning</span><br class="calibre26"/>
The following code will cause the application to hang. You will have to kill the process to exit.</div>
<pre class="calibre25">  public static void main(String[] args) throws IOException { 
 
    System.out.println("Type any character and Enter to cause <br class="title-page-name"/>     deadlock - "); 
    System.in.read(); 
 
    final Object obj1 = new Object(), obj2 = new Object(); 
 
    Thread th1 = new Thread("MyThread1") { 
      public void run() { 
        synchronized (obj1) { 
          try { 
            sleep(2000); 
          } catch (InterruptedException e) { 
            e.printStackTrace(); 
          } 
 
          synchronized (obj2) { 
            //do nothing 
          } 
        } 
      } 
    }; 
 
    Thread th2 = new Thread("MyThread2") { 
      public void run() { 
        synchronized (obj2) { 
          try { 
            sleep(2000); 
          } catch (InterruptedException e) { 
            e.printStackTrace(); 
          } 
 
          synchronized (obj1) { 
 
          } 
        } 
      } 
    }; 
 
 
    th1.start(); 
    th2.start(); </pre>
<p class="calibre3"><kbd class="calibre13">MyThread1</kbd> first locks <kbd class="calibre13">obj1</kbd> and then it tries to lock <kbd class="calibre13">obj2</kbd>, whereas <kbd class="calibre13">MyThread2</kbd><br class="calibre6"/>
locks <kbd class="calibre13">obj2</kbd> first and then tries to lock <kbd class="calibre13">obj1</kbd>. When you monitor this application using VisualVM and switch to the <span class="calibre12">Threads</span> tab, you will see the <span class="calibre12">Deadlock detected!</span> message:</p>
<div class="mce-root1"><img src="../images/00216.jpeg" class="calibre226"/></div>
<div class="packt_figure1">Figure 11.7: Detecting deadlock with VisualVM</div>
<p class="calibre3">If you take the thread dump, it will specifically show you where the deadlock is caused:</p>
<pre class="calibre25">Found one Java-level deadlock: 
============================= 
"MyThread2": 
  waiting to lock monitor 0x000000000f6f71a8 (object <br class="title-page-name"/> 0x00000007aaf56538, a java.lang.Object), 
  which is held by "MyThread1" 
"MyThread1": 
  waiting to lock monitor 0x000000000f6f4a78 (object <br class="title-page-name"/> 0x00000007aaf56548, a java.lang.Object), 
  which is held by "MyThread2" </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Memory tracking</h1>
                
            
            <article>
                
<p class="calibre3">VisualVM can be used to monitor memory allocations and detect possible memory leaks. Let's modify our application to simulate a large memory allocation that has not been released. We will modify the <kbd class="calibre13">CourseService</kbd> class:</p>
<pre class="calibre25">public class CourseService { 
 
  private CourseDAO courseDAO = new CourseDAO(); 
 
  //Dummy cached data used only to simulate large 
  //memory allocation 
  private byte[] cachedData = null; 
 
  public synchronized List&lt;CourseDTO&gt; getCourses() { 
 
    //To simulate large memory allocation, 
    //let's assume we are reading serialized cached data 
    //and storing it in the cachedData member 
    try { 
      this.cachedData = generateDummyCachedData(); 
    } catch (IOException e) { 
      //ignore 
    } 
 
    return courseDAO.getCourses(); 
  } 
 
  private byte[] generateDummyCachedData() throws IOException { 
    ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); 
    byte[] dummyData = "Dummy cached data".getBytes(); 
 
    //write 100000 times 
    for (int i = 0; i &lt; 100000; i++) 
      byteStream.write(dummyData); 
 
    byte[] result = byteStream.toByteArray(); 
    byteStream.close(); 
    return result; 
  } 
 } </pre>
<p class="calibre3">In the <kbd class="calibre13">getCourses</kbd> method, we will create a large byte array and store it in a member variable. The memory allocated to the array will not be released until the instance of <kbd class="calibre13">CourseService</kbd> is not garbage collected. Now, let's see how this memory allocation shows up in VisualVM. Start monitoring the process and go to the <span class="calibre12">Profiler</span> tab. Click on the <span class="calibre12">Memory</span> button to start monitoring memory. Now, go back to the console window in Eclipse and enter a character to trigger the <kbd class="calibre13">getCourses</kbd> method. Go to VisualVM to inspect the memory profiling report:</p>
<div class="mce-root1"><img src="../images/00217.jpeg" class="calibre227"/></div>
<div class="packt_figure1">Figure 11.8: Memory monitoring with VisualVM</div>
<p class="calibre3">This report shows the live status of the memory consumed by different objects in the application. However, if you want to analyze and find where exactly the allocation is made, then take a heap dump. Go to the <span class="calibre12">Monitor</span> tab and click on the <span class="calibre12">Heap Dump</span> button. The heap dump report is saved under the process node. Click on the <span class="calibre12">Classes</span> button in the heap dump report, and then click on the <span class="calibre12">Size</span> column to sort objects in descending order of the amount of memory consumed:</p>
<div class="mce-root1"><img src="../images/00218.jpeg" class="calibre228"/></div>
<div class="packt_figure1">Figure 11.9: Classes in the heap dump report</div>
<p class="calibre3">According to the report, <kbd class="calibre13">byte[]</kbd> takes up the maximum memory in our application. To find where the memory is allocated, double-click on the row containing <kbd class="calibre13">byte[]</kbd>:</p>
<div class="mce-root1"><img src="../images/00219.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.10: Object instance report in heap dump</div>
<p class="calibre3">The references window at the bottom-right shows objects holding a reference to the selected instance in the top-left window. As you can see, a reference to <kbd class="calibre13">byte[]</kbd> is held by the <kbd class="calibre13">cachedData</kbd> field of <kbd class="calibre13">CourseServe</kbd>. Furthermore, a reference to <kbd class="calibre13">CourseService</kbd> is held by <kbd class="calibre13">CourseBean</kbd>.</p>
<p class="calibre3">Large memory allocation does not necessarily mean a memory leak. You may want to keep a reference to a large object in your application. However, the heap dump can help you find where the memory was allocated and if that instance is intended to be in the memory. If not, you could find where the memory was allocated and release it at the appropriate place.</p>
<p class="calibre3">The heap dump that we have taken will be lost if we restart VisualVM. Therefore, save it to the disk; to do so, right-click on the <span class="calibre12">Heap Dump</span> node and select <span class="calibre12">Save As</span>. We will use this heap dump in the Eclipse Memory Analyzer in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Eclipse plugins for profiling memory</h1>
                
            
            <article>
                
<p class="calibre3">The Eclipse Memory Analyzer (<a href="https://eclipse.org/mat/" class="calibre9"><span>https://eclipse.org/mat/</span></a>) can be used to analyze heap dumps created by VisualVM. It provides additional features such as auto memory leak detection. Furthermore, by using it as an Eclipse plugin, you can quickly jump to the source code from the heap dump reports. You can use this tool either as a standalone application or as an Eclipse plugin. We will see how to use it as an Eclipse plugin in this section.</p>
<p class="calibre3">To install the Memory Analyzer plugin and analyze the memory dump, perform the following steps:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Open <span>Eclipse Marketplace</span> (select the <span>Help</span> | <span>Eclipse Marketplace</span> menu). Search for <kbd class="calibre13">Memory Analyzer</kbd> and install the plugin:</li>
</ol>
<div class="mce-root1"><img src="../images/00220.jpeg" class="calibre229"/></div>
<div class="packt_figure1">Figure 11.11: Searching for the Memory Analyzer plugin in Eclipse Marketplace</div>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Open the heap dump that you saved in the previous section. Select the <span>File</span> | <span>Open File</span> menu and select the <kbd class="calibre13">.hprof</kbd> file that has been saved by VisualVM. Memory Analyzer will prompt you to select a report type:</li>
</ol>
<div class="mce-root1"><img src="../images/00221.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.12: Eclipse Memory Analyzer: Getting Started Wizard</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Select <span>Leak Suspects Report</span> and click on <span>Finish</span>. The Eclipse Memory Analyzer creates the <span>Leak Suspects</span> report with a couple of <span>Problem Suspects</span>:</li>
</ol>
<div class="mce-root1"><img src="../images/00222.jpeg" class="calibre230"/></div>
<div class="packt_figure1">Figure 11.13: Eclipse Memory Analyzer: Leak Suspect report</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Click on the <span>Details</span> link in the first <span>Problem Suspect</span>:</li>
</ol>
<div class="mce-root1"><img src="../images/00223.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 11.14: Eclipse Memory Analyzer: Details of Problem Suspect</div>
<p class="mce-root2">The report clearly identifies <kbd class="calibre13">cachedData</kbd> in <kbd class="calibre13">CourseService</kbd> as a leak suspect. To open the source file, click on the node and select the <span class="calibre12">Open Source File</span> option.</p>
<div class="packt_infobox"><br class="calibre26"/>
Memory Analyzer also provides many other useful reports. Refer to <a href="http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html" class="calibre17">http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</a> for more details.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">The VisualVM tool that is shipped with JDK 6 and above is useful for detecting performance bottlenecks and memory leaks.</p>
<p class="calibre3">In this chapter, we learned how to use this tool in a simple Java application. However, the technique can be used in large applications too. The Eclipse Memory Analyzer can be used to quickly detect memory leaks from a heap dump. In the next chapter we will learn how to develop Microservices in JEE.</p>


            </article>

            
        </section>
    </body></html>