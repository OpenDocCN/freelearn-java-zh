- en: Module Resolution, Readability, and Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we significantly enhanced the address book viewer application
    by leveraging multiple platform APIs to add extra functionality. We implemented
    logging, XML parsing, and a UI module using JavaFX. The address book viewer application
    has come a long way from its simple *Hello world* origins. And in the process,
    you have acquired a good amount of knowledge about the Java module system and
    you should have the required know-how and tools to build any Java application
    of similar complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you will be learning in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll be introduced to two important concepts and related terminologies--readability
    and accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn some of the nuances about what makes modules readable and packages
    accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn some powerful new ways to tweak the default methods of specifying
    dependencies--implicit dependencies and qualified exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll then apply these two new ways in the address book viewer application
    to tweak and optimize the dependencies using aggregator modules and qualified
    exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll do a significant deep-dive on some of the concepts we've
    learned only at a high level along the way. While you can use everything we've
    covered so far to build various different applications, there are certain nuances
    to several of the topics covered that will be helpful to learn and understand.
    Knowing about these concepts will help you use the module system in powerful new
    ways. In addition, some of the terminologies we'll learn in this chapter will
    help you understand and describe concepts and processes that run under the hood
    every time you use the module system.
  prefs: []
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readability is an important concept in modularity and it describes how modules
    work with each other. We've been using module dependencies to have one module
    require another module and use its APIs. Whenever a module depends on another
    module, the first module is said to read the second module. Also, the second module
    is said to be readable by the first. When a module reads another module, it has
    access to the types exported by the second module. In other words, the readability
    relationship between two modules is the arrow in the module graph that we've seen
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the address book viewer application, the module `packt.addressbook` *reads *`packt.sortutil`,
    `packt.contact`, and `java.logging`. That's because it `requires` those modules
    in the module descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example. The following diagram shows the relationships between
    three modules **A**, **B**, and **C**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Module A** requires **module B**. So, **module A** *reads* **module B**.
    **Module B** is *readable* by **module A**. **Module C** also *reads* **module
    B**. However, **module C** does not read **module A** and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell, the *reads* relationship is not symmetric. If **module A**
    *reads* **module B**, it does not mean that **module B** reads **module A**. In
    fact, in the Java module system, we can guarantee that the *reads* relationship
    between modules is asymmetric. Why? Because if two modules *read* each other,
    what we'll end up with is a cyclic dependency, which is not allowed (see [Chapter
    5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb), *Using Platform APIs*).
    So to summarize, firstly, the *readability* relationship is established through
    the usage of the `requires` clause. Secondly, if a module *reads* another module,
    we can guarantee that the second module does not *read* the first module.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, two exceptions to this, and you can probably guess what
    they are, since we've already covered them. First, every module *reads* the `java.base`
    module. And this dependency is *automatic* and there's no explicit usage of the
    `requires` qualifier. Secondly, every module *reads* itself by definition, because
    a module automatically has access to all the public types in the module by default.
  prefs: []
  type: TYPE_NORMAL
- en: The readability relationship is fundamental to achieving one of the two primary
    goals of the Java module system--reliable configuration. We want to be able to
    reliably guarantee that the dependencies of all the modules in an application
    are satisfied. An additional advantage that we'll see more over time is the performance
    optimization of these formal modular relationships. No longer does the runtime
    need to scan the entire class path to find a given type. There are ways in which
    the runtime can optimally find the right module and thus the location to find
    types. This is a huge win!
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessibility is the other side of the Java modularity coin. If the *readability*
    relationship specifies what modules can read a given module, *accessibility* indicates
    what they actually do get when they read it. Not everything in a module is accessible
    to the other modules that read it. Only the public types in packages that are
    marked with an `exports` declaration are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, for a type in module B to be *accessible* in module A, the following
    needs to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Module A needs to *read* module B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module B needs to export the package that contains the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type itself should be `public`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example and examine the readability and accessibility relationships.
    Consider two modules, `app` and `lib`. Module `app` has a `requires` qualifier
    for module `lib`. Module `lib` exports its package `lib.external`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say the `lib` module has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It has two packages--`lib.external` and `lib.internal`. Both packages contain
    one public interface and one package-private implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The implementation classes in this example don''t have the `public` keyword
    in the class declaration, which makes them visible only in the same package. They
    have the *default* package-private access level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Does module `app` read module `lib`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This one should be simple. The answer is yes, because of the `requires` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Does module `lib` read module `app`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The answer is no. Hopefully equally simple!
  prefs: []
  type: TYPE_NORMAL
- en: Is the type `LibApi` in module `lib` *accessible* to module `app`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's verify the two requirements for accessibility. Is the type `public`? Yes.
    Is the type in a package that's exported by the module? Yes. So, the answer is
    `LibApi` *is* accessible to module `app`.
  prefs: []
  type: TYPE_NORMAL
- en: Is the type `InternalService` in module `lib` *accessible* to module `app`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Because even though the type is `public`, it belongs to a package that is
    not exported in the module definition of the `lib` module. The type `InternalImpl`
    is also not accessible to the `app` module.
  prefs: []
  type: TYPE_NORMAL
- en: Is the type `LibApiImpl` in module `lib` *accessible* to module `app`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The answer is no, because it fails the requirement--is the type public? Since `LibApiImpl` is
    package-private, it is not accessible outside the module, since it's not `public`.
    This is true even though the type belongs to an exported package. This scenario
    is, however, more interesting with a couple of important lessons we can learn
    from it. Let's look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Interface and implementation accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does it mean for an interface to be accessible to a module in Java 9? Quite
    obviously, it means that you can use the interface type in the code in that module.
    However, an interface is quite meaningless without an implementation. Does this
    mean that when you export a public interface (as in `LibApi`), but not the implementation
    (`LibApiImpl`), the implementation is essentially useless outside the module?
    Not quite!
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider we add a static method in the `LibApi` interface to create an instance
    of `LibApiImpl`. We''ll also add a handy `testMethod()` to the interface for us
    to call from another module to verify if it works. Notice that while the `createInstance`
    method is creating a new instance of `LibApiImpl`, its return type is the interface,
    and not the implementation. This is important, as we''ll see in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build a simple implementation class that prints a message to the console.
    Note the missing `public` keyword in front of the class declaration. This means
    that this class is package-private, not `public`. So, even though it''s in the
    package that''s exported by the module, it''s not *accessible* outside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we access these types outside the `lib` module? Let''s find
    out! Let''s create a class `App.java` in the module `app`. Let''s first try creating
    an instance of `LibApiImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we compile this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just as we thought. The package-private class isn't accessible, even though
    it's in the exported package. How about we use the interface to get its instance?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are now using the `createInstance()` method of the interface `LibApi` to
    create an instance of `LibApi`. It then calls `testMethod` on that instance. We
    know that `LibApi` is creating a new instance of `LibApiImpl`, and we know that
    that class is not accessible. Will this work now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It does! Since we are not referring to the type `LibApiImpl` directly in the
    code, the compiler and runtime are perfectly happy to allow access to the instance
    through the interface. This is a valuable pattern in modules, as this lets you
    provide APIs that are public while still managing to change and rewrite the implementation
    underneath. This applies not just for non-public implementation classes in an
    exported package (as in this case); it also applies to public types sitting in
    packages that are *not* exported, thereby being equally inaccessible. So, let's
    revisit the question. Is the `LibApiImpl` accessible outside the module now? The
    answer is still no. However, the important lesson here is that the accessibility
    rules apply to usage of types and do not apply to dynamic instances of types at
    runtime. This is by design and is a great pattern to use to achieve implementation-level
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Split packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a question that some of you might be asking already. The `LibApiImpl`
    class is package-private. So, there''s no way it is accessible to a type outside
    the `packt.lib.external` package it is in. So, our attempt to access the type
    in `packt.app.App`, a completely different package, was bound to fail anyway!
    In fact, it would have failed even in Java 8 or earlier! How about if we try to
    access it from the same package in another module? If we were to create the same
    package `packt.lib.external` in the `app` module and create a new class there,
    would *that* class be able to access `LibApiImpl`? In this scenario, the consuming
    class is in the same package. Let''s give it a try! You don''t have to go too
    far. Just creating the same package from one module into another module doesn''t
    work. Let''s say you recreate the package in the `app` module and add any arbitrary
    Java type in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not even using `LibApiImpl` here! We''ve just used the same package
    in another module. The compilation step will fail with the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Yes! A package cannot exist in two modules at the same time. Well, not in two
    observable modules, at least! In other words, given a package in an application,
    it should be a part of one and only one module on the module path!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a significant deviation from how we''ve traditionally thought of libraries
    in Java. Having come this far, I don''t have to highlight that modules are different
    from traditional JAR libraries. But here is yet another aspect that breaks the
    traditional *library* paradigm. Traditionally, multiple jars in the class path
    can contain the same package. We''ve seen this figure already in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With modules not allowing *sharing* of packages, or *split packages* as they''re
    often called, we now end up with a new hierarchy. Modules at the top, packages
    under them, and then types under packages, as shown in the following diagram with
    a couple of example modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This now results in another change to the way we think about packages. Packages
    are not grouping of types in the entire application anymore. Packages are grouping
    of types only inside a single module. When you create a package, you are *forced*
    to choose which module the types should all be in. One advantage of this approach,
    if we design our packages well, is clearer organization. There are also performance
    optimizations. The Java class loader internally maps each package to a single
    module, so when it's looking up types to load, it immediately knows where (and
    in which module) to find a given type.
  prefs: []
  type: TYPE_NORMAL
- en: This restriction of avoiding split packages will come back to be a bitter pain
    in the neck when migrating legacy Java codebases to Java 9 modules which we'll
    cover in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*. Also note that there are ways to bypass this
    restriction by using multiple class loaders, but that's beyond the scope of what
    we are covering here.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at two language constructs you can use in the module descriptor--*requiring*
    modules and *exporting* packages. Together, they give you sufficient control over
    the interface of your modules and they address the two main goals of modularity--reliable
    configuration and strong encapsulation. However, in many real-world situations,
    you might sometimes find that these two alone are not enough to achieve certain
    things you want to do. For example, you may want to `export` a package from a
    module, only for it to be consumed by a certain other module, and not for public
    consumption. To handle many such special cases, the module system has some powerful
    features that we'll take a look at in this part of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implied readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We looked at the problem of dependency leakage in [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Platform APIs*. The module that you depend on might have APIs that might
    also require you to use another module. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The module A  `requires` module B, which in turn `requires` C. We know that
    with this, A does not read C, since module dependencies are not *transitive* in
    nature. But what if it needs to? For instance, if B has an API whose return type
    is in module C.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example can be found in the platform module itself. Let''s say you write
    your custom module that reads `java.sql`. And you''d like to use the `Driver`
    interface from the module. The `Driver` interface has a method called `getParentLogger()`
    that returns the type `Logger`. Here''s what the method in the `Driver` interface
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s your code in your custom module that calls the API from `java.sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To get this to work, you just need to add requires `java.sql` in your module
    definition, and you should be good to go, right? Not so fast! Think about the
    return type `Logger`. That type is actually coming from `java.logging`, like we've
    already seen. The `java.sql` module depends on `java.logging` for logging capabilities,
    so it isn't a problem for *that* module. But how about yours?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since `yourmodule` does not directly require `java.logging`, in order to use
    the `java.sql` API, you'd have to `require` the `java.logging` module too!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can tell, this is not very convenient. If the usage of a certain module
    requires the use of other modules too, it just adds to the complexity of the API.
    Here, you'd need to have some documentation for the developers that says, *If
    you happen to use java.sql, don't forget to also require java.logging*.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a better way? Although dependencies aren't transitive by default, what
    we'd like is the ability to selectively make only certain dependencies transitively
    available, for situations like this. Thankfully, this is possible in Java 9 by
    using the `transitive` keyword. When you declare `requires` on a module, you can
    also have that module be available and readable to any modules that depend on
    your module. The way to use this feature is like this--`requires transitive <module-name>;`
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, module A requires B. But module B *requires transitive
    C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, module C is readable by not only module B, but by all other modules that
    read module B. So here, A gets to read C too!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `transitive` keyword is adding an additional semantic to the
    `requires` keyword. The line `requires transitive C` now makes C readable by all
    modules that read B, while at the same time retaining the meaning of `requires`
    that we've known all along--that B needs to read C too!
  prefs: []
  type: TYPE_NORMAL
- en: How does this affect the *readability* relationship we have just discussed?
    We know that A *reads* B because of the explicit `requires` relationship? But
    does A *read* C as well? The answer is yes, and this kind of readability relationship
    is referred to as *implied readability*. The relationship is not *explicit*, since
    there's no direct dependency declared by A on C. The readability is implied due
    to its transitive nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is leveraged in the `java.sql` module to solve the problem with
    the `Logger` return type. If you run `java -d` on `java.sql`, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the two modules `java.xml` and `java.logging` that `java.sql` requires
    are both marked `transitive`. Like we''ve just seen, this means that any module
    that requires `java.sql` *will* get access to the APIs in `java.xml` and `java.logging`
    automatically! This is a decision taken by the platform team because using many
    of the APIs in `java.sql` requires the use of the other two modules as well. So
    rather than having all the developers remember to `require` those too, the platform
    has made it *automatic*. This is why any module that depends on `java.sql` and
    calls the `Driver.getParentLogger()` will have no problems using the `Logger`
    type, since that module will have an implied readability on `java.logging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you need to be cautious about adding a lot of transitive dependencies
    in your modules. I mentioned dependency leakage in [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Platform APIs*, and how it's better to have all of your module's dependencies
    restricted in usage in your module. Any usage of APIs that the module exposes
    should only need to deal with types that are all exposed and available in the
    same module as well. The concept of transitive dependencies in a way seems to
    run counter to that philosophy. Thanks to `transitive`, any dependency leakages
    can be handled easily by making the modules containing the leaked types as `requires
    transitive`. But that's a slippery slope. Imagine having to depend on a module
    and inadvertently getting a dozen other module dependencies because they are all
    marked `requires transitive` in the module you need! Such module designs clearly
    violate the principles of modularity, and I highly recommend avoiding them unless
    absolutely required.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a really interesting and handy usage of transitive dependencies
    that will help library developers. That is *aggregator modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An aggregator module is a module that does not provide any functionality on
    its own, but instead, its sole purpose is to gather and bundle together a bunch
    of other modules. As the name implies, these modules *aggregate* several other
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume you have a group of your favorite library modules that you often
    use together in your applications. Let's say this is a list of some core libraries,
    and whenever you write a module, it's very likely that you'll use pretty much
    every library in that list. Now, using every module in that list in any of your
    own modules involves specifying each of those modules using the `requires` clause.
    Depending on how big that list is, it can be tedious to specify the same set of
    core dependencies in every one of your module descriptors. Even if you were to
    do that once, it's hard to change the list of core libraries, perhaps to add a
    new one. Your only option would be to go through all your module descriptors again
    and make that change. Wouldn't it be nice if you could create a new module that
    bundles all your core libraries? That way you have the list in one place and you
    don't have to specify the complete list anywhere else. Any module that needs all
    those libraries can now express a dependency to this new *module bundle*! You
    can do just that by creating an essentially *empty* module with all the dependencies
    transitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here's a module called `librarybundle` that does not really export *anything*,
    since there are no `exports` packages specified in the module descriptor. This
    module doesn't really need to contain a single Java class! What it does do, however,
    is `requires transitive` three other libraries. So, any module that depends on
    the `librarybundle` module automatically reads those three libraries too.
  prefs: []
  type: TYPE_NORMAL
- en: Java platform aggregator modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java platform has a couple of aggregator modules to represent the *complete*
    JRE, at least as we knew it in Java 8 and earlier. The `java.se` module essentially
    re-exports the entire Java SE platform. The `java.se.ee` module contains the subset
    of the platform that overlaps with Java EE and contains APIs such as web services,
    transactions, and the legacy CORBA APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `java -d` on the `java.se` module shows us how it''s implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, I hope you resist the temptation to use these aggregator modules in any
    new modules you create in your Java 9 code. You could practically throw in `requires
    java.se` in all your module definitions and not have to worry about doing any
    other `requires` ever again! But that again defeats the purpose of modularity
    and you are back to using the Java platform the way we did in Java 8 and earlier--by
    depending on the entirety of the platform APIs irrespective of what part of them
    you really need. These aggregator modules are mainly to be used for legacy code
    migration purposes, and that too as a temporary measure, in an attempt to get
    to more fine-grained dependencies eventually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `java.se.ee` module is deprecated and is not encouraged for use,
    there''s an interesting observation to be made by examining it. While `java.se.ee`
    is a super set that includes all modules in `java.se` and then some more, its
    module definition doesn''t re-declare a entire list of all the modules in the
    platform. What it does is simply require transitive the `java.se` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can use this approach in your own modules to create aggregator modules of
    other aggregator modules! Pretty powerful stuff!
  prefs: []
  type: TYPE_NORMAL
- en: Qualified exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at transitive dependencies that let us tweak
    the *readability* relationship between modules to handle some special use cases.
    In this section, you'll be introduced to a way you can tweak the *accessibility*
    relationships in some special cases. This can be done using a feature called **qualified
    exports**. Let's learn what they are.
  prefs: []
  type: TYPE_NORMAL
- en: You've already learned that the `exports` keyword lets you specify which packages
    in a module are allowed to be used outside the module. The exported packages form
    the *public contract* of the module, and any module that reads such a module automatically
    gets *accessibility* to those exported packages.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a catch here! Ideally, you'd like to design your modules and APIs
    as standalone entities and you always have a clear idea about what the modules
    should export. But you might encounter real-world scenarios where that isn't the
    case. Sometimes you'll have to design modules to make them work well with others,
    and that incurs an interesting cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that you have built a library module called **B** that is being used
    by a consumer module **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The developer of module A can obviously call the exported APIs of B now. But
    then, it so happens that they also need this one other API in module B that isn''t
    exported yet. You didn''t initially want to export that private package from module
    B because it''s not something that''s commonly needed outside B, but it turns
    out there''s just one other module, module A, that really needs it! So, to make
    the developer of module A happy, you add that private package to the `exports`
    list from module B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, a new module, module C, depends on module B. It too has an interesting
    use case where it needs another private API from module B. It''s very likely that
    it''s only C that''ll ever need that API outside of B, but in order to make module
    C work, you have no option but to add that package to the exported packages of
    module B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I hope you notice the problem already. Now two originally private packages in
    module B are now public for use by every module that reads B, although the intent
    for exporting those packages was to satisfy two very small and specific use cases.
    If this goes on, the exported APIs in your module end up being the greatest common
    set of APIs that are sure to keep every consumer module happy. In the process,
    you've lost the advantages of encapsulation. Now that an internal package is exported,
    albeit with the intention to satisfy one module, it is available for *any* module
    to use. Wouldn't it be great if when exporting packages to a module, you could
    selectively specify *which modules* the packages need to be exported to? If so,
    then only those selected modules could access those specially exported packages.
    All other modules would only get the *publicly exported *packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible using qualified exports. The `exports` clause in the module
    definition optionally lets you specify which module you need to export the package
    to. If you do that, the `export` is not public anymore. Only the module you specify
    has access to it. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this concept to our example module B, we can still have better encapsulation
    of our private packages by selectively giving modules A and C access to what they
    alone need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this change, package `moduleb.privateA` is *accessible* to A, but not to
    B or any other module that reads B. Similarly, `moduleb.privateC` is *accessible*
    only by C. Now, while the private APIs are still not fully encapsulated, you at
    least know for sure what modules they are accessed by, and so any changes are
    easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example usage of this feature in the Java platform is in the `java.base`
    module. This module contains a lot of core internal packages that have been deemed
    *internal* and that we Java developers are ideally not supposed to use. Unfortunately,
    other platform modules still need to use them, and encapsulating these internal
    packages prevents access to those platform modules too! Thus, you''ll see a lot
    of these qualified exports where the internal APIs are exported just to the platform
    modules that need them. You can run the `java -d` command on `java.base` to see
    many instances of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remember that using qualified exports is generally not recommended. The principles
    of modularity recommend that a module should not be aware of who the consumers
    are. Qualified exports, by definition, add a certain level of coupling between
    two modules. The coupling is not forced--if you have a qualified export to a certain
    module, and that module isn't even in the module path to take advantage of it,
    there are no errors. But the coupling is there nevertheless, and so it's not a
    good idea to use qualified exports unless it's absolutely required.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the concepts to address book viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned about a couple of powerful ways in which we can tweak the *default*
    behavior of module dependencies in Java 9\. Let's get hands-on now and apply some
    of these to our address book viewer application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom aggregator module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that we have two modules in the address book viewer application that
    provides a view of the address book. The `packt.addressbook` module shows a simple
    list of contacts in command line. The `packt.addressbook.ui` module shows the
    address book contacts and details in UI form. Both these modules happen to use
    the two utility modules to get the list of contacts (`packt.contact`) and to sort
    them (`sort.util`). Here, we have just two modules, so it's not that big of a
    deal to add the requires descriptor for both of these modules in two places. But
    imagine if there were many more libraries and many more consumers! You'd be duplicating
    the list multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that, let's create an aggregator module that bundles and re-exports
    the `packt.contact` and `sort.util` modules. We can then have the `packt.addressbook`
    and `packt.addressbook.ui` modules depend on the aggregator module directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the aggregator module `packt.addressbook.lib`. This module acts
    as the *library* for all `addressbook` modules. Create a directory with the name
    of the module in the `src` folder and add the following code in its module descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is actually the only file that this module would need. It doesn't provide
    any APIs of its own. It just has the module descriptor that `requires transitive`
    all the modules that it wants to re-export. Here, we choose for it to re-export
    the two custom utility modules we've created. We have the option here to add `requires
    transitive` on some of the platform modules as well, like `java.logging`. But
    we'll just stick with our custom modules for now.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to go to the consumer modules and change the direct dependencies
    to the aggregator module instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the module descriptors for the two address book modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compile and execute the two modules, and you should still see the output as
    before. Here's the updated dependency graph of our address book application now,
    excluding the platform modules. Notice that the transitive dependencies are illustrated
    with a dotted arrow to convey that while the dependency is not direct, it's still
    there!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.gif)'
  prefs: []
  type: TYPE_IMG
- en: Optimizing module imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created the GUI address viewer module that required
    the Java FX modules necessary for building the UI. Here''s what the module descriptor
    looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now see that not all the modules imported are actually required, and
    we can optimize this list a bit, thanks to our new knowledge of transitive dependencies.
    Running `java -d` on `javafx.controls` gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Turns out the `javafx.base` and `javafx.graphics` modules are transitive dependencies
    of `javafx.controls` already. So, any module that *reads *`javafx.controls` also
    *reads *`javafx.base` and `javafx.graphics`! So, we can remove those two modules
    and just declare our dependency on `javafx.controls`, since that module alone
    pulls in all the dependencies we need. Here''s the updated module descriptor for `packt.addressbook.ui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to recompile and execute the UI module to make sure things
    still work just the same.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing module exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the previous chapter, we begrudgingly added the `exports` qualifier
    for the package containing the main JavaFX class in the module descriptor for
    the `packt.addressbook.ui` module. We did this because the way the JavaFX framework
    works, it needs to be able to access the class that extends `javafx.application.Application`
    that launches the UI application. We said how that isn't an ideal solution because
    not only are we exporting the package to the JavaFX framework, we are essentially
    exporting it to the whole world, that is, any module that reads `packt.addressbook.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new knowledge of qualified exports, we have just the solution for
    this problem! Instead of exporting `packt.addressbook.ui` globally, we can use
    a qualified export in order to export it just to the JavaFX module. Here, the
    module that needs access to the class is the module `java.graphics`. We''ve removed
    the explicit dependency, although the dependency is still implicitly there! With
    the qualified export to `java.graphics`, here''s what the module descriptor looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, you should be able to compile and run the code to make sure everything
    works well. With this change, you've retained encapsulation of the `Main` class
    while still making it available to the right JavaFX framework module that needs
    access to it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a slightly better way to achieve this by using the  `opens` keyword
    if the problem is with reflective access only. We can use the concept of open
    modules. We'll be covering open modules in detail in [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Design Patterns and Strategies*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned some important concepts and terminologies related
    to modularity, including *readability* and *accessibility*. You've also learned
    how the default behavior of the module system can be tweaked for certain specialized
    needs--using implied dependencies and qualified exports. And more importantly,
    you've understood some scenarios where such needs might be required, like aggregator
    modules and certain encapsulation challenges, and how these tweaks might be useful
    in such cases. We then looked at a few places in the address book viewer application
    where these tweaks helped us optimize and simplify dependencies while improving
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about a whole new way of handling depended
    abstractions using a powerful concept in Java modularity--using services.
  prefs: []
  type: TYPE_NORMAL
