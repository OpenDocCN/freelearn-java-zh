- en: Module Resolution, Readability, and Accessibility
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块解析、可读性和可访问性
- en: In the previous chapter, we significantly enhanced the address book viewer application
    by leveraging multiple platform APIs to add extra functionality. We implemented
    logging, XML parsing, and a UI module using JavaFX. The address book viewer application
    has come a long way from its simple *Hello world* origins. And in the process,
    you have acquired a good amount of knowledge about the Java module system and
    you should have the required know-how and tools to build any Java application
    of similar complexity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过利用多个平台API来添加额外功能，显著增强了地址簿查看器应用程序。我们使用了JavaFX实现了日志记录、XML解析和UI模块。地址簿查看器应用程序已经从简单的
    *Hello world* 原始版本发展了很多。在这个过程中，你已经获得了大量关于Java模块系统的知识，你应该具备构建任何类似复杂性的Java应用程序所需的知识和工具。
- en: 'Here''s what you will be learning in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习以下内容：
- en: You'll be introduced to two important concepts and related terminologies--readability
    and accessibility
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将介绍两个重要概念及其相关术语--可读性和可访问性
- en: You'll learn some of the nuances about what makes modules readable and packages
    accessible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解一些关于使模块可读和包可访问的细微差别
- en: You'll learn some powerful new ways to tweak the default methods of specifying
    dependencies--implicit dependencies and qualified exports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习一些强大的新方法来调整指定依赖项的默认方法--隐式依赖和限定导出
- en: You'll then apply these two new ways in the address book viewer application
    to tweak and optimize the dependencies using aggregator modules and qualified
    exports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将应用这两种新方法在地址簿查看器应用程序中调整和优化依赖项，使用聚合模块和限定导出
- en: In this chapter, we'll do a significant deep-dive on some of the concepts we've
    learned only at a high level along the way. While you can use everything we've
    covered so far to build various different applications, there are certain nuances
    to several of the topics covered that will be helpful to learn and understand.
    Knowing about these concepts will help you use the module system in powerful new
    ways. In addition, some of the terminologies we'll learn in this chapter will
    help you understand and describe concepts and processes that run under the hood
    every time you use the module system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对我们在学习过程中仅以高层次了解的一些概念进行深入探讨。虽然你可以使用我们迄今为止所涵盖的一切来构建各种不同的应用程序，但了解所涵盖的某些主题的细微差别将有助于学习和理解。了解这些概念将帮助你以强大的新方式使用模块系统。此外，在本章中我们将学习的某些术语将帮助你理解和描述每次使用模块系统时在底层运行的概念和过程。
- en: Readability
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性
- en: Readability is an important concept in modularity and it describes how modules
    work with each other. We've been using module dependencies to have one module
    require another module and use its APIs. Whenever a module depends on another
    module, the first module is said to read the second module. Also, the second module
    is said to be readable by the first. When a module reads another module, it has
    access to the types exported by the second module. In other words, the readability
    relationship between two modules is the arrow in the module graph that we've seen
    so far.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性是模块化中的一个重要概念，它描述了模块如何相互协作。我们一直使用模块依赖关系，让一个模块要求另一个模块并使用其API。每当一个模块依赖于另一个模块时，第一个模块就被说成是读取第二个模块。同样，第二个模块也被说成是可被第一个模块读取。当一个模块读取另一个模块时，它有权访问第二个模块导出的类型。换句话说，两个模块之间的可读性关系是我们迄今为止所看到的模块图中的箭头。
- en: For example, in the address book viewer application, the module `packt.addressbook` *reads *`packt.sortutil`,
    `packt.contact`, and `java.logging`. That's because it `requires` those modules
    in the module descriptor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在地址簿查看器应用程序中，模块 `packt.addressbook` 读取 `packt.sortutil`、`packt.contact` 和
    `java.logging`。这是因为它在模块描述符中`requires`了这些模块。
- en: 'Consider an example. The following diagram shows the relationships between
    three modules **A**, **B**, and **C**:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子。以下图表显示了三个模块 **A**、**B** 和 **C** 之间的关系：
- en: '![](img/00053.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00053.jpeg)'
- en: '**Module A** requires **module B**. So, **module A** *reads* **module B**.
    **Module B** is *readable* by **module A**. **Module C** also *reads* **module
    B**. However, **module C** does not read **module A** and vice versa.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块A** 需要 **模块B**。因此，**模块A** 读取 **模块B**。**模块B** 可被 **模块A** 读取。**模块C** 也读取
    **模块B**。然而，**模块C** 不读取 **模块A**，反之亦然。'
- en: As you can tell, the *reads* relationship is not symmetric. If **module A**
    *reads* **module B**, it does not mean that **module B** reads **module A**. In
    fact, in the Java module system, we can guarantee that the *reads* relationship
    between modules is asymmetric. Why? Because if two modules *read* each other,
    what we'll end up with is a cyclic dependency, which is not allowed (see [Chapter
    5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb), *Using Platform APIs*).
    So to summarize, firstly, the *readability* relationship is established through
    the usage of the `requires` clause. Secondly, if a module *reads* another module,
    we can guarantee that the second module does not *read* the first module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*读取*关系不是对称的。如果**模块A***读取***模块B**，并不意味着**模块B**会读取**模块A**。实际上，在Java模块系统中，我们可以保证模块之间的*读取*关系是不对称的。为什么？因为如果两个模块相互*读取*，最终我们会得到一个循环依赖，这是不允许的（参见[第5章](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb)，*使用平台API*）。所以总结一下，首先，*可读性*关系是通过使用`requires`子句建立的。其次，如果一个模块*读取*另一个模块，我们可以保证第二个模块不会*读取*第一个模块。
- en: There are, however, two exceptions to this, and you can probably guess what
    they are, since we've already covered them. First, every module *reads* the `java.base`
    module. And this dependency is *automatic* and there's no explicit usage of the
    `requires` qualifier. Secondly, every module *reads* itself by definition, because
    a module automatically has access to all the public types in the module by default.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两个例外，你可能已经猜到了它们是什么，因为我们已经讨论过它们了。首先，每个模块都会*读取*`java.base`模块。这种依赖关系是*自动的*，没有使用`requires`限定符的显式使用。其次，每个模块根据定义都会*读取*自身，因为模块默认自动有权访问模块中的所有公共类型。
- en: The readability relationship is fundamental to achieving one of the two primary
    goals of the Java module system--reliable configuration. We want to be able to
    reliably guarantee that the dependencies of all the modules in an application
    are satisfied. An additional advantage that we'll see more over time is the performance
    optimization of these formal modular relationships. No longer does the runtime
    need to scan the entire class path to find a given type. There are ways in which
    the runtime can optimally find the right module and thus the location to find
    types. This is a huge win!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性关系对于实现Java模块系统的两个主要目标之一--可靠配置是基本的。我们希望能够可靠地保证应用程序中所有模块的依赖关系都得到满足。随着时间的推移，我们还将看到这些正式模块关系的性能优化优势。运行时不再需要扫描整个类路径来查找给定的类型。运行时可以通过某些方式最优地找到正确的模块以及找到类型的定位。这是一个巨大的胜利！
- en: Accessibility
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可访问性
- en: Accessibility is the other side of the Java modularity coin. If the *readability*
    relationship specifies what modules can read a given module, *accessibility* indicates
    what they actually do get when they read it. Not everything in a module is accessible
    to the other modules that read it. Only the public types in packages that are
    marked with an `exports` declaration are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性是Java模块化硬币的另一面。如果*可读性*关系指定了哪些模块可以读取给定模块，*可访问性*则表示它们实际读取的内容。并非模块中的所有内容都对读取它的其他模块可访问。只有标记了`exports`声明的包中的公共类型才是可访问的。
- en: 'Thus, for a type in module B to be *accessible* in module A, the following
    needs to happen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使模块B中的类型在模块A中*可访问*，需要发生以下情况：
- en: Module A needs to *read* module B
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块A需要*读取*模块B
- en: Module B needs to export the package that contains the type
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块B需要导出包含类型的包
- en: The type itself should be `public`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型本身应该是`public`
- en: 'Let''s look at an example and examine the readability and accessibility relationships.
    Consider two modules, `app` and `lib`. Module `app` has a `requires` qualifier
    for module `lib`. Module `lib` exports its package `lib.external`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，并检查可读性和可访问性关系。考虑两个模块，`app`和`lib`。模块`app`对模块`lib`有`requires`限定符。模块`lib`导出其包`lib.external`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s say the `lib` module has the following structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`lib`模块具有以下结构：
- en: '![](img/00054.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: It has two packages--`lib.external` and `lib.internal`. Both packages contain
    one public interface and one package-private implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个包--`lib.external`和`lib.internal`。这两个包都包含一个公共接口和一个包私有实现。
- en: 'Note: The implementation classes in this example don''t have the `public` keyword
    in the class declaration, which makes them visible only in the same package. They
    have the *default* package-private access level.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本例中的实现类在类声明中没有使用`public`关键字，这使得它们只能在同一包中可见。它们具有`*default*`包私有访问级别。
- en: 'Let''s try to answer the following questions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试回答以下问题：
- en: Does module `app` read module `lib`?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `app` 是否读取模块 `lib`？
- en: This one should be simple. The answer is yes, because of the `requires` qualifier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题应该很简单。答案是肯定的，因为 `requires` 限定符的存在。
- en: Does module `lib` read module `app`?
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `lib` 是否读取模块 `app`？
- en: The answer is no. Hopefully equally simple!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。希望同样简单！
- en: Is the type `LibApi` in module `lib` *accessible* to module `app`?
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `lib` 中的类型 `LibApi` 是否对模块 `app` 可访问？
- en: Let's verify the two requirements for accessibility. Is the type `public`? Yes.
    Is the type in a package that's exported by the module? Yes. So, the answer is
    `LibApi` *is* accessible to module `app`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证可访问性的两个要求。类型是 `public` 吗？是的。类型是否在模块导出定义中导出的包中？是的。所以，答案是 `LibApi` 对模块 `app`
    是可访问的。
- en: Is the type `InternalService` in module `lib` *accessible* to module `app`?
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `lib` 中的类型 `InternalService` 是否对模块 `app` 可访问？
- en: No. Because even though the type is `public`, it belongs to a package that is
    not exported in the module definition of the `lib` module. The type `InternalImpl`
    is also not accessible to the `app` module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不。尽管类型是 `public`，但它属于在 `lib` 模块的模块定义中没有导出的包。类型 `InternalImpl` 也不对 `app` 模块可访问。
- en: Is the type `LibApiImpl` in module `lib` *accessible* to module `app`?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `lib` 中的类型 `LibApiImpl` 是否对模块 `app` 可访问？
- en: The answer is no, because it fails the requirement--is the type public? Since `LibApiImpl` is
    package-private, it is not accessible outside the module, since it's not `public`.
    This is true even though the type belongs to an exported package. This scenario
    is, however, more interesting with a couple of important lessons we can learn
    from it. Let's look at them in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，因为它没有满足要求——类型是 `public` 吗？由于 `LibApiImpl` 是包私有的，它不在模块外部可访问，因为它不是 `public`。即使类型属于导出包，这也是正确的。然而，这种情况却有一些我们可以从中学习的重要经验教训。让我们详细看看它们。
- en: Interface and implementation accessibility
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和实现的可访问性
- en: What does it mean for an interface to be accessible to a module in Java 9? Quite
    obviously, it means that you can use the interface type in the code in that module.
    However, an interface is quite meaningless without an implementation. Does this
    mean that when you export a public interface (as in `LibApi`), but not the implementation
    (`LibApiImpl`), the implementation is essentially useless outside the module?
    Not quite!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，一个接口对模块可访问意味着什么？很明显，这意味着你可以在该模块的代码中使用接口类型。然而，没有实现，接口几乎没有意义。这意味着当你导出一个公共接口（如
    `LibApi`），但不导出实现（`LibApiImpl`）时，实现对于模块外部来说基本上是无用的吗？并不完全是这样！
- en: 'Consider we add a static method in the `LibApi` interface to create an instance
    of `LibApiImpl`. We''ll also add a handy `testMethod()` to the interface for us
    to call from another module to verify if it works. Notice that while the `createInstance`
    method is creating a new instance of `LibApiImpl`, its return type is the interface,
    and not the implementation. This is important, as we''ll see in a bit:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在 `LibApi` 接口中添加一个静态方法来创建 `LibApiImpl` 的实例。我们还会在接口中添加一个方便的 `testMethod()`
    方法，以便我们从另一个模块调用它来验证其是否工作。注意，当 `createInstance` 方法创建 `LibApiImpl` 的新实例时，其返回类型是接口，而不是实现。这很重要，我们稍后会看到：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s build a simple implementation class that prints a message to the console.
    Note the missing `public` keyword in front of the class declaration. This means
    that this class is package-private, not `public`. So, even though it''s in the
    package that''s exported by the module, it''s not *accessible* outside the module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的实现类，它将消息打印到控制台。注意类声明前缺少 `public` 关键字。这意味着这个类是包私有的，而不是 `public`。所以，尽管它位于由模块导出的包中，但它对模块外部不可访问：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What happens if we access these types outside the `lib` module? Let''s find
    out! Let''s create a class `App.java` in the module `app`. Let''s first try creating
    an instance of `LibApiImpl`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `lib` 模块外部访问这些类型会发生什么？让我们来看看！让我们在模块 `app` 中创建一个名为 `App.java` 的类。让我们首先尝试创建
    `LibApiImpl` 的实例：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happens if we compile this?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译这个会发生什么？
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just as we thought. The package-private class isn't accessible, even though
    it's in the exported package. How about we use the interface to get its instance?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所想。包私有的类不可访问，即使它位于导出包中。我们是否可以使用接口来获取其实例？
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are now using the `createInstance()` method of the interface `LibApi` to
    create an instance of `LibApi`. It then calls `testMethod` on that instance. We
    know that `LibApi` is creating a new instance of `LibApiImpl`, and we know that
    that class is not accessible. Will this work now?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用接口`LibApi`的`createInstance()`方法来创建`LibApi`的实例。然后在该实例上调用`testMethod`。我们知道`LibApi`正在创建一个新的`LibApiImpl`实例，我们也知道这个类是不可访问的。现在这会工作吗？
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It does! Since we are not referring to the type `LibApiImpl` directly in the
    code, the compiler and runtime are perfectly happy to allow access to the instance
    through the interface. This is a valuable pattern in modules, as this lets you
    provide APIs that are public while still managing to change and rewrite the implementation
    underneath. This applies not just for non-public implementation classes in an
    exported package (as in this case); it also applies to public types sitting in
    packages that are *not* exported, thereby being equally inaccessible. So, let's
    revisit the question. Is the `LibApiImpl` accessible outside the module now? The
    answer is still no. However, the important lesson here is that the accessibility
    rules apply to usage of types and do not apply to dynamic instances of types at
    runtime. This is by design and is a great pattern to use to achieve implementation-level
    encapsulation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实工作了！因为我们没有在代码中直接引用类型`LibApiImpl`，编译器和运行时都乐于允许通过接口访问该实例。这在模块中是一个很有价值的模式，因为它允许你提供公共API，同时仍然能够管理和重写底层的实现。这不仅适用于导出包中的非公共实现类（如本例所示）；它也适用于位于未导出包中的公共类型，因此同样不可访问。所以，让我们重新审视这个问题。现在`LibApiImpl`在模块外部可访问吗？答案是仍然不可访问。然而，这里的重要教训是，可访问性规则适用于类型的用法，并不适用于运行时类型的动态实例。这是设计的一部分，并且是一个实现级别封装的好模式。
- en: Split packages
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割包
- en: 'Here''s a question that some of you might be asking already. The `LibApiImpl`
    class is package-private. So, there''s no way it is accessible to a type outside
    the `packt.lib.external` package it is in. So, our attempt to access the type
    in `packt.app.App`, a completely different package, was bound to fail anyway!
    In fact, it would have failed even in Java 8 or earlier! How about if we try to
    access it from the same package in another module? If we were to create the same
    package `packt.lib.external` in the `app` module and create a new class there,
    would *that* class be able to access `LibApiImpl`? In this scenario, the consuming
    class is in the same package. Let''s give it a try! You don''t have to go too
    far. Just creating the same package from one module into another module doesn''t
    work. Let''s say you recreate the package in the `app` module and add any arbitrary
    Java type in it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些人可能已经提出的问题。`LibApiImpl`类是包私有的。所以，它不可能被它所在的`packt.lib.external`包外的任何类型访问。所以，我们尝试在完全不同的包`packt.app.App`中访问该类型的尝试注定会失败！实际上，即使在Java
    8或更早的版本中也会失败！如果我们尝试从另一个模块中的相同包中访问它会怎样呢？如果我们要在`app`模块中创建相同的包`packt.lib.external`并在其中创建一个新的类，那么这个类能够访问`LibApiImpl`吗？在这种情况下，消费类在同一个包中。让我们试一试！你不必走得太远。仅仅从一个模块到另一个模块创建相同的包是不行的。假设你在`app`模块中重新创建这个包，并在其中添加任何任意的Java类型：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are not even using `LibApiImpl` here! We''ve just used the same package
    in another module. The compilation step will fail with the error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里甚至没有使用`LibApiImpl`！我们只是在其他模块中使用了相同的包。编译步骤将因以下错误而失败：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Yes! A package cannot exist in two modules at the same time. Well, not in two
    observable modules, at least! In other words, given a package in an application,
    it should be a part of one and only one module on the module path!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！一个包不能同时在两个模块中存在。好吧，至少不能在两个可观察的模块中同时存在！换句话说，给定一个应用程序中的包，它应该是模块路径上仅一个模块的一部分！
- en: 'This is a significant deviation from how we''ve traditionally thought of libraries
    in Java. Having come this far, I don''t have to highlight that modules are different
    from traditional JAR libraries. But here is yet another aspect that breaks the
    traditional *library* paradigm. Traditionally, multiple jars in the class path
    can contain the same package. We''ve seen this figure already in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在Java中传统上对库的看法有显著不同。既然我们已经走到这一步，我就不必强调模块与传统JAR库的不同。但这里还有一个方面打破了传统的*库*范式。传统上，类路径中的多个JAR可以包含相同的包。我们已经在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”中看到了这个例子：
- en: '![](img/00055.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.jpeg)'
- en: 'With modules not allowing *sharing* of packages, or *split packages* as they''re
    often called, we now end up with a new hierarchy. Modules at the top, packages
    under them, and then types under packages, as shown in the following diagram with
    a couple of example modules:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块不允许*共享*包，或者如常所说，*分割包*，我们现在面临一个新的层次结构。顶层是模块，下面是包，然后是包下的类型，如下面的图示中几个示例模块所示：
- en: '![](img/00056.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: This now results in another change to the way we think about packages. Packages
    are not grouping of types in the entire application anymore. Packages are grouping
    of types only inside a single module. When you create a package, you are *forced*
    to choose which module the types should all be in. One advantage of this approach,
    if we design our packages well, is clearer organization. There are also performance
    optimizations. The Java class loader internally maps each package to a single
    module, so when it's looking up types to load, it immediately knows where (and
    in which module) to find a given type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在导致我们对包的思考方式发生了另一项变化。包不再是整个应用程序中类型的分组。包只是单个模块内类型的分组。当你创建一个包时，你被迫选择所有类型都应该在哪个模块中。如果我们设计得好的话，这种方法的一个优点是组织更清晰。还有性能优化。Java类加载器内部将每个包映射到单个模块，因此当它查找要加载的类型时，它立即知道在哪里（以及哪个模块）可以找到给定类型。
- en: This restriction of avoiding split packages will come back to be a bitter pain
    in the neck when migrating legacy Java codebases to Java 9 modules which we'll
    cover in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*. Also note that there are ways to bypass this
    restriction by using multiple class loaders, but that's beyond the scope of what
    we are covering here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 避免分割包的限制在将遗留Java代码库迁移到Java 9模块时将变成一个痛苦的头痛问题，我们将在[第11章](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb)“将您的代码迁移到Java
    9”中讨论。此外，请注意，有方法可以通过使用多个类加载器来绕过这个限制，但这超出了我们在这里讨论的范围。
- en: Tweaking modularity
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整模块化
- en: We've looked at two language constructs you can use in the module descriptor--*requiring*
    modules and *exporting* packages. Together, they give you sufficient control over
    the interface of your modules and they address the two main goals of modularity--reliable
    configuration and strong encapsulation. However, in many real-world situations,
    you might sometimes find that these two alone are not enough to achieve certain
    things you want to do. For example, you may want to `export` a package from a
    module, only for it to be consumed by a certain other module, and not for public
    consumption. To handle many such special cases, the module system has some powerful
    features that we'll take a look at in this part of the chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两个可以在模块描述符中使用的语言结构--*要求*模块和*导出*包。它们共同为你提供了足够的控制权来管理模块的接口，并解决了模块化的两个主要目标--可靠的配置和强大的封装。然而，在许多实际情况下，你可能会发现仅这两个还不够来实现你想要完成的事情。例如，你可能只想从模块中导出一个包，仅供某个特定的其他模块使用，而不是公开使用。为了处理许多这样的特殊情况，模块系统有一些强大的功能，我们将在本章的这一部分进行探讨。
- en: Implied readability
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐含的可读性
- en: 'We looked at the problem of dependency leakage in [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Platform APIs*. The module that you depend on might have APIs that might
    also require you to use another module. Here''s an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb)“使用平台API”中探讨了依赖泄露的问题。你依赖的模块可能包含需要你使用另一个模块的API。以下是一个例子：
- en: '![](img/00057.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The module A  `requires` module B, which in turn `requires` C. We know that
    with this, A does not read C, since module dependencies are not *transitive* in
    nature. But what if it needs to? For instance, if B has an API whose return type
    is in module C.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模块A“要求”模块B，而模块B反过来“要求”模块C。我们知道，由于模块依赖不是*传递性*的，A不会读取C。但如果是这种情况呢？例如，如果B有一个API，其返回类型在模块C中。
- en: 'A good example can be found in the platform module itself. Let''s say you write
    your custom module that reads `java.sql`. And you''d like to use the `Driver`
    interface from the module. The `Driver` interface has a method called `getParentLogger()`
    that returns the type `Logger`. Here''s what the method in the `Driver` interface
    looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子可以在平台模块本身中找到。假设你编写了一个自定义模块，该模块读取`java.sql`。你希望使用该模块中的`Driver`接口。`Driver`接口有一个名为`getParentLogger()`的方法，它返回类型`Logger`。以下是`Driver`接口中该方法的模样：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s your code in your custom module that calls the API from `java.sql`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在自定义模块中调用 `java.sql` API 的代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To get this to work, you just need to add requires `java.sql` in your module
    definition, and you should be good to go, right? Not so fast! Think about the
    return type `Logger`. That type is actually coming from `java.logging`, like we've
    already seen. The `java.sql` module depends on `java.logging` for logging capabilities,
    so it isn't a problem for *that* module. But how about yours?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，你只需要在你的模块定义中添加 `requires java.sql`，然后你应该就可以正常使用了，对吧？但等等！考虑一下返回类型 `Logger`。实际上，这个类型是从
    `java.logging` 来的，就像我们之前看到的。`java.sql` 模块依赖于 `java.logging` 来实现日志功能，所以对那个模块来说没问题。但你的模块呢？
- en: '![](img/00058.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: Since `yourmodule` does not directly require `java.logging`, in order to use
    the `java.sql` API, you'd have to `require` the `java.logging` module too!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `yourmodule` 没有直接要求 `java.logging`，为了使用 `java.sql` API，你必须也 `require` `java.logging`
    模块！
- en: '![](img/00059.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: As you can tell, this is not very convenient. If the usage of a certain module
    requires the use of other modules too, it just adds to the complexity of the API.
    Here, you'd need to have some documentation for the developers that says, *If
    you happen to use java.sql, don't forget to also require java.logging*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这并不太方便。如果使用某个模块需要使用其他模块，这只会增加 API 的复杂性。在这里，你需要为开发者提供一些文档说明，例如：“如果你恰好使用
    java.sql，别忘了也要要求 java.logging。”
- en: Is there a better way? Although dependencies aren't transitive by default, what
    we'd like is the ability to selectively make only certain dependencies transitively
    available, for situations like this. Thankfully, this is possible in Java 9 by
    using the `transitive` keyword. When you declare `requires` on a module, you can
    also have that module be available and readable to any modules that depend on
    your module. The way to use this feature is like this--`requires transitive <module-name>;`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更好的方法？尽管依赖默认不是传递性的，但我们希望有选择性地仅使某些依赖传递性可用，以应对这种情况。幸运的是，Java 9 通过使用 `transitive`
    关键字实现了这一点。当你在一个模块上声明 `requires` 时，你也可以让该模块对任何依赖于你的模块的模块可用和可读。使用此功能的办法是这样的——`requires
    transitive <module-name>;`
- en: 'In the following example, module A requires B. But module B *requires transitive
    C*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，模块 A 需要 B。但模块 B *需要传递性 C*：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, module C is readable by not only module B, but by all other modules that
    read module B. So here, A gets to read C too!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模块 C 不仅可被模块 B 读取，而且可被所有读取模块 B 的其他模块读取。所以在这里，A 也可以读取 C！
- en: Notice that the `transitive` keyword is adding an additional semantic to the
    `requires` keyword. The line `requires transitive C` now makes C readable by all
    modules that read B, while at the same time retaining the meaning of `requires`
    that we've known all along--that B needs to read C too!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`transitive` 关键字为 `requires` 关键字添加了额外的语义。现在 `requires transitive C` 使得 C
    可被所有读取 B 的模块读取，同时仍然保留我们一直知道的 `requires` 的意义——即 B 需要读取 C！
- en: How does this affect the *readability* relationship we have just discussed?
    We know that A *reads* B because of the explicit `requires` relationship? But
    does A *read* C as well? The answer is yes, and this kind of readability relationship
    is referred to as *implied readability*. The relationship is not *explicit*, since
    there's no direct dependency declared by A on C. The readability is implied due
    to its transitive nature.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们刚才讨论的 *可读性* 关系有何影响？我们知道 A *读取* B 是因为显式的 `requires` 关系？但 A 是否也 *读取* C？答案是肯定的，这种可读性关系被称为
    *隐式可读性*。这种关系不是 *显式* 的，因为 A 没有直接声明对 C 的依赖。这种可读性是由于其传递性而隐含的。
- en: 'This feature is leveraged in the `java.sql` module to solve the problem with
    the `Logger` return type. If you run `java -d` on `java.sql`, you''ll see this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在 `java.sql` 模块中被利用来解决 `Logger` 返回类型的问题。如果你在 `java.sql` 上运行 `java -d`，你会看到如下内容：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the two modules `java.xml` and `java.logging` that `java.sql` requires
    are both marked `transitive`. Like we''ve just seen, this means that any module
    that requires `java.sql` *will* get access to the APIs in `java.xml` and `java.logging`
    automatically! This is a decision taken by the platform team because using many
    of the APIs in `java.sql` requires the use of the other two modules as well. So
    rather than having all the developers remember to `require` those too, the platform
    has made it *automatic*. This is why any module that depends on `java.sql` and
    calls the `Driver.getParentLogger()` will have no problems using the `Logger`
    type, since that module will have an implied readability on `java.logging`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`java.sql`所需的两个模块`java.xml`和`java.logging`都被标记为`transitive`。正如我们刚才看到的，这意味着任何需要`java.sql`的模块都将自动获得`java.xml`和`java.logging`中的API访问权限！这是平台团队做出的决定，因为使用`java.sql`中的许多API也需要使用其他两个模块。因此，为了避免所有开发者都记得`require`这些模块，平台已经将其设置为*自动*。这就是为什么任何依赖于`java.sql`并调用`Driver.getParentLogger()`的模块在使用`Logger`类型时不会有任何问题，因为这个模块将对`java.logging`具有隐含的可读性：
- en: '![](img/00060.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: Note that you need to be cautious about adding a lot of transitive dependencies
    in your modules. I mentioned dependency leakage in [Chapter 5](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Using Platform APIs*, and how it's better to have all of your module's dependencies
    restricted in usage in your module. Any usage of APIs that the module exposes
    should only need to deal with types that are all exposed and available in the
    same module as well. The concept of transitive dependencies in a way seems to
    run counter to that philosophy. Thanks to `transitive`, any dependency leakages
    can be handled easily by making the modules containing the leaked types as `requires
    transitive`. But that's a slippery slope. Imagine having to depend on a module
    and inadvertently getting a dozen other module dependencies because they are all
    marked `requires transitive` in the module you need! Such module designs clearly
    violate the principles of modularity, and I highly recommend avoiding them unless
    absolutely required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要在你的模块中谨慎添加大量的传递依赖。我在[第五章](part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb)“使用平台API”中提到了依赖泄露，并且建议将你模块的所有依赖限制在模块内部使用。模块暴露的API的使用应该只需要处理在相同模块中暴露和可用的类型。从某种意义上说，传递依赖的概念似乎与那种哲学相悖。多亏了`transitive`，任何依赖泄露都可以通过将包含泄露类型的模块标记为`requires
    transitive`来轻松处理。但这是一条滑梯。想象一下，你需要依赖一个模块，却意外地得到了一打其他的模块依赖，因为它们在你需要的模块中都被标记为`requires
    transitive`！这种模块设计显然违反了模块化的原则，我强烈建议除非绝对必要，否则避免使用它们。
- en: There is, however, a really interesting and handy usage of transitive dependencies
    that will help library developers. That is *aggregator modules*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种非常有趣且实用的传递依赖的使用方法，这将帮助库开发者。那就是*聚合模块*。
- en: Aggregator modules
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合模块
- en: An aggregator module is a module that does not provide any functionality on
    its own, but instead, its sole purpose is to gather and bundle together a bunch
    of other modules. As the name implies, these modules *aggregate* several other
    modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合模块是一种不提供任何自身功能的模块，而是它的唯一目的是收集和捆绑其他模块。正如其名所示，这些模块*聚合*了几个其他模块。
- en: Let's assume you have a group of your favorite library modules that you often
    use together in your applications. Let's say this is a list of some core libraries,
    and whenever you write a module, it's very likely that you'll use pretty much
    every library in that list. Now, using every module in that list in any of your
    own modules involves specifying each of those modules using the `requires` clause.
    Depending on how big that list is, it can be tedious to specify the same set of
    core dependencies in every one of your module descriptors. Even if you were to
    do that once, it's hard to change the list of core libraries, perhaps to add a
    new one. Your only option would be to go through all your module descriptors again
    and make that change. Wouldn't it be nice if you could create a new module that
    bundles all your core libraries? That way you have the list in one place and you
    don't have to specify the complete list anywhere else. Any module that needs all
    those libraries can now express a dependency to this new *module bundle*! You
    can do just that by creating an essentially *empty* module with all the dependencies
    transitive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组你最喜欢的库模块，你经常在应用程序中一起使用。假设这是一个核心库的列表，每次你编写一个模块时，你很可能几乎会使用列表中的每一个库。现在，在任何一个自己的模块中使用列表中的每个模块都涉及到使用
    `requires` 子句来指定每个模块。根据列表的大小，指定每个模块描述符中的相同核心依赖可能很繁琐。即使你只做一次，也很难更改核心库的列表，可能需要添加一个新的库。你唯一的选择是再次遍历所有模块描述符并做出更改。如果你能创建一个捆绑所有核心库的新模块，那岂不是很好？这样你就可以在一个地方找到这个列表，而且你不必在其他任何地方指定完整的列表。现在，任何需要所有这些库的模块都可以表达对这个新的
    *模块捆绑包* 的依赖！你可以通过创建一个本质上 *空* 的模块，并带有所有依赖项的传递性来实现这一点。
- en: 'Consider this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here's a module called `librarybundle` that does not really export *anything*,
    since there are no `exports` packages specified in the module descriptor. This
    module doesn't really need to contain a single Java class! What it does do, however,
    is `requires transitive` three other libraries. So, any module that depends on
    the `librarybundle` module automatically reads those three libraries too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为 `librarybundle` 的模块，实际上并没有导出任何内容，因为在模块描述符中没有指定任何 `exports` 包。这个模块实际上并不需要包含一个单独的
    Java 类！然而，它所做的确实是 `requires transitive` 三种其他库。因此，任何依赖于 `librarybundle` 模块的模块都会自动读取这三个库。
- en: Java platform aggregator modules
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 平台聚合模块
- en: The Java platform has a couple of aggregator modules to represent the *complete*
    JRE, at least as we knew it in Java 8 and earlier. The `java.se` module essentially
    re-exports the entire Java SE platform. The `java.se.ee` module contains the subset
    of the platform that overlaps with Java EE and contains APIs such as web services,
    transactions, and the legacy CORBA APIs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台有几个聚合模块来表示 *完整* 的 JRE，至少在我们知道 Java 8 及更早版本时是这样。`java.se` 模块基本上重新导出了整个
    Java SE 平台。`java.se.ee` 模块包含与 Java EE 重叠的平台子集，并包含诸如 Web 服务、事务和遗留 CORBA API 等API。
- en: 'Running `java -d` on the `java.se` module shows us how it''s implemented:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.se` 模块上运行 `java -d` 命令可以显示其实现方式：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, I hope you resist the temptation to use these aggregator modules in any
    new modules you create in your Java 9 code. You could practically throw in `requires
    java.se` in all your module definitions and not have to worry about doing any
    other `requires` ever again! But that again defeats the purpose of modularity
    and you are back to using the Java platform the way we did in Java 8 and earlier--by
    depending on the entirety of the platform APIs irrespective of what part of them
    you really need. These aggregator modules are mainly to be used for legacy code
    migration purposes, and that too as a temporary measure, in an attempt to get
    to more fine-grained dependencies eventually.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我希望你抵制在创建的任何新的 Java 9 代码中使用这些聚合模块的诱惑。你几乎可以在所有的模块定义中抛入 `requires java.se`，并且再也不必担心做任何其他的
    `requires`！但这样又违背了模块化的目的，你又会回到使用 Java 平台的方式，就像我们在 Java 8 及更早版本中做的那样——依赖于整个平台 API，而不考虑你真正需要的是哪一部分。这些聚合模块主要用于遗留代码迁移目的，而且也只作为临时措施，试图最终达到更细粒度的依赖。
- en: 'Although the `java.se.ee` module is deprecated and is not encouraged for use,
    there''s an interesting observation to be made by examining it. While `java.se.ee`
    is a super set that includes all modules in `java.se` and then some more, its
    module definition doesn''t re-declare a entire list of all the modules in the
    platform. What it does is simply require transitive the `java.se` module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`java.se.ee`模块已被弃用，不鼓励使用，但通过检查它，我们可以得出一个有趣的观察。虽然`java.se.ee`是一个超集，包括`java.se`中的所有模块以及一些额外的模块，但其模块定义并没有重新声明平台中所有模块的整个列表。它所做的只是简单地要求传递性地需要`java.se`模块：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use this approach in your own modules to create aggregator modules of
    other aggregator modules! Pretty powerful stuff!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在自己的模块中使用这种方法来创建其他聚合模块的聚合模块！非常强大！
- en: Qualified exports
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合格导出
- en: In the previous section, we looked at transitive dependencies that let us tweak
    the *readability* relationship between modules to handle some special use cases.
    In this section, you'll be introduced to a way you can tweak the *accessibility*
    relationships in some special cases. This can be done using a feature called **qualified
    exports**. Let's learn what they are.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了传递性依赖，它让我们可以调整模块之间的*可读性*关系来处理一些特殊用例。在本节中，你将了解到一种可以调整某些特殊情况下*访问性*关系的方法。这可以通过一个称为**合格导出**的功能来实现。让我们来了解一下它们是什么。
- en: You've already learned that the `exports` keyword lets you specify which packages
    in a module are allowed to be used outside the module. The exported packages form
    the *public contract* of the module, and any module that reads such a module automatically
    gets *accessibility* to those exported packages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到`exports`关键字允许你指定模块中哪些包可以在模块外部使用。导出的包构成了模块的*公共契约*，任何读取此类模块的模块都会自动获得对这些导出包的*访问权限*。
- en: But there is a catch here! Ideally, you'd like to design your modules and APIs
    as standalone entities and you always have a clear idea about what the modules
    should export. But you might encounter real-world scenarios where that isn't the
    case. Sometimes you'll have to design modules to make them work well with others,
    and that incurs an interesting cost.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里有一个问题！理想情况下，你可能希望将你的模块和API设计成独立的实体，并且始终清楚地知道模块应该导出什么。但你也可能遇到现实世界中的场景，情况并非如此。有时你可能需要设计模块，以便它们能够与其他模块良好地协同工作，这会带来一些有趣的成本。
- en: 'Consider that you have built a library module called **B** that is being used
    by a consumer module **A**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经构建了一个名为**B**的库模块，它被消费者模块**A**所使用：
- en: '![](img/00061.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00061.jpeg)'
- en: 'The developer of module A can obviously call the exported APIs of B now. But
    then, it so happens that they also need this one other API in module B that isn''t
    exported yet. You didn''t initially want to export that private package from module
    B because it''s not something that''s commonly needed outside B, but it turns
    out there''s just one other module, module A, that really needs it! So, to make
    the developer of module A happy, you add that private package to the `exports`
    list from module B:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模块A的开发者现在显然可以调用B模块导出的API。但随后，他们还需要B模块中尚未导出的另一个API。你最初不想从B模块中导出那个私有包，因为它不是B外部通常需要的，但结果证明，只有一个模块A真正需要它！所以，为了让模块A的开发者满意，你将那个私有包添加到B模块的`exports`列表中：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After a while, a new module, module C, depends on module B. It too has an interesting
    use case where it needs another private API from module B. It''s very likely that
    it''s only C that''ll ever need that API outside of B, but in order to make module
    C work, you have no option but to add that package to the exported packages of
    module B:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，一个新的模块，模块C，依赖于模块B。它也有一个有趣的使用场景，需要从模块B中获取另一个私有API。很可能只有C模块会在B外部需要那个API，但为了让模块C工作，你除了将那个包添加到B模块的导出包中别无选择：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I hope you notice the problem already. Now two originally private packages in
    module B are now public for use by every module that reads B, although the intent
    for exporting those packages was to satisfy two very small and specific use cases.
    If this goes on, the exported APIs in your module end up being the greatest common
    set of APIs that are sure to keep every consumer module happy. In the process,
    you've lost the advantages of encapsulation. Now that an internal package is exported,
    albeit with the intention to satisfy one module, it is available for *any* module
    to use. Wouldn't it be great if when exporting packages to a module, you could
    selectively specify *which modules* the packages need to be exported to? If so,
    then only those selected modules could access those specially exported packages.
    All other modules would only get the *publicly exported *packages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你已经注意到了这个问题。现在，模块B中原本是私有的两个包现在对读取B的每个模块都是公开的，尽管导出这些包的意图是为了满足两个非常小且具体的用例。如果继续这样下去，你模块中的导出API最终会变成确保每个消费者模块都满意的API的最大公约集。在这个过程中，你失去了封装的优势。现在，一个内部包被导出，尽管意图是为了满足一个模块，但它对*任何*模块都是可用的。如果当导出包到一个模块时，你可以选择性地指定*哪些模块*需要导出这些包，那岂不是很好？如果是这样，那么只有那些选定的模块才能访问那些特别导出的包。所有其他模块将只能获得*公开导出*的包。
- en: 'This is possible using qualified exports. The `exports` clause in the module
    definition optionally lets you specify which module you need to export the package
    to. If you do that, the `export` is not public anymore. Only the module you specify
    has access to it. The syntax is:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过有资格的导出来实现。模块定义中的`exports`子句允许你指定需要导出包到的模块。如果你这样做，`export`就不再是公开的了。只有你指定的模块可以访问它。语法是：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Applying this concept to our example module B, we can still have better encapsulation
    of our private packages by selectively giving modules A and C access to what they
    alone need:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将此概念应用于我们的示例模块B，我们可以通过选择性地给予模块A和C访问它们各自需要的，来更好地封装我们的私有包：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this change, package `moduleb.privateA` is *accessible* to A, but not to
    B or any other module that reads B. Similarly, `moduleb.privateC` is *accessible*
    only by C. Now, while the private APIs are still not fully encapsulated, you at
    least know for sure what modules they are accessed by, and so any changes are
    easier to manage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变更，包`moduleb.privateA`对A是*可访问的*，但对B或任何读取B的其他模块则不是。同样，`moduleb.privateC`仅由C*可访问*。现在，尽管私有API尚未完全封装，但你至少可以确切知道它们被哪些模块访问，因此任何更改都更容易管理。
- en: 'An example usage of this feature in the Java platform is in the `java.base`
    module. This module contains a lot of core internal packages that have been deemed
    *internal* and that we Java developers are ideally not supposed to use. Unfortunately,
    other platform modules still need to use them, and encapsulating these internal
    packages prevents access to those platform modules too! Thus, you''ll see a lot
    of these qualified exports where the internal APIs are exported just to the platform
    modules that need them. You can run the `java -d` command on `java.base` to see
    many instances of these:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java平台中，此功能的示例用法位于`java.base`模块中。此模块包含许多被认为是*内部*的核心内部包，我们Java开发者理想上不应该使用它们。不幸的是，其他平台模块仍然需要使用它们，而这些内部包的封装也阻止了对这些平台模块的访问！因此，你会看到很多这些有资格的导出，其中内部API仅导出到需要它们的平台模块。你可以在`java.base`上运行`java
    -d`命令来查看这些实例：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that using qualified exports is generally not recommended. The principles
    of modularity recommend that a module should not be aware of who the consumers
    are. Qualified exports, by definition, add a certain level of coupling between
    two modules. The coupling is not forced--if you have a qualified export to a certain
    module, and that module isn't even in the module path to take advantage of it,
    there are no errors. But the coupling is there nevertheless, and so it's not a
    good idea to use qualified exports unless it's absolutely required.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用有资格的导出通常是不推荐的。模块化的原则建议一个模块不应该知道其消费者是谁。有资格的导出，根据定义，在两个模块之间增加了一定程度的耦合。这种耦合不是强制的——如果你有一个有资格的导出到某个模块，而这个模块甚至不在模块路径中利用它，那么不会有错误。但耦合确实存在，因此除非绝对必要，否则不建议使用有资格的导出。
- en: Applying the concepts to address book viewer
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将此概念应用于地址簿查看器
- en: We've learned about a couple of powerful ways in which we can tweak the *default*
    behavior of module dependencies in Java 9\. Let's get hands-on now and apply some
    of these to our address book viewer application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了几种强大的方法，可以调整 Java 9 中模块依赖项的 *默认* 行为。现在让我们动手操作，将这些方法应用到我们的地址簿查看器应用程序中。
- en: Creating a custom aggregator module
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义聚合器模块
- en: Notice that we have two modules in the address book viewer application that
    provides a view of the address book. The `packt.addressbook` module shows a simple
    list of contacts in command line. The `packt.addressbook.ui` module shows the
    address book contacts and details in UI form. Both these modules happen to use
    the two utility modules to get the list of contacts (`packt.contact`) and to sort
    them (`sort.util`). Here, we have just two modules, so it's not that big of a
    deal to add the requires descriptor for both of these modules in two places. But
    imagine if there were many more libraries and many more consumers! You'd be duplicating
    the list multiple times.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在地址簿查看器应用程序中，我们有两个模块提供了地址簿的视图。`packt.addressbook` 模块在命令行中显示简单的联系人列表。`packt.addressbook.ui`
    模块以 UI 形式显示地址簿联系人和详细信息。这两个模块恰好都使用了两个实用模块来获取联系人列表（`packt.contact`）和排序（`sort.util`）。在这里，我们只有两个模块，所以将这两个模块的要求描述符添加到两个地方并不是什么大问题。但是，想象一下如果有更多的库和更多的消费者！你将不得不多次重复列表。
- en: To avoid that, let's create an aggregator module that bundles and re-exports
    the `packt.contact` and `sort.util` modules. We can then have the `packt.addressbook`
    and `packt.addressbook.ui` modules depend on the aggregator module directly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，让我们创建一个聚合器模块，它将 `packt.contact` 和 `sort.util` 模块捆绑并重新导出。然后，`packt.addressbook`
    和 `packt.addressbook.ui` 模块可以直接依赖于聚合器模块。
- en: 'Let''s call the aggregator module `packt.addressbook.lib`. This module acts
    as the *library* for all `addressbook` modules. Create a directory with the name
    of the module in the `src` folder and add the following code in its module descriptor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将聚合器模块命名为 `packt.addressbook.lib`。此模块充当所有 `addressbook` 模块的 *库*。在 `src` 文件夹中创建一个以模块名称命名的目录，并在其模块描述符中添加以下代码：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is actually the only file that this module would need. It doesn't provide
    any APIs of its own. It just has the module descriptor that `requires transitive`
    all the modules that it wants to re-export. Here, we choose for it to re-export
    the two custom utility modules we've created. We have the option here to add `requires
    transitive` on some of the platform modules as well, like `java.logging`. But
    we'll just stick with our custom modules for now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个模块只需要一个文件。它不提供任何自己的 API。它只是有一个模块描述符，该描述符 `requires transitive` 所有它想要重新导出的模块。在这里，我们选择重新导出我们创建的两个自定义实用模块。我们还有选择在这里添加
    `requires transitive` 到一些平台模块，如 `java.logging`。但我们将暂时坚持使用我们的自定义模块。
- en: The next step is to go to the consumer modules and change the direct dependencies
    to the aggregator module instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是进入消费者模块，并将直接依赖项更改为聚合器模块。
- en: 'Here''s the module descriptors for the two address book modules:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个地址簿模块的模块描述符：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and execute the two modules, and you should still see the output as
    before. Here's the updated dependency graph of our address book application now,
    excluding the platform modules. Notice that the transitive dependencies are illustrated
    with a dotted arrow to convey that while the dependency is not direct, it's still
    there!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行这两个模块，你应该仍然看到之前的输出。以下是我们的地址簿应用程序现在更新的依赖关系图，不包括平台模块。注意，传递依赖项用虚线箭头表示，以传达虽然依赖项不是直接的，但它仍然存在！
- en: '![](img/00062.gif)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00062.gif)'
- en: Optimizing module imports
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化模块导入
- en: 'In the previous chapter, we created the GUI address viewer module that required
    the Java FX modules necessary for building the UI. Here''s what the module descriptor
    looked like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了需要构建 UI 所必需的 Java FX 模块的 GUI 地址查看器模块。以下是模块描述符的样子：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll now see that not all the modules imported are actually required, and
    we can optimize this list a bit, thanks to our new knowledge of transitive dependencies.
    Running `java -d` on `javafx.controls` gives us:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到并非所有导入的模块都是实际需要的，我们可以利用我们对传递依赖项的新知识来优化这个列表。在 `javafx.controls` 上运行 `java
    -d` 给出：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Turns out the `javafx.base` and `javafx.graphics` modules are transitive dependencies
    of `javafx.controls` already. So, any module that *reads *`javafx.controls` also
    *reads *`javafx.base` and `javafx.graphics`! So, we can remove those two modules
    and just declare our dependency on `javafx.controls`, since that module alone
    pulls in all the dependencies we need. Here''s the updated module descriptor for `packt.addressbook.ui`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`javafx.base`和`javafx.graphics`模块已经是`javafx.controls`的传递依赖。所以，任何读取`javafx.controls`的模块也会读取`javafx.base`和`javafx.graphics`！因此，我们可以移除这两个模块，只需声明我们对`javafx.controls`的依赖，因为这个模块本身拉入了我们需要的所有依赖。以下是`packt.addressbook.ui`的更新模块描述符：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You should be able to recompile and execute the UI module to make sure things
    still work just the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够重新编译并执行UI模块，以确保一切仍然按预期工作。
- en: Optimizing module exports
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化模块导出
- en: At the end of the previous chapter, we begrudgingly added the `exports` qualifier
    for the package containing the main JavaFX class in the module descriptor for
    the `packt.addressbook.ui` module. We did this because the way the JavaFX framework
    works, it needs to be able to access the class that extends `javafx.application.Application`
    that launches the UI application. We said how that isn't an ideal solution because
    not only are we exporting the package to the JavaFX framework, we are essentially
    exporting it to the whole world, that is, any module that reads `packt.addressbook.ui`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的结尾，我们很不情愿地在`packt.addressbook.ui`模块的模块描述符中为包含主JavaFX类的包添加了`exports`限定符。我们这样做是因为JavaFX框架的工作方式，它需要能够访问扩展`javafx.application.Application`并启动UI应用程序的类。我们说过这不是一个理想的解决方案，因为我们不仅将包导出到JavaFX框架，实际上是将它导出到全世界，也就是说，任何读取`packt.addressbook.ui`的模块。
- en: 'With our new knowledge of qualified exports, we have just the solution for
    this problem! Instead of exporting `packt.addressbook.ui` globally, we can use
    a qualified export in order to export it just to the JavaFX module. Here, the
    module that needs access to the class is the module `java.graphics`. We''ve removed
    the explicit dependency, although the dependency is still implicitly there! With
    the qualified export to `java.graphics`, here''s what the module descriptor looks
    like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们对限定导出的新知识，我们正好有这个问题的解决方案！我们不必全局导出`packt.addressbook.ui`，而可以使用限定导出仅将其导出到JavaFX模块。在这里，需要访问该类的模块是`java.graphics`模块。我们移除了显式依赖，尽管依赖仍然隐式存在！通过到`java.graphics`的限定导出，模块描述符看起来是这样的：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, you should be able to compile and run the code to make sure everything
    works well. With this change, you've retained encapsulation of the `Main` class
    while still making it available to the right JavaFX framework module that needs
    access to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你应该能够编译并运行代码以确保一切正常工作。通过这个变更，你保留了`Main`类的封装性，同时仍然使其对需要访问它的正确JavaFX框架模块可用。
- en: There is a slightly better way to achieve this by using the  `opens` keyword
    if the problem is with reflective access only. We can use the concept of open
    modules. We'll be covering open modules in detail in [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Design Patterns and Strategies*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题仅与反射访问有关，我们可以通过使用`opens`关键字来稍微更好地实现这一点。我们可以使用开放模块的概念。我们将在第9章详细介绍开放模块，*模块设计模式和策略*。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned some important concepts and terminologies related
    to modularity, including *readability* and *accessibility*. You've also learned
    how the default behavior of the module system can be tweaked for certain specialized
    needs--using implied dependencies and qualified exports. And more importantly,
    you've understood some scenarios where such needs might be required, like aggregator
    modules and certain encapsulation challenges, and how these tweaks might be useful
    in such cases. We then looked at a few places in the address book viewer application
    where these tweaks helped us optimize and simplify dependencies while improving
    encapsulation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了一些与模块化相关的重要概念和术语，包括*可读性*和*可访问性*。你还了解了如何根据特定的专业需求调整模块系统的默认行为——使用隐式依赖和限定导出。更重要的是，你理解了在某些场景下可能需要这些需求的情况，比如聚合模块和某些封装挑战，以及这些调整在这种情况下可能如何有用。然后我们查看了一些在地址簿查看器应用程序中这些调整如何帮助我们优化和简化依赖关系，同时提高封装性的地方。
- en: In the next chapter, you'll learn about a whole new way of handling depended
    abstractions using a powerful concept in Java modularity--using services.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习到一种全新的处理依赖抽象的方法，这是通过Java模块化中的一个强大概念——使用服务来实现的。
