<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer114">
			</div>
		</div>
		<div class="Content" id="_idContainer115">
			<h1 id="_idParaDest-309"><a id="_idTextAnchor319"/>16. Predicates and Other Functional Interfaces</h1>
		</div>
		<div class="Content" id="_idContainer116">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter explores all the valid use cases of functional interfaces. It will first define what these interfaces are (beginning with the predicate interface), as well as how best to employ them in your code. You will then learn how to build and apply predicates, studying their composition and how to use this to model complex behavior. You will practice creating consumer interfaces to change the state of your program, and, eventually, use functions to extract useful constructs.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor320"/>Introduction</h1>
			<p>Alongside the many other improvements in Java 8 (such as the streaming API, method references, optionals, and collectors) there are interface improvements that allow default and static methods known as functional interfaces. These are interfaces with one single abstract method, which enables their transformation into lambdas. You can read more about this in <em class="italic">Chapter 13</em>, <em class="italic">Functional Programming with Lambda Expressions</em>.</p>
			<p>There are a total of 43 unique functional interfaces in the <strong class="source-inline">java.util.function</strong> package; most of them are variants of the same kind of interface, albeit with different data types. In this chapter, we'll introduce you to the <strong class="bold">predicate functional interface</strong>, along with a few other selected interfaces. </p>
			<p>Here, you'll find that many of the functional interfaces operate in very similar ways, often just replacing the type of data that the interface can operate on.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor321"/>Predicate Interface</h1>
			<p>The predicate interface is a quite simple, yet surprisingly elegant and complex, functional interface that allows you, as a programmer, to define functions that describe the state of your program in the shape of Booleans. In Java, speech predicates are one-argument functions that return a Boolean value.</p>
			<p>The predicate API looks like this:</p>
			<p class="source-code">boolean test(T t);</p>
			<p>However, the predicate API also utilizes the new interface features of Java 8. Its sports default and static functions to enrich the API, allowing more complex descriptions of your program's state. Here, three functions are important:</p>
			<p class="source-code">Predicate&lt;T&gt; and(Predicate&lt;T&gt;);</p>
			<p class="source-code">Predicate&lt;T&gt; or(Predicate&lt;T&gt;);</p>
			<p class="source-code">Predicate&lt;T&gt; not(Predicate&lt;T&gt;);</p>
			<p>With these three functions, you can chain predicates to describe more complex queries on your program's state. The <strong class="source-inline">and</strong> function will combine two or more predicates, ensuring that every predicate supplied returns true.</p>
			<p>The <strong class="source-inline">or</strong> function is equivalent to a logical OR, letting you short-circuit the predicate chain when required.</p>
			<p>Finally, the <strong class="source-inline">not</strong> function returns the negated version of the predicate supplied, and it has the exact same effect as calling <strong class="source-inline">negate()</strong> on the supplied predicate.</p>
			<p>There is also a <strong class="source-inline">helper</strong> function to build a predicate that checks whether two objects are identical according to the <strong class="source-inline">equals</strong> method on said objects. We can use the static <strong class="source-inline">isEqual(Object target)</strong> method to build that predicate for two objects The following exercise will serve as an example of defining a predicate.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor322"/>Exercise 1: Defining a predicate</h2>
			<p>Defining a predicate is quite simple. Consider building the backend server of a home alarm system. This system needs to easily understand the state of numerous different sensors at the same time—instances such as: Is the door open or closed? Is the battery healthy or not? Are the sensors connected?</p>
			<p>Building such a system is a complex task. We'll try simplifying the process in this exercise:</p>
			<ol>
				<li>If IntelliJ is already started, but no project is open, select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project open, select <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In <strong class="source-inline">New Project</strong> dialog, select a Java project. Click <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>. Click <strong class="source-inline">Next</strong>.</li>
				<li>Give the new project the name <strong class="source-inline">Chapter16</strong>.</li>
				<li>IntelliJ will give you a default project location. If you wish to select one, you may enter it here.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter16</strong>.</li>
				<li>Click <strong class="source-inline">Finish</strong>.<p>Your project will be created with the standard folder structure, and with an entry point class for your program. It will look something like this:</p><p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Main {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Rename this file to <strong class="source-inline">Exercise1.java</strong>, making sure to use the <strong class="source-inline">Refactor</strong> | <strong class="source-inline">Rename</strong> menu. When you're done, it should look like this:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The alarm system will have three different kinds of sensors – a <strong class="source-inline">Gateway sensor</strong>, a <strong class="source-inline">Movement sensor</strong>, and a <strong class="source-inline">Fire sensor</strong>. They will all have the same basic qualities but may differ in certain aspects. Create the <strong class="source-inline">Base</strong> sensor interface and let it have two getter/setter pairs. The first pair should be called <strong class="source-inline">batteryHealth</strong> and will return an integer between 0 and 100, and the second pair will be a Boolean value called <strong class="source-inline">triggered</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public interface Sensor {</p><p class="source-code">    int batteryHealth();</p><p class="source-code">    void batteryHealth(int health);</p><p class="source-code">    boolean triggered();</p><p class="source-code">    void triggered(boolean state);</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Gateway Sensor</strong> class, and allow it to implement the <strong class="source-inline">Sensor</strong> interface and return instance variables:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Gateway implements Sensor {</p><p class="source-code">    private int batteryHealth;</p><p class="source-code">    private boolean triggered;</p><p class="source-code">    @Override</p><p class="source-code">    public int batteryHealth() {</p><p class="source-code">        return batteryHealth;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void batteryHealth(int health) {</p><p class="source-code">        this.batteryHealth = health;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public boolean triggered() {</p><p class="source-code">        return triggered;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void triggered(boolean state) {</p><p class="source-code">        triggered = state;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Do the same thing for the <strong class="source-inline">Movement</strong> and <strong class="source-inline">Fire</strong> sensor classes, except the <strong class="source-inline">Fire</strong> sensor will also have the current <strong class="source-inline">temperature</strong>, and the <strong class="source-inline">movement sensor</strong> will return the strength of the ambient light in the room:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Fire implements Sensor {</p><p class="source-code">    private int batteryHealth;</p><p class="source-code">    private boolean triggered;</p><p class="source-code">    private int temperature;</p><p class="source-code">    @Override</p><p class="source-code">    public int batteryHealth() {</p><p class="source-code">        return batteryHealth;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void batteryHealth(int health) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public boolean triggered() {</p><p class="source-code">        return triggered;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void triggered(boolean state) {</p><p class="source-code">    }</p><p class="source-code">    public int temperature() {</p><p class="source-code">        return temperature;</p><p class="source-code">    }</p><p class="source-code">}</p><p>The code for <strong class="source-inline">Movement</strong> class is as follows:</p><p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Movement implements Sensor {</p><p class="source-code">    private int batteryHealth;</p><p class="source-code">    private boolean isTriggered;</p><p class="source-code">    private int ambientLight;</p><p class="source-code">    @Override</p><p class="source-code">    public int batteryHealth() {</p><p class="source-code">        return batteryHealth;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void batteryHealth(int health) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public boolean triggered() {</p><p class="source-code">        return isTriggered;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void triggered(boolean state) {</p><p class="source-code">    }</p><p class="source-code">    public int ambientLight() {</p><p class="source-code">        return ambientLight;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add constructors to all three sensor classes, utilizing IntelliJ helpers to this end. Open the <strong class="source-inline">Fire</strong> class, use the <strong class="source-inline">Code</strong> | <strong class="source-inline">Generate</strong> menu, and select <strong class="source-inline">Constructor</strong>.</li>
				<li>Select all three variables and click <strong class="source-inline">OK</strong>. Your <strong class="source-inline">Fire</strong> class should now look something like this:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class Fire implements Sensor {</p><p class="source-code">    private int batteryHealth;</p><p class="source-code">    private boolean triggered;</p><p class="source-code">    private int temperature;</p><p class="source-code">    public Fire(int batteryHealth, boolean isTriggered, int temperature) {</p><p class="source-code">        this.batteryHealth = batteryHealth;</p><p class="source-code">        this.triggered = isTriggered;</p><p class="source-code">        this.temperature = temperature;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public int batteryHealth() {</p><p class="source-code">        return batteryHealth;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void batteryHealth(int health) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public boolean triggered() {</p><p class="source-code">        return triggered;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void triggered(boolean state) {</p><p class="source-code">    }</p><p class="source-code">    public int temperature() {</p><p class="source-code">        return temperature;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Generate constructors for the <strong class="source-inline">Gateway</strong> and <strong class="source-inline">Movement</strong> sensors as well.</li>
				<li>You should now have three functioning classes representing sensor states in your program.</li>
				<li>It's now time to describe your first predicate class, the predicate that describes whether a sensor has a triggered alarm. Create a new class, and call it <strong class="source-inline">HasAlarm</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">public class HasAlarm {</p><p class="source-code">}</p></li>
				<li>Implement the <strong class="source-inline">Predicate</strong> interface, using <strong class="source-inline">Sensor</strong> as the type definition. In the <strong class="source-inline">test</strong> function, return the trigger status of the sensor:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class HasAlarm implements Predicate&lt;Sensor&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public boolean test(Sensor sensor) {</p><p class="source-code">        return sensor.triggered();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Back in your program's entry point, the <strong class="source-inline">main</strong> method, create a list of sensors and add a few <strong class="source-inline">Gateway</strong> sensors to it:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;<a id="_idTextAnchor323"/></p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Use a <strong class="source-inline">for</strong> loop in the main method to iterate through the list. In the <strong class="source-inline">for</strong> loop, add an <strong class="source-inline">if</strong> statement that uses the predicate to check whether an alarm was triggered:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        for (Sensor sensor : sensors) {</p><p class="source-code">            if (new HasAlarm().test(sensor)) {</p><p class="source-code">                System.out.println("Alarm was triggered");</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You may very well ask yourself what the point of this is. This is no different from using the sensor's <strong class="source-inline">public triggered()</strong> function. This is also an uncommon way of applying predicates, but it illustrates how predicates work. A much more common approach involves using streams and lambdas.</p></li>
				<li>Now, create another predicate and call it <strong class="source-inline">HasWarning</strong>. In this class, we'll simply check whether the battery status is below a threshold of <strong class="source-inline">10</strong>, which will symbolize 10% in our example:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class HasWarning implements Predicate&lt;Sensor&gt; {</p><p class="source-code">    public static final int BATTERY_WARNING = 10;</p><p class="source-code">    @Override</p><p class="source-code">    public boolean test(Sensor sensor) {</p><p class="source-code">        return sensor.batteryHealth() &lt; BATTERY_WARNING;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Use the <strong class="source-inline">HasAlarm</strong> and <strong class="source-inline">HasWarning</strong> predicates to generate a newly composed predicate. Instantiate the <strong class="source-inline">HasAlarm</strong> predicate and apply the default <strong class="source-inline">or()</strong> function to chain the <strong class="source-inline">HasWarning</strong> predicate as well:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        Predicate&lt;Sensor&gt; hasAlarmOrWarning = new HasAlarm().or(new           HasWarning());</p><p class="source-code">        for (Sensor sensor : sensors) {</p><p class="source-code">            if (new HasAlarm().test(sensor)) {</p><p class="source-code">                System.out.println("Alarm was triggered");</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add a new <strong class="source-inline">if</strong> statement in the <strong class="source-inline">for</strong> loop using the newly composed predicate:</li>
			</ol>
			<p class="source-code-heading">Exercise1.java</p>
			<p class="source-code">1  package com.packt.java.chapter16;</p>
			<p class="source-code">2  </p>
			<p class="source-code">3  import java.util.ArrayList;</p>
			<p class="source-code">4  import java.util.List;</p>
			<p class="source-code">5  import java.util.function.Predicate;</p>
			<p class="source-code">6  </p>
			<p class="source-code">7  public class Exercise1 {</p>
			<p class="source-code">8  </p>
			<p class="source-code">9      public static void main(String[] args) {</p>
			<p class="source-code">10         List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p>
			<p class="source-code">11         sensors.add(new Gateway(34, false));</p>
			<p class="source-code">12         sensors.add(new Gateway(14, true));</p>
			<p class="source-code">13         sensors.add(new Gateway(74, false));</p>
			<p class="source-code">14         sensors.add(new Gateway(8, false));</p>
			<p class="source-code">15         sensors.add(new Gateway(18, false));</p>
			<p class="source-code">16         sensors.add(new Gateway(9, false));</p>
			<p class="source-code-link"><a href="https://packt.live/2P9njsy">https://packt.live/2P9njsy</a></p>
			<p>As mentioned earlier, applying predicates—or any other functional interface, for that matter—directly on objects in loops like this is uncommon. Instead you will primarily use the Java streams API.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor324"/>Activity 1: Toggling the Sensor States</h1>
			<p>Rewrite the program once more, adding a scanner to your program to toggle sensor states from the command line. Each sensor should be capable of at least toggling the battery health and triggered status. When a sensor has updated, you should check the system for changes and generate a proper response on the command line if a warning or alarm has been triggered.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this Activity can be found on page 565.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor325"/>Consumer Interface</h2>
			<p>In functional programming, we're often told to avoid side effects in our code. The consumer functional interface, however, is an exception to this rule. Its only purpose is to produce a side effect based on the state of the argument. The consumer has quite a simple API, the core function of which is called <strong class="source-inline">accept()</strong> and doesn't return anything:</p>
			<p class="source-code">void accept(T);</p>
			<p>This can also be used for chaining multiple consumers by using the <strong class="source-inline">andThen()</strong> function, which returns the newly chained consumer:</p>
			<p class="source-code">Consumer&lt;T&gt; andThen(Consumer&lt;T&gt;);</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor326"/>Exercise 2: Producing Side Effects</h2>
			<p>Continuing the previous exercise, consider the following example wherein we will add functionality for reacting to warnings and alarms in the system. You can use consumers to produce side effects and to store the current state of the system in variables:</p>
			<ol>
				<li value="1">Copy the <strong class="source-inline">Exercise1.java</strong> class, and call it <strong class="source-inline">Exercise2</strong>. Remove the whole <strong class="source-inline">for</strong> loop, but leave the instantiated predicate.</li>
				<li>Create a new static Boolean variable in <strong class="source-inline">Exercise2</strong>, and call it <strong class="source-inline">alarmServiceNotified</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    static boolean alarmServiceNotified;</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        Predicate&lt;Sensor&gt; hasAlarmOrWarning = new HasAlarm().or(new           HasWarning());</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">This is, of course, not the manner in which you'd commonly apply static variables (if you ever really should use static variables). However, in this example, it makes it a lot easier to illustrate side effects.</p></li>
				<li>Create a new class, call it <strong class="source-inline">SendAlarm</strong>, and allow it to implement the consumer interface. It should look something like this:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Consumer;</p><p class="source-code">public class SendAlarm implements Consumer&lt;Sensor&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public void accept(Sensor sensor) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">accept(Sensor sensor)</strong> function, check whether the sensor has been triggered. If it has been triggered, set the static variable to <strong class="source-inline">true</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Consumer;</p><p class="source-code">public class SendAlarm implements Consumer&lt;Sensor&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public void accept(Sensor sensor) {</p><p class="source-code">        if (sensor.triggered()) {</p><p class="source-code">            Exercise2.alarmServiceNotified = true;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Back in the <strong class="source-inline">main</strong> method, instantiate a new <strong class="source-inline">SendAlarm</strong> consumer:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    static boolean alarmServiceNotified;</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        Predicate&lt;Sensor&gt; hasAlarmOrWarning = new HasAlarm().or(new       HasWarning());</p><p class="source-code">        SendAlarm sendAlarm = new SendAlarm();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Using streams, first, filter the list of sensors based on the previously defined composed predicate. Then, use <strong class="source-inline">forEach</strong> to apply the <strong class="source-inline">SendAlarm</strong> consumer to each of the sensors that have an alarm or warning triggered:<p class="source-code">        sensors.stream().filter(hasAlarmOrWarning).forEach(sendAlarm);</p></li>
				<li>Now, add an <strong class="source-inline">if</strong> statement, checking whether the alarm service was notified, and print a message if it was:<p class="source-code">        if (alarmServiceNotified) {</p><p class="source-code">            System.out.println("Alarm service notified");</p><p class="source-code">        }</p></li>
				<li>Build one more consumer, and this time call it <strong class="source-inline">ResetAlarm</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Consumer;</p><p class="source-code">public class ResetAlarm implements Consumer&lt;Sensor&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public void accept(Sensor sensor) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add logic to the <strong class="source-inline">ResetAlarm</strong> <strong class="source-inline">accept()</strong> function to set <strong class="source-inline">batteryHealth</strong> to <strong class="source-inline">50</strong> and <strong class="source-inline">Triggered</strong> to <strong class="source-inline">false</strong>. Also, set the static notification variable to <strong class="source-inline">false</strong>:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">        import java.util.function.Consumer;</p><p class="source-code">public class ResetAlarm implements Consumer&lt;Sensor&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public void accept(Sensor sensor) {</p><p class="source-code">        sensor.triggered(false);</p><p class="source-code">        sensor.batteryHealth(50);</p><p class="source-code">        Exercise2.alarmServiceNotified = false;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Instantiate the new <strong class="source-inline">ResetAlarm</strong> consumer, and then apply it after the <strong class="source-inline">SendAlarm</strong> consumer using the <strong class="source-inline">andThen()</strong> function:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">import java.util.function.Consumer;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    static boolean alarmServiceNotified;</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        Predicate&lt;Sensor&gt; hasAlarmOrWarning = new HasAlarm().or(new       HasWarning());</p><p class="source-code">        if (sensors.stream().anyMatch(hasAlarmOrWarning)) {</p><p class="source-code">            System.out.println("Alarm or warning was triggered");</p><p class="source-code">        }</p><p class="source-code">        SendAlarm sendAlarm = new SendAlarm();</p><p class="source-code">        ResetAlarm resetAlarm = new ResetAlarm();</p><p class="source-code">        sensors.stream().filter(hasAlarmOrWarning)      .forEach(sendAlarm.andThen(resetAlarm));</p><p class="source-code">        if (alarmServiceNotified) {</p><p class="source-code">            System.out.println("Alarm service notified");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Finally, a bonus. At the very end of <em class="italic">Exercise 2</em>, <em class="italic">Producing Side Effects</em> 's <strong class="source-inline">main</strong> method, apply the negated version of the <strong class="source-inline">hasAlarmOrWarning</strong> predicate, and print out an <strong class="source-inline">Everything okay</strong> message:</li>
			</ol>
			<p class="source-code-heading">Exercise2.java</p>
			<p class="source-code">21         Predicate&lt;Sensor&gt; hasAlarmOrWarning = new HasAlarm().or(new       HasWarning());</p>
			<p class="source-code">22 </p>
			<p class="source-code">23         if (sensors.stream().anyMatch(hasAlarmOrWarning)) {</p>
			<p class="source-code">24             System.out.println("Alarm or warning was triggered");</p>
			<p class="source-code">25         }</p>
			<p class="source-code">26 </p>
			<p class="source-code">27         SendAlarm sendAlarm = new SendAlarm();</p>
			<p class="source-code">28 </p>
			<p class="source-code">29         ResetAlarm resetAlarm = new ResetAlarm();</p>
			<p class="source-code">30 </p>
			<p class="source-code">31         sensors.stream().filter(hasAlarmOrWarning)      .forEach(sendAlarm.andThen(resetAlarm));</p>
			<p class="source-code">32 </p>
			<p class="source-code">33         if (alarmServiceNotified) {</p>
			<p class="source-code">34             System.out.println("Alarm service notified");</p>
			<p class="source-code">35         }</p>
			<p class="source-code">36 </p>
			<p class="source-code">37         if (sensors.stream().anyMatch(hasAlarmOrWarning.negate())) {</p>
			<p class="source-code">38             System.out.println("Nothing was triggered");</p>
			<p class="source-code">39         }</p>
			<p class="source-code-link"><a href="https://packt.live/2JqD7n9">https://packt.live/2JqD7n9</a></p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor327"/>Function</h1>
			<p>The function, functional interface (yes, it's called a function) was introduced mainly to translate one value into another. It is often used in mapping scenarios. It also contains default methods to combine multiple functions into one, and chain functions after one another.</p>
			<p>The main function in the interface is called <strong class="source-inline">apply</strong>, and it looks like this:</p>
			<p class="source-code">R apply(T);</p>
			<p>It defines a return value, <strong class="source-inline">R</strong>, and an input to the function. The idea is that the return value and input don't have to be of the same type.</p>
			<p>The composition is handled by the <strong class="source-inline">compose</strong> function, which also returns an instance of the interface, which means that you can chain compositions. The order is right to left; in other words, the argument function is applied before the calling function:</p>
			<p class="source-code">Function&lt;V, R&gt; compose(Function&lt;V, T&gt;);</p>
			<p>Finally, the <strong class="source-inline">andThen</strong> function allows you to chain functions after one another:</p>
			<p class="source-code">Function&lt;T, V&gt; andThen(Function&lt;R, V&gt;);</p>
			<p>In the following exercise, you will practice using these functions.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor328"/>Exercise 3: Extracting Data</h2>
			<p>Extract all of the alarm system data as integers—battery percentages, temperatures, triggered status, and others, depending on how far you've taken your alarm system. Start by extracting the battery health data:</p>
			<ol>
				<li value="1">Copy the <strong class="source-inline">Exercise2</strong> class and call it <strong class="source-inline">Exercise3</strong>.</li>
				<li>Remove everything except the list of sensors. Your class should look something like this:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a new class, call it <strong class="source-inline">ExtractBatteryHealth</strong>, and let it implement the <strong class="source-inline">Function&lt;T, R&gt;</strong> functional interface. Override the <strong class="source-inline">apply</strong> function. Your class should look like this:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Function;</p><p class="source-code">public class ExtractBatteryHealth implements Function&lt;Sensor, Integer&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public Integer apply(Sensor sensor) {</p><p class="source-code">        return null;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">apply</strong> function, make it return the battery health, as follows:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.function.Function;</p><p class="source-code">public class ExtractBatteryHealth implements Function&lt;Sensor, Integer&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public Integer apply(Sensor sensor) {</p><p class="source-code">        return sensor.batteryHealth();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Instantiate your new <strong class="source-inline">ExtractBatteryHealth</strong> function and add a few more sensors to the list if you haven't already done so:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Fire(78, false, 21));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Movement(87, false, 45));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Fire(32, false, 23));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        sensors.add(new Movement(76, false, 41));</p><p class="source-code">        ExtractBatteryHealth extractBatteryHealth = new ExtractBatteryHealth();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Finally, use the java streams <strong class="source-inline">map</strong> operation and apply your new instance of <strong class="source-inline">ExtractBatteryHealth</strong>. Terminate the stream with a <strong class="source-inline">toArray</strong> operation. You should now have an array of all your battery health:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Fire(78, false, 21));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Movement(87, false, 45));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Fire(32, false, 23));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        sensors.add(new Movement(76, false, 41));</p><p class="source-code">        ExtractBatteryHealth extractBatteryHealth = new           ExtractBatteryHealth();</p><p class="source-code">        Integer[] batteryHealths =           sensors.stream().map(extractBatteryHealth)          .toArray(Integer[]::new);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Print your battery health to the terminal:<p class="source-code">package com.packt.java.chapter16;</p><p class="source-code">import java.util.ArrayList;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.List;</p><p class="source-code">public class Exercise3 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        List&lt;Sensor&gt; sensors = new ArrayList&lt;&gt;();</p><p class="source-code">        sensors.add(new Gateway(34, false));</p><p class="source-code">        sensors.add(new Gateway(14, true));</p><p class="source-code">        sensors.add(new Fire(78, false, 21));</p><p class="source-code">        sensors.add(new Gateway(74, false));</p><p class="source-code">        sensors.add(new Gateway(8, false));</p><p class="source-code">        sensors.add(new Movement(87, false, 45));</p><p class="source-code">        sensors.add(new Gateway(18, false));</p><p class="source-code">        sensors.add(new Fire(32, false, 23));</p><p class="source-code">        sensors.add(new Gateway(9, false));</p><p class="source-code">        sensors.add(new Movement(76, false, 41));</p><p class="source-code">        ExtractBatteryHealth extractBatteryHealth = new ExtractBatteryHealth();</p><p class="source-code">        Integer[] batteryHealths =           sensors.stream().map(extractBatteryHealth)          .toArray(Integer[]::new);</p><p class="source-code">        System.out.println(Arrays.toString(batteryHealths));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor329"/>Activity 2: Using a Recursive Function</h2>
			<p>Calculate the average battery health in your alarm system—either through a loop, a stream, or a recursive function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 566.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor330"/>Activity 3: Using a Lambda Function</h2>
			<p>Instead of instantiating the <strong class="source-inline">ExtractBatteryHealth</strong> functional interface, use a lambda and store a reference to that.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 567.</p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor331"/>Summary</h1>
			<p>In this chapter, you've explored how to use the functional interfaces provided by Java 8. You've used them both in loops, on single instances, and in streams—all of which are valid use cases for functional interfaces. However, you'll quickly find that these instances of functional interfaces (lamdas, for short) are more commonly used together with streams.</p>
			<p>There are many pre-defined functional interfaces in Java, but only a few of them are unique in the way they work. Most are just primitive versions of the different functions, such as <strong class="source-inline">IntPredicate</strong>, <strong class="source-inline">LongPredicate</strong>, <strong class="source-inline">DoublePredicate</strong>, and <strong class="source-inline">Predicate</strong>.</p>
			<p>In the next chapter, you'll learn more about the Reactive Streams initiative, the Flow API, and what Java does to build good foundational interfaces for reactive programming.</p>
		</div>
	</body></html>