<html><head></head><body>
<div id="_idContainer088">
<h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-241"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.2.1">Comparing Hexagonal Architecture with Layered Architecture</span><a id="_idTextAnchor307"/></h1>
<p><span class="koboSpan" id="kobo.3.1">Hexagonal architecture is just one of several software architecture approaches. </span><span class="koboSpan" id="kobo.3.2">Among these approaches, one that</span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.4.1"> stands out is the so-called layered architecture, which has been widely used in enterprise software development for years. </span><span class="koboSpan" id="kobo.4.2">Its vast adoption is because it’s reasonably simple to apply the layered architecture principles and also because this is one of the patterns that may naturally emerge when there is no conscious decision made regarding which architectural approach to use for </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">new projects.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Understanding layered architecture and being aware of its differences when comparing it to hexagonal architecture is good to help us make more informed decisions regarding which software architecture approach to use when starting or refactoring a software project. </span><span class="koboSpan" id="kobo.6.2">That’s why in this chapter, we will begin by reviewing layered architecture ideas. </span><span class="koboSpan" id="kobo.6.3">Then, based on those ideas, we will implement a simple application to learn how to apply the layered architecture concepts. </span><span class="koboSpan" id="kobo.6.4">We will then proceed by refactoring that simple application using hexagonal architecture ideas so we can better grasp the contrasts between the two architectures. </span><span class="koboSpan" id="kobo.6.5">Finally, we will finish by assessing the advantages and disadvantages of hexagonal and </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">layered architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Reviewing the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">layered architecture</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Creating an application using the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">layered architecture</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Rewriting a layered architecture application into a </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">hexagonal one</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Assessing the benefits and disadvantages of hexagonal and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">layered architectures</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">By the end of this chapter, you will understand the difference between layered and hexagonal architecture, enabling you to make better, informed decisions on your next </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">software project.</span></span></p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.23.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.25.1"> installed on your computer. </span><span class="koboSpan" id="kobo.25.2">They are available for the Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.31.1">Reviewing the layered architecture</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Layered architecture, in my view, may emerge</span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.33.1"> when a group of developers in charge of a project do not stop to think about which kind of architecture is more suitable for the software they want to develop. </span><span class="koboSpan" id="kobo.33.2">I have observed this scenario in projects where without conscious team planning, the code structure would evolve to some level of separation of concerns where the presentation/API code would be somewhat isolated from the business and infrastructure code. </span><span class="koboSpan" id="kobo.33.3">You would not see core business logic in the classes responsible for providing a REST endpoint, for example. </span><span class="koboSpan" id="kobo.33.4">You may notice, in such projects, packages named </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">model</span></strong><span class="koboSpan" id="kobo.35.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">repository</span></strong><span class="koboSpan" id="kobo.37.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">service</span></strong><span class="koboSpan" id="kobo.39.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">controller</span></strong><span class="koboSpan" id="kobo.41.1"> as hints to a system based on the layered architecture ideas. </span><span class="koboSpan" id="kobo.41.2">They are hints because each of those packages usually represents an intent to allocate a specific software responsibility. </span><span class="koboSpan" id="kobo.41.3">The code present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">model</span></strong><span class="koboSpan" id="kobo.43.1"> package is used to represent database entities. </span><span class="koboSpan" id="kobo.43.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">repository</span></strong><span class="koboSpan" id="kobo.45.1"> package contains classes showing which kind of database operations the system can do based on the model entities. </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">service</span></strong><span class="koboSpan" id="kobo.47.1"> is a package where some business logic is executed over the data retrieved from the database using classes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">repository</span></strong><span class="koboSpan" id="kobo.49.1"> package. </span><span class="koboSpan" id="kobo.49.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">controller</span></strong><span class="koboSpan" id="kobo.51.1"> package contains classes exposing API endpoints to allow triggering one of the supported </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">application behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">As a form of layered architecture, we can see the code structure based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">model</span></strong><span class="koboSpan" id="kobo.55.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">repository</span></strong><span class="koboSpan" id="kobo.57.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">service</span></strong><span class="koboSpan" id="kobo.59.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">controller</span></strong><span class="koboSpan" id="kobo.61.1"> packages. </span><span class="koboSpan" id="kobo.61.2">Each package represents a layer with its responsibility that depends directly on the code from the package/layer that comes next or is below it. </span><span class="koboSpan" id="kobo.61.3">The controller depends on the service, which depends on the repository, which depends on the model. </span><span class="koboSpan" id="kobo.61.4">It’s not uncommon to see slight variations of this pattern where more layers are introduced, even though the general idea of downward dependency is always there. </span><span class="koboSpan" id="kobo.61.5">There may even be situations where a layer bypasses the next layer and relies on the classes from another layer. </span><span class="koboSpan" id="kobo.61.6">We can see how a backend application based on layered architecture is usually structured in the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.63.1"><img alt="Figure 15.1 – Layered architecture example" src="image/B19777_15_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.64.1">Figure 15.1 – Layered architecture example</span></p>
<p><span class="koboSpan" id="kobo.65.1">Instead of a presentation</span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.66.1"> layer, which would make sense if we were developing a web application, we have the API layer containing classes with REST endpoint logic. </span><span class="koboSpan" id="kobo.66.2">These classes are responsible for receiving the client request and triggering some application behavior in the service layer. </span><span class="koboSpan" id="kobo.66.3">This layer usually contains business logic that depends on external data. </span><span class="koboSpan" id="kobo.66.4">To handle external data, we have the data layer containing classes responsible for getting, persisting, and mapping external data. </span><span class="koboSpan" id="kobo.66.5">I don’t use the term persistence here to avoid implying the data source will be a database. </span><span class="koboSpan" id="kobo.66.6">The data can come from anywhere, including </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">a database.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">I have seen this pattern being employed in a few software development projects in large enterprises and start-ups. </span><span class="koboSpan" id="kobo.68.2">Curiously, if you ask developers involved in the project which architecture they used, they would probably say no specific architecture was applied, even though their code suggests the software was developed based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">layered architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Because layered architecture has existed for many years, it has kind of become a standard architecture for enterprise software projects. </span><span class="koboSpan" id="kobo.70.2">The idea of segregating responsibilities based on high-level system</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.71.1"> components seems to accommodate a good deal of the necessities we see in enterprise software, usually because this kind of software follows, most of the time, the same pattern of receiving input, getting data from somewhere, performing data processing, and then persisting or sending that data to another system. </span><span class="koboSpan" id="kobo.71.2">Given that many enterprise applications are developed following this pattern, what significantly changes between those applications is the data-processing part containing the business rules specific to a given application. </span><span class="koboSpan" id="kobo.71.3">The other parts may also change but not so considerably because how APIs are exposed and how data is retrieved/persisted may be standardized across different applications of the same organization, especially when the same team maintains </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">those applications.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Although layered architecture helps to provide some level of decoupling, it does not entirely avoid situations where changes in one layer may also require changes in another. </span><span class="koboSpan" id="kobo.73.2">When you have the business/service layer depending on the persistence layer, changes on the latter can impact the former. </span><span class="koboSpan" id="kobo.73.3">Next, I will share an experience using the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">layered architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">I recall a situation where the team I was working with decided to change the database technology in the middle of the project. </span><span class="koboSpan" id="kobo.75.2">During the implementation, it turned out that an ORM feature available for the previous database technology was unavailable to the new database. </span><span class="koboSpan" id="kobo.75.3">The problem was that the system had some business rules that relied directly on that missing feature from the new database. </span><span class="koboSpan" id="kobo.75.4">Ultimately, we had to adjust our approach by significantly changing how those business rules would be processed. </span><span class="koboSpan" id="kobo.75.5">This application, in particular, evolved without a team discussion on what architectural principles should have been followed. </span><span class="koboSpan" id="kobo.75.6">Eventually, the project evolved into something with layered </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">architecture characteristics.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">To better understand the layered</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.78.1"> architecture, let’s develop an application based on this </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">architecture idea.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.80.1">Creating an application using the layered architecture</span></h1>
<p><span class="koboSpan" id="kobo.81.1">In the previous section, we saw how a backend</span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.82.1"> application based on layered architecture</span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.83.1"> can be structured. </span><span class="koboSpan" id="kobo.83.2">Our example has three layers: API, service, and data. </span><span class="koboSpan" id="kobo.83.3">Following this structure, we will develop a simple user application that allows user registration and login. </span><span class="koboSpan" id="kobo.83.4">We will implement the data layer, then proceed to the service layer, and then the API layer. </span><span class="koboSpan" id="kobo.83.5">The application will be based on Quarkus, so we can rely on the framework to provide REST endpoints and connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">a database.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.85.1">Implementing the data layer</span></h2>
<p><span class="koboSpan" id="kobo.86.1">The data layer is responsible</span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.87.1"> for allowing getting, persisting, and mapping external data. </span><span class="koboSpan" id="kobo.87.2">We rely on a database for the user application to store </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">user information:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.89.1">So, let’s start by preparing Quarkus to enable us to use an H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">in-memory database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.91.1">
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:mem:default;DB_CLO
  SE_DELAY=-1.;NON_KEYWORDS=user
quarkus.hibernate-orm.database.generation=drop-and-
  create</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.92.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">quarkus.datasource.db-kind</span></strong><span class="koboSpan" id="kobo.94.1"> property tells Quarkus to use the H2 driver. </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">quarkus.datasource.jdbc.url</span></strong><span class="koboSpan" id="kobo.96.1"> configures an in-memory database that will live while the application is running. </span><span class="koboSpan" id="kobo.96.2">Finally, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">quarkus.hibernate-orm.database.generation</span></strong><span class="koboSpan" id="kobo.98.1"> to allow the automatic creation of the database on the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">application startup.</span></span></p></li> <li><span class="koboSpan" id="kobo.100.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">dev.davivieira.layered.data.entity</span></strong><span class="koboSpan" id="kobo.102.1"> package, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">User</span></strong><span class="koboSpan" id="kobo.104.1"> ORM </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">entity</span></span><span class="No-Break"><a id="_idIndexMarker975"/></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.107.1">
package dev.davivieira.layered.data.entity;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;
@Entity
@Getter
@Setter
@RequiredArgsConstructor
@NoArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy =
    GenerationType.IDENTITY)
    private Long id;
    @NonNull
    private String email;
    @NonNull
    private String password;
}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">User</span></strong><span class="koboSpan" id="kobo.109.1"> is an ORM entity</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.110.1"> because the Jakarta </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">@Entity</span></strong><span class="koboSpan" id="kobo.112.1"> annotation is placed on top of the class. </span><span class="koboSpan" id="kobo.112.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">id</span></strong><span class="koboSpan" id="kobo.114.1"> attribute is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">@GeneratedValue</span></strong><span class="koboSpan" id="kobo.116.1">, so the underlying database generates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">id</span></strong><span class="koboSpan" id="kobo.118.1"> value. </span><span class="koboSpan" id="kobo.118.2">We finished the implementation with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">email</span></strong><span class="koboSpan" id="kobo.120.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">password</span></strong><span class="koboSpan" id="kobo.122.1"> attributes required for new user registration </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">and login.</span></span></p></li> <li><span class="koboSpan" id="kobo.124.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">dev.davivieira.layered.data.repository</span></strong><span class="koboSpan" id="kobo.126.1"> package, we create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">UserRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.129.1">
package dev.davivieira.layered.data.repository;
import dev.davivieira.layered.data.entity.User;
import io.quarkus.hibernate.orm.
</span><span class="koboSpan" id="kobo.129.2">  panache.PanacheRepository;
import jakarta.enterprise.context.ApplicationScoped;
import java.util.Optional;
@ApplicationScoped
public class UserRepository implements PanacheReposi
  tory&lt;User&gt; {
    public Optional&lt;User&gt; findByEmail(String email) {
        return find("email",
        email).firstResultOptional();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.130.1">By implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">PanacheRepository</span></strong><span class="koboSpan" id="kobo.132.1">, we get predefined standard database operations to allow fetching, saving, and deleting data. </span><span class="koboSpan" id="kobo.132.2">In addition to those predefined operations, we create </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">findByEmail</span></strong><span class="koboSpan" id="kobo.134.1"> to search </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">User</span></strong><span class="koboSpan" id="kobo.136.1"> entities using the email address. </span><span class="koboSpan" id="kobo.136.2">If no data is found, it returns an </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">empty </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Optional</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.140.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">User</span></strong><span class="koboSpan" id="kobo.142.1"> entity and repository comprise the data layer, allowing us to persist and retrieve user data</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.143.1"> from a database. </span><span class="koboSpan" id="kobo.143.2">Let’s now implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">service layer.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.145.1">Implementing the service layer</span></h2>
<p><span class="koboSpan" id="kobo.146.1">We need a place to put the logic</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.147.1"> to check whether the email address already exists when registering a new user or validating the user credentials during the login. </span><span class="koboSpan" id="kobo.147.2">The service layer is where we place </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">that logic:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.149.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">dev.davivieira.layered.service</span></strong><span class="koboSpan" id="kobo.151.1"> package, we start the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">UserService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
@ApplicationScoped
public class UserService {
    @Inject
    UserRepository userRepository;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.155.1">We inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">UserRepository</span></strong><span class="koboSpan" id="kobo.157.1"> to enable the service class to handle external data through the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">data layer.</span></span></p></li> <li><span class="koboSpan" id="kobo.159.1">We won’t map client requests directly to an ORM entity when receiving them. </span><span class="koboSpan" id="kobo.159.2">Instead, we map those requests to a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">UserDto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.162.1">
public record UserDto (String email, String password)
  {}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.163.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">record</span></strong><span class="koboSpan" id="kobo.165.1"> class will automatically</span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.166.1"> generate the class constructor, getters, and setters for the email and </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">password fields.</span></span></p></li> <li><span class="koboSpan" id="kobo.168.1">Continuing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">UserService</span></strong><span class="koboSpan" id="kobo.170.1"> class, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">createAccount</span></strong><span class="koboSpan" id="kobo.172.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">isEmailAlreadyUsed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> methods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.175.1">
@Transactional
public String createAccount(UserDto userDto) throws
  Exception {
    isEmailAlreadyUsed(userDto.email());
    var user = new User(userDto.email(),
    userDto.password());
    userRepository.persist(user);
    return "User successfully created";
}
private void isEmailAlreadyUsed(String email) throws
  Exception {
    if(userRepository.findByEmail(email).isPresent()){
        throw new Exception("Email address already
                             exist");
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">createAccount</span></strong><span class="koboSpan" id="kobo.178.1"> method receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">UserDto</span></strong><span class="koboSpan" id="kobo.180.1"> parameter. </span><span class="koboSpan" id="kobo.180.2">We get the email from this parameter and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">isEmailAlreadyUsed</span></strong><span class="koboSpan" id="kobo.182.1"> method, which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">findByEmail</span></strong><span class="koboSpan" id="kobo.184.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">UserRepository</span></strong><span class="koboSpan" id="kobo.186.1"> to check whether the email </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">already exists.</span></span></p></li> <li><span class="koboSpan" id="kobo.188.1">To finish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">UserService</span></strong><span class="koboSpan" id="kobo.190.1"> implementation, we create</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.191.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">login</span></strong><span class="koboSpan" id="kobo.193.1"> and  </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">isThePasswordValid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1"> methods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
public String login(UserDto userDto) {
    var optionalUser =
    userRepository.findByEmail(userDto.email());
    if (optionalUser.isPresent()) {
        var user = optionalUser.get();
        var isThePasswordValid =
        isThePasswordValid(user, userDto);
        if (isThePasswordValid) {
            return "Authenticated with success";
        } else {
            return "Invalid credentials";
        }
    } else {
        return "Invalid credentials";
    }
}
private boolean isThePasswordValid(User user, UserDto
  userDto) {
    return
    user.getPassword().equals(userDto.password());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.197.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">login</span></strong><span class="koboSpan" id="kobo.199.1"> method, we get the email from </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">UserDto</span></strong><span class="koboSpan" id="kobo.201.1"> and use it to check whether the user account exists for that email. </span><span class="koboSpan" id="kobo.201.2">If not, we return the invalid credentials message. </span><span class="koboSpan" id="kobo.201.3">Otherwise, we check whether the password from </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">UserDto</span></strong><span class="koboSpan" id="kobo.203.1"> matches the password from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">User</span></strong><span class="koboSpan" id="kobo.205.1"> entity retrieved from the database </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">UserRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.209.1">Creating a user account and validating</span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.210.1"> the user credentials for login are the responsibilities of the service layer. </span><span class="koboSpan" id="kobo.210.2">It accomplishes that by relying on the data layer to get user data from the database. </span><span class="koboSpan" id="kobo.210.3">Now we need to expose an API to allow clients to send requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">our application.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.212.1">Implementing the API layer</span></h2>
<p><span class="koboSpan" id="kobo.213.1">The last layer, the API layer, is where </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.214.1">we implement REST endpoints for user creation and user </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">login requests:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.216.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">dev.davivieira.layered.api</span></strong><span class="koboSpan" id="kobo.218.1"> package, we start the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">UserEndpoint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
@Path("/user")
public class UserEndpoint {
    @Inject
    UserService userService;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.222.1">We inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">UserService</span></strong><span class="koboSpan" id="kobo.224.1"> to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">createAccount</span></strong><span class="koboSpan" id="kobo.226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">login</span></strong><span class="koboSpan" id="kobo.228.1"> methods from the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">service layer.</span></span></p></li> <li><span class="koboSpan" id="kobo.230.1">We first define the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">register</span></span><span class="No-Break"><a id="_idIndexMarker983"/></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> endpoint:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/register")
public String register(UserDto userDto) throws Excep
  tion {
    return userService.createAccount(userDto);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.234.1">That is a straightforward REST endpoint implementation, receiving a JSON payload mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">UserDto</span></strong><span class="koboSpan" id="kobo.236.1"> and returning plain text. </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">UserDto</span></strong><span class="koboSpan" id="kobo.238.1"> is passed directly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">createAccount</span></strong><span class="koboSpan" id="kobo.240.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">UserService</span></strong><span class="koboSpan" id="kobo.242.1"> class on the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">service layer.</span></span></p></li> <li><span class="koboSpan" id="kobo.244.1">Finally, we define the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">login endpoint:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/login")
public String login(UserDto userDto) {
    return userService.login(userDto);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.247.1">As we did in the previous register endpoint, here we are simply exposing the REST endpoint and passing the DTO directly to the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">service layer.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.249.1">The API layer is responsible only for exposing the REST endpoints and nothing more. </span><span class="koboSpan" id="kobo.249.2">We avoid putting any business logic on this layer to ensure we separate the concerns among</span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.250.1"> this and the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">other layers.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.252.1">Let’s see now how we can test this </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">layered application.</span></span></p></li> </ol>
<h2 id="_idParaDest-248"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.254.1">Testing the layered application</span></h2>
<p><span class="koboSpan" id="kobo.255.1">We will test the service</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.256.1"> layer by focusing only on the logic that checks whether the email already exists and the credentials are valid. </span><span class="koboSpan" id="kobo.256.2">The following is what one of the tests would </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
@QuarkusTest
public class UserServiceTest {
    @Inject
    UserService userService;
    @Test
    public void
     givenTheUserEmailAlreadyExistsAnExceptionIsThrown()
     throws Exception {
        var userDto = new UserDto("test@davivieira.dev",
        "password");
        userService.createAccount(userDto);
        Assertions.assertThrows(
                Exception.class,
                ()-&gt; userService.createAccount(userDto)
        );
    }
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.259.1">The preceding test checks whether an exception is thrown when the email address already exists. </span><span class="koboSpan" id="kobo.259.2">Note that for this test to work, the service layer depends on the data layer, which requires a database to persist data. </span><span class="koboSpan" id="kobo.259.3">So, the core system logic, present in the service layer, depends directly on the data layer that is composed of the ORM entity and repository classes. </span><span class="koboSpan" id="kobo.259.4">How we handle external data dictates what we can do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">service layer.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Suppose we want to avoid creating this dependency, where the core system’s logic depends on and sits so close to data-handling code. </span><span class="koboSpan" id="kobo.261.2">In that case, hexagonal architecture can help us with a different arrangement where the core system’s logic does not depend on anything and provides the flexibility to evolve that core logic without any concerns regarding how external data is handled. </span><span class="koboSpan" id="kobo.261.3">Let’s see how that can be done by refactoring our layered architecture application</span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.262.1"> into a </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">hexagonal one.</span></span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.264.1">Refactoring a layered architecture application into a hexagonal one</span></h1>
<p><span class="koboSpan" id="kobo.265.1">By now, we have</span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.266.1"> an idea of how to implement</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.267.1"> a layered architecture application. </span><span class="koboSpan" id="kobo.267.2">Let’s refactor this application we have just developed into a hexagonal one. </span><span class="koboSpan" id="kobo.267.3">This exercise will highlight the significant differences between the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">two architectures.</span></span></p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.269.1">Implementing the Domain hexagon</span></h2>
<p><span class="koboSpan" id="kobo.270.1">The Domain hexagon</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.271.1"> contains data and behaviors with core system logic. </span><span class="koboSpan" id="kobo.271.2">In the following steps, we’ll see how to refactor some data and behaviors from the layered application using the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">hexagonal approach:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.273.1">While using the layered architecture, we started developing the system by implementing the data layer. </span><span class="koboSpan" id="kobo.273.2">We’ll refactor it into a Domain hexagon containing only a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">User</span></strong><span class="koboSpan" id="kobo.275.1"> domain </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">entity class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.277.1">
@Getter
@Setter
@RequiredArgsConstructor
@NoArgsConstructor
public class User {
    private Long id;
    @NonNull
    private String email;
    @NonNull
    private String password;
    public User(Long id, String email, String
    password) {
        this.id = id;
        this.email = email;
        this.password = password;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.278.1">The major difference</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.279.1"> is that this entity is not an ORM used to map database entities. </span><span class="koboSpan" id="kobo.279.2">This entity is a POJO that contains not only data but also behaviors. </span><span class="koboSpan" id="kobo.279.3">Let’s implement </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">these behaviors.</span></span></p></li> <li><span class="koboSpan" id="kobo.281.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">User</span></strong><span class="koboSpan" id="kobo.283.1"> entity class, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">isEmailAlreadyUsed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.286.1">
public void isEmailAlreadyUsed(Optional&lt;User&gt; op
  tionalUser) throws Exception {
    if(optionalUser.isPresent()) {
        throw new Exception(
        "Email address already exist");
    }
}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">isEmailAlreadyUsed</span></strong><span class="koboSpan" id="kobo.288.1"> receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Optional&lt;User&gt;</span></strong><span class="koboSpan" id="kobo.290.1"> parameter. </span><span class="koboSpan" id="kobo.290.2">If the value is present, then we throw </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">an exception.</span></span></p></li> <li><span class="koboSpan" id="kobo.292.1">To finish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">User</span></strong><span class="koboSpan" id="kobo.294.1"> entity class</span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.295.1"> implementation, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">login</span></strong><span class="koboSpan" id="kobo.297.1"> and   </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">isPasswordValid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1"> methods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
public String login(Optional&lt;User&gt; optionalUser) {
    if (optionalUser.isPresent()) {
        var user = optionalUser.get();
        var isThePasswordValid =
        isThePasswordValid(user);
        if (isThePasswordValid) {
            return "Authenticated with success";
        } else {
            return "Invalid credentials";
        }
    } else {
        return "Invalid credentials";
    }
}
private boolean isThePasswordValid(User user) {
    return user.getPassword().equals(this.password);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.301.1">The logic is similar to the methods we implemented in the layered application, but instead of using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">UserDto</span></strong><span class="koboSpan" id="kobo.303.1"> class, we operate directly on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">User</span></strong><span class="koboSpan" id="kobo.305.1"> domain </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">entity class.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.307.1">Following a DDD approach, we pushed logic from the Service Layer into the Domain hexagon in the hexagonal application. </span><span class="koboSpan" id="kobo.307.2">Methods containing core system logic that used to be on the service layer are now part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">User</span></strong><span class="koboSpan" id="kobo.309.1"> domain entity class in the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">Domain hexagon.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.311.1">The significant difference </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.312.1">here is that the Domain hexagon does not depend on anything. </span><span class="koboSpan" id="kobo.312.2">In contrast, in the layered architecture approach, the Service layer containing the core system logic depends on the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">data layer.</span></span></p></li> </ol>
<h2 id="_idParaDest-251"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.314.1">Implementing the Application hexagon</span></h2>
<p><span class="koboSpan" id="kobo.315.1">We implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">User</span></strong><span class="koboSpan" id="kobo.317.1"> domain entity class</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.318.1"> on the Domain hexagon containing core logic to handle user registration and login. </span><span class="koboSpan" id="kobo.318.2">We need to define how, in an agnostic way, the behaviors will be triggered and how external data will be retrieved. </span><span class="koboSpan" id="kobo.318.3">By agnostic, I mean expressing the need for external data without going into the technology details to provide such data. </span><span class="koboSpan" id="kobo.318.4">We employ use cases and input and output ports in the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">Application hexagon:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.320.1">Let’s start by defining the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">UserAccessUserCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
public interface UserAccessUseCase {
    String createAccount(User user) throws Exception;
    String login(User user);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.324.1">Creating an account and being able to log in are the two use cases supported by </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">our application.</span></span></p></li> <li><span class="koboSpan" id="kobo.326.1">To allow handling external data, we define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">UserAccessOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.329.1">
public interface UserAccessOutputPort {
    Optional&lt;User&gt; findByEmail(String email);
    void persist(User user);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.330.1">This interface is just a POJO containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">findByEmail</span></strong><span class="koboSpan" id="kobo.332.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">persist</span></strong><span class="koboSpan" id="kobo.334.1"> method definitions. </span><span class="koboSpan" id="kobo.334.2">In the layered architecture</span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.335.1"> approach, we had these methods as part of the repository class in the data layer. </span><span class="koboSpan" id="kobo.335.2">In the repository class, it was implied that the data would come from a database. </span><span class="koboSpan" id="kobo.335.3">In the hexagonal approach, we express, through the output port interface, that the data can come </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">from anywhere.</span></span></p></li> <li><span class="koboSpan" id="kobo.337.1">We finish by implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">UserAccessInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
@ApplicationScoped
public class UserAccessInputPort implements UserAcces
  sUseCase {
@Inject
UserAccessOutputPort userAccessOutputPort;
@Override
public String createAccount(User user) throws
Exception {
        user.isEmailAlreadyUsed
          (userAccessOutputPort.findByEmail
            (user.getEmail()));
    userAccessOutputPort.persist(user);
    return "User successfully created";
}
@Override
public String login(User user) {
    return
    user.login(
    userAccessOutputPort
    .findByEmail(user.getEmail()));
   }
}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">UserAccessInputPort</span></strong><span class="koboSpan" id="kobo.342.1"> implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">UserAccessUseCase</span></strong><span class="koboSpan" id="kobo.344.1"> interface. </span><span class="koboSpan" id="kobo.344.2">Note we are injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">UserAccessOutputPort</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">It’s through this output port that the input port will handle external data. </span><span class="koboSpan" id="kobo.346.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">createAccount</span></strong><span class="koboSpan" id="kobo.348.1"> method checks whether the email already exists by relying on the logic provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">isEmailAlreadyUsed</span></strong><span class="koboSpan" id="kobo.350.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">User</span></strong><span class="koboSpan" id="kobo.352.1"> domain entity class. </span><span class="koboSpan" id="kobo.352.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">login</span></strong><span class="koboSpan" id="kobo.354.1"> method also relies on the Domain hexagon by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">login</span></strong><span class="koboSpan" id="kobo.356.1"> method present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">User</span></strong><span class="koboSpan" id="kobo.358.1"> domain </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">entity class.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.360.1">The Application hexagon</span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.361.1"> allowed us to express how the system should handle external data in conjunction with the core system’s logic from the Domain hexagon. </span><span class="koboSpan" id="kobo.361.2">Contrary to what we did in the layered architecture approach, the core system logic and external data handling have been defined without specifying whether the data is coming from a database or </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">somewhere else.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">This approach of expressing, through</span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.364.1"> output ports, what data the system needs without exposing how the system will get that data is a significant difference between layered and </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">hexagonal architecture.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.366.1">Implementing the Framework hexagon</span></h2>
<p><span class="koboSpan" id="kobo.367.1">The Application hexagon</span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.368.1"> orchestrates external data with core system logic from the Domain hexagon. </span><span class="koboSpan" id="kobo.368.2">Still, we need to provide a way to get that external data. </span><span class="koboSpan" id="kobo.368.3">In the layered architecture approach, the data layer allowed us to get data from a database, and the API layer exposed REST endpoints. </span><span class="koboSpan" id="kobo.368.4">In the Framework hexagon, we use input adapters to provide the REST endpoints and output adapters to get data from a database. </span><span class="koboSpan" id="kobo.368.5">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">implement it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.370.1">We start with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">UserAccessInputAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
@Path("/user")
public class UserAccessInputAdapter {
    @Inject
    UserAccessUseCase userAccessUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.374.1">We inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">UserAccessUseCase</span></strong><span class="koboSpan" id="kobo.376.1"> to access the operations available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">Application hexagon.</span></span></p></li> <li><span class="koboSpan" id="kobo.378.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">UserAccessInputAdapter</span></strong><span class="koboSpan" id="kobo.380.1"> class, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">register</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/register")
public String register(UserDto userDto) throws Excep
  tion {
    return userAccessUseCase.createAccount(new
    User(userDto.email(), userDto.password()));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.384.1">We map </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">UserDto</span></strong><span class="koboSpan" id="kobo.386.1"> directly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">User</span></strong><span class="koboSpan" id="kobo.388.1"> domain entity class. </span><span class="koboSpan" id="kobo.388.2">Then, we pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">createAccount</span></strong><span class="koboSpan" id="kobo.390.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">UserAccessUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.394.1">To finish the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">UserAccessInputAdapter</span></strong><span class="koboSpan" id="kobo.396.1"> implementation, we create</span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.397.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">login</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/login")
public String login(UserDto userDto) {
    return userAccessUseCase.login(new
    User(userDto.email(), userDto.password()));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.401.1">As we did in the register method, we map </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">UserDto</span></strong><span class="koboSpan" id="kobo.403.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">User</span></strong><span class="koboSpan" id="kobo.405.1"> domain entity class and then pass it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">login</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1"> method.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.408.1">We still need to implement the output adapter. </span><span class="koboSpan" id="kobo.408.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">do that.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">UserAccessOutputAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.411.1">implements </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">UserAccessOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
@ApplicationScoped
public class UserAccessOutputAdapter implements
  UserAccessOutputPort {
    @Inject
    UserRepository userRepository;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.415.1">By injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">UserRepository</span></strong><span class="koboSpan" id="kobo.417.1">, we are effectively turning this output adapter into one that deals </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">with databases.</span></span></p></li> <li><span class="koboSpan" id="kobo.419.1">We need to implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">findByEmail</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
@Override
public Optional&lt;User&gt; findByEmail(String email) {
    return UserMapper
           .userDataToDomain(
           userRepository.findByEmail(email));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.423.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">UserRepository</span></strong><span class="koboSpan" id="kobo.425.1"> when implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">findByEmail</span></strong><span class="koboSpan" id="kobo.427.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">UserAccessOutputPort</span></strong><span class="koboSpan" id="kobo.429.1"> interface. </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">UserMapper</span></strong><span class="koboSpan" id="kobo.431.1"> is a helper class to map the ORM entity class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">UserData</span></strong><span class="koboSpan" id="kobo.433.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">User</span></strong><span class="koboSpan" id="kobo.435.1"> domain </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">entity class.</span></span></p></li> <li><span class="koboSpan" id="kobo.437.1">Finally, we implement</span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.438.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">persist</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.441.1">
@Transactional
@Override
public void persist(User user) {
    var userData = UserMapper.userDomainToData(user);
    userRepository.persist(userData);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.442.1">We again use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">UserMapper</span></strong><span class="koboSpan" id="kobo.444.1"> helper class to map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">User</span></strong><span class="koboSpan" id="kobo.446.1"> domain entity class into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">UserData</span></strong><span class="koboSpan" id="kobo.448.1"> ORM entity class. </span><span class="koboSpan" id="kobo.448.2">That is required because we cannot persist the domain entity. </span><span class="koboSpan" id="kobo.448.3">So, we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">UserData</span></strong><span class="koboSpan" id="kobo.450.1"> ORM entity class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">persist</span></strong><span class="koboSpan" id="kobo.452.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">UserRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.456.1">Introducing the Framework hexagon allows clients to access the system’s API provided by input adapters and connect the hexagonal application to an external data source, a database in our case. </span><span class="koboSpan" id="kobo.456.2">The input adapter from the Framework hexagon does not differ much when compared to the REST endpoints provided by the API layer. </span><span class="koboSpan" id="kobo.456.3">Both approaches expose similar methods, rely on DTO classes to map client requests, and send them downstream to either the service layer or the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">Application hexagon.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.458.1">What significantly changes is how external data is handled. </span><span class="koboSpan" id="kobo.458.2">In the hexagonal approach, the output adapter implements an output port, which provides flexibility with the output port abstraction. </span><span class="koboSpan" id="kobo.458.3">A new output adapter can be implemented without disrupting the core system’s logic. </span><span class="koboSpan" id="kobo.458.4">On the other hand, there is no such abstraction in the layered architecture approach. </span><span class="koboSpan" id="kobo.458.5">The service layer relies directly on the repository classes</span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.459.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">data layer.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.461.1">Let’s see now how we can test the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">hexagonal application.</span></span></p></li> </ol>
<h2 id="_idParaDest-253"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.463.1">Testing the hexagonal application</span></h2>
<p><span class="koboSpan" id="kobo.464.1">Because the core system’s logic is part of the Domain</span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.465.1"> hexagon, we can create unit tests to validate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">User</span></strong><span class="koboSpan" id="kobo.467.1"> domain entity behaviors. </span><span class="koboSpan" id="kobo.467.2">The following is what one of those unit tests would </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
@QuarkusTest
public class UserServiceTest {
@Test
public void givenTheUserEmailAlreadyExistsAnException
  IsThrown() {
    var user = new User("test@davivieira.dev", "password");
    var optionalUser = Optional.of(user);
    Assertions.assertThrows(
            Exception.class,
            ()-&gt; user.isEmailAlreadyUsed(optionalUser)
    );
}
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.470.1">In the layered approach, we had to inject a service class and provide a database to test whether the email was already being used. </span><span class="koboSpan" id="kobo.470.2">In the hexagonal approach, we are testing the logic directly from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">User</span></strong><span class="koboSpan" id="kobo.472.1"> domain entity class. </span><span class="koboSpan" id="kobo.472.2">Moving the core system logic from the service layer, in the layered architecture, to the Domain hexagon in the hexagonal architecture provided the flexibility</span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.473.1"> to run more constrained tests without dependencies on </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">external resources.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">Based on our implementation of the same application using layered and hexagonal architecture, let’s assess the pros and cons of </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">each architecture.</span></span></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.477.1">Assessing the benefits and disadvantages of hexagonal and layered architectures</span></h1>
<p><span class="koboSpan" id="kobo.478.1">The structure of a layered</span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.479.1"> application is more straightforward than a hexagonal</span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.480.1"> one. </span><span class="koboSpan" id="kobo.480.2">In the layered approach, we have the service layer depending directly on the data layer. </span><span class="koboSpan" id="kobo.480.3">This dependence implies that the core system logic relies on the ORM entity and repository classes from the data layer. </span><span class="koboSpan" id="kobo.480.4">Contrary</span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.481.1"> to the hexagonal approach, there is no abstraction</span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.482.1"> regarding external data access, and the core system logic is embedded with code that handles external data. </span><span class="koboSpan" id="kobo.482.2">Is this good or bad? </span><span class="koboSpan" id="kobo.482.3">As with most things in software development, it depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">your context.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">The experience I shared at the beginning of the chapter, where my team had to change the database technology in the middle of the project, is an example where employing the hexagonal approach would have been beneficial. </span><span class="koboSpan" id="kobo.484.2">If you expect considerable requirement changes in your project, then the hexagonal approach may be a good idea to make it easier for your application to accommodate those changes. </span><span class="koboSpan" id="kobo.484.3">Otherwise, the layered architecture is a good choice, given it’s fast to bootstrap a new application with </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">such architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">The layered architecture</span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.487.1"> provides a simple and fast approach to developing new applications. </span><span class="koboSpan" id="kobo.487.2">Most backend developers are acquainted with having an API layer to expose endpoints, a service layer containing core system logic, and the data layer usually providing database access. </span><span class="koboSpan" id="kobo.487.3">So, it’s a small undertaking to onboard new team members to maintain applications based on this architecture. </span><span class="koboSpan" id="kobo.487.4">The trade-off is that this architecture offers less flexibility</span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.488.1"> when infrastructure components need </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">On the other hand, the hexagonal</span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.491.1"> architecture allows us to decouple the core system logic code from the infrastructure/external data-handling code. </span><span class="koboSpan" id="kobo.491.2">Still, this decoupling does not come for free. </span><span class="koboSpan" id="kobo.491.3">Hexagonal architecture</span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.492.1"> slightly increases the code complexity due to additional components, such as the ports, use cases, and adapters we use to ensure the decoupling. </span><span class="koboSpan" id="kobo.492.2">The major benefit is a change-tolerant application shielded from the unpredictability of unexpected system requirements. </span><span class="koboSpan" id="kobo.492.3">Onboarding new team members may represent an additional effort because hexagonal architecture is less widely used than its layered counterpart. </span><span class="koboSpan" id="kobo.492.4">Hence, people need more time to grasp the hexagonal approach ideas to start contributing to </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the project.</span></span></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.494.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.495.1">This chapter explored layered architecture and its differences from hexagonal architecture. </span><span class="koboSpan" id="kobo.495.2">We started by reviewing the purpose of layered architecture to provide some level of separation of concerns through logical layers containing code with specific responsibilities. </span><span class="koboSpan" id="kobo.495.3">After reviewing the idea of the layered approach, we dirtied our hands by implementing a simple user access application from scratch containing the API, service, and data layers. </span><span class="koboSpan" id="kobo.495.4">To highlight the differences between the layered and hexagonal architectures, we refactored the user access application to use the hexagonal approach. </span><span class="koboSpan" id="kobo.495.5">By doing so, we saw that the layered architecture does not entirely protect the application from major changes, such as those that touch on infrastructure components such as external data access handling. </span><span class="koboSpan" id="kobo.495.6">Finally, we assessed the advantages and disadvantages of the layered and hexagonal architectures, concluding that the layered one is a good choice when no significant project requirement changes are expected, and the hexagonal architecture is recommended when one needs a more change-tolerable application capable to accommodate considerable system changes, especially at the infrastructure level. </span><span class="koboSpan" id="kobo.495.7">In the next chapter, we will explore how SOLID principles can be used with </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">hexagonal architecture.</span></span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.497.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.498.1">Why would you choose layered architecture over hexagonal architecture in a </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">new project?</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">Although layered architecture provides some level of separation of concerns, it does not completely decouple core system logic from infrastructure </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">code. </span><span class="koboSpan" id="kobo.501.2">Why?</span></span></li>
<li><span class="koboSpan" id="kobo.502.1">In which scenario does using hexagonal architecture instead of layered architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">make sense?</span></span></li>
</ol>
<h1 id="_idParaDest-257"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.504.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.505.1">It provides a simple and fast way to bootstrap </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">new applications.</span></span></li>
<li><span class="koboSpan" id="kobo.507.1">Because the core system logic depends directly on the infrastructure code, usually when there is a service layer depending on a </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">data layer.</span></span></li>
<li><span class="koboSpan" id="kobo.509.1">When project requirements are expected to change, using hexagonal architecture allows the creation of change-tolerable applications capable of accommodating </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">those requirements.</span></span></li>
</ol>
</div>
</body></html>