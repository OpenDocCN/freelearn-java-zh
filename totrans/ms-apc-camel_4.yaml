- en: Chapter 4. Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw one of the key, and very helpful, Camel components—the
    processor. However, a processor is tied to Camel as it extends the `org.apache.camel.Processor`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in order to reuse some existing beans in your application, you
    have to wrap it in a processor, meaning additional code to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Camel has extensive support for POJO and beans, and bean model
    frameworks such as Spring or Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: How Camel looks for beans in different registries and the different registry
    implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Camel acts as a service activator to load the beans and bind the parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Camel annotations that enables *advanced* binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Camel language annotations that allow the usage of code in parameter binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to use a bean exactly as a processor, meaning, directly inline
    in a route. This allows us to use a lightweight, simple programming model, reusing
    existing components in Camel routes.
  prefs: []
  type: TYPE_NORMAL
- en: When a bean is used in a Camel route, the bean must be registered in a registry.
    Depending on which environment is running, Camel bootstraps different registries.
    When Camel works with beans, it looks them up in the registry to locate them.
  prefs: []
  type: TYPE_NORMAL
- en: The registry is defined at the `CamelContext` level. A registry is automatically
    created for you by Camel with the `CamelContext`. If you create the `CamelContext`
    manually, you can instantiate a registry and put this registry in the `CamelContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following registry implementations are shipped with Camel:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleRegistry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JndiRegistry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationContextRegistry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OsgiServiceRegistry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a look at each one of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleRegistry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SimpleRegistry` is a simple implementation, mostly used for testing where
    only a limited number of JDK classes are available. It''s basically a simple `Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to create an instance of `SimpleRegistry` by hand before using it.
    Camel doesn't load any `SimpleRegistry` by default.
  prefs: []
  type: TYPE_NORMAL
- en: The following example in (`chapter4a` folder) shows how to create a `SimpleRegistry`,
    register a bean, and use it in a Camel route.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we instantiate a `SimpleRegistry` that we put in a `CamelContext`
    that we create as well.
  prefs: []
  type: TYPE_NORMAL
- en: We populate the `SimpleRegistry` with a `SimpleBean`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CamelContext`, we add a route that calls the `SimpleBean`.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the execution, we embed this code in a main method that we execute
    via a Maven plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven `pom.xml` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/main/java` folder of the project, we create the `com.packt.camel.chapter4a`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this package, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: A `SimpleBean` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Main` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SimpleBean` class is pretty simple; it just says hello:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` class contains only the main method. It''s in this method that:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `SimpleRegistry`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We populate the registry with an instance of the `SimpleBean`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `CamelContext`, which uses our `SimpleRegistry`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create and add a route in the `CamelContext`. This route uses the `SimpleBean`
    from the registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This proves that the `SimpleRegistry` has been used by our `CamelContext`. Camel
    succeeded in looking for the bean in the registry and using it.
  prefs: []
  type: TYPE_NORMAL
- en: JndiRegistry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JndiRegistry` is an implementation that uses an existing **Java Naming and
    Directory** (**JNDI**) registry to look up beans. It''s the default registry used
    by Camel when using the Camel Java DSL.'
  prefs: []
  type: TYPE_NORMAL
- en: A `JndiRegistry` can be constructed using a JNDI InitialContext. It gives the
    flexibility to use existing JNDI InitialContext. Camel itself provides a simple
    `JndiContext` that you can use with the `JndiRegistry`.
  prefs: []
  type: TYPE_NORMAL
- en: We can illustrate the usage of a `JndiRegistry` by implementing an example very
    similar to the previous one (using a `SimpleRegistry`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven `pom.xml` is basically the same as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/main/java` directory of the project, we create the `com.packt.camel.chapter4b`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package contains a `SimpleBean` class similar to the one in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the main difference is in the `Main` class; we just replace the `SimpleRegistry`
    with a `JndiRegistry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution gives basically the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We switched to another registry implementation without any impact on the execution.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the `JndiRegistry` is implicitly created by Camel when you use
    the Java DSL for your route.
  prefs: []
  type: TYPE_NORMAL
- en: ApplicationContextRegistry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ApplicationContextRegistry` is a Spring-based implementation to look up beans
    from the Spring `ApplicationContext`. This implementation is automatically used
    when you are using Camel in a Spring environment.'
  prefs: []
  type: TYPE_NORMAL
- en: OsgiServiceRegistry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OsgiServiceRegistry` is a hook to the OSGi Service Registry. It''s used by
    Camel when running in OSGi environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating CompositeRegistry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These registries can be composed to create a multilayer registry using a `CompositeRegistry`.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `CompositeRegistry` by adding other registries.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the usage of a `CompositeRegistry`, we create a new example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the Maven `pom.xml` is basically the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/main/java` directory of the project, we have a `com.packt.camel.chapter4c`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We again have the sample `SimpleBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But this time, in the `Main` class, we create two registries that we gather
    in a composite registry.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the usage, we create two instances of the `SimpleBean` in each
    registry part of the composite, each instance having a different name in the registries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create two routes in the `CamelContext`; one route uses the `SimpleBean`
    instance, and the other uses the `otherBean` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at execution time, we can see that the two routes have been executed,
    each route using the `bean` instance in the registry. But actually, each instance
    is in a different registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Service activator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel acts as a service activator, using `BeanProcessor`, which sits between
    the caller and the actual bean.
  prefs: []
  type: TYPE_NORMAL
- en: The `BeanProcessor` is a special processor that converts the inbound exchange
    to a method invocation on a bean (POJO).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BeanProcessor` performs the following steps when called:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks up the bean in the registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It selects the method to invoke the bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It binds to the parameters of the selected method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It actually invokes the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It possibly handles any invocation errors that occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the method's reply as the body of the output message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bean and method bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During step 2, when the `BeanProcessor` selects the method to invoke, the message/method
    bindings can occur in different ways. Camel tries the following steps to resolve
    the bean method:'
  prefs: []
  type: TYPE_NORMAL
- en: If the incoming message (`in` message) contains the `CamelBeanMethodName` header,
    then this method is invoked, converting the `in` message body to the type of the
    method's argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can specify the method name directly in the route definition (on the bean
    endpoint).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the bean contains a method annotated with `@Handler`, then this method is
    invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the bean can be converted to a processor (containing the `process()` method),
    we fall back to the regular processor usage as seen in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the body of the in message can be converted to a `org.apache.camel.component.bean.BeanInvocation`
    component, then it's the result of the `getMethod()` method, which is used as
    the method name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the body type of the in message is used to find a matching method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Several exceptions can occur during the method lookup. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If Camel cannot find the method, it throws a `MethodNotFoundException` exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Camel cannot uniquely resolve a method (for instance, depending on the method
    argument), it throws an `AmbigiousMethodCallException` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before Camel invokes the selected method, it must convert the in message body
    to the parameter type required by the method. If this fails, a `NoTypeConversionAvailableException`
    exception is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the method name has been identified, Camel populates the method parameters;
    it's what we name method parameters binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Camel types are automatically bound, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.apache.camel.Exchange`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.camel.Message`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.camel.CamelContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.camel.TypeConverter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.camel.spi.Registry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Exception`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It means that you can directly use any of these types in the method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, your bean may contain a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Camel will provide the current exchange to your method.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Camel will try to convert the `in` message body as the first parameter
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: The return statement of the `bean` method is used to populate the body of the
    `in` message (in case the bean is used via the Camel bean component) or a header
    value (in case the bean is used via the `setHeader` Camel statement).
  prefs: []
  type: TYPE_NORMAL
- en: However, depending on your bean, you might have some ambiguity. Camel gives
    you fine-grained control of the method parameters by providing a set of annotations,
    which we will cover in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your bean, you might have some ambiguity. Camel gives you fine-grained
    control of the method parameters by providing a set of annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the annotations, you can describe the expected binding for both method
    binding and parameter binding.
  prefs: []
  type: TYPE_NORMAL
- en: For method binding, Camel provides the `@Handler` annotation. This annotation
    allows you to specify the method that Camel will use during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you may have the following bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In that case, Camel (without specifying the method to use in the route definition)
    will fail to find the method to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Handler` annotation removes the ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Camel also provides annotations for the method parameters binding. The `@Body`
    binds the parameter to the `in` message body. It allows to bind type like directly
    a POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Camel will use a converter to transform the actual in message body to the expected
    type of the method parameter. The `@ExchangeException` binds the parameter to
    the `Exchange` exception. This annotation allows you to directly inject the `Exchange`
    exception in your method. For instance, you can test if the exception is not null
    and react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Header` binds the parameter to a header of the in message. You can specify
    the header name on the annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `@Headers` binds the parameter to the `Map` containing all headers of the
    `in` message. It's especially interesting when you have to manipulate multiple
    headers in your method. Using this annotation, the parameter has to be of the
    `Map` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, like `@Headers` for the in message, the `@OutHeaders` annotation
    binds the parameter to the `Map` containing all headers of the `out` message.
    It''s especially interesting when you have to populate some headers (using the
    `put()` method on the Map):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `@Property` binds a property of the `Exchange`. As a reminder, the lifetime
    of a property is the `Exchange`, whereas a header is related to a message. The
    name of the property is directly provided on the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the headers, `@Properties` binds a property to the `Map` containing
    all the properties of the `Exchange`. Again, it''s interesting to add new properties
    to the method (using the `put()` method of the `Map`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Annotations for expression languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's also possible to directly leverage the languages supported by Camel to
    populate the method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following annotations are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Bean` binds another bean to the parameter. It allows you to inject a bean
    into a bean. Camel will look for the bean with the ID provided in the annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@BeanShell` binds the result of a bean method call to the parameter. BeanShell
    is a convenient language allowing you to explicitly call a bean method. The bean
    scripting is defined directly on the annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@Constant` binds a static String to the parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@EL` binds the result of an expression language (JUEL) to the parameter. The
    expression is defined in the annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@Groovy` binds the result of a Groovy expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@JavaScript` binds the result of a JavaScript expression to the parameter.
    The expression is defined in the annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@MVEL` binds the result of a MVEL expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@OGNL` binds the result of a OGNL expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@PHP` binds the result of a PHP expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@Python` binds the result of a Python expression to the parameter. The expression
    is defined in the annotation. The request keyword corresponds to the `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@Ruby` binds the result of a Ruby expression to the parameter. The expression
    is defined in the annotation. The request Ruby variable corresponds to the `in`
    message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@Simple` binds the result of a simple expression to the parameter. The expression
    is defined in the annotation. Simple is a Camel language allowing you to define
    simple expressions directly using the Camel objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@XPath` binds the result of a XPath expression to the parameter. The expression
    is defined in the annotation. It''s very convenient to extract part of an XML
    `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@XQuery` binds the result of a XQuery expression to the parameter. The expression
    is defined in the annotation. Like XPath, it''s very convenient to extract part
    of a XML `in` message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, it's possible to combine the different annotations with multiple
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Camel gives you great flexibility, irrespective of the language that you already
    know, you can use it in the expressions and predicates definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example – creating an OSGi bundle with a bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We illustrate the use of beans in a simple example. This example will create
    an OSGi bundle containing a bean called by a Camel route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a bean used in two parts of a route:'
  prefs: []
  type: TYPE_NORMAL
- en: One that directly uses the Camel bean component to change the body of the in
    message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another to define a header in the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we create the Maven project `pom.xml` for our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This `pom.xml` is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines the Camel core dependency in order to get the bean annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the Maven bundle plugin to package the bean and the route as an OSGi
    bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MyBean class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create the `MyBean` class containing two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `doMyLogic()` method is annotated as `@Handler` as described previously.
    It's the one that will be used by the Camel Bean component. This method has a
    unique parameter `body` of the `String` type. Thanks to the `@Body` annotation,
    this parameter will be populated by Camel with the body of the in message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setMyHeader()` method just returns `String`. This method will be used by
    Camel to populate a header of the in message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code of `MyBean` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can note that the doMyLogic() method defines the bean as a message translator:
    it transforms the body of the in message in another message body. It looks like
    the `PrefixerProcessor` used in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a route definition using the Camel Blueprint DSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use Blueprint DSL to write the definition of the route. Thanks
    to this, we don't have to provide all the plumbing code to create the `CamelContext`
    and reference it as an OSGi service.
  prefs: []
  type: TYPE_NORMAL
- en: The `CamelContext` is implicitly created by Camel, and we describe the route
    directly using XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OSGI-INF/blueprint` folder of our bundle, we create the following `route.xml`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare our bean in the Blueprint container. It means that the Blueprint
    container will use our class to create an instance of this bean and give it an
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Blueprint DSL, Camel uses a Blueprint container registry; this
    means that Camel will lookup the beans using the ID in the Blueprint container.
  prefs: []
  type: TYPE_NORMAL
- en: Using Camel, DSL would use exactly the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<route/>` element defines the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: The route starts with a timer that creates an empty exchange every 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a static content Hello Chapter4 for the body of the `in` message using
    `<setBody/>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exchange is sent to our bean. We use the Camel Bean component to directly
    call `myBean`. Camel will look for a bean named myBean in the Blueprint container.
    Once found, it will use the `doMyLogic()` method as it's the one with the `@Handler`
    annotation. Camel will bind the body of the in message with the `doMyLogic()`
    body parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the bean processor, we can see another use of the bean. This time, we
    use the bean (the same instance) to define the `myHeaderSetByTheBean` header of
    the in message. Here we use the `<method/>` syntax providing the `myBean` bean
    ID and the `setMyHeader()` method. Camel will look for the bean with the `myBean`
    ID in the Blueprint container, and it will call the `setMyHeader()` method. The
    return value of this method will be used to populate the `myHeaderSetByTheBean`
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we send the exchange to a log endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to build our bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Maven, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is now available in our local Maven repository (by default in the
    `.m2/repository` folder of the home directory).
  prefs: []
  type: TYPE_NORMAL
- en: We can deploy this bundle in a Karaf OSGi container.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having started Karaf (with `bin/karaf` script for instance), we add the
    Camel features using the `feature:repo-add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We install the camel-blueprint feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install our bundle and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our routes are running, since we can see the log messages (using
    the `log:display` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our route using the `camel:route-list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `camel:route-info` command gives details about our route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the bean support, it's possible to easily use an existing code in
    Camel routes.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, with the wide range of annotations and the supported languages, you
    have complete control over the usage of your beans.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DSL used to write the route definition, Camel knows on which system
    it's running, and so, it loads different bean registry implementations, making
    it possible to define the bean in a standard way.
  prefs: []
  type: TYPE_NORMAL
- en: The Camel bean support is a great complement to the Camel processors.
  prefs: []
  type: TYPE_NORMAL
- en: If most of the EIPs that we will see in the next chapter are implemented using
    Camel processors, some EIPs can be implemented using a bean (such as MessageTranslator
    EIP).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use beans in Camel routes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we saw the different registries supported, where Camel looks for beans.
    Specifically, we saw the mapping between the Camel DSL used and the default registry
    loaded. We saw examples of different registries in action, including the composite
    registry. For this lookup, Camel acts as a service activator. The example showed
    how to leverage the Spring or Blueprint service registry.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw the usage of the annotations to qualify the method and arguments
    binding. Those annotations can be combined with language annotations, allowing
    a very powerful way to populate method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see one of the Camel key features—routing and Enterprise
    Integration Patterns support. We will see ready-to-use processors and DSL implementing
    different EIPs.
  prefs: []
  type: TYPE_NORMAL
