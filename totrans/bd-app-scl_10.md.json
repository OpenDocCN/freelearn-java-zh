["```java\n    package reports  \n    object ReportBuilder {  \n      private var reportCache:scala.collection.Map[String,Boolean] = \n      new scala.collection.mutable.HashMap[String,Boolean].empty  \n      def generateCompileFileName(jrxml:String): String = \n      \"/tmp/report_\" + jrxml + \"_.jasper\"  \n      def compile(jrxml:String){ \n        if(reportCache.get(jrxml).getOrElse(true)){ \n          val design:JasperDesign = JRXmlLoader.load( \n            Play.resourceAsStream(\"/public/reports/\" + jrxml)\n          (Play.current).get ) \n          JasperCompileManager.compileReportToFile(design, \n          generateCompileFileName(jrxml)) \n          reportCache += (jrxml -> false) \n        } \n      }  \n      def toPdf(jrxml:String):ByteArrayInputStream = { \n        try { \n          val os:OutputStream = new ByteArrayOutputStream() \n          val reportParams:java.util.Map[String,Object] = \n          new java.util.HashMap() \n          val con:Connection =     \n          DriverManager.getConnection(\"jdbc:mysql://localhost/RWS_DB?\n            user=root&password=&useUnicode=\n            true&useJDBCCompliantTimezoneShift=\n            true&useLegacyDatetimeCode=false&serverTimezone=UTC\") \n          compile(jrxml) \n          val jrprint:JasperPrint = \n          JasperFillManager.fillReport(generateCompileFileName(jrxml),     \n          reportParams, con) \n          val exporter:JRPdfExporter = new JRPdfExporter() \n          exporter.setExporterInput(new SimpleExporterInput(jrprint)); \n          exporter.setExporterOutput(\n          new SimpleOutputStreamExporterOutput(os)); \n          exporter.exportReport() \n          new ByteArrayInputStream\n          ((os.asInstanceOf[ByteArrayOutputStream]).toByteArray()) \n        }catch { \n          case e:Exception => throw new RuntimeException(e) \n          null \n        }\n      }\n    } \n\n```", "```java\n$ activator universal:packageZipTarball\n\n```", "```java\nplay.crypto.secret = \"changeme\" \n\n```"]